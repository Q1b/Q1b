var bQ = Object.defineProperty;
var WA = (t) => {
	throw TypeError(t);
};
var vQ = (t, e, n) =>
	e in t
		? bQ(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n })
		: (t[e] = n);
var Fe = (t, e, n) => vQ(t, typeof e != "symbol" ? e + "" : e, n),
	h4 = (t, e, n) => e.has(t) || WA("Cannot " + n);
var z = (t, e, n) => (
		h4(t, e, "read from private field"), n ? n.call(t) : e.get(t)
	),
	qe = (t, e, n) =>
		e.has(t)
			? WA("Cannot add the same private member more than once")
			: e instanceof WeakSet
				? e.add(t)
				: e.set(t, n),
	Te = (t, e, n, r) => (
		h4(t, e, "write to private field"), r ? r.call(t, n) : e.set(t, n), n
	),
	Ne = (t, e, n) => (h4(t, e, "access private method"), n);
var o1 = (t, e, n, r) => ({
	set _(i) {
		Te(t, e, i, n);
	},
	get _() {
		return z(t, e, r);
	},
});
import {
	r as E,
	R as le,
	d as ix,
	j as m,
	a as nl,
	b as J8,
	g as Dl,
	e as hu,
	f as yQ,
} from "./index-DFWxKLZT.js";
import { p as ju, f as _m, s as Ep, a as Ue } from "./index-1h9o7eJh.js";
const qA = Symbol.for("react.memo_cache_sentinel");
function ee(t) {
	return E.useState(() => {
		const e = new Array(t);
		for (let n = 0; n < t; n++) e[n] = qA;
		return (e[qA] = !0), e;
	})[0];
}
const GA = Symbol.for("react.memo_cache_sentinel");
function ce(t) {
	return E.useState(() => {
		const e = new Array(t);
		for (let n = 0; n < t; n++) e[n] = GA;
		return (e[GA] = !0), e;
	})[0];
}
const at = typeof document < "u" ? le.useLayoutEffect : () => {};
function Pt(t) {
	const e = E.useRef(null);
	return (
		at(() => {
			e.current = t;
		}, [t]),
		E.useCallback((...n) => {
			const r = e.current;
			return r == null ? void 0 : r(...n);
		}, [])
	);
}
function ox(t) {
	let [e, n] = E.useState(t),
		r = E.useRef(null),
		i = Pt(() => {
			if (!r.current) return;
			let s = r.current.next();
			if (s.done) {
				r.current = null;
				return;
			}
			e === s.value ? i() : n(s.value);
		});
	at(() => {
		r.current && i();
	});
	let o = Pt((s) => {
		(r.current = s(e)), i();
	});
	return [e, o];
}
const Qb = { prefix: String(Math.round(Math.random() * 1e10)), current: 0 },
	X8 = le.createContext(Qb),
	xQ = le.createContext(!1);
let kQ = !!(
		typeof window < "u" &&
		window.document &&
		window.document.createElement
	),
	p4 = new WeakMap();
function CQ(t = !1) {
	let e = E.useContext(X8),
		n = E.useRef(null);
	if (n.current === null && !t) {
		var r, i;
		let o =
			(i = le.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED) ===
				null ||
			i === void 0 ||
			(r = i.ReactCurrentOwner) === null ||
			r === void 0
				? void 0
				: r.current;
		if (o) {
			let s = p4.get(o);
			s == null
				? p4.set(o, { id: e.current, state: o.memoizedState })
				: o.memoizedState !== s.state &&
					((e.current = s.id), p4.delete(o));
		}
		n.current = ++e.current;
	}
	return n.current;
}
function wQ(t) {
	let e = E.useContext(X8);
	e === Qb &&
		!kQ &&
		console.warn(
			"When server rendering, you must wrap your application in an <SSRProvider> to ensure consistent ids are generated between the client and server.",
		);
	let n = CQ(!!t),
		r = `react-aria${e.prefix}`;
	return t || `${r}-${n}`;
}
function EQ(t) {
	let e = le.useId(),
		[n] = E.useState(Vd()),
		r = n ? "react-aria" : `react-aria${Qb.prefix}`;
	return t || `${r}-${e}`;
}
const DQ = typeof le.useId == "function" ? EQ : wQ;
function SQ() {
	return !1;
}
function AQ() {
	return !0;
}
function $Q(t) {
	return () => {};
}
function Vd() {
	return typeof le.useSyncExternalStore == "function"
		? le.useSyncExternalStore($Q, SQ, AQ)
		: E.useContext(xQ);
}
let TQ = !!(
		typeof window < "u" &&
		window.document &&
		window.document.createElement
	),
	ev = new Map();
function Ot(t) {
	let [e, n] = E.useState(t),
		r = E.useRef(null),
		i = DQ(e),
		o = E.useCallback((s) => {
			r.current = s;
		}, []);
	return (
		TQ && ev.set(i, o),
		at(() => {
			let s = i;
			return () => {
				ev.delete(s);
			};
		}, [i]),
		E.useEffect(() => {
			let s = r.current;
			s && ((r.current = null), n(s));
		}),
		i
	);
}
function BQ(t, e) {
	if (t === e) return t;
	let n = ev.get(t);
	if (n) return n(e), e;
	let r = ev.get(e);
	return r ? (r(t), t) : e;
}
function Lo(t = []) {
	let e = Ot(),
		[n, r] = ox(e),
		i = E.useCallback(() => {
			r(function* () {
				yield e, yield document.getElementById(e) ? e : void 0;
			});
		}, [e, r]);
	return at(i, [e, i, ...t]), n;
}
function hr(...t) {
	return (...e) => {
		for (let n of t) typeof n == "function" && n(...e);
	};
}
const Yt = (t) => {
		var e;
		return (e = t == null ? void 0 : t.ownerDocument) !== null &&
			e !== void 0
			? e
			: document;
	},
	jo = (t) =>
		t && "window" in t && t.window === t ? t : Yt(t).defaultView || window;
function Z8(t) {
	var e,
		n,
		r = "";
	if (typeof t == "string" || typeof t == "number") r += t;
	else if (typeof t == "object")
		if (Array.isArray(t)) {
			var i = t.length;
			for (e = 0; e < i; e++)
				t[e] && (n = Z8(t[e])) && (r && (r += " "), (r += n));
		} else for (n in t) t[n] && (r && (r += " "), (r += n));
	return r;
}
function Q8() {
	for (var t, e, n = 0, r = "", i = arguments.length; n < i; n++)
		(t = arguments[n]) && (e = Z8(t)) && (r && (r += " "), (r += e));
	return r;
}
function xe(...t) {
	let e = { ...t[0] };
	for (let n = 1; n < t.length; n++) {
		let r = t[n];
		for (let i in r) {
			let o = e[i],
				s = r[i];
			typeof o == "function" &&
			typeof s == "function" &&
			i[0] === "o" &&
			i[1] === "n" &&
			i.charCodeAt(2) >= 65 &&
			i.charCodeAt(2) <= 90
				? (e[i] = hr(o, s))
				: (i === "className" || i === "UNSAFE_className") &&
					  typeof o == "string" &&
					  typeof s == "string"
					? (e[i] = Q8(o, s))
					: i === "id" && o && s
						? (e.id = BQ(o, s))
						: (e[i] = s !== void 0 ? s : o);
		}
	}
	return e;
}
function IQ(...t) {
	return t.length === 1 && t[0]
		? t[0]
		: (e) => {
				for (let n of t)
					typeof n == "function"
						? n(e)
						: n != null && (n.current = e);
			};
}
const FQ = new Set(["id"]),
	PQ = new Set([
		"aria-label",
		"aria-labelledby",
		"aria-describedby",
		"aria-details",
	]),
	NQ = new Set([
		"href",
		"hrefLang",
		"target",
		"rel",
		"download",
		"ping",
		"referrerPolicy",
	]),
	RQ = /^(data-.*)$/;
function Ge(t, e = {}) {
	let { labelable: n, isLink: r, propNames: i } = e,
		o = {};
	for (const s in t)
		Object.prototype.hasOwnProperty.call(t, s) &&
			(FQ.has(s) ||
				(n && PQ.has(s)) ||
				(r && NQ.has(s)) ||
				(i != null && i.has(s)) ||
				RQ.test(s)) &&
			(o[s] = t[s]);
	return o;
}
function io(t) {
	if (OQ()) t.focus({ preventScroll: !0 });
	else {
		let e = MQ(t);
		t.focus(), jQ(e);
	}
}
let s1 = null;
function OQ() {
	if (s1 == null) {
		s1 = !1;
		try {
			document.createElement("div").focus({
				get preventScroll() {
					return (s1 = !0), !0;
				},
			});
		} catch {}
	}
	return s1;
}
function MQ(t) {
	let e = t.parentNode,
		n = [],
		r = document.scrollingElement || document.documentElement;
	for (; e instanceof HTMLElement && e !== r; )
		(e.offsetHeight < e.scrollHeight || e.offsetWidth < e.scrollWidth) &&
			n.push({
				element: e,
				scrollTop: e.scrollTop,
				scrollLeft: e.scrollLeft,
			}),
			(e = e.parentNode);
	return (
		r instanceof HTMLElement &&
			n.push({
				element: r,
				scrollTop: r.scrollTop,
				scrollLeft: r.scrollLeft,
			}),
		n
	);
}
function jQ(t) {
	for (let { element: e, scrollTop: n, scrollLeft: r } of t)
		(e.scrollTop = n), (e.scrollLeft = r);
}
function sx(t) {
	var e;
	return typeof window > "u" || window.navigator == null
		? !1
		: ((e = window.navigator.userAgentData) === null || e === void 0
				? void 0
				: e.brands.some((n) => t.test(n.brand))) ||
				t.test(window.navigator.userAgent);
}
function qE(t) {
	var e;
	return typeof window < "u" && window.navigator != null
		? t.test(
				((e = window.navigator.userAgentData) === null || e === void 0
					? void 0
					: e.platform) || window.navigator.platform,
			)
		: !1;
}
function Sl(t) {
	let e = null;
	return () => (e == null && (e = t()), e);
}
const Ss = Sl(function () {
		return qE(/^Mac/i);
	}),
	e9 = Sl(function () {
		return qE(/^iPhone/i);
	}),
	GE = Sl(function () {
		return qE(/^iPad/i) || (Ss() && navigator.maxTouchPoints > 1);
	}),
	Vh = Sl(function () {
		return e9() || GE();
	}),
	tb = Sl(function () {
		return Ss() || Vh();
	}),
	ax = Sl(function () {
		return sx(/AppleWebKit/i) && !_Q();
	}),
	_Q = Sl(function () {
		return sx(/Chrome/i);
	}),
	zm = Sl(function () {
		return sx(/Android/i);
	}),
	zQ = Sl(function () {
		return sx(/Firefox/i);
	}),
	t9 = E.createContext({ isNative: !0, open: VQ, useHref: (t) => t });
function LQ(t) {
	let { children: e, navigate: n, useHref: r } = t,
		i = E.useMemo(
			() => ({
				isNative: !1,
				open: (o, s, a, l) => {
					r9(o, (u) => {
						n9(u, s) ? n(a, l) : _u(u, s);
					});
				},
				useHref: r || ((o) => o),
			}),
			[n, r],
		);
	return le.createElement(t9.Provider, { value: i }, e);
}
function Kd() {
	return E.useContext(t9);
}
function n9(t, e) {
	let n = t.getAttribute("target");
	return (
		(!n || n === "_self") &&
		t.origin === location.origin &&
		!t.hasAttribute("download") &&
		!e.metaKey &&
		!e.ctrlKey &&
		!e.altKey &&
		!e.shiftKey
	);
}
function _u(t, e, n = !0) {
	var r, i;
	let { metaKey: o, ctrlKey: s, altKey: a, shiftKey: l } = e;
	zQ() &&
		!(
			(i = window.event) === null ||
			i === void 0 ||
			(r = i.type) === null ||
			r === void 0
		) &&
		r.startsWith("key") &&
		t.target === "_blank" &&
		(Ss() ? (o = !0) : (s = !0));
	let u =
		ax() && Ss() && !GE()
			? new KeyboardEvent("keydown", {
					keyIdentifier: "Enter",
					metaKey: o,
					ctrlKey: s,
					altKey: a,
					shiftKey: l,
				})
			: new MouseEvent("click", {
					metaKey: o,
					ctrlKey: s,
					altKey: a,
					shiftKey: l,
					bubbles: !0,
					cancelable: !0,
				});
	(_u.isOpening = n), io(t), t.dispatchEvent(u), (_u.isOpening = !1);
}
_u.isOpening = !1;
function r9(t, e) {
	if (t instanceof HTMLAnchorElement) e(t);
	else if (t.hasAttribute("data-href")) {
		let n = document.createElement("a");
		(n.href = t.getAttribute("data-href")),
			t.hasAttribute("data-target") &&
				(n.target = t.getAttribute("data-target")),
			t.hasAttribute("data-rel") && (n.rel = t.getAttribute("data-rel")),
			t.hasAttribute("data-download") &&
				(n.download = t.getAttribute("data-download")),
			t.hasAttribute("data-ping") &&
				(n.ping = t.getAttribute("data-ping")),
			t.hasAttribute("data-referrer-policy") &&
				(n.referrerPolicy = t.getAttribute("data-referrer-policy")),
			t.appendChild(n),
			e(n),
			t.removeChild(n);
	}
}
function VQ(t, e) {
	r9(t, (n) => _u(n, e));
}
function i9(t) {
	let e = Kd();
	return {
		"data-href": t.href ? e.useHref(t.href) : void 0,
		"data-target": t.target,
		"data-rel": t.rel,
		"data-download": t.download,
		"data-ping": t.ping,
		"data-referrer-policy": t.referrerPolicy,
	};
}
function YE(t) {
	let e = Kd();
	return {
		href:
			t != null && t.href
				? e.useHref(t == null ? void 0 : t.href)
				: void 0,
		target: t == null ? void 0 : t.target,
		rel: t == null ? void 0 : t.rel,
		download: t == null ? void 0 : t.download,
		ping: t == null ? void 0 : t.ping,
		referrerPolicy: t == null ? void 0 : t.referrerPolicy,
	};
}
let Df = new Map(),
	YC = new Set();
function YA() {
	if (typeof window > "u") return;
	function t(r) {
		return "propertyName" in r;
	}
	let e = (r) => {
			if (!t(r) || !r.target) return;
			let i = Df.get(r.target);
			i ||
				((i = new Set()),
				Df.set(r.target, i),
				r.target.addEventListener("transitioncancel", n, { once: !0 })),
				i.add(r.propertyName);
		},
		n = (r) => {
			if (!t(r) || !r.target) return;
			let i = Df.get(r.target);
			if (
				i &&
				(i.delete(r.propertyName),
				i.size === 0 &&
					(r.target.removeEventListener("transitioncancel", n),
					Df.delete(r.target)),
				Df.size === 0)
			) {
				for (let o of YC) o();
				YC.clear();
			}
		};
	document.body.addEventListener("transitionrun", e),
		document.body.addEventListener("transitionend", n);
}
typeof document < "u" &&
	(document.readyState !== "loading"
		? YA()
		: document.addEventListener("DOMContentLoaded", YA));
function o9(t) {
	requestAnimationFrame(() => {
		Df.size === 0 ? t() : YC.add(t);
	});
}
function i0() {
	let t = E.useRef(new Map()),
		e = E.useCallback((i, o, s, a) => {
			let l =
				a != null && a.once
					? (...u) => {
							t.current.delete(s), s(...u);
						}
					: s;
			t.current.set(s, { type: o, eventTarget: i, fn: l, options: a }),
				i.addEventListener(o, s, a);
		}, []),
		n = E.useCallback((i, o, s, a) => {
			var l;
			let u =
				((l = t.current.get(s)) === null || l === void 0
					? void 0
					: l.fn) || s;
			i.removeEventListener(o, u, a), t.current.delete(s);
		}, []),
		r = E.useCallback(() => {
			t.current.forEach((i, o) => {
				n(i.eventTarget, i.type, o, i.options);
			});
		}, [n]);
	return (
		E.useEffect(() => r, [r]),
		{
			addGlobalListener: e,
			removeGlobalListener: n,
			removeAllGlobalListeners: r,
		}
	);
}
function tv(t, e) {
	let { id: n, "aria-label": r, "aria-labelledby": i } = t;
	return (
		(n = Ot(n)),
		i && r
			? (i = [...new Set([n, ...i.trim().split(/\s+/)])].join(" "))
			: i && (i = i.trim().split(/\s+/).join(" ")),
		!r && !i && e && (r = e),
		{ id: n, "aria-label": r, "aria-labelledby": i }
	);
}
function Ct(t) {
	const e = E.useRef(null);
	return E.useMemo(
		() => ({
			get current() {
				return e.current;
			},
			set current(n) {
				(e.current = n),
					typeof t == "function" ? t(n) : t && (t.current = n);
			},
		}),
		[t],
	);
}
function o0(t, e) {
	const n = E.useRef(!0),
		r = E.useRef(null);
	E.useEffect(
		() => (
			(n.current = !0),
			() => {
				n.current = !1;
			}
		),
		[],
	),
		E.useEffect(() => {
			n.current
				? (n.current = !1)
				: (!r.current || e.some((i, o) => !Object.is(i, r[o]))) && t(),
				(r.current = e);
		}, e);
}
function KQ() {
	return typeof window.ResizeObserver < "u";
}
function fa(t) {
	const { ref: e, box: n, onResize: r } = t;
	E.useEffect(() => {
		let i = e == null ? void 0 : e.current;
		if (i)
			if (KQ()) {
				const o = new window.ResizeObserver((s) => {
					s.length && r();
				});
				return (
					o.observe(i, { box: n }),
					() => {
						i && o.unobserve(i);
					}
				);
			} else
				return (
					window.addEventListener("resize", r, !1),
					() => {
						window.removeEventListener("resize", r, !1);
					}
				);
	}, [r, e, n]);
}
function lx(t, e) {
	at(() => {
		if (t && t.ref && e)
			return (
				(t.ref.current = e.current),
				() => {
					t.ref && (t.ref.current = null);
				}
			);
	});
}
function bh(t, e) {
	let n = window.getComputedStyle(t),
		r = /(auto|scroll)/.test(n.overflow + n.overflowX + n.overflowY);
	return (
		r &&
			e &&
			(r =
				t.scrollHeight !== t.clientHeight ||
				t.scrollWidth !== t.clientWidth),
		r
	);
}
function li(t, e) {
	let n = t;
	for (bh(n, e) && (n = n.parentElement); n && !bh(n, e); )
		n = n.parentElement;
	return n || document.scrollingElement || document.documentElement;
}
function UQ(t, e) {
	const n = [];
	for (; t && t !== document.documentElement; )
		bh(t, e) && n.push(t), (t = t.parentElement);
	return n;
}
let Ao = typeof document < "u" && window.visualViewport;
function s9() {
	let t = Vd(),
		[e, n] = E.useState(() => (t ? { width: 0, height: 0 } : JA()));
	return (
		E.useEffect(() => {
			let r = () => {
				n((i) => {
					let o = JA();
					return o.width === i.width && o.height === i.height ? i : o;
				});
			};
			return (
				Ao
					? Ao.addEventListener("resize", r)
					: window.addEventListener("resize", r),
				() => {
					Ao
						? Ao.removeEventListener("resize", r)
						: window.removeEventListener("resize", r);
				}
			);
		}, []),
		e
	);
}
function JA() {
	return {
		width: (Ao && (Ao == null ? void 0 : Ao.width)) || window.innerWidth,
		height: (Ao && (Ao == null ? void 0 : Ao.height)) || window.innerHeight,
	};
}
let HQ = 0;
const m4 = new Map();
function tc(t) {
	let [e, n] = E.useState();
	return (
		at(() => {
			if (!t) return;
			let r = m4.get(t);
			if (r) n(r.element.id);
			else {
				let i = `react-aria-description-${HQ++}`;
				n(i);
				let o = document.createElement("div");
				(o.id = i),
					(o.style.display = "none"),
					(o.textContent = t),
					document.body.appendChild(o),
					(r = { refCount: 0, element: o }),
					m4.set(t, r);
			}
			return (
				r.refCount++,
				() => {
					r &&
						--r.refCount === 0 &&
						(r.element.remove(), m4.delete(t));
				}
			);
		}, [t]),
		{ "aria-describedby": t ? e : void 0 }
	);
}
function Lm(t, e, n, r) {
	let i = Pt(n),
		o = n == null;
	E.useEffect(() => {
		if (o || !t.current) return;
		let s = t.current;
		return (
			s.addEventListener(e, i, r),
			() => {
				s.removeEventListener(e, i, r);
			}
		);
	}, [t, e, r, o, i]);
}
function JE(t, e) {
	let n = XA(t, e, "left"),
		r = XA(t, e, "top"),
		i = e.offsetWidth,
		o = e.offsetHeight,
		s = t.scrollLeft,
		a = t.scrollTop,
		{ borderTopWidth: l, borderLeftWidth: u } = getComputedStyle(t),
		c = t.scrollLeft + parseInt(u, 10),
		d = t.scrollTop + parseInt(l, 10),
		f = c + t.clientWidth,
		h = d + t.clientHeight;
	n <= s ? (s = n - parseInt(u, 10)) : n + i > f && (s += n + i - f),
		r <= d ? (a = r - parseInt(l, 10)) : r + o > h && (a += r + o - h),
		(t.scrollLeft = s),
		(t.scrollTop = a);
}
function XA(t, e, n) {
	const r = n === "left" ? "offsetLeft" : "offsetTop";
	let i = 0;
	for (; e.offsetParent && ((i += e[r]), e.offsetParent !== t); ) {
		if (e.offsetParent.contains(t)) {
			i -= t[r];
			break;
		}
		e = e.offsetParent;
	}
	return i;
}
function ui(t, e) {
	if (document.contains(t)) {
		let s = document.scrollingElement || document.documentElement;
		if (window.getComputedStyle(s).overflow === "hidden") {
			let l = UQ(t);
			for (let u of l) JE(u, t);
		} else {
			var n;
			let { left: l, top: u } = t.getBoundingClientRect();
			t == null ||
				(n = t.scrollIntoView) === null ||
				n === void 0 ||
				n.call(t, { block: "nearest" });
			let { left: c, top: d } = t.getBoundingClientRect();
			if (Math.abs(l - c) > 1 || Math.abs(u - d) > 1) {
				var r, i, o;
				e == null ||
					(i = e.containingElement) === null ||
					i === void 0 ||
					(r = i.scrollIntoView) === null ||
					r === void 0 ||
					r.call(i, { block: "center", inline: "center" }),
					(o = t.scrollIntoView) === null ||
						o === void 0 ||
						o.call(t, { block: "nearest" });
			}
		}
	}
}
function Vm(t) {
	return t.mozInputSource === 0 && t.isTrusted
		? !0
		: zm() && t.pointerType
			? t.type === "click" && t.buttons === 1
			: t.detail === 0 && !t.pointerType;
}
function XE(t) {
	return (
		(!zm() && t.width === 0 && t.height === 0) ||
		(t.width === 1 &&
			t.height === 1 &&
			t.pressure === 0 &&
			t.detail === 0 &&
			t.pointerType === "mouse")
	);
}
function s0(t, e, n) {
	let r = E.useRef(e),
		i = Pt(() => {
			n && n(r.current);
		});
	E.useEffect(() => {
		var o;
		let s =
			t == null || (o = t.current) === null || o === void 0
				? void 0
				: o.form;
		return (
			s == null || s.addEventListener("reset", i),
			() => {
				s == null || s.removeEventListener("reset", i);
			}
		);
	}, [t, i]);
}
function a9(t, e) {
	let { isLoading: n, onLoadMore: r, scrollOffset: i = 1, items: o } = t,
		s = E.useRef(n),
		a = E.useRef(t),
		l = E.useCallback(() => {
			e.current &&
				!s.current &&
				r &&
				e.current.scrollHeight -
					e.current.scrollTop -
					e.current.clientHeight <
					e.current.clientHeight * i &&
				((s.current = !0), r());
		}, [r, e, i]),
		u = E.useRef(o);
	at(() => {
		t !== a.current && ((s.current = n), (a.current = t)),
			(e == null ? void 0 : e.current) &&
				!s.current &&
				r &&
				(!o || o !== u.current) &&
				e.current.clientHeight === e.current.scrollHeight &&
				((s.current = !0), r == null || r()),
			(u.current = o);
	}, [n, r, t, e]),
		Lm(e, "scroll", l);
}
function Ns(t, e, n) {
	let [r, i] = E.useState(t || e),
		o = E.useRef(t !== void 0),
		s = t !== void 0;
	E.useEffect(() => {
		let u = o.current;
		u !== s &&
			console.warn(
				`WARN: A component changed from ${u ? "controlled" : "uncontrolled"} to ${s ? "controlled" : "uncontrolled"}.`,
			),
			(o.current = s);
	}, [s]);
	let a = s ? t : r,
		l = E.useCallback(
			(u, ...c) => {
				let d = (f, ...h) => {
					n && (Object.is(a, f) || n(f, ...h)), s || (a = f);
				};
				typeof u == "function"
					? (console.warn(
							"We can not support a function callback. See Github Issues for details https://github.com/adobe/react-spectrum/issues/2320",
						),
						i((h, ...p) => {
							let g = u(s ? a : h, ...p);
							return d(g, ...c), s ? h : g;
						}))
					: (s || i(u), d(u, ...c));
			},
			[s, a, n],
		);
	return [a, l];
}
function rl(t, e = -1 / 0, n = 1 / 0) {
	return Math.min(Math.max(t, e), n);
}
function a1(t, e) {
	let n = t,
		r = e.toString(),
		i = r.indexOf("."),
		o = i >= 0 ? r.length - i : 0;
	if (o > 0) {
		let s = Math.pow(10, o);
		n = Math.round(n * s) / s;
	}
	return n;
}
function Ra(t, e, n, r) {
	(e = Number(e)), (n = Number(n));
	let i = (t - (isNaN(e) ? 0 : e)) % r,
		o = a1(
			Math.abs(i) * 2 >= r ? t + Math.sign(i) * (r - Math.abs(i)) : t - i,
			r,
		);
	return (
		isNaN(e)
			? !isNaN(n) && o > n && (o = Math.floor(a1(n / r, r)) * r)
			: o < e
				? (o = e)
				: !isNaN(n) &&
					o > n &&
					(o = e + Math.floor(a1((n - e) / r, r)) * r),
		(o = a1(o, r)),
		o
	);
}
const WQ = new Set([
		"Arab",
		"Syrc",
		"Samr",
		"Mand",
		"Thaa",
		"Mend",
		"Nkoo",
		"Adlm",
		"Rohg",
		"Hebr",
	]),
	qQ = new Set([
		"ae",
		"ar",
		"arc",
		"bcc",
		"bqi",
		"ckb",
		"dv",
		"fa",
		"glk",
		"he",
		"ku",
		"mzn",
		"nqo",
		"pnb",
		"ps",
		"sd",
		"ug",
		"ur",
		"yi",
	]);
function l9(t) {
	if (Intl.Locale) {
		let n = new Intl.Locale(t).maximize(),
			r =
				typeof n.getTextInfo == "function"
					? n.getTextInfo()
					: n.textInfo;
		if (r) return r.direction === "rtl";
		if (n.script) return WQ.has(n.script);
	}
	let e = t.split("-")[0];
	return qQ.has(e);
}
const GQ = Symbol.for("react-aria.i18n.locale");
function u9() {
	let t =
		(typeof window < "u" && window[GQ]) ||
		(typeof navigator < "u" &&
			(navigator.language || navigator.userLanguage)) ||
		"en-US";
	try {
		Intl.DateTimeFormat.supportedLocalesOf([t]);
	} catch {
		t = "en-US";
	}
	return { locale: t, direction: l9(t) ? "rtl" : "ltr" };
}
let JC = u9(),
	Wp = new Set();
function ZA() {
	JC = u9();
	for (let t of Wp) t(JC);
}
function c9() {
	let t = Vd(),
		[e, n] = E.useState(JC);
	return (
		E.useEffect(
			() => (
				Wp.size === 0 && window.addEventListener("languagechange", ZA),
				Wp.add(n),
				() => {
					Wp.delete(n),
						Wp.size === 0 &&
							window.removeEventListener("languagechange", ZA);
				}
			),
			[],
		),
		t ? { locale: "en-US", direction: "ltr" } : e
	);
}
const d9 = le.createContext(null);
function YQ(t) {
	let { locale: e, children: n } = t,
		r = c9(),
		i = le.useMemo(
			() => (e ? { locale: e, direction: l9(e) ? "rtl" : "ltr" } : r),
			[r, e],
		);
	return le.createElement(d9.Provider, { value: i }, n);
}
function Vt() {
	let t = c9();
	return E.useContext(d9) || t;
}
var nv = function () {
	return (
		(nv =
			Object.assign ||
			function (e) {
				for (var n, r = 1, i = arguments.length; r < i; r++) {
					n = arguments[r];
					for (var o in n)
						Object.prototype.hasOwnProperty.call(n, o) &&
							(e[o] = n[o]);
				}
				return e;
			}),
		nv.apply(this, arguments)
	);
};
const JQ = Symbol.for("react-aria.i18n.locale"),
	XQ = Symbol.for("react-aria.i18n.strings");
let uf;
class ux {
	getStringForLocale(e, n) {
		let i = this.getStringsForLocale(n)[e];
		if (!i)
			throw new Error(`Could not find intl message ${e} in ${n} locale`);
		return i;
	}
	getStringsForLocale(e) {
		let n = this.strings[e];
		return (
			n ||
				((n = ZQ(e, this.strings, this.defaultLocale)),
				(this.strings[e] = n)),
			n
		);
	}
	static getGlobalDictionaryForPackage(e) {
		if (typeof window > "u") return null;
		let n = window[JQ];
		if (uf === void 0) {
			let i = window[XQ];
			if (!i) return null;
			uf = {};
			for (let o in i) uf[o] = new ux({ [n]: i[o] }, n);
		}
		let r = uf == null ? void 0 : uf[e];
		if (!r)
			throw new Error(
				`Strings for package "${e}" were not included by LocalizedStringProvider. Please add it to the list passed to createLocalizedStringDictionary.`,
			);
		return r;
	}
	constructor(e, n = "en-US") {
		(this.strings = Object.fromEntries(
			Object.entries(e).filter(([, r]) => r),
		)),
			(this.defaultLocale = n);
	}
}
function ZQ(t, e, n = "en-US") {
	if (e[t]) return e[t];
	let r = QQ(t);
	if (e[r]) return e[r];
	for (let i in e) if (i.startsWith(r + "-")) return e[i];
	return e[n];
}
function QQ(t) {
	return Intl.Locale ? new Intl.Locale(t).language : t.split("-")[0];
}
const QA = new Map(),
	e6 = new Map();
class eee {
	format(e, n) {
		let r = this.strings.getStringForLocale(e, this.locale);
		return typeof r == "function" ? r(n, this) : r;
	}
	plural(e, n, r = "cardinal") {
		let i = n["=" + e];
		if (i) return typeof i == "function" ? i() : i;
		let o = this.locale + ":" + r,
			s = QA.get(o);
		s ||
			((s = new Intl.PluralRules(this.locale, { type: r })),
			QA.set(o, s));
		let a = s.select(e);
		return (i = n[a] || n.other), typeof i == "function" ? i() : i;
	}
	number(e) {
		let n = e6.get(this.locale);
		return (
			n ||
				((n = new Intl.NumberFormat(this.locale)),
				e6.set(this.locale, n)),
			n.format(e)
		);
	}
	select(e, n) {
		let r = e[n] || e.other;
		return typeof r == "function" ? r() : r;
	}
	constructor(e, n) {
		(this.locale = e), (this.strings = n);
	}
}
const t6 = new WeakMap();
function tee(t) {
	let e = t6.get(t);
	return e || ((e = new ux(t)), t6.set(t, e)), e;
}
function nee(t, e) {
	return (e && ux.getGlobalDictionaryForPackage(e)) || tee(t);
}
function Le(t, e) {
	let { locale: n } = Vt(),
		r = nee(t, e);
	return E.useMemo(() => new eee(n, r), [n, r]);
}
function ree(t, e) {
	if (e.has(t))
		throw new TypeError(
			"Cannot initialize the same private elements twice on an object",
		);
}
function iee(t, e, n) {
	ree(t, e), e.set(t, n);
}
let g4 = new Map(),
	XC = !1;
try {
	XC =
		new Intl.NumberFormat("de-DE", {
			signDisplay: "exceptZero",
		}).resolvedOptions().signDisplay === "exceptZero";
} catch {}
let rv = !1;
try {
	rv =
		new Intl.NumberFormat("de-DE", {
			style: "unit",
			unit: "degree",
		}).resolvedOptions().style === "unit";
} catch {}
const f9 = {
	degree: {
		narrow: { default: "°", "ja-JP": " 度", "zh-TW": "度", "sl-SI": " °" },
	},
};
class iv {
	format(e) {
		let n = "";
		if (
			(!XC && this.options.signDisplay != null
				? (n = see(this.numberFormatter, this.options.signDisplay, e))
				: (n = this.numberFormatter.format(e)),
			this.options.style === "unit" && !rv)
		) {
			var r;
			let {
				unit: i,
				unitDisplay: o = "short",
				locale: s,
			} = this.resolvedOptions();
			if (!i) return n;
			let a = (r = f9[i]) === null || r === void 0 ? void 0 : r[o];
			n += a[s] || a.default;
		}
		return n;
	}
	formatToParts(e) {
		return this.numberFormatter.formatToParts(e);
	}
	formatRange(e, n) {
		if (typeof this.numberFormatter.formatRange == "function")
			return this.numberFormatter.formatRange(e, n);
		if (n < e) throw new RangeError("End date must be >= start date");
		return `${this.format(e)} – ${this.format(n)}`;
	}
	formatRangeToParts(e, n) {
		if (typeof this.numberFormatter.formatRangeToParts == "function")
			return this.numberFormatter.formatRangeToParts(e, n);
		if (n < e) throw new RangeError("End date must be >= start date");
		let r = this.numberFormatter.formatToParts(e),
			i = this.numberFormatter.formatToParts(n);
		return [
			...r.map((o) => ({ ...o, source: "startRange" })),
			{ type: "literal", value: " – ", source: "shared" },
			...i.map((o) => ({ ...o, source: "endRange" })),
		];
	}
	resolvedOptions() {
		let e = this.numberFormatter.resolvedOptions();
		return (
			!XC &&
				this.options.signDisplay != null &&
				(e = { ...e, signDisplay: this.options.signDisplay }),
			!rv &&
				this.options.style === "unit" &&
				(e = {
					...e,
					style: "unit",
					unit: this.options.unit,
					unitDisplay: this.options.unitDisplay,
				}),
			e
		);
	}
	constructor(e, n = {}) {
		(this.numberFormatter = oee(e, n)), (this.options = n);
	}
}
function oee(t, e = {}) {
	let { numberingSystem: n } = e;
	if (
		(n &&
			t.includes("-nu-") &&
			(t.includes("-u-") || (t += "-u-"), (t += `-nu-${n}`)),
		e.style === "unit" && !rv)
	) {
		var r;
		let { unit: s, unitDisplay: a = "short" } = e;
		if (!s)
			throw new Error('unit option must be provided with style: "unit"');
		if (!(!((r = f9[s]) === null || r === void 0) && r[a]))
			throw new Error(`Unsupported unit ${s} with unitDisplay = ${a}`);
		e = { ...e, style: "decimal" };
	}
	let i =
		t +
		(e
			? Object.entries(e)
					.sort((s, a) => (s[0] < a[0] ? -1 : 1))
					.join()
			: "");
	if (g4.has(i)) return g4.get(i);
	let o = new Intl.NumberFormat(t, e);
	return g4.set(i, o), o;
}
function see(t, e, n) {
	if (e === "auto") return t.format(n);
	if (e === "never") return t.format(Math.abs(n));
	{
		let r = !1;
		if (
			(e === "always"
				? (r = n > 0 || Object.is(n, 0))
				: e === "exceptZero" &&
					(Object.is(n, -0) || Object.is(n, 0)
						? (n = Math.abs(n))
						: (r = n > 0)),
			r)
		) {
			let i = t.format(-n),
				o = t.format(n),
				s = i.replace(o, "").replace(/\u200e|\u061C/, "");
			return (
				[...s].length !== 1 &&
					console.warn(
						"@react-aria/i18n polyfill for NumberFormat signDisplay: Unsupported case",
					),
				i.replace(o, "!!!").replace(s, "+").replace("!!!", o)
			);
		} else return t.format(n);
	}
}
const aee = new RegExp("^.*\\(.*\\).*$"),
	lee = ["latn", "arab", "hanidec"];
class h9 {
	parse(e) {
		return b4(this.locale, this.options, e).parse(e);
	}
	isValidPartialNumber(e, n, r) {
		return b4(this.locale, this.options, e).isValidPartialNumber(e, n, r);
	}
	getNumberingSystem(e) {
		return b4(this.locale, this.options, e).options.numberingSystem;
	}
	constructor(e, n = {}) {
		(this.locale = e), (this.options = n);
	}
}
const n6 = new Map();
function b4(t, e, n) {
	let r = r6(t, e);
	if (!t.includes("-nu-") && !r.isValidPartialNumber(n)) {
		for (let i of lee)
			if (i !== r.options.numberingSystem) {
				let o = r6(t + (t.includes("-u-") ? "-nu-" : "-u-nu-") + i, e);
				if (o.isValidPartialNumber(n)) return o;
			}
	}
	return r;
}
function r6(t, e) {
	let n =
			t +
			(e
				? Object.entries(e)
						.sort((i, o) => (i[0] < o[0] ? -1 : 1))
						.join()
				: ""),
		r = n6.get(n);
	return r || ((r = new uee(t, e)), n6.set(n, r)), r;
}
class uee {
	parse(e) {
		let n = this.sanitize(e);
		if (
			(this.symbols.group && (n = l1(n, this.symbols.group, "")),
			this.symbols.decimal && (n = n.replace(this.symbols.decimal, ".")),
			this.symbols.minusSign &&
				(n = n.replace(this.symbols.minusSign, "-")),
			(n = n.replace(this.symbols.numeral, this.symbols.index)),
			this.options.style === "percent")
		) {
			let s = n.indexOf("-");
			n = n.replace("-", "");
			let a = n.indexOf(".");
			a === -1 && (a = n.length),
				(n = n.replace(".", "")),
				a - 2 === 0
					? (n = `0.${n}`)
					: a - 2 === -1
						? (n = `0.0${n}`)
						: a - 2 === -2
							? (n = "0.00")
							: (n = `${n.slice(0, a - 2)}.${n.slice(a - 2)}`),
				s > -1 && (n = `-${n}`);
		}
		let r = n ? +n : NaN;
		if (isNaN(r)) return NaN;
		if (this.options.style === "percent") {
			var i, o;
			let s = {
				...this.options,
				style: "decimal",
				minimumFractionDigits: Math.min(
					((i = this.options.minimumFractionDigits) !== null &&
					i !== void 0
						? i
						: 0) + 2,
					20,
				),
				maximumFractionDigits: Math.min(
					((o = this.options.maximumFractionDigits) !== null &&
					o !== void 0
						? o
						: 0) + 2,
					20,
				),
			};
			return new h9(this.locale, s).parse(
				new iv(this.locale, s).format(r),
			);
		}
		return (
			this.options.currencySign === "accounting" &&
				aee.test(e) &&
				(r = -1 * r),
			r
		);
	}
	sanitize(e) {
		return (
			(e = e.replace(this.symbols.literals, "")),
			this.symbols.minusSign &&
				(e = e.replace("-", this.symbols.minusSign)),
			this.options.numberingSystem === "arab" &&
				(this.symbols.decimal &&
					((e = e.replace(",", this.symbols.decimal)),
					(e = e.replace("،", this.symbols.decimal))),
				this.symbols.group && (e = l1(e, ".", this.symbols.group))),
			this.options.locale === "fr-FR" && (e = l1(e, ".", " ")),
			e
		);
	}
	isValidPartialNumber(e, n = -1 / 0, r = 1 / 0) {
		return (
			(e = this.sanitize(e)),
			this.symbols.minusSign &&
			e.startsWith(this.symbols.minusSign) &&
			n < 0
				? (e = e.slice(this.symbols.minusSign.length))
				: this.symbols.plusSign &&
					e.startsWith(this.symbols.plusSign) &&
					r > 0 &&
					(e = e.slice(this.symbols.plusSign.length)),
			(this.symbols.group && e.startsWith(this.symbols.group)) ||
			(this.symbols.decimal &&
				e.indexOf(this.symbols.decimal) > -1 &&
				this.options.maximumFractionDigits === 0)
				? !1
				: (this.symbols.group && (e = l1(e, this.symbols.group, "")),
					(e = e.replace(this.symbols.numeral, "")),
					this.symbols.decimal &&
						(e = e.replace(this.symbols.decimal, "")),
					e.length === 0)
		);
	}
	constructor(e, n = {}) {
		(this.locale = e),
			(this.formatter = new Intl.NumberFormat(e, n)),
			(this.options = this.formatter.resolvedOptions()),
			(this.symbols = dee(e, this.formatter, this.options, n));
		var r, i;
		this.options.style === "percent" &&
			(((r = this.options.minimumFractionDigits) !== null && r !== void 0
				? r
				: 0) > 18 ||
				((i = this.options.maximumFractionDigits) !== null &&
				i !== void 0
					? i
					: 0) > 18) &&
			console.warn(
				"NumberParser cannot handle percentages with greater than 18 decimal places, please reduce the number in your options.",
			);
	}
}
const i6 = new Set([
		"decimal",
		"fraction",
		"integer",
		"minusSign",
		"plusSign",
		"group",
	]),
	cee = [0, 4, 2, 1, 11, 20, 3, 7, 100, 21, 0.1, 1.1];
function dee(t, e, n, r) {
	var i, o, s, a;
	let l = new Intl.NumberFormat(t, {
			...n,
			minimumSignificantDigits: 1,
			maximumSignificantDigits: 21,
		}),
		u = l.formatToParts(-10000.111),
		c = l.formatToParts(10000.111),
		d = cee.map((A) => l.formatToParts(A));
	var f;
	let h =
			(f =
				(i = u.find((A) => A.type === "minusSign")) === null ||
				i === void 0
					? void 0
					: i.value) !== null && f !== void 0
				? f
				: "-",
		p =
			(o = c.find((A) => A.type === "plusSign")) === null || o === void 0
				? void 0
				: o.value;
	!p &&
		((r == null ? void 0 : r.signDisplay) === "exceptZero" ||
			(r == null ? void 0 : r.signDisplay) === "always") &&
		(p = "+");
	let v =
			(s = new Intl.NumberFormat(t, {
				...n,
				minimumFractionDigits: 2,
				maximumFractionDigits: 2,
			})
				.formatToParts(0.001)
				.find((A) => A.type === "decimal")) === null || s === void 0
				? void 0
				: s.value,
		b =
			(a = u.find((A) => A.type === "group")) === null || a === void 0
				? void 0
				: a.value,
		y = u.filter((A) => !i6.has(A.type)).map((A) => o6(A.value)),
		x = d.flatMap((A) =>
			A.filter((T) => !i6.has(T.type)).map((T) => o6(T.value)),
		),
		C = [...new Set([...y, ...x])].sort((A, T) => T.length - A.length),
		k =
			C.length === 0
				? new RegExp("[\\p{White_Space}]", "gu")
				: new RegExp(`${C.join("|")}|[\\p{White_Space}]`, "gu"),
		w = [
			...new Intl.NumberFormat(n.locale, { useGrouping: !1 }).format(
				9876543210,
			),
		].reverse(),
		D = new Map(w.map((A, T) => [A, T])),
		S = new RegExp(`[${w.join("")}]`, "g");
	return {
		minusSign: h,
		plusSign: p,
		decimal: v,
		group: b,
		literals: k,
		numeral: S,
		index: (A) => String(D.get(A)),
	};
}
function l1(t, e, n) {
	return t.replaceAll ? t.replaceAll(e, n) : t.split(e).join(n);
}
function o6(t) {
	return t.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function ZC(t = {}) {
	let { locale: e } = Vt();
	return E.useMemo(() => new iv(e, t), [e, t]);
}
let v4 = new Map();
function a0(t) {
	let { locale: e } = Vt(),
		n =
			e +
			(t
				? Object.entries(t)
						.sort((i, o) => (i[0] < o[0] ? -1 : 1))
						.join()
				: "");
	if (v4.has(n)) return v4.get(n);
	let r = new Intl.Collator(e, t);
	return v4.set(n, r), r;
}
function p9(t) {
	let e = a0({ usage: "search", ...t }),
		n = E.useCallback(
			(o, s) =>
				s.length === 0
					? !0
					: ((o = o.normalize("NFC")),
						(s = s.normalize("NFC")),
						e.compare(o.slice(0, s.length), s) === 0),
			[e],
		),
		r = E.useCallback(
			(o, s) =>
				s.length === 0
					? !0
					: ((o = o.normalize("NFC")),
						(s = s.normalize("NFC")),
						e.compare(o.slice(-s.length), s) === 0),
			[e],
		),
		i = E.useCallback(
			(o, s) => {
				if (s.length === 0) return !0;
				(o = o.normalize("NFC")), (s = s.normalize("NFC"));
				let a = 0,
					l = s.length;
				for (; a + l <= o.length; a++) {
					let u = o.slice(a, a + l);
					if (e.compare(s, u) === 0) return !0;
				}
				return !1;
			},
			[e],
		);
	return E.useMemo(
		() => ({ startsWith: n, endsWith: r, contains: i }),
		[n, r, i],
	);
}
const Zs = { top: "top", bottom: "top", left: "left", right: "left" },
	ov = { top: "bottom", bottom: "top", left: "right", right: "left" },
	fee = { top: "left", left: "top" },
	QC = { top: "height", left: "width" },
	m9 = { width: "totalWidth", height: "totalHeight" },
	u1 = {};
let Ci = typeof document < "u" && window.visualViewport;
function s6(t) {
	let e = 0,
		n = 0,
		r = 0,
		i = 0,
		o = 0,
		s = 0,
		a = {},
		l = (Ci == null ? void 0 : Ci.scale) > 1;
	if (t.tagName === "BODY") {
		let d = document.documentElement;
		(r = d.clientWidth), (i = d.clientHeight);
		var u;
		e =
			(u = Ci == null ? void 0 : Ci.width) !== null && u !== void 0
				? u
				: r;
		var c;
		(n =
			(c = Ci == null ? void 0 : Ci.height) !== null && c !== void 0
				? c
				: i),
			(a.top = d.scrollTop || t.scrollTop),
			(a.left = d.scrollLeft || t.scrollLeft),
			Ci && ((o = Ci.offsetTop), (s = Ci.offsetLeft));
	} else
		({ width: e, height: n, top: o, left: s } = Qf(t)),
			(a.top = t.scrollTop),
			(a.left = t.scrollLeft),
			(r = e),
			(i = n);
	return (
		ax() &&
			(t.tagName === "BODY" || t.tagName === "HTML") &&
			l &&
			((a.top = 0), (a.left = 0), (o = Ci.pageTop), (s = Ci.pageLeft)),
		{
			width: e,
			height: n,
			totalWidth: r,
			totalHeight: i,
			scroll: a,
			top: o,
			left: s,
		}
	);
}
function hee(t) {
	return {
		top: t.scrollTop,
		left: t.scrollLeft,
		width: t.scrollWidth,
		height: t.scrollHeight,
	};
}
function a6(t, e, n, r, i, o, s) {
	let a = i.scroll[t],
		l = r[QC[t]],
		u = r.scroll[Zs[t]] + o,
		c = l + r.scroll[Zs[t]] - o,
		d = e - a + s[t] - r[Zs[t]],
		f = e - a + n + s[t] - r[Zs[t]];
	return d < u ? u - d : f > c ? Math.max(c - f, u - d) : 0;
}
function pee(t) {
	let e = window.getComputedStyle(t);
	return {
		top: parseInt(e.marginTop, 10) || 0,
		bottom: parseInt(e.marginBottom, 10) || 0,
		left: parseInt(e.marginLeft, 10) || 0,
		right: parseInt(e.marginRight, 10) || 0,
	};
}
function l6(t) {
	if (u1[t]) return u1[t];
	let [e, n] = t.split(" "),
		r = Zs[e] || "right",
		i = fee[r];
	Zs[n] || (n = "center");
	let o = QC[r],
		s = QC[i];
	return (
		(u1[t] = {
			placement: e,
			crossPlacement: n,
			axis: r,
			crossAxis: i,
			size: o,
			crossSize: s,
		}),
		u1[t]
	);
}
function y4(t, e, n, r, i, o, s, a, l, u) {
	let {
			placement: c,
			crossPlacement: d,
			axis: f,
			crossAxis: h,
			size: p,
			crossSize: g,
		} = r,
		v = {};
	(v[h] = t[h]),
		d === "center"
			? (v[h] += (t[g] - n[g]) / 2)
			: d !== h && (v[h] += t[g] - n[g]),
		(v[h] += o);
	const b = t[h] - n[g] + l + u,
		y = t[h] + t[g] - l - u;
	if (((v[h] = rl(v[h], b, y)), c === f)) {
		const x = a ? s[p] : e[m9[p]];
		v[ov[f]] = Math.floor(x - t[f] + i);
	} else v[f] = Math.floor(t[f] + t[p] + i);
	return v;
}
function mee(t, e, n, r, i, o, s, a) {
	const l = r ? n.height : e[m9.height];
	let u = t.top != null ? n.top + t.top : n.top + (l - t.bottom - s),
		c =
			a !== "top"
				? Math.max(
						0,
						e.height +
							e.top +
							e.scroll.top -
							u -
							(i.top + i.bottom + o),
					)
				: Math.max(
						0,
						u + s - (e.top + e.scroll.top) - (i.top + i.bottom + o),
					);
	return Math.min(e.height - o * 2, c);
}
function u6(t, e, n, r, i, o) {
	let { placement: s, axis: a, size: l } = o;
	return s === a
		? Math.max(0, n[a] - t[a] - t.scroll[a] + e[a] - r[a] - r[ov[a]] - i)
		: Math.max(
				0,
				t[l] +
					t[a] +
					t.scroll[a] -
					e[a] -
					n[a] -
					n[l] -
					r[a] -
					r[ov[a]] -
					i,
			);
}
function gee(t, e, n, r, i, o, s, a, l, u, c, d, f, h, p, g) {
	let v = l6(t),
		{
			size: b,
			crossAxis: y,
			crossSize: x,
			placement: C,
			crossPlacement: k,
		} = v,
		w = y4(e, a, n, v, c, d, u, f, p, g),
		D = c,
		S = u6(a, u, e, i, o + c, v);
	if (s && r[b] > S) {
		let M = l6(`${ov[C]} ${k}`),
			G = y4(e, a, n, M, c, d, u, f, p, g);
		u6(a, u, e, i, o + c, M) > S && ((v = M), (w = G), (D = c));
	}
	let $ = "bottom";
	v.axis === "top"
		? v.placement === "top"
			? ($ = "top")
			: v.placement === "bottom" && ($ = "bottom")
		: v.crossAxis === "top" &&
			(v.crossPlacement === "top"
				? ($ = "bottom")
				: v.crossPlacement === "bottom" && ($ = "top"));
	let A = a6(y, w[y], n[x], a, l, o, u);
	w[y] += A;
	let T = mee(w, a, u, f, i, o, n.height, $);
	h && h < T && (T = h),
		(n.height = Math.min(n.height, T)),
		(w = y4(e, a, n, v, D, d, u, f, p, g)),
		(A = a6(y, w[y], n[x], a, l, o, u)),
		(w[y] += A);
	let I = {},
		F = e[y] + 0.5 * e[x] - w[y] - i[Zs[y]];
	const N = p / 2 + g,
		O = Zs[y] === "left" ? i.left + i.right : i.top + i.bottom,
		_ = n[x] - O - p / 2 - g,
		j = e[y] + p / 2 - (w[y] + i[Zs[y]]),
		V = e[y] + e[x] - p / 2 - (w[y] + i[Zs[y]]),
		K = rl(F, j, V);
	return (
		(I[y] = rl(K, N, _)),
		{
			position: w,
			maxHeight: T,
			arrowOffsetLeft: I.left,
			arrowOffsetTop: I.top,
			placement: v.placement,
		}
	);
}
function bee(t) {
	let {
			placement: e,
			targetNode: n,
			overlayNode: r,
			scrollNode: i,
			padding: o,
			shouldFlip: s,
			boundaryElement: a,
			offset: l,
			crossOffset: u,
			maxHeight: c,
			arrowSize: d = 0,
			arrowBoundaryOffset: f = 0,
		} = t,
		h = r instanceof HTMLElement ? vee(r) : document.documentElement,
		p = h === document.documentElement;
	const g = window.getComputedStyle(h).position;
	let v = !!g && g !== "static",
		b = p ? Qf(n) : c6(n, h);
	if (!p) {
		let { marginTop: S, marginLeft: $ } = window.getComputedStyle(n);
		(b.top += parseInt(S, 10) || 0), (b.left += parseInt($, 10) || 0);
	}
	let y = Qf(r),
		x = pee(r);
	(y.width += x.left + x.right), (y.height += x.top + x.bottom);
	let C = hee(i),
		k = s6(a),
		w = s6(h),
		D = a.tagName === "BODY" ? Qf(h) : c6(h, a);
	return (
		h.tagName === "HTML" &&
			a.tagName === "BODY" &&
			((w.scroll.top = 0), (w.scroll.left = 0)),
		gee(e, b, y, C, x, o, s, k, w, D, l, u, v, c, d, f)
	);
}
function Qf(t) {
	let { top: e, left: n, width: r, height: i } = t.getBoundingClientRect(),
		{
			scrollTop: o,
			scrollLeft: s,
			clientTop: a,
			clientLeft: l,
		} = document.documentElement;
	return { top: e + o - a, left: n + s - l, width: r, height: i };
}
function c6(t, e) {
	let n = window.getComputedStyle(t),
		r;
	if (n.position === "fixed") {
		let {
			top: i,
			left: o,
			width: s,
			height: a,
		} = t.getBoundingClientRect();
		r = { top: i, left: o, width: s, height: a };
	} else {
		r = Qf(t);
		let i = Qf(e),
			o = window.getComputedStyle(e);
		(i.top += (parseInt(o.borderTopWidth, 10) || 0) - e.scrollTop),
			(i.left += (parseInt(o.borderLeftWidth, 10) || 0) - e.scrollLeft),
			(r.top -= i.top),
			(r.left -= i.left);
	}
	return (
		(r.top -= parseInt(n.marginTop, 10) || 0),
		(r.left -= parseInt(n.marginLeft, 10) || 0),
		r
	);
}
function vee(t) {
	let e = t.offsetParent;
	if (
		(e &&
			e === document.body &&
			window.getComputedStyle(e).position === "static" &&
			!d6(e) &&
			(e = document.documentElement),
		e == null)
	)
		for (e = t.parentElement; e && !d6(e); ) e = e.parentElement;
	return e || document.documentElement;
}
function d6(t) {
	let e = window.getComputedStyle(t);
	return (
		e.transform !== "none" ||
		/transform|perspective/.test(e.willChange) ||
		e.filter !== "none" ||
		e.contain === "paint" ||
		("backdropFilter" in e && e.backdropFilter !== "none") ||
		("WebkitBackdropFilter" in e && e.WebkitBackdropFilter !== "none")
	);
}
const g9 = new WeakMap();
function yee(t) {
	let { triggerRef: e, isOpen: n, onClose: r } = t;
	E.useEffect(() => {
		if (!n || r === null) return;
		let i = (o) => {
			let s = o.target;
			if (
				!e.current ||
				(s instanceof Node && !s.contains(e.current)) ||
				o.target instanceof HTMLInputElement ||
				o.target instanceof HTMLTextAreaElement
			)
				return;
			let a = r || g9.get(e.current);
			a && a();
		};
		return (
			window.addEventListener("scroll", i, !0),
			() => {
				window.removeEventListener("scroll", i, !0);
			}
		);
	}, [n, r, e]);
}
let Tn = typeof document < "u" && window.visualViewport;
function ZE(t) {
	let { direction: e } = Vt(),
		{
			arrowSize: n = 0,
			targetRef: r,
			overlayRef: i,
			scrollRef: o = i,
			placement: s = "bottom",
			containerPadding: a = 12,
			shouldFlip: l = !0,
			boundaryElement: u = typeof document < "u" ? document.body : null,
			offset: c = 0,
			crossOffset: d = 0,
			shouldUpdatePosition: f = !0,
			isOpen: h = !0,
			onClose: p,
			maxHeight: g,
			arrowBoundaryOffset: v = 0,
		} = t,
		[b, y] = E.useState({
			position: {},
			arrowOffsetLeft: void 0,
			arrowOffsetTop: void 0,
			maxHeight: void 0,
			placement: void 0,
		}),
		x = [
			f,
			s,
			i.current,
			r.current,
			o.current,
			a,
			l,
			u,
			c,
			d,
			h,
			e,
			g,
			v,
			n,
		],
		C = E.useRef(Tn == null ? void 0 : Tn.scale);
	E.useEffect(() => {
		h && (C.current = Tn == null ? void 0 : Tn.scale);
	}, [h]);
	let k = E.useCallback(() => {
		if (
			f === !1 ||
			!h ||
			!i.current ||
			!r.current ||
			!u ||
			(Tn == null ? void 0 : Tn.scale) !== C.current
		)
			return;
		let $ = null;
		if (o.current && o.current.contains(document.activeElement)) {
			let N = document.activeElement.getBoundingClientRect(),
				O = o.current.getBoundingClientRect();
			($ = { type: "top", offset: N.top - O.top }),
				$.offset > O.height / 2 &&
					(($.type = "bottom"), ($.offset = N.bottom - O.bottom));
		}
		let A = i.current;
		if (!g && i.current) {
			var T;
			(A.style.top = "0px"), (A.style.bottom = "");
			var I;
			A.style.maxHeight =
				((I =
					(T = window.visualViewport) === null || T === void 0
						? void 0
						: T.height) !== null && I !== void 0
					? I
					: window.innerHeight) + "px";
		}
		let F = bee({
			placement: kee(s, e),
			overlayNode: i.current,
			targetNode: r.current,
			scrollNode: o.current || i.current,
			padding: a,
			shouldFlip: l,
			boundaryElement: u,
			offset: c,
			crossOffset: d,
			maxHeight: g,
			arrowSize: n,
			arrowBoundaryOffset: v,
		});
		if (
			((A.style.top = ""),
			(A.style.bottom = ""),
			(A.style.left = ""),
			(A.style.right = ""),
			Object.keys(F.position).forEach(
				(N) => (A.style[N] = F.position[N] + "px"),
			),
			(A.style.maxHeight =
				F.maxHeight != null ? F.maxHeight + "px" : void 0),
			$)
		) {
			let N = document.activeElement.getBoundingClientRect(),
				O = o.current.getBoundingClientRect(),
				_ = N[$.type] - O[$.type];
			o.current.scrollTop += _ - $.offset;
		}
		y(F);
	}, x);
	at(k, x), xee(k), fa({ ref: i, onResize: k }), fa({ ref: r, onResize: k });
	let w = E.useRef(!1);
	at(() => {
		let $,
			A = () => {
				(w.current = !0),
					clearTimeout($),
					($ = setTimeout(() => {
						w.current = !1;
					}, 500)),
					k();
			},
			T = () => {
				w.current && A();
			};
		return (
			Tn == null || Tn.addEventListener("resize", A),
			Tn == null || Tn.addEventListener("scroll", T),
			() => {
				Tn == null || Tn.removeEventListener("resize", A),
					Tn == null || Tn.removeEventListener("scroll", T);
			}
		);
	}, [k]);
	let D = E.useCallback(() => {
		w.current || p();
	}, [p, w]);
	yee({ triggerRef: r, isOpen: h, onClose: p && D });
	var S;
	return {
		overlayProps: {
			style: {
				position: "absolute",
				zIndex: 1e5,
				...b.position,
				maxHeight:
					(S = b.maxHeight) !== null && S !== void 0 ? S : "100vh",
			},
		},
		placement: b.placement,
		arrowProps: {
			"aria-hidden": "true",
			role: "presentation",
			style: { left: b.arrowOffsetLeft, top: b.arrowOffsetTop },
		},
		updatePosition: k,
	};
}
function xee(t) {
	at(
		() => (
			window.addEventListener("resize", t, !1),
			() => {
				window.removeEventListener("resize", t, !1);
			}
		),
		[t],
	);
}
function kee(t, e) {
	return e === "rtl"
		? t.replace("start", "right").replace("end", "left")
		: t.replace("start", "left").replace("end", "right");
}
let Rf = "default",
	ew = "",
	nb = new WeakMap();
function tw(t) {
	if (Vh()) {
		if (Rf === "default") {
			const e = Yt(t);
			(ew = e.documentElement.style.webkitUserSelect),
				(e.documentElement.style.webkitUserSelect = "none");
		}
		Rf = "disabled";
	} else
		(t instanceof HTMLElement || t instanceof SVGElement) &&
			(nb.set(t, t.style.userSelect), (t.style.userSelect = "none"));
}
function qp(t) {
	if (Vh()) {
		if (Rf !== "disabled") return;
		(Rf = "restoring"),
			setTimeout(() => {
				o9(() => {
					if (Rf === "restoring") {
						const e = Yt(t);
						e.documentElement.style.webkitUserSelect === "none" &&
							(e.documentElement.style.webkitUserSelect =
								ew || ""),
							(ew = ""),
							(Rf = "default");
					}
				});
			}, 300);
	} else if (
		(t instanceof HTMLElement || t instanceof SVGElement) &&
		t &&
		nb.has(t)
	) {
		let e = nb.get(t);
		t.style.userSelect === "none" && (t.style.userSelect = e),
			t.getAttribute("style") === "" && t.removeAttribute("style"),
			nb.delete(t);
	}
}
const Km = le.createContext({ register: () => {} });
Km.displayName = "PressResponderContext";
function Cee(t, e) {
	return e.get ? e.get.call(t) : e.value;
}
function b9(t, e, n) {
	if (!e.has(t))
		throw new TypeError(
			"attempted to " + n + " private field on non-instance",
		);
	return e.get(t);
}
function wee(t, e) {
	var n = b9(t, e, "get");
	return Cee(t, n);
}
function Eee(t, e, n) {
	if (e.set) e.set.call(t, n);
	else {
		if (!e.writable)
			throw new TypeError("attempted to set read only private field");
		e.value = n;
	}
}
function f6(t, e, n) {
	var r = b9(t, e, "set");
	return Eee(t, r, n), n;
}
function Dee(t) {
	let e = E.useContext(Km);
	if (e) {
		let { register: n, ...r } = e;
		(t = xe(r, t)), n();
	}
	return lx(e, t.ref), t;
}
var c1 = new WeakMap();
class d1 {
	continuePropagation() {
		f6(this, c1, !1);
	}
	get shouldStopPropagation() {
		return wee(this, c1);
	}
	constructor(e, n, r, i) {
		iee(this, c1, { writable: !0, value: void 0 }), f6(this, c1, !0);
		var o;
		let s =
			(o = i == null ? void 0 : i.target) !== null && o !== void 0
				? o
				: r.currentTarget;
		const a = s == null ? void 0 : s.getBoundingClientRect();
		let l,
			u = 0,
			c,
			d = null;
		r.clientX != null &&
			r.clientY != null &&
			((c = r.clientX), (d = r.clientY)),
			a &&
				(c != null && d != null
					? ((l = c - a.left), (u = d - a.top))
					: ((l = a.width / 2), (u = a.height / 2))),
			(this.type = e),
			(this.pointerType = n),
			(this.target = r.currentTarget),
			(this.shiftKey = r.shiftKey),
			(this.metaKey = r.metaKey),
			(this.ctrlKey = r.ctrlKey),
			(this.altKey = r.altKey),
			(this.x = l),
			(this.y = u);
	}
}
const h6 = Symbol("linkClicked");
function zi(t) {
	let {
			onPress: e,
			onPressChange: n,
			onPressStart: r,
			onPressEnd: i,
			onPressUp: o,
			isDisabled: s,
			isPressed: a,
			preventFocusOnPress: l,
			shouldCancelOnPointerExit: u,
			allowTextSelectionOnPress: c,
			ref: d,
			...f
		} = Dee(t),
		[h, p] = E.useState(!1),
		g = E.useRef({
			isPressed: !1,
			ignoreEmulatedMouseEvents: !1,
			ignoreClickAfterPress: !1,
			didFirePressStart: !1,
			isTriggeringEvent: !1,
			activePointerId: null,
			target: null,
			isOverTarget: !1,
			pointerType: null,
		}),
		{ addGlobalListener: v, removeAllGlobalListeners: b } = i0(),
		y = Pt((S, $) => {
			let A = g.current;
			if (s || A.didFirePressStart) return !1;
			let T = !0;
			if (((A.isTriggeringEvent = !0), r)) {
				let I = new d1("pressstart", $, S);
				r(I), (T = I.shouldStopPropagation);
			}
			return (
				n && n(!0),
				(A.isTriggeringEvent = !1),
				(A.didFirePressStart = !0),
				p(!0),
				T
			);
		}),
		x = Pt((S, $, A = !0) => {
			let T = g.current;
			if (!T.didFirePressStart) return !1;
			(T.ignoreClickAfterPress = !0),
				(T.didFirePressStart = !1),
				(T.isTriggeringEvent = !0);
			let I = !0;
			if (i) {
				let F = new d1("pressend", $, S);
				i(F), (I = F.shouldStopPropagation);
			}
			if ((n && n(!1), p(!1), e && A && !s)) {
				let F = new d1("press", $, S);
				e(F), I && (I = F.shouldStopPropagation);
			}
			return (T.isTriggeringEvent = !1), I;
		}),
		C = Pt((S, $) => {
			let A = g.current;
			if (s) return !1;
			if (o) {
				A.isTriggeringEvent = !0;
				let T = new d1("pressup", $, S);
				return (
					o(T), (A.isTriggeringEvent = !1), T.shouldStopPropagation
				);
			}
			return !0;
		}),
		k = Pt((S) => {
			let $ = g.current;
			$.isPressed &&
				$.target &&
				($.isOverTarget &&
					$.pointerType != null &&
					x(Oa($.target, S), $.pointerType, !1),
				($.isPressed = !1),
				($.isOverTarget = !1),
				($.activePointerId = null),
				($.pointerType = null),
				b(),
				c || qp($.target));
		}),
		w = Pt((S) => {
			u && k(S);
		}),
		D = E.useMemo(() => {
			let S = g.current,
				$ = {
					onKeyDown(T) {
						if (
							x4(T.nativeEvent, T.currentTarget) &&
							T.currentTarget.contains(T.target)
						) {
							var I;
							m6(T.target, T.key) && T.preventDefault();
							let F = !0;
							if (!S.isPressed && !T.repeat) {
								(S.target = T.currentTarget),
									(S.isPressed = !0),
									(F = y(T, "keyboard"));
								let N = T.currentTarget,
									O = (_) => {
										x4(_, N) &&
											!_.repeat &&
											N.contains(_.target) &&
											S.target &&
											C(Oa(S.target, _), "keyboard");
									};
								v(Yt(T.currentTarget), "keyup", hr(O, A), !0);
							}
							F && T.stopPropagation(),
								T.metaKey &&
									Ss() &&
									((I = S.metaKeyEvents) === null ||
										I === void 0 ||
										I.set(T.key, T.nativeEvent));
						} else
							T.key === "Meta" && (S.metaKeyEvents = new Map());
					},
					onClick(T) {
						if (
							!(T && !T.currentTarget.contains(T.target)) &&
							T &&
							T.button === 0 &&
							!S.isTriggeringEvent &&
							!_u.isOpening
						) {
							let I = !0;
							if (
								(s && T.preventDefault(),
								!S.ignoreClickAfterPress &&
									!S.ignoreEmulatedMouseEvents &&
									!S.isPressed &&
									(S.pointerType === "virtual" ||
										Vm(T.nativeEvent)))
							) {
								!s && !l && io(T.currentTarget);
								let F = y(T, "virtual"),
									N = C(T, "virtual"),
									O = x(T, "virtual");
								I = F && N && O;
							}
							(S.ignoreEmulatedMouseEvents = !1),
								(S.ignoreClickAfterPress = !1),
								I && T.stopPropagation();
						}
					},
				},
				A = (T) => {
					var I;
					if (S.isPressed && S.target && x4(T, S.target)) {
						var F;
						m6(T.target, T.key) && T.preventDefault();
						let O = T.target;
						x(Oa(S.target, T), "keyboard", S.target.contains(O)),
							b(),
							T.key !== "Enter" &&
								QE(S.target) &&
								S.target.contains(O) &&
								!T[h6] &&
								((T[h6] = !0), _u(S.target, T, !1)),
							(S.isPressed = !1),
							(F = S.metaKeyEvents) === null ||
								F === void 0 ||
								F.delete(T.key);
					} else if (
						T.key === "Meta" &&
						!((I = S.metaKeyEvents) === null || I === void 0) &&
						I.size
					) {
						var N;
						let O = S.metaKeyEvents;
						S.metaKeyEvents = void 0;
						for (let _ of O.values())
							(N = S.target) === null ||
								N === void 0 ||
								N.dispatchEvent(new KeyboardEvent("keyup", _));
					}
				};
			if (typeof PointerEvent < "u") {
				($.onPointerDown = (N) => {
					if (N.button !== 0 || !N.currentTarget.contains(N.target))
						return;
					if (XE(N.nativeEvent)) {
						S.pointerType = "virtual";
						return;
					}
					k4(N.currentTarget) && N.preventDefault(),
						(S.pointerType = N.pointerType);
					let O = !0;
					S.isPressed ||
						((S.isPressed = !0),
						(S.isOverTarget = !0),
						(S.activePointerId = N.pointerId),
						(S.target = N.currentTarget),
						!s && !l && io(N.currentTarget),
						c || tw(S.target),
						(O = y(N, S.pointerType)),
						v(Yt(N.currentTarget), "pointermove", T, !1),
						v(Yt(N.currentTarget), "pointerup", I, !1),
						v(Yt(N.currentTarget), "pointercancel", F, !1)),
						O && N.stopPropagation();
				}),
					($.onMouseDown = (N) => {
						N.currentTarget.contains(N.target) &&
							N.button === 0 &&
							(k4(N.currentTarget) && N.preventDefault(),
							N.stopPropagation());
					}),
					($.onPointerUp = (N) => {
						!N.currentTarget.contains(N.target) ||
							S.pointerType === "virtual" ||
							(N.button === 0 &&
								cf(N, N.currentTarget) &&
								C(N, S.pointerType || N.pointerType));
					});
				let T = (N) => {
						N.pointerId === S.activePointerId &&
							(S.target && cf(N, S.target)
								? !S.isOverTarget &&
									S.pointerType != null &&
									((S.isOverTarget = !0),
									y(Oa(S.target, N), S.pointerType))
								: S.target &&
									S.isOverTarget &&
									S.pointerType != null &&
									((S.isOverTarget = !1),
									x(Oa(S.target, N), S.pointerType, !1),
									w(N)));
					},
					I = (N) => {
						N.pointerId === S.activePointerId &&
							S.isPressed &&
							N.button === 0 &&
							S.target &&
							(cf(N, S.target) && S.pointerType != null
								? x(Oa(S.target, N), S.pointerType)
								: S.isOverTarget &&
									S.pointerType != null &&
									x(Oa(S.target, N), S.pointerType, !1),
							(S.isPressed = !1),
							(S.isOverTarget = !1),
							(S.activePointerId = null),
							(S.pointerType = null),
							b(),
							c || qp(S.target));
					},
					F = (N) => {
						k(N);
					};
				$.onDragStart = (N) => {
					N.currentTarget.contains(N.target) && k(N);
				};
			} else {
				($.onMouseDown = (F) => {
					if (F.button !== 0 || !F.currentTarget.contains(F.target))
						return;
					if (
						(k4(F.currentTarget) && F.preventDefault(),
						S.ignoreEmulatedMouseEvents)
					) {
						F.stopPropagation();
						return;
					}
					(S.isPressed = !0),
						(S.isOverTarget = !0),
						(S.target = F.currentTarget),
						(S.pointerType = Vm(F.nativeEvent)
							? "virtual"
							: "mouse"),
						!s && !l && io(F.currentTarget),
						y(F, S.pointerType) && F.stopPropagation(),
						v(Yt(F.currentTarget), "mouseup", T, !1);
				}),
					($.onMouseEnter = (F) => {
						if (!F.currentTarget.contains(F.target)) return;
						let N = !0;
						S.isPressed &&
							!S.ignoreEmulatedMouseEvents &&
							S.pointerType != null &&
							((S.isOverTarget = !0), (N = y(F, S.pointerType))),
							N && F.stopPropagation();
					}),
					($.onMouseLeave = (F) => {
						if (!F.currentTarget.contains(F.target)) return;
						let N = !0;
						S.isPressed &&
							!S.ignoreEmulatedMouseEvents &&
							S.pointerType != null &&
							((S.isOverTarget = !1),
							(N = x(F, S.pointerType, !1)),
							w(F)),
							N && F.stopPropagation();
					}),
					($.onMouseUp = (F) => {
						F.currentTarget.contains(F.target) &&
							!S.ignoreEmulatedMouseEvents &&
							F.button === 0 &&
							C(F, S.pointerType || "mouse");
					});
				let T = (F) => {
					if (F.button === 0) {
						if (
							((S.isPressed = !1),
							b(),
							S.ignoreEmulatedMouseEvents)
						) {
							S.ignoreEmulatedMouseEvents = !1;
							return;
						}
						S.target && cf(F, S.target) && S.pointerType != null
							? x(Oa(S.target, F), S.pointerType)
							: S.target &&
								S.isOverTarget &&
								S.pointerType != null &&
								x(Oa(S.target, F), S.pointerType, !1),
							(S.isOverTarget = !1);
					}
				};
				($.onTouchStart = (F) => {
					if (!F.currentTarget.contains(F.target)) return;
					let N = See(F.nativeEvent);
					if (!N) return;
					(S.activePointerId = N.identifier),
						(S.ignoreEmulatedMouseEvents = !0),
						(S.isOverTarget = !0),
						(S.isPressed = !0),
						(S.target = F.currentTarget),
						(S.pointerType = "touch"),
						!s && !l && io(F.currentTarget),
						c || tw(S.target),
						y(_l(S.target, F), S.pointerType) &&
							F.stopPropagation(),
						v(jo(F.currentTarget), "scroll", I, !0);
				}),
					($.onTouchMove = (F) => {
						if (!F.currentTarget.contains(F.target)) return;
						if (!S.isPressed) {
							F.stopPropagation();
							return;
						}
						let N = p6(F.nativeEvent, S.activePointerId),
							O = !0;
						N && cf(N, F.currentTarget)
							? !S.isOverTarget &&
								S.pointerType != null &&
								((S.isOverTarget = !0),
								(O = y(_l(S.target, F), S.pointerType)))
							: S.isOverTarget &&
								S.pointerType != null &&
								((S.isOverTarget = !1),
								(O = x(_l(S.target, F), S.pointerType, !1)),
								w(_l(S.target, F))),
							O && F.stopPropagation();
					}),
					($.onTouchEnd = (F) => {
						if (!F.currentTarget.contains(F.target)) return;
						if (!S.isPressed) {
							F.stopPropagation();
							return;
						}
						let N = p6(F.nativeEvent, S.activePointerId),
							O = !0;
						N && cf(N, F.currentTarget) && S.pointerType != null
							? (C(_l(S.target, F), S.pointerType),
								(O = x(_l(S.target, F), S.pointerType)))
							: S.isOverTarget &&
								S.pointerType != null &&
								(O = x(_l(S.target, F), S.pointerType, !1)),
							O && F.stopPropagation(),
							(S.isPressed = !1),
							(S.activePointerId = null),
							(S.isOverTarget = !1),
							(S.ignoreEmulatedMouseEvents = !0),
							S.target && !c && qp(S.target),
							b();
					}),
					($.onTouchCancel = (F) => {
						F.currentTarget.contains(F.target) &&
							(F.stopPropagation(),
							S.isPressed && k(_l(S.target, F)));
					});
				let I = (F) => {
					S.isPressed &&
						F.target.contains(S.target) &&
						k({
							currentTarget: S.target,
							shiftKey: !1,
							ctrlKey: !1,
							metaKey: !1,
							altKey: !1,
						});
				};
				$.onDragStart = (F) => {
					F.currentTarget.contains(F.target) && k(F);
				};
			}
			return $;
		}, [v, s, l, b, c, k, w, x, y, C]);
	return (
		E.useEffect(
			() => () => {
				var S;
				c ||
					qp(
						(S = g.current.target) !== null && S !== void 0
							? S
							: void 0,
					);
			},
			[c],
		),
		{ isPressed: a || h, pressProps: xe(f, D) }
	);
}
function QE(t) {
	return t.tagName === "A" && t.hasAttribute("href");
}
function x4(t, e) {
	const { key: n, code: r } = t,
		i = e,
		o = i.getAttribute("role");
	return (
		(n === "Enter" || n === " " || n === "Spacebar" || r === "Space") &&
		!(
			(i instanceof jo(i).HTMLInputElement && !v9(i, n)) ||
			i instanceof jo(i).HTMLTextAreaElement ||
			i.isContentEditable
		) &&
		!((o === "link" || (!o && QE(i))) && n !== "Enter")
	);
}
function See(t) {
	const { targetTouches: e } = t;
	return e.length > 0 ? e[0] : null;
}
function p6(t, e) {
	const n = t.changedTouches;
	for (let r = 0; r < n.length; r++) {
		const i = n[r];
		if (i.identifier === e) return i;
	}
	return null;
}
function _l(t, e) {
	let n = 0,
		r = 0;
	return (
		e.targetTouches &&
			e.targetTouches.length === 1 &&
			((n = e.targetTouches[0].clientX),
			(r = e.targetTouches[0].clientY)),
		{
			currentTarget: t,
			shiftKey: e.shiftKey,
			ctrlKey: e.ctrlKey,
			metaKey: e.metaKey,
			altKey: e.altKey,
			clientX: n,
			clientY: r,
		}
	);
}
function Oa(t, e) {
	let n = e.clientX,
		r = e.clientY;
	return {
		currentTarget: t,
		shiftKey: e.shiftKey,
		ctrlKey: e.ctrlKey,
		metaKey: e.metaKey,
		altKey: e.altKey,
		clientX: n,
		clientY: r,
	};
}
function Aee(t) {
	let e = 0,
		n = 0;
	return (
		t.width !== void 0
			? (e = t.width / 2)
			: t.radiusX !== void 0 && (e = t.radiusX),
		t.height !== void 0
			? (n = t.height / 2)
			: t.radiusY !== void 0 && (n = t.radiusY),
		{
			top: t.clientY - n,
			right: t.clientX + e,
			bottom: t.clientY + n,
			left: t.clientX - e,
		}
	);
}
function $ee(t, e) {
	return !(
		t.left > e.right ||
		e.left > t.right ||
		t.top > e.bottom ||
		e.top > t.bottom
	);
}
function cf(t, e) {
	let n = e.getBoundingClientRect(),
		r = Aee(t);
	return $ee(n, r);
}
function k4(t) {
	return !(t instanceof HTMLElement) || !t.hasAttribute("draggable");
}
function m6(t, e) {
	return t instanceof HTMLInputElement
		? !v9(t, e)
		: t instanceof HTMLButtonElement
			? t.type !== "submit" && t.type !== "reset"
			: !QE(t);
}
const Tee = new Set([
	"checkbox",
	"radio",
	"range",
	"color",
	"file",
	"image",
	"button",
	"submit",
	"reset",
]);
function v9(t, e) {
	return t.type === "checkbox" || t.type === "radio"
		? e === " "
		: Tee.has(t.type);
}
const Al = le.forwardRef(({ children: t, ...e }, n) => {
	let r = E.useRef(!1),
		i = E.useContext(Km);
	n = Ct(n || (i == null ? void 0 : i.ref));
	let o = xe(i || {}, {
		...e,
		ref: n,
		register() {
			(r.current = !0), i && i.register();
		},
	});
	return (
		lx(i, n),
		E.useEffect(() => {
			r.current ||
				(console.warn(
					"A PressResponder was rendered without a pressable child. Either call the usePress hook, or wrap your DOM node with <Pressable> component.",
				),
				(r.current = !0));
		}, []),
		le.createElement(Km.Provider, { value: o }, t)
	);
});
function Bee({ children: t }) {
	let e = E.useMemo(() => ({ register: () => {} }), []);
	return le.createElement(Km.Provider, { value: e }, t);
}
class Iee {
	isDefaultPrevented() {
		return this.nativeEvent.defaultPrevented;
	}
	preventDefault() {
		(this.defaultPrevented = !0), this.nativeEvent.preventDefault();
	}
	stopPropagation() {
		this.nativeEvent.stopPropagation(),
			(this.isPropagationStopped = () => !0);
	}
	isPropagationStopped() {
		return !1;
	}
	persist() {}
	constructor(e, n) {
		(this.nativeEvent = n),
			(this.target = n.target),
			(this.currentTarget = n.currentTarget),
			(this.relatedTarget = n.relatedTarget),
			(this.bubbles = n.bubbles),
			(this.cancelable = n.cancelable),
			(this.defaultPrevented = n.defaultPrevented),
			(this.eventPhase = n.eventPhase),
			(this.isTrusted = n.isTrusted),
			(this.timeStamp = n.timeStamp),
			(this.type = e);
	}
}
function y9(t) {
	let e = E.useRef({ isFocused: !1, observer: null });
	at(() => {
		const r = e.current;
		return () => {
			r.observer && (r.observer.disconnect(), (r.observer = null));
		};
	}, []);
	let n = Pt((r) => {
		t == null || t(r);
	});
	return E.useCallback(
		(r) => {
			if (
				r.target instanceof HTMLButtonElement ||
				r.target instanceof HTMLInputElement ||
				r.target instanceof HTMLTextAreaElement ||
				r.target instanceof HTMLSelectElement
			) {
				e.current.isFocused = !0;
				let i = r.target,
					o = (s) => {
						(e.current.isFocused = !1),
							i.disabled && n(new Iee("blur", s)),
							e.current.observer &&
								(e.current.observer.disconnect(),
								(e.current.observer = null));
					};
				i.addEventListener("focusout", o, { once: !0 }),
					(e.current.observer = new MutationObserver(() => {
						if (e.current.isFocused && i.disabled) {
							var s;
							(s = e.current.observer) === null ||
								s === void 0 ||
								s.disconnect();
							let a =
								i === document.activeElement
									? null
									: document.activeElement;
							i.dispatchEvent(
								new FocusEvent("blur", { relatedTarget: a }),
							),
								i.dispatchEvent(
									new FocusEvent("focusout", {
										bubbles: !0,
										relatedTarget: a,
									}),
								);
						}
					})),
					e.current.observer.observe(i, {
						attributes: !0,
						attributeFilter: ["disabled"],
					});
			}
		},
		[n],
	);
}
function cx(t) {
	let { isDisabled: e, onFocus: n, onBlur: r, onFocusChange: i } = t;
	const o = E.useCallback(
			(l) => {
				if (l.target === l.currentTarget)
					return r && r(l), i && i(!1), !0;
			},
			[r, i],
		),
		s = y9(o),
		a = E.useCallback(
			(l) => {
				const u = Yt(l.target);
				l.target === l.currentTarget &&
					u.activeElement === l.target &&
					(n && n(l), i && i(!0), s(l));
			},
			[i, n, s],
		);
	return {
		focusProps: {
			onFocus: !e && (n || i || r) ? a : void 0,
			onBlur: !e && (r || i) ? o : void 0,
		},
	};
}
let pl = null,
	Um = new Set(),
	pm = new Map(),
	md = !1,
	nw = !1;
const Fee = { Tab: !0, Escape: !0 };
function dx(t, e) {
	for (let n of Um) n(t, e);
}
function Pee(t) {
	return !(
		t.metaKey ||
		(!Ss() && t.altKey) ||
		t.ctrlKey ||
		t.key === "Control" ||
		t.key === "Shift" ||
		t.key === "Meta"
	);
}
function sv(t) {
	(md = !0), Pee(t) && ((pl = "keyboard"), dx("keyboard", t));
}
function Io(t) {
	(pl = "pointer"),
		(t.type === "mousedown" || t.type === "pointerdown") &&
			((md = !0), dx("pointer", t));
}
function x9(t) {
	Vm(t) && ((md = !0), (pl = "virtual"));
}
function k9(t) {
	t.target === window ||
		t.target === document ||
		(!md && !nw && ((pl = "virtual"), dx("virtual", t)),
		(md = !1),
		(nw = !1));
}
function C9() {
	(md = !1), (nw = !0);
}
function av(t) {
	if (typeof window > "u" || pm.get(jo(t))) return;
	const e = jo(t),
		n = Yt(t);
	let r = e.HTMLElement.prototype.focus;
	(e.HTMLElement.prototype.focus = function () {
		(md = !0), r.apply(this, arguments);
	}),
		n.addEventListener("keydown", sv, !0),
		n.addEventListener("keyup", sv, !0),
		n.addEventListener("click", x9, !0),
		e.addEventListener("focus", k9, !0),
		e.addEventListener("blur", C9, !1),
		typeof PointerEvent < "u"
			? (n.addEventListener("pointerdown", Io, !0),
				n.addEventListener("pointermove", Io, !0),
				n.addEventListener("pointerup", Io, !0))
			: (n.addEventListener("mousedown", Io, !0),
				n.addEventListener("mousemove", Io, !0),
				n.addEventListener("mouseup", Io, !0)),
		e.addEventListener(
			"beforeunload",
			() => {
				w9(t);
			},
			{ once: !0 },
		),
		pm.set(e, { focus: r });
}
const w9 = (t, e) => {
	const n = jo(t),
		r = Yt(t);
	e && r.removeEventListener("DOMContentLoaded", e),
		pm.has(n) &&
			((n.HTMLElement.prototype.focus = pm.get(n).focus),
			r.removeEventListener("keydown", sv, !0),
			r.removeEventListener("keyup", sv, !0),
			r.removeEventListener("click", x9, !0),
			n.removeEventListener("focus", k9, !0),
			n.removeEventListener("blur", C9, !1),
			typeof PointerEvent < "u"
				? (r.removeEventListener("pointerdown", Io, !0),
					r.removeEventListener("pointermove", Io, !0),
					r.removeEventListener("pointerup", Io, !0))
				: (r.removeEventListener("mousedown", Io, !0),
					r.removeEventListener("mousemove", Io, !0),
					r.removeEventListener("mouseup", Io, !0)),
			pm.delete(n));
};
function Nee(t) {
	const e = Yt(t);
	let n;
	return (
		e.readyState !== "loading"
			? av(t)
			: ((n = () => {
					av(t);
				}),
				e.addEventListener("DOMContentLoaded", n)),
		() => w9(t, n)
	);
}
typeof document < "u" && Nee();
function ml() {
	return pl !== "pointer";
}
function gl() {
	return pl;
}
function Ic(t) {
	(pl = t), dx(t, null);
}
function fx() {
	av();
	let [t, e] = E.useState(pl);
	return (
		E.useEffect(() => {
			let n = () => {
				e(pl);
			};
			return (
				Um.add(n),
				() => {
					Um.delete(n);
				}
			);
		}, []),
		Vd() ? null : t
	);
}
const Ree = new Set([
	"checkbox",
	"radio",
	"range",
	"color",
	"file",
	"image",
	"button",
	"submit",
	"reset",
]);
function Oee(t, e, n) {
	var r;
	const i =
			typeof window < "u"
				? jo(n == null ? void 0 : n.target).HTMLInputElement
				: HTMLInputElement,
		o =
			typeof window < "u"
				? jo(n == null ? void 0 : n.target).HTMLTextAreaElement
				: HTMLTextAreaElement,
		s =
			typeof window < "u"
				? jo(n == null ? void 0 : n.target).HTMLElement
				: HTMLElement,
		a =
			typeof window < "u"
				? jo(n == null ? void 0 : n.target).KeyboardEvent
				: KeyboardEvent;
	return (
		(t =
			t ||
			((n == null ? void 0 : n.target) instanceof i &&
				!Ree.has(
					n == null || (r = n.target) === null || r === void 0
						? void 0
						: r.type,
				)) ||
			(n == null ? void 0 : n.target) instanceof o ||
			((n == null ? void 0 : n.target) instanceof s &&
				(n == null ? void 0 : n.target.isContentEditable))),
		!(t && e === "keyboard" && n instanceof a && !Fee[n.key])
	);
}
function Mee(t, e, n) {
	av(),
		E.useEffect(() => {
			let r = (i, o) => {
				Oee(!!(n != null && n.isTextInput), i, o) && t(ml());
			};
			return (
				Um.add(r),
				() => {
					Um.delete(r);
				}
			);
		}, e);
}
function Ud(t) {
	let {
			isDisabled: e,
			onBlurWithin: n,
			onFocusWithin: r,
			onFocusWithinChange: i,
		} = t,
		o = E.useRef({ isFocusWithin: !1 }),
		s = E.useCallback(
			(u) => {
				o.current.isFocusWithin &&
					!u.currentTarget.contains(u.relatedTarget) &&
					((o.current.isFocusWithin = !1), n && n(u), i && i(!1));
			},
			[n, i, o],
		),
		a = y9(s),
		l = E.useCallback(
			(u) => {
				!o.current.isFocusWithin &&
					document.activeElement === u.target &&
					(r && r(u),
					i && i(!0),
					(o.current.isFocusWithin = !0),
					a(u));
			},
			[r, i, a],
		);
	return e
		? { focusWithinProps: { onFocus: void 0, onBlur: void 0 } }
		: { focusWithinProps: { onFocus: l, onBlur: s } };
}
let lv = !1,
	C4 = 0;
function rw() {
	(lv = !0),
		setTimeout(() => {
			lv = !1;
		}, 50);
}
function g6(t) {
	t.pointerType === "touch" && rw();
}
function jee() {
	if (!(typeof document > "u"))
		return (
			typeof PointerEvent < "u"
				? document.addEventListener("pointerup", g6)
				: document.addEventListener("touchend", rw),
			C4++,
			() => {
				C4--,
					!(C4 > 0) &&
						(typeof PointerEvent < "u"
							? document.removeEventListener("pointerup", g6)
							: document.removeEventListener("touchend", rw));
			}
		);
}
function gn(t) {
	let { onHoverStart: e, onHoverChange: n, onHoverEnd: r, isDisabled: i } = t,
		[o, s] = E.useState(!1),
		a = E.useRef({
			isHovered: !1,
			ignoreEmulatedMouseEvents: !1,
			pointerType: "",
			target: null,
		}).current;
	E.useEffect(jee, []);
	let { hoverProps: l, triggerHoverEnd: u } = E.useMemo(() => {
		let c = (h, p) => {
				if (
					((a.pointerType = p),
					i ||
						p === "touch" ||
						a.isHovered ||
						!h.currentTarget.contains(h.target))
				)
					return;
				a.isHovered = !0;
				let g = h.currentTarget;
				(a.target = g),
					e && e({ type: "hoverstart", target: g, pointerType: p }),
					n && n(!0),
					s(!0);
			},
			d = (h, p) => {
				if (
					((a.pointerType = ""),
					(a.target = null),
					p === "touch" || !a.isHovered)
				)
					return;
				a.isHovered = !1;
				let g = h.currentTarget;
				r && r({ type: "hoverend", target: g, pointerType: p }),
					n && n(!1),
					s(!1);
			},
			f = {};
		return (
			typeof PointerEvent < "u"
				? ((f.onPointerEnter = (h) => {
						(lv && h.pointerType === "mouse") ||
							c(h, h.pointerType);
					}),
					(f.onPointerLeave = (h) => {
						!i &&
							h.currentTarget.contains(h.target) &&
							d(h, h.pointerType);
					}))
				: ((f.onTouchStart = () => {
						a.ignoreEmulatedMouseEvents = !0;
					}),
					(f.onMouseEnter = (h) => {
						!a.ignoreEmulatedMouseEvents && !lv && c(h, "mouse"),
							(a.ignoreEmulatedMouseEvents = !1);
					}),
					(f.onMouseLeave = (h) => {
						!i &&
							h.currentTarget.contains(h.target) &&
							d(h, "mouse");
					})),
			{ hoverProps: f, triggerHoverEnd: d }
		);
	}, [e, n, r, i, a]);
	return (
		E.useEffect(() => {
			i && u({ currentTarget: a.target }, a.pointerType);
		}, [i]),
		{ hoverProps: l, isHovered: o }
	);
}
function _ee(t) {
	let {
			ref: e,
			onInteractOutside: n,
			isDisabled: r,
			onInteractOutsideStart: i,
		} = t,
		o = E.useRef({ isPointerDown: !1, ignoreEmulatedMouseEvents: !1 }),
		s = Pt((l) => {
			n && f1(l, e) && (i && i(l), (o.current.isPointerDown = !0));
		}),
		a = Pt((l) => {
			n && n(l);
		});
	E.useEffect(() => {
		let l = o.current;
		if (r) return;
		const u = e.current,
			c = Yt(u);
		if (typeof PointerEvent < "u") {
			let d = (f) => {
				l.isPointerDown && f1(f, e) && a(f), (l.isPointerDown = !1);
			};
			return (
				c.addEventListener("pointerdown", s, !0),
				c.addEventListener("pointerup", d, !0),
				() => {
					c.removeEventListener("pointerdown", s, !0),
						c.removeEventListener("pointerup", d, !0);
				}
			);
		} else {
			let d = (h) => {
					l.ignoreEmulatedMouseEvents
						? (l.ignoreEmulatedMouseEvents = !1)
						: l.isPointerDown && f1(h, e) && a(h),
						(l.isPointerDown = !1);
				},
				f = (h) => {
					(l.ignoreEmulatedMouseEvents = !0),
						l.isPointerDown && f1(h, e) && a(h),
						(l.isPointerDown = !1);
				};
			return (
				c.addEventListener("mousedown", s, !0),
				c.addEventListener("mouseup", d, !0),
				c.addEventListener("touchstart", s, !0),
				c.addEventListener("touchend", f, !0),
				() => {
					c.removeEventListener("mousedown", s, !0),
						c.removeEventListener("mouseup", d, !0),
						c.removeEventListener("touchstart", s, !0),
						c.removeEventListener("touchend", f, !0);
				}
			);
		}
	}, [e, r, s, a]);
}
function f1(t, e) {
	if (t.button > 0) return !1;
	if (t.target) {
		const n = t.target.ownerDocument;
		if (
			!n ||
			!n.documentElement.contains(t.target) ||
			t.target.closest("[data-react-aria-top-layer]")
		)
			return !1;
	}
	return e.current && !e.current.contains(t.target);
}
function b6(t) {
	if (!t) return;
	let e = !0;
	return (n) => {
		let r = {
			...n,
			preventDefault() {
				n.preventDefault();
			},
			isDefaultPrevented() {
				return n.isDefaultPrevented();
			},
			stopPropagation() {
				console.error(
					"stopPropagation is now the default behavior for events in React Spectrum. You can use continuePropagation() to revert this behavior.",
				);
			},
			continuePropagation() {
				e = !1;
			},
		};
		t(r), e && n.stopPropagation();
	};
}
function hx(t) {
	return {
		keyboardProps: t.isDisabled
			? {}
			: { onKeyDown: b6(t.onKeyDown), onKeyUp: b6(t.onKeyUp) },
	};
}
function zee(t) {
	let { onMoveStart: e, onMove: n, onMoveEnd: r } = t,
		i = E.useRef({ didMove: !1, lastPosition: null, id: null }),
		{ addGlobalListener: o, removeGlobalListener: s } = i0(),
		a = Pt((c, d, f, h) => {
			(f === 0 && h === 0) ||
				(i.current.didMove ||
					((i.current.didMove = !0),
					e == null ||
						e({
							type: "movestart",
							pointerType: d,
							shiftKey: c.shiftKey,
							metaKey: c.metaKey,
							ctrlKey: c.ctrlKey,
							altKey: c.altKey,
						})),
				n == null ||
					n({
						type: "move",
						pointerType: d,
						deltaX: f,
						deltaY: h,
						shiftKey: c.shiftKey,
						metaKey: c.metaKey,
						ctrlKey: c.ctrlKey,
						altKey: c.altKey,
					}));
		}),
		l = Pt((c, d) => {
			qp(),
				i.current.didMove &&
					(r == null ||
						r({
							type: "moveend",
							pointerType: d,
							shiftKey: c.shiftKey,
							metaKey: c.metaKey,
							ctrlKey: c.ctrlKey,
							altKey: c.altKey,
						}));
		});
	return {
		moveProps: E.useMemo(() => {
			let c = {},
				d = () => {
					tw(), (i.current.didMove = !1);
				};
			if (typeof PointerEvent > "u") {
				let h = (b) => {
						if (b.button === 0) {
							var y, x, C, k;
							a(
								b,
								"mouse",
								b.pageX -
									((C =
										(y = i.current.lastPosition) === null ||
										y === void 0
											? void 0
											: y.pageX) !== null && C !== void 0
										? C
										: 0),
								b.pageY -
									((k =
										(x = i.current.lastPosition) === null ||
										x === void 0
											? void 0
											: x.pageY) !== null && k !== void 0
										? k
										: 0),
							),
								(i.current.lastPosition = {
									pageX: b.pageX,
									pageY: b.pageY,
								});
						}
					},
					p = (b) => {
						b.button === 0 &&
							(l(b, "mouse"),
							s(window, "mousemove", h, !1),
							s(window, "mouseup", p, !1));
					};
				c.onMouseDown = (b) => {
					b.button === 0 &&
						(d(),
						b.stopPropagation(),
						b.preventDefault(),
						(i.current.lastPosition = {
							pageX: b.pageX,
							pageY: b.pageY,
						}),
						o(window, "mousemove", h, !1),
						o(window, "mouseup", p, !1));
				};
				let g = (b) => {
						let y = [...b.changedTouches].findIndex(
							({ identifier: D }) => D === i.current.id,
						);
						if (y >= 0) {
							var x, C;
							let { pageX: D, pageY: S } = b.changedTouches[y];
							var k, w;
							a(
								b,
								"touch",
								D -
									((k =
										(x = i.current.lastPosition) === null ||
										x === void 0
											? void 0
											: x.pageX) !== null && k !== void 0
										? k
										: 0),
								S -
									((w =
										(C = i.current.lastPosition) === null ||
										C === void 0
											? void 0
											: C.pageY) !== null && w !== void 0
										? w
										: 0),
							),
								(i.current.lastPosition = {
									pageX: D,
									pageY: S,
								});
						}
					},
					v = (b) => {
						[...b.changedTouches].findIndex(
							({ identifier: x }) => x === i.current.id,
						) >= 0 &&
							(l(b, "touch"),
							(i.current.id = null),
							s(window, "touchmove", g),
							s(window, "touchend", v),
							s(window, "touchcancel", v));
					};
				c.onTouchStart = (b) => {
					if (b.changedTouches.length === 0 || i.current.id != null)
						return;
					let {
						pageX: y,
						pageY: x,
						identifier: C,
					} = b.changedTouches[0];
					d(),
						b.stopPropagation(),
						b.preventDefault(),
						(i.current.lastPosition = { pageX: y, pageY: x }),
						(i.current.id = C),
						o(window, "touchmove", g, !1),
						o(window, "touchend", v, !1),
						o(window, "touchcancel", v, !1);
				};
			} else {
				let h = (g) => {
						if (g.pointerId === i.current.id) {
							var v, b;
							let C = g.pointerType || "mouse";
							var y, x;
							a(
								g,
								C,
								g.pageX -
									((y =
										(v = i.current.lastPosition) === null ||
										v === void 0
											? void 0
											: v.pageX) !== null && y !== void 0
										? y
										: 0),
								g.pageY -
									((x =
										(b = i.current.lastPosition) === null ||
										b === void 0
											? void 0
											: b.pageY) !== null && x !== void 0
										? x
										: 0),
							),
								(i.current.lastPosition = {
									pageX: g.pageX,
									pageY: g.pageY,
								});
						}
					},
					p = (g) => {
						if (g.pointerId === i.current.id) {
							let v = g.pointerType || "mouse";
							l(g, v),
								(i.current.id = null),
								s(window, "pointermove", h, !1),
								s(window, "pointerup", p, !1),
								s(window, "pointercancel", p, !1);
						}
					};
				c.onPointerDown = (g) => {
					g.button === 0 &&
						i.current.id == null &&
						(d(),
						g.stopPropagation(),
						g.preventDefault(),
						(i.current.lastPosition = {
							pageX: g.pageX,
							pageY: g.pageY,
						}),
						(i.current.id = g.pointerId),
						o(window, "pointermove", h, !1),
						o(window, "pointerup", p, !1),
						o(window, "pointercancel", p, !1));
				};
			}
			let f = (h, p, g) => {
				d(), a(h, "keyboard", p, g), l(h, "keyboard");
			};
			return (
				(c.onKeyDown = (h) => {
					switch (h.key) {
						case "Left":
						case "ArrowLeft":
							h.preventDefault(),
								h.stopPropagation(),
								f(h, -1, 0);
							break;
						case "Right":
						case "ArrowRight":
							h.preventDefault(), h.stopPropagation(), f(h, 1, 0);
							break;
						case "Up":
						case "ArrowUp":
							h.preventDefault(),
								h.stopPropagation(),
								f(h, 0, -1);
							break;
						case "Down":
						case "ArrowDown":
							h.preventDefault(), h.stopPropagation(), f(h, 0, 1);
							break;
					}
				}),
				c
			);
		}, [i, o, s, a, l]),
	};
}
function Lee(t, e) {
	let { onScroll: n, isDisabled: r } = t,
		i = E.useCallback(
			(o) => {
				o.ctrlKey ||
					(o.preventDefault(),
					o.stopPropagation(),
					n && n({ deltaX: o.deltaX, deltaY: o.deltaY }));
			},
			[n],
		);
	Lm(e, "wheel", r ? void 0 : i);
}
const Vee = 500;
function E9(t) {
	let {
		isDisabled: e,
		onLongPressStart: n,
		onLongPressEnd: r,
		onLongPress: i,
		threshold: o = Vee,
		accessibilityDescription: s,
	} = t;
	const a = E.useRef(void 0);
	let { addGlobalListener: l, removeGlobalListener: u } = i0(),
		{ pressProps: c } = zi({
			isDisabled: e,
			onPressStart(f) {
				if (
					(f.continuePropagation(),
					(f.pointerType === "mouse" || f.pointerType === "touch") &&
						(n && n({ ...f, type: "longpressstart" }),
						(a.current = setTimeout(() => {
							f.target.dispatchEvent(
								new PointerEvent("pointercancel", {
									bubbles: !0,
								}),
							),
								i && i({ ...f, type: "longpress" }),
								(a.current = void 0);
						}, o)),
						f.pointerType === "touch"))
				) {
					let h = (p) => {
						p.preventDefault();
					};
					l(f.target, "contextmenu", h, { once: !0 }),
						l(
							window,
							"pointerup",
							() => {
								setTimeout(() => {
									u(f.target, "contextmenu", h);
								}, 30);
							},
							{ once: !0 },
						);
				}
			},
			onPressEnd(f) {
				a.current && clearTimeout(a.current),
					r &&
						(f.pointerType === "mouse" ||
							f.pointerType === "touch") &&
						r({ ...f, type: "longpressend" });
			},
		}),
		d = tc(i && !e ? s : void 0);
	return { longPressProps: xe(c, d) };
}
function on(t) {
	const e = Yt(t);
	if (gl() === "virtual") {
		let n = e.activeElement;
		o9(() => {
			e.activeElement === n && t.isConnected && io(t);
		});
	} else io(t);
}
function Kee(t) {
	const e = jo(t);
	if (!(t instanceof e.HTMLElement) && !(t instanceof e.SVGElement))
		return !1;
	let { display: n, visibility: r } = t.style,
		i = n !== "none" && r !== "hidden" && r !== "collapse";
	if (i) {
		const { getComputedStyle: o } = t.ownerDocument.defaultView;
		let { display: s, visibility: a } = o(t);
		i = s !== "none" && a !== "hidden" && a !== "collapse";
	}
	return i;
}
function Uee(t, e) {
	return (
		!t.hasAttribute("hidden") &&
		!t.hasAttribute("data-react-aria-prevent-focus") &&
		(t.nodeName === "DETAILS" && e && e.nodeName !== "SUMMARY"
			? t.hasAttribute("open")
			: !0)
	);
}
function D9(t, e) {
	return (
		t.nodeName !== "#comment" &&
		Kee(t) &&
		Uee(t, e) &&
		(!t.parentElement || D9(t.parentElement, t))
	);
}
const v6 = le.createContext(null),
	iw = "react-aria-focus-scope-restore";
let Zt = null;
function nc(t) {
	let { children: e, contain: n, restoreFocus: r, autoFocus: i } = t,
		o = E.useRef(null),
		s = E.useRef(null),
		a = E.useRef([]),
		{ parentNode: l } = E.useContext(v6) || {},
		u = E.useMemo(() => new sw({ scopeRef: a }), [a]);
	at(() => {
		let f = l || Ln.root;
		if (Ln.getTreeNode(f.scopeRef) && Zt && !cv(Zt, f.scopeRef)) {
			let h = Ln.getTreeNode(Zt);
			h && (f = h);
		}
		f.addChild(u), Ln.addNode(u);
	}, [u, l]),
		at(() => {
			let f = Ln.getTreeNode(a);
			f && (f.contain = !!n);
		}, [n]),
		at(() => {
			var f;
			let h =
					(f = o.current) === null || f === void 0
						? void 0
						: f.nextSibling,
				p = [],
				g = (v) => v.stopPropagation();
			for (; h && h !== s.current; )
				p.push(h), h.addEventListener(iw, g), (h = h.nextSibling);
			return (
				(a.current = p),
				() => {
					for (let v of p) v.removeEventListener(iw, g);
				}
			);
		}, [e]),
		Xee(a, r, n),
		Gee(a, n),
		Qee(a, r, n),
		Jee(a, i),
		E.useEffect(() => {
			const f = Yt(a.current ? a.current[0] : void 0).activeElement;
			let h = null;
			if (Lr(f, a.current)) {
				for (let p of Ln.traverse())
					p.scopeRef && Lr(f, p.scopeRef.current) && (h = p);
				h === Ln.getTreeNode(a) && (Zt = h.scopeRef);
			}
		}, [a]),
		at(
			() => () => {
				var f, h, p;
				let g =
					(p =
						(h = Ln.getTreeNode(a)) === null ||
						h === void 0 ||
						(f = h.parent) === null ||
						f === void 0
							? void 0
							: f.scopeRef) !== null && p !== void 0
						? p
						: null;
				(a === Zt || cv(a, Zt)) &&
					(!g || Ln.getTreeNode(g)) &&
					(Zt = g),
					Ln.removeTreeNode(a);
			},
			[a],
		);
	let c = E.useMemo(() => Hee(a), []),
		d = E.useMemo(() => ({ focusManager: c, parentNode: u }), [u, c]);
	return le.createElement(
		v6.Provider,
		{ value: d },
		le.createElement("span", {
			"data-focus-scope-start": !0,
			hidden: !0,
			ref: o,
		}),
		e,
		le.createElement("span", {
			"data-focus-scope-end": !0,
			hidden: !0,
			ref: s,
		}),
	);
}
function Hee(t) {
	return {
		focusNext(e = {}) {
			let n = t.current,
				{ from: r, tabbable: i, wrap: o, accept: s } = e,
				a = r || Yt(n[0]).activeElement,
				l = n[0].previousElementSibling,
				u = Fc(n),
				c = rr(u, { tabbable: i, accept: s }, n);
			c.currentNode = Lr(a, n) ? a : l;
			let d = c.nextNode();
			return (
				!d && o && ((c.currentNode = l), (d = c.nextNode())),
				d && Ii(d, !0),
				d
			);
		},
		focusPrevious(e = {}) {
			let n = t.current,
				{ from: r, tabbable: i, wrap: o, accept: s } = e,
				a = r || Yt(n[0]).activeElement,
				l = n[n.length - 1].nextElementSibling,
				u = Fc(n),
				c = rr(u, { tabbable: i, accept: s }, n);
			c.currentNode = Lr(a, n) ? a : l;
			let d = c.previousNode();
			return (
				!d && o && ((c.currentNode = l), (d = c.previousNode())),
				d && Ii(d, !0),
				d
			);
		},
		focusFirst(e = {}) {
			let n = t.current,
				{ tabbable: r, accept: i } = e,
				o = Fc(n),
				s = rr(o, { tabbable: r, accept: i }, n);
			s.currentNode = n[0].previousElementSibling;
			let a = s.nextNode();
			return a && Ii(a, !0), a;
		},
		focusLast(e = {}) {
			let n = t.current,
				{ tabbable: r, accept: i } = e,
				o = Fc(n),
				s = rr(o, { tabbable: r, accept: i }, n);
			s.currentNode = n[n.length - 1].nextElementSibling;
			let a = s.previousNode();
			return a && Ii(a, !0), a;
		},
	};
}
const eD = [
		"input:not([disabled]):not([type=hidden])",
		"select:not([disabled])",
		"textarea:not([disabled])",
		"button:not([disabled])",
		"a[href]",
		"area[href]",
		"summary",
		"iframe",
		"object",
		"embed",
		"audio[controls]",
		"video[controls]",
		"[contenteditable]",
	],
	Wee =
		eD.join(":not([hidden]),") +
		",[tabindex]:not([disabled]):not([hidden])";
eD.push('[tabindex]:not([tabindex="-1"]):not([disabled])');
const qee = eD.join(':not([hidden]):not([tabindex="-1"]),');
function Fc(t) {
	return t[0].parentElement;
}
function Gp(t) {
	let e = Ln.getTreeNode(Zt);
	for (; e && e.scopeRef !== t; ) {
		if (e.contain) return !1;
		e = e.parent;
	}
	return !0;
}
function Gee(t, e) {
	let n = E.useRef(void 0),
		r = E.useRef(void 0);
	at(() => {
		let i = t.current;
		if (!e) {
			r.current &&
				(cancelAnimationFrame(r.current), (r.current = void 0));
			return;
		}
		const o = Yt(i ? i[0] : void 0);
		let s = (u) => {
				if (
					u.key !== "Tab" ||
					u.altKey ||
					u.ctrlKey ||
					u.metaKey ||
					!Gp(t) ||
					u.isComposing
				)
					return;
				let c = o.activeElement,
					d = t.current;
				if (!d || !Lr(c, d)) return;
				let f = Fc(d),
					h = rr(f, { tabbable: !0 }, d);
				if (!c) return;
				h.currentNode = c;
				let p = u.shiftKey ? h.previousNode() : h.nextNode();
				p ||
					((h.currentNode = u.shiftKey
						? d[d.length - 1].nextElementSibling
						: d[0].previousElementSibling),
					(p = u.shiftKey ? h.previousNode() : h.nextNode())),
					u.preventDefault(),
					p && Ii(p, !0);
			},
			a = (u) => {
				(!Zt || cv(Zt, t)) && Lr(u.target, t.current)
					? ((Zt = t), (n.current = u.target))
					: Gp(t) && !uv(u.target, t)
						? n.current
							? n.current.focus()
							: Zt && Zt.current && ow(Zt.current)
						: Gp(t) && (n.current = u.target);
			},
			l = (u) => {
				r.current && cancelAnimationFrame(r.current),
					(r.current = requestAnimationFrame(() => {
						if (o.activeElement && Gp(t) && !uv(o.activeElement, t))
							if (((Zt = t), o.body.contains(u.target))) {
								var c;
								(n.current = u.target),
									(c = n.current) === null ||
										c === void 0 ||
										c.focus();
							} else Zt.current && ow(Zt.current);
					}));
			};
		return (
			o.addEventListener("keydown", s, !1),
			o.addEventListener("focusin", a, !1),
			i == null || i.forEach((u) => u.addEventListener("focusin", a, !1)),
			i == null ||
				i.forEach((u) => u.addEventListener("focusout", l, !1)),
			() => {
				o.removeEventListener("keydown", s, !1),
					o.removeEventListener("focusin", a, !1),
					i == null ||
						i.forEach((u) =>
							u.removeEventListener("focusin", a, !1),
						),
					i == null ||
						i.forEach((u) =>
							u.removeEventListener("focusout", l, !1),
						);
			}
		);
	}, [t, e]),
		at(
			() => () => {
				r.current && cancelAnimationFrame(r.current);
			},
			[r],
		);
}
function S9(t) {
	return uv(t);
}
function Lr(t, e) {
	return !t || !e ? !1 : e.some((n) => n.contains(t));
}
function uv(t, e = null) {
	if (t instanceof Element && t.closest("[data-react-aria-top-layer]"))
		return !0;
	for (let { scopeRef: n } of Ln.traverse(Ln.getTreeNode(e)))
		if (n && Lr(t, n.current)) return !0;
	return !1;
}
function Yee(t) {
	return uv(t, Zt);
}
function cv(t, e) {
	var n;
	let r =
		(n = Ln.getTreeNode(e)) === null || n === void 0 ? void 0 : n.parent;
	for (; r; ) {
		if (r.scopeRef === t) return !0;
		r = r.parent;
	}
	return !1;
}
function Ii(t, e = !1) {
	if (t != null && !e)
		try {
			on(t);
		} catch {}
	else if (t != null)
		try {
			t.focus();
		} catch {}
}
function A9(t, e = !0) {
	let n = t[0].previousElementSibling,
		r = Fc(t),
		i = rr(r, { tabbable: e }, t);
	i.currentNode = n;
	let o = i.nextNode();
	return (
		e &&
			!o &&
			((r = Fc(t)),
			(i = rr(r, { tabbable: !1 }, t)),
			(i.currentNode = n),
			(o = i.nextNode())),
		o
	);
}
function ow(t, e = !0) {
	Ii(A9(t, e));
}
function Jee(t, e) {
	const n = le.useRef(e);
	E.useEffect(() => {
		if (n.current) {
			Zt = t;
			const r = Yt(t.current ? t.current[0] : void 0);
			!Lr(r.activeElement, Zt.current) && t.current && ow(t.current);
		}
		n.current = !1;
	}, [t]);
}
function Xee(t, e, n) {
	at(() => {
		if (e || n) return;
		let r = t.current;
		const i = Yt(r ? r[0] : void 0);
		let o = (s) => {
			let a = s.target;
			Lr(a, t.current) ? (Zt = t) : S9(a) || (Zt = null);
		};
		return (
			i.addEventListener("focusin", o, !1),
			r == null || r.forEach((s) => s.addEventListener("focusin", o, !1)),
			() => {
				i.removeEventListener("focusin", o, !1),
					r == null ||
						r.forEach((s) =>
							s.removeEventListener("focusin", o, !1),
						);
			}
		);
	}, [t, e, n]);
}
function Zee(t) {
	let e = Ln.getTreeNode(Zt);
	for (; e && e.scopeRef !== t; ) {
		if (e.nodeToRestore) return !1;
		e = e.parent;
	}
	return (e == null ? void 0 : e.scopeRef) === t;
}
function Qee(t, e, n) {
	const r = E.useRef(
		typeof document < "u"
			? Yt(t.current ? t.current[0] : void 0).activeElement
			: null,
	);
	at(() => {
		let i = t.current;
		const o = Yt(i ? i[0] : void 0);
		if (!e || n) return;
		let s = () => {
			(!Zt || cv(Zt, t)) && Lr(o.activeElement, t.current) && (Zt = t);
		};
		return (
			o.addEventListener("focusin", s, !1),
			i == null || i.forEach((a) => a.addEventListener("focusin", s, !1)),
			() => {
				o.removeEventListener("focusin", s, !1),
					i == null ||
						i.forEach((a) =>
							a.removeEventListener("focusin", s, !1),
						);
			}
		);
	}, [t, n]),
		at(() => {
			const i = Yt(t.current ? t.current[0] : void 0);
			if (!e) return;
			let o = (s) => {
				if (
					s.key !== "Tab" ||
					s.altKey ||
					s.ctrlKey ||
					s.metaKey ||
					!Gp(t) ||
					s.isComposing
				)
					return;
				let a = i.activeElement;
				if (!Lr(a, t.current)) return;
				let l = Ln.getTreeNode(t);
				if (!l) return;
				let u = l.nodeToRestore,
					c = rr(i.body, { tabbable: !0 });
				c.currentNode = a;
				let d = s.shiftKey ? c.previousNode() : c.nextNode();
				if (
					((!u || !i.body.contains(u) || u === i.body) &&
						((u = void 0), (l.nodeToRestore = void 0)),
					(!d || !Lr(d, t.current)) && u)
				) {
					c.currentNode = u;
					do d = s.shiftKey ? c.previousNode() : c.nextNode();
					while (Lr(d, t.current));
					s.preventDefault(),
						s.stopPropagation(),
						d ? Ii(d, !0) : S9(u) ? Ii(u, !0) : a.blur();
				}
			};
			return (
				n || i.addEventListener("keydown", o, !0),
				() => {
					n || i.removeEventListener("keydown", o, !0);
				}
			);
		}, [t, e, n]),
		at(() => {
			const i = Yt(t.current ? t.current[0] : void 0);
			if (!e) return;
			let o = Ln.getTreeNode(t);
			if (o) {
				var s;
				return (
					(o.nodeToRestore =
						(s = r.current) !== null && s !== void 0 ? s : void 0),
					() => {
						let a = Ln.getTreeNode(t);
						if (!a) return;
						let l = a.nodeToRestore;
						if (
							e &&
							l &&
							(Lr(i.activeElement, t.current) ||
								(i.activeElement === i.body && Zee(t)))
						) {
							let u = Ln.clone();
							requestAnimationFrame(() => {
								if (i.activeElement === i.body) {
									let c = u.getTreeNode(t);
									for (; c; ) {
										if (
											c.nodeToRestore &&
											c.nodeToRestore.isConnected
										) {
											y6(c.nodeToRestore);
											return;
										}
										c = c.parent;
									}
									for (c = u.getTreeNode(t); c; ) {
										if (
											c.scopeRef &&
											c.scopeRef.current &&
											Ln.getTreeNode(c.scopeRef)
										) {
											let d = A9(c.scopeRef.current, !0);
											y6(d);
											return;
										}
										c = c.parent;
									}
								}
							});
						}
					}
				);
			}
		}, [t, e]);
}
function y6(t) {
	t.dispatchEvent(new CustomEvent(iw, { bubbles: !0, cancelable: !0 })) &&
		Ii(t);
}
function rr(t, e, n) {
	let r = e != null && e.tabbable ? qee : Wee,
		i = Yt(t).createTreeWalker(t, NodeFilter.SHOW_ELEMENT, {
			acceptNode(o) {
				var s;
				return !(e == null || (s = e.from) === null || s === void 0) &&
					s.contains(o)
					? NodeFilter.FILTER_REJECT
					: o.matches(r) &&
						  D9(o) &&
						  (!n || Lr(o, n)) &&
						  (!(e != null && e.accept) || e.accept(o))
						? NodeFilter.FILTER_ACCEPT
						: NodeFilter.FILTER_SKIP;
			},
		});
	return e != null && e.from && (i.currentNode = e.from), i;
}
function $9(t, e = {}) {
	return {
		focusNext(n = {}) {
			let r = t.current;
			if (!r) return null;
			let {
					from: i,
					tabbable: o = e.tabbable,
					wrap: s = e.wrap,
					accept: a = e.accept,
				} = n,
				l = i || Yt(r).activeElement,
				u = rr(r, { tabbable: o, accept: a });
			r.contains(l) && (u.currentNode = l);
			let c = u.nextNode();
			return (
				!c && s && ((u.currentNode = r), (c = u.nextNode())),
				c && Ii(c, !0),
				c
			);
		},
		focusPrevious(n = e) {
			let r = t.current;
			if (!r) return null;
			let {
					from: i,
					tabbable: o = e.tabbable,
					wrap: s = e.wrap,
					accept: a = e.accept,
				} = n,
				l = i || Yt(r).activeElement,
				u = rr(r, { tabbable: o, accept: a });
			if (r.contains(l)) u.currentNode = l;
			else {
				let d = w4(u);
				return d && Ii(d, !0), d ?? null;
			}
			let c = u.previousNode();
			if (!c && s) {
				u.currentNode = r;
				let d = w4(u);
				if (!d) return null;
				c = d;
			}
			return c && Ii(c, !0), c ?? null;
		},
		focusFirst(n = e) {
			let r = t.current;
			if (!r) return null;
			let { tabbable: i = e.tabbable, accept: o = e.accept } = n,
				a = rr(r, { tabbable: i, accept: o }).nextNode();
			return a && Ii(a, !0), a;
		},
		focusLast(n = e) {
			let r = t.current;
			if (!r) return null;
			let { tabbable: i = e.tabbable, accept: o = e.accept } = n,
				s = rr(r, { tabbable: i, accept: o }),
				a = w4(s);
			return a && Ii(a, !0), a ?? null;
		},
	};
}
function w4(t) {
	let e, n;
	do (n = t.lastChild()), n && (e = n);
	while (n);
	return e;
}
class tD {
	get size() {
		return this.fastMap.size;
	}
	getTreeNode(e) {
		return this.fastMap.get(e);
	}
	addTreeNode(e, n, r) {
		let i = this.fastMap.get(n ?? null);
		if (!i) return;
		let o = new sw({ scopeRef: e });
		i.addChild(o),
			(o.parent = i),
			this.fastMap.set(e, o),
			r && (o.nodeToRestore = r);
	}
	addNode(e) {
		this.fastMap.set(e.scopeRef, e);
	}
	removeTreeNode(e) {
		if (e === null) return;
		let n = this.fastMap.get(e);
		if (!n) return;
		let r = n.parent;
		for (let o of this.traverse())
			o !== n &&
				n.nodeToRestore &&
				o.nodeToRestore &&
				n.scopeRef &&
				n.scopeRef.current &&
				Lr(o.nodeToRestore, n.scopeRef.current) &&
				(o.nodeToRestore = n.nodeToRestore);
		let i = n.children;
		r &&
			(r.removeChild(n),
			i.size > 0 && i.forEach((o) => r && r.addChild(o))),
			this.fastMap.delete(n.scopeRef);
	}
	*traverse(e = this.root) {
		if ((e.scopeRef != null && (yield e), e.children.size > 0))
			for (let n of e.children) yield* this.traverse(n);
	}
	clone() {
		var e;
		let n = new tD();
		var r;
		for (let i of this.traverse())
			n.addTreeNode(
				i.scopeRef,
				(r =
					(e = i.parent) === null || e === void 0
						? void 0
						: e.scopeRef) !== null && r !== void 0
					? r
					: null,
				i.nodeToRestore,
			);
		return n;
	}
	constructor() {
		(this.fastMap = new Map()),
			(this.root = new sw({ scopeRef: null })),
			this.fastMap.set(null, this.root);
	}
}
class sw {
	addChild(e) {
		this.children.add(e), (e.parent = this);
	}
	removeChild(e) {
		this.children.delete(e), (e.parent = void 0);
	}
	constructor(e) {
		(this.children = new Set()),
			(this.contain = !1),
			(this.scopeRef = e.scopeRef);
	}
}
let Ln = new tD();
function ha(t = {}) {
	let { autoFocus: e = !1, isTextInput: n, within: r } = t,
		i = E.useRef({ isFocused: !1, isFocusVisible: e || ml() }),
		[o, s] = E.useState(!1),
		[a, l] = E.useState(
			() => i.current.isFocused && i.current.isFocusVisible,
		),
		u = E.useCallback(
			() => l(i.current.isFocused && i.current.isFocusVisible),
			[],
		),
		c = E.useCallback(
			(h) => {
				(i.current.isFocused = h), s(h), u();
			},
			[u],
		);
	Mee(
		(h) => {
			(i.current.isFocusVisible = h), u();
		},
		[],
		{ isTextInput: n },
	);
	let { focusProps: d } = cx({ isDisabled: r, onFocusChange: c }),
		{ focusWithinProps: f } = Ud({
			isDisabled: !r,
			onFocusWithinChange: c,
		});
	return { isFocused: o, isFocusVisible: a, focusProps: r ? f : d };
}
function ete(t) {
	let { children: e, focusClass: n, focusRingClass: r } = t,
		{ isFocused: i, isFocusVisible: o, focusProps: s } = ha(t),
		a = le.Children.only(e);
	return le.cloneElement(
		a,
		xe(a.props, { ...s, className: Q8({ [n || ""]: i, [r || ""]: o }) }),
	);
}
let T9 = le.createContext(null);
function tte(t) {
	let e = E.useContext(T9) || {};
	lx(e, t);
	let { ref: n, ...r } = e;
	return r;
}
function nte(t, e) {
	let { children: n, ...r } = t,
		i = Ct(e),
		o = { ...r, ref: i };
	return le.createElement(T9.Provider, { value: o }, n);
}
let rte = le.forwardRef(nte);
function Hd(t, e) {
	let { focusProps: n } = cx(t),
		{ keyboardProps: r } = hx(t),
		i = xe(n, r),
		o = tte(e),
		s = t.isDisabled ? {} : o,
		a = E.useRef(t.autoFocus);
	return (
		E.useEffect(() => {
			a.current && e.current && on(e.current), (a.current = !1);
		}, [e]),
		{
			focusableProps: xe(
				{
					...i,
					tabIndex:
						t.excludeFromTabOrder && !t.isDisabled ? -1 : void 0,
				},
				s,
			),
		}
	);
}
function B9(t, e) {
	let n = e == null ? void 0 : e.isDisabled,
		[r, i] = E.useState(!1);
	return (
		at(() => {
			if (t != null && t.current && !n) {
				let o = () => {
					if (t.current) {
						let a = rr(t.current, { tabbable: !0 });
						i(!!a.nextNode());
					}
				};
				o();
				let s = new MutationObserver(o);
				return (
					s.observe(t.current, {
						subtree: !0,
						childList: !0,
						attributes: !0,
						attributeFilter: ["tabIndex", "disabled"],
					}),
					() => {
						s.disconnect();
					}
				);
			}
		}),
		n ? !1 : r
	);
}
const Ma = [];
function nD(t, e) {
	let {
		onClose: n,
		shouldCloseOnBlur: r,
		isOpen: i,
		isDismissable: o = !1,
		isKeyboardDismissDisabled: s = !1,
		shouldCloseOnInteractOutside: a,
	} = t;
	E.useEffect(
		() => (
			i && Ma.push(e),
			() => {
				let p = Ma.indexOf(e);
				p >= 0 && Ma.splice(p, 1);
			}
		),
		[i, e],
	);
	let l = () => {
			Ma[Ma.length - 1] === e && n && n();
		},
		u = (p) => {
			(!a || a(p.target)) &&
				Ma[Ma.length - 1] === e &&
				(p.stopPropagation(), p.preventDefault());
		},
		c = (p) => {
			(!a || a(p.target)) &&
				(Ma[Ma.length - 1] === e &&
					(p.stopPropagation(), p.preventDefault()),
				l());
		},
		d = (p) => {
			p.key === "Escape" &&
				!s &&
				!p.nativeEvent.isComposing &&
				(p.stopPropagation(), p.preventDefault(), l());
		};
	_ee({
		ref: e,
		onInteractOutside: o && i ? c : null,
		onInteractOutsideStart: u,
	});
	let { focusWithinProps: f } = Ud({
			isDisabled: !r,
			onBlurWithin: (p) => {
				!p.relatedTarget ||
					Yee(p.relatedTarget) ||
					((!a || a(p.relatedTarget)) && n());
			},
		}),
		h = (p) => {
			p.target === p.currentTarget && p.preventDefault();
		};
	return {
		overlayProps: { onKeyDown: d, ...f },
		underlayProps: { onPointerDown: h },
	};
}
function px(t, e, n) {
	let { type: r } = t,
		{ isOpen: i } = e;
	E.useEffect(() => {
		n && n.current && g9.set(n.current, e.close);
	});
	let o;
	r === "menu" ? (o = !0) : r === "listbox" && (o = "listbox");
	let s = Ot();
	return {
		triggerProps: {
			"aria-haspopup": o,
			"aria-expanded": i,
			"aria-controls": i ? s : null,
			onPress: e.toggle,
		},
		overlayProps: { id: s },
	};
}
const E4 = typeof document < "u" && window.visualViewport,
	ite = new Set([
		"checkbox",
		"radio",
		"range",
		"color",
		"file",
		"image",
		"button",
		"submit",
		"reset",
	]);
let h1 = 0,
	D4;
function I9(t = {}) {
	let { isDisabled: e } = t;
	at(() => {
		if (!e)
			return (
				h1++,
				h1 === 1 && (Vh() ? (D4 = ste()) : (D4 = ote())),
				() => {
					h1--, h1 === 0 && D4();
				}
			);
	}, [e]);
}
function ote() {
	return hr(
		Of(
			document.documentElement,
			"paddingRight",
			`${window.innerWidth - document.documentElement.clientWidth}px`,
		),
		Of(document.documentElement, "overflow", "hidden"),
	);
}
function ste() {
	let t,
		e,
		n = (u) => {
			(t = li(u.target, !0)),
				!(t === document.documentElement && t === document.body) &&
					t instanceof HTMLElement &&
					window.getComputedStyle(t).overscrollBehavior === "auto" &&
					(e = Of(t, "overscrollBehavior", "contain"));
		},
		r = (u) => {
			if (!t || t === document.documentElement || t === document.body) {
				u.preventDefault();
				return;
			}
			t.scrollHeight === t.clientHeight &&
				t.scrollWidth === t.clientWidth &&
				u.preventDefault();
		},
		i = (u) => {
			let c = u.target;
			k6(c) &&
				c !== document.activeElement &&
				(u.preventDefault(),
				a(),
				(c.style.transform = "translateY(-2000px)"),
				c.focus(),
				requestAnimationFrame(() => {
					c.style.transform = "";
				})),
				e && e();
		},
		o = (u) => {
			let c = u.target;
			k6(c) &&
				(a(),
				(c.style.transform = "translateY(-2000px)"),
				requestAnimationFrame(() => {
					(c.style.transform = ""),
						E4 &&
							(E4.height < window.innerHeight
								? requestAnimationFrame(() => {
										x6(c);
									})
								: E4.addEventListener("resize", () => x6(c), {
										once: !0,
									}));
				}));
		},
		s = null,
		a = () => {
			if (s) return;
			let u = () => {
					window.scrollTo(0, 0);
				},
				c = window.pageXOffset,
				d = window.pageYOffset;
			(s = hr(
				Dp(window, "scroll", u),
				Of(
					document.documentElement,
					"paddingRight",
					`${window.innerWidth - document.documentElement.clientWidth}px`,
				),
				Of(document.documentElement, "overflow", "hidden"),
				Of(document.body, "marginTop", `-${d}px`),
				() => {
					window.scrollTo(c, d);
				},
			)),
				window.scrollTo(0, 0);
		},
		l = hr(
			Dp(document, "touchstart", n, { passive: !1, capture: !0 }),
			Dp(document, "touchmove", r, { passive: !1, capture: !0 }),
			Dp(document, "touchend", i, { passive: !1, capture: !0 }),
			Dp(document, "focus", o, !0),
		);
	return () => {
		e == null || e(), s == null || s(), l();
	};
}
function Of(t, e, n) {
	let r = t.style[e];
	return (
		(t.style[e] = n),
		() => {
			t.style[e] = r;
		}
	);
}
function Dp(t, e, n, r) {
	return (
		t.addEventListener(e, n, r),
		() => {
			t.removeEventListener(e, n, r);
		}
	);
}
function x6(t) {
	let e = document.scrollingElement || document.documentElement;
	for (; t && t !== e; ) {
		let n = li(t);
		if (n !== document.documentElement && n !== document.body && n !== t) {
			let r = n.getBoundingClientRect().top,
				i = t.getBoundingClientRect().top;
			i > r + t.clientHeight && (n.scrollTop += i - r);
		}
		t = n.parentElement;
	}
}
function k6(t) {
	return (
		(t instanceof HTMLInputElement && !ite.has(t.type)) ||
		t instanceof HTMLTextAreaElement ||
		(t instanceof HTMLElement && t.isContentEditable)
	);
}
const aw = le.createContext(null);
function ate(t) {
	let { children: e } = t,
		n = E.useContext(aw),
		[r, i] = E.useState(0),
		o = E.useMemo(
			() => ({
				parent: n,
				modalCount: r,
				addModal() {
					i((s) => s + 1), n && n.addModal();
				},
				removeModal() {
					i((s) => s - 1), n && n.removeModal();
				},
			}),
			[n, r],
		);
	return le.createElement(aw.Provider, { value: o }, e);
}
function lte() {
	let t = E.useContext(aw);
	return {
		modalProviderProps: {
			"aria-hidden": t && t.modalCount > 0 ? !0 : null,
		},
	};
}
var F9 = {};
F9 = { dismiss: "تجاهل" };
var P9 = {};
P9 = { dismiss: "Отхвърляне" };
var N9 = {};
N9 = { dismiss: "Odstranit" };
var R9 = {};
R9 = { dismiss: "Luk" };
var O9 = {};
O9 = { dismiss: "Schließen" };
var M9 = {};
M9 = { dismiss: "Απόρριψη" };
var j9 = {};
j9 = { dismiss: "Dismiss" };
var _9 = {};
_9 = { dismiss: "Descartar" };
var z9 = {};
z9 = { dismiss: "Lõpeta" };
var L9 = {};
L9 = { dismiss: "Hylkää" };
var V9 = {};
V9 = { dismiss: "Rejeter" };
var K9 = {};
K9 = { dismiss: "התעלם" };
var U9 = {};
U9 = { dismiss: "Odbaci" };
var H9 = {};
H9 = { dismiss: "Elutasítás" };
var W9 = {};
W9 = { dismiss: "Ignora" };
var q9 = {};
q9 = { dismiss: "閉じる" };
var G9 = {};
G9 = { dismiss: "무시" };
var Y9 = {};
Y9 = { dismiss: "Atmesti" };
var J9 = {};
J9 = { dismiss: "Nerādīt" };
var X9 = {};
X9 = { dismiss: "Lukk" };
var Z9 = {};
Z9 = { dismiss: "Negeren" };
var Q9 = {};
Q9 = { dismiss: "Zignoruj" };
var eP = {};
eP = { dismiss: "Descartar" };
var tP = {};
tP = { dismiss: "Dispensar" };
var nP = {};
nP = { dismiss: "Revocare" };
var rP = {};
rP = { dismiss: "Пропустить" };
var iP = {};
iP = { dismiss: "Zrušiť" };
var oP = {};
oP = { dismiss: "Opusti" };
var sP = {};
sP = { dismiss: "Odbaci" };
var aP = {};
aP = { dismiss: "Avvisa" };
var lP = {};
lP = { dismiss: "Kapat" };
var uP = {};
uP = { dismiss: "Скасувати" };
var cP = {};
cP = { dismiss: "取消" };
var dP = {};
dP = { dismiss: "關閉" };
var fP = {};
fP = {
	"ar-AE": F9,
	"bg-BG": P9,
	"cs-CZ": N9,
	"da-DK": R9,
	"de-DE": O9,
	"el-GR": M9,
	"en-US": j9,
	"es-ES": _9,
	"et-EE": z9,
	"fi-FI": L9,
	"fr-FR": V9,
	"he-IL": K9,
	"hr-HR": U9,
	"hu-HU": H9,
	"it-IT": W9,
	"ja-JP": q9,
	"ko-KR": G9,
	"lt-LT": Y9,
	"lv-LV": J9,
	"nb-NO": X9,
	"nl-NL": Z9,
	"pl-PL": Q9,
	"pt-BR": eP,
	"pt-PT": tP,
	"ro-RO": nP,
	"ru-RU": rP,
	"sk-SK": iP,
	"sl-SI": oP,
	"sr-SP": sP,
	"sv-SE": aP,
	"tr-TR": lP,
	"uk-UA": uP,
	"zh-CN": cP,
	"zh-TW": dP,
};
const C6 = {
	border: 0,
	clip: "rect(0 0 0 0)",
	clipPath: "inset(50%)",
	height: "1px",
	margin: "-1px",
	overflow: "hidden",
	padding: 0,
	position: "absolute",
	width: "1px",
	whiteSpace: "nowrap",
};
function Ea(t = {}) {
	let { style: e, isFocusable: n } = t,
		[r, i] = E.useState(!1),
		{ focusWithinProps: o } = Ud({
			isDisabled: !n,
			onFocusWithinChange: (a) => i(a),
		}),
		s = E.useMemo(() => (r ? e : e ? { ...C6, ...e } : C6), [r]);
	return { visuallyHiddenProps: { ...o, style: s } };
}
function l0(t) {
	let {
			children: e,
			elementType: n = "div",
			isFocusable: r,
			style: i,
			...o
		} = t,
		{ visuallyHiddenProps: s } = Ea(t);
	return le.createElement(n, xe(o, s), e);
}
function ute(t) {
	return t && t.__esModule ? t.default : t;
}
function Hm(t) {
	let { onDismiss: e, ...n } = t,
		r = Le(ute(fP), "@react-aria/overlays"),
		i = tv(n, r.format("dismiss")),
		o = () => {
			e && e();
		};
	return le.createElement(
		l0,
		null,
		le.createElement("button", {
			...i,
			tabIndex: -1,
			onClick: o,
			style: { width: 1, height: 1 },
		}),
	);
}
let Sp = new WeakMap(),
	ko = [];
function mx(t, e = document.body) {
	let n = new Set(t),
		r = new Set(),
		i = (l) => {
			for (let f of l.querySelectorAll(
				"[data-live-announcer], [data-react-aria-top-layer]",
			))
				n.add(f);
			let u = (f) => {
					if (
						n.has(f) ||
						(r.has(f.parentElement) &&
							f.parentElement.getAttribute("role") !== "row")
					)
						return NodeFilter.FILTER_REJECT;
					for (let h of n)
						if (f.contains(h)) return NodeFilter.FILTER_SKIP;
					return NodeFilter.FILTER_ACCEPT;
				},
				c = document.createTreeWalker(l, NodeFilter.SHOW_ELEMENT, {
					acceptNode: u,
				}),
				d = u(l);
			if (
				(d === NodeFilter.FILTER_ACCEPT && o(l),
				d !== NodeFilter.FILTER_REJECT)
			) {
				let f = c.nextNode();
				for (; f != null; ) o(f), (f = c.nextNode());
			}
		},
		o = (l) => {
			var u;
			let c = (u = Sp.get(l)) !== null && u !== void 0 ? u : 0;
			(l.getAttribute("aria-hidden") === "true" && c === 0) ||
				(c === 0 && l.setAttribute("aria-hidden", "true"),
				r.add(l),
				Sp.set(l, c + 1));
		};
	ko.length && ko[ko.length - 1].disconnect(), i(e);
	let s = new MutationObserver((l) => {
		for (let u of l)
			if (
				!(u.type !== "childList" || u.addedNodes.length === 0) &&
				![...n, ...r].some((c) => c.contains(u.target))
			) {
				for (let c of u.removedNodes)
					c instanceof Element && (n.delete(c), r.delete(c));
				for (let c of u.addedNodes)
					(c instanceof HTMLElement || c instanceof SVGElement) &&
					(c.dataset.liveAnnouncer === "true" ||
						c.dataset.reactAriaTopLayer === "true")
						? n.add(c)
						: c instanceof Element && i(c);
			}
	});
	s.observe(e, { childList: !0, subtree: !0 });
	let a = {
		observe() {
			s.observe(e, { childList: !0, subtree: !0 });
		},
		disconnect() {
			s.disconnect();
		},
	};
	return (
		ko.push(a),
		() => {
			s.disconnect();
			for (let l of r) {
				let u = Sp.get(l);
				u === 1
					? (l.removeAttribute("aria-hidden"), Sp.delete(l))
					: Sp.set(l, u - 1);
			}
			a === ko[ko.length - 1]
				? (ko.pop(), ko.length && ko[ko.length - 1].observe())
				: ko.splice(ko.indexOf(a), 1);
		}
	);
}
function cte(t, e) {
	let {
			triggerRef: n,
			popoverRef: r,
			isNonModal: i,
			isKeyboardDismissDisabled: o,
			shouldCloseOnInteractOutside: s,
			...a
		} = t,
		{ overlayProps: l, underlayProps: u } = nD(
			{
				isOpen: e.isOpen,
				onClose: e.close,
				shouldCloseOnBlur: !0,
				isDismissable: !i,
				isKeyboardDismissDisabled: o,
				shouldCloseOnInteractOutside: s,
			},
			r,
		),
		{
			overlayProps: c,
			arrowProps: d,
			placement: f,
		} = ZE({
			...a,
			targetRef: n,
			overlayRef: r,
			isOpen: e.isOpen,
			onClose: i ? e.close : null,
		});
	return (
		I9({ isDisabled: i || !e.isOpen }),
		at(() => {
			if (e.isOpen && !i && r.current) return mx([r.current]);
		}, [i, e.isOpen, r]),
		{
			popoverProps: xe(l, c),
			arrowProps: d,
			underlayProps: u,
			placement: f,
		}
	);
}
const dte = E.createContext({});
function hP() {
	var t;
	return (t = E.useContext(dte)) !== null && t !== void 0 ? t : {};
}
const pP = le.createContext(null);
function fte(t) {
	let e = Vd(),
		{ portalContainer: n = e ? null : document.body, isExiting: r } = t,
		[i, o] = E.useState(!1),
		s = E.useMemo(() => ({ contain: i, setContain: o }), [i, o]),
		{ getContainer: a } = hP();
	if ((!t.portalContainer && a && (n = a()), !n)) return null;
	let l = t.children;
	return (
		t.disableFocusManagement ||
			(l = le.createElement(
				nc,
				{ restoreFocus: !0, contain: i && !r },
				l,
			)),
		(l = le.createElement(
			pP.Provider,
			{ value: s },
			le.createElement(Bee, null, l),
		)),
		ix.createPortal(l, n)
	);
}
function mP() {
	let t = E.useContext(pP),
		e = t == null ? void 0 : t.setContain;
	at(() => {
		e == null || e(!0);
	}, [e]);
}
function rD(t, e, n) {
	let { overlayProps: r, underlayProps: i } = nD(
		{ ...t, isOpen: e.isOpen, onClose: e.close },
		n,
	);
	return (
		I9({ isDisabled: !e.isOpen }),
		mP(),
		E.useEffect(() => {
			if (e.isOpen) return mx([n.current]);
		}, [e.isOpen, n]),
		{ modalProps: xe(r), underlayProps: i }
	);
}
var hte = !1;
function pte(t) {
	if (t.sheet) return t.sheet;
	for (var e = 0; e < document.styleSheets.length; e++)
		if (document.styleSheets[e].ownerNode === t)
			return document.styleSheets[e];
}
function mte(t) {
	var e = document.createElement("style");
	return (
		e.setAttribute("data-emotion", t.key),
		t.nonce !== void 0 && e.setAttribute("nonce", t.nonce),
		e.appendChild(document.createTextNode("")),
		e.setAttribute("data-s", ""),
		e
	);
}
var gte = (function () {
		function t(n) {
			var r = this;
			(this._insertTag = function (i) {
				var o;
				r.tags.length === 0
					? r.insertionPoint
						? (o = r.insertionPoint.nextSibling)
						: r.prepend
							? (o = r.container.firstChild)
							: (o = r.before)
					: (o = r.tags[r.tags.length - 1].nextSibling),
					r.container.insertBefore(i, o),
					r.tags.push(i);
			}),
				(this.isSpeedy = n.speedy === void 0 ? !hte : n.speedy),
				(this.tags = []),
				(this.ctr = 0),
				(this.nonce = n.nonce),
				(this.key = n.key),
				(this.container = n.container),
				(this.prepend = n.prepend),
				(this.insertionPoint = n.insertionPoint),
				(this.before = null);
		}
		var e = t.prototype;
		return (
			(e.hydrate = function (r) {
				r.forEach(this._insertTag);
			}),
			(e.insert = function (r) {
				this.ctr % (this.isSpeedy ? 65e3 : 1) === 0 &&
					this._insertTag(mte(this));
				var i = this.tags[this.tags.length - 1];
				if (this.isSpeedy) {
					var o = pte(i);
					try {
						o.insertRule(r, o.cssRules.length);
					} catch {}
				} else i.appendChild(document.createTextNode(r));
				this.ctr++;
			}),
			(e.flush = function () {
				this.tags.forEach(function (r) {
					var i;
					return (i = r.parentNode) == null
						? void 0
						: i.removeChild(r);
				}),
					(this.tags = []),
					(this.ctr = 0);
			}),
			t
		);
	})(),
	Rr = "-ms-",
	dv = "-moz-",
	Nt = "-webkit-",
	gP = "comm",
	iD = "rule",
	oD = "decl",
	bte = "@import",
	bP = "@keyframes",
	vte = "@layer",
	yte = Math.abs,
	gx = String.fromCharCode,
	xte = Object.assign;
function kte(t, e) {
	return Sr(t, 0) ^ 45
		? (((((((e << 2) ^ Sr(t, 0)) << 2) ^ Sr(t, 1)) << 2) ^ Sr(t, 2)) << 2) ^
				Sr(t, 3)
		: 0;
}
function vP(t) {
	return t.trim();
}
function Cte(t, e) {
	return (t = e.exec(t)) ? t[0] : t;
}
function Rt(t, e, n) {
	return t.replace(e, n);
}
function lw(t, e) {
	return t.indexOf(e);
}
function Sr(t, e) {
	return t.charCodeAt(e) | 0;
}
function Wm(t, e, n) {
	return t.slice(e, n);
}
function Js(t) {
	return t.length;
}
function sD(t) {
	return t.length;
}
function p1(t, e) {
	return e.push(t), t;
}
function wte(t, e) {
	return t.map(e).join("");
}
var bx = 1,
	vh = 1,
	yP = 0,
	Li = 0,
	Vn = 0,
	Kh = "";
function vx(t, e, n, r, i, o, s) {
	return {
		value: t,
		root: e,
		parent: n,
		type: r,
		props: i,
		children: o,
		line: bx,
		column: vh,
		length: s,
		return: "",
	};
}
function Ap(t, e) {
	return xte(
		vx("", null, null, "", null, null, 0),
		t,
		{ length: -t.length },
		e,
	);
}
function Ete() {
	return Vn;
}
function Dte() {
	return (
		(Vn = Li > 0 ? Sr(Kh, --Li) : 0),
		vh--,
		Vn === 10 && ((vh = 1), bx--),
		Vn
	);
}
function oo() {
	return (
		(Vn = Li < yP ? Sr(Kh, Li++) : 0),
		vh++,
		Vn === 10 && ((vh = 1), bx++),
		Vn
	);
}
function na() {
	return Sr(Kh, Li);
}
function rb() {
	return Li;
}
function u0(t, e) {
	return Wm(Kh, t, e);
}
function qm(t) {
	switch (t) {
		case 0:
		case 9:
		case 10:
		case 13:
		case 32:
			return 5;
		case 33:
		case 43:
		case 44:
		case 47:
		case 62:
		case 64:
		case 126:
		case 59:
		case 123:
		case 125:
			return 4;
		case 58:
			return 3;
		case 34:
		case 39:
		case 40:
		case 91:
			return 2;
		case 41:
		case 93:
			return 1;
	}
	return 0;
}
function xP(t) {
	return (bx = vh = 1), (yP = Js((Kh = t))), (Li = 0), [];
}
function kP(t) {
	return (Kh = ""), t;
}
function ib(t) {
	return vP(u0(Li - 1, uw(t === 91 ? t + 2 : t === 40 ? t + 1 : t)));
}
function Ste(t) {
	for (; (Vn = na()) && Vn < 33; ) oo();
	return qm(t) > 2 || qm(Vn) > 3 ? "" : " ";
}
function Ate(t, e) {
	for (
		;
		--e &&
		oo() &&
		!(Vn < 48 || Vn > 102 || (Vn > 57 && Vn < 65) || (Vn > 70 && Vn < 97));

	);
	return u0(t, rb() + (e < 6 && na() == 32 && oo() == 32));
}
function uw(t) {
	for (; oo(); )
		switch (Vn) {
			case t:
				return Li;
			case 34:
			case 39:
				t !== 34 && t !== 39 && uw(Vn);
				break;
			case 40:
				t === 41 && uw(t);
				break;
			case 92:
				oo();
				break;
		}
	return Li;
}
function $te(t, e) {
	for (; oo() && t + Vn !== 57; ) if (t + Vn === 84 && na() === 47) break;
	return "/*" + u0(e, Li - 1) + "*" + gx(t === 47 ? t : oo());
}
function Tte(t) {
	for (; !qm(na()); ) oo();
	return u0(t, Li);
}
function Bte(t) {
	return kP(ob("", null, null, null, [""], (t = xP(t)), 0, [0], t));
}
function ob(t, e, n, r, i, o, s, a, l) {
	for (
		var u = 0,
			c = 0,
			d = s,
			f = 0,
			h = 0,
			p = 0,
			g = 1,
			v = 1,
			b = 1,
			y = 0,
			x = "",
			C = i,
			k = o,
			w = r,
			D = x;
		v;

	)
		switch (((p = y), (y = oo()))) {
			case 40:
				if (p != 108 && Sr(D, d - 1) == 58) {
					lw((D += Rt(ib(y), "&", "&\f")), "&\f") != -1 && (b = -1);
					break;
				}
			case 34:
			case 39:
			case 91:
				D += ib(y);
				break;
			case 9:
			case 10:
			case 13:
			case 32:
				D += Ste(p);
				break;
			case 92:
				D += Ate(rb() - 1, 7);
				continue;
			case 47:
				switch (na()) {
					case 42:
					case 47:
						p1(Ite($te(oo(), rb()), e, n), l);
						break;
					default:
						D += "/";
				}
				break;
			case 123 * g:
				a[u++] = Js(D) * b;
			case 125 * g:
			case 59:
			case 0:
				switch (y) {
					case 0:
					case 125:
						v = 0;
					case 59 + c:
						b == -1 && (D = Rt(D, /\f/g, "")),
							h > 0 &&
								Js(D) - d &&
								p1(
									h > 32
										? E6(D + ";", r, n, d - 1)
										: E6(Rt(D, " ", "") + ";", r, n, d - 2),
									l,
								);
						break;
					case 59:
						D += ";";
					default:
						if (
							(p1(
								(w = w6(
									D,
									e,
									n,
									u,
									c,
									i,
									a,
									x,
									(C = []),
									(k = []),
									d,
								)),
								o,
							),
							y === 123)
						)
							if (c === 0) ob(D, e, w, w, C, o, d, a, k);
							else
								switch (
									f === 99 && Sr(D, 3) === 110 ? 100 : f
								) {
									case 100:
									case 108:
									case 109:
									case 115:
										ob(
											t,
											w,
											w,
											r &&
												p1(
													w6(
														t,
														w,
														w,
														0,
														0,
														i,
														a,
														x,
														i,
														(C = []),
														d,
													),
													k,
												),
											i,
											k,
											d,
											a,
											r ? C : k,
										);
										break;
									default:
										ob(D, w, w, w, [""], k, 0, a, k);
								}
				}
				(u = c = h = 0), (g = b = 1), (x = D = ""), (d = s);
				break;
			case 58:
				(d = 1 + Js(D)), (h = p);
			default:
				if (g < 1) {
					if (y == 123) --g;
					else if (y == 125 && g++ == 0 && Dte() == 125) continue;
				}
				switch (((D += gx(y)), y * g)) {
					case 38:
						b = c > 0 ? 1 : ((D += "\f"), -1);
						break;
					case 44:
						(a[u++] = (Js(D) - 1) * b), (b = 1);
						break;
					case 64:
						na() === 45 && (D += ib(oo())),
							(f = na()),
							(c = d = Js((x = D += Tte(rb())))),
							y++;
						break;
					case 45:
						p === 45 && Js(D) == 2 && (g = 0);
				}
		}
	return o;
}
function w6(t, e, n, r, i, o, s, a, l, u, c) {
	for (
		var d = i - 1, f = i === 0 ? o : [""], h = sD(f), p = 0, g = 0, v = 0;
		p < r;
		++p
	)
		for (
			var b = 0, y = Wm(t, d + 1, (d = yte((g = s[p])))), x = t;
			b < h;
			++b
		)
			(x = vP(g > 0 ? f[b] + " " + y : Rt(y, /&\f/g, f[b]))) &&
				(l[v++] = x);
	return vx(t, e, n, i === 0 ? iD : a, l, u, c);
}
function Ite(t, e, n) {
	return vx(t, e, n, gP, gx(Ete()), Wm(t, 2, -2), 0);
}
function E6(t, e, n, r) {
	return vx(t, e, n, oD, Wm(t, 0, r), Wm(t, r + 1, -1), r);
}
function eh(t, e) {
	for (var n = "", r = sD(t), i = 0; i < r; i++) n += e(t[i], i, t, e) || "";
	return n;
}
function Fte(t, e, n, r) {
	switch (t.type) {
		case vte:
			if (t.children.length) break;
		case bte:
		case oD:
			return (t.return = t.return || t.value);
		case gP:
			return "";
		case bP:
			return (t.return = t.value + "{" + eh(t.children, r) + "}");
		case iD:
			t.value = t.props.join(",");
	}
	return Js((n = eh(t.children, r)))
		? (t.return = t.value + "{" + n + "}")
		: "";
}
function Pte(t) {
	var e = sD(t);
	return function (n, r, i, o) {
		for (var s = "", a = 0; a < e; a++) s += t[a](n, r, i, o) || "";
		return s;
	};
}
function Nte(t) {
	return function (e) {
		e.root || ((e = e.return) && t(e));
	};
}
function Rte(t) {
	var e = Object.create(null);
	return function (n) {
		return e[n] === void 0 && (e[n] = t(n)), e[n];
	};
}
var Ote = function (e, n, r) {
		for (
			var i = 0, o = 0;
			(i = o), (o = na()), i === 38 && o === 12 && (n[r] = 1), !qm(o);

		)
			oo();
		return u0(e, Li);
	},
	Mte = function (e, n) {
		var r = -1,
			i = 44;
		do
			switch (qm(i)) {
				case 0:
					i === 38 && na() === 12 && (n[r] = 1),
						(e[r] += Ote(Li - 1, n, r));
					break;
				case 2:
					e[r] += ib(i);
					break;
				case 4:
					if (i === 44) {
						(e[++r] = na() === 58 ? "&\f" : ""),
							(n[r] = e[r].length);
						break;
					}
				default:
					e[r] += gx(i);
			}
		while ((i = oo()));
		return e;
	},
	jte = function (e, n) {
		return kP(Mte(xP(e), n));
	},
	D6 = new WeakMap(),
	_te = function (e) {
		if (!(e.type !== "rule" || !e.parent || e.length < 1)) {
			for (
				var n = e.value,
					r = e.parent,
					i = e.column === r.column && e.line === r.line;
				r.type !== "rule";

			)
				if (((r = r.parent), !r)) return;
			if (
				!(
					e.props.length === 1 &&
					n.charCodeAt(0) !== 58 &&
					!D6.get(r)
				) &&
				!i
			) {
				D6.set(e, !0);
				for (
					var o = [], s = jte(n, o), a = r.props, l = 0, u = 0;
					l < s.length;
					l++
				)
					for (var c = 0; c < a.length; c++, u++)
						e.props[u] = o[l]
							? s[l].replace(/&\f/g, a[c])
							: a[c] + " " + s[l];
			}
		}
	},
	zte = function (e) {
		if (e.type === "decl") {
			var n = e.value;
			n.charCodeAt(0) === 108 &&
				n.charCodeAt(2) === 98 &&
				((e.return = ""), (e.value = ""));
		}
	};
function CP(t, e) {
	switch (kte(t, e)) {
		case 5103:
			return Nt + "print-" + t + t;
		case 5737:
		case 4201:
		case 3177:
		case 3433:
		case 1641:
		case 4457:
		case 2921:
		case 5572:
		case 6356:
		case 5844:
		case 3191:
		case 6645:
		case 3005:
		case 6391:
		case 5879:
		case 5623:
		case 6135:
		case 4599:
		case 4855:
		case 4215:
		case 6389:
		case 5109:
		case 5365:
		case 5621:
		case 3829:
			return Nt + t + t;
		case 5349:
		case 4246:
		case 4810:
		case 6968:
		case 2756:
			return Nt + t + dv + t + Rr + t + t;
		case 6828:
		case 4268:
			return Nt + t + Rr + t + t;
		case 6165:
			return Nt + t + Rr + "flex-" + t + t;
		case 5187:
			return (
				Nt +
				t +
				Rt(t, /(\w+).+(:[^]+)/, Nt + "box-$1$2" + Rr + "flex-$1$2") +
				t
			);
		case 5443:
			return Nt + t + Rr + "flex-item-" + Rt(t, /flex-|-self/, "") + t;
		case 4675:
			return (
				Nt +
				t +
				Rr +
				"flex-line-pack" +
				Rt(t, /align-content|flex-|-self/, "") +
				t
			);
		case 5548:
			return Nt + t + Rr + Rt(t, "shrink", "negative") + t;
		case 5292:
			return Nt + t + Rr + Rt(t, "basis", "preferred-size") + t;
		case 6060:
			return (
				Nt +
				"box-" +
				Rt(t, "-grow", "") +
				Nt +
				t +
				Rr +
				Rt(t, "grow", "positive") +
				t
			);
		case 4554:
			return Nt + Rt(t, /([^-])(transform)/g, "$1" + Nt + "$2") + t;
		case 6187:
			return (
				Rt(
					Rt(
						Rt(t, /(zoom-|grab)/, Nt + "$1"),
						/(image-set)/,
						Nt + "$1",
					),
					t,
					"",
				) + t
			);
		case 5495:
		case 3959:
			return Rt(t, /(image-set\([^]*)/, Nt + "$1$`$1");
		case 4968:
			return (
				Rt(
					Rt(
						t,
						/(.+:)(flex-)?(.*)/,
						Nt + "box-pack:$3" + Rr + "flex-pack:$3",
					),
					/s.+-b[^;]+/,
					"justify",
				) +
				Nt +
				t +
				t
			);
		case 4095:
		case 3583:
		case 4068:
		case 2532:
			return Rt(t, /(.+)-inline(.+)/, Nt + "$1$2") + t;
		case 8116:
		case 7059:
		case 5753:
		case 5535:
		case 5445:
		case 5701:
		case 4933:
		case 4677:
		case 5533:
		case 5789:
		case 5021:
		case 4765:
			if (Js(t) - 1 - e > 6)
				switch (Sr(t, e + 1)) {
					case 109:
						if (Sr(t, e + 4) !== 45) break;
					case 102:
						return (
							Rt(
								t,
								/(.+:)(.+)-([^]+)/,
								"$1" +
									Nt +
									"$2-$3$1" +
									dv +
									(Sr(t, e + 3) == 108 ? "$3" : "$2-$3"),
							) + t
						);
					case 115:
						return ~lw(t, "stretch")
							? CP(Rt(t, "stretch", "fill-available"), e) + t
							: t;
				}
			break;
		case 4949:
			if (Sr(t, e + 1) !== 115) break;
		case 6444:
			switch (Sr(t, Js(t) - 3 - (~lw(t, "!important") && 10))) {
				case 107:
					return Rt(t, ":", ":" + Nt) + t;
				case 101:
					return (
						Rt(
							t,
							/(.+:)([^;!]+)(;|!.+)?/,
							"$1" +
								Nt +
								(Sr(t, 14) === 45 ? "inline-" : "") +
								"box$3$1" +
								Nt +
								"$2$3$1" +
								Rr +
								"$2box$3",
						) + t
					);
			}
			break;
		case 5936:
			switch (Sr(t, e + 11)) {
				case 114:
					return Nt + t + Rr + Rt(t, /[svh]\w+-[tblr]{2}/, "tb") + t;
				case 108:
					return (
						Nt + t + Rr + Rt(t, /[svh]\w+-[tblr]{2}/, "tb-rl") + t
					);
				case 45:
					return Nt + t + Rr + Rt(t, /[svh]\w+-[tblr]{2}/, "lr") + t;
			}
			return Nt + t + Rr + t + t;
	}
	return t;
}
var Lte = function (e, n, r, i) {
		if (e.length > -1 && !e.return)
			switch (e.type) {
				case oD:
					e.return = CP(e.value, e.length);
					break;
				case bP:
					return eh(
						[Ap(e, { value: Rt(e.value, "@", "@" + Nt) })],
						i,
					);
				case iD:
					if (e.length)
						return wte(e.props, function (o) {
							switch (Cte(o, /(::plac\w+|:read-\w+)/)) {
								case ":read-only":
								case ":read-write":
									return eh(
										[
											Ap(e, {
												props: [
													Rt(
														o,
														/:(read-\w+)/,
														":" + dv + "$1",
													),
												],
											}),
										],
										i,
									);
								case "::placeholder":
									return eh(
										[
											Ap(e, {
												props: [
													Rt(
														o,
														/:(plac\w+)/,
														":" + Nt + "input-$1",
													),
												],
											}),
											Ap(e, {
												props: [
													Rt(
														o,
														/:(plac\w+)/,
														":" + dv + "$1",
													),
												],
											}),
											Ap(e, {
												props: [
													Rt(
														o,
														/:(plac\w+)/,
														Rr + "input-$1",
													),
												],
											}),
										],
										i,
									);
							}
							return "";
						});
			}
	},
	Vte = [Lte],
	Kte = function (e) {
		var n = e.key;
		if (n === "css") {
			var r = document.querySelectorAll(
				"style[data-emotion]:not([data-s])",
			);
			Array.prototype.forEach.call(r, function (g) {
				var v = g.getAttribute("data-emotion");
				v.indexOf(" ") !== -1 &&
					(document.head.appendChild(g),
					g.setAttribute("data-s", ""));
			});
		}
		var i = e.stylisPlugins || Vte,
			o = {},
			s,
			a = [];
		(s = e.container || document.head),
			Array.prototype.forEach.call(
				document.querySelectorAll('style[data-emotion^="' + n + ' "]'),
				function (g) {
					for (
						var v = g.getAttribute("data-emotion").split(" "),
							b = 1;
						b < v.length;
						b++
					)
						o[v[b]] = !0;
					a.push(g);
				},
			);
		var l,
			u = [_te, zte];
		{
			var c,
				d = [
					Fte,
					Nte(function (g) {
						c.insert(g);
					}),
				],
				f = Pte(u.concat(i, d)),
				h = function (v) {
					return eh(Bte(v), f);
				};
			l = function (v, b, y, x) {
				(c = y),
					h(v ? v + "{" + b.styles + "}" : b.styles),
					x && (p.inserted[b.name] = !0);
			};
		}
		var p = {
			key: n,
			sheet: new gte({
				key: n,
				container: s,
				nonce: e.nonce,
				speedy: e.speedy,
				prepend: e.prepend,
				insertionPoint: e.insertionPoint,
			}),
			nonce: e.nonce,
			inserted: o,
			registered: {},
			insert: l,
		};
		return p.sheet.hydrate(a), p;
	};
function Ute(t) {
	for (var e = 0, n, r = 0, i = t.length; i >= 4; ++r, i -= 4)
		(n =
			(t.charCodeAt(r) & 255) |
			((t.charCodeAt(++r) & 255) << 8) |
			((t.charCodeAt(++r) & 255) << 16) |
			((t.charCodeAt(++r) & 255) << 24)),
			(n = (n & 65535) * 1540483477 + (((n >>> 16) * 59797) << 16)),
			(n ^= n >>> 24),
			(e =
				((n & 65535) * 1540483477 + (((n >>> 16) * 59797) << 16)) ^
				((e & 65535) * 1540483477 + (((e >>> 16) * 59797) << 16)));
	switch (i) {
		case 3:
			e ^= (t.charCodeAt(r + 2) & 255) << 16;
		case 2:
			e ^= (t.charCodeAt(r + 1) & 255) << 8;
		case 1:
			(e ^= t.charCodeAt(r) & 255),
				(e = (e & 65535) * 1540483477 + (((e >>> 16) * 59797) << 16));
	}
	return (
		(e ^= e >>> 13),
		(e = (e & 65535) * 1540483477 + (((e >>> 16) * 59797) << 16)),
		((e ^ (e >>> 15)) >>> 0).toString(36)
	);
}
var Hte = {
		animationIterationCount: 1,
		aspectRatio: 1,
		borderImageOutset: 1,
		borderImageSlice: 1,
		borderImageWidth: 1,
		boxFlex: 1,
		boxFlexGroup: 1,
		boxOrdinalGroup: 1,
		columnCount: 1,
		columns: 1,
		flex: 1,
		flexGrow: 1,
		flexPositive: 1,
		flexShrink: 1,
		flexNegative: 1,
		flexOrder: 1,
		gridRow: 1,
		gridRowEnd: 1,
		gridRowSpan: 1,
		gridRowStart: 1,
		gridColumn: 1,
		gridColumnEnd: 1,
		gridColumnSpan: 1,
		gridColumnStart: 1,
		msGridRow: 1,
		msGridRowSpan: 1,
		msGridColumn: 1,
		msGridColumnSpan: 1,
		fontWeight: 1,
		lineHeight: 1,
		opacity: 1,
		order: 1,
		orphans: 1,
		scale: 1,
		tabSize: 1,
		widows: 1,
		zIndex: 1,
		zoom: 1,
		WebkitLineClamp: 1,
		fillOpacity: 1,
		floodOpacity: 1,
		stopOpacity: 1,
		strokeDasharray: 1,
		strokeDashoffset: 1,
		strokeMiterlimit: 1,
		strokeOpacity: 1,
		strokeWidth: 1,
	},
	Wte = !1,
	qte = /[A-Z]|^ms/g,
	Gte = /_EMO_([^_]+?)_([^]*?)_EMO_/g,
	wP = function (e) {
		return e.charCodeAt(1) === 45;
	},
	S6 = function (e) {
		return e != null && typeof e != "boolean";
	},
	S4 = Rte(function (t) {
		return wP(t) ? t : t.replace(qte, "-$&").toLowerCase();
	}),
	A6 = function (e, n) {
		switch (e) {
			case "animation":
			case "animationName":
				if (typeof n == "string")
					return n.replace(Gte, function (r, i, o) {
						return (pu = { name: i, styles: o, next: pu }), i;
					});
		}
		return Hte[e] !== 1 && !wP(e) && typeof n == "number" && n !== 0
			? n + "px"
			: n;
	},
	Yte =
		"Component selectors can only be used in conjunction with @emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware compiler transform.";
function fv(t, e, n) {
	if (n == null) return "";
	var r = n;
	if (r.__emotion_styles !== void 0) return r;
	switch (typeof n) {
		case "boolean":
			return "";
		case "object": {
			var i = n;
			if (i.anim === 1)
				return (
					(pu = { name: i.name, styles: i.styles, next: pu }), i.name
				);
			var o = n;
			if (o.styles !== void 0) {
				var s = o.next;
				if (s !== void 0)
					for (; s !== void 0; )
						(pu = { name: s.name, styles: s.styles, next: pu }),
							(s = s.next);
				var a = o.styles + ";";
				return a;
			}
			return Jte(t, e, n);
		}
	}
	var l = n;
	if (e == null) return l;
	var u = e[l];
	return u !== void 0 ? u : l;
}
function Jte(t, e, n) {
	var r = "";
	if (Array.isArray(n))
		for (var i = 0; i < n.length; i++) r += fv(t, e, n[i]) + ";";
	else
		for (var o in n) {
			var s = n[o];
			if (typeof s != "object") {
				var a = s;
				e != null && e[a] !== void 0
					? (r += o + "{" + e[a] + "}")
					: S6(a) && (r += S4(o) + ":" + A6(o, a) + ";");
			} else {
				if (o === "NO_COMPONENT_SELECTOR" && Wte) throw new Error(Yte);
				if (
					Array.isArray(s) &&
					typeof s[0] == "string" &&
					(e == null || e[s[0]] === void 0)
				)
					for (var l = 0; l < s.length; l++)
						S6(s[l]) && (r += S4(o) + ":" + A6(o, s[l]) + ";");
				else {
					var u = fv(t, e, s);
					switch (o) {
						case "animation":
						case "animationName": {
							r += S4(o) + ":" + u + ";";
							break;
						}
						default:
							r += o + "{" + u + "}";
					}
				}
			}
		}
	return r;
}
var $6 = /label:\s*([^\s;\n{]+)\s*(;|$)/g,
	pu;
function A4(t, e, n) {
	if (
		t.length === 1 &&
		typeof t[0] == "object" &&
		t[0] !== null &&
		t[0].styles !== void 0
	)
		return t[0];
	var r = !0,
		i = "";
	pu = void 0;
	var o = t[0];
	if (o == null || o.raw === void 0) (r = !1), (i += fv(n, e, o));
	else {
		var s = o;
		i += s[0];
	}
	for (var a = 1; a < t.length; a++)
		if (((i += fv(n, e, t[a])), r)) {
			var l = o;
			i += l[a];
		}
	$6.lastIndex = 0;
	for (var u = "", c; (c = $6.exec(i)) !== null; ) u += "-" + c[1];
	var d = Ute(i) + u;
	return { name: d, styles: i, next: pu };
}
function EP(t, e, n) {
	var r = "";
	return (
		n.split(" ").forEach(function (i) {
			t[i] !== void 0 ? e.push(t[i] + ";") : (r += i + " ");
		}),
		r
	);
}
var Xte = function (e, n, r) {
		var i = e.key + "-" + n.name;
		e.registered[i] === void 0 && (e.registered[i] = n.styles);
	},
	Zte = function (e, n, r) {
		Xte(e, n);
		var i = e.key + "-" + n.name;
		if (e.inserted[n.name] === void 0) {
			var o = n;
			do e.insert(n === o ? "." + i : "", o, e.sheet, !0), (o = o.next);
			while (o !== void 0);
		}
	};
function T6(t, e) {
	if (t.inserted[e.name] === void 0) return t.insert("", e, t.sheet, !0);
}
function B6(t, e, n) {
	var r = [],
		i = EP(t, r, n);
	return r.length < 2 ? n : i + e(r);
}
var Qte = function (e) {
		var n = Kte(e);
		(n.sheet.speedy = function (a) {
			this.isSpeedy = a;
		}),
			(n.compat = !0);
		var r = function () {
				for (
					var l = arguments.length, u = new Array(l), c = 0;
					c < l;
					c++
				)
					u[c] = arguments[c];
				var d = A4(u, n.registered, void 0);
				return Zte(n, d), n.key + "-" + d.name;
			},
			i = function () {
				for (
					var l = arguments.length, u = new Array(l), c = 0;
					c < l;
					c++
				)
					u[c] = arguments[c];
				var d = A4(u, n.registered),
					f = "animation-" + d.name;
				return (
					T6(n, {
						name: d.name,
						styles: "@keyframes " + f + "{" + d.styles + "}",
					}),
					f
				);
			},
			o = function () {
				for (
					var l = arguments.length, u = new Array(l), c = 0;
					c < l;
					c++
				)
					u[c] = arguments[c];
				var d = A4(u, n.registered);
				T6(n, d);
			},
			s = function () {
				for (
					var l = arguments.length, u = new Array(l), c = 0;
					c < l;
					c++
				)
					u[c] = arguments[c];
				return B6(n.registered, r, ene(u));
			};
		return {
			css: r,
			cx: s,
			injectGlobal: o,
			keyframes: i,
			hydrate: function (l) {
				l.forEach(function (u) {
					n.inserted[u] = !0;
				});
			},
			flush: function () {
				(n.registered = {}), (n.inserted = {}), n.sheet.flush();
			},
			sheet: n.sheet,
			cache: n,
			getRegisteredStyles: EP.bind(null, n.registered),
			merge: B6.bind(null, n.registered, r),
		};
	},
	ene = function t(e) {
		for (var n = "", r = 0; r < e.length; r++) {
			var i = e[r];
			if (i != null) {
				var o = void 0;
				switch (typeof i) {
					case "boolean":
						break;
					case "object": {
						if (Array.isArray(i)) o = t(i);
						else {
							o = "";
							for (var s in i)
								i[s] && s && (o && (o += " "), (o += s));
						}
						break;
					}
					default:
						o = i;
				}
				o && (n && (n += " "), (n += o));
			}
		}
		return n;
	},
	yx = Qte({ key: "css" }),
	I6 = yx.cx,
	xx = yx.injectGlobal,
	Uh = yx.keyframes,
	X = yx.css;
function wt(t) {
	var e =
		arguments.length > 1 && arguments[1] !== void 0
			? arguments[1]
			: "Assert failed";
	if (!t) throw new TypeError(e);
}
function qn(t) {
	throw new Error(
		"Expected never to be called, but received: " + JSON.stringify(t),
	);
}
function tne(t) {
	return typeof t == "number" && !isNaN(t);
}
function nne(t) {
	return typeof t == "string";
}
function rne(t) {
	return t == null;
}
function ine(t) {
	return !rne(t);
}
function one(t) {
	return Object.entries(t);
}
function DP(t) {
	return Object.keys(t);
}
const Wd = "kui",
	sne = `${Wd}-theme`,
	ane = `${Wd}-scheme--auto`,
	lne = `${Wd}-scheme--light`,
	une = `${Wd}-scheme--dark`;
var cne = function (t) {
	var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
		n = e.literal,
		r = e.overlap,
		i = n ? t : ["&"].concat(t);
	function o(s) {
		if (typeof s != "object" || s == null) return [];
		if (Array.isArray(s)) return s.map(o);
		var a = {},
			l = {},
			u = {};
		return (
			Object.keys(s).forEach(function (c) {
				var d = s[c];
				if (
					(!Array.isArray(d) && n && (d = [d]),
					(n || Array.isArray(d)) && c.charCodeAt(0) !== 38)
				) {
					var f = void 0;
					d.forEach(function (h, p) {
						if (!(r && f === h) && h != null)
							if (((f = h), p === 0 && !n)) u[c] = h;
							else if (a[i[p]] === void 0) {
								var g;
								a[i[p]] = ((g = {}), (g[c] = h), g);
							} else a[i[p]][c] = h;
					});
				} else typeof d == "object" ? (l[c] = o(d)) : (u[c] = d);
			}),
			i.forEach(function (c) {
				a[c] && (u[c] = a[c]);
			}),
			Object.assign(u, l),
			u
		);
	}
	return function () {
		for (var s = arguments.length, a = Array(s), l = 0; l < s; l++)
			a[l] = arguments[l];
		return a.map(o);
	};
};
const B = {
	animation: {
		duration: {
			short: "var(--kui-animation-duration-short)",
			regular: "var(--kui-animation-duration-regular)",
			long: "var(--kui-animation-duration-long)",
			xlong: "var(--kui-animation-duration-xlong)",
		},
		easing: {
			easeInOut: "var(--kui-animation-easing-ease-in-out)",
			easeIn: "var(--kui-animation-easing-ease-in)",
			easeOut: "var(--kui-animation-easing-ease-out)",
		},
	},
	size: {
		alias: {
			focusRing: "var(--kui-size-alias-focus-ring)",
			focusRingGap: "var(--kui-size-alias-focus-ring-gap)",
			singleLineHeight: "var(--kui-size-alias-single-line-height)",
			singleLineWidth: "var(--kui-size-alias-single-line-width)",
		},
		element: {
			xsmall: "var(--kui-size-element-xsmall)",
			small: "var(--kui-size-element-small)",
			regular: "var(--kui-size-element-regular)",
			medium: "var(--kui-size-element-medium)",
			large: "var(--kui-size-element-large)",
			xlarge: "var(--kui-size-element-xlarge)",
		},
		icon: {
			small: "var(--kui-size-icon-small)",
			regular: "var(--kui-size-icon-regular)",
			medium: "var(--kui-size-icon-medium)",
			large: "var(--kui-size-icon-large)",
		},
		container: {
			xsmall: "var(--kui-size-container-xsmall)",
			small: "var(--kui-size-container-small)",
			medium: "var(--kui-size-container-medium)",
			large: "var(--kui-size-container-large)",
			xlarge: "var(--kui-size-container-xlarge)",
		},
		dialog: {
			xsmall: "var(--kui-size-dialog-xsmall)",
			small: "var(--kui-size-dialog-small)",
			medium: "var(--kui-size-dialog-medium)",
			large: "var(--kui-size-dialog-large)",
		},
		border: {
			regular: "var(--kui-size-border-regular)",
			medium: "var(--kui-size-border-medium)",
			large: "var(--kui-size-border-large)",
		},
		radius: {
			full: "var(--kui-size-radius-full)",
			xsmall: "var(--kui-size-radius-xsmall)",
			small: "var(--kui-size-radius-small)",
			regular: "var(--kui-size-radius-regular)",
			medium: "var(--kui-size-radius-medium)",
			large: "var(--kui-size-radius-large)",
			xlarge: "var(--kui-size-radius-xlarge)",
		},
		shadow: {
			small: "var(--kui-size-shadow-small)",
			medium: "var(--kui-size-shadow-medium)",
			large: "var(--kui-size-shadow-large)",
		},
		space: {
			xsmall: "var(--kui-size-space-xsmall)",
			small: "var(--kui-size-space-small)",
			regular: "var(--kui-size-space-regular)",
			medium: "var(--kui-size-space-medium)",
			large: "var(--kui-size-space-large)",
			xlarge: "var(--kui-size-space-xlarge)",
			xxlarge: "var(--kui-size-space-xxlarge)",
		},
		scale: {
			0: "var(--kui-size-scale-0)",
			10: "var(--kui-size-scale-10)",
			25: "var(--kui-size-scale-25)",
			40: "var(--kui-size-scale-40)",
			50: "var(--kui-size-scale-50)",
			65: "var(--kui-size-scale-65)",
			75: "var(--kui-size-scale-75)",
			85: "var(--kui-size-scale-85)",
			100: "var(--kui-size-scale-100)",
			115: "var(--kui-size-scale-115)",
			125: "var(--kui-size-scale-125)",
			130: "var(--kui-size-scale-130)",
			150: "var(--kui-size-scale-150)",
			160: "var(--kui-size-scale-160)",
			175: "var(--kui-size-scale-175)",
			200: "var(--kui-size-scale-200)",
			225: "var(--kui-size-scale-225)",
			250: "var(--kui-size-scale-250)",
			275: "var(--kui-size-scale-275)",
			300: "var(--kui-size-scale-300)",
			325: "var(--kui-size-scale-325)",
			350: "var(--kui-size-scale-350)",
			400: "var(--kui-size-scale-400)",
			450: "var(--kui-size-scale-450)",
			500: "var(--kui-size-scale-500)",
			550: "var(--kui-size-scale-550)",
			600: "var(--kui-size-scale-600)",
			675: "var(--kui-size-scale-675)",
			700: "var(--kui-size-scale-700)",
			800: "var(--kui-size-scale-800)",
			900: "var(--kui-size-scale-900)",
			1e3: "var(--kui-size-scale-1000)",
			1200: "var(--kui-size-scale-1200)",
			1250: "var(--kui-size-scale-1250)",
			1600: "var(--kui-size-scale-1600)",
			1700: "var(--kui-size-scale-1700)",
			2e3: "var(--kui-size-scale-2000)",
			2400: "var(--kui-size-scale-2400)",
			3e3: "var(--kui-size-scale-3000)",
			3400: "var(--kui-size-scale-3400)",
			3600: "var(--kui-size-scale-3600)",
			4600: "var(--kui-size-scale-4600)",
			5e3: "var(--kui-size-scale-5000)",
			6e3: "var(--kui-size-scale-6000)",
		},
	},
	typography: {
		fontFamily: {
			base: "var(--kui-typography-font-family-base)",
			code: "var(--kui-typography-font-family-code)",
		},
		fontWeight: {
			regular: "var(--kui-typography-font-weight-regular)",
			medium: "var(--kui-typography-font-weight-medium)",
			semibold: "var(--kui-typography-font-weight-semibold)",
			bold: "var(--kui-typography-font-weight-bold)",
		},
		lineheight: {
			large: "var(--kui-typography-lineheight-large)",
			medium: "var(--kui-typography-lineheight-medium)",
			small: "var(--kui-typography-lineheight-small)",
		},
		text: {
			small: {
				size: "var(--kui-typography-text-small-size)",
				lineheight: "var(--kui-typography-text-small-lineheight)",
				baselineTrim: "var(--kui-typography-text-small-baseline-trim)",
				capheightTrim:
					"var(--kui-typography-text-small-capheight-trim)",
				capheight: "var(--kui-typography-text-small-capheight)",
			},
			regular: {
				size: "var(--kui-typography-text-regular-size)",
				lineheight: "var(--kui-typography-text-regular-lineheight)",
				baselineTrim:
					"var(--kui-typography-text-regular-baseline-trim)",
				capheightTrim:
					"var(--kui-typography-text-regular-capheight-trim)",
				capheight: "var(--kui-typography-text-regular-capheight)",
			},
			medium: {
				size: "var(--kui-typography-text-medium-size)",
				lineheight: "var(--kui-typography-text-medium-lineheight)",
				baselineTrim: "var(--kui-typography-text-medium-baseline-trim)",
				capheightTrim:
					"var(--kui-typography-text-medium-capheight-trim)",
				capheight: "var(--kui-typography-text-medium-capheight)",
			},
			large: {
				size: "var(--kui-typography-text-large-size)",
				lineheight: "var(--kui-typography-text-large-lineheight)",
				baselineTrim: "var(--kui-typography-text-large-baseline-trim)",
				capheightTrim:
					"var(--kui-typography-text-large-capheight-trim)",
				capheight: "var(--kui-typography-text-large-capheight)",
			},
		},
		heading: {
			small: {
				size: "var(--kui-typography-heading-small-size)",
				lineheight: "var(--kui-typography-heading-small-lineheight)",
				baselineTrim:
					"var(--kui-typography-heading-small-baseline-trim)",
				capheightTrim:
					"var(--kui-typography-heading-small-capheight-trim)",
				capheight: "var(--kui-typography-heading-small-capheight)",
			},
			regular: {
				size: "var(--kui-typography-heading-regular-size)",
				lineheight: "var(--kui-typography-heading-regular-lineheight)",
				baselineTrim:
					"var(--kui-typography-heading-regular-baseline-trim)",
				capheightTrim:
					"var(--kui-typography-heading-regular-capheight-trim)",
				capheight: "var(--kui-typography-heading-regular-capheight)",
			},
			medium: {
				size: "var(--kui-typography-heading-medium-size)",
				lineheight: "var(--kui-typography-heading-medium-lineheight)",
				baselineTrim:
					"var(--kui-typography-heading-medium-baseline-trim)",
				capheightTrim:
					"var(--kui-typography-heading-medium-capheight-trim)",
				capheight: "var(--kui-typography-heading-medium-capheight)",
			},
			large: {
				size: "var(--kui-typography-heading-large-size)",
				lineheight: "var(--kui-typography-heading-large-lineheight)",
				baselineTrim:
					"var(--kui-typography-heading-large-baseline-trim)",
				capheightTrim:
					"var(--kui-typography-heading-large-capheight-trim)",
				capheight: "var(--kui-typography-heading-large-capheight)",
			},
		},
	},
	color: {
		alias: {
			blanket: "var(--kui-color-alias-blanket)",
			backgroundIdle: "var(--kui-color-alias-background-idle)",
			backgroundDisabled: "var(--kui-color-alias-background-disabled)",
			backgroundHovered: "var(--kui-color-alias-background-hovered)",
			backgroundFocused: "var(--kui-color-alias-background-focused)",
			backgroundPressed: "var(--kui-color-alias-background-pressed)",
			backgroundSelected: "var(--kui-color-alias-background-selected)",
			backgroundSelectedHovered:
				"var(--kui-color-alias-background-selected-hovered)",
			focusRing: "var(--kui-color-alias-focus-ring)",
			borderIdle: "var(--kui-color-alias-border-idle)",
			borderHovered: "var(--kui-color-alias-border-hovered)",
			borderPressed: "var(--kui-color-alias-border-pressed)",
			borderFocused: "var(--kui-color-alias-border-focused)",
			borderDisabled: "var(--kui-color-alias-border-disabled)",
			borderSelected: "var(--kui-color-alias-border-selected)",
			borderInvalid: "var(--kui-color-alias-border-invalid)",
			foregroundIdle: "var(--kui-color-alias-foreground-idle)",
			foregroundHovered: "var(--kui-color-alias-foreground-hovered)",
			foregroundPressed: "var(--kui-color-alias-foreground-pressed)",
			foregroundFocused: "var(--kui-color-alias-foreground-focused)",
			foregroundDisabled: "var(--kui-color-alias-foreground-disabled)",
			foregroundSelected: "var(--kui-color-alias-foreground-selected)",
		},
		background: {
			canvas: "var(--kui-color-background-canvas)",
			surface: "var(--kui-color-background-surface)",
			surfaceSecondary: "var(--kui-color-background-surface-secondary)",
			surfaceTertiary: "var(--kui-color-background-surface-tertiary)",
			inverse: "var(--kui-color-background-inverse)",
			accent: "var(--kui-color-background-accent)",
			accentEmphasis: "var(--kui-color-background-accent-emphasis)",
			positive: "var(--kui-color-background-positive)",
			positiveEmphasis: "var(--kui-color-background-positive-emphasis)",
			caution: "var(--kui-color-background-caution)",
			cautionEmphasis: "var(--kui-color-background-caution-emphasis)",
			critical: "var(--kui-color-background-critical)",
			criticalEmphasis: "var(--kui-color-background-critical-emphasis)",
			pending: "var(--kui-color-background-pending)",
			pendingEmphasis: "var(--kui-color-background-pending-emphasis)",
			highlight: "var(--kui-color-background-highlight)",
			highlightEmphasis: "var(--kui-color-background-highlight-emphasis)",
		},
		border: {
			muted: "var(--kui-color-border-muted)",
			neutral: "var(--kui-color-border-neutral)",
			emphasis: "var(--kui-color-border-emphasis)",
			accent: "var(--kui-color-border-accent)",
			positive: "var(--kui-color-border-positive)",
			caution: "var(--kui-color-border-caution)",
			critical: "var(--kui-color-border-critical)",
			pending: "var(--kui-color-border-pending)",
			highlight: "var(--kui-color-border-highlight)",
		},
		foreground: {
			neutral: "var(--kui-color-foreground-neutral)",
			neutralEmphasis: "var(--kui-color-foreground-neutral-emphasis)",
			neutralSecondary: "var(--kui-color-foreground-neutral-secondary)",
			neutralTertiary: "var(--kui-color-foreground-neutral-tertiary)",
			onEmphasis: "var(--kui-color-foreground-on-emphasis)",
			inverse: "var(--kui-color-foreground-inverse)",
			inverseSecondary: "var(--kui-color-foreground-inverse-secondary)",
			accent: "var(--kui-color-foreground-accent)",
			positive: "var(--kui-color-foreground-positive)",
			caution: "var(--kui-color-foreground-caution)",
			critical: "var(--kui-color-foreground-critical)",
			pending: "var(--kui-color-foreground-pending)",
			highlight: "var(--kui-color-foreground-highlight)",
		},
		shadow: {
			muted: "var(--kui-color-shadow-muted)",
			regular: "var(--kui-color-shadow-regular)",
			emphasis: "var(--kui-color-shadow-emphasis)",
		},
		scale: {
			black: "var(--kui-color-scale-black)",
			white: "var(--kui-color-scale-white)",
			amber1: "var(--kui-color-scale-amber1)",
			amber2: "var(--kui-color-scale-amber2)",
			amber3: "var(--kui-color-scale-amber3)",
			amber4: "var(--kui-color-scale-amber4)",
			amber5: "var(--kui-color-scale-amber5)",
			amber6: "var(--kui-color-scale-amber6)",
			amber7: "var(--kui-color-scale-amber7)",
			amber8: "var(--kui-color-scale-amber8)",
			amber9: "var(--kui-color-scale-amber9)",
			amber10: "var(--kui-color-scale-amber10)",
			amber11: "var(--kui-color-scale-amber11)",
			green1: "var(--kui-color-scale-green1)",
			green2: "var(--kui-color-scale-green2)",
			green3: "var(--kui-color-scale-green3)",
			green4: "var(--kui-color-scale-green4)",
			green5: "var(--kui-color-scale-green5)",
			green6: "var(--kui-color-scale-green6)",
			green7: "var(--kui-color-scale-green7)",
			green8: "var(--kui-color-scale-green8)",
			green9: "var(--kui-color-scale-green9)",
			green10: "var(--kui-color-scale-green10)",
			green11: "var(--kui-color-scale-green11)",
			indigo1: "var(--kui-color-scale-indigo1)",
			indigo2: "var(--kui-color-scale-indigo2)",
			indigo3: "var(--kui-color-scale-indigo3)",
			indigo4: "var(--kui-color-scale-indigo4)",
			indigo5: "var(--kui-color-scale-indigo5)",
			indigo6: "var(--kui-color-scale-indigo6)",
			indigo7: "var(--kui-color-scale-indigo7)",
			indigo8: "var(--kui-color-scale-indigo8)",
			indigo9: "var(--kui-color-scale-indigo9)",
			indigo10: "var(--kui-color-scale-indigo10)",
			indigo11: "var(--kui-color-scale-indigo11)",
			pink1: "var(--kui-color-scale-pink1)",
			pink2: "var(--kui-color-scale-pink2)",
			pink3: "var(--kui-color-scale-pink3)",
			pink4: "var(--kui-color-scale-pink4)",
			pink5: "var(--kui-color-scale-pink5)",
			pink6: "var(--kui-color-scale-pink6)",
			pink7: "var(--kui-color-scale-pink7)",
			pink8: "var(--kui-color-scale-pink8)",
			pink9: "var(--kui-color-scale-pink9)",
			pink10: "var(--kui-color-scale-pink10)",
			pink11: "var(--kui-color-scale-pink11)",
			purple1: "var(--kui-color-scale-purple1)",
			purple2: "var(--kui-color-scale-purple2)",
			purple3: "var(--kui-color-scale-purple3)",
			purple4: "var(--kui-color-scale-purple4)",
			purple5: "var(--kui-color-scale-purple5)",
			purple6: "var(--kui-color-scale-purple6)",
			purple7: "var(--kui-color-scale-purple7)",
			purple8: "var(--kui-color-scale-purple8)",
			purple9: "var(--kui-color-scale-purple9)",
			purple10: "var(--kui-color-scale-purple10)",
			purple11: "var(--kui-color-scale-purple11)",
			red1: "var(--kui-color-scale-red1)",
			red2: "var(--kui-color-scale-red2)",
			red3: "var(--kui-color-scale-red3)",
			red4: "var(--kui-color-scale-red4)",
			red5: "var(--kui-color-scale-red5)",
			red6: "var(--kui-color-scale-red6)",
			red7: "var(--kui-color-scale-red7)",
			red8: "var(--kui-color-scale-red8)",
			red9: "var(--kui-color-scale-red9)",
			red10: "var(--kui-color-scale-red10)",
			red11: "var(--kui-color-scale-red11)",
			slate1: "var(--kui-color-scale-slate1)",
			slate2: "var(--kui-color-scale-slate2)",
			slate3: "var(--kui-color-scale-slate3)",
			slate4: "var(--kui-color-scale-slate4)",
			slate5: "var(--kui-color-scale-slate5)",
			slate6: "var(--kui-color-scale-slate6)",
			slate7: "var(--kui-color-scale-slate7)",
			slate8: "var(--kui-color-scale-slate8)",
			slate9: "var(--kui-color-scale-slate9)",
			slate10: "var(--kui-color-scale-slate10)",
			slate11: "var(--kui-color-scale-slate11)",
		},
	},
};
function bt(t, e = {}) {
	let { delay: n = 0, duration: r = "short", easing: i = "easeInOut" } = e,
		o = i === "linear" ? "linear" : B.animation.easing[i],
		s = F6(r);
	return Array.isArray(t)
		? t.map((a) => bt(a, e)).join(", ")
		: `${t} ${s} ${o}` + (n ? ` ${F6(n)}` : "");
}
function F6(t) {
	return tne(t) ? `${t}ms` : B.animation.duration[t];
}
const dne = Wd,
	hv = SP("reset");
function SP(t) {
	return `${dne}:${t}`;
}
function Se(...t) {
	let e = I6(t);
	return e.includes(hv) ? e : I6(hv, e);
}
var Hg, fh, Wg;
class Gr {
	constructor(e, n = []) {
		qe(this, Hg);
		qe(this, fh);
		qe(this, Wg);
		Te(this, Hg, e),
			Te(this, fh, SP(e)),
			Te(this, Wg, new Map(n.map((r) => [r, `${z(this, fh)}-${r}`])));
	}
	element(e) {
		if (e === "root") return z(this, fh);
		let n = z(this, Wg).get(e);
		return (
			wt(
				!!n,
				`Element "${e}" not found in "${z(this, Hg)}" class list. All elements must be defined when the ClassList is instantiated.`,
			),
			n
		);
	}
	selector(e, n) {
		let r = this.element(e);
		return n ? fne[n] + P6(r) : P6(r);
	}
}
(Hg = new WeakMap()), (fh = new WeakMap()), (Wg = new WeakMap());
function P6(t) {
	return `.${t.replace(/:/g, "\\:")}`;
}
const fne = {
		descendant: "& ",
		child: "& > ",
		sibling: "& ~ ",
		"adjacent-sibling": "& + ",
	},
	Pn = { mobile: 0, tablet: 740, desktop: 992, wide: 1200 },
	sb = (t) => `@media (min-width: ${t}px)`,
	$4 = (t) => `@media (max-width: ${t - 1}px)`,
	T4 = (t) => `@container (min-width: ${t}px)`,
	B4 = (t) => `@container (max-width: ${t - 1}px)`,
	en = {
		above: {
			mobile: sb(Pn.tablet),
			tablet: sb(Pn.desktop),
			desktop: sb(Pn.wide),
		},
		below: {
			tablet: $4(Pn.tablet),
			desktop: $4(Pn.desktop),
			wide: $4(Pn.wide),
		},
	},
	Gm = {
		above: {
			mobile: T4(Pn.tablet),
			tablet: T4(Pn.desktop),
			desktop: T4(Pn.wide),
		},
		below: {
			tablet: B4(Pn.tablet),
			desktop: B4(Pn.desktop),
			wide: B4(Pn.wide),
		},
	},
	Mf = DP(Pn),
	{ mobile: yMe, ...hne } = Pn,
	pne = Object.values(hne).map(sb),
	mne = cne(pne);
function gne(t, e) {
	return e == null
		? null
		: typeof e == "object" && !Array.isArray(e)
			? bne(t, e)
			: t(e);
}
function bne(t, e) {
	const n = [];
	for (let r = 0; r < Mf.length; r++) {
		const i = Mf[r];
		n.push(e[i] != null ? t(e[i]) : null);
	}
	return n;
}
function N6(t, e) {
	if (typeof t == "object" && t !== null) {
		for (let n = 0; n < e.length; n++) {
			let r = t[e[n]];
			if (r != null) return r;
		}
		return t.mobile;
	}
	return t;
}
function vne(t, e) {
	if (typeof t == "boolean") return t;
	if (!("above" in t) && !("below" in t)) return N6(t, e);
	const n = "above" in t ? Mf.indexOf(t.above) + 1 : 0,
		r = "below" in t ? Mf.indexOf(t.below) - 1 : Mf.length - 1,
		i = Object.fromEntries(Mf.map((o, s) => [o, s >= n && s <= r]));
	return N6(i, e);
}
const AP = le.createContext(["mobile"]);
function yne(t) {
	const e = ce(3),
		{ children: n, value: r } = t;
	let i;
	return (
		e[0] !== r || e[1] !== n
			? ((i = m.jsx(AP.Provider, { value: r, children: n })),
				(e[0] = r),
				(e[1] = n),
				(e[2] = i))
			: (i = e[2]),
		i
	);
}
function $P() {
	return E.useContext(AP);
}
const { mobile: xMe, ...xne } = Pn,
	TP = one(xne).sort(([, t], [, e]) => e - t),
	R6 = TP.map(([, t]) => `(min-width: ${t}px)`);
function kne() {
	const t = ce(4),
		e = typeof window < "u" && typeof window.matchMedia == "function";
	let n;
	t[0] === Symbol.for("react.memo_cache_sentinel")
		? ((n = () => {
				const u = [];
				for (const c in R6) {
					const d = R6[c];
					window.matchMedia(d).matches && u.push(TP[c][0]);
				}
				return u.push("mobile"), u;
			}),
			(t[0] = n))
		: (n = t[0]);
	const r = n;
	let i;
	t[1] === Symbol.for("react.memo_cache_sentinel")
		? ((i = () => (e ? r() : ["mobile"])), (t[1] = i))
		: (i = t[1]);
	const [o, s] = E.useState(i);
	let a, l;
	return (
		t[2] === Symbol.for("react.memo_cache_sentinel")
			? ((a = () => {
					if (!e) return;
					const u = () => {
						const c = r();
						s((d) =>
							d.length !== c.length ||
							d.some((f, h) => f !== c[h])
								? c
								: d,
						);
					};
					return (
						u(),
						window.addEventListener("resize", u),
						() => {
							window.removeEventListener("resize", u);
						}
					);
				}),
				(l = [e]),
				(t[2] = a),
				(t[3] = l))
			: ((a = t[2]), (l = t[3])),
		at(a, l),
		o
	);
}
function Cne() {
	const t = ce(2),
		e = $P();
	let n;
	return (
		t[0] !== e
			? ((n = function (i) {
					return vne(i, e);
				}),
				(t[0] = e),
				(t[1] = n))
			: (n = t[1]),
		n
	);
}
function wne(t, e) {
	for (const n of e.split(".")) {
		if (
			typeof t != "object" ||
			t === null ||
			!Object.prototype.hasOwnProperty.call(t, n)
		)
			return;
		t = t[n];
	}
	return t;
}
function yh(t, e) {
	var n;
	return typeof e != "string"
		? e
		: ((t = e.includes(".") ? e : `${t}.${e}`),
			(n = wne(B, t)) !== null && n !== void 0 ? n : e);
}
function Mr(t, e) {
	return [t, (r) => yh(e, r)];
}
const Ene = (t) => t;
function pt(t, e = Ene) {
	return [t, e];
}
function $p(t) {
	return [
		t,
		(n) => {
			const r = yh("color.border", n);
			return `${B.size.border.regular} solid ${r}`;
		},
	];
}
function Dne(t) {
	let [e, n] = t.split(".");
	return !e || !n ? !1 : !!B.size[e][n];
}
function pv(t) {
	if (typeof t == "number") {
		if (t === 0) return `${t}px`;
		qn(t);
	}
	if (Dne(t)) {
		let [e, n] = t.split(".");
		return B.size[e][n];
	}
	if (
		t === "auto" ||
		t === "inherit" ||
		t === "100%" ||
		t === "100vh" ||
		t === "100vw"
	)
		return t;
	qn(t);
}
function uc(t) {
	return [t, pv];
}
function Bn(t) {
	return Mr(t, "size.space");
}
function ja(t) {
	return Mr(t, "size.radius");
}
const BP = {
	backgroundColor: Mr("backgroundColor", "color.background"),
	boxShadow: ["boxShadow", Sne],
	height: uc("height"),
	maxHeight: uc("maxHeight"),
	minHeight: uc("minHeight"),
	maxWidth: uc("maxWidth"),
	minWidth: uc("minWidth"),
	width: uc("width"),
	margin: Bn("margin"),
	marginStart: Bn("marginInlineStart"),
	marginEnd: Bn("marginInlineEnd"),
	marginTop: Bn("marginBlockStart"),
	marginBottom: Bn("marginBlockEnd"),
	marginX: Bn("marginInline"),
	marginY: Bn("marginBlock"),
	padding: Bn("padding"),
	paddingStart: Bn("paddingInlineStart"),
	paddingEnd: Bn("paddingInlineEnd"),
	paddingTop: Bn("paddingBlockStart"),
	paddingBottom: Bn("paddingBlockEnd"),
	paddingX: Bn("paddingInline"),
	paddingY: Bn("paddingBlock"),
	border: $p("border"),
	borderStart: $p("borderInlineStart"),
	borderEnd: $p("borderInlineEnd"),
	borderTop: $p("borderTop"),
	borderBottom: $p("borderBottom"),
	borderColor: Mr("borderColor", "color.border"),
	borderStartColor: Mr("borderInlineStartColor", "color.border"),
	borderEndColor: Mr("borderInlineEndColor", "color.border"),
	borderTopColor: Mr("borderTopColor", "color.border"),
	borderBottomColor: Mr("borderBottomColor", "color.border"),
	borderStyle: pt("borderStyle"),
	borderStartStyle: pt("borderInlineStartStyle"),
	borderEndStyle: pt("borderInlineEndStyle"),
	borderTopStyle: pt("borderTopStyle"),
	borderBottomStyle: pt("borderBottomStyle"),
	borderWidth: Mr("borderWidth", "size.border"),
	borderStartWidth: Mr("borderInlineStartWidth", "size.border"),
	borderEndWidth: Mr("borderInlineEndWidth", "size.border"),
	borderTopWidth: Mr("borderTopWidth", "size.border"),
	borderBottomWidth: Mr("borderBottomWidth", "size.border"),
	borderRadius: ja("borderRadius"),
	borderTopStartRadius: ja("borderStartStartRadius"),
	borderTopEndRadius: ja("borderStartEndRadius"),
	borderBottomStartRadius: ja("borderEndStartRadius"),
	borderBottomEndRadius: ja("borderEndEndRadius"),
	borderTopRadius: ja(["borderStartStartRadius", "borderStartEndRadius"]),
	borderBottomRadius: ja(["borderEndStartRadius", "borderEndEndRadius"]),
	borderStartRadius: ja(["borderStartStartRadius", "borderEndStartRadius"]),
	borderEndRadius: ja(["borderEndEndRadius", "borderStartEndRadius"]),
	inset: Bn("inset"),
	insetBottom: Bn("insetBlockEnd"),
	insetEnd: Bn("insetInlineEnd"),
	insetStart: Bn("insetInlineStart"),
	insetTop: Bn("insetBlockStart"),
	insetX: Bn("insetInline"),
	insetY: Bn("insetBlock"),
	position: pt("position"),
	zIndex: pt("zIndex"),
	order: pt("order"),
	alignSelf: pt("alignSelf"),
	flex: pt("flex", I4),
	flexBasis: uc("flexBasis"),
	flexGrow: pt("flexGrow", I4),
	flexShrink: pt("flexShrink", I4),
	justifySelf: pt("justifySelf"),
	gridArea: pt("gridArea"),
	gridColumn: pt("gridColumn"),
	gridColumnEnd: pt("gridColumnEnd"),
	gridColumnStart: pt("gridColumnStart"),
	gridRow: pt("gridRow"),
	gridRowEnd: pt("gridRowEnd"),
	gridRowStart: pt("gridRowStart"),
	cursor: pt("cursor"),
	opacity: pt("opacity"),
	pointerEvents: pt("pointerEvents"),
	overflow: pt("overflow"),
	userSelect: pt("userSelect"),
};
function I4(t) {
	return typeof t == "boolean" ? (t ? "1" : void 0) : "" + t;
}
function Sne(t) {
	const e = { small: "muted", medium: "regular", large: "emphasis" },
		[n, r] = t.split(" "),
		i = yh("color.shadow", r ?? e[n]);
	return `${yh("size.shadow", n)} ${i}`;
}
const IP = Object.keys(BP);
function qd(t, e = []) {
	let n = {},
		r = new Set([
			"isHidden",
			"UNSAFE_className",
			"UNSAFE_style",
			...IP,
			...e,
		]);
	for (const i in t)
		Object.prototype.hasOwnProperty.call(t, i) &&
			!r.has(i) &&
			(n[i] = t[i]);
	return n;
}
function FP(t) {
	let e = {},
		n = new Set(["isHidden", "UNSAFE_className", "UNSAFE_style", ...IP]);
	for (const r in t)
		Object.prototype.hasOwnProperty.call(t, r) && n.has(r) && (e[r] = t[r]);
	return e;
}
function lt(t, e = {}) {
	let n = {};
	for (let r in t) {
		let i = r,
			o = t[r];
		o == null ||
			(e.omitFalsyValues && (o === !1 || o === "")) ||
			(e.trimBooleanKeys &&
				r.startsWith("is") &&
				(i = i.charAt(2).toLowerCase() + i.slice(3)),
			(i = i.replace(/[A-Z]/g, (s) => `-${s.toLowerCase()}`)),
			(n[`data-${i}`] = o));
	}
	return n;
}
function xn(t) {
	const e = ce(6),
		{ children: n } = t,
		{ isFocused: r, isFocusVisible: i, focusProps: o } = ha(t);
	let s;
	if (e[0] !== n || e[1] !== i || e[2] !== t || e[3] !== r || e[4] !== o) {
		const a = E.Children.only(n);
		(s = E.cloneElement(
			a,
			xe(a.props, {
				...o,
				...lt({
					focus: i ? "visible" : t.within ? "within" : r || void 0,
				}),
			}),
		)),
			(e[0] = n),
			(e[1] = i),
			(e[2] = t),
			(e[3] = r),
			(e[4] = o),
			(e[5] = s);
	} else s = e[5];
	return s;
}
function kx() {
	return Vd() || typeof window > "u" ? !1 : window.screen.width <= Pn.tablet;
}
function $l(t) {
	const e = ce(7);
	let n;
	e[0] !== t ? ((n = Ane(t)), (e[0] = t), (e[1] = n)) : (n = e[1]);
	const r = n,
		i = typeof window < "u" && typeof window.matchMedia == "function";
	let o;
	e[2] !== r
		? ((o = () => (i ? window.matchMedia(r).matches : !1)),
			(e[2] = r),
			(e[3] = o))
		: (o = e[3]);
	const [s, a] = E.useState(o);
	let l, u;
	return (
		e[4] !== r
			? ((l = () => {
					if (!i) return;
					const d = window.matchMedia(r),
						f = typeof d.addEventListener == "function",
						h = (p) => {
							a(p.matches);
						};
					return (
						f ? d.addEventListener("change", h) : d.addListener(h),
						() => {
							f
								? d.removeEventListener("change", h)
								: d.removeListener(h);
						}
					);
				}),
				(u = [i, r]),
				(e[4] = r),
				(e[5] = l),
				(e[6] = u))
			: ((l = e[5]), (u = e[6])),
		E.useEffect(l, u),
		Vd() ? !1 : s
	);
}
function Ane(t) {
	return t.replace(/^@media( ?)/m, "");
}
function $ne(t, e) {
	let n = {};
	for (let r in t) {
		let i = e[r];
		if (!i || t[r] == null) continue;
		let [o, s] = i,
			a = gne(s, t[r]);
		if (Array.isArray(o)) for (let l of o) n[l] = a;
		else n[o] = a;
	}
	return n;
}
function ht(t, e = {}) {
	let n = { ...BP, ...e },
		{ isHidden: r, UNSAFE_className: i, UNSAFE_style: o, ...s } = t,
		a = $ne(t, n),
		l = mne(a);
	s.className, s.style;
	let u = [];
	if (r)
		if (r === !0) u.push({ display: "none" });
		else {
			const c = {};
			"above" in r && (c[en.above[r.above]] = { display: "none" }),
				"below" in r && (c[en.below[r.below]] = { display: "none" }),
				u.push(c);
		}
	return { className: Se(X(l), i, X(u)), style: o };
}
function yi(t) {
	return E.forwardRef(t);
}
const mv = E.createContext(null);
mv.displayName = "KeystarProviderContext";
function Rs() {
	const t = E.useContext(mv);
	if (!t)
		throw new Error(
			"Attempt to access context outside of KeystarProvider.",
		);
	return t;
}
function vo(t) {
	const e = ce(5),
		n = Rs();
	if (!n) return t;
	let r;
	return (
		e[0] !== n.isDisabled ||
		e[1] !== n.isRequired ||
		e[2] !== n.isReadOnly ||
		e[3] !== t
			? ((r = Object.assign(
					{},
					{
						isDisabled: n.isDisabled,
						isRequired: n.isRequired,
						isReadOnly: n.isReadOnly,
					},
					t,
				)),
				(e[0] = n.isDisabled),
				(e[1] = n.isRequired),
				(e[2] = n.isReadOnly),
				(e[3] = t),
				(e[4] = r))
			: (r = e[4]),
		r
	);
}
const Tne = `
/**
 * Do not edit directly
 * Generated on Fri, 03 Nov 2023 05:52:12 GMT
 */

.kui-scheme--auto,
.kui-scheme--light {
  color-scheme: light;

  --kui-color-scale-slate11: #2c2c2c;
  --kui-color-scale-slate10: #4b4b4b;
  --kui-color-scale-slate9: #6e6e6e;
  --kui-color-scale-slate8: #8e8e8e;
  --kui-color-scale-slate7: #b3b3b3;
  --kui-color-scale-slate6: #cacaca;
  --kui-color-scale-slate5: #e1e1e1;
  --kui-color-scale-slate4: #eaeaea;
  --kui-color-scale-slate3: #f5f5f5;
  --kui-color-scale-slate2: #fafafa;
  --kui-color-scale-slate1: #ffffff;
  --kui-color-scale-red11: #cd2b31;
  --kui-color-scale-red10: #dc3d43;
  --kui-color-scale-red9: #e5484d;
  --kui-color-scale-red8: #eb9091;
  --kui-color-scale-red7: #f3aeaf;
  --kui-color-scale-red6: #f9c6c6;
  --kui-color-scale-red5: #fdd8d8;
  --kui-color-scale-red4: #ffe5e5;
  --kui-color-scale-red3: #ffefef;
  --kui-color-scale-red2: #fff8f8;
  --kui-color-scale-red1: #fffcfc;
  --kui-color-scale-purple11: #793aaf;
  --kui-color-scale-purple10: #8445bc;
  --kui-color-scale-purple9: #8e4ec6;
  --kui-color-scale-purple8: #be93e4;
  --kui-color-scale-purple7: #d3b4ed;
  --kui-color-scale-purple6: #e3ccf4;
  --kui-color-scale-purple5: #eddbf9;
  --kui-color-scale-purple4: #f3e7fc;
  --kui-color-scale-purple3: #f9f1fe;
  --kui-color-scale-purple2: #fdfaff;
  --kui-color-scale-purple1: #fefcfe;
  --kui-color-scale-pink11: #cd1d8d;
  --kui-color-scale-pink10: #d23197;
  --kui-color-scale-pink9: #d6409f;
  --kui-color-scale-pink8: #e38ec3;
  --kui-color-scale-pink7: #ecadd4;
  --kui-color-scale-pink6: #f3c6e2;
  --kui-color-scale-pink5: #f9d8ec;
  --kui-color-scale-pink4: #fce5f3;
  --kui-color-scale-pink3: #feeef8;
  --kui-color-scale-pink2: #fff7fc;
  --kui-color-scale-pink1: #fffcfe;
  --kui-color-scale-indigo11: #3451b2;
  --kui-color-scale-indigo10: #3a5ccc;
  --kui-color-scale-indigo9: #3e63dd;
  --kui-color-scale-indigo8: #8da4ef;
  --kui-color-scale-indigo7: #aec0f5;
  --kui-color-scale-indigo6: #c6d4f9;
  --kui-color-scale-indigo5: #d9e2fc;
  --kui-color-scale-indigo4: #e6edfe;
  --kui-color-scale-indigo3: #f0f4ff;
  --kui-color-scale-indigo2: #f8faff;
  --kui-color-scale-indigo1: #fdfdfe;
  --kui-color-scale-green11: #18794e;
  --kui-color-scale-green10: #299764;
  --kui-color-scale-green9: #30a46c;
  --kui-color-scale-green8: #5bb98c;
  --kui-color-scale-green7: #92ceac;
  --kui-color-scale-green6: #b4dfc4;
  --kui-color-scale-green5: #ccebd7;
  --kui-color-scale-green4: #ddf3e4;
  --kui-color-scale-green3: #e9f9ee;
  --kui-color-scale-green2: #f2fcf5;
  --kui-color-scale-green1: #fbfefc;
  --kui-color-scale-amber11: #ad5700;
  --kui-color-scale-amber10: #ffa01c;
  --kui-color-scale-amber9: #ffb224;
  --kui-color-scale-amber8: #ee9d2b;
  --kui-color-scale-amber7: #f3ba63;
  --kui-color-scale-amber6: #ffd386;
  --kui-color-scale-amber5: #ffe3a2;
  --kui-color-scale-amber4: #ffecbc;
  --kui-color-scale-amber3: #fff4d5;
  --kui-color-scale-amber2: #fff9ed;
  --kui-color-scale-amber1: #fefdfb;
  --kui-color-scale-white: #ffffff;
  --kui-color-scale-black: #000000;
  --kui-color-alias-foreground-selected: var(--kui-color-scale-indigo11);
  --kui-color-alias-foreground-disabled: var(--kui-color-scale-slate7);
  --kui-color-alias-foreground-focused: var(--kui-color-scale-indigo11);
  --kui-color-alias-foreground-pressed: var(--kui-color-scale-slate11);
  --kui-color-alias-foreground-hovered: var(--kui-color-scale-slate11);
  --kui-color-alias-foreground-idle: var(--kui-color-scale-slate10);
  --kui-color-alias-border-invalid: var(--kui-color-scale-red9);
  --kui-color-alias-border-selected: var(--kui-color-scale-indigo9);
  --kui-color-alias-border-disabled: var(--kui-color-scale-slate4);
  --kui-color-alias-border-focused: var(--kui-color-scale-indigo9);
  --kui-color-alias-border-pressed: var(--kui-color-scale-slate8);
  --kui-color-alias-border-hovered: var(--kui-color-scale-slate7);
  --kui-color-alias-border-idle: var(--kui-color-scale-slate6);
  --kui-color-alias-focus-ring: var(--kui-color-scale-indigo9);
  --kui-color-alias-background-selected-hovered: color-mix(in srgb, transparent, var(--kui-color-scale-indigo9) 20%);
  --kui-color-alias-background-selected: color-mix(in srgb, transparent, var(--kui-color-scale-indigo9) 10%);
  --kui-color-alias-background-pressed: color-mix(in srgb, transparent, var(--kui-color-scale-slate11) 10%);
  --kui-color-alias-background-focused: color-mix(in srgb, transparent, var(--kui-color-scale-slate11) 6%);
  --kui-color-alias-background-hovered: color-mix(in srgb, transparent, var(--kui-color-scale-slate11) 6%);
  --kui-color-alias-background-disabled: var(--kui-color-scale-slate3);
  --kui-color-alias-background-idle: color-mix(in srgb, transparent, var(--kui-color-scale-slate11) 3%);
  --kui-color-alias-blanket: color-mix(in srgb, transparent, var(--kui-color-scale-black) 60%);
  --kui-color-shadow-emphasis: color-mix(in srgb, transparent, var(--kui-color-scale-black) 20%);
  --kui-color-shadow-regular: color-mix(in srgb, transparent, var(--kui-color-scale-black) 15%);
  --kui-color-shadow-muted: color-mix(in srgb, transparent, var(--kui-color-scale-black) 5%);
  --kui-color-foreground-highlight: var(--kui-color-scale-pink11);
  --kui-color-foreground-pending: var(--kui-color-scale-purple11);
  --kui-color-foreground-critical: var(--kui-color-scale-red11);
  --kui-color-foreground-caution: var(--kui-color-scale-amber11);
  --kui-color-foreground-positive: var(--kui-color-scale-green11);
  --kui-color-foreground-accent: var(--kui-color-scale-indigo11);
  --kui-color-foreground-inverse-secondary: var(--kui-color-scale-slate6);
  --kui-color-foreground-inverse: var(--kui-color-scale-slate2);
  --kui-color-foreground-on-emphasis: var(--kui-color-scale-white);
  --kui-color-foreground-neutral-tertiary: var(--kui-color-scale-slate8);
  --kui-color-foreground-neutral-secondary: var(--kui-color-scale-slate9);
  --kui-color-foreground-neutral-emphasis: var(--kui-color-scale-slate11);
  --kui-color-foreground-neutral: var(--kui-color-scale-slate10);
  --kui-color-border-highlight: var(--kui-color-scale-pink6);
  --kui-color-border-pending: var(--kui-color-scale-purple6);
  --kui-color-border-critical: var(--kui-color-scale-red6);
  --kui-color-border-caution: var(--kui-color-scale-amber6);
  --kui-color-border-positive: var(--kui-color-scale-green6);
  --kui-color-border-accent: var(--kui-color-scale-indigo6);
  --kui-color-border-emphasis: var(--kui-color-scale-slate6);
  --kui-color-border-neutral: var(--kui-color-scale-slate5);
  --kui-color-border-muted: var(--kui-color-scale-slate4);
  --kui-color-background-highlight-emphasis: var(--kui-color-scale-pink9);
  --kui-color-background-highlight: var(--kui-color-scale-pink3);
  --kui-color-background-pending-emphasis: var(--kui-color-scale-purple9);
  --kui-color-background-pending: var(--kui-color-scale-purple3);
  --kui-color-background-critical-emphasis: var(--kui-color-scale-red9);
  --kui-color-background-critical: var(--kui-color-scale-red3);
  --kui-color-background-caution-emphasis: var(--kui-color-scale-amber9);
  --kui-color-background-caution: var(--kui-color-scale-amber3);
  --kui-color-background-positive-emphasis: var(--kui-color-scale-green9);
  --kui-color-background-positive: var(--kui-color-scale-green3);
  --kui-color-background-accent-emphasis: var(--kui-color-scale-indigo9);
  --kui-color-background-accent: var(--kui-color-scale-indigo3);
  --kui-color-background-inverse: var(--kui-color-scale-slate10);
  --kui-color-background-surface-tertiary: var(--kui-color-scale-slate4);
  --kui-color-background-surface-secondary: var(--kui-color-scale-slate3);
  --kui-color-background-surface: var(--kui-color-scale-slate2);
  --kui-color-background-canvas: var(--kui-color-scale-slate1);
}
.kui-scheme--dark {
  color-scheme: dark;

  --kui-color-scale-slate11: #e3e3e3;
  --kui-color-scale-slate10: #b9b9b9;
  --kui-color-scale-slate9: #909090;
  --kui-color-scale-slate8: #6e6e6e;
  --kui-color-scale-slate7: #5a5a5a;
  --kui-color-scale-slate6: #4a4a4a;
  --kui-color-scale-slate5: #3e3e3e;
  --kui-color-scale-slate4: #323232;
  --kui-color-scale-slate3: #2f2f2f;
  --kui-color-scale-slate2: #252525;
  --kui-color-scale-slate1: #1f1f1f;
  --kui-color-scale-red11: #ff6369;
  --kui-color-scale-red10: #f2555a;
  --kui-color-scale-red9: #e5484d;
  --kui-color-scale-red8: #aa2429;
  --kui-color-scale-red7: #822025;
  --kui-color-scale-red6: #671e22;
  --kui-color-scale-red5: #541b1f;
  --kui-color-scale-red4: #481a1d;
  --kui-color-scale-red3: #3c181a;
  --kui-color-scale-red2: #291415;
  --kui-color-scale-red1: #1f1315;
  --kui-color-scale-purple11: #bf7af0;
  --kui-color-scale-purple10: #9d5bd2;
  --kui-color-scale-purple9: #8e4ec6;
  --kui-color-scale-purple8: #7938b2;
  --kui-color-scale-purple7: #5f2d84;
  --kui-color-scale-purple6: #4e2667;
  --kui-color-scale-purple5: #432155;
  --kui-color-scale-purple4: #3a1e48;
  --kui-color-scale-purple3: #301a3a;
  --kui-color-scale-purple2: #221527;
  --kui-color-scale-purple1: #1b141d;
  --kui-color-scale-pink11: #f65cb6;
  --kui-color-scale-pink10: #e34ba9;
  --kui-color-scale-pink9: #d6409f;
  --kui-color-scale-pink8: #a71873;
  --kui-color-scale-pink7: #7a1d5a;
  --kui-color-scale-pink6: #601d48;
  --kui-color-scale-pink5: #501b3f;
  --kui-color-scale-pink4: #451a37;
  --kui-color-scale-pink3: #3a182f;
  --kui-color-scale-pink2: #271421;
  --kui-color-scale-pink1: #1f121b;
  --kui-color-scale-indigo11: #849dff;
  --kui-color-scale-indigo10: #5373e7;
  --kui-color-scale-indigo9: #3e63dd;
  --kui-color-scale-indigo8: #2f4eb2;
  --kui-color-scale-indigo7: #273e89;
  --kui-color-scale-indigo6: #22346e;
  --kui-color-scale-indigo5: #1f2c5c;
  --kui-color-scale-indigo4: #1c274f;
  --kui-color-scale-indigo3: #192140;
  --kui-color-scale-indigo2: #15192d;
  --kui-color-scale-indigo1: #131620;
  --kui-color-scale-green11: #4cc38a;
  --kui-color-scale-green10: #3cb179;
  --kui-color-scale-green9: #30a46c;
  --kui-color-scale-green8: #236e4a;
  --kui-color-scale-green7: #1b543a;
  --kui-color-scale-green6: #164430;
  --kui-color-scale-green5: #133929;
  --kui-color-scale-green4: #113123;
  --kui-color-scale-green3: #0f291e;
  --kui-color-scale-green2: #0c1f17;
  --kui-color-scale-green1: #0d1912;
  --kui-color-scale-amber11: #f1a10d;
  --kui-color-scale-amber10: #ffcb47;
  --kui-color-scale-amber9: #ffb224;
  --kui-color-scale-amber8: #824e00;
  --kui-color-scale-amber7: #693f05;
  --kui-color-scale-amber6: #573300;
  --kui-color-scale-amber5: #4a2900;
  --kui-color-scale-amber4: #3f2200;
  --kui-color-scale-amber3: #341c00;
  --kui-color-scale-amber2: #271700;
  --kui-color-scale-amber1: #1f1300;
  --kui-color-scale-white: #ffffff;
  --kui-color-scale-black: #000000;
  --kui-color-alias-foreground-selected: var(--kui-color-scale-indigo11);
  --kui-color-alias-foreground-disabled: var(--kui-color-scale-slate7);
  --kui-color-alias-foreground-focused: var(--kui-color-scale-indigo11);
  --kui-color-alias-foreground-pressed: var(--kui-color-scale-slate11);
  --kui-color-alias-foreground-hovered: var(--kui-color-scale-slate11);
  --kui-color-alias-foreground-idle: var(--kui-color-scale-slate10);
  --kui-color-alias-border-invalid: var(--kui-color-scale-red9);
  --kui-color-alias-border-selected: var(--kui-color-scale-indigo9);
  --kui-color-alias-border-disabled: var(--kui-color-scale-slate4);
  --kui-color-alias-border-focused: var(--kui-color-scale-indigo9);
  --kui-color-alias-border-pressed: var(--kui-color-scale-slate8);
  --kui-color-alias-border-hovered: var(--kui-color-scale-slate7);
  --kui-color-alias-border-idle: var(--kui-color-scale-slate6);
  --kui-color-alias-focus-ring: var(--kui-color-scale-indigo9);
  --kui-color-alias-background-selected-hovered: color-mix(in srgb, transparent, var(--kui-color-scale-indigo9) 20%);
  --kui-color-alias-background-selected: color-mix(in srgb, transparent, var(--kui-color-scale-indigo9) 10%);
  --kui-color-alias-background-pressed: color-mix(in srgb, transparent, var(--kui-color-scale-slate11) 10%);
  --kui-color-alias-background-focused: color-mix(in srgb, transparent, var(--kui-color-scale-slate11) 6%);
  --kui-color-alias-background-hovered: color-mix(in srgb, transparent, var(--kui-color-scale-slate11) 6%);
  --kui-color-alias-background-disabled: var(--kui-color-scale-slate3);
  --kui-color-alias-background-idle: color-mix(in srgb, transparent, var(--kui-color-scale-slate11) 4%);
  --kui-color-alias-blanket: color-mix(in srgb, transparent, var(--kui-color-scale-black) 60%);
  --kui-color-shadow-emphasis: color-mix(in srgb, transparent, var(--kui-color-scale-black) 60%);
  --kui-color-shadow-regular: color-mix(in srgb, transparent, var(--kui-color-scale-black) 40%);
  --kui-color-shadow-muted: color-mix(in srgb, transparent, var(--kui-color-scale-black) 20%);
  --kui-color-foreground-highlight: var(--kui-color-scale-pink11);
  --kui-color-foreground-pending: var(--kui-color-scale-purple11);
  --kui-color-foreground-critical: var(--kui-color-scale-red11);
  --kui-color-foreground-caution: var(--kui-color-scale-amber11);
  --kui-color-foreground-positive: var(--kui-color-scale-green11);
  --kui-color-foreground-accent: var(--kui-color-scale-indigo11);
  --kui-color-foreground-inverse-secondary: var(--kui-color-scale-slate6);
  --kui-color-foreground-inverse: var(--kui-color-scale-slate2);
  --kui-color-foreground-on-emphasis: var(--kui-color-scale-white);
  --kui-color-foreground-neutral-tertiary: var(--kui-color-scale-slate8);
  --kui-color-foreground-neutral-secondary: var(--kui-color-scale-slate9);
  --kui-color-foreground-neutral-emphasis: var(--kui-color-scale-slate11);
  --kui-color-foreground-neutral: var(--kui-color-scale-slate10);
  --kui-color-border-highlight: var(--kui-color-scale-pink6);
  --kui-color-border-pending: var(--kui-color-scale-purple6);
  --kui-color-border-critical: var(--kui-color-scale-red6);
  --kui-color-border-caution: var(--kui-color-scale-amber6);
  --kui-color-border-positive: var(--kui-color-scale-green6);
  --kui-color-border-accent: var(--kui-color-scale-indigo6);
  --kui-color-border-emphasis: var(--kui-color-scale-slate6);
  --kui-color-border-neutral: var(--kui-color-scale-slate5);
  --kui-color-border-muted: var(--kui-color-scale-slate4);
  --kui-color-background-highlight-emphasis: var(--kui-color-scale-pink9);
  --kui-color-background-highlight: var(--kui-color-scale-pink3);
  --kui-color-background-pending-emphasis: var(--kui-color-scale-purple9);
  --kui-color-background-pending: var(--kui-color-scale-purple3);
  --kui-color-background-critical-emphasis: var(--kui-color-scale-red9);
  --kui-color-background-critical: var(--kui-color-scale-red3);
  --kui-color-background-caution-emphasis: var(--kui-color-scale-amber9);
  --kui-color-background-caution: var(--kui-color-scale-amber3);
  --kui-color-background-positive-emphasis: var(--kui-color-scale-green9);
  --kui-color-background-positive: var(--kui-color-scale-green3);
  --kui-color-background-accent-emphasis: var(--kui-color-scale-indigo9);
  --kui-color-background-accent: var(--kui-color-scale-indigo3);
  --kui-color-background-inverse: var(--kui-color-scale-slate10);
  --kui-color-background-surface-tertiary: var(--kui-color-scale-slate4);
  --kui-color-background-surface-secondary: var(--kui-color-scale-slate3);
  --kui-color-background-surface: var(--kui-color-scale-slate2);
  --kui-color-background-canvas: var(--kui-color-scale-slate1);
}
@media (prefers-color-scheme: dark) {
  .kui-scheme--auto {
    color-scheme: dark;

    --kui-color-scale-slate11: #e3e3e3;
    --kui-color-scale-slate10: #b9b9b9;
    --kui-color-scale-slate9: #909090;
    --kui-color-scale-slate8: #6e6e6e;
    --kui-color-scale-slate7: #5a5a5a;
    --kui-color-scale-slate6: #4a4a4a;
    --kui-color-scale-slate5: #3e3e3e;
    --kui-color-scale-slate4: #323232;
    --kui-color-scale-slate3: #2f2f2f;
    --kui-color-scale-slate2: #252525;
    --kui-color-scale-slate1: #1f1f1f;
    --kui-color-scale-red11: #ff6369;
    --kui-color-scale-red10: #f2555a;
    --kui-color-scale-red9: #e5484d;
    --kui-color-scale-red8: #aa2429;
    --kui-color-scale-red7: #822025;
    --kui-color-scale-red6: #671e22;
    --kui-color-scale-red5: #541b1f;
    --kui-color-scale-red4: #481a1d;
    --kui-color-scale-red3: #3c181a;
    --kui-color-scale-red2: #291415;
    --kui-color-scale-red1: #1f1315;
    --kui-color-scale-purple11: #bf7af0;
    --kui-color-scale-purple10: #9d5bd2;
    --kui-color-scale-purple9: #8e4ec6;
    --kui-color-scale-purple8: #7938b2;
    --kui-color-scale-purple7: #5f2d84;
    --kui-color-scale-purple6: #4e2667;
    --kui-color-scale-purple5: #432155;
    --kui-color-scale-purple4: #3a1e48;
    --kui-color-scale-purple3: #301a3a;
    --kui-color-scale-purple2: #221527;
    --kui-color-scale-purple1: #1b141d;
    --kui-color-scale-pink11: #f65cb6;
    --kui-color-scale-pink10: #e34ba9;
    --kui-color-scale-pink9: #d6409f;
    --kui-color-scale-pink8: #a71873;
    --kui-color-scale-pink7: #7a1d5a;
    --kui-color-scale-pink6: #601d48;
    --kui-color-scale-pink5: #501b3f;
    --kui-color-scale-pink4: #451a37;
    --kui-color-scale-pink3: #3a182f;
    --kui-color-scale-pink2: #271421;
    --kui-color-scale-pink1: #1f121b;
    --kui-color-scale-indigo11: #849dff;
    --kui-color-scale-indigo10: #5373e7;
    --kui-color-scale-indigo9: #3e63dd;
    --kui-color-scale-indigo8: #2f4eb2;
    --kui-color-scale-indigo7: #273e89;
    --kui-color-scale-indigo6: #22346e;
    --kui-color-scale-indigo5: #1f2c5c;
    --kui-color-scale-indigo4: #1c274f;
    --kui-color-scale-indigo3: #192140;
    --kui-color-scale-indigo2: #15192d;
    --kui-color-scale-indigo1: #131620;
    --kui-color-scale-green11: #4cc38a;
    --kui-color-scale-green10: #3cb179;
    --kui-color-scale-green9: #30a46c;
    --kui-color-scale-green8: #236e4a;
    --kui-color-scale-green7: #1b543a;
    --kui-color-scale-green6: #164430;
    --kui-color-scale-green5: #133929;
    --kui-color-scale-green4: #113123;
    --kui-color-scale-green3: #0f291e;
    --kui-color-scale-green2: #0c1f17;
    --kui-color-scale-green1: #0d1912;
    --kui-color-scale-amber11: #f1a10d;
    --kui-color-scale-amber10: #ffcb47;
    --kui-color-scale-amber9: #ffb224;
    --kui-color-scale-amber8: #824e00;
    --kui-color-scale-amber7: #693f05;
    --kui-color-scale-amber6: #573300;
    --kui-color-scale-amber5: #4a2900;
    --kui-color-scale-amber4: #3f2200;
    --kui-color-scale-amber3: #341c00;
    --kui-color-scale-amber2: #271700;
    --kui-color-scale-amber1: #1f1300;
    --kui-color-scale-white: #ffffff;
    --kui-color-scale-black: #000000;
    --kui-color-alias-foreground-selected: var(--kui-color-scale-indigo11);
    --kui-color-alias-foreground-disabled: var(--kui-color-scale-slate7);
    --kui-color-alias-foreground-focused: var(--kui-color-scale-indigo11);
    --kui-color-alias-foreground-pressed: var(--kui-color-scale-slate11);
    --kui-color-alias-foreground-hovered: var(--kui-color-scale-slate11);
    --kui-color-alias-foreground-idle: var(--kui-color-scale-slate10);
    --kui-color-alias-border-invalid: var(--kui-color-scale-red9);
    --kui-color-alias-border-selected: var(--kui-color-scale-indigo9);
    --kui-color-alias-border-disabled: var(--kui-color-scale-slate4);
    --kui-color-alias-border-focused: var(--kui-color-scale-indigo9);
    --kui-color-alias-border-pressed: var(--kui-color-scale-slate8);
    --kui-color-alias-border-hovered: var(--kui-color-scale-slate7);
    --kui-color-alias-border-idle: var(--kui-color-scale-slate6);
    --kui-color-alias-focus-ring: var(--kui-color-scale-indigo9);
    --kui-color-alias-background-selected-hovered: color-mix(in srgb, transparent, var(--kui-color-scale-indigo9) 20%);
    --kui-color-alias-background-selected: color-mix(in srgb, transparent, var(--kui-color-scale-indigo9) 10%);
    --kui-color-alias-background-pressed: color-mix(in srgb, transparent, var(--kui-color-scale-slate11) 10%);
    --kui-color-alias-background-focused: color-mix(in srgb, transparent, var(--kui-color-scale-slate11) 6%);
    --kui-color-alias-background-hovered: color-mix(in srgb, transparent, var(--kui-color-scale-slate11) 6%);
    --kui-color-alias-background-disabled: var(--kui-color-scale-slate3);
    --kui-color-alias-background-idle: color-mix(in srgb, transparent, var(--kui-color-scale-slate11) 4%);
    --kui-color-alias-blanket: color-mix(in srgb, transparent, var(--kui-color-scale-black) 60%);
    --kui-color-shadow-emphasis: color-mix(in srgb, transparent, var(--kui-color-scale-black) 60%);
    --kui-color-shadow-regular: color-mix(in srgb, transparent, var(--kui-color-scale-black) 40%);
    --kui-color-shadow-muted: color-mix(in srgb, transparent, var(--kui-color-scale-black) 20%);
    --kui-color-foreground-highlight: var(--kui-color-scale-pink11);
    --kui-color-foreground-pending: var(--kui-color-scale-purple11);
    --kui-color-foreground-critical: var(--kui-color-scale-red11);
    --kui-color-foreground-caution: var(--kui-color-scale-amber11);
    --kui-color-foreground-positive: var(--kui-color-scale-green11);
    --kui-color-foreground-accent: var(--kui-color-scale-indigo11);
    --kui-color-foreground-inverse-secondary: var(--kui-color-scale-slate6);
    --kui-color-foreground-inverse: var(--kui-color-scale-slate2);
    --kui-color-foreground-on-emphasis: var(--kui-color-scale-white);
    --kui-color-foreground-neutral-tertiary: var(--kui-color-scale-slate8);
    --kui-color-foreground-neutral-secondary: var(--kui-color-scale-slate9);
    --kui-color-foreground-neutral-emphasis: var(--kui-color-scale-slate11);
    --kui-color-foreground-neutral: var(--kui-color-scale-slate10);
    --kui-color-border-highlight: var(--kui-color-scale-pink6);
    --kui-color-border-pending: var(--kui-color-scale-purple6);
    --kui-color-border-critical: var(--kui-color-scale-red6);
    --kui-color-border-caution: var(--kui-color-scale-amber6);
    --kui-color-border-positive: var(--kui-color-scale-green6);
    --kui-color-border-accent: var(--kui-color-scale-indigo6);
    --kui-color-border-emphasis: var(--kui-color-scale-slate6);
    --kui-color-border-neutral: var(--kui-color-scale-slate5);
    --kui-color-border-muted: var(--kui-color-scale-slate4);
    --kui-color-background-highlight-emphasis: var(--kui-color-scale-pink9);
    --kui-color-background-highlight: var(--kui-color-scale-pink3);
    --kui-color-background-pending-emphasis: var(--kui-color-scale-purple9);
    --kui-color-background-pending: var(--kui-color-scale-purple3);
    --kui-color-background-critical-emphasis: var(--kui-color-scale-red9);
    --kui-color-background-critical: var(--kui-color-scale-red3);
    --kui-color-background-caution-emphasis: var(--kui-color-scale-amber9);
    --kui-color-background-caution: var(--kui-color-scale-amber3);
    --kui-color-background-positive-emphasis: var(--kui-color-scale-green9);
    --kui-color-background-positive: var(--kui-color-scale-green3);
    --kui-color-background-accent-emphasis: var(--kui-color-scale-indigo9);
    --kui-color-background-accent: var(--kui-color-scale-indigo3);
    --kui-color-background-inverse: var(--kui-color-scale-slate10);
    --kui-color-background-surface-tertiary: var(--kui-color-scale-slate4);
    --kui-color-background-surface-secondary: var(--kui-color-scale-slate3);
    --kui-color-background-surface: var(--kui-color-scale-slate2);
    --kui-color-background-canvas: var(--kui-color-scale-slate1);
  }
}
.kui-theme {
  --kui-animation-easing-ease-out: cubic-bezier(0, 0, 0.4, 1);
  --kui-animation-easing-ease-in: cubic-bezier(0.5, 0, 1, 1);
  --kui-animation-easing-ease-in-out: cubic-bezier(0.45, 0, 0.4, 1);
  --kui-animation-duration-xlong: 1920ms;
  --kui-animation-duration-long: 960ms;
  --kui-animation-duration-regular: 320ms;
  --kui-animation-duration-short: 160ms;
}
.kui-theme {
  --kui-size-dialog-large: 860px;
  --kui-size-dialog-medium: 640px;
  --kui-size-dialog-small: 420px;
  --kui-size-dialog-xsmall: 320px;
  --kui-size-container-xlarge: 1400px;
  --kui-size-container-large: 1280px;
  --kui-size-container-medium: 940px;
  --kui-size-container-small: 660px;
  --kui-size-container-xsmall: 400px;
  --kui-size-alias-focus-ring-gap: 2px;
  --kui-size-alias-focus-ring: 2px;
  --kui-size-icon-large: var(--kui-size-scale-400);
  --kui-size-icon-medium: var(--kui-size-scale-300);
  --kui-size-icon-regular: var(--kui-size-scale-200);
  --kui-size-icon-small: var(--kui-size-scale-150);
  --kui-size-element-xlarge: var(--kui-size-scale-800);
  --kui-size-element-large: var(--kui-size-scale-600);
  --kui-size-element-medium: var(--kui-size-scale-450);
  --kui-size-element-regular: var(--kui-size-scale-400);
  --kui-size-element-small: var(--kui-size-scale-300);
  --kui-size-element-xsmall: var(--kui-size-scale-200);
  --kui-size-alias-single-line-width: var(--kui-size-scale-2400);
  --kui-size-alias-single-line-height: var(--kui-size-scale-400);
}
.kui-theme {
  --kui-size-radius-xlarge: 16px;
  --kui-size-radius-large: 12px;
  --kui-size-radius-medium: 8px;
  --kui-size-radius-regular: 6px;
  --kui-size-radius-small: 4px;
  --kui-size-radius-xsmall: 2px;
  --kui-size-radius-full: 9999px;
  --kui-size-border-large: 4px;
  --kui-size-border-medium: 2px;
  --kui-size-border-regular: 1px;
  --kui-size-space-xxlarge: var(--kui-size-scale-400);
  --kui-size-space-xlarge: var(--kui-size-scale-300);
  --kui-size-space-large: var(--kui-size-scale-200);
  --kui-size-space-medium: var(--kui-size-scale-150);
  --kui-size-space-regular: var(--kui-size-scale-100);
  --kui-size-space-small: var(--kui-size-scale-50);
  --kui-size-space-xsmall: var(--kui-size-scale-25);
  --kui-size-shadow-large: 0px var(--kui-size-scale-100) var(--kui-size-scale-300) 0px;
  --kui-size-shadow-medium: 0px var(--kui-size-scale-40) var(--kui-size-scale-75) 0px;
  --kui-size-shadow-small: 0px var(--kui-size-scale-10) var(--kui-size-scale-25) 0px;
}
.kui-theme {
  --kui-size-scale-6000: 480px;
  --kui-size-scale-5000: 400px;
  --kui-size-scale-4600: 368px;
  --kui-size-scale-3600: 288px;
  --kui-size-scale-3400: 272px;
  --kui-size-scale-3000: 240px;
  --kui-size-scale-2400: 192px;
  --kui-size-scale-2000: 160px;
  --kui-size-scale-1700: 136px;
  --kui-size-scale-1600: 128px;
  --kui-size-scale-1250: 100px;
  --kui-size-scale-1200: 96px;
  --kui-size-scale-1000: 80px;
  --kui-size-scale-900: 72px;
  --kui-size-scale-800: 64px;
  --kui-size-scale-700: 56px;
  --kui-size-scale-675: 54px;
  --kui-size-scale-600: 48px;
  --kui-size-scale-550: 44px;
  --kui-size-scale-500: 40px;
  --kui-size-scale-450: 36px;
  --kui-size-scale-400: 32px;
  --kui-size-scale-350: 28px;
  --kui-size-scale-325: 26px;
  --kui-size-scale-300: 24px;
  --kui-size-scale-275: 22px;
  --kui-size-scale-250: 20px;
  --kui-size-scale-225: 18px;
  --kui-size-scale-200: 16px;
  --kui-size-scale-175: 14px;
  --kui-size-scale-160: 13px;
  --kui-size-scale-150: 12px;
  --kui-size-scale-130: 11px;
  --kui-size-scale-125: 10px;
  --kui-size-scale-115: 9px;
  --kui-size-scale-100: 8px;
  --kui-size-scale-85: 7px;
  --kui-size-scale-75: 6px;
  --kui-size-scale-65: 5px;
  --kui-size-scale-50: 4px;
  --kui-size-scale-40: 3px;
  --kui-size-scale-25: 2px;
  --kui-size-scale-10: 1px;
  --kui-size-scale-0: 0px;
}
.kui-theme {
  --kui-typography-heading-large-lineheight: 1.2;
  --kui-typography-heading-large-size: 32px;
  --kui-typography-heading-medium-lineheight: 1.2;
  --kui-typography-heading-medium-size: 24px;
  --kui-typography-heading-regular-lineheight: 1.2;
  --kui-typography-heading-regular-size: 20px;
  --kui-typography-heading-small-lineheight: 1.2;
  --kui-typography-heading-small-size: 16px;
  --kui-typography-text-large-lineheight: 1.2;
  --kui-typography-text-large-size: 18px;
  --kui-typography-text-medium-lineheight: 1.4;
  --kui-typography-text-medium-size: 16px;
  --kui-typography-text-regular-lineheight: 1.4;
  --kui-typography-text-regular-size: 14px;
  --kui-typography-text-small-lineheight: 1.4;
  --kui-typography-text-small-size: 12px;
  --kui-typography-lineheight-small: 1.2;
  --kui-typography-lineheight-medium: 1.4;
  --kui-typography-lineheight-large: 1.6;
  --kui-typography-font-weight-bold: 700;
  --kui-typography-font-weight-semibold: 600;
  --kui-typography-font-weight-medium: 500;
  --kui-typography-font-weight-regular: 400;
  --kui-typography-font-family-code: ui-monospace, SFMono-Regular, SF Mono, Menlo, Consolas, Liberation Mono, monospace;
  --kui-typography-font-family-base: var(--font-inter, Inter);
  --kui-typography-heading-large-capheight: 23.2727px;
  --kui-typography-heading-large-capheight-trim: -0.2364em;
  --kui-typography-heading-large-baseline-trim: -0.2364em;
  --kui-typography-heading-medium-capheight: 17.4545px;
  --kui-typography-heading-medium-capheight-trim: -0.2364em;
  --kui-typography-heading-medium-baseline-trim: -0.2364em;
  --kui-typography-heading-regular-capheight: 14.5455px;
  --kui-typography-heading-regular-capheight-trim: -0.2364em;
  --kui-typography-heading-regular-baseline-trim: -0.2364em;
  --kui-typography-heading-small-capheight: 11.6364px;
  --kui-typography-heading-small-capheight-trim: -0.2364em;
  --kui-typography-heading-small-baseline-trim: -0.2364em;
  --kui-typography-text-large-capheight: 13.0909px;
  --kui-typography-text-large-capheight-trim: -0.2364em;
  --kui-typography-text-large-baseline-trim: -0.2364em;
  --kui-typography-text-medium-capheight: 11.6364px;
  --kui-typography-text-medium-capheight-trim: -0.3364em;
  --kui-typography-text-medium-baseline-trim: -0.3364em;
  --kui-typography-text-regular-capheight: 10.1818px;
  --kui-typography-text-regular-capheight-trim: -0.3364em;
  --kui-typography-text-regular-baseline-trim: -0.3364em;
  --kui-typography-text-small-capheight: 8.7273px;
  --kui-typography-text-small-capheight-trim: -0.3364em;
  --kui-typography-text-small-baseline-trim: -0.3364em;
}`,
	Bne = { auto: ane, light: lne, dark: une },
	PP = (t) => {
		const e = Bne[t.colorScheme || "auto"];
		return `${Ine(t.bodyBackground)} ${sne} ${e}`;
	},
	Ine = (t = "canvas") => X`
  html& {
    scroll-behavior: smooth;
    text-size-adjust: none;
    -webkit-tap-highlight-color: #0000;
  }
  @media (prefers-reduced-motion: reduce) {
    html& {
      scroll-behavior: auto;
    }
  }

  html& body {
    background-color: ${B.color.background[t]};
    margin: 0;
  }
`;
function Fne(t) {
	return t.replace(/\n|\s{2,}/g, "");
}
const ti = hv.replace(":", "\\:"),
	Pne = Fne(`
  :where(.${ti}) {
    border: 0;
    box-sizing: border-box;
    font: inherit;
    font-size: 100%;
    margin: 0;
    padding: 0;
    vertical-align: baseline;
  }
  :where(ol.${ti}, ul.${ti}) { list-style: none; }
  :where(canvas.${ti}, img.${ti}, picture.${ti}, svg.${ti}, video.${ti}) { display: block; }
  :where(input.${ti}, button.${ti}, textarea.${ti}, select.${ti}) { appearance: none; background-color: transparent; }
  :where(a.${ti}, abbr.${ti}) { color: inherit; text-decoration: none; }
  :where(table.${ti}) = { border-collapse: collapse; border-spacing: 0; }
`);
xx(Tne);
xx(Pne);
function Nne() {
	return $l("(any-pointer: fine)") ? "medium" : "large";
}
const Hh = yi(function (e, n) {
		let r = E.useContext(mv),
			i = r && r.colorScheme,
			o = Nne(),
			{ locale: s } = Vt(),
			a = kne(),
			{
				children: l,
				colorScheme: u = i || "auto",
				isDisabled: c,
				isRequired: d,
				isReadOnly: f,
				locale: h = r ? s : void 0,
				router: p,
				scale: g = r ? r.scale : o,
				...v
			} = e,
			y = Object.fromEntries(
				Object.entries({
					colorScheme: u,
					isDisabled: c,
					isRequired: d,
					isReadOnly: f,
					scale: g,
				}).filter(([S, $]) => $ !== void 0),
			),
			x = Object.assign({}, r, y),
			C = l,
			k = Ge(v),
			w = ht(v);
		if (
			!r ||
			e.elementType ||
			e.locale ||
			u !== r.colorScheme ||
			g !== r.scale ||
			Object.keys(k).length > 0 ||
			v.UNSAFE_className ||
			(w.style && Object.keys(w.style).length > 0)
		) {
			var D;
			C = m.jsx(Rne, {
				ref: n,
				...e,
				style: { isolation: r ? void 0 : "isolate" },
				elementType:
					(D = e.elementType) !== null && D !== void 0 ? D : "div",
				children: C,
			});
		}
		return (
			p && (C = m.jsx(LQ, { ...p, children: C })),
			m.jsx(mv.Provider, {
				value: x,
				children: m.jsx(yne, {
					value: a,
					children: m.jsx(YQ, {
						locale: h,
						children: m.jsx(ate, { children: C }),
					}),
				}),
			})
		);
	}),
	Rne = yi(function (e, n) {
		var r;
		let { children: i, style: o } = e,
			{ locale: s, direction: a } = Vt(),
			{ modalProviderProps: l } = lte(),
			{ colorScheme: u } = Rs();
		const c = (r = e.elementType) !== null && r !== void 0 ? r : "div";
		return m.jsx(c, {
			...l,
			className: `${e.UNSAFE_className ? `${e.UNSAFE_className} ` : ""}${PP({ bodyBackground: e.bodyBackground, colorScheme: u })}`,
			lang: s,
			dir: a,
			ref: n,
			style: { ...o, ...e.UNSAFE_style },
			children: i,
		});
	});
function One(t) {
	const e = ce(6),
		n = Rs();
	let r;
	e[0] !== t.bodyBackground || e[1] !== n.colorScheme
		? ((r = PP({
				bodyBackground: t.bodyBackground,
				colorScheme: n.colorScheme,
			})),
			(e[0] = t.bodyBackground),
			(e[1] = n.colorScheme),
			(e[2] = r))
		: (r = e[2]);
	const i = r;
	let o, s;
	return (
		e[3] !== i
			? ((o = () => {
					const a = i.split(" "),
						l = document.documentElement;
					return (
						l.classList.add(...a),
						() => {
							l.classList.remove(...a);
						}
					);
				}),
				(s = [i]),
				(e[3] = i),
				(e[4] = o),
				(e[5] = s))
			: ((o = e[4]), (s = e[5])),
		E.useLayoutEffect(o, s),
		null
	);
}
let gv = le.createContext({});
function Yr(t, e) {
	let n = t.slot || e,
		{ [n]: r = {} } = E.useContext(gv);
	return xe(t, xe(r, { id: t.id }));
}
const Cn = (t) => {
		const e = ce(6),
			{ children: n, slots: r } = t,
			i = E.useContext(gv);
		let o, s;
		e[0] !== i || e[1] !== r
			? ((s = Object.keys(i)
					.concat(Object.keys(r))
					.reduce((u, c) => ({ ...u, [c]: xe(i[c], r[c]) }), {})),
				(e[0] = i),
				(e[1] = r),
				(e[2] = s))
			: (s = e[2]),
			(o = s);
		const a = o;
		let l;
		return (
			e[3] !== a || e[4] !== n
				? ((l = m.jsx(gv.Provider, { value: a, children: n })),
					(e[3] = a),
					(e[4] = n),
					(e[5] = l))
				: (l = e[5]),
			l
		);
	},
	c0 = (t) => {
		const e = ce(3),
			{ children: n } = t;
		let r;
		e[0] === Symbol.for("react.memo_cache_sentinel")
			? ((r = {}), (e[0] = r))
			: (r = e[0]);
		let i;
		return (
			e[1] !== n
				? ((i = m.jsx(gv.Provider, { value: r, children: n })),
					(e[1] = n),
					(e[2] = i))
				: (i = e[2]),
			i
		);
	},
	Pr = yi((t, e) => {
		t = Yr(t, "content");
		let { elementType: n = "section", children: r, ...i } = t,
			o = ht(i);
		return m.jsx(n, {
			...Ge(i),
			...o,
			ref: e,
			children: m.jsx(c0, { children: r }),
		});
	}),
	Mne = yi((t, e) => {
		t = Yr(t, "footer");
		let { elementType: n = "footer", children: r, ...i } = t,
			o = ht(i);
		return m.jsx(n, { ...Ge(i), ...o, ref: e, children: r });
	});
function Yo(t, e) {
	let {
			elementType: n = "button",
			isDisabled: r,
			onPress: i,
			onPressStart: o,
			onPressEnd: s,
			onPressUp: a,
			onPressChange: l,
			preventFocusOnPress: u,
			allowFocusWhenDisabled: c,
			onClick: d,
			href: f,
			target: h,
			rel: p,
			type: g = "button",
		} = t,
		v;
	n === "button"
		? (v = { type: g, disabled: r })
		: (v = {
				role: "button",
				tabIndex: r ? void 0 : 0,
				href: n === "a" && r ? void 0 : f,
				target: n === "a" ? h : void 0,
				type: n === "input" ? g : void 0,
				disabled: n === "input" ? r : void 0,
				"aria-disabled": !r || n === "input" ? void 0 : r,
				rel: n === "a" ? p : void 0,
			});
	let { pressProps: b, isPressed: y } = zi({
			onPressStart: o,
			onPressEnd: s,
			onPressChange: l,
			onPress: i,
			onPressUp: a,
			isDisabled: r,
			preventFocusOnPress: u,
			ref: e,
		}),
		{ focusableProps: x } = Hd(t, e);
	c && (x.tabIndex = r ? -1 : x.tabIndex);
	let C = xe(x, b, Ge(t, { labelable: !0 }));
	return {
		isPressed: y,
		buttonProps: xe(v, C, {
			"aria-haspopup": t["aria-haspopup"],
			"aria-expanded": t["aria-expanded"],
			"aria-controls": t["aria-controls"],
			"aria-pressed": t["aria-pressed"],
			onClick: (k) => {
				d &&
					(d(k),
					console.warn("onClick is deprecated, please use onPress"));
			},
		}),
	};
}
function jne(t, e, n) {
	const { isSelected: r } = e,
		{ isPressed: i, buttonProps: o } = Yo(
			{ ...t, onPress: hr(e.toggle, t.onPress) },
			n,
		);
	return { isPressed: i, buttonProps: xe(o, { "aria-pressed": r }) };
}
function Wh(t, e) {
	let {
			elementType: n = "a",
			onPress: r,
			onPressStart: i,
			onPressEnd: o,
			onClick: s,
			isDisabled: a,
			...l
		} = t,
		u = {};
	n !== "a" && (u = { role: "link", tabIndex: a ? void 0 : 0 });
	let { focusableProps: c } = Hd(t, e),
		{ pressProps: d, isPressed: f } = zi({
			onPress: r,
			onPressStart: i,
			onPressEnd: o,
			isDisabled: a,
			ref: e,
		}),
		h = Ge(l, { labelable: !0 }),
		p = xe(c, d),
		g = Kd(),
		v = YE(t);
	return {
		isPressed: f,
		linkProps: xe(h, v, {
			...p,
			...u,
			"aria-disabled": a || void 0,
			"aria-current": t["aria-current"],
			onClick: (b) => {
				var y;
				(y = d.onClick) === null || y === void 0 || y.call(d, b),
					s &&
						(s(b),
						console.warn(
							"onClick is deprecated, please use onPress",
						)),
					!g.isNative &&
						b.currentTarget instanceof HTMLAnchorElement &&
						b.currentTarget.href &&
						!b.isDefaultPrevented() &&
						n9(b.currentTarget, b) &&
						t.href &&
						(b.preventDefault(),
						g.open(b.currentTarget, b, t.href, t.routerOptions));
			},
		}),
	};
}
function Yp(t, e) {
	const n = ce(6),
		[r, i] = E.useState(!0);
	let o;
	n[0] !== e.current || n[1] !== t
		? ((o = () => {
				i(!!(e.current && e.current.querySelector(t)));
			}),
			(n[0] = e.current),
			(n[1] = t),
			(n[2] = o))
		: (o = n[2]);
	let s;
	return (
		n[3] !== t || n[4] !== e
			? ((s = [i, t, e]), (n[3] = t), (n[4] = e), (n[5] = s))
			: (s = n[5]),
		at(o, s),
		r
	);
}
function NP(t, e) {
	return E.isValidElement(t) ? E.cloneElement(t, e) : null;
}
function $n(t) {
	return Array.isArray(t)
		? t.every($n)
		: typeof t == "string" || typeof t == "number";
}
function _ne(t) {
	const e = le.useId();
	return t || e;
}
function zne() {
	const t = ce(3),
		e = E.useRef(!1);
	let n, r;
	t[0] === Symbol.for("react.memo_cache_sentinel")
		? ((n = () => (
				(e.current = !0),
				() => {
					e.current = !1;
				}
			)),
			(r = []),
			(t[0] = n),
			(t[1] = r))
		: ((n = t[0]), (r = t[1])),
		E.useEffect(n, r);
	let i;
	return (
		t[2] === Symbol.for("react.memo_cache_sentinel")
			? ((i = () => e.current), (t[2] = i))
			: (i = t[2]),
		i
	);
}
function Lne(t) {
	const e = ce(2),
		n = E.useRef();
	let r;
	return (
		e[0] !== t
			? ((r = () => {
					n.current = t;
				}),
				(e[0] = t),
				(e[1] = r))
			: (r = e[1]),
		E.useEffect(r),
		n.current
	);
}
const RP = E.createContext(void 0);
function OP() {
	return E.useContext(RP);
}
function MP(t) {
	const { capheightTrim: e, baselineTrim: n } = t;
	return {
		display: "block",
		lineHeight: t.lineheight,
		"::before": { content: '" "', display: "table", marginBottom: e },
		"::after": { content: '" "', display: "table", marginTop: n },
	};
}
const jP = E.createContext(void 0);
function aD() {
	return E.useContext(jP);
}
const Vne = new Gr("Text");
function lD(t) {
	const e = ce(30),
		n = aD();
	let r, i, o, s, a, l, u, c, d, f;
	e[0] !== t
		? (({
				align: l,
				casing: c,
				overflow: r,
				size: o,
				color: s,
				trim: i,
				variant: u,
				weight: a,
				UNSAFE_className: f,
				...d
			} = t),
			(e[0] = t),
			(e[1] = r),
			(e[2] = i),
			(e[3] = o),
			(e[4] = s),
			(e[5] = a),
			(e[6] = l),
			(e[7] = u),
			(e[8] = c),
			(e[9] = d),
			(e[10] = f))
		: ((r = e[1]),
			(i = e[2]),
			(o = e[3]),
			(s = e[4]),
			(a = e[5]),
			(l = e[6]),
			(u = e[7]),
			(c = e[8]),
			(d = e[9]),
			(f = e[10]));
	const h = r === void 0 ? "breakword" : r,
		p = i === void 0 ? !n : i,
		g = B.typography.text[o];
	let v, b, y;
	if (
		e[11] !== p ||
		e[12] !== g ||
		e[13] !== s ||
		e[14] !== a ||
		e[15] !== l ||
		e[16] !== u ||
		e[17] !== c ||
		e[18] !== h ||
		e[19] !== d
	) {
		const w = p ? MP(g) : null,
			D = [
				{
					color: yh("color.foreground", s),
					fontFamily: B.typography.fontFamily.base,
					fontSize: g.size,
					fontVariantNumeric: u,
					fontWeight:
						a === "inherit" ? void 0 : B.typography.fontWeight[a],
					minWidth: 0,
					textAlign: l ? Kne[l] : void 0,
					textTransform: c,
				},
				_P,
				h && Une[h],
				w,
			];
		(y = ht),
			(b = d),
			(v = X(D)),
			(e[11] = p),
			(e[12] = g),
			(e[13] = s),
			(e[14] = a),
			(e[15] = l),
			(e[16] = u),
			(e[17] = c),
			(e[18] = h),
			(e[19] = d),
			(e[20] = v),
			(e[21] = b),
			(e[22] = y);
	} else (v = e[20]), (b = e[21]), (y = e[22]);
	let x;
	e[23] === Symbol.for("react.memo_cache_sentinel")
		? ((x = Vne.element("root")), (e[23] = x))
		: (x = e[23]);
	let C;
	e[24] !== v || e[25] !== f
		? ((C = [v, f, x]), (e[24] = v), (e[25] = f), (e[26] = C))
		: (C = e[26]);
	let k;
	return (
		e[27] !== b || e[28] !== C
			? ((k = { ...b, UNSAFE_className: C }),
				(e[27] = b),
				(e[28] = C),
				(e[29] = k))
			: (k = e[29]),
		y(k)
	);
}
const _P = { MozOsxFontSmoothing: "auto", WebkitFontSmoothing: "auto" },
	Kne = {
		start: "start",
		center: "center",
		end: "end",
		FORCE_left: "left",
		FORCE_right: "right",
	},
	Une = {
		unset: {},
		nowrap: { whiteSpace: "nowrap" },
		breakword: { overflowWrap: "break-word" },
	},
	Hne = new Gr("Heading");
function Wne(t) {
	const e = ce(19);
	let n, r, i, o;
	e[0] !== t
		? (({ align: r, size: n, UNSAFE_className: o, ...i } = t),
			(e[0] = t),
			(e[1] = n),
			(e[2] = r),
			(e[3] = i),
			(e[4] = o))
		: ((n = e[1]), (r = e[2]), (i = e[3]), (o = e[4]));
	const s = B.typography.heading[n];
	let a, l, u;
	if (e[5] !== s || e[6] !== n || e[7] !== r || e[8] !== i) {
		const h = MP(s),
			p = [
				{
					color: B.color.foreground.neutralEmphasis,
					fontSize: s.size,
					fontFamily: B.typography.fontFamily.base,
					fontWeight: qne[n],
					textAlign: r,
				},
				_P,
				h,
			];
		(u = ht),
			(l = i),
			(a = X(p)),
			(e[5] = s),
			(e[6] = n),
			(e[7] = r),
			(e[8] = i),
			(e[9] = a),
			(e[10] = l),
			(e[11] = u);
	} else (a = e[9]), (l = e[10]), (u = e[11]);
	let c;
	e[12] === Symbol.for("react.memo_cache_sentinel")
		? ((c = Hne.element("root")), (e[12] = c))
		: (c = e[12]);
	let d;
	e[13] !== a || e[14] !== o
		? ((d = [a, o, c]), (e[13] = a), (e[14] = o), (e[15] = d))
		: (d = e[15]);
	let f;
	return (
		e[16] !== l || e[17] !== d
			? ((f = { ...l, UNSAFE_className: d }),
				(e[16] = l),
				(e[17] = d),
				(e[18] = f))
			: (f = e[18]),
		u(f)
	);
}
const qne = {
	small: B.typography.fontWeight.semibold,
	regular: B.typography.fontWeight.bold,
	medium: B.typography.fontWeight.medium,
	large: B.typography.fontWeight.bold,
};
function zP(t) {
	const e = ce(11);
	let n, r, i;
	e[0] !== t
		? (({ lines: n, title: r, ...i } = t),
			(e[0] = t),
			(e[1] = n),
			(e[2] = r),
			(e[3] = i))
		: ((n = e[1]), (r = e[2]), (i = e[3]));
	const o = Gne(typeof n == "boolean" ? 1 : n);
	let s;
	if (e[4] !== r || e[5] !== i) {
		var a;
		(s =
			(a = r) !== null && a !== void 0
				? a
				: $n(i.children)
					? i.children.toString()
					: void 0),
			(e[4] = r),
			(e[5] = i),
			(e[6] = s);
	} else s = e[6];
	let l;
	return (
		e[7] !== o || e[8] !== s || e[9] !== i
			? ((l = m.jsx("span", { className: o, title: s, ...i })),
				(e[7] = o),
				(e[8] = s),
				(e[9] = i),
				(e[10] = l))
			: (l = e[10]),
		l
	);
}
function Gne(t) {
	return X({
		display: "-webkit-box",
		WebkitLineClamp: t,
		textOverflow: "ellipsis",
		WebkitBoxOrient: "vertical",
		overflow: "hidden",
	});
}
function LP(t) {
	const e = Cne(),
		{ visuallyHiddenProps: n } = Ea();
	if (t && e(t)) return n;
}
const Yne = { small: "h4", regular: "h3", medium: "h2", large: "h1" },
	Jne = { propNames: new Set(["aria-hidden"]) },
	Ut = yi((t, e) => {
		t = Yr(t, "heading");
		const {
				children: n,
				size: r = "regular",
				truncate: i,
				elementType: o = Yne[r],
				...s
			} = t,
			a = Wne({ size: r, ...t }),
			l = E.useMemo(() => ({ size: r }), [r]),
			u = LP(t.visuallyHidden),
			c = i ? m.jsx(zP, { lines: i, children: n }) : n;
		return m.jsx(RP.Provider, {
			value: l,
			children: m.jsx(o, {
				ref: e,
				...Ge(s, Jne),
				...a,
				...u,
				children: c,
			}),
		});
	}),
	Xne = { propNames: new Set(["aria-hidden", "role"]) },
	ue = yi((t, e) => {
		var n, r, i;
		t = Yr(t, "text");
		const o = OP(),
			s = aD();
		if ((Zne(t, s), o)) return m.jsx("span", { children: t.children });
		const {
				children: a,
				color: l = (n = s == null ? void 0 : s.color) !== null &&
				n !== void 0
					? n
					: "neutral",
				elementType: u = "span",
				size: c = (r = s == null ? void 0 : s.size) !== null &&
				r !== void 0
					? r
					: "regular",
				trim: d = !s,
				truncate: f,
				visuallyHidden: h,
				weight: p = (i = s == null ? void 0 : s.weight) !== null &&
				i !== void 0
					? i
					: "regular",
				...g
			} = t,
			v = lD({ color: l, size: c, trim: d, weight: p, ...g }),
			b = LP(h),
			y = f ? m.jsx(zP, { lines: f, children: a }) : a,
			x = m.jsx(u, { ref: e, ...Ge(g, Xne), ...v, ...b, children: y }),
			C = E.useMemo(() => ({ size: c, color: l, weight: p }), [c, l, p]);
		return s || h ? x : m.jsx(jP.Provider, { value: C, children: x });
	});
function Zne(t, e) {
	wt(!e || !t.align, 'The "align" prop is unsupported on nested Text.'),
		wt(!e || !t.trim, 'The "trim" prop is unsupported on nested Text.');
}
function Qne() {
	return () => {};
}
function ere() {
	const t = ce(1);
	let e;
	return (
		t[0] === Symbol.for("react.memo_cache_sentinel")
			? ((e = () => !1), (t[0] = e))
			: (e = t[0]),
		E.useSyncExternalStore(Qne, Ss, e)
	);
}
const fi = E.forwardRef(function (e, n) {
	const r = ce(25);
	e = Yr(e, "kbd");
	let i, o, s, a, l;
	r[0] !== e
		? (({ alt: o, meta: s, shift: a, children: l, ...i } = e),
			(r[0] = e),
			(r[1] = i),
			(r[2] = o),
			(r[3] = s),
			(r[4] = a),
			(r[5] = l))
		: ((i = r[1]), (o = r[2]), (s = r[3]), (a = r[4]), (l = r[5]));
	let u;
	r[6] !== i
		? ((u = {
				casing: "full-width",
				color: "neutral",
				size: "regular",
				weight: "regular",
				...i,
			}),
			(r[6] = i),
			(r[7] = u))
		: (u = r[7]);
	const c = lD(u),
		d = ere();
	let f, h;
	r[8] !== d
		? ((h = d
				? { alt: "⌥", meta: "⌘", shift: "⇧" }
				: { alt: "Alt", meta: "Ctrl", shift: "Shift" }),
			(r[8] = d),
			(r[9] = h))
		: (h = r[9]);
	const p = h,
		g = o && p.alt,
		v = a && p.shift,
		b = s && p.meta;
	let y;
	if (r[10] !== g || r[11] !== v || r[12] !== b || r[13] !== d) {
		const D = [g, v, b].filter(Boolean);
		(y = nre(D, d)),
			(r[10] = g),
			(r[11] = v),
			(r[12] = b),
			(r[13] = d),
			(r[14] = y);
	} else y = r[14];
	f = y;
	const x = f;
	let C;
	r[15] !== i ? ((C = Ge(i)), (r[15] = i), (r[16] = C)) : (C = r[16]);
	let k;
	r[17] !== l
		? ((k = m.jsx(tre, { children: l })), (r[17] = l), (r[18] = k))
		: (k = r[18]);
	let w;
	return (
		r[19] !== C || r[20] !== c || r[21] !== n || r[22] !== x || r[23] !== k
			? ((w = m.jsxs("kbd", {
					...C,
					...c,
					dir: "ltr",
					ref: n,
					children: [x, k],
				})),
				(r[19] = C),
				(r[20] = c),
				(r[21] = n),
				(r[22] = x),
				(r[23] = k),
				(r[24] = w))
			: (w = r[24]),
		w
	);
});
function tre(t) {
	const e = ce(3);
	let n;
	e[0] === Symbol.for("react.memo_cache_sentinel")
		? ((n = X({
				display: "inline-block",
				minWidth: "1em",
				textAlign: "center",
			})),
			(e[0] = n))
		: (n = e[0]);
	let r;
	return (
		e[1] !== t
			? ((r = m.jsx("span", { className: n, ...t })),
				(e[1] = t),
				(e[2] = r))
			: (r = e[2]),
		r
	);
}
function nre(t, e) {
	if (t.length === 0) return "";
	let n = e ? "" : "+";
	return t.join(n) + n;
}
const rre = yi((t, e) => {
	const { children: n, elementType: r = "div", ...i } = t,
		o = VP(i);
	return m.jsx(r, { ref: e, ...qd(i), ...o, children: n });
});
function VP(t) {
	const e = ce(11);
	let n, r;
	e[0] !== t
		? (({ size: n, ...r } = t), (e[0] = t), (e[1] = n), (e[2] = r))
		: ((n = e[1]), (r = e[2]));
	const i = n === void 0 ? "medium" : n,
		o = ht(r);
	let s;
	e[3] !== i ? ((s = lt({ size: i })), (e[3] = i), (e[4] = s)) : (s = e[4]);
	let a;
	e[5] !== o.className
		? ((a = Se(
				X({
					color: B.color.foreground.neutral,
					fontFamily: B.typography.fontFamily.base,
					height: "100%",
					maxWidth: "100%",
					minHeight: 0,
					minWidth: 0,
					position: "relative",
					overflowWrap: "break-word",
					whiteSpace: "break-spaces",
					fontVariantLigatures: "none",
					fontFeatureSettings: '"liga" 0',
					MozOsxFontSmoothing: "auto",
					WebkitFontSmoothing: "auto",
					'&[data-size="small"]': {
						fontSize: B.typography.text.small.size,
						lineHeight: 1.6,
					},
					'&[data-size="regular"]': {
						fontSize: B.typography.text.regular.size,
						lineHeight: 1.5,
					},
					'&[data-size="medium"]': {
						fontSize: B.typography.text.medium.size,
						lineHeight: 1.5,
					},
					'&[data-size="large"]': {
						fontSize: B.typography.text.large.size,
						lineHeight: 1.4,
					},
					"& :is(blockquote, p, pre, ol, ul, table)": {
						marginBlock: "0.75em",
						":first-child": { marginTop: 0 },
						":last-child": { marginBottom: 0 },
					},
					"ol, ul": { paddingInlineStart: "1em" },
					"ol ol, ul ul, ol ul, ul ol": { marginBlock: 0 },
					"li :is(blockquote, p, pre, ol, ul, table)": {
						marginBottom: 0,
					},
					blockquote: {
						borderInlineStart: `${B.size.border.large} solid ${B.color.foreground.neutral}`,
						marginInline: 0,
						paddingInlineStart: "1em",
					},
					hr: {
						backgroundColor: B.color.alias.borderIdle,
						border: 0,
						borderRadius: B.size.border.medium,
						height: B.size.border.medium,
						marginBlock: "1.5em",
					},
					img: { height: "auto", maxWidth: "100%" },
					strong: { fontWeight: B.typography.fontWeight.semibold },
					a: { color: B.color.foreground.accent },
					pre: {
						backgroundColor: B.color.background.surface,
						borderRadius: B.size.radius.medium,
						color: B.color.foreground.neutralEmphasis,
						fontFamily: B.typography.fontFamily.code,
						fontSize: "0.85em",
						lineHeight: B.typography.lineheight.medium,
						minWidth: 0,
						maxWidth: "100%",
						overflow: "auto",
						padding: B.size.space.medium,
						whiteSpace: "pre-wrap",
					},
					"pre > code": { fontFamily: "inherit" },
					"& :not(pre) > code": {
						backgroundColor: B.color.background.accent,
						borderRadius: B.size.radius.small,
						color: B.color.foreground.neutralEmphasis,
						display: "inline-block",
						fontSize: "0.85em",
						fontFamily: B.typography.fontFamily.code,
						paddingInline: B.size.space.small,
					},
					"& :is(h1, h2, h3, h4, h5, h6)": {
						color: B.color.foreground.neutralEmphasis,
						lineHeight: 1.25,
						marginTop: "1.5em",
						marginBottom: "0.67em",
						":first-child": { marginTop: 0 },
						":last-child": { marginBottom: 0 },
					},
					h1: {
						fontSize: "2em",
						fontWeight: B.typography.fontWeight.bold,
					},
					h2: {
						fontSize: "1.5em",
						fontWeight: B.typography.fontWeight.bold,
					},
					h3: {
						fontSize: "1.25em",
						fontWeight: B.typography.fontWeight.bold,
					},
					h4: {
						fontSize: "1.1em",
						fontWeight: B.typography.fontWeight.semibold,
					},
					h5: {
						fontSize: "1em",
						fontWeight: B.typography.fontWeight.semibold,
					},
					h6: {
						fontSize: "0.9em",
						fontWeight: B.typography.fontWeight.semibold,
						letterSpacing: "0.0125em",
					},
					...ire(),
				}),
				o.className,
			)),
			(e[5] = o.className),
			(e[6] = a))
		: (a = e[6]);
	let l;
	return (
		e[7] !== o || e[8] !== s || e[9] !== a
			? ((l = { ...o, ...s, className: a }),
				(e[7] = o),
				(e[8] = s),
				(e[9] = a),
				(e[10] = l))
			: (l = e[10]),
		l
	);
}
function ire() {
	let t = {},
		e = 10;
	const n = ["lower-roman", "decimal", "lower-alpha"],
		r = ["square", "disc", "circle"];
	for (; e--; ) {
		let i = Array.from({ length: e });
		i.length &&
			((t[i.map(() => "ol").join(" ")] = { listStyle: n[e % 3] }),
			(t[i.map(() => "ul").join(" ")] = { listStyle: r[e % 3] }));
	}
	return t;
}
function uD(t) {
	let {
		id: e,
		label: n,
		"aria-labelledby": r,
		"aria-label": i,
		labelElementType: o = "label",
	} = t;
	e = Ot(e);
	let s = Ot(),
		a = {};
	n
		? ((r = r ? `${s} ${r}` : s),
			(a = { id: s, htmlFor: o === "label" ? e : void 0 }))
		: !r &&
			!i &&
			console.warn(
				"If you do not provide a visible label, you must specify an aria-label or aria-labelledby attribute for accessibility",
			);
	let l = tv({ id: e, "aria-label": i, "aria-labelledby": r });
	return { labelProps: a, fieldProps: l };
}
function Gd(t) {
	let {
			description: e,
			errorMessage: n,
			isInvalid: r,
			validationState: i,
		} = t,
		{ labelProps: o, fieldProps: s } = uD(t),
		a = Lo([!!e, !!n, r, i]),
		l = Lo([!!e, !!n, r, i]);
	return (
		(s = xe(s, {
			"aria-describedby":
				[a, l, t["aria-describedby"]].filter(Boolean).join(" ") ||
				void 0,
		})),
		{
			labelProps: o,
			fieldProps: s,
			descriptionProps: { id: a },
			errorMessageProps: { id: l },
		}
	);
}
function ore(t) {
	let {
			value: e = 0,
			minValue: n = 0,
			maxValue: r = 100,
			valueLabel: i,
			isIndeterminate: o,
			formatOptions: s = { style: "percent" },
		} = t,
		a = Ge(t, { labelable: !0 }),
		{ labelProps: l, fieldProps: u } = uD({
			...t,
			labelElementType: "span",
		});
	e = rl(e, n, r);
	let c = (e - n) / (r - n),
		d = ZC(s);
	if (!o && !i) {
		let f = s.style === "percent" ? c : e;
		i = d.format(f);
	}
	return {
		progressBarProps: xe(a, {
			...u,
			"aria-valuenow": o ? void 0 : e,
			"aria-valuemin": n,
			"aria-valuemax": r,
			"aria-valuetext": o ? void 0 : i,
			role: "progressbar",
		}),
		labelProps: l,
	};
}
Uh({
	from: { transform: "translate(-100%)" },
	to: { transform: "translate(100%)" },
});
Uh({
	from: { transform: "translate(100%)" },
	to: { transform: "translate(-100%)" },
});
const Cr = E.forwardRef(function (e, n) {
	var r, i, o;
	const s = ce(40);
	let a, l, u, c, d, f, h, p;
	s[0] !== e
		? (({
				value: a,
				minValue: l,
				maxValue: u,
				size: c,
				isIndeterminate: p,
				"aria-label": f,
				"aria-labelledby": h,
				...d
			} = e),
			(s[0] = e),
			(s[1] = a),
			(s[2] = l),
			(s[3] = u),
			(s[4] = c),
			(s[5] = d),
			(s[6] = f),
			(s[7] = h),
			(s[8] = p))
		: ((a = s[1]),
			(l = s[2]),
			(u = s[3]),
			(c = s[4]),
			(d = s[5]),
			(f = s[6]),
			(h = s[7]),
			(p = s[8]));
	let g = a === void 0 ? 0 : a;
	const v = l === void 0 ? 0 : l,
		b = u === void 0 ? 100 : u,
		y = c === void 0 ? "medium" : c;
	g = rl(g, v, b);
	let x;
	s[9] !== e || s[10] !== g
		? ((x = { ...e, value: g }), (s[9] = e), (s[10] = g), (s[11] = x))
		: (x = s[11]);
	const { progressBarProps: C } = ore(x),
		k = ht(d),
		w = (r = p) !== null && r !== void 0 ? r : void 0,
		D = y === "medium" ? void 0 : y;
	let S;
	s[12] !== w || s[13] !== D
		? ((S = lt({ indeterminate: w, size: D })),
			(s[12] = w),
			(s[13] = D),
			(s[14] = S))
		: (S = s[14]);
	let $;
	s[15] !== k.className
		? (($ = Se(
				X({
					height: "var(--diameter)",
					width: "var(--diameter)",
					"--diameter": B.size.element.regular,
					"--radius": "calc(var(--diameter) / 2)",
					"--stroke-width": B.size.scale[40],
					"--offset-radius":
						"calc(var(--radius) - var(--stroke-width) / 2)",
					"--circumference": "calc(var(--offset-radius) * pi * 2)",
					"&[data-size=small]": {
						"--diameter": B.size.element.xsmall,
						"--stroke-width": B.size.border.medium,
					},
					"&[data-size=large]": {
						"--diameter": B.size.element.xlarge,
						"--stroke-width": B.size.border.large,
					},
				}),
				k.className,
			)),
			(s[15] = k.className),
			(s[16] = $))
		: ($ = s[16]);
	const A = (g - v) / (b - v);
	let T;
	s[17] !== A || s[18] !== k.style
		? ((T = { "--percent": A, ...k.style }),
			(s[17] = A),
			(s[18] = k.style),
			(s[19] = T))
		: (T = s[19]);
	const I = (i = p) !== null && i !== void 0 ? i : void 0;
	let F;
	s[20] !== I
		? ((F = lt({ indeterminate: I })), (s[20] = I), (s[21] = F))
		: (F = s[21]);
	let N;
	s[22] === Symbol.for("react.memo_cache_sentinel")
		? ((N = X({
				height: "var(--diameter)",
				width: "var(--diameter)",
				"&[data-indeterminate]": {
					animation: `${sre} ${B.animation.duration.xlong} linear infinite`,
				},
			})),
			(s[22] = N))
		: (N = s[22]);
	let O;
	s[23] === Symbol.for("react.memo_cache_sentinel")
		? ((O = m.jsx("circle", {
				className: O6({ stroke: B.color.border.muted }),
			})),
			(s[23] = O))
		: (O = s[23]);
	const _ = (o = p) !== null && o !== void 0 ? o : void 0;
	let j;
	s[24] !== _
		? ((j = lt({ indeterminate: _ })), (s[24] = _), (s[25] = j))
		: (j = s[25]);
	let V;
	s[26] === Symbol.for("react.memo_cache_sentinel")
		? ((V = O6({
				stroke: B.color.background.accentEmphasis,
				strokeDasharray: "var(--circumference)",
				strokeLinecap: "round",
				"&:not([data-indeterminate])": {
					strokeDashoffset:
						"calc(var(--circumference) - var(--percent) * var(--circumference))",
					transition: bt("stroke-dashoffset", {
						duration: "regular",
					}),
					transform: "rotate(-90deg)",
					transformOrigin: "center",
				},
				"&[data-indeterminate]": {
					animation: `${are} ${B.animation.duration.xlong} ${B.animation.easing.easeInOut} infinite`,
				},
			})),
			(s[26] = V))
		: (V = s[26]);
	let K;
	s[27] !== j
		? ((K = m.jsx("circle", { ...j, className: V })),
			(s[27] = j),
			(s[28] = K))
		: (K = s[28]);
	let M;
	s[29] !== F || s[30] !== K
		? ((M = m.jsxs("svg", {
				...F,
				role: "presentation",
				tabIndex: -1,
				className: N,
				children: [O, K],
			})),
			(s[29] = F),
			(s[30] = K),
			(s[31] = M))
		: (M = s[31]);
	let G;
	return (
		s[32] !== k ||
		s[33] !== C ||
		s[34] !== n ||
		s[35] !== S ||
		s[36] !== $ ||
		s[37] !== T ||
		s[38] !== M
			? ((G = m.jsx("div", {
					...k,
					...C,
					ref: n,
					...S,
					className: $,
					style: T,
					children: M,
				})),
				(s[32] = k),
				(s[33] = C),
				(s[34] = n),
				(s[35] = S),
				(s[36] = $),
				(s[37] = T),
				(s[38] = M),
				(s[39] = G))
			: (G = s[39]),
		G
	);
});
function O6(t) {
	return X([
		{
			cx: "var(--radius)",
			cy: "var(--radius)",
			r: "var(--offset-radius)",
			fill: "transparent",
			strokeWidth: "var(--stroke-width)",
		},
		t,
	]);
}
const sre = Uh({
		from: { transform: "rotate(0deg)" },
		to: { transform: "rotate(360deg)" },
	}),
	are = Uh({
		from: { strokeDashoffset: "calc(var(--circumference) * 1.25)" },
		to: { strokeDashoffset: "calc(var(--circumference) * -0.75)" },
	}),
	cD = m.jsx("path", { d: "M18 6 6 18M6 6l12 12" }),
	M6 = `--${Wd}-icon-stroke`,
	ve = (t) => {
		var e;
		t = Yr(t, "icon");
		const { strokeScaling: n, size: r, color: i, ...o } = t,
			s =
				(e = yh("color.foreground", i)) !== null && e !== void 0
					? e
					: "currentColor",
			a = X({
				fill: "none",
				stroke: `var(${M6})`,
				flexShrink: 0,
				height: B.size.icon.regular,
				width: B.size.icon.regular,
				"&[data-size=small]": {
					height: B.size.icon.small,
					width: B.size.icon.small,
				},
				"&[data-size=medium]": {
					height: B.size.icon.medium,
					width: B.size.icon.medium,
				},
				"&[data-size=large]": {
					height: B.size.icon.large,
					width: B.size.icon.large,
				},
				"&[data-stroke-scaling=false] > *": {
					vectorEffect: "non-scaling-stroke",
				},
			}),
			l = ht(o),
			u = "aria-label" in t && !!t["aria-label"];
		return m.jsx("svg", {
			xmlns: "http://www.w3.org/2000/svg",
			viewBox: "0 0 24 24",
			strokeWidth: 2,
			strokeLinecap: "round",
			strokeLinejoin: "round",
			...lt({ strokeScaling: n, size: r }),
			...Ge(o, { labelable: !0 }),
			"aria-hidden": !u,
			focusable: "false",
			role: "img",
			className: Se(a, l.className),
			style: { [M6]: s, ...l.style },
			height: "1em",
			children: t.src,
		});
	};
function dD(t = {}) {
	let { isReadOnly: e } = t,
		[n, r] = Ns(t.isSelected, t.defaultSelected || !1, t.onChange);
	function i(s) {
		e || r(s);
	}
	function o() {
		e || r(!n);
	}
	return { isSelected: n, setSelected: i, toggle: o };
}
function lre(t, e, n, r, i) {
	return () => {
		let o = () => {
			if (t.current && e === "horizontal") {
				let s = Array.from(t.current.children),
					a = t.current.offsetWidth + 1;
				return !!s.some(
					(l) => l.offsetLeft < 0 || l.offsetLeft + l.offsetWidth > a,
				);
			}
		};
		e === "horizontal" &&
			r(function* () {
				yield !1, yield o();
			});
	};
}
const Nr = E.forwardRef(function (e, n) {
		const r = ce(37),
			{ scale: i } = Rs();
		(e = vo(e)), (e = Yr(e, "buttonGroup"));
		let o, s, a, l, u;
		r[0] !== e
			? (({
					align: o,
					children: l,
					isDisabled: u,
					orientation: s,
					...a
				} = e),
				(r[0] = e),
				(r[1] = o),
				(r[2] = s),
				(r[3] = a),
				(r[4] = l),
				(r[5] = u))
			: ((o = r[1]), (s = r[2]), (a = r[3]), (l = r[4]), (u = r[5]));
		const c = o === void 0 ? "start" : o,
			d = s === void 0 ? "horizontal" : s,
			f = ht(a),
			h = Ct(n),
			[p, g] = ox(!1);
		let v, b;
		r[6] !== h || r[7] !== d || r[8] !== i || r[9] !== g || r[10] !== l
			? ((b = lre(h, d, i, g)),
				(r[6] = h),
				(r[7] = d),
				(r[8] = i),
				(r[9] = g),
				(r[10] = l),
				(r[11] = b))
			: (b = r[11]),
			(v = b);
		const y = v;
		let x, C;
		r[12] !== y
			? ((x = () => {
					y();
				}),
				(C = [y]),
				(r[12] = y),
				(r[13] = x),
				(r[14] = C))
			: ((x = r[13]), (C = r[14])),
			at(x, C);
		const k = E.useRef();
		let w;
		r[15] !== h.current
			? ((w = () => {
					h.current && (k.current = h.current.parentElement);
				}),
				(r[15] = h.current),
				(r[16] = w))
			: (w = r[16]),
			at(w);
		let D;
		r[17] !== k || r[18] !== y
			? ((D = { ref: k, onResize: y }),
				(r[17] = k),
				(r[18] = y),
				(r[19] = D))
			: (D = r[19]),
			fa(D);
		let S;
		r[20] !== a ? ((S = Ge(a)), (r[20] = a), (r[21] = S)) : (S = r[21]);
		const $ = p ? "vertical" : d;
		let A;
		r[22] !== c || r[23] !== $
			? ((A = lt({ align: c, orientation: $ })),
				(r[22] = c),
				(r[23] = $),
				(r[24] = A))
			: (A = r[24]);
		let T;
		r[25] !== f.className
			? ((T = Se(
					f.className,
					X({
						alignItems: "flex-start",
						display: "inline-flex",
						gap: B.size.space.regular,
						position: "relative",
						'&[data-orientation="horizontal"]': {
							'&[data-align="center"]': {
								justifyContent: "center",
							},
							'&[data-align="end"]': {
								justifyContent: "flex-end",
							},
						},
						'&[data-orientation="vertical"]': {
							flexDirection: "column",
							'&[data-align="center"]': { alignItems: "center" },
							'&[data-align="end"]': { alignItems: "flex-end" },
						},
					}),
				)),
				(r[25] = f.className),
				(r[26] = T))
			: (T = r[26]);
		let I;
		r[27] !== u || r[28] !== l
			? ((I = m.jsx(Hh, { isDisabled: u, children: l })),
				(r[27] = u),
				(r[28] = l),
				(r[29] = I))
			: (I = r[29]);
		let F;
		return (
			r[30] !== S ||
			r[31] !== A ||
			r[32] !== f ||
			r[33] !== h ||
			r[34] !== T ||
			r[35] !== I
				? ((F = m.jsx("div", {
						...S,
						...A,
						...f,
						ref: h,
						className: T,
						children: I,
					})),
					(r[30] = S),
					(r[31] = A),
					(r[32] = f),
					(r[33] = h),
					(r[34] = T),
					(r[35] = I),
					(r[36] = F))
				: (F = r[36]),
			F
		);
	}),
	ure = {
		"ar-AE": { pending: "قيد الانتظار" },
		"bg-BG": { pending: "недовършено" },
		"cs-CZ": { pending: "čeká na vyřízení" },
		"da-DK": { pending: "afventende" },
		"de-DE": { pending: "Ausstehend" },
		"el-GR": { pending: "σε εκκρεμότητα" },
		"en-US": { pending: "pending" },
		"es-ES": { pending: "pendiente" },
		"et-EE": { pending: "ootel" },
		"fi-FI": { pending: "odottaa" },
		"fr-FR": { pending: "En attente" },
		"he-IL": { pending: "ממתין ל" },
		"hr-HR": { pending: "u tijeku" },
		"hu-HU": { pending: "függőben levő" },
		"it-IT": { pending: "in sospeso" },
		"ja-JP": { pending: "保留" },
		"ko-KR": { pending: "보류 중" },
		"lt-LT": { pending: "laukiama" },
		"lv-LV": { pending: "gaida" },
		"nb-NO": { pending: "avventer" },
		"nl-NL": { pending: "in behandeling" },
		"pl-PL": { pending: "oczekujące" },
		"pt-BR": { pending: "pendente" },
		"pt-PT": { pending: "pendente" },
		"ro-RO": { pending: "în așteptare" },
		"ru-RU": { pending: "в ожидании" },
		"sk-SK": { pending: "čakajúce" },
		"sl-SI": { pending: "v teku" },
		"sr-SP": { pending: "nerešeno" },
		"sv-SE": { pending: "väntande" },
		"tr-TR": { pending: "beklemede" },
		"uk-UA": { pending: "в очікуванні" },
		"zh-CN": { pending: "待处理" },
		"zh-TW": { pending: "待處理" },
	},
	Cc = new Gr("Button", ["icon", "text"]);
function KP(t, e) {
	const {
			prominence: n = "default",
			tone: r = n === "high" ? "accent" : "neutral",
		} = t,
		{ isHovered: i, isPending: o, isPressed: s } = e,
		a = ht(t);
	return {
		...lt({
			hovered: i || void 0,
			pending: o || void 0,
			pressed: s || void 0,
			prominence: n === "default" ? void 0 : n,
			tone: r,
			static: t.static,
		}),
		style: a.style,
		className: Se(
			Cc.element("root"),
			X({
				alignItems: "center",
				borderRadius: B.size.radius.full,
				cursor: "default",
				display: "inline-flex",
				flexShrink: 0,
				fontSize: B.typography.text.regular.size,
				fontWeight: B.typography.fontWeight.medium,
				height: B.size.element.regular,
				justifyContent: "center",
				minWidth: B.size.element.regular,
				outline: 0,
				paddingInline: B.size.space.medium,
				position: "relative",
				transitionDuration: "130ms",
				transitionProperty:
					"background, border-color, box-shadow, color, ",
				transitionTimingFunction: "ease-out",
				userSelect: "none",
				"a&": { cursor: "pointer" },
				"&:disabled, &[aria-disabled]": { cursor: "default" },
				[Cc.selector("text", "descendant")]: {
					fontSize: "inherit",
					fontWeight: "inherit",
					marginInline: B.size.space.regular,
				},
				[`&[data-pending] ${Cc.selector("text")}`]: { opacity: 0 },
				[Cc.selector("icon", "descendant")]: {
					height: B.size.scale[225],
					width: B.size.scale[225],
				},
				[`&[data-pending] ${Cc.selector("icon")}`]: { opacity: 0 },
				"--focus-ring-color": B.color.alias.focusRing,
				"&[data-static=light]": { "--focus-ring-color": "#fff" },
				"&[data-static=dark]": { "--focus-ring-color": "#000" },
				"&::after": {
					borderRadius: B.size.radius.full,
					content: '""',
					inset: 0,
					pointerEvents: "none",
					position: "absolute",
					transition: bt(["box-shadow", "margin"], {
						easing: "easeOut",
					}),
				},
				"&[data-focus=visible]::after": {
					boxShadow: `0 0 0 ${B.size.alias.focusRing} var(--focus-ring-color)`,
					margin: `calc(-1 * ${B.size.alias.focusRingGap})`,
				},
				"&:not([data-prominence])": {
					backgroundColor: B.color.scale.slate4,
					color: B.color.foreground.neutralEmphasis,
					'&[data-hovered], &[data-focus="visible"]': {
						backgroundColor: B.color.scale.slate5,
					},
					"&[data-pressed]": {
						backgroundColor: B.color.scale.slate6,
					},
					"&[data-tone=accent]": { color: B.color.foreground.accent },
					"&[data-tone=critical]": {
						color: B.color.foreground.critical,
					},
					"&:disabled, &[aria-disabled=true]": {
						backgroundColor: B.color.alias.backgroundDisabled,
						color: B.color.alias.foregroundDisabled,
					},
					"&[data-static=light]": {
						backgroundColor: "#ffffff12",
						color: "#fff",
						'&[data-hovered], &[data-focus="visible"]': {
							backgroundColor: "#ffffff1a",
						},
						"&[data-pressed]": { backgroundColor: "#ffffff26" },
						"&:disabled, &[aria-disabled]": {
							backgroundColor: "#ffffff1a",
							color: "#ffffff8c",
						},
					},
					"&[data-static=dark]": {
						backgroundColor: "#00000012",
						color: "#000",
						'&[data-hovered], &[data-focus="visible"]': {
							backgroundColor: "#0000001a",
						},
						"&[data-pressed]": { backgroundColor: "#00000026" },
						"&:disabled, &[aria-disabled]": {
							backgroundColor: "#0000001a",
							color: "#0000008c",
						},
					},
				},
				"&[data-prominence=high]": {
					backgroundColor: B.color.scale.slate10,
					color: B.color.foreground.inverse,
					'&[data-hovered], &[data-focus="visible"]': {
						backgroundColor: B.color.scale.slate11,
					},
					"&[data-pressed]": {
						backgroundColor: B.color.scale.slate11,
					},
					"&[data-tone=accent]": {
						backgroundColor: B.color.scale.indigo9,
						color: B.color.foreground.onEmphasis,
						'&[data-hovered], &[data-focus="visible"]': {
							backgroundColor: B.color.scale.indigo10,
						},
						"&[data-pressed]": {
							backgroundColor: B.color.scale.indigo11,
						},
					},
					"&[data-tone=critical]": {
						backgroundColor: B.color.scale.red9,
						color: B.color.foreground.onEmphasis,
						'&[data-hovered], &[data-focus="visible"]': {
							backgroundColor: B.color.scale.red10,
						},
						"&[data-pressed]": {
							backgroundColor: B.color.scale.red11,
						},
					},
					"&[data-tone]:disabled, &[data-tone][aria-disabled=true]": {
						backgroundColor: B.color.alias.backgroundDisabled,
						color: B.color.alias.foregroundDisabled,
					},
					"&[data-static=light]": {
						backgroundColor: "#ffffffe6",
						color: "#000",
						'&[data-hovered], &[data-focus="visible"]': {
							backgroundColor: "#fff",
						},
						"&[data-pressed]": { backgroundColor: "#fff" },
						"&:disabled, &[aria-disabled]": {
							backgroundColor: "#ffffff1a",
							color: "#ffffff8c",
						},
					},
					"&[data-static=dark]": {
						backgroundColor: "#000000e6",
						color: "#fff",
						'&[data-hovered], &[data-focus="visible"]': {
							backgroundColor: "#000",
						},
						"&[data-pressed]": { backgroundColor: "#000" },
						"&:disabled, &[aria-disabled]": {
							backgroundColor: "#0000001a",
							color: "#0000008c",
						},
					},
				},
				"&[data-prominence=low]": {
					color: B.color.foreground.neutral,
					'&[data-hovered], &[data-focus="visible"]': {
						backgroundColor: B.color.alias.backgroundHovered,
						color: B.color.foreground.neutralEmphasis,
					},
					"&[data-pressed]": {
						backgroundColor: B.color.alias.backgroundPressed,
					},
					"&[data-tone=accent]": {
						color: B.color.foreground.accent,
						'&[data-hovered], &[data-focus="visible"]': {
							backgroundColor: B.color.scale.indigo3,
						},
						"&[data-pressed]": {
							backgroundColor: B.color.scale.indigo4,
						},
					},
					"&[data-tone=critical]": {
						color: B.color.foreground.critical,
						'&[data-hovered], &[data-focus="visible"]': {
							backgroundColor: B.color.scale.red3,
						},
						"&[data-pressed]": {
							backgroundColor: B.color.scale.red4,
						},
					},
					"&:disabled, &[aria-disabled=true]": {
						backgroundColor: B.color.alias.backgroundDisabled,
						color: B.color.alias.foregroundDisabled,
					},
					"&[data-static=light]": {
						color: "#fff",
						'&[data-hovered], &[data-focus="visible"]': {
							backgroundColor: "#ffffff1a",
						},
						"&[data-pressed]": { backgroundColor: "#ffffff26" },
						"&:disabled, &[aria-disabled]": { color: "#ffffff8c" },
					},
					"&[data-static=dark]": {
						color: "#000",
						'&[data-hovered], &[data-focus="visible"]': {
							backgroundColor: "#0000001a",
						},
						"&[data-pressed]": { backgroundColor: "#00000026" },
						"&:disabled, &[aria-disabled]": { color: "#0000008c" },
					},
				},
			}),
			a.className,
		),
	};
}
const vt = E.forwardRef(function (e, n) {
		const r = ce(14);
		(e = vo(e)), (e = Yr(e, "button"));
		const i = hre(e),
			o = Ct(n);
		if ("href" in e && e.href) {
			const u = o;
			let c;
			r[0] !== u || r[1] !== e || r[2] !== i
				? ((c = m.jsx(cre, { ref: u, ...e, children: i })),
					(r[0] = u),
					(r[1] = e),
					(r[2] = i),
					(r[3] = c))
				: (c = r[3]);
			let d;
			return (
				r[4] !== e.autoFocus || r[5] !== c
					? ((d = m.jsx(xn, { autoFocus: e.autoFocus, children: c })),
						(r[4] = e.autoFocus),
						(r[5] = c),
						(r[6] = d))
					: (d = r[6]),
				d
			);
		}
		const s = o;
		let a;
		r[7] !== s || r[8] !== e || r[9] !== i
			? ((a = m.jsx(dre, { ref: s, ...e, children: i })),
				(r[7] = s),
				(r[8] = e),
				(r[9] = i),
				(r[10] = a))
			: (a = r[10]);
		let l;
		return (
			r[11] !== e.autoFocus || r[12] !== a
				? ((l = m.jsx(xn, { autoFocus: e.autoFocus, children: a })),
					(r[11] = e.autoFocus),
					(r[12] = a),
					(r[13] = l))
				: (l = r[13]),
			l
		);
	}),
	cre = E.forwardRef(function (e, n) {
		const r = ce(23);
		let i, o, s;
		r[0] !== e
			? (({ children: s, isDisabled: i, ...o } = e),
				(r[0] = e),
				(r[1] = i),
				(r[2] = o),
				(r[3] = s))
			: ((i = r[1]), (o = r[2]), (s = r[3]));
		const a = Ct(n);
		let l;
		r[4] !== e
			? ((l = { elementType: "a", ...e }), (r[4] = e), (r[5] = l))
			: (l = r[5]);
		const { buttonProps: u, isPressed: c } = Yo(l, a),
			{ linkProps: d } = Wh(e, a);
		let f;
		r[6] !== i
			? ((f = { isDisabled: i }), (r[6] = i), (r[7] = f))
			: (f = r[7]);
		const { hoverProps: h, isHovered: p } = gn(f);
		let g;
		r[8] !== p || r[9] !== c
			? ((g = { isHovered: p, isPressed: c }),
				(r[8] = p),
				(r[9] = c),
				(r[10] = g))
			: (g = r[10]);
		const v = KP(e, g);
		let b;
		r[11] !== o ? ((b = Ge(o)), (r[11] = o), (r[12] = b)) : (b = r[12]);
		let y;
		r[13] !== u || r[14] !== d || r[15] !== h || r[16] !== v
			? ((y = xe(u, d, h, v)),
				(r[13] = u),
				(r[14] = d),
				(r[15] = h),
				(r[16] = v),
				(r[17] = y))
			: (y = r[17]);
		let x;
		return (
			r[18] !== b || r[19] !== y || r[20] !== a || r[21] !== s
				? ((x = m.jsx("a", { ...b, ...y, ref: a, children: s })),
					(r[18] = b),
					(r[19] = y),
					(r[20] = a),
					(r[21] = s),
					(r[22] = x))
				: (x = r[22]),
			x
		);
	}),
	dre = E.forwardRef(function (e, n) {
		const r = ce(39);
		let i;
		r[0] !== e ? ((i = fre(e)), (r[0] = e), (r[1] = i)) : (i = r[1]),
			(e = i);
		let o, s, a, l;
		r[2] !== e
			? (({ children: l, isDisabled: o, isPending: s, ...a } = e),
				(r[2] = e),
				(r[3] = o),
				(r[4] = s),
				(r[5] = a),
				(r[6] = l))
			: ((o = r[3]), (s = r[4]), (a = r[5]), (l = r[6]));
		const [u, c] = E.useState(!1),
			d = Le(ure),
			f = Ct(n),
			{ buttonProps: h, isPressed: p } = Yo(e, f);
		let g;
		r[7] !== o
			? ((g = { isDisabled: o }), (r[7] = o), (r[8] = g))
			: (g = r[8]);
		const { hoverProps: v, isHovered: b } = gn(g);
		let y;
		r[9] !== b || r[10] !== u || r[11] !== p
			? ((y = { isHovered: b, isPending: u, isPressed: p }),
				(r[9] = b),
				(r[10] = u),
				(r[11] = p),
				(r[12] = y))
			: (y = r[12]);
		const x = KP(e, y);
		let C, k;
		r[13] !== s
			? ((C = () => {
					let F;
					return (
						s
							? (F = setTimeout(() => {
									c(!0);
								}, 1e3))
							: c(!1),
						() => {
							clearTimeout(F);
						}
					);
				}),
				(k = [s]),
				(r[13] = s),
				(r[14] = C),
				(r[15] = k))
			: ((C = r[14]), (k = r[15])),
			E.useEffect(C, k);
		let w, D, S, $;
		if (
			r[16] !== s ||
			r[17] !== f ||
			r[18] !== x ||
			r[19] !== a ||
			r[20] !== h ||
			r[21] !== v
		) {
			const F = s
				? { onClick: (N) => N.preventDefault() }
				: { onClick: () => {} };
			(w = f),
				(D = x),
				r[26] !== a
					? ((S = Ge(a, { propNames: new Set(["form"]) })),
						(r[26] = a),
						(r[27] = S))
					: (S = r[27]),
				($ = xe(h, v, F)),
				(r[16] = s),
				(r[17] = f),
				(r[18] = x),
				(r[19] = a),
				(r[20] = h),
				(r[21] = v),
				(r[22] = w),
				(r[23] = D),
				(r[24] = S),
				(r[25] = $);
		} else (w = r[22]), (D = r[23]), (S = r[24]), ($ = r[25]);
		const A = s ? "true" : void 0;
		let T;
		r[28] !== u || r[29] !== d
			? ((T =
					u &&
					m.jsx(Cr, {
						"aria-atomic": "false",
						"aria-live": "assertive",
						"aria-label": d.format("pending"),
						isIndeterminate: !0,
						size: "small",
						UNSAFE_style: { position: "absolute" },
					})),
				(r[28] = u),
				(r[29] = d),
				(r[30] = T))
			: (T = r[30]);
		let I;
		return (
			r[31] !== w ||
			r[32] !== D ||
			r[33] !== S ||
			r[34] !== $ ||
			r[35] !== A ||
			r[36] !== l ||
			r[37] !== T
				? ((I = m.jsxs("button", {
						ref: w,
						...D,
						...S,
						...$,
						"aria-disabled": A,
						children: [l, T],
					})),
					(r[31] = w),
					(r[32] = D),
					(r[33] = S),
					(r[34] = $),
					(r[35] = A),
					(r[36] = l),
					(r[37] = T),
					(r[38] = I))
				: (I = r[38]),
			I
		);
	});
function fre(t) {
	return (
		t.isPending &&
			((t = { ...t }),
			(t.onKeyDown = void 0),
			(t.onKeyUp = void 0),
			(t.onPress = void 0),
			(t.onPressChange = void 0),
			(t.onPressEnd = void 0),
			(t.onPressStart = void 0),
			(t.onPressUp = void 0)),
		t
	);
}
const hre = (t) => {
		const e = ce(4),
			{ children: n } = t;
		let r, i;
		e[0] === Symbol.for("react.memo_cache_sentinel")
			? ((i = { UNSAFE_className: Cc.element("icon") }), (e[0] = i))
			: (i = e[0]);
		let o;
		e[1] === Symbol.for("react.memo_cache_sentinel")
			? ((o = {
					icon: i,
					text: {
						color: "inherit",
						overflow: "unset",
						trim: !1,
						UNSAFE_className: Cc.element("text"),
					},
				}),
				(e[1] = o))
			: (o = e[1]),
			(r = o);
		const s = r;
		let a;
		return (
			e[2] !== n
				? ((a = m.jsx(Cn, {
						slots: s,
						children: $n(n) ? m.jsx(ue, { children: n }) : n,
					})),
					(e[2] = n),
					(e[3] = a))
				: (a = e[3]),
			a
		);
	},
	qc = new Gr("ActionButton", ["icon", "text"]);
function Cx(t, e) {
	const { prominence: n = "default" } = t,
		{ isHovered: r, isPressed: i } = e,
		o = ("isSelected" in t && t.isSelected) || e.isSelected,
		s = ht(t);
	return {
		...lt({
			interaction: i ? "press" : r ? "hover" : void 0,
			prominence: n === "default" ? void 0 : n,
			selected: o || void 0,
			static: t.static,
		}),
		style: s.style,
		className: Se(
			qc.element("root"),
			X({
				alignItems: "center",
				borderColor: "transparent",
				borderRadius: B.size.radius.regular,
				borderStyle: "solid",
				borderWidth: B.size.border.regular,
				cursor: "default",
				display: "inline-flex",
				flexShrink: 0,
				fontWeight: B.typography.fontWeight.regular,
				height: B.size.element.regular,
				justifyContent: "center",
				minWidth: B.size.element.regular,
				outline: 0,
				paddingInline: B.size.space.regular,
				position: "relative",
				transitionDuration: "130ms",
				transitionProperty:
					"background, border-color, box-shadow, color",
				transitionTimingFunction: "ease-out",
				userSelect: "none",
				"a&": { cursor: "pointer" },
				[qc.selector("text", "descendant")]: {
					fontWeight: "inherit",
					marginInline: B.size.space.small,
					overflow: "hidden",
					textOverflow: "ellipsis",
					whiteSpace: "nowrap",
				},
				"--focus-ring-color": B.color.alias.focusRing,
				"&[data-static]": { "--focus-ring-color": "currentColor" },
				"&::after": {
					borderRadius: "inherit",
					content: '""',
					inset: 0,
					margin: 0,
					pointerEvents: "none",
					position: "absolute",
					transition: bt(["box-shadow", "margin"], {
						easing: "easeOut",
					}),
				},
				"&[data-focus=visible]::after": {
					boxShadow: `0 0 0 ${B.size.alias.focusRing} var(--focus-ring-color)`,
				},
				"&:not([data-prominence])": {
					backgroundColor: B.color.alias.backgroundIdle,
					borderColor: B.color.alias.borderIdle,
					color: B.color.alias.foregroundIdle,
					"&[data-interaction=hover]": {
						backgroundColor: B.color.alias.backgroundHovered,
						borderColor: B.color.alias.borderHovered,
						color: B.color.alias.foregroundHovered,
					},
					"&[data-interaction=press]": {
						backgroundColor: B.color.alias.backgroundPressed,
						borderColor: B.color.alias.borderPressed,
						color: B.color.alias.foregroundPressed,
					},
					"&[data-selected]": {
						backgroundColor: B.color.foreground.neutralSecondary,
						borderColor: B.color.foreground.neutralSecondary,
						color: B.color.foreground.inverse,
						"&[data-interaction=hover]": {
							backgroundColor: B.color.foreground.neutral,
							borderColor: B.color.foreground.neutral,
						},
						"&[data-interaction=press]": {
							backgroundColor: B.color.foreground.neutralEmphasis,
							borderColor: B.color.foreground.neutralEmphasis,
						},
					},
					"&:disabled, &[aria-disabled=true], &[data-disabled=true]":
						{
							backgroundColor: B.color.alias.backgroundDisabled,
							borderColor: "transparent",
							color: B.color.alias.foregroundDisabled,
						},
					"&[data-static]": { backgroundColor: "transparent" },
					"&[data-static=light]": {
						borderColor: "#fff6",
						color: "#fff",
						'&[data-interaction=hover], &[data-focus="visible"]': {
							backgroundColor: "#ffffff1a",
							borderColor: "#ffffff8c",
						},
						"&[data-interaction=press]": {
							backgroundColor: "#ffffff26",
							borderColor: "#ffffffb3",
						},
						"&:disabled, &[aria-disabled]": {
							borderColor: "#ffffff40",
							color: "#ffffff8c",
						},
					},
					"&[data-static=dark]": {
						borderColor: "#0006",
						color: "#000",
						'&[data-interaction=hover], &[data-focus="visible"]': {
							backgroundColor: "#0000001a",
							borderColor: "#0000008c",
						},
						"&[data-interaction=press]": {
							backgroundColor: "#00000026",
							borderColor: "#000000b3",
						},
						"&:disabled, &[aria-disabled]": {
							borderColor: "#00000040",
							color: "#0000008c",
						},
					},
				},
				"&[data-prominence=low]": {
					color: B.color.foreground.neutral,
					"&[data-interaction=hover]": {
						backgroundColor: B.color.alias.backgroundHovered,
						color: B.color.alias.foregroundHovered,
					},
					"&[data-interaction=press]": {
						backgroundColor: B.color.alias.backgroundPressed,
						color: B.color.alias.foregroundPressed,
					},
					"&[data-selected]": {
						backgroundColor: B.color.foreground.neutralSecondary,
						borderColor: B.color.foreground.neutralSecondary,
						color: B.color.foreground.inverse,
						"&[data-interaction=hover]": {
							backgroundColor: B.color.foreground.neutral,
							borderColor: B.color.foreground.neutral,
						},
						"&[data-interaction=press]": {
							backgroundColor: B.color.foreground.neutralEmphasis,
							borderColor: B.color.foreground.neutralEmphasis,
						},
					},
					"&:disabled, &[aria-disabled=true], &[data-disabled=true]":
						{
							borderColor: "transparent",
							color: B.color.alias.foregroundDisabled,
						},
					"&[data-static=light]": {
						color: "#fff",
						'&[data-interaction=hover], &[data-focus="visible"]': {
							backgroundColor: "#ffffff1a",
						},
						"&[data-interaction=press]": {
							backgroundColor: "#ffffff26",
						},
						"&:disabled, &[aria-disabled]": { color: "#ffffff8c" },
					},
					"&[data-static=dark]": {
						color: "#000",
						'&[data-interaction=hover], &[data-focus="visible"]': {
							backgroundColor: "#0000001a",
						},
						"&[data-interaction=press]": {
							backgroundColor: "#00000026",
						},
						"&:disabled, &[aria-disabled]": { color: "#0000008c" },
					},
				},
			}),
			s.className,
		),
	};
}
const Re = E.forwardRef(function (e, n) {
		const r = ce(14),
			i = Ct(n),
			o = fD(e);
		if ("href" in e && e.href) {
			const u = i;
			let c;
			r[0] !== u || r[1] !== e || r[2] !== o
				? ((c = m.jsx(pre, { ref: u, ...e, children: o })),
					(r[0] = u),
					(r[1] = e),
					(r[2] = o),
					(r[3] = c))
				: (c = r[3]);
			let d;
			return (
				r[4] !== e.autoFocus || r[5] !== c
					? ((d = m.jsx(xn, { autoFocus: e.autoFocus, children: c })),
						(r[4] = e.autoFocus),
						(r[5] = c),
						(r[6] = d))
					: (d = r[6]),
				d
			);
		}
		const s = i;
		let a;
		r[7] !== s || r[8] !== e || r[9] !== o
			? ((a = m.jsx(mre, { ref: s, ...e, children: o })),
				(r[7] = s),
				(r[8] = e),
				(r[9] = o),
				(r[10] = a))
			: (a = r[10]);
		let l;
		return (
			r[11] !== e.autoFocus || r[12] !== a
				? ((l = m.jsx(xn, { autoFocus: e.autoFocus, children: a })),
					(r[11] = e.autoFocus),
					(r[12] = a),
					(r[13] = l))
				: (l = r[13]),
			l
		);
	}),
	pre = E.forwardRef(function (e, n) {
		const r = ce(23);
		let i, o, s;
		r[0] !== e
			? (({ children: s, isDisabled: i, ...o } = e),
				(r[0] = e),
				(r[1] = i),
				(r[2] = o),
				(r[3] = s))
			: ((i = r[1]), (o = r[2]), (s = r[3]));
		const a = Ct(n);
		let l;
		r[4] !== e
			? ((l = { elementType: "a", ...e }), (r[4] = e), (r[5] = l))
			: (l = r[5]);
		const { buttonProps: u, isPressed: c } = Yo(l, a),
			{ linkProps: d } = Wh(e, a);
		let f;
		r[6] !== i
			? ((f = { isDisabled: i }), (r[6] = i), (r[7] = f))
			: (f = r[7]);
		const { hoverProps: h, isHovered: p } = gn(f);
		let g;
		r[8] !== p || r[9] !== c
			? ((g = { isHovered: p, isPressed: c }),
				(r[8] = p),
				(r[9] = c),
				(r[10] = g))
			: (g = r[10]);
		const v = Cx(e, g);
		let b;
		r[11] !== o ? ((b = Ge(o)), (r[11] = o), (r[12] = b)) : (b = r[12]);
		let y;
		r[13] !== u || r[14] !== d || r[15] !== h || r[16] !== v
			? ((y = xe(u, d, h, v)),
				(r[13] = u),
				(r[14] = d),
				(r[15] = h),
				(r[16] = v),
				(r[17] = y))
			: (y = r[17]);
		let x;
		return (
			r[18] !== b || r[19] !== y || r[20] !== a || r[21] !== s
				? ((x = m.jsx("a", { ...b, ...y, ref: a, children: s })),
					(r[18] = b),
					(r[19] = y),
					(r[20] = a),
					(r[21] = s),
					(r[22] = x))
				: (x = r[22]),
			x
		);
	}),
	mre = E.forwardRef(function (e, n) {
		const r = ce(20);
		(e = vo(e)), (e = Yr(e, "button"));
		let i, o, s;
		r[0] !== e
			? (({ children: s, isDisabled: i, ...o } = e),
				(r[0] = e),
				(r[1] = i),
				(r[2] = o),
				(r[3] = s))
			: ((i = r[1]), (o = r[2]), (s = r[3]));
		const a = Ct(n),
			{ buttonProps: l, isPressed: u } = Yo(e, a);
		let c;
		r[4] !== i
			? ((c = { isDisabled: i }), (r[4] = i), (r[5] = c))
			: (c = r[5]);
		const { hoverProps: d, isHovered: f } = gn(c);
		let h;
		r[6] !== f || r[7] !== u
			? ((h = { isHovered: f, isPressed: u }),
				(r[6] = f),
				(r[7] = u),
				(r[8] = h))
			: (h = r[8]);
		const p = Cx(e, h);
		let g;
		r[9] !== o
			? ((g = Ge(o, { propNames: new Set(["form"]) })),
				(r[9] = o),
				(r[10] = g))
			: (g = r[10]);
		let v;
		r[11] !== l || r[12] !== d
			? ((v = xe(l, d)), (r[11] = l), (r[12] = d), (r[13] = v))
			: (v = r[13]);
		let b;
		return (
			r[14] !== a ||
			r[15] !== p ||
			r[16] !== g ||
			r[17] !== v ||
			r[18] !== s
				? ((b = m.jsx("button", {
						ref: a,
						...p,
						...g,
						...v,
						children: s,
					})),
					(r[14] = a),
					(r[15] = p),
					(r[16] = g),
					(r[17] = v),
					(r[18] = s),
					(r[19] = b))
				: (b = r[19]),
			b
		);
	});
let gre = qc.element("icon"),
	bre = qc.element("text");
const fD = (t, e) => {
		const n = ce(13),
			{ children: r } = t;
		let i;
		const o = e == null ? void 0 : e.icon;
		let s;
		n[0] !== o
			? ((s = { UNSAFE_className: gre, ...o }), (n[0] = o), (n[1] = s))
			: (s = n[1]);
		const a = e == null ? void 0 : e.text;
		let l;
		n[2] !== a
			? ((l = {
					color: "inherit",
					overflow: "unset",
					trim: !1,
					UNSAFE_className: bre,
					...a,
				}),
				(n[2] = a),
				(n[3] = l))
			: (l = n[3]);
		let u;
		n[4] !== e || n[5] !== s || n[6] !== l
			? ((u = { ...e, icon: s, text: l }),
				(n[4] = e),
				(n[5] = s),
				(n[6] = l),
				(n[7] = u))
			: (u = n[7]),
			(i = u);
		const c = i;
		let d;
		n[8] !== r
			? ((d = $n(r) ? m.jsx(ue, { children: r }) : r),
				(n[8] = r),
				(n[9] = d))
			: (d = n[9]);
		let f;
		return (
			n[10] !== c || n[11] !== d
				? ((f = m.jsx(Cn, { slots: c, children: d })),
					(n[10] = c),
					(n[11] = d),
					(n[12] = f))
				: (f = n[12]),
			f
		);
	},
	wx = E.forwardRef(function (e, n) {
		const r = ce(28);
		let i, o, s, a, l;
		r[0] !== e
			? (({
					autoFocus: l,
					isDisabled: s,
					preventFocus: o,
					elementType: i,
					...a
				} = e),
				(r[0] = e),
				(r[1] = i),
				(r[2] = o),
				(r[3] = s),
				(r[4] = a),
				(r[5] = l))
			: ((i = r[1]), (o = r[2]), (s = r[3]), (a = r[4]), (l = r[5]));
		const u = i === void 0 ? (o ? "div" : "button") : i,
			c = Ct(n);
		let d;
		r[6] !== e || r[7] !== u
			? ((d = { ...e, elementType: u }),
				(r[6] = e),
				(r[7] = u),
				(r[8] = d))
			: (d = r[8]);
		let { buttonProps: f, isPressed: h } = Yo(d, c),
			p;
		r[9] !== s
			? ((p = { isDisabled: s }), (r[9] = s), (r[10] = p))
			: (p = r[10]);
		const { hoverProps: g, isHovered: v } = gn(p);
		let b;
		r[11] !== v || r[12] !== h
			? ((b = { isHovered: v, isPressed: h }),
				(r[11] = v),
				(r[12] = h),
				(r[13] = b))
			: (b = r[13]);
		const y = vre(a, b);
		if (o) {
			let S;
			if (r[14] !== f) {
				const { tabIndex: $, ...A } = f;
				(S = A), (r[14] = f), (r[15] = S);
			} else S = r[15];
			f = S;
		}
		const x = u;
		let C;
		r[16] !== f || r[17] !== g
			? ((C = xe(f, g)), (r[16] = f), (r[17] = g), (r[18] = C))
			: (C = r[18]);
		let k;
		r[19] === Symbol.for("react.memo_cache_sentinel")
			? ((k = m.jsx(ve, { src: cD })), (r[19] = k))
			: (k = r[19]);
		let w;
		r[20] !== x || r[21] !== y || r[22] !== C || r[23] !== c
			? ((w = m.jsx(x, { ...y, ...C, ref: c, children: k })),
				(r[20] = x),
				(r[21] = y),
				(r[22] = C),
				(r[23] = c),
				(r[24] = w))
			: (w = r[24]);
		let D;
		return (
			r[25] !== l || r[26] !== w
				? ((D = m.jsx(xn, { autoFocus: l, children: w })),
					(r[25] = l),
					(r[26] = w),
					(r[27] = D))
				: (D = r[27]),
			D
		);
	});
function vre(t, e) {
	const n = ce(14),
		{ isPressed: r, isHovered: i } = e,
		o = ht(t);
	let s, a, l;
	if (n[0] !== o || n[1] !== r || n[2] !== i || n[3] !== t.static) {
		const c = X({
			alignItems: "center",
			borderRadius: "100%",
			color: B.color.foreground.neutralSecondary,
			display: "flex",
			height: B.size.element.regular,
			justifyContent: "center",
			outline: 0,
			position: "relative",
			transition: bt(["box-shadow", "margin"], { easing: "easeOut" }),
			width: B.size.element.regular,
			"--focus-ring-color": B.color.alias.focusRing,
			"&[data-static]": { "--focus-ring-color": "currentColor" },
			"&::after": {
				borderRadius: "inherit",
				content: '""',
				inset: 0,
				pointerEvents: "none",
				position: "absolute",
				transition: bt(["box-shadow", "margin"], { easing: "easeOut" }),
			},
			"&[data-focus=visible]::after": {
				boxShadow: `0 0 0 ${B.size.alias.focusRing} var(--focus-ring-color)`,
				margin: `calc(-1 * ${B.size.alias.focusRingGap})`,
			},
			"&[data-interaction=hover]": { color: B.color.foreground.neutral },
			"&[data-interaction=press]": {
				color: B.color.foreground.neutralEmphasis,
			},
			"&:disabled, &[aria-disabled]": {
				color: B.color.alias.foregroundDisabled,
			},
			"&[data-static=light]": {
				color: "#fff",
				'&[data-interaction=hover], &[data-focus="visible"]': {
					backgroundColor: "#ffffff1a",
				},
				"&[data-interaction=press]": { backgroundColor: "#ffffff26" },
				"&:disabled, &[aria-disabled]": {
					backgroundColor: "#ffffff1a",
					color: "#ffffff8c",
				},
			},
			"&[data-static=dark]": {
				color: "#000",
				'&[data-interaction=hover], &[data-focus="visible"]': {
					backgroundColor: "#0000001a",
				},
				"&[data-interaction=press]": { backgroundColor: "#00000026" },
				"&:disabled, &[aria-disabled]": {
					backgroundColor: "#0000001a",
					color: "#0000008c",
				},
			},
		});
		s = o;
		const d = r ? "press" : i ? "hover" : void 0;
		n[7] !== t.static || n[8] !== d
			? ((a = lt({ static: t.static, interaction: d })),
				(n[7] = t.static),
				(n[8] = d),
				(n[9] = a))
			: (a = n[9]),
			(l = Se(c, o.className)),
			(n[0] = o),
			(n[1] = r),
			(n[2] = i),
			(n[3] = t.static),
			(n[4] = s),
			(n[5] = a),
			(n[6] = l);
	} else (s = n[4]), (a = n[5]), (l = n[6]);
	let u;
	return (
		n[10] !== s || n[11] !== a || n[12] !== l
			? ((u = { ...s, ...a, className: l }),
				(n[10] = s),
				(n[11] = a),
				(n[12] = l),
				(n[13] = u))
			: (u = n[13]),
		u
	);
}
const UP = E.forwardRef(function (e, n) {
	const r = ce(23);
	e = Yr(e, "button");
	const { elementType: i, isDisabled: o, autoFocus: s, isActive: a } = e,
		l = i === void 0 ? "button" : i,
		u = Ct(n),
		{ buttonProps: c, isPressed: d } = Yo(e, u);
	let f;
	r[0] !== o ? ((f = { isDisabled: o }), (r[0] = o), (r[1] = f)) : (f = r[1]);
	const { hoverProps: h, isHovered: p } = gn(f),
		g = a ?? d;
	let v;
	r[2] !== p || r[3] !== g
		? ((v = { isHovered: p, isPressed: g }),
			(r[2] = p),
			(r[3] = g),
			(r[4] = v))
		: (v = r[4]);
	const { children: b, styleProps: y } = HP(e, v);
	let x;
	r[5] !== c || r[6] !== h
		? ((x = xe(c, h)), (r[5] = c), (r[6] = h), (r[7] = x))
		: (x = r[7]);
	let C;
	r[8] !== y.className
		? ((C = Se(
				X({ justifyContent: "space-between", textAlign: "start" }),
				y.className,
			)),
			(r[8] = y.className),
			(r[9] = C))
		: (C = r[9]);
	let k;
	r[10] !== y.style
		? ((k = { ...y.style, boxShadow: "none" }),
			(r[10] = y.style),
			(r[11] = k))
		: (k = r[11]);
	let w;
	r[12] !== l ||
	r[13] !== y ||
	r[14] !== x ||
	r[15] !== u ||
	r[16] !== C ||
	r[17] !== k ||
	r[18] !== b
		? ((w = m.jsx(l, {
				...y,
				...x,
				ref: u,
				className: C,
				style: k,
				children: b,
			})),
			(r[12] = l),
			(r[13] = y),
			(r[14] = x),
			(r[15] = u),
			(r[16] = C),
			(r[17] = k),
			(r[18] = b),
			(r[19] = w))
		: (w = r[19]);
	let D;
	return (
		r[20] !== s || r[21] !== w
			? ((D = m.jsx(xn, { autoFocus: s, children: w })),
				(r[20] = s),
				(r[21] = w),
				(r[22] = D))
			: (D = r[22]),
		D
	);
});
function HP(t, e) {
	const n = ce(7),
		{ isHovered: r, isPressed: i } = e;
	let o;
	n[0] !== r || n[1] !== i
		? ((o = { isHovered: r, isPressed: i }),
			(n[0] = r),
			(n[1] = i),
			(n[2] = o))
		: (o = n[2]);
	const s = Cx(t, o);
	let a, l;
	n[3] === Symbol.for("react.memo_cache_sentinel")
		? ((l = { text: { flex: !0 } }), (n[3] = l))
		: (l = n[3]),
		(a = l);
	const c = fD(t, a);
	let d;
	return (
		n[4] !== c || n[5] !== s
			? ((d = { children: c, styleProps: s }),
				(n[4] = c),
				(n[5] = s),
				(n[6] = d))
			: (d = n[6]),
		d
	);
}
const WP = E.forwardRef(function (e, n) {
		const r = ce(23);
		let i, o;
		r[0] !== e
			? (({ isDisabled: i, ...o } = e),
				(r[0] = e),
				(r[1] = i),
				(r[2] = o))
			: ((i = r[1]), (o = r[2])),
			(e = vo(e)),
			(e = Yr(e, "button"));
		const s = fD(e),
			a = Ct(n),
			l = dD(e),
			{ buttonProps: u, isPressed: c } = jne(e, l, a);
		let d;
		r[3] !== i
			? ((d = { isDisabled: i }), (r[3] = i), (r[4] = d))
			: (d = r[4]);
		const { hoverProps: f, isHovered: h } = gn(d);
		let p;
		r[5] !== h || r[6] !== c || r[7] !== l.isSelected
			? ((p = { isHovered: h, isPressed: c, isSelected: l.isSelected }),
				(r[5] = h),
				(r[6] = c),
				(r[7] = l.isSelected),
				(r[8] = p))
			: (p = r[8]);
		const g = Cx(e, p);
		let v;
		r[9] !== u || r[10] !== f
			? ((v = xe(u, f)), (r[9] = u), (r[10] = f), (r[11] = v))
			: (v = r[11]);
		let b;
		r[12] !== o ? ((b = Ge(o)), (r[12] = o), (r[13] = b)) : (b = r[13]);
		let y;
		r[14] !== a || r[15] !== g || r[16] !== v || r[17] !== b || r[18] !== s
			? ((y = m.jsx("button", { ref: a, ...g, ...v, ...b, children: s })),
				(r[14] = a),
				(r[15] = g),
				(r[16] = v),
				(r[17] = b),
				(r[18] = s),
				(r[19] = y))
			: (y = r[19]);
		let x;
		return (
			r[20] !== e.autoFocus || r[21] !== y
				? ((x = m.jsx(xn, { autoFocus: e.autoFocus, children: y })),
					(r[20] = e.autoFocus),
					(r[21] = y),
					(r[22] = x))
				: (x = r[22]),
			x
		);
	}),
	yre = m.jsxs(m.Fragment, {
		children: [
			m.jsx("path", {
				d: "M4 22h14a2 2 0 0 0 2-2V7l-5-5H6a2 2 0 0 0-2 2v4",
			}),
			m.jsx("path", {
				d: "M14 2v4a2 2 0 0 0 2 2h4M8 12.5l-5 5M3 12.5l5 5",
			}),
		],
	}),
	Ex = m.jsxs(m.Fragment, {
		children: [
			m.jsx("path", {
				d: "M15 22v-4a4.8 4.8 0 0 0-1-3.5c3 0 6-2 6-5.5.08-1.25-.27-2.48-1-3.5.28-1.15.28-2.35 0-3.5 0 0-1 0-3 1.5-2.64-.5-5.36-.5-8 0C6 2 5 2 5 2c-.3 1.15-.3 2.35 0 3.5A5.403 5.403 0 0 0 4 9c0 3.5 3 5.5 6 5.5-.39.49-.68 1.05-.85 1.65-.17.6-.22 1.23-.15 1.85v4",
			}),
			m.jsx("path", { d: "M9 18c-4.51 2-5-2-7-2" }),
		],
	});
function qP(t) {
	let e = Ge(t, { labelable: !0 }),
		n;
	return (
		t.orientation === "vertical" && (n = "vertical"),
		t.elementType !== "hr"
			? {
					separatorProps: {
						...e,
						role: "separator",
						"aria-orientation": n,
					},
				}
			: { separatorProps: e }
	);
}
const pr = yi((t, e) => {
		const { elementType: n = "div", children: r, ...i } = t,
			o = ht(i);
		return m.jsx(n, { ref: e, ...qd(i), ...o, children: r });
	}),
	xre = new Gr("Divider"),
	kre = { propNames: new Set(["role"]) },
	ra = yi((t, e) => {
		t = Yr(t, "divider");
		const {
				orientation: n = "horizontal",
				elementType: r = n === "vertical" ? "div" : "hr",
				size: i = "regular",
				...o
			} = t,
			s = ht(o);
		let { separatorProps: a } = qP({ ...t, elementType: r });
		return m.jsx(r, {
			...s,
			...a,
			...lt({ orientation: n, size: i }),
			...Ge(o, kre),
			ref: e,
			className: Se(
				xre.element("root"),
				X({
					alignSelf: "stretch",
					backgroundColor: B.color.border.neutral,
					borderRadius: "var(--size)",
					"&[data-size=regular]": { "--size": B.size.border.regular },
					"&[data-size=medium]": { "--size": B.size.border.medium },
					"&[data-size=large]": { "--size": B.size.border.large },
					"&[data-orientation=horizontal]": { height: "var(--size)" },
					"&[data-orientation=vertical]": { width: "var(--size)" },
				}),
				s.className,
			),
		});
	}),
	GP = {
		gap: Mr("gap", "size.space"),
		columnGap: Mr("columnGap", "size.space"),
		rowGap: Mr("rowGap", "size.space"),
		alignContent: pt("alignContent", F4),
		alignItems: pt("alignItems", F4),
		direction: pt("flexDirection"),
		justifyContent: pt("justifyContent", F4),
	};
function YP(t) {
	return (n) => (n ? `inline-${t}` : t);
}
function hD(t) {
	const e = ce(2);
	let n;
	return (
		e[0] !== t
			? ((n = { inline: !1, ...t }), (e[0] = t), (e[1] = n))
			: (n = e[1]),
		ht(n, Dx)
	);
}
const Dx = {
	...GP,
	direction: pt("flexDirection"),
	inline: pt("display", YP("flex")),
	wrap: pt("flexWrap", Cre),
};
function F4(t) {
	return t === "start" ? "flex-start" : t === "end" ? "flex-end" : t;
}
function Cre(t) {
	return typeof t == "boolean" ? (t ? "wrap" : "nowrap") : t;
}
function wre(t) {
	return t.endsWith("fr");
}
function cw(t) {
	return typeof t == "number" || wre(t) ? t : pv(t);
}
function JP(t) {
	const e = ce(2);
	let n;
	return (
		e[0] !== t
			? ((n = { inline: !1, ...t }), (e[0] = t), (e[1] = n))
			: (n = e[1]),
		ht(n, XP)
	);
}
const XP = {
	...GP,
	inline: pt("display", YP("grid")),
	autoFlow: pt("gridAutoFlow"),
	autoColumns: pt("gridAutoColumns", pv),
	autoRows: pt("gridAutoRows", pv),
	areas: pt("gridTemplateAreas", Ere),
	columns: pt("gridTemplateColumns", j6),
	rows: pt("gridTemplateRows", j6),
	justifyItems: pt("justifyItems"),
	justifyContent: pt("justifyContent"),
	alignItems: pt("alignItems"),
	alignContent: pt("alignContent"),
};
function Ere(t) {
	return t.map((e) => `"${e}"`).join(`
`);
}
function j6(t) {
	return Array.isArray(t) ? t.map(cw).join(" ") : t;
}
function Dre(t, e) {
	return `minmax(${cw(t)}, ${cw(e)})`;
}
const ke = yi((t, e) => {
		const { elementType: n = "div", children: r, ...i } = t,
			o = hD(i);
		return m.jsx(n, {
			ref: e,
			...qd(i, Object.keys(Dx)),
			...o,
			children: r,
		});
	}),
	gd = yi((t, e) => {
		const { elementType: n = "div", children: r, ...i } = t,
			o = JP(i);
		return m.jsx(n, {
			ref: e,
			...qd(i, Object.keys(XP)),
			...o,
			children: r,
		});
	}),
	Sre = E.forwardRef(function (e, n) {
		let { children: r, direction: i = "vertical", ...o } = e,
			s = Ct(n),
			[a, l] = E.useState("none"),
			u = JP(o),
			c = E.useCallback(() => {
				let d = s.current;
				if (!d) return;
				let {
						clientDimension: f,
						scrollDimension: h,
						scrollStart: p,
					} = Are(i, d),
					g = "none";
				h > f &&
					(p === 0
						? (g = "end")
						: Math.ceil(p + f) >= h
							? (g = "start")
							: p > 0 && (g = "both")),
					l(g);
			}, [i, s]);
		return (
			at(() => {
				c();
			}, [c]),
			fa({ ref: s, onResize: c }),
			m.jsx("div", {
				...u,
				...Ge(e),
				onScroll: c,
				ref: s,
				"data-scroll-indicator": a,
				"data-scroll-direction": i,
				className: Se(
					X({
						height: "100%",
						width: "100%",
						minHeight: 0,
						minWidth: 0,
						transition: bt("border-color", { duration: "regular" }),
						WebkitOverflowScrolling: "touch",
						"&[data-scroll-direction=vertical]": {
							borderBlock: `${B.size.border.regular} solid transparent`,
							overflowX: "hidden",
							overflowY: "auto",
							"&[data-scroll-indicator=both]": {
								borderBlockColor: B.color.border.neutral,
							},
							"&[data-scroll-indicator=start]": {
								borderBlockStartColor: B.color.border.neutral,
							},
							"&[data-scroll-indicator=end]": {
								borderBlockEndColor: B.color.border.neutral,
							},
						},
						"&[data-scroll-direction=horizontal]": {
							borderInline: `${B.size.border.regular} solid transparent`,
							gridAutoFlow: "column",
							overflowX: "auto",
							overflowY: "hidden",
							"&[data-scroll-indicator=both]": {
								borderInlineColor: B.color.border.neutral,
							},
							"&[data-scroll-indicator=start]": {
								borderInlineStartColor: B.color.border.neutral,
							},
							"&[data-scroll-indicator=end]": {
								borderInlineEndColor: B.color.border.neutral,
							},
						},
					}),
					u.className,
				),
				children: r,
			})
		);
	});
function Are(t, e) {
	let n = t === "horizontal" ? e.scrollLeft : e.scrollTop,
		r = t === "horizontal" ? e.scrollWidth : e.scrollHeight;
	return {
		clientDimension: t === "horizontal" ? e.clientWidth : e.clientHeight,
		scrollDimension: r,
		scrollStart: n,
	};
}
const Hr = yi((t, e) => {
		const { elementType: n = "div", children: r, ...i } = t,
			o = hD({ direction: "column", ...i });
		return m.jsx(n, {
			ref: e,
			...qd(i, Object.keys(Dx)),
			...o,
			children: r,
		});
	}),
	As = yi((t, e) => {
		const { elementType: n = "div", children: r, ...i } = t,
			o = hD({ direction: "row", ...i });
		return m.jsx(n, {
			ref: e,
			...qd(i, Object.keys(Dx)),
			...o,
			children: r,
		});
	});
var Tl = {};
Object.defineProperty(Tl, "__esModule", { value: !0 });
var $re =
		typeof window < "u" &&
		/Mac|iPod|iPhone|iPad/.test(window.navigator.platform),
	P4 = {
		alt: "altKey",
		control: "ctrlKey",
		meta: "metaKey",
		shift: "shiftKey",
	},
	ZP = {
		add: "+",
		break: "pause",
		cmd: "meta",
		command: "meta",
		ctl: "control",
		ctrl: "control",
		del: "delete",
		down: "arrowdown",
		esc: "escape",
		ins: "insert",
		left: "arrowleft",
		mod: $re ? "meta" : "control",
		opt: "alt",
		option: "alt",
		return: "enter",
		right: "arrowright",
		space: " ",
		spacebar: " ",
		up: "arrowup",
		win: "meta",
		windows: "meta",
	},
	pD = {
		backspace: 8,
		tab: 9,
		enter: 13,
		shift: 16,
		control: 17,
		alt: 18,
		pause: 19,
		capslock: 20,
		escape: 27,
		" ": 32,
		pageup: 33,
		pagedown: 34,
		end: 35,
		home: 36,
		arrowleft: 37,
		arrowup: 38,
		arrowright: 39,
		arrowdown: 40,
		insert: 45,
		delete: 46,
		meta: 91,
		numlock: 144,
		scrolllock: 145,
		";": 186,
		"=": 187,
		",": 188,
		"-": 189,
		".": 190,
		"/": 191,
		"`": 192,
		"[": 219,
		"\\": 220,
		"]": 221,
		"'": 222,
	};
for (var m1 = 1; m1 < 20; m1++) pD["f" + m1] = 111 + m1;
function Sx(t, e, n) {
	e && !("byKey" in e) && ((n = e), (e = null)),
		Array.isArray(t) || (t = [t]);
	var r = t.map(function (s) {
			return QP(s, e);
		}),
		i = function (a) {
			return r.some(function (l) {
				return eN(l, a);
			});
		},
		o = n == null ? i : i(n);
	return o;
}
function Tre(t, e) {
	return Sx(t, e);
}
function Bre(t, e) {
	return Sx(t, { byKey: !0 }, e);
}
function QP(t, e) {
	var n = e && e.byKey,
		r = {};
	t = t.replace("++", "+add");
	var i = t.split("+"),
		o = i.length;
	for (var s in P4) r[P4[s]] = !1;
	var a = !0,
		l = !1,
		u = void 0;
	try {
		for (
			var c = i[Symbol.iterator](), d;
			!(a = (d = c.next()).done);
			a = !0
		) {
			var f = d.value,
				h = f.endsWith("?") && f.length > 1;
			h && (f = f.slice(0, -1));
			var p = mD(f),
				g = P4[p];
			if (f.length > 1 && !g && !ZP[f] && !pD[p])
				throw new TypeError('Unknown modifier: "' + f + '"');
			(o === 1 || !g) && (n ? (r.key = p) : (r.which = tN(f))),
				g && (r[g] = h ? null : !0);
		}
	} catch (v) {
		(l = !0), (u = v);
	} finally {
		try {
			!a && c.return && c.return();
		} finally {
			if (l) throw u;
		}
	}
	return r;
}
function eN(t, e) {
	for (var n in t) {
		var r = t[n],
			i = void 0;
		if (
			r != null &&
			(n === "key" && e.key != null
				? (i = e.key.toLowerCase())
				: n === "which"
					? (i = r === 91 && e.which === 93 ? 91 : e.which)
					: (i = e[n]),
			!(i == null && r === !1) && i !== r)
		)
			return !1;
	}
	return !0;
}
function tN(t) {
	t = mD(t);
	var e = pD[t] || t.toUpperCase().charCodeAt(0);
	return e;
}
function mD(t) {
	return (t = t.toLowerCase()), (t = ZP[t] || t), t;
}
Tl.default = Sx;
var jf = (Tl.isHotkey = Sx);
Tl.isCodeHotkey = Tre;
Tl.isKeyHotkey = Bre;
Tl.parseHotkey = QP;
Tl.compareHotkey = eN;
Tl.toKeyCode = tN;
Tl.toKeyName = mD;
const gD = m.jsxs(m.Fragment, {
		children: [
			m.jsx("circle", { cx: 12, cy: 12, r: 10 }),
			m.jsx("path", { d: "M12 8v4M12 16h.01" }),
		],
	}),
	Ire = m.jsx("path", { d: "M11 12H3M16 6H3M16 18H3M19 10l-4 4M15 10l4 4" }),
	nN = m.jsxs(m.Fragment, {
		children: [
			m.jsx("circle", { cx: 11, cy: 11, r: 8 }),
			m.jsx("path", { d: "m21 21-4.3-4.3" }),
		],
	}),
	Fre = m.jsxs(m.Fragment, {
		children: [
			m.jsx("path", { d: "m13.5 8.5-5 5M8.5 8.5l5 5" }),
			m.jsx("circle", { cx: 11, cy: 11, r: 8 }),
			m.jsx("path", { d: "m21 21-4.3-4.3" }),
		],
	}),
	Pre = m.jsx("path", { d: "M12 3v14M5 10h14M5 21h14" }),
	Nre = m.jsxs(m.Fragment, {
		children: [
			m.jsx("rect", { width: 18, height: 18, x: 3, y: 3, rx: 2 }),
			m.jsx("path", { d: "M8 12h8M12 8v8" }),
		],
	}),
	Rre = m.jsxs(m.Fragment, {
		children: [
			m.jsx("rect", { width: 18, height: 18, x: 3, y: 3, rx: 2 }),
			m.jsx("circle", { cx: 12, cy: 12, r: 1 }),
		],
	});
function rN(t) {
	const e = ce(18),
		{ autoFocus: n, prominence: r } = t,
		i = r === void 0 ? "default" : r,
		o = OP(),
		s = aD();
	let a;
	e[0] !== n ? ((a = { autoFocus: n }), (e[0] = n), (e[1] = a)) : (a = e[1]);
	const { focusProps: l, isFocusVisible: u } = ha(a);
	let c;
	e[2] === Symbol.for("react.memo_cache_sentinel")
		? ((c = {}), (e[2] = c))
		: (c = e[2]);
	const { hoverProps: d, isHovered: f } = gn(c),
		h = f ? "true" : void 0,
		p = u ? "visible" : void 0;
	let g, v;
	if (e[3] !== i || e[4] !== h || e[5] !== p || e[6] !== d || e[7] !== l) {
		const C = { prominence: i, hover: h, focus: p };
		e[10] !== d || e[11] !== l
			? ((g = xe(d, l)), (e[10] = d), (e[11] = l), (e[12] = g))
			: (g = e[12]),
			(v = lt(C)),
			(e[3] = i),
			(e[4] = h),
			(e[5] = p),
			(e[6] = d),
			(e[7] = l),
			(e[8] = g),
			(e[9] = v);
	} else (g = e[8]), (v = e[9]);
	const b = !s && !o ? ue : E.Fragment;
	let y;
	e[13] === Symbol.for("react.memo_cache_sentinel")
		? ((y = Se(
				X({
					color: B.color.foreground.neutral,
					cursor: "pointer",
					outline: 0,
					textDecoration: "underline",
					textDecorationColor: B.color.border.emphasis,
					textDecorationThickness: B.size.border.regular,
					textUnderlineOffset: B.size.border.medium,
					'&[data-hover="true"], &[data-focus="visible"]': {
						color: B.color.foreground.neutralEmphasis,
						textDecorationColor: B.color.foreground.neutral,
					},
					'&[data-focus="visible"]': {
						textDecorationStyle: "double",
					},
					'&[data-prominence="high"]': {
						color: B.color.foreground.accent,
						textDecorationColor: B.color.border.accent,
						'&[data-hover="true"], &[data-focus="visible"]': {
							textDecorationColor: B.color.foreground.accent,
						},
					},
				}),
			)),
			(e[13] = y))
		: (y = e[13]);
	let x;
	return (
		e[14] !== g || e[15] !== v || e[16] !== b
			? ((x = { ...g, ...v, Wrapper: b, className: y }),
				(e[14] = g),
				(e[15] = v),
				(e[16] = b),
				(e[17] = x))
			: (x = e[17]),
		x
	);
}
const Ore = E.forwardRef(function (e, n) {
		const r = ce(13),
			{ children: i } = e,
			o = Ct(n),
			s = rN(e);
		let a, l;
		r[0] !== s
			? (({ Wrapper: l, ...a } = s), (r[0] = s), (r[1] = a), (r[2] = l))
			: ((a = r[1]), (l = r[2]));
		const { linkProps: u } = Wh(e, o);
		let c;
		r[3] !== u || r[4] !== a
			? ((c = xe(u, a)), (r[3] = u), (r[4] = a), (r[5] = c))
			: (c = r[5]);
		let d;
		r[6] !== o || r[7] !== c || r[8] !== i
			? ((d = m.jsx("a", { ref: o, ...c, children: i })),
				(r[6] = o),
				(r[7] = c),
				(r[8] = i),
				(r[9] = d))
			: (d = r[9]);
		let f;
		return (
			r[10] !== l || r[11] !== d
				? ((f = m.jsx(l, { children: d })),
					(r[10] = l),
					(r[11] = d),
					(r[12] = f))
				: (f = r[12]),
			f
		);
	}),
	Mre = E.forwardRef(function (e, n) {
		const r = ce(18);
		let i, o;
		r[0] !== e
			? (({ children: o, ...i } = e), (r[0] = e), (r[1] = i), (r[2] = o))
			: ((i = r[1]), (o = r[2]));
		const s = Ct(n),
			a = rN(i);
		let l, u;
		r[3] !== a
			? (({ Wrapper: u, ...l } = a), (r[3] = a), (r[4] = l), (r[5] = u))
			: ((l = r[4]), (u = r[5]));
		let c;
		r[6] !== i
			? ((c = { elementType: "span", ...i }), (r[6] = i), (r[7] = c))
			: (c = r[7]);
		const { buttonProps: d } = Yo(c, s);
		let f;
		r[8] !== d || r[9] !== l
			? ((f = xe(d, l)), (r[8] = d), (r[9] = l), (r[10] = f))
			: (f = r[10]);
		let h;
		r[11] !== s || r[12] !== f || r[13] !== o
			? ((h = m.jsx("span", { ref: s, ...f, children: o })),
				(r[11] = s),
				(r[12] = f),
				(r[13] = o),
				(r[14] = h))
			: (h = r[14]);
		let p;
		return (
			r[15] !== u || r[16] !== h
				? ((p = m.jsx(u, { children: h })),
					(r[15] = u),
					(r[16] = h),
					(r[17] = p))
				: (p = r[17]),
			p
		);
	}),
	xh = E.forwardRef(function (e, n) {
		const r = ce(6);
		if ("href" in e) {
			const s = n;
			let a;
			return (
				r[0] !== e || r[1] !== s
					? ((a = m.jsx(Ore, { ...e, ref: s })),
						(r[0] = e),
						(r[1] = s),
						(r[2] = a))
					: (a = r[2]),
				a
			);
		}
		const i = n;
		let o;
		return (
			r[3] !== e || r[4] !== i
				? ((o = m.jsx(Mre, { ...e, ref: i })),
					(r[3] = e),
					(r[4] = i),
					(r[5] = o))
				: (o = r[5]),
			o
		);
	});
var iN = {};
iN = { "Clear search": "مسح البحث" };
var oN = {};
oN = { "Clear search": "Изчистване на търсене" };
var sN = {};
sN = { "Clear search": "Vymazat hledání" };
var aN = {};
aN = { "Clear search": "Ryd søgning" };
var lN = {};
lN = { "Clear search": "Suche zurücksetzen" };
var uN = {};
uN = { "Clear search": "Απαλοιφή αναζήτησης" };
var cN = {};
cN = { "Clear search": "Clear search" };
var dN = {};
dN = { "Clear search": "Borrar búsqueda" };
var fN = {};
fN = { "Clear search": "Tühjenda otsing" };
var hN = {};
hN = { "Clear search": "Tyhjennä haku" };
var pN = {};
pN = { "Clear search": "Effacer la recherche" };
var mN = {};
mN = { "Clear search": "נקה חיפוש" };
var gN = {};
gN = { "Clear search": "Obriši pretragu" };
var bN = {};
bN = { "Clear search": "Keresés törlése" };
var vN = {};
vN = { "Clear search": "Cancella ricerca" };
var yN = {};
yN = { "Clear search": "検索をクリア" };
var xN = {};
xN = { "Clear search": "검색 지우기" };
var kN = {};
kN = { "Clear search": "Išvalyti iešką" };
var CN = {};
CN = { "Clear search": "Notīrīt meklēšanu" };
var wN = {};
wN = { "Clear search": "Tøm søk" };
var EN = {};
EN = { "Clear search": "Zoekactie wissen" };
var DN = {};
DN = { "Clear search": "Wyczyść zawartość wyszukiwania" };
var SN = {};
SN = { "Clear search": "Limpar pesquisa" };
var AN = {};
AN = { "Clear search": "Limpar pesquisa" };
var $N = {};
$N = { "Clear search": "Ştergeţi căutarea" };
var TN = {};
TN = { "Clear search": "Очистить поиск" };
var BN = {};
BN = { "Clear search": "Vymazať vyhľadávanie" };
var IN = {};
IN = { "Clear search": "Počisti iskanje" };
var FN = {};
FN = { "Clear search": "Obriši pretragu" };
var PN = {};
PN = { "Clear search": "Rensa sökning" };
var NN = {};
NN = { "Clear search": "Aramayı temizle" };
var RN = {};
RN = { "Clear search": "Очистити пошук" };
var ON = {};
ON = { "Clear search": "清除搜索" };
var MN = {};
MN = { "Clear search": "清除搜尋條件" };
var jN = {};
jN = {
	"ar-AE": iN,
	"bg-BG": oN,
	"cs-CZ": sN,
	"da-DK": aN,
	"de-DE": lN,
	"el-GR": uN,
	"en-US": cN,
	"es-ES": dN,
	"et-EE": fN,
	"fi-FI": hN,
	"fr-FR": pN,
	"he-IL": mN,
	"hr-HR": gN,
	"hu-HU": bN,
	"it-IT": vN,
	"ja-JP": yN,
	"ko-KR": xN,
	"lt-LT": kN,
	"lv-LV": CN,
	"nb-NO": wN,
	"nl-NL": EN,
	"pl-PL": DN,
	"pt-BR": SN,
	"pt-PT": AN,
	"ro-RO": $N,
	"ru-RU": TN,
	"sk-SK": BN,
	"sl-SI": IN,
	"sr-SP": FN,
	"sv-SE": PN,
	"tr-TR": NN,
	"uk-UA": RN,
	"zh-CN": ON,
	"zh-TW": MN,
};
function Ax(t, e, n) {
	let { validationBehavior: r, focus: i } = t;
	at(() => {
		if (r === "native" && n != null && n.current) {
			let l = e.realtimeValidation.isInvalid
				? e.realtimeValidation.validationErrors.join(" ") ||
					"Invalid value."
				: "";
			n.current.setCustomValidity(l),
				n.current.hasAttribute("title") || (n.current.title = ""),
				e.realtimeValidation.isInvalid ||
					e.updateValidation(_re(n.current));
		}
	});
	let o = Pt(() => {
			e.resetValidation();
		}),
		s = Pt((l) => {
			var u;
			e.displayValidation.isInvalid || e.commitValidation();
			let c =
				n == null || (u = n.current) === null || u === void 0
					? void 0
					: u.form;
			if (!l.defaultPrevented && n && c && zre(c) === n.current) {
				var d;
				i ? i() : (d = n.current) === null || d === void 0 || d.focus(),
					Ic("keyboard");
			}
			l.preventDefault();
		}),
		a = Pt(() => {
			e.commitValidation();
		});
	E.useEffect(() => {
		let l = n == null ? void 0 : n.current;
		if (!l) return;
		let u = l.form;
		return (
			l.addEventListener("invalid", s),
			l.addEventListener("change", a),
			u == null || u.addEventListener("reset", o),
			() => {
				l.removeEventListener("invalid", s),
					l.removeEventListener("change", a),
					u == null || u.removeEventListener("reset", o);
			}
		);
	}, [n, s, a, o, r]);
}
function jre(t) {
	let e = t.validity;
	return {
		badInput: e.badInput,
		customError: e.customError,
		patternMismatch: e.patternMismatch,
		rangeOverflow: e.rangeOverflow,
		rangeUnderflow: e.rangeUnderflow,
		stepMismatch: e.stepMismatch,
		tooLong: e.tooLong,
		tooShort: e.tooShort,
		typeMismatch: e.typeMismatch,
		valueMissing: e.valueMissing,
		valid: e.valid,
	};
}
function _re(t) {
	return {
		isInvalid: !t.validity.valid,
		validationDetails: jre(t),
		validationErrors: t.validationMessage ? [t.validationMessage] : [],
	};
}
function zre(t) {
	for (let e = 0; e < t.elements.length; e++) {
		let n = t.elements[e];
		if (!n.validity.valid) return n;
	}
	return null;
}
const _N = {
		badInput: !1,
		customError: !1,
		patternMismatch: !1,
		rangeOverflow: !1,
		rangeUnderflow: !1,
		stepMismatch: !1,
		tooLong: !1,
		tooShort: !1,
		typeMismatch: !1,
		valueMissing: !1,
		valid: !0,
	},
	zN = { ..._N, customError: !0, valid: !1 },
	Sf = { isInvalid: !1, validationDetails: _N, validationErrors: [] },
	Lre = E.createContext({}),
	Ym = "__formValidationState" + Date.now();
function Yd(t) {
	if (t[Ym]) {
		let {
			realtimeValidation: e,
			displayValidation: n,
			updateValidation: r,
			resetValidation: i,
			commitValidation: o,
		} = t[Ym];
		return {
			realtimeValidation: e,
			displayValidation: n,
			updateValidation: r,
			resetValidation: i,
			commitValidation: o,
		};
	}
	return Vre(t);
}
function Vre(t) {
	let {
		isInvalid: e,
		validationState: n,
		name: r,
		value: i,
		builtinValidation: o,
		validate: s,
		validationBehavior: a = "aria",
	} = t;
	n && (e || (e = n === "invalid"));
	let l =
			e !== void 0
				? { isInvalid: e, validationErrors: [], validationDetails: zN }
				: null,
		u = E.useMemo(() => _6(Kre(s, i)), [s, i]);
	o != null && o.validationDetails.valid && (o = null);
	let c = E.useContext(Lre),
		d = E.useMemo(
			() =>
				r
					? Array.isArray(r)
						? r.flatMap((A) => dw(c[A]))
						: dw(c[r])
					: [],
			[c, r],
		),
		[f, h] = E.useState(c),
		[p, g] = E.useState(!1);
	c !== f && (h(c), g(!1));
	let v = E.useMemo(() => _6(p ? [] : d), [p, d]),
		b = E.useRef(Sf),
		[y, x] = E.useState(Sf),
		C = E.useRef(Sf),
		k = () => {
			if (!w) return;
			D(!1);
			let A = u || o || b.current;
			N4(A, C.current) || ((C.current = A), x(A));
		},
		[w, D] = E.useState(!1);
	return (
		E.useEffect(k),
		{
			realtimeValidation: l || v || u || o || Sf,
			displayValidation:
				a === "native" ? l || v || y : l || v || u || o || y,
			updateValidation(A) {
				a === "aria" && !N4(y, A) ? x(A) : (b.current = A);
			},
			resetValidation() {
				let A = Sf;
				N4(A, C.current) || ((C.current = A), x(A)),
					a === "native" && D(!1),
					g(!0);
			},
			commitValidation() {
				a === "native" && D(!0), g(!0);
			},
		}
	);
}
function dw(t) {
	return t ? (Array.isArray(t) ? t : [t]) : [];
}
function Kre(t, e) {
	if (typeof t == "function") {
		let n = t(e);
		if (n && typeof n != "boolean") return dw(n);
	}
	return [];
}
function _6(t) {
	return t.length
		? { isInvalid: !0, validationErrors: t, validationDetails: zN }
		: null;
}
function N4(t, e) {
	return t === e
		? !0
		: t &&
				e &&
				t.isInvalid === e.isInvalid &&
				t.validationErrors.length === e.validationErrors.length &&
				t.validationErrors.every(
					(n, r) => n === e.validationErrors[r],
				) &&
				Object.entries(t.validationDetails).every(
					([n, r]) => e.validationDetails[n] === r,
				);
}
function d0(t, e) {
	let {
			inputElementType: n = "input",
			isDisabled: r = !1,
			isRequired: i = !1,
			isReadOnly: o = !1,
			type: s = "text",
			validationBehavior: a = "aria",
		} = t,
		[l, u] = Ns(t.value, t.defaultValue || "", t.onChange),
		{ focusableProps: c } = Hd(t, e),
		d = Yd({ ...t, value: l }),
		{
			isInvalid: f,
			validationErrors: h,
			validationDetails: p,
		} = d.displayValidation,
		{
			labelProps: g,
			fieldProps: v,
			descriptionProps: b,
			errorMessageProps: y,
		} = Gd({ ...t, isInvalid: f, errorMessage: t.errorMessage || h }),
		x = Ge(t, { labelable: !0 });
	const C = { type: s, pattern: t.pattern };
	return (
		s0(e, l, u),
		Ax(t, d, e),
		E.useEffect(() => {
			if (e.current instanceof jo(e.current).HTMLTextAreaElement) {
				let k = e.current;
				Object.defineProperty(k, "defaultValue", {
					get: () => k.value,
					set: () => {},
					configurable: !0,
				});
			}
		}, [e]),
		{
			labelProps: g,
			inputProps: xe(x, n === "input" ? C : void 0, {
				disabled: r,
				readOnly: o,
				required: i && a === "native",
				"aria-required": (i && a === "aria") || void 0,
				"aria-invalid": f || void 0,
				"aria-errormessage": t["aria-errormessage"],
				"aria-activedescendant": t["aria-activedescendant"],
				"aria-autocomplete": t["aria-autocomplete"],
				"aria-haspopup": t["aria-haspopup"],
				value: l,
				onChange: (k) => u(k.target.value),
				autoComplete: t.autoComplete,
				autoCapitalize: t.autoCapitalize,
				maxLength: t.maxLength,
				minLength: t.minLength,
				name: t.name,
				placeholder: t.placeholder,
				inputMode: t.inputMode,
				onCopy: t.onCopy,
				onCut: t.onCut,
				onPaste: t.onPaste,
				onCompositionEnd: t.onCompositionEnd,
				onCompositionStart: t.onCompositionStart,
				onCompositionUpdate: t.onCompositionUpdate,
				onSelect: t.onSelect,
				onBeforeInput: t.onBeforeInput,
				onInput: t.onInput,
				...c,
				...v,
			}),
			descriptionProps: b,
			errorMessageProps: y,
			isInvalid: f,
			validationErrors: h,
			validationDetails: p,
		}
	);
}
function z6() {
	return (
		typeof window < "u" &&
		window.InputEvent &&
		typeof InputEvent.prototype.getTargetRanges == "function"
	);
}
function Ure(t, e, n) {
	let r = Pt((d) => {
		let f = n.current,
			h;
		switch (d.inputType) {
			case "historyUndo":
			case "historyRedo":
				return;
			case "insertLineBreak":
				return;
			case "deleteContent":
			case "deleteByCut":
			case "deleteByDrag":
				h =
					f.value.slice(0, f.selectionStart) +
					f.value.slice(f.selectionEnd);
				break;
			case "deleteContentForward":
				h =
					f.selectionEnd === f.selectionStart
						? f.value.slice(0, f.selectionStart) +
							f.value.slice(f.selectionEnd + 1)
						: f.value.slice(0, f.selectionStart) +
							f.value.slice(f.selectionEnd);
				break;
			case "deleteContentBackward":
				h =
					f.selectionEnd === f.selectionStart
						? f.value.slice(0, f.selectionStart - 1) +
							f.value.slice(f.selectionStart)
						: f.value.slice(0, f.selectionStart) +
							f.value.slice(f.selectionEnd);
				break;
			case "deleteSoftLineBackward":
			case "deleteHardLineBackward":
				h = f.value.slice(f.selectionStart);
				break;
			default:
				d.data != null &&
					(h =
						f.value.slice(0, f.selectionStart) +
						d.data +
						f.value.slice(f.selectionEnd));
				break;
		}
		(h == null || !e.validate(h)) && d.preventDefault();
	});
	E.useEffect(() => {
		if (!z6()) return;
		let d = n.current;
		return (
			d.addEventListener("beforeinput", r, !1),
			() => {
				d.removeEventListener("beforeinput", r, !1);
			}
		);
	}, [n, r]);
	let i = z6()
			? null
			: (d) => {
					let f =
						d.target.value.slice(0, d.target.selectionStart) +
						d.data +
						d.target.value.slice(d.target.selectionEnd);
					e.validate(f) || d.preventDefault();
				},
		{
			labelProps: o,
			inputProps: s,
			descriptionProps: a,
			errorMessageProps: l,
			...u
		} = d0(t, n),
		c = E.useRef(null);
	return {
		inputProps: xe(s, {
			onBeforeInput: i,
			onCompositionStart() {
				let {
					value: d,
					selectionStart: f,
					selectionEnd: h,
				} = n.current;
				c.current = { value: d, selectionStart: f, selectionEnd: h };
			},
			onCompositionEnd() {
				if (!e.validate(n.current.value)) {
					let {
						value: d,
						selectionStart: f,
						selectionEnd: h,
					} = c.current;
					(n.current.value = d),
						n.current.setSelectionRange(f, h),
						e.setInputValue(d);
				}
			},
		}),
		labelProps: o,
		descriptionProps: a,
		errorMessageProps: l,
		...u,
	};
}
function Hre(t) {
	return t && t.__esModule ? t.default : t;
}
function Wre(t, e, n) {
	let r = Le(Hre(jN), "@react-aria/searchfield"),
		{
			isDisabled: i,
			isReadOnly: o,
			onSubmit: s,
			onClear: a,
			type: l = "search",
		} = t,
		u = (b) => {
			const y = b.key;
			y === "Enter" && (i || o) && b.preventDefault(),
				!(i || o) &&
					(y === "Enter" && s && (b.preventDefault(), s(e.value)),
					y === "Escape" &&
						(e.value === ""
							? b.continuePropagation()
							: (e.setValue(""), a && a())));
		},
		c = () => {
			e.setValue(""), a && a();
		},
		d = () => {
			var b;
			(b = n.current) === null || b === void 0 || b.focus();
		},
		{
			labelProps: f,
			inputProps: h,
			descriptionProps: p,
			errorMessageProps: g,
			...v
		} = d0(
			{
				...t,
				value: e.value,
				onChange: e.setValue,
				onKeyDown: o ? t.onKeyDown : hr(u, t.onKeyDown),
				type: l,
			},
			n,
		);
	return {
		labelProps: f,
		inputProps: { ...h, defaultValue: void 0 },
		clearButtonProps: {
			"aria-label": r.format("Clear search"),
			excludeFromTabOrder: !0,
			preventFocusOnPress: !0,
			isDisabled: i || o,
			onPress: c,
			onPressStart: d,
		},
		descriptionProps: p,
		errorMessageProps: g,
		...v,
	};
}
function qre(t) {
	let [e, n] = Ns(L6(t.value), L6(t.defaultValue) || "", t.onChange);
	return { value: e, setValue: n };
}
function L6(t) {
	if (t != null) return t.toString();
}
const bv = m.jsx("path", {
		d: "m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3ZM12 9v4M12 17h.01",
	}),
	Gre = {
		"ar-AE": { "(optional)": "(اختياري)", "(required)": "(مطلوب)" },
		"bg-BG": {
			"(optional)": "(незадължително)",
			"(required)": "(задължително)",
		},
		"cs-CZ": { "(optional)": "(volitelně)", "(required)": "(požadováno)" },
		"da-DK": { "(optional)": "(valgfrit)", "(required)": "(obligatorisk)" },
		"de-DE": { "(optional)": "(optional)", "(required)": "(erforderlich)" },
		"el-GR": {
			"(optional)": "(προαιρετικό)",
			"(required)": "(απαιτείται)",
		},
		"en-US": { "(optional)": "(optional)", "(required)": "(required)" },
		"es-ES": { "(optional)": "(opcional)", "(required)": "(necesario)" },
		"et-EE": { "(optional)": "(valikuline)", "(required)": "(nõutav)" },
		"fi-FI": {
			"(optional)": "(valinnainen)",
			"(required)": "(pakollinen)",
		},
		"fr-FR": { "(optional)": "(facultatif)", "(required)": "(requis)" },
		"he-IL": { "(optional)": "(אופציונלי)", "(required)": "(נדרש)" },
		"hr-HR": { "(optional)": "(opcionalno)", "(required)": "(obvezno)" },
		"hu-HU": { "(optional)": "(opcionális)", "(required)": "(kötelező)" },
		"it-IT": {
			"(optional)": "(facoltativo)",
			"(required)": "(obbligatorio)",
		},
		"ja-JP": { "(optional)": "（オプション）", "(required)": "（必須）" },
		"ko-KR": { "(optional)": "(선택 사항)", "(required)": "(필수 사항)" },
		"lt-LT": { "(optional)": "(pasirenkama)", "(required)": "(privaloma)" },
		"lv-LV": { "(optional)": "(neobligāti)", "(required)": "(obligāti)" },
		"nb-NO": {
			"(optional)": "(valgfritt)",
			"(required)": "(obligatorisk)",
		},
		"nl-NL": { "(optional)": "(optioneel)", "(required)": "(vereist)" },
		"pl-PL": { "(optional)": "(opcjonalne)", "(required)": "(wymagane)" },
		"pt-BR": { "(optional)": "(opcional)", "(required)": "(obrigatório)" },
		"pt-PT": { "(optional)": "(opcional)", "(required)": "(obrigatório)" },
		"ro-RO": { "(optional)": "(opţional)", "(required)": "(obligatoriu)" },
		"ru-RU": {
			"(optional)": "(дополнительно)",
			"(required)": "(обязательно)",
		},
		"sk-SK": { "(optional)": "(nepovinné)", "(required)": "(povinné)" },
		"sl-SI": { "(optional)": "(opcijsko)", "(required)": "(obvezno)" },
		"sr-SP": { "(optional)": "(opciono)", "(required)": "(obavezno)" },
		"sv-SE": { "(optional)": "(valfritt)", "(required)": "(krävs)" },
		"tr-TR": { "(optional)": "(isteğe bağlı)", "(required)": "(gerekli)" },
		"uk-UA": {
			"(optional)": "(необов’язково)",
			"(required)": "(обов’язково)",
		},
		"zh-CN": { "(optional)": "（可选）", "(required)": "（必填）" },
		"zh-TW": { "(optional)": "(選填)", "(required)": "(必填)" },
	},
	qh = yi(function (
		{
			children: e,
			elementType: n = "label",
			isRequired: r,
			supplementRequiredState: i,
			...o
		},
		s,
	) {
		const a = lD({
			color: "neutral",
			size: "regular",
			trim: !0,
			weight: "medium",
			UNSAFE_className: X({ cursor: "default" }),
		});
		return m.jsxs(n, {
			ref: s,
			...o,
			...a,
			children: [e, r && m.jsx(Yre, { supplementRequiredState: i })],
		});
	});
function Yre(t) {
	const e = ce(6),
		{ supplementRequiredState: n } = t,
		r = Le(Gre);
	let i;
	e[0] !== n || e[1] !== r
		? ((i = n ? r.format("(required)") : void 0),
			(e[0] = n),
			(e[1] = r),
			(e[2] = i))
		: (i = e[2]);
	let o;
	e[3] === Symbol.for("react.memo_cache_sentinel")
		? ((o = m.jsx("span", {
				"aria-hidden": !0,
				className: X({
					color: B.color.foreground.critical,
					fontSize: B.typography.text.large.size,
					lineHeight: 1,
					paddingInlineStart: "0.125em",
				}),
				children: "*",
			})),
			(e[3] = o))
		: (o = e[3]);
	let s;
	return (
		e[4] !== i
			? ((s = m.jsx("span", { "aria-label": i, children: o })),
				(e[4] = i),
				(e[5] = s))
			: (s = e[5]),
		s
	);
}
const Gh = (t) => {
		const e = ce(6);
		let n;
		e[0] === Symbol.for("react.memo_cache_sentinel")
			? ((n = X({ marginTop: "calc(var(--icon-offset) * -1)" })),
				(e[0] = n))
			: (n = e[0]);
		let r;
		e[1] === Symbol.for("react.memo_cache_sentinel")
			? ((r = {
					"--icon-offset": `calc(${B.size.icon.regular} - ${B.typography.text.small.size})`,
				}),
				(e[1] = r))
			: (r = e[1]);
		let i;
		e[2] === Symbol.for("react.memo_cache_sentinel")
			? ((i = m.jsx(ve, { src: bv, color: "critical" })), (e[2] = i))
			: (i = e[2]);
		let o;
		e[3] === Symbol.for("react.memo_cache_sentinel")
			? ((o = X({ paddingTop: "var(--icon-offset)" })), (e[3] = o))
			: (o = e[3]);
		let s;
		return (
			e[4] !== t
				? ((s = m.jsxs(ke, {
						gap: "regular",
						UNSAFE_className: n,
						UNSAFE_style: r,
						children: [
							i,
							m.jsx(ue, {
								color: "critical",
								size: "small",
								UNSAFE_className: o,
								...t,
							}),
						],
					})),
					(e[4] = t),
					(e[5] = s))
				: (s = e[5]),
			s
		);
	},
	Yh = E.forwardRef(function (e, n) {
		const r = ce(30),
			{
				children: i,
				contextualHelp: o,
				isRequired: s,
				label: a,
				labelElementType: l,
				labelProps: u,
				description: c,
				descriptionProps: d,
				errorMessage: f,
				errorMessageProps: h,
				supplementRequiredState: p,
			} = e,
			g = ht(e),
			v = E.useId();
		u == null || u.id;
		let b, y;
		r[0] === Symbol.for("react.memo_cache_sentinel")
			? ((y = X({
					marginBottom: B.typography.text.regular.capheightTrim,
					marginTop: B.typography.text.regular.baselineTrim,
				})),
				(r[0] = y))
			: (y = r[0]);
		const x = u != null && u.id ? `${u.id} ${v}` : void 0;
		let C;
		r[1] !== v || r[2] !== x
			? ((C = {
					button: {
						UNSAFE_className: y,
						id: v,
						"aria-labelledby": x,
					},
				}),
				(r[1] = v),
				(r[2] = x),
				(r[3] = C))
			: (C = r[3]),
			(b = C);
		const k = b;
		let w;
		e: {
			if (!a) {
				w = null;
				break e;
			}
			let A;
			r[4] !== l || r[5] !== s || r[6] !== p || r[7] !== u || r[8] !== a
				? ((A = m.jsx(qh, {
						elementType: l,
						isRequired: s,
						supplementRequiredState: p,
						...u,
						children: a,
					})),
					(r[4] = l),
					(r[5] = s),
					(r[6] = p),
					(r[7] = u),
					(r[8] = a),
					(r[9] = A))
				: (A = r[9]);
			const T = A;
			if (o) {
				let I;
				r[10] !== k || r[11] !== o
					? ((I = m.jsx(Cn, { slots: k, children: o })),
						(r[10] = k),
						(r[11] = o),
						(r[12] = I))
					: (I = r[12]);
				let F;
				r[13] !== T || r[14] !== I
					? ((F = m.jsxs(ke, {
							gap: "small",
							alignItems: "center",
							children: [T, I],
						})),
						(r[13] = T),
						(r[14] = I),
						(r[15] = F))
					: (F = r[15]),
					(w = F);
				break e;
			}
			w = T;
		}
		let D;
		r[16] !== c || r[17] !== d
			? ((D =
					c &&
					m.jsx(ue, {
						...d,
						size: "small",
						color: "neutralSecondary",
						children: c,
					})),
				(r[16] = c),
				(r[17] = d),
				(r[18] = D))
			: (D = r[18]);
		let S;
		r[19] !== f || r[20] !== h
			? ((S = f && m.jsx(Gh, { ...h, children: f })),
				(r[19] = f),
				(r[20] = h),
				(r[21] = S))
			: (S = r[21]);
		let $;
		return (
			r[22] !== n ||
			r[23] !== g.className ||
			r[24] !== g.style ||
			r[25] !== w ||
			r[26] !== D ||
			r[27] !== i ||
			r[28] !== S
				? (($ = m.jsxs(ke, {
						ref: n,
						direction: "column",
						gap: "medium",
						minWidth: 0,
						UNSAFE_className: g.className,
						UNSAFE_style: g.style,
						children: [w, D, i, S],
					})),
					(r[22] = n),
					(r[23] = g.className),
					(r[24] = g.style),
					(r[25] = w),
					(r[26] = D),
					(r[27] = i),
					(r[28] = S),
					(r[29] = $))
				: ($ = r[29]),
			$
		);
	}),
	bD = (t) => {
		const e = ce(44);
		let n, r, i, o, s, a, l, u;
		e[0] !== t
			? (({
					children: u,
					description: a,
					errorMessage: r,
					isDisabled: i,
					isReadOnly: o,
					isRequired: n,
					label: s,
					...l
				} = t),
				(e[0] = t),
				(e[1] = n),
				(e[2] = r),
				(e[3] = i),
				(e[4] = o),
				(e[5] = s),
				(e[6] = a),
				(e[7] = l),
				(e[8] = u))
			: ((n = e[1]),
				(r = e[2]),
				(i = e[3]),
				(o = e[4]),
				(s = e[5]),
				(a = e[6]),
				(l = e[7]),
				(u = e[8]));
		const {
				labelProps: c,
				fieldProps: d,
				descriptionProps: f,
				errorMessageProps: h,
			} = Gd(t),
			p = n || void 0,
			g = r ? !0 : void 0;
		let v, b, y, x, C, k, w, D, S, $;
		if (
			e[9] !== d ||
			e[10] !== i ||
			e[11] !== o ||
			e[12] !== p ||
			e[13] !== g ||
			e[14] !== n ||
			e[15] !== s ||
			e[16] !== c ||
			e[17] !== a ||
			e[18] !== f ||
			e[19] !== r ||
			e[20] !== h ||
			e[21] !== l ||
			e[22] !== u
		) {
			const T = {
				...d,
				disabled: i,
				readOnly: o,
				"aria-required": p,
				"aria-invalid": g,
			};
			(v = Yh),
				(b = n),
				(y = s),
				(x = c),
				(C = a),
				(k = f),
				(w = r),
				(D = h),
				(S = l),
				($ = u(T)),
				(e[9] = d),
				(e[10] = i),
				(e[11] = o),
				(e[12] = p),
				(e[13] = g),
				(e[14] = n),
				(e[15] = s),
				(e[16] = c),
				(e[17] = a),
				(e[18] = f),
				(e[19] = r),
				(e[20] = h),
				(e[21] = l),
				(e[22] = u),
				(e[23] = v),
				(e[24] = b),
				(e[25] = y),
				(e[26] = x),
				(e[27] = C),
				(e[28] = k),
				(e[29] = w),
				(e[30] = D),
				(e[31] = S),
				(e[32] = $);
		} else
			(v = e[23]),
				(b = e[24]),
				(y = e[25]),
				(x = e[26]),
				(C = e[27]),
				(k = e[28]),
				(w = e[29]),
				(D = e[30]),
				(S = e[31]),
				($ = e[32]);
		let A;
		return (
			e[33] !== v ||
			e[34] !== b ||
			e[35] !== y ||
			e[36] !== x ||
			e[37] !== C ||
			e[38] !== k ||
			e[39] !== w ||
			e[40] !== D ||
			e[41] !== S ||
			e[42] !== $
				? ((A = m.jsx(v, {
						isRequired: b,
						label: y,
						labelProps: x,
						description: C,
						descriptionProps: k,
						errorMessage: w,
						errorMessageProps: D,
						...S,
						children: $,
					})),
					(e[33] = v),
					(e[34] = b),
					(e[35] = y),
					(e[36] = x),
					(e[37] = C),
					(e[38] = k),
					(e[39] = w),
					(e[40] = D),
					(e[41] = S),
					(e[42] = $),
					(e[43] = A))
				: (A = e[43]),
			A
		);
	};
function LN(t) {
	return t.errorMessage
		? Object.assign({}, { validationState: "invalid" }, t)
		: t;
}
const Jh = E.forwardRef(function (e, n) {
	var r;
	const i = ce(66);
	let o, s, a, l, u, c, d, f, h, p, g, v, b, y, x;
	if (i[0] !== e) {
		const {
			autoFocus: oe,
			description: ne,
			descriptionProps: de,
			endElement: se,
			errorMessage: re,
			errorMessageProps: he,
			id: ye,
			inputProps: Ae,
			inputWrapperProps: Pe,
			isDisabled: we,
			isMultiline: Ke,
			isRequired: rt,
			label: Ce,
			labelProps: Me,
			startElement: me,
			...De
		} = e;
		(u = oe),
			(h = ne),
			(p = de),
			(d = se),
			(g = re),
			(v = he),
			(l = Ae),
			(a = Pe),
			(s = we),
			(o = Ke),
			(f = rt),
			(b = Ce),
			(y = Me),
			(c = me),
			(x = De),
			(i[0] = e),
			(i[1] = o),
			(i[2] = s),
			(i[3] = a),
			(i[4] = l),
			(i[5] = u),
			(i[6] = c),
			(i[7] = d),
			(i[8] = f),
			(i[9] = h),
			(i[10] = p),
			(i[11] = g),
			(i[12] = v),
			(i[13] = b),
			(i[14] = y),
			(i[15] = x);
	} else
		(o = i[1]),
			(s = i[2]),
			(a = i[3]),
			(l = i[4]),
			(u = i[5]),
			(c = i[6]),
			(d = i[7]),
			(f = i[8]),
			(h = i[9]),
			(p = i[10]),
			(g = i[11]),
			(v = i[12]),
			(b = i[13]),
			(y = i[14]),
			(x = i[15]);
	const C = o === void 0 ? !1 : o,
		k = C ? "textarea" : "input";
	let w;
	i[16] !== s
		? ((w = { isDisabled: s }), (i[16] = s), (i[17] = w))
		: (w = i[17]);
	const { hoverProps: D, isHovered: S } = gn(w),
		$ = Zre(),
		A = Ct(n);
	let T;
	i[18] !== A.current
		? ((T = () => {
				var oe;
				document.activeElement !== A.current &&
					((oe = A.current) === null || oe === void 0 || oe.focus());
			}),
			(i[18] = A.current),
			(i[19] = T))
		: (T = i[19]);
	const I = T;
	let F;
	i[20] !== s || i[21] !== I
		? ((F = { isDisabled: s, onPressStart: I, preventFocusOnPress: !0 }),
			(i[20] = s),
			(i[21] = I),
			(i[22] = F))
		: (F = i[22]);
	const { pressProps: N } = zi(F);
	let O;
	if (i[23] !== a) {
		var _;
		(O = Se(
			X({
				display: "flex",
				flex: "1 1 auto",
				position: "relative",
				zIndex: 0,
			}),
			(_ = a) === null || _ === void 0 ? void 0 : _.className,
		)),
			(i[23] = a),
			(i[24] = O);
	} else O = i[24];
	let j;
	i[25] !== e || i[26] !== S || i[27] !== C
		? ((j = lt({
				adornment: V6(e),
				hovered: S || void 0,
				multiline: C || void 0,
			})),
			(i[25] = e),
			(i[26] = S),
			(i[27] = C),
			(i[28] = j))
		: (j = i[28]);
	const V = (r = l) === null || r === void 0 ? void 0 : r.className;
	let K;
	i[29] !== $ || i[30] !== V
		? ((K = Se($, V)), (i[29] = $), (i[30] = V), (i[31] = K))
		: (K = i[31]);
	let M;
	i[32] !== e ? ((M = V6(e)), (i[32] = e), (i[33] = M)) : (M = i[33]);
	const G = C ? 1 : void 0;
	let H;
	i[34] !== k ||
	i[35] !== l ||
	i[36] !== j ||
	i[37] !== K ||
	i[38] !== M ||
	i[39] !== A ||
	i[40] !== G
		? ((H = m.jsx(k, {
				...l,
				...j,
				className: K,
				"data-adornment": M,
				ref: A,
				rows: G,
			})),
			(i[34] = k),
			(i[35] = l),
			(i[36] = j),
			(i[37] = K),
			(i[38] = M),
			(i[39] = A),
			(i[40] = G),
			(i[41] = H))
		: (H = i[41]);
	let P;
	i[42] !== u || i[43] !== H
		? ((P = m.jsx(xn, { autoFocus: u, isTextInput: !0, children: H })),
			(i[42] = u),
			(i[43] = H),
			(i[44] = P))
		: (P = i[44]);
	let q;
	i[45] !== $ || i[46] !== N
		? ((q = m.jsx(Xre, { inputClassName: $, ...N })),
			(i[45] = $),
			(i[46] = N),
			(i[47] = q))
		: (q = i[47]);
	let J;
	i[48] !== a ||
	i[49] !== D ||
	i[50] !== O ||
	i[51] !== c ||
	i[52] !== P ||
	i[53] !== q ||
	i[54] !== d
		? ((J = m.jsxs("div", {
				...a,
				...D,
				className: O,
				children: [c, P, q, d],
			})),
			(i[48] = a),
			(i[49] = D),
			(i[50] = O),
			(i[51] = c),
			(i[52] = P),
			(i[53] = q),
			(i[54] = d),
			(i[55] = J))
		: (J = i[55]);
	let Z;
	return (
		i[56] !== f ||
		i[57] !== h ||
		i[58] !== p ||
		i[59] !== g ||
		i[60] !== v ||
		i[61] !== b ||
		i[62] !== y ||
		i[63] !== x ||
		i[64] !== J
			? ((Z = m.jsx(Yh, {
					isRequired: f,
					description: h,
					descriptionProps: p,
					errorMessage: g,
					errorMessageProps: v,
					label: b,
					labelProps: y,
					...x,
					children: J,
				})),
				(i[56] = f),
				(i[57] = h),
				(i[58] = p),
				(i[59] = g),
				(i[60] = v),
				(i[61] = b),
				(i[62] = y),
				(i[63] = x),
				(i[64] = J),
				(i[65] = Z))
			: (Z = i[65]),
		Z
	);
});
function Jre(t) {
	return function (...n) {
		return n.map((r) => `.${t}${r} + &`).join(", ");
	};
}
const Xre = ({ inputClassName: t, ...e }) => {
	const n = Jre(t);
	return m.jsx("div", {
		role: "presentation",
		...e,
		className: X({
			backgroundColor: B.color.background.canvas,
			border: `${B.size.border.regular} solid ${B.color.alias.borderIdle}`,
			borderRadius: B.size.radius.regular,
			cursor: "text",
			inset: 0,
			position: "absolute",
			transition: bt(["border-color", "box-shadow"]),
			zIndex: -1,
			[n("[data-hovered]")]: { borderColor: B.color.alias.borderHovered },
			[n(":invalid", "[aria-invalid]")]: {
				borderColor: B.color.alias.borderInvalid,
			},
			[n(":focus")]: { borderColor: B.color.alias.borderFocused },
			[n(":focus:not([readonly])")]: {
				boxShadow: `0 0 0 1px ${B.color.alias.borderFocused}`,
			},
			[n(":disabled", "[aria-disabled]")]: {
				backgroundColor: B.color.alias.backgroundDisabled,
				borderColor: "transparent",
				cursor: "auto",
			},
		}),
	});
};
function Zre() {
	return X({
		color: B.color.foreground.neutral,
		flex: 1,
		fontFamily: B.typography.fontFamily.base,
		fontSize: B.typography.text.regular.size,
		fontWeight: B.typography.fontWeight.regular,
		height: B.size.element.regular,
		lineHeight: B.typography.lineheight.small,
		outline: 0,
		overflow: "visible",
		paddingBlock: B.size.space.small,
		paddingInline: B.size.space.medium,
		position: "relative",
		textIndent: 0,
		textOverflow: "ellipsis",
		verticalAlign: "top",
		width: "100%",
		MozOsxFontSmoothing: "auto",
		WebkitFontSmoothing: "auto",
		"::placeholder": { color: B.color.foreground.neutralTertiary },
		"&:disabled, &[aria-disabled]": {
			color: B.color.alias.foregroundDisabled,
			"::placeholder": { color: B.color.alias.foregroundDisabled },
		},
		"&::-webkit-search-cancel-button, &::-webkit-search-decoration": {
			WebkitAppearance: "none",
		},
		"&[data-multiline]": {
			height: "auto",
			lineHeight: B.typography.lineheight.medium,
			minHeight: `calc(${B.size.space.regular} * 2 + ${B.typography.text.regular.size} * ${B.typography.lineheight.medium} * 3)`,
			overflow: "auto",
			paddingBlock: B.size.space.regular,
			resize: "none",
		},
	});
}
function V6(t) {
	return t.startElement && t.endElement
		? "both"
		: t.startElement
			? "start"
			: t.endElement
				? "end"
				: "none";
}
function vD(t) {
	return !t.placeholder || t.description, LN(t);
}
const An = E.forwardRef(function (e, n) {
		const r = ce(9);
		let i;
		r[0] !== e ? ((i = vD(e)), (r[0] = e), (r[1] = i)) : (i = r[1]),
			(e = i);
		const o = Ct(n),
			{
				labelProps: s,
				inputProps: a,
				descriptionProps: l,
				errorMessageProps: u,
			} = d0(e, o);
		let c;
		return (
			r[2] !== o ||
			r[3] !== e ||
			r[4] !== s ||
			r[5] !== a ||
			r[6] !== l ||
			r[7] !== u
				? ((c = m.jsx(Jh, {
						ref: o,
						...e,
						labelProps: s,
						inputProps: a,
						descriptionProps: l,
						errorMessageProps: u,
					})),
					(r[2] = o),
					(r[3] = e),
					(r[4] = s),
					(r[5] = a),
					(r[6] = l),
					(r[7] = u),
					(r[8] = c))
				: (c = r[8]),
			c
		);
	}),
	VN = E.forwardRef(function ({ onChange: e, ...n }, r) {
		var i;
		n = vD(n);
		let o = Ct(r),
			[s, a] = Ns(
				n.value,
				(i = n.defaultValue) !== null && i !== void 0 ? i : "",
				() => {},
			),
			l = E.useCallback(() => {
				let h = o.current;
				if (!n.height && h) {
					let p = h.style.overflow;
					"MozAppearance" in h.style || (h.style.overflow = "hidden"),
						(h.style.height = "auto"),
						(h.style.height = `${h.scrollHeight + (h.offsetHeight - h.clientHeight)}px`),
						(h.style.overflow = p);
				}
			}, [o, n.height]);
		at(() => {
			o.current && l();
		}, [l, s, o]);
		let {
			labelProps: u,
			inputProps: c,
			descriptionProps: d,
			errorMessageProps: f,
		} = d0({ ...n, onChange: hr(e, a), inputElementType: "textarea" }, o);
		return m.jsx(Jh, {
			...n,
			ref: o,
			labelProps: u,
			inputProps: c,
			descriptionProps: d,
			errorMessageProps: f,
			isMultiline: !0,
		});
	}),
	Qre = E.forwardRef(function (e, n) {
		const r = ce(30);
		let i, o, s, a, l, u, c, d;
		if (r[0] !== e) {
			const {
				autoFocus: N,
				description: O,
				errorMessage: _,
				id: j,
				isDisabled: V,
				isReadOnly: K,
				isRequired: M,
				label: G,
				showIcon: H,
				...P
			} = e;
			(c = O),
				(d = _),
				(o = V),
				(a = K),
				(l = M),
				(u = G),
				(i = H),
				(s = P),
				(r[0] = e),
				(r[1] = i),
				(r[2] = o),
				(r[3] = s),
				(r[4] = a),
				(r[5] = l),
				(r[6] = u),
				(r[7] = c),
				(r[8] = d);
		} else
			(i = r[1]),
				(o = r[2]),
				(s = r[3]),
				(a = r[4]),
				(l = r[5]),
				(u = r[6]),
				(c = r[7]),
				(d = r[8]);
		const f = i === void 0 ? !0 : i,
			h = Ct(n),
			p = qre(e),
			{
				labelProps: g,
				inputProps: v,
				clearButtonProps: b,
				descriptionProps: y,
				errorMessageProps: x,
			} = Wre(e, p, h),
			C = p.value !== "" && !e.isReadOnly;
		let k;
		r[9] !== b || r[10] !== o
			? ((k = m.jsx(wx, { ...b, preventFocus: !0, isDisabled: o })),
				(r[9] = b),
				(r[10] = o),
				(r[11] = k))
			: (k = r[11]);
		const w = k,
			D = e.isDisabled
				? "color.alias.foregroundDisabled"
				: "neutralSecondary";
		let S;
		r[12] !== D
			? ((S = m.jsx(ke, {
					alignItems: "center",
					flexShrink: 0,
					justifyContent: "center",
					pointerEvents: "none",
					width: "element.regular",
					children: m.jsx(ve, { src: nN, color: D }),
				})),
				(r[12] = D),
				(r[13] = S))
			: (S = r[13]);
		const $ = S;
		let A;
		r[14] === Symbol.for("react.memo_cache_sentinel")
			? ((A = {
					className: X({
						input: {
							'&[data-adornment="start"]': {
								paddingInlineStart: 0,
							},
							'&[data-adornment="end"]': { paddingInlineEnd: 0 },
							'&[data-adornment="both"]': { paddingInline: 0 },
						},
					}),
				}),
				(r[14] = A))
			: (A = r[14]);
		const T = f && $,
			I = C && w;
		let F;
		return (
			r[15] !== h ||
			r[16] !== s ||
			r[17] !== o ||
			r[18] !== a ||
			r[19] !== l ||
			r[20] !== u ||
			r[21] !== g ||
			r[22] !== v ||
			r[23] !== c ||
			r[24] !== y ||
			r[25] !== d ||
			r[26] !== x ||
			r[27] !== T ||
			r[28] !== I
				? ((F = m.jsx(Jh, {
						ref: h,
						...s,
						isDisabled: o,
						isReadOnly: a,
						isRequired: l,
						label: u,
						labelProps: g,
						inputProps: v,
						inputWrapperProps: A,
						description: c,
						descriptionProps: y,
						errorMessage: d,
						errorMessageProps: x,
						startElement: T,
						endElement: I,
					})),
					(r[15] = h),
					(r[16] = s),
					(r[17] = o),
					(r[18] = a),
					(r[19] = l),
					(r[20] = u),
					(r[21] = g),
					(r[22] = v),
					(r[23] = c),
					(r[24] = y),
					(r[25] = d),
					(r[26] = x),
					(r[27] = T),
					(r[28] = I),
					(r[29] = F))
				: (F = r[29]),
			F
		);
	});
function eie(t) {
	return t != null && (!isNaN(t) || String(t).match(/^(\d+)(?=%$)/) !== null);
}
function tie(t) {
	if (!t) return 1;
	let e = t.match(/^(.+)(?=fr$)/);
	return e
		? parseFloat(e[0])
		: (console.warn(
				`width: ${t} is not a supported format, width should be a number (ex. 150), percentage (ex. '50%') or fr unit (ex. '2fr')`,
				"defaulting to '1fr'",
			),
			1);
}
function yD(t, e) {
	if (typeof t == "string") {
		let n = t.match(/^(\d+)(?=%$)/);
		if (!n)
			throw new Error(
				"Only percentages or numbers are supported for static column widths",
			);
		return e * (parseFloat(n[0]) / 100);
	}
	return t;
}
function KN(t, e) {
	return t != null ? yD(t, e) : Number.MAX_SAFE_INTEGER;
}
function UN(t, e) {
	return t != null ? yD(t, e) : 0;
}
function nie(t, e, n, r, i) {
	let o = !1,
		s = e.map((a, l) => {
			var u, c, d;
			let f =
					n.get(a.key) != null
						? n.get(a.key)
						: (d =
									(c =
										(u = a.width) !== null && u !== void 0
											? u
											: a.defaultWidth) !== null &&
									c !== void 0
										? c
										: r == null
											? void 0
											: r(l)) !== null && d !== void 0
							? d
							: "1fr",
				h = !1,
				p = 0,
				g = 0,
				v = null;
			eie(f)
				? ((p = yD(f, t)), (h = !0))
				: ((g = tie(f)), g <= 0 && (h = !0));
			var b, y;
			let x = UN(
					(y =
						(b = a.minWidth) !== null && b !== void 0
							? b
							: i == null
								? void 0
								: i(l)) !== null && y !== void 0
						? y
						: 0,
					t,
				),
				C = KN(a.maxWidth, t),
				k = Math.max(x, Math.min(p, C));
			return (
				h ? (v = k) : p > k && ((h = !0), (v = k)),
				h || (o = !0),
				{
					frozen: h,
					baseSize: p,
					hypotheticalMainSize: k,
					min: x,
					max: C,
					flex: g,
					targetMainSize: v,
					violation: 0,
				}
			);
		});
	for (; o; ) {
		let a = 0,
			l = 0;
		s.forEach((d) => {
			d.frozen
				? (a += d.targetMainSize)
				: ((a += d.baseSize), (l += d.flex));
		});
		let u = t - a;
		u > 0 &&
			s.forEach((d) => {
				if (!d.frozen) {
					let f = d.flex / l;
					d.targetMainSize = d.baseSize + f * u;
				}
			});
		let c = 0;
		s.forEach((d) => {
			if (((d.violation = 0), !d.frozen)) {
				let { min: f, max: h, targetMainSize: p } = d;
				(d.targetMainSize = Math.max(f, Math.min(p, h))),
					(d.violation = d.targetMainSize - p),
					(c += d.violation);
			}
		}),
			(o = !1),
			s.forEach((d) => {
				c === 0 || Math.sign(c) === Math.sign(d.violation)
					? (d.frozen = !0)
					: d.frozen || (o = !0);
			});
	}
	return rie(s);
}
function rie(t) {
	let e = 0,
		n = 0,
		r = [];
	return (
		t.forEach(function (i) {
			let o = i.targetMainSize,
				s = Math.round(o + e) - n;
			(e += o), (n += s), r.push(s);
		}),
		r
	);
}
class HN {
	splitColumnsIntoControlledAndUncontrolled(e) {
		return e.reduce(
			(n, r) => (
				r.props.width != null ? n[0].set(r.key, r) : n[1].set(r.key, r),
				n
			),
			[new Map(), new Map()],
		);
	}
	recombineColumns(e, n, r, i) {
		return new Map(
			e.map((o) =>
				r.has(o.key)
					? [o.key, n.get(o.key)]
					: [o.key, i.get(o.key).props.width],
			),
		);
	}
	getInitialUncontrolledWidths(e) {
		return new Map(
			Array.from(e).map(([n, r]) => {
				var i, o, s, a;
				return [
					n,
					(a =
						(s = r.props.defaultWidth) !== null && s !== void 0
							? s
							: (i = (o = this).getDefaultWidth) === null ||
								  i === void 0
								? void 0
								: i.call(o, r)) !== null && a !== void 0
						? a
						: "1fr",
				];
			}),
		);
	}
	getColumnWidth(e) {
		var n;
		return (n = this.columnWidths.get(e)) !== null && n !== void 0 ? n : 0;
	}
	getColumnMinWidth(e) {
		var n;
		return (n = this.columnMinWidths.get(e)) !== null && n !== void 0
			? n
			: 0;
	}
	getColumnMaxWidth(e) {
		var n;
		return (n = this.columnMaxWidths.get(e)) !== null && n !== void 0
			? n
			: 0;
	}
	resizeColumnWidth(e, n, r, i) {
		let o = this.columnWidths,
			s = !0,
			a = new Map();
		return (
			(i = Math.max(
				this.getColumnMinWidth(r),
				Math.min(this.getColumnMaxWidth(r), Math.floor(i)),
			)),
			e.columns.forEach((l) => {
				var u;
				l.key === r
					? (a.set(l.key, i), (s = !1))
					: s
						? a.set(l.key, o.get(l.key))
						: a.set(
								l.key,
								(u = l.props.width) !== null && u !== void 0
									? u
									: n.get(l.key),
							);
			}),
			a
		);
	}
	buildColumnWidths(e, n, r) {
		return (
			(this.columnWidths = new Map()),
			(this.columnMinWidths = new Map()),
			(this.columnMaxWidths = new Map()),
			nie(
				e,
				n.columns.map((o) => ({ ...o.props, key: o.key })),
				r,
				(o) => this.getDefaultWidth(n.columns[o]),
				(o) => this.getDefaultMinWidth(n.columns[o]),
			).forEach((o, s) => {
				let a = n.columns[s].key,
					l = n.columns[s];
				this.columnWidths.set(a, o);
				var u;
				this.columnMinWidths.set(
					a,
					UN(
						(u = l.props.minWidth) !== null && u !== void 0
							? u
							: this.getDefaultMinWidth(l),
						e,
					),
				),
					this.columnMaxWidths.set(a, KN(l.props.maxWidth, e));
			}),
			this.columnWidths
		);
	}
	constructor(e) {
		(this.columnWidths = new Map()),
			(this.columnMinWidths = new Map()),
			(this.columnMaxWidths = new Map());
		var n;
		this.getDefaultWidth =
			(n = e == null ? void 0 : e.getDefaultWidth) !== null &&
			n !== void 0
				? n
				: () => "1fr";
		var r;
		this.getDefaultMinWidth =
			(r = e == null ? void 0 : e.getDefaultMinWidth) !== null &&
			r !== void 0
				? r
				: () => 75;
	}
}
function iie(t, e) {
	let { getDefaultWidth: n, getDefaultMinWidth: r, tableWidth: i = 0 } = t,
		[o, s] = E.useState(null),
		a = E.useMemo(
			() => new HN({ getDefaultWidth: n, getDefaultMinWidth: r }),
			[n, r],
		),
		[l, u] = E.useMemo(
			() =>
				a.splitColumnsIntoControlledAndUncontrolled(
					e.collection.columns,
				),
			[e.collection.columns, a],
		),
		[c, d] = E.useState(() => a.getInitialUncontrolledWidths(u)),
		[f, h] = E.useState(e.collection.columns);
	if (e.collection.columns !== f) {
		if (
			e.collection.columns.length !== f.length ||
			e.collection.columns.some((x, C) => x.key !== f[C].key)
		) {
			let x = a.getInitialUncontrolledWidths(u);
			d(x);
		}
		h(e.collection.columns);
	}
	let p = E.useMemo(
			() => a.recombineColumns(e.collection.columns, c, u, l),
			[e.collection.columns, c, u, l, a],
		),
		g = E.useCallback(
			(x) => {
				s(x);
			},
			[s],
		),
		v = E.useCallback(
			(x, C) => {
				let k = a.resizeColumnWidth(e.collection, c, x, C),
					w = new Map(Array.from(u).map(([D]) => [D, k.get(D)]));
				return w.set(x, C), d(w), k;
			},
			[u, d, a, e.collection, c],
		),
		b = E.useCallback(() => {
			s(null);
		}, [s]),
		y = E.useMemo(
			() => a.buildColumnWidths(i, e.collection, p),
			[i, e.collection, p, a],
		);
	return E.useMemo(
		() => ({
			resizingColumn: o,
			updateResizedColumns: v,
			startResize: g,
			endResize: b,
			getColumnWidth: (x) => a.getColumnWidth(x),
			getColumnMinWidth: (x) => a.getColumnMinWidth(x),
			getColumnMaxWidth: (x) => a.getColumnMaxWidth(x),
			tableState: e,
			columnWidths: y,
		}),
		[a, y, o, v, g, b, e],
	);
}
function WN(t) {
	return null;
}
WN.getCollectionNode = function* (e, n) {
	let { childItems: r, title: i, children: o } = e,
		s = e.title || e.children,
		a =
			e.textValue ||
			(typeof s == "string" ? s : "") ||
			e["aria-label"] ||
			"";
	!a &&
		!(n != null && n.suppressTextValueWarning) &&
		console.warn(
			"<Item> with non-plain text contents is unsupported by type to select for accessibility. Please add a `textValue` prop.",
		),
		yield {
			type: "item",
			props: e,
			rendered: s,
			textValue: a,
			"aria-label": e["aria-label"],
			hasChildNodes: oie(e),
			*childNodes() {
				if (r) for (let l of r) yield { type: "item", value: l };
				else if (i) {
					let l = [];
					le.Children.forEach(o, (u) => {
						l.push({ type: "item", element: u });
					}),
						yield* l;
				}
			},
		};
};
function oie(t) {
	return t.hasChildItems != null
		? t.hasChildItems
		: !!(t.childItems || (t.title && le.Children.count(t.children) > 0));
}
let Mt = WN;
function qN(t) {
	return null;
}
qN.getCollectionNode = function* (e) {
	let { children: n, title: r, items: i } = e;
	yield {
		type: "section",
		props: e,
		hasChildNodes: !0,
		rendered: r,
		"aria-label": e["aria-label"],
		*childNodes() {
			if (typeof n == "function") {
				if (!i)
					throw new Error(
						"props.children was a function but props.items is missing",
					);
				for (let o of i) yield { type: "item", value: o, renderer: n };
			} else {
				let o = [];
				le.Children.forEach(n, (s) => {
					o.push({ type: "item", element: s });
				}),
					yield* o;
			}
		},
	};
};
let sie = qN;
class aie {
	build(e, n) {
		return (this.context = n), K6(() => this.iterateCollection(e));
	}
	*iterateCollection(e) {
		let { children: n, items: r } = e;
		if (typeof n == "function") {
			if (!r)
				throw new Error(
					"props.children was a function but props.items is missing",
				);
			for (let i of e.items)
				yield* this.getFullNode({ value: i }, { renderer: n });
		} else {
			let i = [];
			le.Children.forEach(n, (s) => {
				i.push(s);
			});
			let o = 0;
			for (let s of i) {
				let a = this.getFullNode({ element: s, index: o }, {});
				for (let l of a) o++, yield l;
			}
		}
	}
	getKey(e, n, r, i) {
		if (e.key != null) return e.key;
		if (n.type === "cell" && n.key != null) return `${i}${n.key}`;
		let o = n.value;
		if (o != null) {
			var s;
			let a = (s = o.key) !== null && s !== void 0 ? s : o.id;
			if (a == null) throw new Error("No key found for item");
			return a;
		}
		return i ? `${i}.${n.index}` : `$.${n.index}`;
	}
	getChildState(e, n) {
		return { renderer: n.renderer || e.renderer };
	}
	*getFullNode(e, n, r, i) {
		let o = e.element;
		if (!o && e.value && n && n.renderer) {
			let l = this.cache.get(e.value);
			if (
				l &&
				(!l.shouldInvalidate || !l.shouldInvalidate(this.context))
			) {
				(l.index = e.index), (l.parentKey = i ? i.key : null), yield l;
				return;
			}
			o = n.renderer(e.value);
		}
		if (le.isValidElement(o)) {
			let l = o.type;
			if (
				typeof l != "function" &&
				typeof l.getCollectionNode != "function"
			) {
				let f = typeof o.type == "function" ? o.type.name : o.type;
				throw new Error(`Unknown element <${f}> in collection.`);
			}
			let u = l.getCollectionNode(o.props, this.context),
				c = e.index,
				d = u.next();
			for (; !d.done && d.value; ) {
				let f = d.value;
				e.index = c;
				let h = f.key;
				h || (h = f.element ? null : this.getKey(o, e, n, r));
				let g = [
					...this.getFullNode(
						{
							...f,
							key: h,
							index: c,
							wrapper: lie(e.wrapper, f.wrapper),
						},
						this.getChildState(n, f),
						r ? `${r}${o.key}` : o.key,
						i,
					),
				];
				for (let v of g) {
					if (
						((v.value = f.value || e.value),
						v.value && this.cache.set(v.value, v),
						e.type && v.type !== e.type)
					)
						throw new Error(
							`Unsupported type <${R4(v.type)}> in <${R4(i.type)}>. Only <${R4(e.type)}> is supported.`,
						);
					c++, yield v;
				}
				d = u.next(g);
			}
			return;
		}
		if (e.key == null) return;
		let s = this,
			a = {
				type: e.type,
				props: e.props,
				key: e.key,
				parentKey: i ? i.key : null,
				value: e.value,
				level: i ? i.level + 1 : 0,
				index: e.index,
				rendered: e.rendered,
				textValue: e.textValue,
				"aria-label": e["aria-label"],
				wrapper: e.wrapper,
				shouldInvalidate: e.shouldInvalidate,
				hasChildNodes: e.hasChildNodes,
				childNodes: K6(function* () {
					if (!e.hasChildNodes) return;
					let l = 0;
					for (let u of e.childNodes()) {
						u.key != null && (u.key = `${a.key}${u.key}`),
							(u.index = l);
						let c = s.getFullNode(
							u,
							s.getChildState(n, u),
							a.key,
							a,
						);
						for (let d of c) l++, yield d;
					}
				}),
			};
		yield a;
	}
	constructor() {
		this.cache = new WeakMap();
	}
}
function K6(t) {
	let e = [],
		n = null;
	return {
		*[Symbol.iterator]() {
			for (let r of e) yield r;
			n || (n = t());
			for (let r of n) e.push(r), yield r;
		},
	};
}
function lie(t, e) {
	if (t && e) return (n) => t(e(n));
	if (t) return t;
	if (e) return e;
}
function R4(t) {
	return t[0].toUpperCase() + t.slice(1);
}
function xD(t, e, n) {
	let r = E.useMemo(() => new aie(), []),
		{ children: i, items: o, collection: s } = t;
	return E.useMemo(() => {
		if (s) return s;
		let l = r.build({ children: i, items: o }, n);
		return e(l);
	}, [r, i, o, s, n, e]);
}
function Wt(t, e) {
	return typeof e.getChildren == "function"
		? e.getChildren(t.key)
		: t.childNodes;
}
function Ja(t) {
	return Zl(t, 0);
}
function Zl(t, e) {
	if (e < 0) return;
	let n = 0;
	for (let r of t) {
		if (n === e) return r;
		n++;
	}
}
function Xa(t) {
	let e;
	for (let n of t) e = n;
	return e;
}
function O4(t, e, n) {
	if (e.parentKey === n.parentKey) return e.index - n.index;
	let r = [...U6(t, e), e],
		i = [...U6(t, n), n],
		o = r.slice(0, i.length).findIndex((s, a) => s !== i[a]);
	return o !== -1
		? ((e = r[o]), (n = i[o]), e.index - n.index)
		: r.findIndex((s) => s === n) >= 0
			? 1
			: (i.findIndex((s) => s === e) >= 0, -1);
}
function U6(t, e) {
	let n = [];
	for (; (e == null ? void 0 : e.parentKey) != null; )
		(e = t.getItem(e.parentKey)), n.unshift(e);
	return n;
}
const H6 = new WeakMap();
function kD(t) {
	let e = H6.get(t);
	if (e != null) return e;
	e = 0;
	let n = (r) => {
		for (let i of r) i.type === "section" ? n(Wt(i, t)) : e++;
	};
	return n(t), H6.set(t, e), e;
}
class hs extends Set {
	constructor(e, n, r) {
		super(e),
			e instanceof hs
				? ((this.anchorKey = n || e.anchorKey),
					(this.currentKey = r || e.currentKey))
				: ((this.anchorKey = n), (this.currentKey = r));
	}
}
function uie(t, e) {
	if (t.size !== e.size) return !1;
	for (let n of t) if (!e.has(n)) return !1;
	return !0;
}
function CD(t) {
	let {
			selectionMode: e = "none",
			disallowEmptySelection: n,
			allowDuplicateSelectionEvents: r,
			selectionBehavior: i = "toggle",
			disabledBehavior: o = "all",
		} = t,
		s = E.useRef(!1),
		[, a] = E.useState(!1),
		l = E.useRef(null),
		u = E.useRef(null),
		[, c] = E.useState(null),
		d = E.useMemo(() => W6(t.selectedKeys), [t.selectedKeys]),
		f = E.useMemo(
			() => W6(t.defaultSelectedKeys, new hs()),
			[t.defaultSelectedKeys],
		),
		[h, p] = Ns(d, f, t.onSelectionChange),
		g = E.useMemo(
			() => (t.disabledKeys ? new Set(t.disabledKeys) : new Set()),
			[t.disabledKeys],
		),
		[v, b] = E.useState(i);
	i === "replace" &&
		v === "toggle" &&
		typeof h == "object" &&
		h.size === 0 &&
		b("replace");
	let y = E.useRef(i);
	return (
		E.useEffect(() => {
			i !== y.current && (b(i), (y.current = i));
		}, [i]),
		{
			selectionMode: e,
			disallowEmptySelection: n,
			selectionBehavior: v,
			setSelectionBehavior: b,
			get isFocused() {
				return s.current;
			},
			setFocused(x) {
				(s.current = x), a(x);
			},
			get focusedKey() {
				return l.current;
			},
			get childFocusStrategy() {
				return u.current;
			},
			setFocusedKey(x, C = "first") {
				(l.current = x), (u.current = C), c(x);
			},
			selectedKeys: h,
			setSelectedKeys(x) {
				(r || !uie(x, h)) && p(x);
			},
			disabledKeys: g,
			disabledBehavior: o,
		}
	);
}
function W6(t, e) {
	return t ? (t === "all" ? "all" : new hs(t)) : e;
}
class wD {
	get selectionMode() {
		return this.state.selectionMode;
	}
	get disallowEmptySelection() {
		return this.state.disallowEmptySelection;
	}
	get selectionBehavior() {
		return this.state.selectionBehavior;
	}
	setSelectionBehavior(e) {
		this.state.setSelectionBehavior(e);
	}
	get isFocused() {
		return this.state.isFocused;
	}
	setFocused(e) {
		this.state.setFocused(e);
	}
	get focusedKey() {
		return this.state.focusedKey;
	}
	get childFocusStrategy() {
		return this.state.childFocusStrategy;
	}
	setFocusedKey(e, n) {
		(e == null || this.collection.getItem(e)) &&
			this.state.setFocusedKey(e, n);
	}
	get selectedKeys() {
		return this.state.selectedKeys === "all"
			? new Set(this.getSelectAllKeys())
			: this.state.selectedKeys;
	}
	get rawSelection() {
		return this.state.selectedKeys;
	}
	isSelected(e) {
		return this.state.selectionMode === "none"
			? !1
			: ((e = this.getKey(e)),
				this.state.selectedKeys === "all"
					? this.canSelectItem(e)
					: this.state.selectedKeys.has(e));
	}
	get isEmpty() {
		return (
			this.state.selectedKeys !== "all" &&
			this.state.selectedKeys.size === 0
		);
	}
	get isSelectAll() {
		if (this.isEmpty) return !1;
		if (this.state.selectedKeys === "all") return !0;
		if (this._isSelectAll != null) return this._isSelectAll;
		let e = this.getSelectAllKeys(),
			n = this.state.selectedKeys;
		return (
			(this._isSelectAll = e.every((r) => n.has(r))), this._isSelectAll
		);
	}
	get firstSelectedKey() {
		let e = null;
		for (let n of this.state.selectedKeys) {
			let r = this.collection.getItem(n);
			(!e || (r && O4(this.collection, r, e) < 0)) && (e = r);
		}
		return e == null ? void 0 : e.key;
	}
	get lastSelectedKey() {
		let e = null;
		for (let n of this.state.selectedKeys) {
			let r = this.collection.getItem(n);
			(!e || (r && O4(this.collection, r, e) > 0)) && (e = r);
		}
		return e == null ? void 0 : e.key;
	}
	get disabledKeys() {
		return this.state.disabledKeys;
	}
	get disabledBehavior() {
		return this.state.disabledBehavior;
	}
	extendSelection(e) {
		if (this.selectionMode === "none") return;
		if (this.selectionMode === "single") {
			this.replaceSelection(e);
			return;
		}
		e = this.getKey(e);
		let n;
		if (this.state.selectedKeys === "all") n = new hs([e], e, e);
		else {
			let r = this.state.selectedKeys,
				i = r.anchorKey || e;
			n = new hs(r, i, e);
			for (let o of this.getKeyRange(i, r.currentKey || e)) n.delete(o);
			for (let o of this.getKeyRange(e, i))
				this.canSelectItem(o) && n.add(o);
		}
		this.state.setSelectedKeys(n);
	}
	getKeyRange(e, n) {
		let r = this.collection.getItem(e),
			i = this.collection.getItem(n);
		return r && i
			? O4(this.collection, r, i) <= 0
				? this.getKeyRangeInternal(e, n)
				: this.getKeyRangeInternal(n, e)
			: [];
	}
	getKeyRangeInternal(e, n) {
		let r = [],
			i = e;
		for (; i; ) {
			let o = this.collection.getItem(i);
			if (
				(((o && o.type === "item") ||
					(o.type === "cell" && this.allowsCellSelection)) &&
					r.push(i),
				i === n)
			)
				return r;
			i = this.collection.getKeyAfter(i);
		}
		return [];
	}
	getKey(e) {
		let n = this.collection.getItem(e);
		if (!n || (n.type === "cell" && this.allowsCellSelection)) return e;
		for (; n.type !== "item" && n.parentKey != null; )
			n = this.collection.getItem(n.parentKey);
		return !n || n.type !== "item" ? null : n.key;
	}
	toggleSelection(e) {
		if (this.selectionMode === "none") return;
		if (this.selectionMode === "single" && !this.isSelected(e)) {
			this.replaceSelection(e);
			return;
		}
		if (((e = this.getKey(e)), e == null)) return;
		let n = new hs(
			this.state.selectedKeys === "all"
				? this.getSelectAllKeys()
				: this.state.selectedKeys,
		);
		n.has(e)
			? n.delete(e)
			: this.canSelectItem(e) &&
				(n.add(e), (n.anchorKey = e), (n.currentKey = e)),
			!(this.disallowEmptySelection && n.size === 0) &&
				this.state.setSelectedKeys(n);
	}
	replaceSelection(e) {
		if (this.selectionMode === "none" || ((e = this.getKey(e)), e == null))
			return;
		let n = this.canSelectItem(e) ? new hs([e], e, e) : new hs();
		this.state.setSelectedKeys(n);
	}
	setSelectedKeys(e) {
		if (this.selectionMode === "none") return;
		let n = new hs();
		for (let r of e)
			if (
				((r = this.getKey(r)),
				r != null && (n.add(r), this.selectionMode === "single"))
			)
				break;
		this.state.setSelectedKeys(n);
	}
	getSelectAllKeys() {
		let e = [],
			n = (r) => {
				for (; r != null; ) {
					if (this.canSelectItem(r)) {
						let i = this.collection.getItem(r);
						i.type === "item" && e.push(r),
							i.hasChildNodes &&
								(this.allowsCellSelection ||
									i.type !== "item") &&
								n(Ja(Wt(i, this.collection)).key);
					}
					r = this.collection.getKeyAfter(r);
				}
			};
		return n(this.collection.getFirstKey()), e;
	}
	selectAll() {
		!this.isSelectAll &&
			this.selectionMode === "multiple" &&
			this.state.setSelectedKeys("all");
	}
	clearSelection() {
		!this.disallowEmptySelection &&
			(this.state.selectedKeys === "all" ||
				this.state.selectedKeys.size > 0) &&
			this.state.setSelectedKeys(new hs());
	}
	toggleSelectAll() {
		this.isSelectAll ? this.clearSelection() : this.selectAll();
	}
	select(e, n) {
		this.selectionMode !== "none" &&
			(this.selectionMode === "single"
				? this.isSelected(e) && !this.disallowEmptySelection
					? this.toggleSelection(e)
					: this.replaceSelection(e)
				: this.selectionBehavior === "toggle" ||
					  (n &&
							(n.pointerType === "touch" ||
								n.pointerType === "virtual"))
					? this.toggleSelection(e)
					: this.replaceSelection(e));
	}
	isSelectionEqual(e) {
		if (e === this.state.selectedKeys) return !0;
		let n = this.selectedKeys;
		if (e.size !== n.size) return !1;
		for (let r of e) if (!n.has(r)) return !1;
		for (let r of n) if (!e.has(r)) return !1;
		return !0;
	}
	canSelectItem(e) {
		var n;
		if (
			this.state.selectionMode === "none" ||
			this.state.disabledKeys.has(e)
		)
			return !1;
		let r = this.collection.getItem(e);
		return !(
			!r ||
			(!(r == null || (n = r.props) === null || n === void 0) &&
				n.isDisabled) ||
			(r.type === "cell" && !this.allowsCellSelection)
		);
	}
	isDisabled(e) {
		var n, r;
		return (
			this.state.disabledBehavior === "all" &&
			(this.state.disabledKeys.has(e) ||
				!!(
					!(
						(r = this.collection.getItem(e)) === null ||
						r === void 0 ||
						(n = r.props) === null ||
						n === void 0
					) && n.isDisabled
				))
		);
	}
	isLink(e) {
		var n, r;
		return !!(
			!(
				(r = this.collection.getItem(e)) === null ||
				r === void 0 ||
				(n = r.props) === null ||
				n === void 0
			) && n.href
		);
	}
	getItemProps(e) {
		var n;
		return (n = this.collection.getItem(e)) === null || n === void 0
			? void 0
			: n.props;
	}
	constructor(e, n, r) {
		(this.collection = e), (this.state = n);
		var i;
		(this.allowsCellSelection =
			(i = r == null ? void 0 : r.allowsCellSelection) !== null &&
			i !== void 0
				? i
				: !1),
			(this._isSelectAll = null);
	}
}
function cie(t) {
	let { collection: e, focusMode: n } = t,
		r = t.UNSAFE_selectionState || CD(t),
		i = E.useMemo(
			() => (t.disabledKeys ? new Set(t.disabledKeys) : new Set()),
			[t.disabledKeys],
		),
		o = r.setFocusedKey;
	r.setFocusedKey = (l, u) => {
		if (n === "cell" && l != null) {
			let f = e.getItem(l);
			if ((f == null ? void 0 : f.type) === "item") {
				var c, d;
				let h = Wt(f, e);
				u === "last"
					? (l =
							(c = Xa(h)) === null || c === void 0
								? void 0
								: c.key)
					: (l =
							(d = Ja(h)) === null || d === void 0
								? void 0
								: d.key);
			}
		}
		o(l, u);
	};
	let s = E.useMemo(() => new wD(e, r), [e, r]);
	const a = E.useRef(null);
	return (
		E.useEffect(() => {
			if (r.focusedKey != null && !e.getItem(r.focusedKey)) {
				const l = a.current.getItem(r.focusedKey),
					u =
						l.parentKey != null &&
						(l.type === "cell" ||
							l.type === "rowheader" ||
							l.type === "column")
							? a.current.getItem(l.parentKey)
							: l,
					c = a.current.rows,
					d = e.rows,
					f = c.length - d.length;
				let h = Math.min(
						f > 1 ? Math.max(u.index - f + 1, 0) : u.index,
						d.length - 1,
					),
					p;
				for (; h >= 0; ) {
					if (!s.isDisabled(d[h].key) && d[h].type !== "headerrow") {
						p = d[h];
						break;
					}
					h < d.length - 1
						? h++
						: (h > u.index && (h = u.index), h--);
				}
				if (p) {
					const g = p.hasChildNodes ? [...Wt(p, e)] : [],
						v =
							p.hasChildNodes && u !== l && l.index < g.length
								? g[l.index].key
								: p.key;
					r.setFocusedKey(v);
				} else r.setFocusedKey(null);
			}
			a.current = e;
		}, [e, s, r, r.focusedKey]),
		{
			collection: e,
			disabledKeys: i,
			isKeyboardNavigationDisabled: !1,
			selectionManager: s,
		}
	);
}
class die {
	*[Symbol.iterator]() {
		yield* [...this.rows];
	}
	get size() {
		return [...this.rows].length;
	}
	getKeys() {
		return this.keyMap.keys();
	}
	getKeyBefore(e) {
		let n = this.keyMap.get(e);
		return n ? n.prevKey : null;
	}
	getKeyAfter(e) {
		let n = this.keyMap.get(e);
		return n ? n.nextKey : null;
	}
	getFirstKey() {
		var e;
		return (e = [...this.rows][0]) === null || e === void 0
			? void 0
			: e.key;
	}
	getLastKey() {
		var e;
		let n = [...this.rows];
		return (e = n[n.length - 1]) === null || e === void 0 ? void 0 : e.key;
	}
	getItem(e) {
		return this.keyMap.get(e);
	}
	at(e) {
		const n = [...this.getKeys()];
		return this.getItem(n[e]);
	}
	getChildren(e) {
		let n = this.keyMap.get(e);
		return (n == null ? void 0 : n.childNodes) || [];
	}
	constructor(e) {
		(this.keyMap = new Map()),
			(this.keyMap = new Map()),
			(this.columnCount = e == null ? void 0 : e.columnCount),
			(this.rows = []);
		let n = (o) => {
				let s = this.keyMap.get(o.key);
				e.visitNode && (o = e.visitNode(o)), this.keyMap.set(o.key, o);
				let a = new Set(),
					l;
				for (let u of o.childNodes)
					u.type === "cell" &&
						u.parentKey == null &&
						(u.parentKey = o.key),
						a.add(u.key),
						l
							? ((l.nextKey = u.key), (u.prevKey = l.key))
							: (u.prevKey = null),
						n(u),
						(l = u);
				if ((l && (l.nextKey = null), s))
					for (let u of s.childNodes) a.has(u.key) || r(u);
			},
			r = (o) => {
				this.keyMap.delete(o.key);
				for (let s of o.childNodes)
					this.keyMap.get(s.key) === s && r(s);
			},
			i;
		e.items.forEach((o, s) => {
			let a = {
				level: 0,
				key: "row-" + s,
				type: "row",
				value: void 0,
				hasChildNodes: !0,
				childNodes: [...o.childNodes],
				rendered: void 0,
				textValue: void 0,
				...o,
			};
			i ? ((i.nextKey = a.key), (a.prevKey = i.key)) : (a.prevKey = null),
				this.rows.push(a),
				n(a),
				(i = a);
		}),
			i && (i.nextKey = null);
	}
}
const GN = "row-header-column-" + Math.random().toString(36).slice(2);
let fw = "row-header-column-" + Math.random().toString(36).slice(2);
for (; GN === fw; )
	fw = "row-header-column-" + Math.random().toString(36).slice(2);
function fie(t, e) {
	if (e.length === 0) return [];
	let n = [],
		r = new Map();
	for (let l of e) {
		let u = l.parentKey,
			c = [l];
		for (; u; ) {
			let d = t.get(u);
			if (!d) break;
			if (r.has(d)) {
				d.colspan++;
				let { column: f, index: h } = r.get(d);
				if (h > c.length) break;
				for (let p = h; p < c.length; p++) f.splice(p, 0, null);
				for (let p = c.length; p < f.length; p++)
					f[p] && r.has(f[p]) && (r.get(f[p]).index = p);
			} else
				(d.colspan = 1),
					c.push(d),
					r.set(d, { column: c, index: c.length - 1 });
			u = d.parentKey;
		}
		n.push(c), (l.index = n.length - 1);
	}
	let i = Math.max(...n.map((l) => l.length)),
		o = Array(i)
			.fill(0)
			.map(() => []),
		s = 0;
	for (let l of n) {
		let u = i - 1;
		for (let c of l) {
			if (c) {
				let d = o[u],
					f = d.reduce((h, p) => h + p.colspan, 0);
				if (f < s) {
					let h = {
						type: "placeholder",
						key: "placeholder-" + c.key,
						colspan: s - f,
						index: f,
						value: null,
						rendered: null,
						level: u,
						hasChildNodes: !1,
						childNodes: [],
						textValue: null,
					};
					d.length > 0 &&
						((d[d.length - 1].nextKey = h.key),
						(h.prevKey = d[d.length - 1].key)),
						d.push(h);
				}
				d.length > 0 &&
					((d[d.length - 1].nextKey = c.key),
					(c.prevKey = d[d.length - 1].key)),
					(c.level = u),
					(c.colIndex = s),
					d.push(c);
			}
			u--;
		}
		s++;
	}
	let a = 0;
	for (let l of o) {
		let u = l.reduce((c, d) => c + d.colspan, 0);
		if (u < e.length) {
			let c = {
				type: "placeholder",
				key: "placeholder-" + l[l.length - 1].key,
				colspan: e.length - u,
				index: u,
				value: null,
				rendered: null,
				level: a,
				hasChildNodes: !1,
				childNodes: [],
				textValue: null,
				prevKey: l[l.length - 1].key,
			};
			l.push(c);
		}
		a++;
	}
	return o.map((l, u) => ({
		type: "headerrow",
		key: "headerrow-" + u,
		index: u,
		value: null,
		rendered: null,
		level: 0,
		hasChildNodes: !0,
		childNodes: l,
		textValue: null,
	}));
}
class hie extends die {
	*[Symbol.iterator]() {
		yield* this.body.childNodes;
	}
	get size() {
		return this._size;
	}
	getKeys() {
		return this.keyMap.keys();
	}
	getKeyBefore(e) {
		let n = this.keyMap.get(e);
		return n ? n.prevKey : null;
	}
	getKeyAfter(e) {
		let n = this.keyMap.get(e);
		return n ? n.nextKey : null;
	}
	getFirstKey() {
		var e;
		return (e = Ja(this.body.childNodes)) === null || e === void 0
			? void 0
			: e.key;
	}
	getLastKey() {
		var e;
		return (e = Xa(this.body.childNodes)) === null || e === void 0
			? void 0
			: e.key;
	}
	getItem(e) {
		return this.keyMap.get(e);
	}
	at(e) {
		const n = [...this.getKeys()];
		return this.getItem(n[e]);
	}
	getChildren(e) {
		return e === this.body.key
			? this.body.childNodes
			: super.getChildren(e);
	}
	getTextValue(e) {
		let n = this.getItem(e);
		if (!n) return "";
		if (n.textValue) return n.textValue;
		let r = this.rowHeaderColumnKeys;
		if (r) {
			let i = [];
			for (let o of n.childNodes) {
				let s = this.columns[o.index];
				if (
					(r.has(s.key) && o.textValue && i.push(o.textValue),
					i.length === r.size)
				)
					break;
			}
			return i.join(" ");
		}
		return "";
	}
	constructor(e, n, r) {
		let i = new Set(),
			o,
			s = [];
		if (r != null && r.showSelectionCheckboxes) {
			let d = {
				type: "column",
				key: GN,
				value: null,
				textValue: "",
				level: 0,
				index: r != null && r.showDragButtons ? 1 : 0,
				hasChildNodes: !1,
				rendered: null,
				childNodes: [],
				props: { isSelectionCell: !0 },
			};
			s.unshift(d);
		}
		if (r != null && r.showDragButtons) {
			let d = {
				type: "column",
				key: fw,
				value: null,
				textValue: "",
				level: 0,
				index: 0,
				hasChildNodes: !1,
				rendered: null,
				childNodes: [],
				props: { isDragButtonCell: !0 },
			};
			s.unshift(d);
		}
		let a = [],
			l = new Map(),
			u = (d) => {
				switch (d.type) {
					case "body":
						o = d;
						break;
					case "column":
						l.set(d.key, d),
							d.hasChildNodes ||
								(s.push(d),
								d.props.isRowHeader && i.add(d.key));
						break;
					case "item":
						a.push(d);
						return;
				}
				for (let f of d.childNodes) u(f);
			};
		for (let d of e) u(d);
		let c = fie(l, s);
		c.forEach((d, f) => a.splice(f, 0, d)),
			super({
				columnCount: s.length,
				items: a,
				visitNode: (d) => ((d.column = s[d.index]), d),
			}),
			(this._size = 0),
			(this.columns = s),
			(this.rowHeaderColumnKeys = i),
			(this.body = o),
			(this.headerRows = c),
			(this._size = [...o.childNodes].length),
			this.rowHeaderColumnKeys.size === 0 &&
				this.rowHeaderColumnKeys.add(
					this.columns.find((d) => {
						var f, h;
						return (
							!(
								!((f = d.props) === null || f === void 0) &&
								f.isDragButtonCell
							) &&
							!(
								!((h = d.props) === null || h === void 0) &&
								h.isSelectionCell
							)
						);
					}).key,
				);
	}
}
const pie = { ascending: "descending", descending: "ascending" };
function mie(t) {
	let [e, n] = E.useState(!1),
		{
			selectionMode: r = "none",
			showSelectionCheckboxes: i,
			showDragButtons: o,
		} = t,
		s = E.useMemo(
			() => ({
				showSelectionCheckboxes: i && r !== "none",
				showDragButtons: o,
				selectionMode: r,
				columns: [],
			}),
			[t.children, i, r, o],
		),
		a = xD(
			t,
			E.useCallback((c) => new hie(c, null, s), [s]),
			s,
		),
		{ disabledKeys: l, selectionManager: u } = cie({
			...t,
			collection: a,
			disabledBehavior: t.disabledBehavior || "selection",
		});
	return {
		collection: a,
		disabledKeys: l,
		selectionManager: u,
		showSelectionCheckboxes: t.showSelectionCheckboxes || !1,
		sortDescriptor: t.sortDescriptor,
		isKeyboardNavigationDisabled: a.size === 0 || e,
		setKeyboardNavigationDisabled: n,
		sort(c, d) {
			var f;
			t.onSortChange({
				column: c,
				direction:
					d ??
					(((f = t.sortDescriptor) === null || f === void 0
						? void 0
						: f.column) === c
						? pie[t.sortDescriptor.direction]
						: "ascending"),
			});
		},
	};
}
function YN(t) {
	return null;
}
YN.getCollectionNode = function* (e, n) {
	let { children: r, columns: i } = e;
	if (((n.columns = []), typeof r == "function")) {
		if (!i)
			throw new Error(
				"props.children was a function but props.columns is missing",
			);
		for (let o of i) yield { type: "column", value: o, renderer: r };
	} else {
		let o = [];
		le.Children.forEach(r, (s) => {
			o.push({ type: "column", element: s });
		}),
			yield* o;
	}
};
let gie = YN;
function JN(t) {
	return null;
}
JN.getCollectionNode = function* (e) {
	let { children: n, items: r } = e;
	yield {
		type: "body",
		hasChildNodes: !0,
		props: e,
		*childNodes() {
			if (typeof n == "function") {
				if (!r)
					throw new Error(
						"props.children was a function but props.items is missing",
					);
				for (let i of r) yield { type: "item", value: i, renderer: n };
			} else {
				let i = [];
				le.Children.forEach(n, (o) => {
					i.push({ type: "item", element: o });
				}),
					yield* i;
			}
		},
	};
};
let bie = JN;
function XN(t) {
	return null;
}
XN.getCollectionNode = function* (e, n) {
	let { title: r, children: i, childColumns: o } = e,
		s = r || i,
		a = e.textValue || (typeof s == "string" ? s : "") || e["aria-label"],
		l = yield {
			type: "column",
			hasChildNodes: !!o || (r && le.Children.count(i) > 0),
			rendered: s,
			textValue: a,
			props: e,
			*childNodes() {
				if (o) for (let c of o) yield { type: "column", value: c };
				else if (r) {
					let c = [];
					le.Children.forEach(i, (d) => {
						c.push({ type: "column", element: d });
					}),
						yield* c;
				}
			},
			shouldInvalidate(c) {
				return u(c), !1;
			},
		},
		u = (c) => {
			for (let d of l) d.hasChildNodes || c.columns.push(d);
		};
	u(n);
};
let vie = XN;
function hw(t) {
	return null;
}
hw.getCollectionNode = function* (e, n) {
	let { children: r, textValue: i, UNSTABLE_childItems: o } = e;
	yield {
		type: "item",
		props: e,
		textValue: i,
		"aria-label": e["aria-label"],
		hasChildNodes: !0,
		*childNodes() {
			if (
				(n.showDragButtons &&
					(yield {
						type: "cell",
						key: "header-drag",
						props: { isDragButtonCell: !0 },
					}),
				n.showSelectionCheckboxes &&
					n.selectionMode !== "none" &&
					(yield {
						type: "cell",
						key: "header",
						props: { isSelectionCell: !0 },
					}),
				typeof r == "function")
			) {
				for (let s of n.columns)
					yield { type: "cell", element: r(s.key), key: s.key };
				if (o) for (let s of o) yield { type: "item", value: s };
			} else {
				let s = [],
					a = [];
				if (
					(le.Children.forEach(r, (l) => {
						if (l.type === hw) {
							if (s.length < n.columns.length)
								throw new Error(
									"All of a Row's child Cells must be positioned before any child Rows.",
								);
							a.push({ type: "item", element: l });
						} else s.push({ type: "cell", element: l });
					}),
					s.length !== n.columns.length)
				)
					throw new Error(
						`Cell count must match column count. Found ${s.length} cells and ${n.columns.length} columns.`,
					);
				yield* s, yield* a;
			}
		},
		shouldInvalidate(s) {
			return (
				s.columns.length !== n.columns.length ||
				s.columns.some((a, l) => a.key !== n.columns[l].key) ||
				s.showSelectionCheckboxes !== n.showSelectionCheckboxes ||
				s.showDragButtons !== n.showDragButtons ||
				s.selectionMode !== n.selectionMode
			);
		},
	};
};
let M4 = hw;
function ZN(t) {
	return null;
}
ZN.getCollectionNode = function* (e) {
	let { children: n } = e,
		r =
			e.textValue ||
			(typeof n == "string" ? n : "") ||
			e["aria-label"] ||
			"";
	yield {
		type: "cell",
		props: e,
		rendered: n,
		textValue: r,
		"aria-label": e["aria-label"],
		hasChildNodes: !1,
	};
};
let j4 = ZN,
	yie = !1;
function vv() {
	return yie;
}
function pw(t) {
	return tb() ? t.altKey : t.ctrlKey;
}
function Af(t) {
	return Ss() ? t.metaKey : t.ctrlKey;
}
const xie = 1e3;
function QN(t) {
	let { keyboardDelegate: e, selectionManager: n, onTypeSelect: r } = t,
		i = E.useRef({ search: "", timeout: null }).current,
		o = (s) => {
			let a = kie(s.key);
			if (
				!a ||
				s.ctrlKey ||
				s.metaKey ||
				!s.currentTarget.contains(s.target)
			)
				return;
			a === " " &&
				i.search.trim().length > 0 &&
				(s.preventDefault(),
				"continuePropagation" in s || s.stopPropagation()),
				(i.search += a);
			let l = e.getKeyForSearch(i.search, n.focusedKey);
			l == null && (l = e.getKeyForSearch(i.search)),
				l != null && (n.setFocusedKey(l), r && r(l)),
				clearTimeout(i.timeout),
				(i.timeout = setTimeout(() => {
					i.search = "";
				}, xie));
		};
	return {
		typeSelectProps: { onKeyDownCapture: e.getKeyForSearch ? o : null },
	};
}
function kie(t) {
	return t.length === 1 || !/^[A-Z]/i.test(t) ? t : "";
}
function $x(t) {
	let {
			selectionManager: e,
			keyboardDelegate: n,
			ref: r,
			autoFocus: i = !1,
			shouldFocusWrap: o = !1,
			disallowEmptySelection: s = !1,
			disallowSelectAll: a = !1,
			selectOnFocus: l = e.selectionBehavior === "replace",
			disallowTypeAhead: u = !1,
			shouldUseVirtualFocus: c,
			allowsTabNavigation: d = !1,
			isVirtualized: f,
			scrollRef: h = r,
			linkBehavior: p = "action",
		} = t,
		{ direction: g } = Vt(),
		v = Kd(),
		b = (A) => {
			if (
				(A.altKey && A.key === "Tab" && A.preventDefault(),
				!r.current.contains(A.target))
			)
				return;
			const T = (M, G) => {
				if (M != null) {
					if (e.isLink(M) && p === "selection" && l && !pw(A)) {
						nl.flushSync(() => {
							e.setFocusedKey(M, G);
						});
						let H = h.current.querySelector(
								`[data-key="${CSS.escape(M.toString())}"]`,
							),
							P = e.getItemProps(M);
						v.open(H, A, P.href, P.routerOptions);
						return;
					}
					if (
						(e.setFocusedKey(M, G), e.isLink(M) && p === "override")
					)
						return;
					A.shiftKey && e.selectionMode === "multiple"
						? e.extendSelection(M)
						: l && !pw(A) && e.replaceSelection(M);
				}
			};
			switch (A.key) {
				case "ArrowDown":
					if (n.getKeyBelow) {
						var I, F;
						A.preventDefault();
						let M =
							e.focusedKey != null
								? n.getKeyBelow(e.focusedKey)
								: (I = n.getFirstKey) === null || I === void 0
									? void 0
									: I.call(n);
						M == null &&
							o &&
							(M =
								(F = n.getFirstKey) === null || F === void 0
									? void 0
									: F.call(n, e.focusedKey)),
							T(M);
					}
					break;
				case "ArrowUp":
					if (n.getKeyAbove) {
						var N, O;
						A.preventDefault();
						let M =
							e.focusedKey != null
								? n.getKeyAbove(e.focusedKey)
								: (N = n.getLastKey) === null || N === void 0
									? void 0
									: N.call(n);
						M == null &&
							o &&
							(M =
								(O = n.getLastKey) === null || O === void 0
									? void 0
									: O.call(n, e.focusedKey)),
							T(M);
					}
					break;
				case "ArrowLeft":
					if (n.getKeyLeftOf) {
						var _, j;
						A.preventDefault();
						let M = n.getKeyLeftOf(e.focusedKey);
						M == null &&
							o &&
							(M =
								g === "rtl"
									? (_ = n.getFirstKey) === null ||
										_ === void 0
										? void 0
										: _.call(n, e.focusedKey)
									: (j = n.getLastKey) === null ||
										  j === void 0
										? void 0
										: j.call(n, e.focusedKey)),
							T(M, g === "rtl" ? "first" : "last");
					}
					break;
				case "ArrowRight":
					if (n.getKeyRightOf) {
						var V, K;
						A.preventDefault();
						let M = n.getKeyRightOf(e.focusedKey);
						M == null &&
							o &&
							(M =
								g === "rtl"
									? (V = n.getLastKey) === null ||
										V === void 0
										? void 0
										: V.call(n, e.focusedKey)
									: (K = n.getFirstKey) === null ||
										  K === void 0
										? void 0
										: K.call(n, e.focusedKey)),
							T(M, g === "rtl" ? "last" : "first");
					}
					break;
				case "Home":
					if (n.getFirstKey) {
						A.preventDefault();
						let M = n.getFirstKey(e.focusedKey, Af(A));
						e.setFocusedKey(M),
							Af(A) &&
							A.shiftKey &&
							e.selectionMode === "multiple"
								? e.extendSelection(M)
								: l && e.replaceSelection(M);
					}
					break;
				case "End":
					if (n.getLastKey) {
						A.preventDefault();
						let M = n.getLastKey(e.focusedKey, Af(A));
						e.setFocusedKey(M),
							Af(A) &&
							A.shiftKey &&
							e.selectionMode === "multiple"
								? e.extendSelection(M)
								: l && e.replaceSelection(M);
					}
					break;
				case "PageDown":
					if (n.getKeyPageBelow) {
						A.preventDefault();
						let M = n.getKeyPageBelow(e.focusedKey);
						T(M);
					}
					break;
				case "PageUp":
					if (n.getKeyPageAbove) {
						A.preventDefault();
						let M = n.getKeyPageAbove(e.focusedKey);
						T(M);
					}
					break;
				case "a":
					Af(A) &&
						e.selectionMode === "multiple" &&
						a !== !0 &&
						(A.preventDefault(), e.selectAll());
					break;
				case "Escape":
					!s &&
						e.selectedKeys.size !== 0 &&
						(A.stopPropagation(),
						A.preventDefault(),
						e.clearSelection());
					break;
				case "Tab":
					if (!d) {
						if (A.shiftKey) r.current.focus();
						else {
							let M = rr(r.current, { tabbable: !0 }),
								G,
								H;
							do (H = M.lastChild()), H && (G = H);
							while (H);
							G && !G.contains(document.activeElement) && io(G);
						}
						break;
					}
			}
		},
		y = E.useRef({ top: 0, left: 0 });
	Lm(
		h,
		"scroll",
		f
			? null
			: () => {
					y.current = {
						top: h.current.scrollTop,
						left: h.current.scrollLeft,
					};
				},
	);
	let x = (A) => {
			if (e.isFocused) {
				A.currentTarget.contains(A.target) || e.setFocused(!1);
				return;
			}
			if (A.currentTarget.contains(A.target)) {
				if ((e.setFocused(!0), e.focusedKey == null)) {
					let F = (O) => {
							O != null &&
								(e.setFocusedKey(O),
								l && e.replaceSelection(O));
						},
						N = A.relatedTarget;
					var T, I;
					N &&
					A.currentTarget.compareDocumentPosition(N) &
						Node.DOCUMENT_POSITION_FOLLOWING
						? F(
								(T = e.lastSelectedKey) !== null && T !== void 0
									? T
									: n.getLastKey(),
							)
						: F(
								(I = e.firstSelectedKey) !== null &&
									I !== void 0
									? I
									: n.getFirstKey(),
							);
				} else
					f ||
						((h.current.scrollTop = y.current.top),
						(h.current.scrollLeft = y.current.left));
				if (e.focusedKey != null) {
					let F = h.current.querySelector(
						`[data-key="${CSS.escape(e.focusedKey.toString())}"]`,
					);
					F &&
						(F.contains(document.activeElement) || io(F),
						gl() === "keyboard" &&
							ui(F, { containingElement: r.current }));
				}
			}
		},
		C = (A) => {
			A.currentTarget.contains(A.relatedTarget) || e.setFocused(!1);
		};
	const k = E.useRef(i);
	E.useEffect(() => {
		if (k.current) {
			let A = null;
			i === "first" && (A = n.getFirstKey()),
				i === "last" && (A = n.getLastKey());
			let T = e.selectedKeys;
			if (T.size) {
				for (let I of T)
					if (e.canSelectItem(I)) {
						A = I;
						break;
					}
			}
			e.setFocused(!0),
				e.setFocusedKey(A),
				A == null && !c && on(r.current);
		}
	}, []);
	let w = E.useRef(e.focusedKey);
	E.useEffect(() => {
		if (
			e.isFocused &&
			e.focusedKey != null &&
			(e.focusedKey !== w.current || k.current) &&
			h != null &&
			h.current
		) {
			let A = gl(),
				T = r.current.querySelector(
					`[data-key="${CSS.escape(e.focusedKey.toString())}"]`,
				);
			if (!T) return;
			(A === "keyboard" || k.current) &&
				(JE(h.current, T),
				A !== "virtual" && ui(T, { containingElement: r.current }));
		}
		!c &&
			e.isFocused &&
			e.focusedKey == null &&
			w.current != null &&
			on(r.current),
			(w.current = e.focusedKey),
			(k.current = !1);
	}),
		Lm(r, "react-aria-focus-scope-restore", (A) => {
			A.preventDefault(), e.setFocused(!0);
		});
	let D = {
			onKeyDown: b,
			onFocus: x,
			onBlur: C,
			onMouseDown(A) {
				h.current === A.target && A.preventDefault();
			},
		},
		{ typeSelectProps: S } = QN({
			keyboardDelegate: n,
			selectionManager: e,
		});
	u || (D = xe(S, D));
	let $;
	return (
		c || ($ = e.focusedKey == null ? 0 : -1),
		{ collectionProps: { ...D, tabIndex: $ } }
	);
}
function f0(t) {
	let {
			selectionManager: e,
			key: n,
			ref: r,
			shouldSelectOnPressUp: i,
			shouldUseVirtualFocus: o,
			focus: s,
			isDisabled: a,
			onAction: l,
			allowsDifferentPressOrigin: u,
			linkBehavior: c = "action",
		} = t,
		d = Kd(),
		f = (j) => {
			if (j.pointerType === "keyboard" && pw(j)) e.toggleSelection(n);
			else {
				if (e.selectionMode === "none") return;
				if (e.isLink(n)) {
					if (c === "selection") {
						let V = e.getItemProps(n);
						d.open(r.current, j, V.href, V.routerOptions),
							e.setSelectedKeys(e.selectedKeys);
						return;
					} else if (c === "override" || c === "none") return;
				}
				e.selectionMode === "single"
					? e.isSelected(n) && !e.disallowEmptySelection
						? e.toggleSelection(n)
						: e.replaceSelection(n)
					: j && j.shiftKey
						? e.extendSelection(n)
						: e.selectionBehavior === "toggle" ||
							  (j &&
									(Af(j) ||
										j.pointerType === "touch" ||
										j.pointerType === "virtual"))
							? e.toggleSelection(n)
							: e.replaceSelection(n);
			}
		};
	E.useEffect(() => {
		n === e.focusedKey &&
			e.isFocused &&
			!o &&
			(s ? s() : document.activeElement !== r.current && on(r.current));
	}, [r, n, e.focusedKey, e.childFocusStrategy, e.isFocused, o]),
		(a = a || e.isDisabled(n));
	let h = {};
	!o && !a
		? (h = {
				tabIndex: n === e.focusedKey ? 0 : -1,
				onFocus(j) {
					j.target === r.current && e.setFocusedKey(n);
				},
			})
		: a &&
			(h.onMouseDown = (j) => {
				j.preventDefault();
			});
	let p = e.isLink(n) && c === "override",
		g = e.isLink(n) && c !== "selection" && c !== "none",
		v = !a && e.canSelectItem(n) && !p,
		b = (l || g) && !a,
		y = b && (e.selectionBehavior === "replace" ? !v : !v || e.isEmpty),
		x = b && v && e.selectionBehavior === "replace",
		C = y || x,
		k = E.useRef(null),
		w = C && v,
		D = E.useRef(!1),
		S = E.useRef(!1),
		$ = (j) => {
			if ((l && l(), g)) {
				let V = e.getItemProps(n);
				d.open(r.current, j, V.href, V.routerOptions);
			}
		},
		A = {};
	i
		? ((A.onPressStart = (j) => {
				(k.current = j.pointerType),
					(D.current = w),
					j.pointerType === "keyboard" && (!C || G6()) && f(j);
			}),
			u
				? ((A.onPressUp = y
						? null
						: (j) => {
								j.pointerType !== "keyboard" && v && f(j);
							}),
					(A.onPress = y ? $ : null))
				: (A.onPress = (j) => {
						if (y || (x && j.pointerType !== "mouse")) {
							if (j.pointerType === "keyboard" && !q6()) return;
							$(j);
						} else j.pointerType !== "keyboard" && v && f(j);
					}))
		: ((A.onPressStart = (j) => {
				(k.current = j.pointerType),
					(D.current = w),
					(S.current = y),
					v &&
						((j.pointerType === "mouse" && !y) ||
							(j.pointerType === "keyboard" && (!b || G6()))) &&
						f(j);
			}),
			(A.onPress = (j) => {
				(j.pointerType === "touch" ||
					j.pointerType === "pen" ||
					j.pointerType === "virtual" ||
					(j.pointerType === "keyboard" && C && q6()) ||
					(j.pointerType === "mouse" && S.current)) &&
					(C ? $(j) : v && f(j));
			})),
		(h["data-key"] = n),
		(A.preventFocusOnPress = o);
	let { pressProps: T, isPressed: I } = zi(A),
		F = x
			? (j) => {
					k.current === "mouse" &&
						(j.stopPropagation(), j.preventDefault(), $(j));
				}
			: void 0,
		{ longPressProps: N } = E9({
			isDisabled: !w,
			onLongPress(j) {
				j.pointerType === "touch" &&
					(f(j), e.setSelectionBehavior("toggle"));
			},
		}),
		O = (j) => {
			k.current === "touch" && D.current && j.preventDefault();
		},
		_ = e.isLink(n)
			? (j) => {
					_u.isOpening || j.preventDefault();
				}
			: void 0;
	return {
		itemProps: xe(h, v || y ? T : {}, w ? N : {}, {
			onDoubleClick: F,
			onDragStartCapture: O,
			onClick: _,
		}),
		isPressed: I,
		isSelected: e.isSelected(n),
		isFocused: e.isFocused && e.focusedKey === n,
		isDisabled: a,
		allowsSelection: v,
		hasAction: C,
	};
}
function q6() {
	let t = window.event;
	return (t == null ? void 0 : t.key) === "Enter";
}
function G6() {
	let t = window.event;
	return (
		(t == null ? void 0 : t.key) === " " ||
		(t == null ? void 0 : t.code) === "Space"
	);
}
class mw {
	getItemRect(e) {
		let n = this.ref.current,
			r =
				e != null
					? n.querySelector(
							`[data-key="${CSS.escape(e.toString())}"]`,
						)
					: null;
		if (!r) return null;
		let i = n.getBoundingClientRect(),
			o = r.getBoundingClientRect();
		return {
			x: o.left - i.left + n.scrollLeft,
			y: o.top - i.top + n.scrollTop,
			width: o.width,
			height: o.height,
		};
	}
	getContentSize() {
		let e = this.ref.current;
		return { width: e.scrollWidth, height: e.scrollHeight };
	}
	getVisibleRect() {
		let e = this.ref.current;
		return {
			x: e.scrollLeft,
			y: e.scrollTop,
			width: e.offsetWidth,
			height: e.offsetHeight,
		};
	}
	constructor(e) {
		this.ref = e;
	}
}
class Xh {
	isDisabled(e) {
		var n;
		return (
			this.disabledBehavior === "all" &&
			(((n = e.props) === null || n === void 0 ? void 0 : n.isDisabled) ||
				this.disabledKeys.has(e.key))
		);
	}
	getNextKey(e) {
		for (e = this.collection.getKeyAfter(e); e != null; ) {
			let n = this.collection.getItem(e);
			if (n.type === "item" && !this.isDisabled(n)) return e;
			e = this.collection.getKeyAfter(e);
		}
		return null;
	}
	getPreviousKey(e) {
		for (e = this.collection.getKeyBefore(e); e != null; ) {
			let n = this.collection.getItem(e);
			if (n.type === "item" && !this.isDisabled(n)) return e;
			e = this.collection.getKeyBefore(e);
		}
		return null;
	}
	findKey(e, n, r) {
		let i = this.layoutDelegate.getItemRect(e);
		if (!i) return null;
		let o = i;
		do (e = n(e)), (i = this.layoutDelegate.getItemRect(e));
		while (i && r(o, i));
		return e;
	}
	isSameRow(e, n) {
		return e.y === n.y || e.x !== n.x;
	}
	isSameColumn(e, n) {
		return e.x === n.x || e.y !== n.y;
	}
	getKeyBelow(e) {
		return this.layout === "grid" && this.orientation === "vertical"
			? this.findKey(e, (n) => this.getNextKey(n), this.isSameRow)
			: this.getNextKey(e);
	}
	getKeyAbove(e) {
		return this.layout === "grid" && this.orientation === "vertical"
			? this.findKey(e, (n) => this.getPreviousKey(n), this.isSameRow)
			: this.getPreviousKey(e);
	}
	getNextColumn(e, n) {
		return n ? this.getPreviousKey(e) : this.getNextKey(e);
	}
	getKeyRightOf(e) {
		return this.layout === "grid"
			? this.orientation === "vertical"
				? this.getNextColumn(e, this.direction === "rtl")
				: this.findKey(
						e,
						(n) => this.getNextColumn(n, this.direction === "rtl"),
						this.isSameColumn,
					)
			: this.orientation === "horizontal"
				? this.getNextColumn(e, this.direction === "rtl")
				: null;
	}
	getKeyLeftOf(e) {
		return this.layout === "grid"
			? this.orientation === "vertical"
				? this.getNextColumn(e, this.direction === "ltr")
				: this.findKey(
						e,
						(n) => this.getNextColumn(n, this.direction === "ltr"),
						this.isSameColumn,
					)
			: this.orientation === "horizontal"
				? this.getNextColumn(e, this.direction === "ltr")
				: null;
	}
	getFirstKey() {
		let e = this.collection.getFirstKey();
		for (; e != null; ) {
			let n = this.collection.getItem(e);
			if ((n == null ? void 0 : n.type) === "item" && !this.isDisabled(n))
				return e;
			e = this.collection.getKeyAfter(e);
		}
		return null;
	}
	getLastKey() {
		let e = this.collection.getLastKey();
		for (; e != null; ) {
			let n = this.collection.getItem(e);
			if (n.type === "item" && !this.isDisabled(n)) return e;
			e = this.collection.getKeyBefore(e);
		}
		return null;
	}
	getKeyPageAbove(e) {
		let n = this.ref.current,
			r = this.layoutDelegate.getItemRect(e);
		if (!r) return null;
		if (!bh(n)) return this.getFirstKey();
		if (this.orientation === "horizontal") {
			let i = Math.max(
				0,
				r.x + r.width - this.layoutDelegate.getVisibleRect().width,
			);
			for (; r && r.x > i; )
				(e = this.getKeyAbove(e)),
					(r = e == null ? null : this.layoutDelegate.getItemRect(e));
		} else {
			let i = Math.max(
				0,
				r.y + r.height - this.layoutDelegate.getVisibleRect().height,
			);
			for (; r && r.y > i; )
				(e = this.getKeyAbove(e)),
					(r = e == null ? null : this.layoutDelegate.getItemRect(e));
		}
		return e ?? this.getFirstKey();
	}
	getKeyPageBelow(e) {
		let n = this.ref.current,
			r = this.layoutDelegate.getItemRect(e);
		if (!r) return null;
		if (!bh(n)) return this.getLastKey();
		if (this.orientation === "horizontal") {
			let i = Math.min(
				this.layoutDelegate.getContentSize().width,
				r.y - r.width + this.layoutDelegate.getVisibleRect().width,
			);
			for (; r && r.x < i; )
				(e = this.getKeyBelow(e)),
					(r = e == null ? null : this.layoutDelegate.getItemRect(e));
		} else {
			let i = Math.min(
				this.layoutDelegate.getContentSize().height,
				r.y - r.height + this.layoutDelegate.getVisibleRect().height,
			);
			for (; r && r.y < i; )
				(e = this.getKeyBelow(e)),
					(r = e == null ? null : this.layoutDelegate.getItemRect(e));
		}
		return e ?? this.getLastKey();
	}
	getKeyForSearch(e, n) {
		if (!this.collator) return null;
		let r = this.collection,
			i = n || this.getFirstKey();
		for (; i != null; ) {
			let o = r.getItem(i),
				s = o.textValue.slice(0, e.length);
			if (o.textValue && this.collator.compare(s, e) === 0) return i;
			i = this.getKeyBelow(i);
		}
		return null;
	}
	constructor(...e) {
		if (e.length === 1) {
			let n = e[0];
			(this.collection = n.collection),
				(this.ref = n.ref),
				(this.collator = n.collator),
				(this.disabledKeys = n.disabledKeys || new Set()),
				(this.disabledBehavior = n.disabledBehavior || "all"),
				(this.orientation = n.orientation || "vertical"),
				(this.direction = n.direction),
				(this.layout = n.layout || "stack"),
				(this.layoutDelegate = n.layoutDelegate || new mw(n.ref));
		} else
			(this.collection = e[0]),
				(this.disabledKeys = e[1]),
				(this.ref = e[2]),
				(this.collator = e[3]),
				(this.layout = "stack"),
				(this.orientation = "vertical"),
				(this.disabledBehavior = "all"),
				(this.layoutDelegate = new mw(this.ref));
		this.layout === "stack" &&
			this.orientation === "vertical" &&
			((this.getKeyLeftOf = void 0), (this.getKeyRightOf = void 0));
	}
}
function ED(t) {
	let {
			selectionManager: e,
			collection: n,
			disabledKeys: r,
			ref: i,
			keyboardDelegate: o,
			layoutDelegate: s,
		} = t,
		a = a0({ usage: "search", sensitivity: "base" }),
		l = e.disabledBehavior,
		u = E.useMemo(
			() =>
				o ||
				new Xh({
					collection: n,
					disabledKeys: r,
					disabledBehavior: l,
					ref: i,
					collator: a,
					layoutDelegate: s,
				}),
			[o, s, n, r, i, a, l],
		),
		{ collectionProps: c } = $x({
			...t,
			ref: i,
			selectionManager: e,
			keyboardDelegate: u,
		});
	return { listProps: c };
}
const DD = new WeakMap();
function gw(t) {
	return typeof t == "string" ? t.replace(/\s*/g, "") : "" + t;
}
function eR(t, e) {
	let n = DD.get(t);
	if (!n) throw new Error("Unknown grid");
	return `${n}-${gw(e)}`;
}
function tR(t, e, n) {
	let r = DD.get(t);
	if (!r) throw new Error("Unknown grid");
	return `${r}-${gw(e)}-${gw(n)}`;
}
function nR(t, e) {
	return [...t.collection.rowHeaderColumnKeys]
		.map((n) => tR(t, e, n))
		.join(" ");
}
var rR = {};
rR = {
	ascending: "تصاعدي",
	ascendingSort: (t) => `ترتيب حسب العمود ${t.columnName} بترتيب تصاعدي`,
	columnSize: (t) => `${t.value} بالبكسل`,
	descending: "تنازلي",
	descendingSort: (t) => `ترتيب حسب العمود ${t.columnName} بترتيب تنازلي`,
	resizerDescription: "اضغط على مفتاح Enter لبدء تغيير الحجم",
	select: "تحديد",
	selectAll: "تحديد الكل",
	sortable: "عمود قابل للترتيب",
};
var iR = {};
iR = {
	ascending: "възходящ",
	ascendingSort: (t) =>
		`сортирано по колона ${t.columnName} във възходящ ред`,
	columnSize: (t) => `${t.value} пиксела`,
	descending: "низходящ",
	descendingSort: (t) => `сортирано по колона ${t.columnName} в низходящ ред`,
	resizerDescription: "Натиснете „Enter“, за да започнете да преоразмерявате",
	select: "Изберете",
	selectAll: "Изберете всичко",
	sortable: "сортираща колона",
};
var oR = {};
oR = {
	ascending: "vzestupně",
	ascendingSort: (t) => `řazeno vzestupně podle sloupce ${t.columnName}`,
	columnSize: (t) => `${t.value} pixelů`,
	descending: "sestupně",
	descendingSort: (t) => `řazeno sestupně podle sloupce ${t.columnName}`,
	resizerDescription: "Stisknutím klávesy Enter začnete měnit velikost",
	select: "Vybrat",
	selectAll: "Vybrat vše",
	sortable: "sloupec s možností řazení",
};
var sR = {};
sR = {
	ascending: "stigende",
	ascendingSort: (t) =>
		`sorteret efter kolonne ${t.columnName} i stigende rækkefølge`,
	columnSize: (t) => `${t.value} pixels`,
	descending: "faldende",
	descendingSort: (t) =>
		`sorteret efter kolonne ${t.columnName} i faldende rækkefølge`,
	resizerDescription: "Tryk på Enter for at ændre størrelse",
	select: "Vælg",
	selectAll: "Vælg alle",
	sortable: "sorterbar kolonne",
};
var aR = {};
aR = {
	ascending: "aufsteigend",
	ascendingSort: (t) =>
		`sortiert nach Spalte ${t.columnName} in aufsteigender Reihenfolge`,
	columnSize: (t) => `${t.value} Pixel`,
	descending: "absteigend",
	descendingSort: (t) =>
		`sortiert nach Spalte ${t.columnName} in absteigender Reihenfolge`,
	resizerDescription: "Eingabetaste zum Starten der Größenänderung drücken",
	select: "Auswählen",
	selectAll: "Alles auswählen",
	sortable: "sortierbare Spalte",
};
var lR = {};
lR = {
	ascending: "αύξουσα",
	ascendingSort: (t) => `διαλογή ανά στήλη ${t.columnName} σε αύξουσα σειρά`,
	columnSize: (t) => `${t.value} pixel`,
	descending: "φθίνουσα",
	descendingSort: (t) =>
		`διαλογή ανά στήλη ${t.columnName} σε φθίνουσα σειρά`,
	resizerDescription: "Πατήστε Enter για έναρξη της αλλαγής μεγέθους",
	select: "Επιλογή",
	selectAll: "Επιλογή όλων",
	sortable: "Στήλη διαλογής",
};
var uR = {};
uR = {
	select: "Select",
	selectAll: "Select All",
	sortable: "sortable column",
	ascending: "ascending",
	descending: "descending",
	ascendingSort: (t) => `sorted by column ${t.columnName} in ascending order`,
	descendingSort: (t) =>
		`sorted by column ${t.columnName} in descending order`,
	columnSize: (t) => `${t.value} pixels`,
	resizerDescription: "Press Enter to start resizing",
};
var cR = {};
cR = {
	ascending: "de subida",
	ascendingSort: (t) =>
		`ordenado por columna ${t.columnName} en orden de subida`,
	columnSize: (t) => `${t.value} píxeles`,
	descending: "de bajada",
	descendingSort: (t) =>
		`ordenado por columna ${t.columnName} en orden de bajada`,
	resizerDescription: "Pulse Intro para empezar a redimensionar",
	select: "Seleccionar",
	selectAll: "Seleccionar todos",
	sortable: "columna ordenable",
};
var dR = {};
dR = {
	ascending: "tõusev järjestus",
	ascendingSort: (t) =>
		`sorditud veeru järgi ${t.columnName} tõusvas järjestuses`,
	columnSize: (t) => `${t.value} pikslit`,
	descending: "laskuv järjestus",
	descendingSort: (t) =>
		`sorditud veeru järgi ${t.columnName} laskuvas järjestuses`,
	resizerDescription: "Suuruse muutmise alustamiseks vajutage klahvi Enter",
	select: "Vali",
	selectAll: "Vali kõik",
	sortable: "sorditav veerg",
};
var fR = {};
fR = {
	ascending: "nouseva",
	ascendingSort: (t) =>
		`lajiteltu sarakkeen ${t.columnName} mukaan nousevassa järjestyksessä`,
	columnSize: (t) => `${t.value} pikseliä`,
	descending: "laskeva",
	descendingSort: (t) =>
		`lajiteltu sarakkeen ${t.columnName} mukaan laskevassa järjestyksessä`,
	resizerDescription: "Aloita koon muutos painamalla Enter-näppäintä",
	select: "Valitse",
	selectAll: "Valitse kaikki",
	sortable: "lajiteltava sarake",
};
var hR = {};
hR = {
	ascending: "croissant",
	ascendingSort: (t) =>
		`trié en fonction de la colonne ${t.columnName} par ordre croissant`,
	columnSize: (t) => `${t.value} pixels`,
	descending: "décroissant",
	descendingSort: (t) =>
		`trié en fonction de la colonne ${t.columnName} par ordre décroissant`,
	resizerDescription:
		"Appuyez sur Entrée pour commencer le redimensionnement.",
	select: "Sélectionner",
	selectAll: "Sélectionner tout",
	sortable: "colonne triable",
};
var pR = {};
pR = {
	ascending: "עולה",
	ascendingSort: (t) => `מוין לפי עמודה ${t.columnName} בסדר עולה`,
	columnSize: (t) => `${t.value} פיקסלים`,
	descending: "יורד",
	descendingSort: (t) => `מוין לפי עמודה ${t.columnName} בסדר יורד`,
	resizerDescription: "הקש Enter כדי לשנות את הגודל",
	select: "בחר",
	selectAll: "בחר הכול",
	sortable: "עמודה שניתן למיין",
};
var mR = {};
mR = {
	ascending: "rastući",
	ascendingSort: (t) =>
		`razvrstano po stupcima ${t.columnName} rastućem redoslijedom`,
	columnSize: (t) => `${t.value} piksela`,
	descending: "padajući",
	descendingSort: (t) =>
		`razvrstano po stupcima ${t.columnName} padajućim redoslijedom`,
	resizerDescription: "Pritisnite Enter da biste započeli promenu veličine",
	select: "Odaberite",
	selectAll: "Odaberite sve",
	sortable: "stupac koji se može razvrstati",
};
var gR = {};
gR = {
	ascending: "növekvő",
	ascendingSort: (t) =>
		`rendezve a(z) ${t.columnName} oszlop szerint, növekvő sorrendben`,
	columnSize: (t) => `${t.value} képpont`,
	descending: "csökkenő",
	descendingSort: (t) =>
		`rendezve a(z) ${t.columnName} oszlop szerint, csökkenő sorrendben`,
	resizerDescription:
		"Nyomja le az Enter billentyűt az átméretezés megkezdéséhez",
	select: "Kijelölés",
	selectAll: "Összes kijelölése",
	sortable: "rendezendő oszlop",
};
var bR = {};
bR = {
	ascending: "crescente",
	ascendingSort: (t) =>
		`in ordine crescente in base alla colonna ${t.columnName}`,
	columnSize: (t) => `${t.value} pixel`,
	descending: "decrescente",
	descendingSort: (t) =>
		`in ordine decrescente in base alla colonna ${t.columnName}`,
	resizerDescription: "Premi Invio per iniziare a ridimensionare",
	select: "Seleziona",
	selectAll: "Seleziona tutto",
	sortable: "colonna ordinabile",
};
var vR = {};
vR = {
	ascending: "昇順",
	ascendingSort: (t) => `列 ${t.columnName} を昇順で並べ替え`,
	columnSize: (t) => `${t.value} ピクセル`,
	descending: "降順",
	descendingSort: (t) => `列 ${t.columnName} を降順で並べ替え`,
	resizerDescription: "Enter キーを押してサイズ変更を開始",
	select: "選択",
	selectAll: "すべて選択",
	sortable: "並べ替え可能な列",
};
var yR = {};
yR = {
	ascending: "오름차순",
	ascendingSort: (t) => `${t.columnName} 열을 기준으로 오름차순으로 정렬됨`,
	columnSize: (t) => `${t.value} 픽셀`,
	descending: "내림차순",
	descendingSort: (t) => `${t.columnName} 열을 기준으로 내림차순으로 정렬됨`,
	resizerDescription: "크기 조정을 시작하려면 Enter를 누르세요.",
	select: "선택",
	selectAll: "모두 선택",
	sortable: "정렬 가능한 열",
};
var xR = {};
xR = {
	ascending: "didėjančia tvarka",
	ascendingSort: (t) =>
		`surikiuota pagal stulpelį ${t.columnName} didėjančia tvarka`,
	columnSize: (t) => `${t.value} piks.`,
	descending: "mažėjančia tvarka",
	descendingSort: (t) =>
		`surikiuota pagal stulpelį ${t.columnName} mažėjančia tvarka`,
	resizerDescription: "Paspauskite „Enter“, kad pradėtumėte keisti dydį",
	select: "Pasirinkti",
	selectAll: "Pasirinkti viską",
	sortable: "rikiuojamas stulpelis",
};
var kR = {};
kR = {
	ascending: "augošā secībā",
	ascendingSort: (t) => `kārtots pēc kolonnas ${t.columnName} augošā secībā`,
	columnSize: (t) => `${t.value} pikseļi`,
	descending: "dilstošā secībā",
	descendingSort: (t) =>
		`kārtots pēc kolonnas ${t.columnName} dilstošā secībā`,
	resizerDescription: "Nospiediet Enter, lai sāktu izmēru mainīšanu",
	select: "Atlasīt",
	selectAll: "Atlasīt visu",
	sortable: "kārtojamā kolonna",
};
var CR = {};
CR = {
	ascending: "stigende",
	ascendingSort: (t) =>
		`sortert etter kolonne ${t.columnName} i stigende rekkefølge`,
	columnSize: (t) => `${t.value} piksler`,
	descending: "synkende",
	descendingSort: (t) =>
		`sortert etter kolonne ${t.columnName} i synkende rekkefølge`,
	resizerDescription: "Trykk på Enter for å starte størrelsesendring",
	select: "Velg",
	selectAll: "Velg alle",
	sortable: "kolonne som kan sorteres",
};
var wR = {};
wR = {
	ascending: "oplopend",
	ascendingSort: (t) =>
		`gesorteerd in oplopende volgorde in kolom ${t.columnName}`,
	columnSize: (t) => `${t.value} pixels`,
	descending: "aflopend",
	descendingSort: (t) =>
		`gesorteerd in aflopende volgorde in kolom ${t.columnName}`,
	resizerDescription: "Druk op Enter om het formaat te wijzigen",
	select: "Selecteren",
	selectAll: "Alles selecteren",
	sortable: "sorteerbare kolom",
};
var ER = {};
ER = {
	ascending: "rosnąco",
	ascendingSort: (t) =>
		`posortowano według kolumny ${t.columnName} w porządku rosnącym`,
	columnSize: (t) => `Liczba pikseli: ${t.value}`,
	descending: "malejąco",
	descendingSort: (t) =>
		`posortowano według kolumny ${t.columnName} w porządku malejącym`,
	resizerDescription: "Naciśnij Enter, aby rozpocząć zmienianie rozmiaru",
	select: "Zaznacz",
	selectAll: "Zaznacz wszystko",
	sortable: "kolumna z możliwością sortowania",
};
var DR = {};
DR = {
	ascending: "crescente",
	ascendingSort: (t) =>
		`classificado pela coluna ${t.columnName} em ordem crescente`,
	columnSize: (t) => `${t.value} pixels`,
	descending: "decrescente",
	descendingSort: (t) =>
		`classificado pela coluna ${t.columnName} em ordem decrescente`,
	resizerDescription: "Pressione Enter para começar a redimensionar",
	select: "Selecionar",
	selectAll: "Selecionar tudo",
	sortable: "coluna classificável",
};
var SR = {};
SR = {
	ascending: "ascendente",
	ascendingSort: (t) =>
		`Ordenar por coluna ${t.columnName} em ordem ascendente`,
	columnSize: (t) => `${t.value} pixels`,
	descending: "descendente",
	descendingSort: (t) =>
		`Ordenar por coluna ${t.columnName} em ordem descendente`,
	resizerDescription: "Prima Enter para iniciar o redimensionamento",
	select: "Selecionar",
	selectAll: "Selecionar tudo",
	sortable: "Coluna ordenável",
};
var AR = {};
AR = {
	ascending: "crescătoare",
	ascendingSort: (t) =>
		`sortate după coloana ${t.columnName} în ordine crescătoare`,
	columnSize: (t) => `${t.value} pixeli`,
	descending: "descrescătoare",
	descendingSort: (t) =>
		`sortate după coloana ${t.columnName} în ordine descrescătoare`,
	resizerDescription: "Apăsați pe Enter pentru a începe redimensionarea",
	select: "Selectare",
	selectAll: "Selectare totală",
	sortable: "coloană sortabilă",
};
var $R = {};
$R = {
	ascending: "возрастание",
	ascendingSort: (t) =>
		`сортировать столбец ${t.columnName} в порядке возрастания`,
	columnSize: (t) => `${t.value} пикс.`,
	descending: "убывание",
	descendingSort: (t) =>
		`сортировать столбец ${t.columnName} в порядке убывания`,
	resizerDescription: "Нажмите клавишу Enter для начала изменения размеров",
	select: "Выбрать",
	selectAll: "Выбрать все",
	sortable: "сортируемый столбец",
};
var TR = {};
TR = {
	ascending: "vzostupne",
	ascendingSort: (t) => `zoradené zostupne podľa stĺpca ${t.columnName}`,
	columnSize: (t) => `Počet pixelov: ${t.value}`,
	descending: "zostupne",
	descendingSort: (t) => `zoradené zostupne podľa stĺpca ${t.columnName}`,
	resizerDescription: "Stlačením klávesu Enter začnete zmenu veľkosti",
	select: "Vybrať",
	selectAll: "Vybrať všetko",
	sortable: "zoraditeľný stĺpec",
};
var BR = {};
BR = {
	ascending: "naraščajoče",
	ascendingSort: (t) =>
		`razvrščeno po stolpcu ${t.columnName} v naraščajočem vrstnem redu`,
	columnSize: (t) => `${t.value} slikovnih pik`,
	descending: "padajoče",
	descendingSort: (t) =>
		`razvrščeno po stolpcu ${t.columnName} v padajočem vrstnem redu`,
	resizerDescription:
		"Pritisnite tipko Enter da začnete spreminjati velikost",
	select: "Izberite",
	selectAll: "Izberite vse",
	sortable: "razvrstljivi stolpec",
};
var IR = {};
IR = {
	ascending: "rastući",
	ascendingSort: (t) =>
		`sortirano po kolonama ${t.columnName} rastućim redosledom`,
	columnSize: (t) => `${t.value} piksela`,
	descending: "padajući",
	descendingSort: (t) =>
		`sortirano po kolonama ${t.columnName} padajućim redosledom`,
	resizerDescription: "Pritisnite Enter da biste započeli promenu veličine",
	select: "Izaberite",
	selectAll: "Izaberite sve",
	sortable: "kolona koja se može sortirati",
};
var FR = {};
FR = {
	ascending: "stigande",
	ascendingSort: (t) =>
		`sorterat på kolumn ${t.columnName} i stigande ordning`,
	columnSize: (t) => `${t.value} pixlar`,
	descending: "fallande",
	descendingSort: (t) =>
		`sorterat på kolumn ${t.columnName} i fallande ordning`,
	resizerDescription: "Tryck på Retur för att börja ändra storlek",
	select: "Markera",
	selectAll: "Markera allt",
	sortable: "sorterbar kolumn",
};
var PR = {};
PR = {
	ascending: "artan sırada",
	ascendingSort: (t) => `${t.columnName} sütuna göre artan düzende sırala`,
	columnSize: (t) => `${t.value} piksel`,
	descending: "azalan sırada",
	descendingSort: (t) => `${t.columnName} sütuna göre azalan düzende sırala`,
	resizerDescription: "Yeniden boyutlandırmak için Enter'a basın",
	select: "Seç",
	selectAll: "Tümünü Seç",
	sortable: "Sıralanabilir sütun",
};
var NR = {};
NR = {
	ascending: "висхідний",
	ascendingSort: (t) =>
		`відсортовано за стовпцем ${t.columnName} у висхідному порядку`,
	columnSize: (t) => `${t.value} пікс.`,
	descending: "низхідний",
	descendingSort: (t) =>
		`відсортовано за стовпцем ${t.columnName} у низхідному порядку`,
	resizerDescription: "Натисніть Enter, щоб почати зміну розміру",
	select: "Вибрати",
	selectAll: "Вибрати все",
	sortable: "сортувальний стовпець",
};
var RR = {};
RR = {
	ascending: "升序",
	ascendingSort: (t) => `按列 ${t.columnName} 升序排序`,
	columnSize: (t) => `${t.value} 像素`,
	descending: "降序",
	descendingSort: (t) => `按列 ${t.columnName} 降序排序`,
	resizerDescription: "按“输入”键开始调整大小。",
	select: "选择",
	selectAll: "全选",
	sortable: "可排序的列",
};
var OR = {};
OR = {
	ascending: "遞增",
	ascendingSort: (t) => `已依據「${t.columnName}」欄遞增排序`,
	columnSize: (t) => `${t.value} 像素`,
	descending: "遞減",
	descendingSort: (t) => `已依據「${t.columnName}」欄遞減排序`,
	resizerDescription: "按 Enter 鍵以開始調整大小",
	select: "選取",
	selectAll: "全選",
	sortable: "可排序的欄",
};
var h0 = {};
h0 = {
	"ar-AE": rR,
	"bg-BG": iR,
	"cs-CZ": oR,
	"da-DK": sR,
	"de-DE": aR,
	"el-GR": lR,
	"en-US": uR,
	"es-ES": cR,
	"et-EE": dR,
	"fi-FI": fR,
	"fr-FR": hR,
	"he-IL": pR,
	"hr-HR": mR,
	"hu-HU": gR,
	"it-IT": bR,
	"ja-JP": vR,
	"ko-KR": yR,
	"lt-LT": xR,
	"lv-LV": kR,
	"nb-NO": CR,
	"nl-NL": wR,
	"pl-PL": ER,
	"pt-BR": DR,
	"pt-PT": SR,
	"ro-RO": AR,
	"ru-RU": $R,
	"sk-SK": TR,
	"sl-SI": BR,
	"sr-SP": IR,
	"sv-SE": FR,
	"tr-TR": PR,
	"uk-UA": NR,
	"zh-CN": RR,
	"zh-TW": OR,
};
class MR {
	isCell(e) {
		return e.type === "cell";
	}
	isRow(e) {
		return e.type === "row" || e.type === "item";
	}
	isDisabled(e) {
		var n;
		return (
			this.disabledBehavior === "all" &&
			(((n = e.props) === null || n === void 0 ? void 0 : n.isDisabled) ||
				this.disabledKeys.has(e.key))
		);
	}
	findPreviousKey(e, n) {
		let r =
			e != null
				? this.collection.getKeyBefore(e)
				: this.collection.getLastKey();
		for (; r != null; ) {
			let i = this.collection.getItem(r);
			if (!this.isDisabled(i) && (!n || n(i))) return r;
			r = this.collection.getKeyBefore(r);
		}
	}
	findNextKey(e, n) {
		let r =
			e != null
				? this.collection.getKeyAfter(e)
				: this.collection.getFirstKey();
		for (; r != null; ) {
			let i = this.collection.getItem(r);
			if (!this.isDisabled(i) && (!n || n(i))) return r;
			r = this.collection.getKeyAfter(r);
		}
	}
	getKeyBelow(e) {
		let n = this.collection.getItem(e);
		if (
			n &&
			(this.isCell(n) && (e = n.parentKey),
			(e = this.findNextKey(e, (r) => r.type === "item")),
			e != null)
		) {
			if (this.isCell(n)) {
				let r = this.collection.getItem(e);
				return Zl(Wt(r, this.collection), n.index).key;
			}
			if (this.focusMode === "row") return e;
		}
	}
	getKeyAbove(e) {
		let n = this.collection.getItem(e);
		if (
			n &&
			(this.isCell(n) && (e = n.parentKey),
			(e = this.findPreviousKey(e, (r) => r.type === "item")),
			e != null)
		) {
			if (this.isCell(n)) {
				let r = this.collection.getItem(e);
				return Zl(Wt(r, this.collection), n.index).key;
			}
			if (this.focusMode === "row") return e;
		}
	}
	getKeyRightOf(e) {
		let n = this.collection.getItem(e);
		if (n) {
			if (this.isRow(n)) {
				let r = Wt(n, this.collection);
				return this.direction === "rtl" ? Xa(r).key : Ja(r).key;
			}
			if (this.isCell(n)) {
				let r = this.collection.getItem(n.parentKey),
					i = Wt(r, this.collection),
					o =
						this.direction === "rtl"
							? Zl(i, n.index - 1)
							: Zl(i, n.index + 1);
				return o
					? o.key
					: this.focusMode === "row"
						? n.parentKey
						: this.direction === "rtl"
							? this.getFirstKey(e)
							: this.getLastKey(e);
			}
		}
	}
	getKeyLeftOf(e) {
		let n = this.collection.getItem(e);
		if (n) {
			if (this.isRow(n)) {
				let r = Wt(n, this.collection);
				return this.direction === "rtl" ? Ja(r).key : Xa(r).key;
			}
			if (this.isCell(n)) {
				let r = this.collection.getItem(n.parentKey),
					i = Wt(r, this.collection),
					o =
						this.direction === "rtl"
							? Zl(i, n.index + 1)
							: Zl(i, n.index - 1);
				return o
					? o.key
					: this.focusMode === "row"
						? n.parentKey
						: this.direction === "rtl"
							? this.getLastKey(e)
							: this.getFirstKey(e);
			}
		}
	}
	getFirstKey(e, n) {
		let r;
		if (e != null) {
			if (((r = this.collection.getItem(e)), !r)) return;
			if (this.isCell(r) && !n) {
				let i = this.collection.getItem(r.parentKey);
				return Ja(Wt(i, this.collection)).key;
			}
		}
		if (
			((e = this.findNextKey(null, (i) => i.type === "item")),
			(e != null && r && this.isCell(r) && n) ||
				this.focusMode === "cell")
		) {
			let i = this.collection.getItem(e);
			e = Ja(Wt(i, this.collection)).key;
		}
		return e;
	}
	getLastKey(e, n) {
		let r;
		if (e != null) {
			if (((r = this.collection.getItem(e)), !r)) return;
			if (this.isCell(r) && !n) {
				let i = this.collection.getItem(r.parentKey),
					o = Wt(i, this.collection);
				return Xa(o).key;
			}
		}
		if (
			((e = this.findPreviousKey(null, (i) => i.type === "item")),
			(e != null && r && this.isCell(r) && n) ||
				this.focusMode === "cell")
		) {
			let i = this.collection.getItem(e),
				o = Wt(i, this.collection);
			e = Xa(o).key;
		}
		return e;
	}
	getKeyPageAbove(e) {
		let n = this.layoutDelegate.getItemRect(e);
		if (!n) return null;
		let r = Math.max(
			0,
			n.y + n.height - this.layoutDelegate.getVisibleRect().height,
		);
		for (; n && n.y > r; )
			(e = this.getKeyAbove(e)), (n = this.layoutDelegate.getItemRect(e));
		return e;
	}
	getKeyPageBelow(e) {
		let n = this.layoutDelegate.getItemRect(e);
		if (!n) return null;
		let r = this.layoutDelegate.getVisibleRect().height,
			i = Math.min(this.layoutDelegate.getContentSize().height, n.y + r);
		for (; n && n.y + n.height < i; ) {
			let o = this.getKeyBelow(e);
			if (o == null) break;
			(n = this.layoutDelegate.getItemRect(o)), (e = o);
		}
		return e;
	}
	getKeyForSearch(e, n) {
		if (!this.collator) return null;
		let r = this.collection,
			i = n ?? this.getFirstKey(),
			o = r.getItem(i);
		o.type === "cell" && (i = o.parentKey);
		let s = !1;
		for (; i != null; ) {
			let a = r.getItem(i);
			if (a.textValue) {
				let l = a.textValue.slice(0, e.length);
				if (this.collator.compare(l, e) === 0)
					return this.isRow(a) && this.focusMode === "cell"
						? Ja(Wt(a, this.collection)).key
						: a.key;
			}
			(i = this.findNextKey(i, (l) => l.type === "item")),
				i == null && !s && ((i = this.getFirstKey()), (s = !0));
		}
		return null;
	}
	constructor(e) {
		(this.collection = e.collection),
			(this.disabledKeys = e.disabledKeys),
			(this.disabledBehavior = e.disabledBehavior || "all"),
			(this.direction = e.direction),
			(this.collator = e.collator),
			(this.layoutDelegate =
				e.layoutDelegate ||
				(e.layout ? new Cie(e.layout) : new mw(e.ref))),
			(this.focusMode = e.focusMode || "row");
	}
}
class Cie {
	getContentSize() {
		return this.layout.getContentSize();
	}
	getItemRect(e) {
		var n;
		return (
			((n = this.layout.getLayoutInfo(e)) === null || n === void 0
				? void 0
				: n.rect) || null
		);
	}
	getVisibleRect() {
		return this.layout.virtualizer.visibleRect;
	}
	constructor(e) {
		this.layout = e;
	}
}
const SD = new WeakMap();
var jR = {};
jR = {
	deselectedItem: (t) => `${t.item} غير المحدد`,
	longPressToSelect: "اضغط مطولًا للدخول إلى وضع التحديد.",
	select: "تحديد",
	selectedAll: "جميع العناصر المحددة.",
	selectedCount: (t, e) =>
		`${e.plural(t.count, { "=0": "لم يتم تحديد عناصر", one: () => `${e.number(t.count)} عنصر محدد`, other: () => `${e.number(t.count)} عنصر محدد` })}.`,
	selectedItem: (t) => `${t.item} المحدد`,
};
var _R = {};
_R = {
	deselectedItem: (t) => `${t.item} не е избран.`,
	longPressToSelect:
		"Натиснете и задръжте за да влезете в избирателен режим.",
	select: "Изберете",
	selectedAll: "Всички елементи са избрани.",
	selectedCount: (t, e) =>
		`${e.plural(t.count, { "=0": "Няма избрани елементи", one: () => `${e.number(t.count)} избран елемент`, other: () => `${e.number(t.count)} избрани елементи` })}.`,
	selectedItem: (t) => `${t.item} избран.`,
};
var zR = {};
zR = {
	deselectedItem: (t) => `Položka ${t.item} není vybrána.`,
	longPressToSelect: "Dlouhým stisknutím přejdete do režimu výběru.",
	select: "Vybrat",
	selectedAll: "Vybrány všechny položky.",
	selectedCount: (t, e) =>
		`${e.plural(t.count, { "=0": "Nevybrány žádné položky", one: () => `Vybrána ${e.number(t.count)} položka`, other: () => `Vybráno ${e.number(t.count)} položek` })}.`,
	selectedItem: (t) => `Vybrána položka ${t.item}.`,
};
var LR = {};
LR = {
	deselectedItem: (t) => `${t.item} ikke valgt.`,
	longPressToSelect: "Lav et langt tryk for at aktivere valgtilstand.",
	select: "Vælg",
	selectedAll: "Alle elementer valgt.",
	selectedCount: (t, e) =>
		`${e.plural(t.count, { "=0": "Ingen elementer valgt", one: () => `${e.number(t.count)} element valgt`, other: () => `${e.number(t.count)} elementer valgt` })}.`,
	selectedItem: (t) => `${t.item} valgt.`,
};
var VR = {};
VR = {
	deselectedItem: (t) => `${t.item} nicht ausgewählt.`,
	longPressToSelect: "Gedrückt halten, um Auswahlmodus zu öffnen.",
	select: "Auswählen",
	selectedAll: "Alle Elemente ausgewählt.",
	selectedCount: (t, e) =>
		`${e.plural(t.count, { "=0": "Keine Elemente ausgewählt", one: () => `${e.number(t.count)} Element ausgewählt`, other: () => `${e.number(t.count)} Elemente ausgewählt` })}.`,
	selectedItem: (t) => `${t.item} ausgewählt.`,
};
var KR = {};
KR = {
	deselectedItem: (t) => `Δεν επιλέχθηκε το στοιχείο ${t.item}.`,
	longPressToSelect:
		"Πατήστε παρατεταμένα για να μπείτε σε λειτουργία επιλογής.",
	select: "Επιλογή",
	selectedAll: "Επιλέχθηκαν όλα τα στοιχεία.",
	selectedCount: (t, e) =>
		`${e.plural(t.count, { "=0": "Δεν επιλέχθηκαν στοιχεία", one: () => `Επιλέχθηκε ${e.number(t.count)} στοιχείο`, other: () => `Επιλέχθηκαν ${e.number(t.count)} στοιχεία` })}.`,
	selectedItem: (t) => `Επιλέχθηκε το στοιχείο ${t.item}.`,
};
var UR = {};
UR = {
	deselectedItem: (t) => `${t.item} not selected.`,
	select: "Select",
	selectedCount: (t, e) =>
		`${e.plural(t.count, { "=0": "No items selected", one: () => `${e.number(t.count)} item selected`, other: () => `${e.number(t.count)} items selected` })}.`,
	selectedAll: "All items selected.",
	selectedItem: (t) => `${t.item} selected.`,
	longPressToSelect: "Long press to enter selection mode.",
};
var HR = {};
HR = {
	deselectedItem: (t) => `${t.item} no seleccionado.`,
	longPressToSelect: "Mantenga pulsado para abrir el modo de selección.",
	select: "Seleccionar",
	selectedAll: "Todos los elementos seleccionados.",
	selectedCount: (t, e) =>
		`${e.plural(t.count, { "=0": "Ningún elemento seleccionado", one: () => `${e.number(t.count)} elemento seleccionado`, other: () => `${e.number(t.count)} elementos seleccionados` })}.`,
	selectedItem: (t) => `${t.item} seleccionado.`,
};
var WR = {};
WR = {
	deselectedItem: (t) => `${t.item} pole valitud.`,
	longPressToSelect: "Valikurežiimi sisenemiseks vajutage pikalt.",
	select: "Vali",
	selectedAll: "Kõik üksused valitud.",
	selectedCount: (t, e) =>
		`${e.plural(t.count, { "=0": "Üksusi pole valitud", one: () => `${e.number(t.count)} üksus valitud`, other: () => `${e.number(t.count)} üksust valitud` })}.`,
	selectedItem: (t) => `${t.item} valitud.`,
};
var qR = {};
qR = {
	deselectedItem: (t) => `Kohdetta ${t.item} ei valittu.`,
	longPressToSelect: "Siirry valintatilaan painamalla pitkään.",
	select: "Valitse",
	selectedAll: "Kaikki kohteet valittu.",
	selectedCount: (t, e) =>
		`${e.plural(t.count, { "=0": "Ei yhtään kohdetta valittu", one: () => `${e.number(t.count)} kohde valittu`, other: () => `${e.number(t.count)} kohdetta valittu` })}.`,
	selectedItem: (t) => `${t.item} valittu.`,
};
var GR = {};
GR = {
	deselectedItem: (t) => `${t.item} non sélectionné.`,
	longPressToSelect:
		"Appuyez de manière prolongée pour passer en mode de sélection.",
	select: "Sélectionner",
	selectedAll: "Tous les éléments sélectionnés.",
	selectedCount: (t, e) =>
		`${e.plural(t.count, { "=0": "Aucun élément sélectionné", one: () => `${e.number(t.count)} élément sélectionné`, other: () => `${e.number(t.count)} éléments sélectionnés` })}.`,
	selectedItem: (t) => `${t.item} sélectionné.`,
};
var YR = {};
YR = {
	deselectedItem: (t) => `${t.item} לא נבחר.`,
	longPressToSelect: "הקשה ארוכה לכניסה למצב בחירה.",
	select: "בחר",
	selectedAll: "כל הפריטים נבחרו.",
	selectedCount: (t, e) =>
		`${e.plural(t.count, { "=0": "לא נבחרו פריטים", one: () => `פריט ${e.number(t.count)} נבחר`, other: () => `${e.number(t.count)} פריטים נבחרו` })}.`,
	selectedItem: (t) => `${t.item} נבחר.`,
};
var JR = {};
JR = {
	deselectedItem: (t) => `Stavka ${t.item} nije odabrana.`,
	longPressToSelect: "Dugo pritisnite za ulazak u način odabira.",
	select: "Odaberite",
	selectedAll: "Odabrane su sve stavke.",
	selectedCount: (t, e) =>
		`${e.plural(t.count, { "=0": "Nije odabrana nijedna stavka", one: () => `Odabrana je ${e.number(t.count)} stavka`, other: () => `Odabrano je ${e.number(t.count)} stavki` })}.`,
	selectedItem: (t) => `Stavka ${t.item} je odabrana.`,
};
var XR = {};
XR = {
	deselectedItem: (t) => `${t.item} nincs kijelölve.`,
	longPressToSelect: "Nyomja hosszan a kijelöléshez.",
	select: "Kijelölés",
	selectedAll: "Az összes elem kijelölve.",
	selectedCount: (t, e) =>
		`${e.plural(t.count, { "=0": "Egy elem sincs kijelölve", one: () => `${e.number(t.count)} elem kijelölve`, other: () => `${e.number(t.count)} elem kijelölve` })}.`,
	selectedItem: (t) => `${t.item} kijelölve.`,
};
var ZR = {};
ZR = {
	deselectedItem: (t) => `${t.item} non selezionato.`,
	longPressToSelect: "Premi a lungo per passare alla modalità di selezione.",
	select: "Seleziona",
	selectedAll: "Tutti gli elementi selezionati.",
	selectedCount: (t, e) =>
		`${e.plural(t.count, { "=0": "Nessun elemento selezionato", one: () => `${e.number(t.count)} elemento selezionato`, other: () => `${e.number(t.count)} elementi selezionati` })}.`,
	selectedItem: (t) => `${t.item} selezionato.`,
};
var QR = {};
QR = {
	deselectedItem: (t) => `${t.item} が選択されていません。`,
	longPressToSelect: "長押しして選択モードを開きます。",
	select: "選択",
	selectedAll: "すべての項目を選択しました。",
	selectedCount: (t, e) =>
		`${e.plural(t.count, { "=0": "項目が選択されていません", one: () => `${e.number(t.count)} 項目を選択しました`, other: () => `${e.number(t.count)} 項目を選択しました` })}。`,
	selectedItem: (t) => `${t.item} を選択しました。`,
};
var eO = {};
eO = {
	deselectedItem: (t) => `${t.item}이(가) 선택되지 않았습니다.`,
	longPressToSelect: "선택 모드로 들어가려면 길게 누르십시오.",
	select: "선택",
	selectedAll: "모든 항목이 선택되었습니다.",
	selectedCount: (t, e) =>
		`${e.plural(t.count, { "=0": "선택된 항목이 없습니다", one: () => `${e.number(t.count)}개 항목이 선택되었습니다`, other: () => `${e.number(t.count)}개 항목이 선택되었습니다` })}.`,
	selectedItem: (t) => `${t.item}이(가) 선택되었습니다.`,
};
var tO = {};
tO = {
	deselectedItem: (t) => `${t.item} nepasirinkta.`,
	longPressToSelect:
		"Norėdami įjungti pasirinkimo režimą, paspauskite ir palaikykite.",
	select: "Pasirinkti",
	selectedAll: "Pasirinkti visi elementai.",
	selectedCount: (t, e) =>
		`${e.plural(t.count, { "=0": "Nepasirinktas nė vienas elementas", one: () => `Pasirinktas ${e.number(t.count)} elementas`, other: () => `Pasirinkta elementų: ${e.number(t.count)}` })}.`,
	selectedItem: (t) => `Pasirinkta: ${t.item}.`,
};
var nO = {};
nO = {
	deselectedItem: (t) => `Vienums ${t.item} nav atlasīts.`,
	longPressToSelect: "Ilgi turiet nospiestu. lai ieslēgtu atlases režīmu.",
	select: "Atlasīt",
	selectedAll: "Atlasīti visi vienumi.",
	selectedCount: (t, e) =>
		`${e.plural(t.count, { "=0": "Nav atlasīts neviens vienums", one: () => `Atlasīto vienumu skaits: ${e.number(t.count)}`, other: () => `Atlasīto vienumu skaits: ${e.number(t.count)}` })}.`,
	selectedItem: (t) => `Atlasīts vienums ${t.item}.`,
};
var rO = {};
rO = {
	deselectedItem: (t) => `${t.item} er ikke valgt.`,
	longPressToSelect: "Bruk et langt trykk for å gå inn i valgmodus.",
	select: "Velg",
	selectedAll: "Alle elementer er valgt.",
	selectedCount: (t, e) =>
		`${e.plural(t.count, { "=0": "Ingen elementer er valgt", one: () => `${e.number(t.count)} element er valgt`, other: () => `${e.number(t.count)} elementer er valgt` })}.`,
	selectedItem: (t) => `${t.item} er valgt.`,
};
var iO = {};
iO = {
	deselectedItem: (t) => `${t.item} niet geselecteerd.`,
	longPressToSelect: "Druk lang om de selectiemodus te openen.",
	select: "Selecteren",
	selectedAll: "Alle items geselecteerd.",
	selectedCount: (t, e) =>
		`${e.plural(t.count, { "=0": "Geen items geselecteerd", one: () => `${e.number(t.count)} item geselecteerd`, other: () => `${e.number(t.count)} items geselecteerd` })}.`,
	selectedItem: (t) => `${t.item} geselecteerd.`,
};
var oO = {};
oO = {
	deselectedItem: (t) => `Nie zaznaczono ${t.item}.`,
	longPressToSelect: "Naciśnij i przytrzymaj, aby wejść do trybu wyboru.",
	select: "Zaznacz",
	selectedAll: "Wszystkie zaznaczone elementy.",
	selectedCount: (t, e) =>
		`${e.plural(t.count, { "=0": "Nie zaznaczono żadnych elementów", one: () => `${e.number(t.count)} zaznaczony element`, other: () => `${e.number(t.count)} zaznaczonych elementów` })}.`,
	selectedItem: (t) => `Zaznaczono ${t.item}.`,
};
var sO = {};
sO = {
	deselectedItem: (t) => `${t.item} não selecionado.`,
	longPressToSelect: "Mantenha pressionado para entrar no modo de seleção.",
	select: "Selecionar",
	selectedAll: "Todos os itens selecionados.",
	selectedCount: (t, e) =>
		`${e.plural(t.count, { "=0": "Nenhum item selecionado", one: () => `${e.number(t.count)} item selecionado`, other: () => `${e.number(t.count)} itens selecionados` })}.`,
	selectedItem: (t) => `${t.item} selecionado.`,
};
var aO = {};
aO = {
	deselectedItem: (t) => `${t.item} não selecionado.`,
	longPressToSelect: "Prima continuamente para entrar no modo de seleção.",
	select: "Selecionar",
	selectedAll: "Todos os itens selecionados.",
	selectedCount: (t, e) =>
		`${e.plural(t.count, { "=0": "Nenhum item selecionado", one: () => `${e.number(t.count)} item selecionado`, other: () => `${e.number(t.count)} itens selecionados` })}.`,
	selectedItem: (t) => `${t.item} selecionado.`,
};
var lO = {};
lO = {
	deselectedItem: (t) => `${t.item} neselectat.`,
	longPressToSelect: "Apăsați lung pentru a intra în modul de selectare.",
	select: "Selectare",
	selectedAll: "Toate elementele selectate.",
	selectedCount: (t, e) =>
		`${e.plural(t.count, { "=0": "Niciun element selectat", one: () => `${e.number(t.count)} element selectat`, other: () => `${e.number(t.count)} elemente selectate` })}.`,
	selectedItem: (t) => `${t.item} selectat.`,
};
var uO = {};
uO = {
	deselectedItem: (t) => `${t.item} не выбрано.`,
	longPressToSelect: "Нажмите и удерживайте для входа в режим выбора.",
	select: "Выбрать",
	selectedAll: "Выбраны все элементы.",
	selectedCount: (t, e) =>
		`${e.plural(t.count, { "=0": "Нет выбранных элементов", one: () => `${e.number(t.count)} элемент выбран`, other: () => `${e.number(t.count)} элементов выбрано` })}.`,
	selectedItem: (t) => `${t.item} выбрано.`,
};
var cO = {};
cO = {
	deselectedItem: (t) => `Nevybraté položky: ${t.item}.`,
	longPressToSelect: "Dlhším stlačením prejdite do režimu výberu.",
	select: "Vybrať",
	selectedAll: "Všetky vybraté položky.",
	selectedCount: (t, e) =>
		`${e.plural(t.count, { "=0": "Žiadne vybraté položky", one: () => `${e.number(t.count)} vybratá položka`, other: () => `Počet vybratých položiek:${e.number(t.count)}` })}.`,
	selectedItem: (t) => `Vybraté položky: ${t.item}.`,
};
var dO = {};
dO = {
	deselectedItem: (t) => `Element ${t.item} ni izbran.`,
	longPressToSelect: "Za izbirni način pritisnite in dlje časa držite.",
	select: "Izberite",
	selectedAll: "Vsi elementi so izbrani.",
	selectedCount: (t, e) =>
		`${e.plural(t.count, { "=0": "Noben element ni izbran", one: () => `${e.number(t.count)} element je izbran`, other: () => `${e.number(t.count)} elementov je izbranih` })}.`,
	selectedItem: (t) => `Element ${t.item} je izbran.`,
};
var fO = {};
fO = {
	deselectedItem: (t) => `${t.item} nije izabrano.`,
	longPressToSelect: "Dugo pritisnite za ulazak u režim biranja.",
	select: "Izaberite",
	selectedAll: "Izabrane su sve stavke.",
	selectedCount: (t, e) =>
		`${e.plural(t.count, { "=0": "Nije izabrana nijedna stavka", one: () => `Izabrana je ${e.number(t.count)} stavka`, other: () => `Izabrano je ${e.number(t.count)} stavki` })}.`,
	selectedItem: (t) => `${t.item} je izabrano.`,
};
var hO = {};
hO = {
	deselectedItem: (t) => `${t.item} ej markerat.`,
	longPressToSelect: "Tryck länge när du vill öppna väljarläge.",
	select: "Markera",
	selectedAll: "Alla markerade objekt.",
	selectedCount: (t, e) =>
		`${e.plural(t.count, { "=0": "Inga markerade objekt", one: () => `${e.number(t.count)} markerat objekt`, other: () => `${e.number(t.count)} markerade objekt` })}.`,
	selectedItem: (t) => `${t.item} markerat.`,
};
var pO = {};
pO = {
	deselectedItem: (t) => `${t.item} seçilmedi.`,
	longPressToSelect: "Seçim moduna girmek için uzun basın.",
	select: "Seç",
	selectedAll: "Tüm ögeler seçildi.",
	selectedCount: (t, e) =>
		`${e.plural(t.count, { "=0": "Hiçbir öge seçilmedi", one: () => `${e.number(t.count)} öge seçildi`, other: () => `${e.number(t.count)} öge seçildi` })}.`,
	selectedItem: (t) => `${t.item} seçildi.`,
};
var mO = {};
mO = {
	deselectedItem: (t) => `${t.item} не вибрано.`,
	longPressToSelect:
		"Виконайте довге натиснення, щоб перейти в режим вибору.",
	select: "Вибрати",
	selectedAll: "Усі елементи вибрано.",
	selectedCount: (t, e) =>
		`${e.plural(t.count, { "=0": "Жодних елементів не вибрано", one: () => `${e.number(t.count)} елемент вибрано`, other: () => `Вибрано елементів: ${e.number(t.count)}` })}.`,
	selectedItem: (t) => `${t.item} вибрано.`,
};
var gO = {};
gO = {
	deselectedItem: (t) => `未选择 ${t.item}。`,
	longPressToSelect: "长按以进入选择模式。",
	select: "选择",
	selectedAll: "已选择所有项目。",
	selectedCount: (t, e) =>
		`${e.plural(t.count, { "=0": "未选择项目", one: () => `已选择 ${e.number(t.count)} 个项目`, other: () => `已选择 ${e.number(t.count)} 个项目` })}。`,
	selectedItem: (t) => `已选择 ${t.item}。`,
};
var bO = {};
bO = {
	deselectedItem: (t) => `未選取「${t.item}」。`,
	longPressToSelect: "長按以進入選擇模式。",
	select: "選取",
	selectedAll: "已選取所有項目。",
	selectedCount: (t, e) =>
		`${e.plural(t.count, { "=0": "未選取任何項目", one: () => `已選取 ${e.number(t.count)} 個項目`, other: () => `已選取 ${e.number(t.count)} 個項目` })}。`,
	selectedItem: (t) => `已選取「${t.item}」。`,
};
var Tx = {};
Tx = {
	"ar-AE": jR,
	"bg-BG": _R,
	"cs-CZ": zR,
	"da-DK": LR,
	"de-DE": VR,
	"el-GR": KR,
	"en-US": UR,
	"es-ES": HR,
	"et-EE": WR,
	"fi-FI": qR,
	"fr-FR": GR,
	"he-IL": YR,
	"hr-HR": JR,
	"hu-HU": XR,
	"it-IT": ZR,
	"ja-JP": QR,
	"ko-KR": eO,
	"lt-LT": tO,
	"lv-LV": nO,
	"nb-NO": rO,
	"nl-NL": iO,
	"pl-PL": oO,
	"pt-BR": sO,
	"pt-PT": aO,
	"ro-RO": lO,
	"ru-RU": uO,
	"sk-SK": cO,
	"sl-SI": dO,
	"sr-SP": fO,
	"sv-SE": hO,
	"tr-TR": pO,
	"uk-UA": mO,
	"zh-CN": gO,
	"zh-TW": bO,
};
const vO = 7e3;
let mm = null;
function xs(t, e = "assertive", n = vO) {
	mm || (mm = new Eie()), mm.announce(t, e, n);
}
function wie(t) {
	mm && mm.clear(t);
}
class Eie {
	createLog(e) {
		let n = document.createElement("div");
		return (
			n.setAttribute("role", "log"),
			n.setAttribute("aria-live", e),
			n.setAttribute("aria-relevant", "additions"),
			n
		);
	}
	destroy() {
		this.node && (document.body.removeChild(this.node), (this.node = null));
	}
	announce(e, n = "assertive", r = vO) {
		if (!this.node) return;
		let i = document.createElement("div");
		(i.textContent = e),
			n === "assertive"
				? this.assertiveLog.appendChild(i)
				: this.politeLog.appendChild(i),
			e !== "" &&
				setTimeout(() => {
					i.remove();
				}, r);
	}
	clear(e) {
		this.node &&
			((!e || e === "assertive") && (this.assertiveLog.innerHTML = ""),
			(!e || e === "polite") && (this.politeLog.innerHTML = ""));
	}
	constructor() {
		(this.node = document.createElement("div")),
			(this.node.dataset.liveAnnouncer = "true"),
			Object.assign(this.node.style, {
				border: 0,
				clip: "rect(0 0 0 0)",
				clipPath: "inset(50%)",
				height: "1px",
				margin: "-1px",
				overflow: "hidden",
				padding: 0,
				position: "absolute",
				width: "1px",
				whiteSpace: "nowrap",
			}),
			(this.assertiveLog = this.createLog("assertive")),
			this.node.appendChild(this.assertiveLog),
			(this.politeLog = this.createLog("polite")),
			this.node.appendChild(this.politeLog),
			document.body.prepend(this.node);
	}
}
function Die(t) {
	return t && t.__esModule ? t.default : t;
}
function yO(t, e) {
	let {
			getRowText: n = (s) => {
				var a, l, u, c;
				return (c =
					(a = (l = e.collection).getTextValue) === null ||
					a === void 0
						? void 0
						: a.call(l, s)) !== null && c !== void 0
					? c
					: (u = e.collection.getItem(s)) === null || u === void 0
						? void 0
						: u.textValue;
			},
		} = t,
		r = Le(Die(Tx), "@react-aria/grid"),
		i = e.selectionManager.rawSelection,
		o = E.useRef(i);
	o0(() => {
		var s;
		if (!e.selectionManager.isFocused) {
			o.current = i;
			return;
		}
		let a = Y6(i, o.current),
			l = Y6(o.current, i),
			u = e.selectionManager.selectionBehavior === "replace",
			c = [];
		if (e.selectionManager.selectedKeys.size === 1 && u) {
			if (
				e.collection.getItem(
					e.selectionManager.selectedKeys.keys().next().value,
				)
			) {
				let d = n(e.selectionManager.selectedKeys.keys().next().value);
				d && c.push(r.format("selectedItem", { item: d }));
			}
		} else if (a.size === 1 && l.size === 0) {
			let d = n(a.keys().next().value);
			d && c.push(r.format("selectedItem", { item: d }));
		} else if (
			l.size === 1 &&
			a.size === 0 &&
			e.collection.getItem(l.keys().next().value)
		) {
			let d = n(l.keys().next().value);
			d && c.push(r.format("deselectedItem", { item: d }));
		}
		e.selectionManager.selectionMode === "multiple" &&
			(c.length === 0 ||
				i === "all" ||
				i.size > 1 ||
				o.current === "all" ||
				((s = o.current) === null || s === void 0 ? void 0 : s.size) >
					1) &&
			c.push(
				i === "all"
					? r.format("selectedAll")
					: r.format("selectedCount", { count: i.size }),
			),
			c.length > 0 && xs(c.join(" ")),
			(o.current = i);
	}, [i]);
}
function Y6(t, e) {
	let n = new Set();
	if (t === "all" || e === "all") return n;
	for (let r of t.keys()) e.has(r) || n.add(r);
	return n;
}
function Sie(t) {
	return t && t.__esModule ? t.default : t;
}
function xO(t) {
	let e = Le(Sie(Tx), "@react-aria/grid"),
		n = fx(),
		r =
			(n === "pointer" || n === "virtual" || n == null) &&
			typeof window < "u" &&
			"ontouchstart" in window,
		i = E.useMemo(() => {
			let s = t.selectionManager.selectionMode,
				a = t.selectionManager.selectionBehavior,
				l;
			return (
				r && (l = e.format("longPressToSelect")),
				a === "replace" && s !== "none" && t.hasItemActions ? l : void 0
			);
		}, [
			t.selectionManager.selectionMode,
			t.selectionManager.selectionBehavior,
			t.hasItemActions,
			e,
			r,
		]);
	return tc(i);
}
function Aie(t, e, n) {
	let {
			isVirtualized: r,
			keyboardDelegate: i,
			focusMode: o,
			scrollRef: s,
			getRowText: a,
			onRowAction: l,
			onCellAction: u,
		} = t,
		{ selectionManager: c } = e;
	!t["aria-label"] &&
		!t["aria-labelledby"] &&
		console.warn(
			"An aria-label or aria-labelledby prop is required for accessibility.",
		);
	let d = a0({ usage: "search", sensitivity: "base" }),
		{ direction: f } = Vt(),
		h = e.selectionManager.disabledBehavior,
		p = E.useMemo(
			() =>
				i ||
				new MR({
					collection: e.collection,
					disabledKeys: e.disabledKeys,
					disabledBehavior: h,
					ref: n,
					direction: f,
					collator: d,
					focusMode: o,
				}),
			[i, e.collection, e.disabledKeys, h, n, f, d, o],
		),
		{ collectionProps: g } = $x({
			ref: n,
			selectionManager: c,
			keyboardDelegate: p,
			isVirtualized: r,
			scrollRef: s,
		}),
		v = Ot(t.id);
	SD.set(e, {
		keyboardDelegate: p,
		actions: { onRowAction: l, onCellAction: u },
	});
	let b = xO({ selectionManager: c, hasItemActions: !!(l || u) }),
		y = Ge(t, { labelable: !0 }),
		x = E.useCallback(
			(D) => {
				if (c.isFocused) {
					D.currentTarget.contains(D.target) || c.setFocused(!1);
					return;
				}
				D.currentTarget.contains(D.target) && c.setFocused(!0);
			},
			[c],
		),
		C = E.useMemo(() => ({ onBlur: g.onBlur, onFocus: x }), [x, g.onBlur]),
		k = B9(n, { isDisabled: e.collection.size !== 0 }),
		w = xe(
			y,
			{
				role: "grid",
				id: v,
				"aria-multiselectable":
					c.selectionMode === "multiple" ? "true" : void 0,
			},
			e.isKeyboardNavigationDisabled ? C : g,
			e.collection.size === 0 && { tabIndex: k ? -1 : 0 },
			b,
		);
	return (
		r &&
			((w["aria-rowcount"] = e.collection.size),
			(w["aria-colcount"] = e.collection.columnCount)),
		yO({ getRowText: a }, e),
		{ gridProps: w }
	);
}
function $ie() {
	return { rowGroupProps: { role: "rowgroup" } };
}
function Tie(t, e, n) {
	var r, i;
	let {
			node: o,
			isVirtualized: s,
			shouldSelectOnPressUp: a,
			onAction: l,
		} = t,
		{ actions: u } = SD.get(e),
		c = u.onRowAction ? () => u.onRowAction(o.key) : l,
		{ itemProps: d, ...f } = f0({
			selectionManager: e.selectionManager,
			key: o.key,
			ref: n,
			isVirtualized: s,
			shouldSelectOnPressUp: a,
			onAction:
				c ||
				(!(o == null || (r = o.props) === null || r === void 0) &&
					r.onAction)
					? hr(
							o == null || (i = o.props) === null || i === void 0
								? void 0
								: i.onAction,
							c,
						)
					: void 0,
			isDisabled: e.collection.size === 0,
		}),
		h = e.selectionManager.isSelected(o.key),
		p = {
			role: "row",
			"aria-selected":
				e.selectionManager.selectionMode !== "none" ? h : void 0,
			"aria-disabled": f.isDisabled || void 0,
			...d,
		};
	return s && (p["aria-rowindex"] = o.index + 1), { rowProps: p, ...f };
}
function kO(t, e, n) {
	let {
			node: r,
			isVirtualized: i,
			focusMode: o = "child",
			shouldSelectOnPressUp: s,
			onAction: a,
		} = t,
		{ direction: l } = Vt(),
		{
			keyboardDelegate: u,
			actions: { onCellAction: c },
		} = SD.get(e),
		d = E.useRef(null),
		f = () => {
			let x = rr(n.current);
			if (o === "child") {
				if (
					n.current.contains(document.activeElement) &&
					n.current !== document.activeElement
				)
					return;
				let C =
					e.selectionManager.childFocusStrategy === "last"
						? _4(x)
						: x.firstChild();
				if (C) {
					on(C);
					return;
				}
			}
			((d.current != null && r.key !== d.current) ||
				!n.current.contains(document.activeElement)) &&
				on(n.current);
		},
		{ itemProps: h, isPressed: p } = f0({
			selectionManager: e.selectionManager,
			key: r.key,
			ref: n,
			isVirtualized: i,
			focus: f,
			shouldSelectOnPressUp: s,
			onAction: c ? () => c(r.key) : a,
			isDisabled: e.collection.size === 0,
		}),
		b = xe(h, {
			role: "gridcell",
			onKeyDownCapture: (x) => {
				if (
					!x.currentTarget.contains(x.target) ||
					e.isKeyboardNavigationDisabled
				)
					return;
				let C = rr(n.current);
				switch (((C.currentNode = document.activeElement), x.key)) {
					case "ArrowLeft": {
						let k = l === "rtl" ? C.nextNode() : C.previousNode();
						if (
							(o === "child" && k === n.current && (k = null),
							x.preventDefault(),
							x.stopPropagation(),
							k)
						)
							on(k), ui(k, { containingElement: li(n.current) });
						else {
							if (u.getKeyLeftOf(r.key) !== r.key) {
								n.current.parentElement.dispatchEvent(
									new KeyboardEvent(
										x.nativeEvent.type,
										x.nativeEvent,
									),
								);
								break;
							}
							o === "cell" && l === "rtl"
								? (on(n.current),
									ui(n.current, {
										containingElement: li(n.current),
									}))
								: ((C.currentNode = n.current),
									(k = l === "rtl" ? C.firstChild() : _4(C)),
									k &&
										(on(k),
										ui(k, {
											containingElement: li(n.current),
										})));
						}
						break;
					}
					case "ArrowRight": {
						let k = l === "rtl" ? C.previousNode() : C.nextNode();
						if (
							(o === "child" && k === n.current && (k = null),
							x.preventDefault(),
							x.stopPropagation(),
							k)
						)
							on(k), ui(k, { containingElement: li(n.current) });
						else {
							if (u.getKeyRightOf(r.key) !== r.key) {
								n.current.parentElement.dispatchEvent(
									new KeyboardEvent(
										x.nativeEvent.type,
										x.nativeEvent,
									),
								);
								break;
							}
							o === "cell" && l === "ltr"
								? (on(n.current),
									ui(n.current, {
										containingElement: li(n.current),
									}))
								: ((C.currentNode = n.current),
									(k = l === "rtl" ? _4(C) : C.firstChild()),
									k &&
										(on(k),
										ui(k, {
											containingElement: li(n.current),
										})));
						}
						break;
					}
					case "ArrowUp":
					case "ArrowDown":
						!x.altKey &&
							n.current.contains(x.target) &&
							(x.stopPropagation(),
							x.preventDefault(),
							n.current.parentElement.dispatchEvent(
								new KeyboardEvent(
									x.nativeEvent.type,
									x.nativeEvent,
								),
							));
						break;
				}
			},
			onFocus: (x) => {
				if (((d.current = r.key), x.target !== n.current)) {
					ml() || e.selectionManager.setFocusedKey(r.key);
					return;
				}
				requestAnimationFrame(() => {
					o === "child" &&
						document.activeElement === n.current &&
						f();
				});
			},
		});
	var y;
	return (
		i &&
			(b["aria-colindex"] =
				((y = r.colIndex) !== null && y !== void 0 ? y : r.index) + 1),
		s &&
			b.tabIndex != null &&
			b.onPointerDown == null &&
			(b.onPointerDown = (x) => {
				let C = x.currentTarget,
					k = C.getAttribute("tabindex");
				C.removeAttribute("tabindex"),
					requestAnimationFrame(() => {
						C.setAttribute("tabindex", k);
					});
			}),
		{ gridCellProps: b, isPressed: p }
	);
}
function _4(t) {
	let e, n;
	do (n = t.lastChild()), n && (e = n);
	while (n);
	return e;
}
function Bie(t) {
	return t && t.__esModule ? t.default : t;
}
function CO(t, e) {
	let { key: n } = t,
		r = e.selectionManager,
		i = Ot(),
		o = !e.selectionManager.canSelectItem(n),
		s = e.selectionManager.isSelected(n),
		a = () => r.toggleSelection(n);
	const l = Le(Bie(Tx), "@react-aria/grid");
	return {
		checkboxProps: {
			id: i,
			"aria-label": l.format("select"),
			isSelected: s,
			isDisabled: o,
			onChange: a,
		},
	};
}
class Iie extends MR {
	isCell(e) {
		return (
			e.type === "cell" || e.type === "rowheader" || e.type === "column"
		);
	}
	getKeyBelow(e) {
		let n = this.collection.getItem(e);
		if (n) {
			if (n.type === "column") {
				let r = Ja(Wt(n, this.collection));
				if (r) return r.key;
				let i = this.getFirstKey();
				if (i == null) return;
				let o = this.collection.getItem(i);
				return Zl(Wt(o, this.collection), n.index).key;
			}
			return super.getKeyBelow(e);
		}
	}
	getKeyAbove(e) {
		let n = this.collection.getItem(e);
		if (!n) return;
		if (n.type === "column") {
			let i = this.collection.getItem(n.parentKey);
			return i && i.type === "column" ? i.key : void 0;
		}
		let r = super.getKeyAbove(e);
		return r != null && this.collection.getItem(r).type !== "headerrow"
			? r
			: this.isCell(n)
				? this.collection.columns[n.index].key
				: this.collection.columns[0].key;
	}
	findNextColumnKey(e) {
		let n = this.findNextKey(e.key, (i) => i.type === "column");
		if (n != null) return n;
		let r = this.collection.headerRows[e.level];
		for (let i of Wt(r, this.collection))
			if (i.type === "column") return i.key;
	}
	findPreviousColumnKey(e) {
		let n = this.findPreviousKey(e.key, (o) => o.type === "column");
		if (n != null) return n;
		let r = this.collection.headerRows[e.level],
			i = [...Wt(r, this.collection)];
		for (let o = i.length - 1; o >= 0; o--) {
			let s = i[o];
			if (s.type === "column") return s.key;
		}
	}
	getKeyRightOf(e) {
		let n = this.collection.getItem(e);
		if (n)
			return n.type === "column"
				? this.direction === "rtl"
					? this.findPreviousColumnKey(n)
					: this.findNextColumnKey(n)
				: super.getKeyRightOf(e);
	}
	getKeyLeftOf(e) {
		let n = this.collection.getItem(e);
		if (n)
			return n.type === "column"
				? this.direction === "rtl"
					? this.findNextColumnKey(n)
					: this.findPreviousColumnKey(n)
				: super.getKeyLeftOf(e);
	}
	getKeyForSearch(e, n) {
		if (!this.collator) return null;
		let r = this.collection,
			i = n ?? this.getFirstKey();
		if (i == null) return null;
		let o = r.getItem(i);
		o.type === "cell" && (i = o.parentKey);
		let s = !1;
		for (; i != null; ) {
			let a = r.getItem(i);
			for (let l of Wt(a, this.collection)) {
				let u = r.columns[l.index];
				if (r.rowHeaderColumnKeys.has(u.key) && l.textValue) {
					let c = l.textValue.slice(0, e.length);
					if (this.collator.compare(c, e) === 0)
						return (n != null ? r.getItem(n) : o).type === "cell"
							? l.key
							: a.key;
				}
			}
			(i = this.getKeyBelow(i)),
				i == null && !s && ((i = this.getFirstKey()), (s = !0));
		}
		return null;
	}
}
function Fie(t) {
	return t && t.__esModule ? t.default : t;
}
function Pie(t, e, n) {
	let {
			keyboardDelegate: r,
			isVirtualized: i,
			layoutDelegate: o,
			layout: s,
		} = t,
		a = a0({ usage: "search", sensitivity: "base" }),
		{ direction: l } = Vt(),
		u = e.selectionManager.disabledBehavior,
		c = E.useMemo(
			() =>
				r ||
				new Iie({
					collection: e.collection,
					disabledKeys: e.disabledKeys,
					disabledBehavior: u,
					ref: n,
					direction: l,
					collator: a,
					layoutDelegate: o,
					layout: s,
				}),
			[r, e.collection, e.disabledKeys, u, n, l, a, o, s],
		),
		d = Ot(t.id);
	DD.set(e, d);
	let { gridProps: f } = Aie({ ...t, id: d, keyboardDelegate: c }, e, n);
	i &&
		(f["aria-rowcount"] =
			e.collection.size + e.collection.headerRows.length),
		vv() && "expandedKeys" in e && (f.role = "treegrid");
	let { column: h, direction: p } = e.sortDescriptor || {},
		g = Le(Fie(h0), "@react-aria/table"),
		v = E.useMemo(() => {
			var y;
			let x =
				(y = e.collection.columns.find((C) => C.key === h)) === null ||
				y === void 0
					? void 0
					: y.textValue;
			return p && h ? g.format(`${p}Sort`, { columnName: x }) : void 0;
		}, [p, h, e.collection.columns]),
		b = tc(v);
	return (
		o0(() => {
			xs(v, "assertive", 500);
		}, [v]),
		{
			gridProps: xe(f, b, {
				"aria-describedby": [
					b["aria-describedby"],
					f["aria-describedby"],
				]
					.filter(Boolean)
					.join(" "),
			}),
		}
	);
}
function Nie(t) {
	return t && t.__esModule ? t.default : t;
}
function Bx(t, e, n) {
	var r, i;
	let { node: o } = t,
		s = o.props.allowsSorting,
		{ gridCellProps: a } = kO({ ...t, focusMode: "child" }, e, n),
		l =
			o.props.isSelectionCell &&
			e.selectionManager.selectionMode === "single",
		{ pressProps: u } = zi({
			isDisabled: !s || l,
			onPress() {
				e.sort(o.key);
			},
			ref: n,
		}),
		{ focusableProps: c } = Hd({}, n),
		d = null,
		f =
			((r = e.sortDescriptor) === null || r === void 0
				? void 0
				: r.column) === o.key,
		h =
			(i = e.sortDescriptor) === null || i === void 0
				? void 0
				: i.direction;
	o.props.allowsSorting && !zm() && (d = f ? h : "none");
	let p = Le(Nie(h0), "@react-aria/table"),
		g;
	s &&
		((g = `${p.format("sortable")}`),
		f && h && zm() && (g = `${g}, ${p.format(h)}`));
	let v = tc(g),
		b = e.collection.size === 0;
	return (
		E.useEffect(() => {
			b &&
				e.selectionManager.focusedKey === o.key &&
				e.selectionManager.setFocusedKey(null);
		}, [b, e.selectionManager, o.key]),
		{
			columnHeaderProps: {
				...xe(a, u, c, v, b && { tabIndex: -1 }),
				role: "columnheader",
				id: eR(e, o.key),
				"aria-colspan": o.colspan && o.colspan > 1 ? o.colspan : null,
				"aria-sort": d,
			},
		}
	);
}
const J6 = {
	expand: { ltr: "ArrowRight", rtl: "ArrowLeft" },
	collapse: { ltr: "ArrowLeft", rtl: "ArrowRight" },
};
function Rie(t, e, n) {
	let { node: r, isVirtualized: i } = t,
		{ rowProps: o, ...s } = Tie(t, e, n),
		{ direction: a } = Vt();
	i && !(vv() && "expandedKeys" in e)
		? (o["aria-rowindex"] = r.index + 1 + e.collection.headerRows.length)
		: delete o["aria-rowindex"];
	let l = {};
	if (vv() && "expandedKeys" in e) {
		let p = e.keyMap.get(r.key);
		if (p != null) {
			var u, c, d;
			let g =
				((u = p.props) === null || u === void 0
					? void 0
					: u.UNSTABLE_childItems) ||
				((d = p.props) === null ||
				d === void 0 ||
				(c = d.children) === null ||
				c === void 0
					? void 0
					: c.length) > e.userColumnCount;
			l = {
				onKeyDown: (v) => {
					((v.key === J6.expand[a] &&
						e.selectionManager.focusedKey === p.key &&
						g &&
						e.expandedKeys !== "all" &&
						!e.expandedKeys.has(p.key)) ||
						(v.key === J6.collapse[a] &&
							e.selectionManager.focusedKey === p.key &&
							g &&
							(e.expandedKeys === "all" ||
								e.expandedKeys.has(p.key)))) &&
						(e.toggleKey(p.key), v.stopPropagation());
				},
				"aria-expanded": g
					? e.expandedKeys === "all" || e.expandedKeys.has(r.key)
					: void 0,
				"aria-level": p.level,
				"aria-posinset": p.indexOfType + 1,
				"aria-setsize":
					p.level > 1
						? Xa(
								e.keyMap.get(p == null ? void 0 : p.parentKey)
									.childNodes,
							).indexOfType + 1
						: Xa(e.keyMap.get(e.collection.body.key).childNodes)
								.indexOfType + 1,
			};
		}
	}
	let f = i9(r.props),
		h = s.hasAction ? f : {};
	return {
		rowProps: { ...xe(o, l, h), "aria-labelledby": nR(e, r.key) },
		...s,
	};
}
function Oie(t, e, n) {
	let { node: r, isVirtualized: i } = t,
		o = { role: "row" };
	return (
		i &&
			!(vv() && "expandedKeys" in e) &&
			(o["aria-rowindex"] = r.index + 1),
		{ rowProps: o }
	);
}
function AD(t, e, n) {
	let { gridCellProps: r, isPressed: i } = kO(t, e, n),
		o = t.node.column.key;
	return (
		e.collection.rowHeaderColumnKeys.has(o) &&
			((r.role = "rowheader"), (r.id = tR(e, t.node.parentKey, o))),
		{ gridCellProps: r, isPressed: i }
	);
}
function Mie(t) {
	return t && t.__esModule ? t.default : t;
}
function jie(t, e) {
	let { key: n } = t;
	const { checkboxProps: r } = CO(t, e);
	return {
		checkboxProps: { ...r, "aria-labelledby": `${r.id} ${nR(e, n)}` },
	};
}
function _ie(t) {
	let { isEmpty: e, isSelectAll: n, selectionMode: r } = t.selectionManager;
	return {
		checkboxProps: {
			"aria-label": Le(Mie(h0), "@react-aria/table").format(
				r === "single" ? "select" : "selectAll",
			),
			isSelected: n,
			isDisabled: r !== "multiple" || t.collection.size === 0,
			isIndeterminate: !e && !n,
			onChange: () => t.selectionManager.toggleSelectAll(),
		},
	};
}
function zie(t) {
	return t && t.__esModule ? t.default : t;
}
function Lie(t, e, n) {
	let {
		column: r,
		triggerRef: i,
		isDisabled: o,
		onResizeStart: s,
		onResize: a,
		onResizeEnd: l,
		"aria-label": u,
	} = t;
	const c = Le(zie(h0), "@react-aria/table");
	let d = Ot(),
		f = e.resizingColumn === r.key,
		h = E.useRef(f),
		p = E.useRef(null),
		g = E.useRef(!1),
		v = e.tableState.isKeyboardNavigationDisabled,
		{ direction: b } = Vt(),
		{ keyboardProps: y } = hx({
			onKeyDown: (H) => {
				v
					? (H.key === "Escape" ||
							H.key === "Enter" ||
							H.key === " " ||
							H.key === "Tab") &&
						(H.preventDefault(), k(r))
					: (H.continuePropagation(), H.key === "Enter" && x(r));
			},
		}),
		x = Pt((H) => {
			h.current ||
				((p.current = e.updateResizedColumns(
					H.key,
					e.getColumnWidth(H.key),
				)),
				e.startResize(H.key),
				e.tableState.setKeyboardNavigationDisabled(!0),
				s == null || s(p.current)),
				(h.current = !0);
		}),
		C = Pt((H, P) => {
			let q = e.updateResizedColumns(H.key, P);
			a == null || a(q), (p.current = q);
		}),
		k = Pt((H) => {
			h.current &&
				(p.current == null &&
					(p.current = e.updateResizedColumns(
						H.key,
						e.getColumnWidth(H.key),
					)),
				e.endResize(),
				e.tableState.setKeyboardNavigationDisabled(!1),
				l == null || l(p.current),
				(h.current = !1),
				i != null && i.current && !g.current && on(i.current)),
				(p.current = null);
		});
	const w = E.useRef(0),
		{ moveProps: D } = zee({
			onMoveStart() {
				(w.current = e.getColumnWidth(r.key)), x(r);
			},
			onMove(H) {
				let { deltaX: P, deltaY: q, pointerType: J } = H;
				b === "rtl" && (P *= -1),
					J === "keyboard" &&
						(q !== 0 && P === 0 && (P = q * -1), (P *= 10)),
					P !== 0 && ((w.current += P), C(r, w.current));
			},
			onMoveEnd(H) {
				let { pointerType: P } = H;
				(w.current = 0),
					(P === "mouse" || (P === "touch" && g.current)) && k(r);
			},
		});
	let S = E.useCallback(
			(H) => {
				v && D.onKeyDown(H);
			},
			[v, D],
		),
		$ = Math.floor(e.getColumnMinWidth(r.key)),
		A = Math.floor(e.getColumnMaxWidth(r.key));
	A === 1 / 0 && (A = Number.MAX_SAFE_INTEGER);
	let T = Math.floor(e.getColumnWidth(r.key)),
		I = fx();
	I === "virtual" &&
		typeof window < "u" &&
		"ontouchstart" in window &&
		(I = "touch");
	let F =
			(i == null ? void 0 : i.current) == null &&
			(I === "keyboard" || I === "virtual") &&
			!f
				? c.format("resizerDescription")
				: void 0,
		N = tc(F),
		O = {
			"aria-label": u,
			"aria-orientation": "horizontal",
			"aria-labelledby": `${d} ${eR(e.tableState, r.key)}`,
			"aria-valuetext": c.format("columnSize", { value: T }),
			type: "range",
			min: $,
			max: A,
			value: T,
			...N,
		};
	const _ = E.useCallback(() => {
		n.current && on(n.current);
	}, [n]);
	let j = e.resizingColumn,
		V = E.useRef(null);
	E.useEffect(() => {
		if (V.current !== j && j != null && j === r.key) {
			(g.current = document.activeElement === n.current), x(r);
			let H = setTimeout(() => _(), 0),
				P = setTimeout(_, 400);
			return () => {
				clearTimeout(H), clearTimeout(P);
			};
		}
		V.current = j;
	}, [j, r, _, n, x]);
	let K = (H) => {
			let P = e.getColumnWidth(r.key),
				q = parseFloat(H.target.value);
			q > P ? (q = P + 10) : (q = P - 10), C(r, q);
		},
		{ pressProps: M } = zi({
			onPressStart: (H) => {
				if (
					!(
						H.ctrlKey ||
						H.altKey ||
						H.metaKey ||
						H.shiftKey ||
						H.pointerType === "keyboard"
					)
				) {
					if (
						H.pointerType === "virtual" &&
						e.resizingColumn != null
					) {
						k(r);
						return;
					}
					_(), H.pointerType !== "virtual" && x(r);
				}
			},
			onPress: (H) => {
				((H.pointerType === "touch" && g.current) ||
					H.pointerType === "mouse") &&
					e.resizingColumn != null &&
					k(r);
			},
		}),
		{ visuallyHiddenProps: G } = Ea();
	return {
		resizerProps: xe(y, { ...D, onKeyDown: S }, M, {
			style: { touchAction: "none" },
		}),
		inputProps: xe(
			G,
			{
				id: d,
				onBlur: () => {
					k(r);
				},
				onChange: K,
				disabled: o,
			},
			O,
		),
		isResizing: f,
	};
}
function wO() {
	return $ie();
}
let df = null;
function EO(t = !1) {
	if (df === null || t) {
		const e = document.createElement("div"),
			n = e.style;
		(n.width = "50px"),
			(n.height = "50px"),
			(n.overflow = "scroll"),
			(n.direction = "rtl");
		const r = document.createElement("div"),
			i = r.style;
		return (
			(i.width = "100px"),
			(i.height = "100px"),
			e.appendChild(r),
			document.body.appendChild(e),
			e.scrollLeft > 0
				? (df = "positive-descending")
				: ((e.scrollLeft = 1),
					e.scrollLeft === 0
						? (df = "negative")
						: (df = "positive-ascending")),
			document.body.removeChild(e),
			df
		);
	}
	return df;
}
function Vie(t, e) {
	let { scrollLeft: n } = t;
	if (e === "rtl") {
		let { scrollWidth: r, clientWidth: i } = t;
		switch (EO()) {
			case "negative":
				n = -n;
				break;
			case "positive-descending":
				n = r - i - n;
				break;
		}
	}
	return n;
}
function Kie(t, e, n) {
	if (e === "rtl")
		switch (EO()) {
			case "negative":
				n = -n;
				break;
			case "positive-ascending":
				break;
			default: {
				const { clientWidth: r, scrollWidth: i } = t;
				n = i - r - n;
				break;
			}
		}
	t.scrollLeft = n;
}
class Uie {
	shouldInvalidate(e, n) {
		return e.width !== n.width || e.height !== n.height;
	}
	update(e) {}
	getItemRect(e) {
		var n;
		return (n = this.getLayoutInfo(e)) === null || n === void 0
			? void 0
			: n.rect;
	}
	getVisibleRect() {
		return this.virtualizer.visibleRect;
	}
}
class er {
	copy() {
		let e = new er(this.type, this.key, this.rect.copy());
		return (
			(e.estimatedSize = this.estimatedSize),
			(e.opacity = this.opacity),
			(e.transform = this.transform),
			(e.parentKey = this.parentKey),
			(e.isSticky = this.isSticky),
			(e.zIndex = this.zIndex),
			(e.allowOverflow = this.allowOverflow),
			e
		);
	}
	constructor(e, n, r) {
		(this.type = e),
			(this.key = n),
			(this.parentKey = null),
			(this.rect = r),
			(this.estimatedSize = !1),
			(this.isSticky = !1),
			(this.opacity = 1),
			(this.transform = null),
			(this.zIndex = 0),
			(this.allowOverflow = !1);
	}
}
class Za {
	copy() {
		return new Za(this.x, this.y);
	}
	equals(e) {
		return this.x === e.x && this.y === e.y;
	}
	isOrigin() {
		return this.x === 0 && this.y === 0;
	}
	constructor(e = 0, n = 0) {
		(this.x = e), (this.y = n);
	}
}
class St {
	get maxX() {
		return this.x + this.width;
	}
	get maxY() {
		return this.y + this.height;
	}
	get area() {
		return this.width * this.height;
	}
	get topLeft() {
		return new Za(this.x, this.y);
	}
	get topRight() {
		return new Za(this.maxX, this.y);
	}
	get bottomLeft() {
		return new Za(this.x, this.maxY);
	}
	get bottomRight() {
		return new Za(this.maxX, this.maxY);
	}
	intersects(e) {
		return (
			this.x <= e.x + e.width &&
			e.x <= this.x + this.width &&
			this.y <= e.y + e.height &&
			e.y <= this.y + this.height
		);
	}
	containsRect(e) {
		return (
			this.x <= e.x &&
			this.y <= e.y &&
			this.maxX >= e.maxX &&
			this.maxY >= e.maxY
		);
	}
	containsPoint(e) {
		return (
			this.x <= e.x &&
			this.y <= e.y &&
			this.maxX >= e.x &&
			this.maxY >= e.y
		);
	}
	getCornerInRect(e) {
		for (let n of ["topLeft", "topRight", "bottomLeft", "bottomRight"])
			if (e.containsPoint(this[n])) return n;
		return null;
	}
	equals(e) {
		return (
			e.x === this.x &&
			e.y === this.y &&
			e.width === this.width &&
			e.height === this.height
		);
	}
	pointEquals(e) {
		return this.x === e.x && this.y === e.y;
	}
	sizeEquals(e) {
		return this.width === e.width && this.height === e.height;
	}
	union(e) {
		let n = Math.min(this.x, e.x),
			r = Math.min(this.y, e.y),
			i = Math.max(this.maxX, e.maxX) - n,
			o = Math.max(this.maxY, e.maxY) - r;
		return new St(n, r, i, o);
	}
	intersection(e) {
		if (!this.intersects(e)) return new St(0, 0, 0, 0);
		let n = Math.max(this.x, e.x),
			r = Math.max(this.y, e.y);
		return new St(
			n,
			r,
			Math.min(this.maxX, e.maxX) - n,
			Math.min(this.maxY, e.maxY) - r,
		);
	}
	copy() {
		return new St(this.x, this.y, this.width, this.height);
	}
	constructor(e = 0, n = 0, r = 0, i = 0) {
		(this.x = e), (this.y = n), (this.width = r), (this.height = i);
	}
}
class bd {
	copy() {
		return new bd(this.width, this.height);
	}
	equals(e) {
		return this.width === e.width && this.height === e.height;
	}
	get area() {
		return this.width * this.height;
	}
	constructor(e = 0, n = 0) {
		(this.width = e), (this.height = n);
	}
}
let Hie = 0;
class $D {
	prepareForReuse() {
		(this.content = null), (this.rendered = null), (this.layoutInfo = null);
	}
	getReusableView(e) {
		let n = this.reusableViews.get(e),
			r =
				(n == null ? void 0 : n.length) > 0
					? n.shift()
					: new $D(this.virtualizer);
		return (r.viewType = e), (r.parent = this), r;
	}
	reuseChild(e) {
		e.prepareForReuse();
		let n = this.reusableViews.get(e.viewType);
		n || ((n = []), this.reusableViews.set(e.viewType, n)), n.push(e);
	}
	constructor(e) {
		(this.virtualizer = e),
			(this.key = ++Hie),
			(this.parent = null),
			(this.children = new Set()),
			(this.reusableViews = new Map());
	}
}
function Wie(t, e) {
	if (t === e) return !0;
	if (t.size !== e.size) return !1;
	for (let n of t) if (!e.has(n)) return !1;
	return !0;
}
class qie {
	setVisibleRect(e) {
		let n = performance.now() - this.startTime;
		n < 500 &&
			(e.x !== this.visibleRect.x &&
				n > 0 &&
				(this.velocity.x = (e.x - this.visibleRect.x) / n),
			e.y !== this.visibleRect.y &&
				n > 0 &&
				(this.velocity.y = (e.y - this.visibleRect.y) / n)),
			(this.startTime = performance.now()),
			(this.visibleRect = e);
	}
	getOverscannedRect() {
		let e = this.visibleRect.copy(),
			n = this.visibleRect.height / 3;
		if (
			((e.height += n),
			this.velocity.y < 0 && (e.y -= n),
			this.velocity.x !== 0)
		) {
			let r = this.visibleRect.width / 3;
			(e.width += r), this.velocity.x < 0 && (e.x -= r);
		}
		return e;
	}
	constructor() {
		(this.startTime = 0),
			(this.velocity = new Za(0, 0)),
			(this.visibleRect = new St());
	}
}
class Gie {
	isPersistedKey(e) {
		if (this.persistedKeys.has(e)) return !0;
		for (let n of this.persistedKeys)
			for (; n != null; ) {
				let r = this.layout.getLayoutInfo(n);
				if (!r) break;
				if (((n = r.parentKey), n === e)) return !0;
			}
		return !1;
	}
	getParentView(e) {
		return e.parentKey != null
			? this._visibleViews.get(e.parentKey)
			: this._rootView;
	}
	getReusableView(e) {
		let r = this.getParentView(e).getReusableView(e.type);
		return (r.layoutInfo = e), this._renderView(r), r;
	}
	_renderView(e) {
		let { type: n, key: r } = e.layoutInfo;
		(e.content = this.collection.getItem(r)),
			(e.rendered = this._renderContent(n, e.content));
	}
	_renderContent(e, n) {
		let r = this._renderedContent.get(n);
		if (r != null) return r;
		let i = this.delegate.renderView(e, n);
		return n && this._renderedContent.set(n, i), i;
	}
	keyAtPoint(e) {
		let n = new St(e.x, e.y, 1, 1),
			r = n.area === 0 ? [] : this.layout.getVisibleLayoutInfos(n);
		for (let i of r) if (i.rect.intersects(n)) return i.key;
		return null;
	}
	relayout(e = {}) {
		this.layout.update(e),
			(this.contentSize = this.layout.getContentSize());
		let n = this.visibleRect,
			r = e.contentChanged ? 0 : n.x,
			i = e.contentChanged ? 0 : n.y;
		if (
			((r = Math.max(0, Math.min(this.contentSize.width - n.width, r))),
			(i = Math.max(0, Math.min(this.contentSize.height - n.height, i))),
			r !== n.x || i !== n.y)
		) {
			let o = new St(r, i, n.width, n.height);
			this.delegate.setVisibleRect(o);
		} else this.updateSubviews();
	}
	getVisibleLayoutInfos() {
		let e;
		e = this._overscanManager.getOverscannedRect();
		let n = e.area === 0 ? [] : this.layout.getVisibleLayoutInfos(e),
			r = new Map();
		for (let i of n) r.set(i.key, i);
		return r;
	}
	updateSubviews() {
		let e = this.getVisibleLayoutInfos(),
			n = new Set();
		for (let [r, i] of this._visibleViews) {
			let o = e.get(r);
			(!o || i.parent !== this.getParentView(o)) &&
				(this._visibleViews.delete(r),
				i.parent.reuseChild(i),
				n.add(i));
		}
		for (let [r, i] of e) {
			let o = this._visibleViews.get(r);
			if (!o)
				(o = this.getReusableView(i)),
					o.parent.children.add(o),
					this._visibleViews.set(r, o),
					n.delete(o);
			else {
				o.layoutInfo = i;
				let s = this.collection.getItem(i.key);
				o.content !== s &&
					(this._renderedContent.delete(o.content),
					this._renderView(o));
			}
		}
		for (let r of n)
			r.parent.children.delete(r), r.parent.reusableViews.clear();
		if (!this._isScrolling)
			for (let r of e.keys()) {
				let i = this._visibleViews.get(r);
				i.parent.children.delete(i), i.parent.children.add(i);
			}
	}
	render(e) {
		let n = this,
			r = !1,
			i = !1,
			o = !1,
			s = !1,
			a = !1;
		return (
			e.collection !== this.collection &&
				((n.collection = e.collection), (r = !0)),
			e.layout !== this.layout &&
				(this.layout && (this.layout.virtualizer = null),
				(e.layout.virtualizer = this),
				(n.layout = e.layout),
				(r = !0)),
			e.persistedKeys &&
				!Wie(e.persistedKeys, this.persistedKeys) &&
				((n.persistedKeys = e.persistedKeys), (a = !0)),
			this.visibleRect.equals(e.visibleRect) ||
				(this._overscanManager.setVisibleRect(e.visibleRect),
				this.layout.shouldInvalidate(e.visibleRect, this.visibleRect)
					? ((i = !e.visibleRect.pointEquals(this.visibleRect)),
						(o = !e.visibleRect.sizeEquals(this.visibleRect)),
						(r = !0))
					: (a = !0),
				(n.visibleRect = e.visibleRect)),
			e.invalidationContext !== this._invalidationContext &&
				(e.invalidationContext &&
					(o || (o = e.invalidationContext.sizeChanged || !1),
					i || (i = e.invalidationContext.offsetChanged || !1),
					s || (s = e.invalidationContext.itemSizeChanged || !1),
					r || (r = s || o || i),
					r ||
						(r =
							e.invalidationContext.layoutOptions !==
							this._invalidationContext.layoutOptions)),
				(this._invalidationContext = e.invalidationContext)),
			e.isScrolling !== this._isScrolling &&
				((this._isScrolling = e.isScrolling),
				e.isScrolling || (a = !0)),
			r
				? this.relayout({
						offsetChanged: i,
						sizeChanged: o,
						itemSizeChanged: s,
						layoutOptions: this._invalidationContext.layoutOptions,
					})
				: a && this.updateSubviews(),
			Array.from(this._rootView.children)
		);
	}
	getVisibleView(e) {
		return this._visibleViews.get(e);
	}
	invalidate(e) {
		this.delegate.invalidate(e);
	}
	updateItemSize(e, n) {
		if (!this.layout.updateItemSize) return;
		this.layout.updateItemSize(e, n) &&
			this.invalidate({ itemSizeChanged: !0 });
	}
	constructor(e) {
		(this.delegate = e),
			(this.contentSize = new bd()),
			(this.visibleRect = new St()),
			(this.persistedKeys = new Set()),
			(this._visibleViews = new Map()),
			(this._renderedContent = new WeakMap()),
			(this._rootView = new $D(this)),
			(this._isScrolling = !1),
			(this._invalidationContext = null),
			(this._overscanManager = new qie());
	}
}
function DO(t) {
	let [e, n] = E.useState(new St(0, 0, 0, 0)),
		[r, i] = E.useState(!1),
		[o, s] = E.useState({}),
		a = E.useRef(!1),
		[l] = E.useState(
			() =>
				new Gie({
					setVisibleRect(g) {
						n(g), (a.current = !0);
					},
					renderView: t.renderView,
					invalidate: s,
				}),
		);
	at(() => {
		a.current && ((a.current = !1), t.onVisibleRectChange(e));
	});
	let u = E.useMemo(
			() =>
				t.layoutOptions != null
					? { ...o, layoutOptions: t.layoutOptions }
					: o,
			[o, t.layoutOptions],
		),
		c = l.render({
			layout: t.layout,
			collection: t.collection,
			persistedKeys: t.persistedKeys,
			layoutOptions: t.layoutOptions,
			visibleRect: e,
			invalidationContext: u,
			isScrolling: r,
		}),
		d = l.contentSize,
		f = E.useCallback(() => {
			i(!0);
		}, []),
		h = E.useCallback(() => {
			i(!1);
		}, []);
	return E.useMemo(
		() => ({
			virtualizer: l,
			visibleViews: c,
			setVisibleRect: n,
			contentSize: d,
			isScrolling: r,
			startScrolling: f,
			endScrolling: h,
		}),
		[l, c, n, d, r, f, h],
	);
}
function Yie(t, e) {
	e = Ct(e);
	let { scrollViewProps: n, contentProps: r } = Jie(t, e);
	return le.createElement(
		"div",
		{ role: "presentation", ...n, ref: e },
		le.createElement("div", { role: "presentation", ...r }, t.children),
	);
}
const SO = le.forwardRef(Yie);
function Jie(t, e) {
	let {
			contentSize: n,
			onVisibleRectChange: r,
			innerStyle: i,
			onScrollStart: o,
			onScrollEnd: s,
			scrollDirection: a = "both",
			...l
		} = t,
		u = E.useRef({
			scrollTop: 0,
			scrollLeft: 0,
			scrollEndTime: 0,
			scrollTimeout: null,
			width: 0,
			height: 0,
			isScrolling: !1,
		}).current,
		{ direction: c } = Vt(),
		[d, f] = E.useState(!1),
		h = E.useCallback(
			(y) => {
				y.target === y.currentTarget &&
					(t.onScroll && t.onScroll(y),
					nl.flushSync(() => {
						let x = y.currentTarget.scrollTop,
							C = Vie(y.currentTarget, c);
						(u.scrollTop = Math.max(
							0,
							Math.min(x, n.height - u.height),
						)),
							(u.scrollLeft = Math.max(
								0,
								Math.min(C, n.width - u.width),
							)),
							r(
								new St(
									u.scrollLeft,
									u.scrollTop,
									u.width,
									u.height,
								),
							),
							u.isScrolling ||
								((u.isScrolling = !0),
								f(!0),
								window.dispatchEvent(
									new Event("tk.disconnect-observer"),
								),
								o && o());
						let k = Date.now();
						u.scrollEndTime <= k + 50 &&
							((u.scrollEndTime = k + 300),
							clearTimeout(u.scrollTimeout),
							(u.scrollTimeout = setTimeout(() => {
								(u.isScrolling = !1),
									f(!1),
									(u.scrollTimeout = null),
									window.dispatchEvent(
										new Event("tk.connect-observer"),
									),
									s && s();
							}, 300)));
					}));
			},
			[t, c, u, n, r, o, s],
		);
	Lm(e, "scroll", h),
		E.useEffect(
			() => () => {
				clearTimeout(u.scrollTimeout),
					u.isScrolling &&
						window.dispatchEvent(new Event("tk.connect-observer"));
			},
			[],
		);
	let p = Pt((y) => {
			let x = e.current;
			if (!x) return;
			Object.getOwnPropertyNames(window.HTMLElement.prototype).includes(
				"clientWidth",
			),
				Object.getOwnPropertyNames(
					window.HTMLElement.prototype,
				).includes("clientHeight");
			let C = x.clientWidth,
				k = x.clientHeight,
				w = C,
				D = k;
			(u.width !== w || u.height !== D) &&
				((u.width = w),
				(u.height = D),
				y(() => {
					r(new St(u.scrollLeft, u.scrollTop, w, D));
				}),
				(C !== x.clientWidth || k !== x.clientHeight) &&
					((u.width = x.clientWidth),
					(u.height = x.clientHeight),
					y(() => {
						r(new St(u.scrollLeft, u.scrollTop, u.width, u.height));
					})));
		}),
		g = E.useRef(!1);
	at(() => {
		queueMicrotask(() => {
			g.current || ((g.current = !0), p(nl.flushSync));
		});
	}, [p]),
		E.useEffect(() => {
			g.current || ((g.current = !0), p((y) => y()));
		}, [p]);
	let v = E.useCallback(() => {
		p(nl.flushSync);
	}, [p]);
	fa({ ref: e, box: "border-box", onResize: v });
	let b = { padding: 0, ...l.style };
	return (
		a === "horizontal"
			? ((b.overflowX = "auto"), (b.overflowY = "hidden"))
			: a === "vertical" || n.width === u.width
				? ((b.overflowY = "auto"), (b.overflowX = "hidden"))
				: (b.overflow = "auto"),
		(i = {
			width: Number.isFinite(n.width) ? n.width : void 0,
			height: Number.isFinite(n.height) ? n.height : void 0,
			pointerEvents: d ? "none" : "auto",
			position: "relative",
			...i,
		}),
		{
			scrollViewProps: { ...l, style: b },
			contentProps: { role: "presentation", style: i },
		}
	);
}
function AO(t) {
	let { layoutInfo: e, virtualizer: n, ref: r } = t,
		i = E.useCallback(() => {
			if (e) {
				let o = Xie(r.current);
				n.updateItemSize(e.key, o);
			}
		}, [n, e == null ? void 0 : e.key, r]);
	return (
		at(() => {
			e != null && e.estimatedSize && i();
		}),
		{ updateSize: i }
	);
}
function Xie(t) {
	let e = t.style.height;
	t.style.height = "";
	let n = new bd(t.scrollWidth, t.scrollHeight);
	return (t.style.height = e), n;
}
function TD(t) {
	let {
			className: e,
			layoutInfo: n,
			virtualizer: r,
			parent: i,
			children: o,
		} = t,
		{ direction: s } = Vt(),
		a = E.useRef(void 0);
	return (
		AO({ layoutInfo: n, virtualizer: r, ref: a }),
		le.createElement(
			"div",
			{ role: "presentation", ref: a, className: e, style: yv(n, s, i) },
			o,
		)
	);
}
let X6 = new WeakMap();
function yv(t, e, n) {
	let r = e === "rtl" ? "right" : "left",
		i = X6.get(t);
	if (i && i[r] != null) {
		if (!n) return i;
		let a = t.rect.y - n.rect.y,
			l = t.rect.x - n.rect.x;
		if (i.top === a && i[r] === l) return i;
	}
	let o = {
		top: t.rect.y - (n ? n.rect.y : 0),
		[r]: t.rect.x - (n ? n.rect.x : 0),
		width: t.rect.width,
		height: t.rect.height,
	};
	Object.entries(o).forEach(([a, l]) => {
		Number.isFinite(l) || (o[a] = void 0);
	});
	let s = {
		position: t.isSticky ? "sticky" : "absolute",
		display: t.isSticky ? "inline-block" : void 0,
		overflow: t.allowOverflow ? "visible" : "hidden",
		opacity: t.opacity,
		zIndex: t.zIndex,
		transform: t.transform,
		contain: "size layout style",
		...o,
	};
	return X6.set(t, s), s;
}
function Zie(t, e) {
	let {
			children: n,
			renderWrapper: r,
			layout: i,
			collection: o,
			scrollDirection: s,
			isLoading: a,
			onLoadMore: l,
			persistedKeys: u,
			layoutOptions: c,
			...d
		} = t,
		f = E.useRef(void 0);
	e = e || f;
	let h = DO({
		layout: i,
		collection: o,
		renderView: n,
		onVisibleRectChange(g) {
			(e.current.scrollLeft = g.x), (e.current.scrollTop = g.y);
		},
		persistedKeys: u,
		layoutOptions: c,
	});
	a9({ isLoading: a, onLoadMore: l, scrollOffset: 1 }, e);
	let p = E.useCallback(
		(g) => {
			h.setVisibleRect(g);
		},
		[h],
	);
	return le.createElement(
		SO,
		{
			...xe(d, { onVisibleRectChange: p }),
			ref: e,
			contentSize: h.contentSize,
			onScrollStart: h.startScrolling,
			onScrollEnd: h.endScrolling,
			scrollDirection: s,
		},
		TO(null, h.visibleViews, r || Qie),
	);
}
const $O = le.forwardRef(Zie);
function TO(t, e, n) {
	return e.map((r) =>
		n(t, r, r.children ? Array.from(r.children) : [], (i) => TO(r, i, n)),
	);
}
function Qie(t, e) {
	return le.createElement(
		TD,
		{
			key: e.key,
			layoutInfo: e.layoutInfo,
			virtualizer: e.virtualizer,
			parent: t == null ? void 0 : t.layoutInfo,
		},
		e.rendered,
	);
}
function eoe(t, e, n) {
	let {
			isDisabled: r = !1,
			isReadOnly: i = !1,
			value: o,
			name: s,
			children: a,
			"aria-label": l,
			"aria-labelledby": u,
			validationState: c = "valid",
			isInvalid: d,
		} = t,
		f = (w) => {
			w.stopPropagation(), e.setSelected(w.target.checked);
		},
		h = a != null,
		p = l != null || u != null;
	!h &&
		!p &&
		console.warn(
			"If you do not provide children, you must specify an aria-label for accessibility",
		);
	let { pressProps: g, isPressed: v } = zi({ isDisabled: r }),
		{ pressProps: b, isPressed: y } = zi({
			isDisabled: r || i,
			onPress() {
				e.toggle();
			},
		}),
		{ focusableProps: x } = Hd(t, n),
		C = xe(g, x),
		k = Ge(t, { labelable: !0 });
	return (
		s0(n, e.isSelected, e.setSelected),
		{
			labelProps: xe(b, { onClick: (w) => w.preventDefault() }),
			inputProps: xe(k, {
				"aria-invalid": d || c === "invalid" || void 0,
				"aria-errormessage": t["aria-errormessage"],
				"aria-controls": t["aria-controls"],
				"aria-readonly": i || void 0,
				onChange: f,
				disabled: r,
				...(o == null ? {} : { value: o }),
				name: s,
				type: "checkbox",
				...C,
			}),
			isSelected: e.isSelected,
			isPressed: v || y,
			isDisabled: r,
			isReadOnly: i,
			isInvalid: d || c === "invalid",
		}
	);
}
function BO(t, e, n) {
	let r = Yd({ ...t, value: e.isSelected }),
		{
			isInvalid: i,
			validationErrors: o,
			validationDetails: s,
		} = r.displayValidation,
		{
			labelProps: a,
			inputProps: l,
			isSelected: u,
			isPressed: c,
			isDisabled: d,
			isReadOnly: f,
		} = eoe({ ...t, isInvalid: i }, e, n);
	Ax(t, r, n);
	let {
		isIndeterminate: h,
		isRequired: p,
		validationBehavior: g = "aria",
	} = t;
	return (
		E.useEffect(() => {
			n.current && (n.current.indeterminate = !!h);
		}),
		{
			labelProps: a,
			inputProps: {
				...l,
				checked: u,
				"aria-required": (p && g === "aria") || void 0,
				required: p && g === "native",
			},
			isSelected: u,
			isPressed: c,
			isDisabled: d,
			isReadOnly: f,
			isInvalid: i,
			validationErrors: o,
			validationDetails: s,
		}
	);
}
const toe = new WeakMap();
function noe(t, e, n) {
	const r = dD({
		isReadOnly: t.isReadOnly || e.isReadOnly,
		isSelected: e.isSelected(t.value),
		onChange(v) {
			v ? e.addValue(t.value) : e.removeValue(t.value),
				t.onChange && t.onChange(v);
		},
	});
	let {
		name: i,
		descriptionId: o,
		errorMessageId: s,
		validationBehavior: a,
	} = toe.get(e);
	var l;
	a = (l = t.validationBehavior) !== null && l !== void 0 ? l : a;
	let { realtimeValidation: u } = Yd({
			...t,
			value: r.isSelected,
			name: void 0,
			validationBehavior: "aria",
		}),
		c = E.useRef(Sf),
		d = () => {
			e.setInvalid(t.value, u.isInvalid ? u : c.current);
		};
	E.useEffect(d);
	let f = e.realtimeValidation.isInvalid ? e.realtimeValidation : u,
		h = a === "native" ? e.displayValidation : f;
	var p;
	let g = BO(
		{
			...t,
			isReadOnly: t.isReadOnly || e.isReadOnly,
			isDisabled: t.isDisabled || e.isDisabled,
			name: t.name || i,
			isRequired:
				(p = t.isRequired) !== null && p !== void 0 ? p : e.isRequired,
			validationBehavior: a,
			[Ym]: {
				realtimeValidation: f,
				displayValidation: h,
				resetValidation: e.resetValidation,
				commitValidation: e.commitValidation,
				updateValidation(v) {
					(c.current = v), d();
				},
			},
		},
		r,
		n,
	);
	return {
		...g,
		inputProps: {
			...g.inputProps,
			"aria-describedby":
				[t["aria-describedby"], e.isInvalid ? s : null, o]
					.filter(Boolean)
					.join(" ") || void 0,
		},
	};
}
const IO = m.jsx("path", { d: "M20 6 9 17l-5-5" }),
	Ix = m.jsx("path", { d: "M5 12h14" }),
	roe = le.createContext(null),
	z4 = new Gr("Checkbox", ["indicator"]);
function p0(t) {
	const e = ce(3),
		n = E.useContext(roe);
	let r;
	return (
		e[0] !== n || e[1] !== t
			? ((r = n
					? m.jsx(ioe, { groupState: n, ...t })
					: m.jsx(ooe, { ...t })),
				(e[0] = n),
				(e[1] = t),
				(e[2] = r))
			: (r = e[2]),
		r
	);
}
function ioe(t) {
	const e = ce(9);
	let n, r;
	e[0] !== t
		? (({ groupState: r, ...n } = t), (e[0] = t), (e[1] = n), (e[2] = r))
		: ((n = e[1]), (r = e[2]));
	const i = E.useRef(null);
	let o;
	e[3] !== n
		? ((o = { ...n, value: n.value }), (e[3] = n), (e[4] = o))
		: (o = e[4]);
	const { inputProps: s } = noe(o, r.state, i);
	let a;
	return (
		e[5] !== i || e[6] !== s || e[7] !== n
			? ((a = m.jsx(FO, { inputRef: i, inputProps: s, ...n })),
				(e[5] = i),
				(e[6] = s),
				(e[7] = n),
				(e[8] = a))
			: (a = e[8]),
		a
	);
}
function ooe(t) {
	const e = ce(4),
		n = E.useRef(null),
		{ inputProps: r } = BO(t, dD(t), n);
	let i;
	return (
		e[0] !== n || e[1] !== r || e[2] !== t
			? ((i = m.jsx(FO, { inputRef: n, inputProps: r, ...t })),
				(e[0] = n),
				(e[1] = r),
				(e[2] = t),
				(e[3] = i))
			: (i = e[3]),
		i
	);
}
function FO(t) {
	const e = ce(37);
	let n, r, i, o, s, a, l, u;
	e[0] !== t
		? (({
				autoFocus: a,
				children: u,
				inputProps: o,
				inputRef: s,
				isDisabled: n,
				isIndeterminate: r,
				prominence: l,
				...i
			} = t),
			(e[0] = t),
			(e[1] = n),
			(e[2] = r),
			(e[3] = i),
			(e[4] = o),
			(e[5] = s),
			(e[6] = a),
			(e[7] = l),
			(e[8] = u))
		: ((n = e[1]),
			(r = e[2]),
			(i = e[3]),
			(o = e[4]),
			(s = e[5]),
			(a = e[6]),
			(l = e[7]),
			(u = e[8]));
	const c = n === void 0 ? !1 : n,
		d = r === void 0 ? !1 : r,
		f = ht(i);
	let h, p, g;
	if (e[9] !== c || e[10] !== f.className) {
		const D = X({
			alignItems: "flex-start",
			display: "inline-flex",
			gap: B.size.space.regular,
			paddingInlineEnd: B.size.space.large,
			paddingBlock: B.size.space.regular,
			position: "relative",
			userSelect: "none",
		});
		let S, $;
		e[14] === Symbol.for("react.memo_cache_sentinel")
			? (($ = {
					text: { color: "inherit" },
					description: { color: "neutralTertiary" },
				}),
				(e[14] = $))
			: ($ = e[14]),
			(S = $),
			(h = S),
			(p = c),
			(g = Se(f.className, D)),
			(e[9] = c),
			(e[10] = f.className),
			(e[11] = h),
			(e[12] = p),
			(e[13] = g);
	} else (h = e[11]), (p = e[12]), (g = e[13]);
	let v;
	e[15] === Symbol.for("react.memo_cache_sentinel")
		? ((v = Se(
				X({
					position: "absolute",
					zIndex: 1,
					inset: 0,
					insetInlineStart: `calc(${B.size.space.regular} * -1)`,
					opacity: 1e-4,
				}),
			)),
			(e[15] = v))
		: (v = e[15]);
	let b;
	e[16] !== o || e[17] !== s
		? ((b = m.jsx("input", { ...o, ref: s, className: v })),
			(e[16] = o),
			(e[17] = s),
			(e[18] = b))
		: (b = e[18]);
	let y;
	e[19] !== a || e[20] !== b
		? ((y = m.jsx(xn, { autoFocus: a, children: b })),
			(e[19] = a),
			(e[20] = b),
			(e[21] = y))
		: (y = e[21]);
	let x;
	e[22] !== d || e[23] !== l
		? ((x = m.jsx(soe, { isIndeterminate: d, prominence: l })),
			(e[22] = d),
			(e[23] = l),
			(e[24] = x))
		: (x = e[24]);
	let C;
	e[25] !== u
		? ((C =
				u &&
				m.jsx(aoe, {
					children: $n(u) ? m.jsx(ue, { children: u }) : u,
				})),
			(e[25] = u),
			(e[26] = C))
		: (C = e[26]);
	let k;
	e[27] !== h || e[28] !== C
		? ((k = m.jsx(Cn, { slots: h, children: C })),
			(e[27] = h),
			(e[28] = C),
			(e[29] = k))
		: (k = e[29]);
	let w;
	return (
		e[30] !== p ||
		e[31] !== g ||
		e[32] !== f.style ||
		e[33] !== y ||
		e[34] !== x ||
		e[35] !== k
			? ((w = m.jsxs("label", {
					"data-disabled": p,
					className: g,
					style: f.style,
					children: [y, x, k],
				})),
				(e[30] = p),
				(e[31] = g),
				(e[32] = f.style),
				(e[33] = y),
				(e[34] = x),
				(e[35] = k),
				(e[36] = w))
			: (w = e[36]),
		w
	);
}
let ab = B.size.element.xsmall;
const soe = (t) => {
		let { isIndeterminate: e, prominence: n } = t;
		return m.jsx("span", {
			"data-prominence": n,
			className: Se(
				X({
					backgroundColor: B.color.background.canvas,
					borderRadius: B.size.radius.small,
					color: B.color.foreground.inverse,
					display: "flex",
					flexShrink: 0,
					justifyContent: "center",
					alignItems: "center",
					position: "relative",
					height: ab,
					width: ab,
					"--selected-idle-bg": B.color.scale.indigo9,
					"--selected-hover-bg": B.color.scale.indigo10,
					"--selected-pressed-bg": B.color.scale.indigo11,
					"&[data-prominence=low]": {
						"--selected-idle-bg": B.color.scale.slate9,
						"--selected-hover-bg": B.color.scale.slate10,
						"--selected-pressed-bg": B.color.scale.slate11,
					},
					[z4.selector("indicator")]: {
						opacity: 0,
						transform: "scale(0) translate3d(0, 0, 0)",
						transition: bt(["opacity", "transform"]),
						willChange: "opacity, transform",
					},
					"::after": {
						borderRadius: `calc(${B.size.alias.focusRingGap} + ${B.size.radius.small})`,
						content: '""',
						inset: 0,
						margin: 0,
						position: "absolute",
						transition: bt(["box-shadow", "margin"], {
							easing: "easeOut",
						}),
					},
					'input[type="checkbox"][data-focus=visible] + &::after': {
						boxShadow: `0 0 0 ${B.size.alias.focusRing} ${B.color.alias.focusRing}`,
						margin: `calc(${B.size.alias.focusRingGap} * -1)`,
					},
					"&::before": {
						border: `${B.size.border.medium} solid ${B.color.scale.slate8}`,
						borderRadius: "inherit",
						content: '""',
						inset: 0,
						margin: 0,
						position: "absolute",
						transition: bt(["border-color", "border-width"]),
					},
					'input[type="checkbox"]:disabled + &': {
						color: B.color.alias.foregroundDisabled,
						"&::before": {
							backgroundColor: B.color.alias.borderDisabled,
							borderColor: B.color.alias.borderDisabled,
						},
					},
					'input[type="checkbox"]:enabled:hover + &::before': {
						borderColor: B.color.scale.slate9,
					},
					'input[type="checkbox"]:enabled:active + &::before': {
						borderColor: B.color.scale.slate10,
					},
					'input[type="checkbox"]:checked + &, input[type="checkbox"]:indeterminate + &':
						{
							"&::before": { borderWidth: `calc(${ab} / 2)` },
							[z4.selector("indicator")]: {
								opacity: 1,
								transform: "scale(1)",
							},
						},
					'input[type="checkbox"]:enabled:checked + &::before, input[type="checkbox"]:enabled:indeterminate + &::before':
						{ borderColor: "var(--selected-idle-bg)" },
					'input[type="checkbox"]:enabled:checked:hover + &::before, input[type="checkbox"]:enabled:indeterminate:hover + &::before':
						{ borderColor: "var(--selected-hover-bg)" },
					'input[type="checkbox"]:enabled:checked:active + &::before, input[type="checkbox"]:enabled:indeterminate:active + &::before':
						{ borderColor: "var(--selected-pressed-bg)" },
				}),
			),
			children: m.jsx("span", {
				className: z4.element("indicator"),
				children: m.jsx(ve, {
					size: "small",
					src: e ? Ix : IO,
					strokeScaling: !1,
				}),
			}),
		});
	},
	aoe = (t) => {
		const e = ce(3);
		let n;
		e[0] === Symbol.for("react.memo_cache_sentinel")
			? ((n = Se(
					X({
						color: B.color.alias.foregroundIdle,
						display: "grid",
						gap: B.size.space.large,
						paddingTop: `calc((${ab} - ${B.typography.text.regular.capheight}) / 2)`,
						'input[type="checkbox"]:hover ~ &': {
							color: B.color.alias.foregroundHovered,
						},
						'input[type="checkbox"]:disabled ~ &': {
							color: B.color.alias.foregroundDisabled,
						},
					}),
				)),
				(e[0] = n))
			: (n = e[0]);
		let r;
		return (
			e[1] !== t
				? ((r = m.jsx("div", { className: n, ...t })),
					(e[1] = t),
					(e[2] = r))
				: (r = e[2]),
			r
		);
	},
	PO = m.jsxs(m.Fragment, {
		children: [
			m.jsx("circle", { cx: 9, cy: 12, r: 1 }),
			m.jsx("circle", { cx: 9, cy: 5, r: 1 }),
			m.jsx("circle", { cx: 9, cy: 19, r: 1 }),
			m.jsx("circle", { cx: 15, cy: 12, r: 1 }),
			m.jsx("circle", { cx: 15, cy: 5, r: 1 }),
			m.jsx("circle", { cx: 15, cy: 19, r: 1 }),
		],
	});
function loe(t, e) {
	let n = Ge(t, { labelable: !0 }),
		{ hoverProps: r } = gn({
			onHoverStart: () => (e == null ? void 0 : e.open(!0)),
			onHoverEnd: () => (e == null ? void 0 : e.close()),
		});
	return { tooltipProps: xe(n, r, { role: "tooltip" }) };
}
function uoe(t, e, n) {
	let { isDisabled: r, trigger: i } = t,
		o = Ot(),
		s = E.useRef(!1),
		a = E.useRef(!1),
		l = () => {
			(s.current || a.current) && e.open(a.current);
		},
		u = (b) => {
			!s.current && !a.current && e.close(b);
		};
	E.useEffect(() => {
		let b = (y) => {
			n &&
				n.current &&
				y.key === "Escape" &&
				(y.stopPropagation(), e.close(!0));
		};
		if (e.isOpen)
			return (
				document.addEventListener("keydown", b, !0),
				() => {
					document.removeEventListener("keydown", b, !0);
				}
			);
	}, [n, e]);
	let c = () => {
			i !== "focus" &&
				(gl() === "pointer" ? (s.current = !0) : (s.current = !1), l());
		},
		d = () => {
			i !== "focus" && ((a.current = !1), (s.current = !1), u());
		},
		f = () => {
			(a.current = !1), (s.current = !1), u(!0);
		},
		h = () => {
			ml() && ((a.current = !0), l());
		},
		p = () => {
			(a.current = !1), (s.current = !1), u(!0);
		},
		{ hoverProps: g } = gn({
			isDisabled: r,
			onHoverStart: c,
			onHoverEnd: d,
		}),
		{ focusableProps: v } = Hd({ isDisabled: r, onFocus: h, onBlur: p }, n);
	return {
		triggerProps: {
			"aria-describedby": e.isOpen ? o : void 0,
			...xe(v, g, { onPointerDown: f, onKeyDown: f }),
		},
		tooltipProps: { id: o },
	};
}
function Fx(t) {
	const e = ce(18);
	let n, r, i;
	e[0] !== t
		? (({ isOpen: i, isTransparent: r, ...n } = t),
			(e[0] = t),
			(e[1] = n),
			(e[2] = r),
			(e[3] = i))
		: ((n = e[1]), (r = e[2]), (i = e[3]));
	const o = ht(n);
	let s;
	e[4] !== n ? ((s = qd(n)), (e[4] = n), (e[5] = s)) : (s = e[5]);
	const a = r ? "transparent" : "translucent",
		l = i || void 0;
	let u;
	e[6] !== a || e[7] !== l
		? ((u = lt({ fill: a, open: l })), (e[6] = a), (e[7] = l), (e[8] = u))
		: (u = e[8]);
	let c;
	e[9] === Symbol.for("react.memo_cache_sentinel")
		? ((c = bt("opacity", {
				easing: "easeOut",
				duration: "regular",
				delay: "short",
			})),
			(e[9] = c))
		: (c = e[9]);
	let d;
	e[10] === Symbol.for("react.memo_cache_sentinel")
		? ((d = [
				c,
				bt("visibility", {
					delay: "regular",
					duration: 0,
					easing: "linear",
				}),
			]),
			(e[10] = d))
		: (d = e[10]);
	let f;
	e[11] !== o.className
		? ((f = Se(
				X({
					inset: 0,
					opacity: 0,
					overflow: "hidden",
					pointerEvents: "none",
					position: "fixed",
					visibility: "hidden",
					zIndex: 1,
					'&[data-fill="translucent"]': {
						backgroundColor: "#0006",
						transition: d.join(", "),
					},
					'&[data-open="true"]': {
						opacity: 1,
						pointerEvents: "auto",
						visibility: "visible",
						transition: bt("opacity", { easing: "easeIn" }),
					},
				}),
				o.className,
			)),
			(e[11] = o.className),
			(e[12] = f))
		: (f = e[12]);
	let h;
	return (
		e[13] !== s || e[14] !== u || e[15] !== o || e[16] !== f
			? ((h = m.jsx("div", { ...s, ...u, ...o, className: f })),
				(e[13] = s),
				(e[14] = u),
				(e[15] = o),
				(e[16] = f),
				(e[17] = h))
			: (h = e[17]),
		h
	);
}
function NO(t) {
	const e = ce(25);
	let n, r, i, o, s;
	e[0] !== t
		? (({ fill: n, placement: r, size: i, stroke: s, ...o } = t),
			(e[0] = t),
			(e[1] = n),
			(e[2] = r),
			(e[3] = i),
			(e[4] = o),
			(e[5] = s))
		: ((n = e[1]), (r = e[2]), (i = e[3]), (o = e[4]), (s = e[5]));
	let a;
	e[6] !== n || e[7] !== r || e[8] !== i
		? ((a = lt({ fill: n, placement: r, size: i })),
			(e[6] = n),
			(e[7] = r),
			(e[8] = i),
			(e[9] = a))
		: (a = e[9]);
	let l;
	e[10] !== o.className
		? ((l = Se(
				X({
					height: "var(--size)",
					position: "absolute",
					width: "var(--size)",
					'&[data-fill="surface"]': {
						fill: B.color.background.surface,
					},
					'&[data-fill="inverse"]': {
						fill: B.color.background.inverse,
					},
					'&[data-fill="accent"]': {
						fill: B.color.background.accentEmphasis,
					},
					'&[data-fill="critical"]': {
						fill: B.color.background.criticalEmphasis,
					},
					'&[data-fill="positive"]': {
						fill: B.color.background.positiveEmphasis,
					},
					'&[data-size="xsmall"]': {
						"--size": B.size.element.xsmall,
					},
					'&[data-size="small"]': { "--size": B.size.element.small },
					'&[data-size="regular"]': {
						"--size": B.size.element.regular,
					},
					'&[data-placement="top"], &[data-placement="bottom"]': {
						left: "50%",
						transform: "translateX(-50%)",
					},
					'&[data-placement="top"]': { top: "100%" },
					'&[data-placement="bottom"]': { bottom: "100%" },
					'&[data-placement="left"], &[data-placement="right"], &[data-placement="start"], &[data-placement="end"]':
						{ top: "50%", transform: "translateY(-50%)" },
					'&[data-placement="left"]': { left: "100%" },
					'&[data-placement="right"]': { right: "100%" },
					'&[data-placement="start"]': { insetInlineStart: "100%" },
					'&[data-placement="end"]': { insetInlineEnd: "100%" },
				}),
				o.className,
			)),
			(e[10] = o.className),
			(e[11] = l))
		: (l = e[11]);
	let u;
	e[12] === Symbol.for("react.memo_cache_sentinel")
		? ((u = X({
				'&[data-placement="top"]': { transform: "rotate(180deg)" },
				'&[data-placement="left"], [dir=ltr] &[data-placement="start"], [dir=rtl] &[data-placement="end"]':
					{ transform: "rotate(90deg)" },
				'&[data-placement="right"], [dir=ltr] &[data-placement="end"], [dir=rtl] &[data-placement="start"]':
					{ transform: "rotate(270deg)" },
			})),
			(e[12] = u))
		: (u = e[12]);
	let c;
	e[13] !== s
		? ((c =
				s &&
				m.jsx("path", {
					fill: s,
					d: "M23.7,27.1L17,19.9C16.5,19.3,15.8,19,15,19s-1.6,0.3-2.1,0.9l-6.6,7.2C5.3,28.1,3.4,29,2,29h26 C26.7,29,24.6,28.1,23.7,27.1z",
				})),
			(e[13] = s),
			(e[14] = c))
		: (c = e[14]);
	let d;
	e[15] === Symbol.for("react.memo_cache_sentinel")
		? ((d = m.jsx("path", {
				d: "M23,27.8c1.1,1.2,3.4,2.2,5,2.2h2H0h2c1.7,0,3.9-1,5-2.2l6.6-7.2c0.7-0.8,2-0.8,2.7,0L23,27.8L23,27.8z",
			})),
			(e[15] = d))
		: (d = e[15]);
	let f;
	e[16] !== r || e[17] !== c
		? ((f = m.jsxs("svg", {
				"data-placement": r,
				viewBox: "0 0 30 30",
				className: u,
				children: [c, d],
			})),
			(e[16] = r),
			(e[17] = c),
			(e[18] = f))
		: (f = e[18]);
	let h;
	return (
		e[19] !== o || e[20] !== a || e[21] !== r || e[22] !== l || e[23] !== f
			? ((h = m.jsx("span", {
					...o,
					...a,
					"data-placement": r,
					className: l,
					children: f,
				})),
				(e[19] = o),
				(e[20] = a),
				(e[21] = r),
				(e[22] = l),
				(e[23] = f),
				(e[24] = h))
			: (h = e[24]),
		h
	);
}
const coe = (t) => t.scrollTop,
	doe = function (e) {
		const n = ce(3),
			{ isOpen: r } = RO(e);
		if (!r) return null;
		let i;
		if (n[0] !== r || n[1] !== e) {
			var o;
			(i =
				(o = NP(e.children, {
					isOpen: r === "mounting" ? !1 : e.isOpen,
				})) !== null && o !== void 0
					? o
					: e.children),
				(n[0] = r),
				(n[1] = e),
				(n[2] = i);
		} else i = n[2];
		return i;
	};
function RO(t) {
	const e = ce(22),
		{
			isOpen: n,
			nodeRef: r,
			onEnter: i,
			onEntered: o,
			onEntering: s,
			onExit: a,
			onExited: l,
			onExiting: u,
		} = t,
		[c, d] = E.useState(n ? "mounting" : !1);
	n && !c && d("mounting");
	const f = E.useRef(!1);
	let h;
	e[0] !== n ||
	e[1] !== c ||
	e[2] !== o ||
	e[3] !== l ||
	e[4] !== i ||
	e[5] !== r.current ||
	e[6] !== s ||
	e[7] !== a ||
	e[8] !== u
		? ((h = () => {
				if (
					(!f.current &&
						n === c &&
						((f.current = !0),
						n ? o == null || o() : l == null || l()),
					n !== c)
				)
					if (((f.current = !1), n))
						i == null || i(),
							r.current && coe(r.current),
							d(!0),
							s == null || s();
					else {
						a == null || a(), u == null || u();
						const v = setTimeout(() => {
							d(!1);
						}, 320);
						return () => clearTimeout(v);
					}
			}),
			(e[0] = n),
			(e[1] = c),
			(e[2] = o),
			(e[3] = l),
			(e[4] = i),
			(e[5] = r.current),
			(e[6] = s),
			(e[7] = a),
			(e[8] = u),
			(e[9] = h))
		: (h = e[9]);
	let p;
	e[10] !== n ||
	e[11] !== c ||
	e[12] !== r ||
	e[13] !== i ||
	e[14] !== s ||
	e[15] !== a ||
	e[16] !== u ||
	e[17] !== o ||
	e[18] !== l
		? ((p = [n, c, r, i, s, a, u, o, l]),
			(e[10] = n),
			(e[11] = c),
			(e[12] = r),
			(e[13] = i),
			(e[14] = s),
			(e[15] = a),
			(e[16] = u),
			(e[17] = o),
			(e[18] = l),
			(e[19] = p))
		: (p = e[19]),
		E.useLayoutEffect(h, p);
	let g;
	return (
		e[20] !== c
			? ((g = { isOpen: c, setIsOpen: d }), (e[20] = c), (e[21] = g))
			: (g = e[21]),
		g
	);
}
const m0 = E.forwardRef(function (e, n) {
		const r = ce(10),
			{ isOpen: i } = RO(e);
		if (!i) return null;
		let o;
		r[0] === Symbol.for("react.memo_cache_sentinel")
			? ((o = { background: "transparent", isolation: "isolate" }),
				(r[0] = o))
			: (o = r[0]);
		let s;
		if (r[1] !== i || r[2] !== e) {
			var a;
			(s =
				(a = NP(e.children, {
					isOpen: i === "mounting" ? !1 : e.isOpen,
				})) !== null && a !== void 0
					? a
					: e.children),
				(r[1] = i),
				(r[2] = e),
				(r[3] = s);
		} else s = r[3];
		let l;
		r[4] !== n || r[5] !== s
			? ((l = m.jsx(Hh, {
					ref: n,
					UNSAFE_style: o,
					isDisabled: !1,
					children: s,
				})),
				(r[4] = n),
				(r[5] = s),
				(r[6] = l))
			: (l = r[6]);
		let u;
		return (
			r[7] !== e.container || r[8] !== l
				? ((u = m.jsx(fte, {
						portalContainer: e.container,
						children: l,
					})),
					(r[7] = e.container),
					(r[8] = l),
					(r[9] = u))
				: (u = r[9]),
			u
		);
	}),
	OO = E.forwardRef(function (e, n) {
		const r = ce(14);
		let i, o, s;
		r[0] !== e
			? (({ children: i, state: s, ...o } = e),
				(r[0] = e),
				(r[1] = i),
				(r[2] = o),
				(r[3] = s))
			: ((i = r[1]), (o = r[2]), (s = r[3]));
		const a = E.useRef(null);
		let l;
		r[4] !== n || r[5] !== e || r[6] !== a || r[7] !== i
			? ((l = m.jsx(foe, { ref: n, ...e, wrapperRef: a, children: i })),
				(r[4] = n),
				(r[5] = e),
				(r[6] = a),
				(r[7] = i),
				(r[8] = l))
			: (l = r[8]);
		let u;
		return (
			r[9] !== o || r[10] !== s.isOpen || r[11] !== a || r[12] !== l
				? ((u = m.jsx(m0, {
						...o,
						isOpen: s.isOpen,
						nodeRef: a,
						children: l,
					})),
					(r[9] = o),
					(r[10] = s.isOpen),
					(r[11] = a),
					(r[12] = l),
					(r[13] = u))
				: (u = r[13]),
			u
		);
	}),
	L4 = `--${Wd}-visual-viewport-height`,
	foe = E.forwardRef(function (e, n) {
		const r = ce(27),
			{ type: i, children: o, state: s, isOpen: a, wrapperRef: l } = e,
			u = Ct(n),
			{ modalProps: c, underlayProps: d } = rD(e, s, u),
			f = ht(e),
			h = s9();
		let p;
		r[0] !== d || r[1] !== a
			? ((p = m.jsx(Fx, { ...d, isOpen: a })),
				(r[0] = d),
				(r[1] = a),
				(r[2] = p))
			: (p = r[2]);
		let g;
		r[3] === Symbol.for("react.memo_cache_sentinel")
			? ((g = X({
					alignItems: "center",
					boxSizing: "border-box",
					display: "flex",
					insetBlockStart: 0,
					insetInlineStart: 0,
					justifyContent: "center",
					pointerEvents: "none",
					position: "fixed",
					width: "100vw",
					zIndex: 2,
				})),
				(r[3] = g))
			: (g = r[3]);
		const v = `${h.height}px`;
		let b;
		r[4] !== v
			? ((b = { [L4]: v, height: `var(${L4})` }), (r[4] = v), (r[5] = b))
			: (b = r[5]);
		let y;
		r[6] !== a || r[7] !== i
			? ((y = lt({ open: a, type: i })),
				(r[6] = a),
				(r[7] = i),
				(r[8] = y))
			: (y = r[8]);
		let x;
		r[9] === Symbol.for("react.memo_cache_sentinel")
			? ((x = bt("opacity", { easing: "easeIn" })), (r[9] = x))
			: (x = r[9]);
		let C;
		r[10] === Symbol.for("react.memo_cache_sentinel")
			? ((C = [
					x,
					bt("transform", {
						delay: "short",
						duration: 0,
						easing: "linear",
					}),
				]),
				(r[10] = C))
			: (C = r[10]);
		let k;
		r[11] !== f.className
			? ((k = Se(
					f.className,
					X({
						backgroundColor: B.color.background.surface,
						borderRadius: B.size.radius.large,
						boxShadow: `${B.size.shadow.large} ${B.color.shadow.emphasis}`,
						maxHeight: `calc(var(${L4}) * 0.9)`,
						maxWidth: "90vw",
						opacity: 0,
						outline: 0,
						pointerEvents: "auto",
						transform: `translateY(${B.size.space.large})`,
						zIndex: 2,
						transition: C.join(", "),
						'&[data-type="fullscreen"]': {
							position: "fixed",
							inset: B.size.space.xxlarge,
							maxWidth: "none",
							maxHeight: "none",
							width: `calc(100% - calc(2 * ${B.size.space.xxlarge}))`,
							height: `calc(100% - calc(2 * ${B.size.space.xxlarge}))`,
						},
						'&[data-open="true"]': {
							opacity: 1,
							transform: "translateY(0)",
							transition: bt(["opacity", "transform"], {
								easing: "easeOut",
							}),
						},
					}),
				)),
				(r[11] = f.className),
				(r[12] = k))
			: (k = r[12]);
		let w;
		r[13] !== c ||
		r[14] !== y ||
		r[15] !== f ||
		r[16] !== u ||
		r[17] !== k ||
		r[18] !== o
			? ((w = m.jsx("div", {
					...c,
					...y,
					...f,
					ref: u,
					className: k,
					children: o,
				})),
				(r[13] = c),
				(r[14] = y),
				(r[15] = f),
				(r[16] = u),
				(r[17] = k),
				(r[18] = o),
				(r[19] = w))
			: (w = r[19]);
		let D;
		r[20] !== b || r[21] !== w
			? ((D = m.jsx("div", { className: g, style: b, children: w })),
				(r[20] = b),
				(r[21] = w),
				(r[22] = D))
			: (D = r[22]);
		let S;
		return (
			r[23] !== l || r[24] !== p || r[25] !== D
				? ((S = m.jsxs("div", { ref: l, children: [p, D] })),
					(r[23] = l),
					(r[24] = p),
					(r[25] = D),
					(r[26] = S))
				: (S = r[26]),
			S
		);
	}),
	g0 = E.forwardRef(function (e, n) {
		const r = ce(14);
		let i, o, s;
		r[0] !== e
			? (({ children: i, state: s, ...o } = e),
				(r[0] = e),
				(r[1] = i),
				(r[2] = o),
				(r[3] = s))
			: ((i = r[1]), (o = r[2]), (s = r[3]));
		const a = E.useRef(null);
		let l;
		r[4] !== n || r[5] !== e || r[6] !== a || r[7] !== i
			? ((l = m.jsx(hoe, { ref: n, ...e, wrapperRef: a, children: i })),
				(r[4] = n),
				(r[5] = e),
				(r[6] = a),
				(r[7] = i),
				(r[8] = l))
			: (l = r[8]);
		let u;
		return (
			r[9] !== o || r[10] !== s.isOpen || r[11] !== a || r[12] !== l
				? ((u = m.jsx(m0, {
						...o,
						isOpen: s.isOpen,
						nodeRef: a,
						children: l,
					})),
					(r[9] = o),
					(r[10] = s.isOpen),
					(r[11] = a),
					(r[12] = l),
					(r[13] = u))
				: (u = r[13]),
			u
		);
	}),
	hoe = E.forwardRef(function (e, n) {
		const r = ce(35),
			{
				children: i,
				isOpen: o,
				hideArrow: s,
				isNonModal: a,
				state: l,
				wrapperRef: u,
			} = e,
			c = Ct(n);
		let d;
		r[0] !== e || r[1] !== c
			? ((d = {
					...e,
					containerPadding: 8,
					popoverRef: c,
					maxHeight: null,
				}),
				(r[0] = e),
				(r[1] = c),
				(r[2] = d))
			: (d = r[2]);
		const {
				popoverProps: f,
				arrowProps: h,
				underlayProps: p,
				placement: g,
			} = cte(d, l),
			v = g;
		let b;
		r[3] !== e || r[4] !== v
			? ((b = { ...e, placement: v }), (r[3] = e), (r[4] = v), (r[5] = b))
			: (b = r[5]);
		const y = poe(b);
		let x;
		r[6] !== a || r[7] !== p || r[8] !== o
			? ((x = !a && m.jsx(Fx, { isTransparent: !0, ...p, isOpen: o })),
				(r[6] = a),
				(r[7] = p),
				(r[8] = o),
				(r[9] = x))
			: (x = r[9]);
		let C;
		r[10] !== y.style || r[11] !== f.style
			? ((C = { ...y.style, ...f.style }),
				(r[10] = y.style),
				(r[11] = f.style),
				(r[12] = C))
			: (C = r[12]);
		let k;
		r[13] !== a || r[14] !== l
			? ((k = !a && m.jsx(Hm, { onDismiss: l.close })),
				(r[13] = a),
				(r[14] = l),
				(r[15] = k))
			: (k = r[15]);
		let w;
		r[16] !== s || r[17] !== g || r[18] !== h
			? ((w = s
					? null
					: m.jsx(NO, {
							...h,
							fill: "surface",
							stroke: B.color.border.emphasis,
							placement: g,
							size: "regular",
						})),
				(r[16] = s),
				(r[17] = g),
				(r[18] = h),
				(r[19] = w))
			: (w = r[19]);
		let D;
		r[20] !== l.close
			? ((D = m.jsx(Hm, { onDismiss: l.close })),
				(r[20] = l.close),
				(r[21] = D))
			: (D = r[21]);
		let S;
		r[22] !== y ||
		r[23] !== f ||
		r[24] !== C ||
		r[25] !== c ||
		r[26] !== k ||
		r[27] !== w ||
		r[28] !== i ||
		r[29] !== D
			? ((S = m.jsxs("div", {
					...y,
					...f,
					style: C,
					ref: c,
					role: "presentation",
					children: [k, w, i, D],
				})),
				(r[22] = y),
				(r[23] = f),
				(r[24] = C),
				(r[25] = c),
				(r[26] = k),
				(r[27] = w),
				(r[28] = i),
				(r[29] = D),
				(r[30] = S))
			: (S = r[30]);
		let $;
		return (
			r[31] !== u || r[32] !== x || r[33] !== S
				? (($ = m.jsxs("div", { ref: u, children: [x, S] })),
					(r[31] = u),
					(r[32] = x),
					(r[33] = S),
					(r[34] = $))
				: ($ = r[34]),
			$
		);
	});
function poe(t) {
	const e = ce(19),
		{ hideArrow: n, isOpen: r, placement: i } = t,
		o = ht(t);
	let s;
	e[0] === Symbol.for("react.memo_cache_sentinel")
		? ((s = bt("opacity", { easing: "easeIn" })), (e[0] = s))
		: (s = e[0]);
	let a;
	e[1] === Symbol.for("react.memo_cache_sentinel")
		? ((a = [
				s,
				bt("transform", {
					delay: "short",
					duration: 0,
					easing: "linear",
				}),
			]),
			(e[1] = a))
		: (a = e[1]);
	let l, u;
	if (e[2] !== n || e[3] !== r || e[4] !== i || e[5] !== o.className) {
		const h = X({
				backgroundColor: B.color.background.surface,
				borderRadius: B.size.radius.medium,
				border: `${B.size.border.regular} solid ${B.color.border.emphasis}`,
				boxSizing: "content-box",
				opacity: 0,
				outline: 0,
				pointerEvents: "auto",
				position: "absolute",
				filter: `drop-shadow(0 1px 4px ${B.color.shadow.regular})`,
				willChange: "filter, transform",
				transition: a.join(", "),
				"&[data-placement=top]": { marginTop: B.size.space.regular },
				"&[data-placement=bottom]": {
					marginBottom: B.size.space.regular,
				},
				"&[data-placement=left]": { marginLeft: B.size.space.regular },
				"&[data-placement=right]": {
					marginRight: B.size.space.regular,
				},
				"&[data-open]": {
					opacity: 1,
					transition: bt(["opacity", "transform"], {
						easing: "easeOut",
					}),
				},
				"&[data-placement=top][data-open]": {
					transform: "translateY(calc(var(--popover-offset) * -1))",
				},
				"&[data-placement=bottom][data-open]": {
					transform: "translateY(var(--popover-offset))",
				},
				"&[data-placement=left][data-open]": {
					transform: "translateX(calc(var(--popover-offset) * -1))",
				},
				"&[data-placement=right][data-open]": {
					transform: "translateX(var(--popover-offset))",
				},
			}),
			p = !n || void 0,
			g = r || void 0;
		e[8] !== p || e[9] !== i || e[10] !== g
			? ((l = lt({ arrow: p, placement: i, open: g })),
				(e[8] = p),
				(e[9] = i),
				(e[10] = g),
				(e[11] = l))
			: (l = e[11]),
			(u = Se(h, o.className)),
			(e[2] = n),
			(e[3] = r),
			(e[4] = i),
			(e[5] = o.className),
			(e[6] = l),
			(e[7] = u);
	} else (l = e[6]), (u = e[7]);
	const c = n ? B.size.space.regular : B.size.space.large;
	let d;
	e[12] !== c || e[13] !== o.style
		? ((d = { "--popover-offset": c, ...o.style }),
			(e[12] = c),
			(e[13] = o.style),
			(e[14] = d))
		: (d = e[14]);
	let f;
	return (
		e[15] !== l || e[16] !== u || e[17] !== d
			? ((f = { ...l, className: u, style: d }),
				(e[15] = l),
				(e[16] = u),
				(e[17] = d),
				(e[18] = f))
			: (f = e[18]),
		f
	);
}
const Px = E.forwardRef(function (e, n) {
	const r = ce(14);
	let i, o, s;
	r[0] !== e
		? (({ children: i, state: s, ...o } = e),
			(r[0] = e),
			(r[1] = i),
			(r[2] = o),
			(r[3] = s))
		: ((i = r[1]), (o = r[2]), (s = r[3]));
	const a = E.useRef(null);
	let l;
	r[4] !== n || r[5] !== e || r[6] !== a || r[7] !== i
		? ((l = m.jsx(moe, { ref: n, ...e, wrapperRef: a, children: i })),
			(r[4] = n),
			(r[5] = e),
			(r[6] = a),
			(r[7] = i),
			(r[8] = l))
		: (l = r[8]);
	let u;
	return (
		r[9] !== o || r[10] !== s.isOpen || r[11] !== a || r[12] !== l
			? ((u = m.jsx(m0, {
					...o,
					isOpen: s.isOpen,
					nodeRef: a,
					children: l,
				})),
				(r[9] = o),
				(r[10] = s.isOpen),
				(r[11] = a),
				(r[12] = l),
				(r[13] = u))
			: (u = r[13]),
		u
	);
});
let moe = E.forwardRef(function (e, n) {
	let {
			children: r,
			state: i,
			isFixedHeight: o,
			isOpen: s,
			wrapperRef: a,
		} = e,
		l = Ct(n),
		{ modalProps: u, underlayProps: c } = rD(
			{ ...e, isDismissable: !0 },
			i,
			l,
		),
		d = ht(e),
		f = s9();
	return m.jsxs("div", {
		ref: a,
		children: [
			m.jsx(Fx, { ...c, isOpen: s }),
			m.jsx("div", {
				className: X({
					boxSizing: "border-box",
					display: "flex",
					insetBlockStart: 0,
					insetInlineStart: 0,
					justifyContent: "center",
					pointerEvents: "none",
					position: "fixed",
					height: "100vh",
					width: "100%",
					zIndex: 2,
				}),
				style: { height: f.height },
				children: m.jsx("div", {
					...u,
					...lt({ open: s, fillScreen: o || void 0 }),
					ref: l,
					style: Object.assign(
						{},
						o
							? {
									height: `calc(${f.height}px - ${B.size.space.xxlarge})`,
									top: B.size.space.xxlarge,
								}
							: {},
						{
							maxHeight: `calc(${f.height}px - ${B.size.space.xxlarge})`,
							paddingBottom: `max(calc(100vh - ${f.height}px), env(safe-area-inset-bottom))`,
						},
						d.style,
					),
					className: Se(
						d.className,
						X({
							backgroundColor: B.color.background.surface,
							bottom: 0,
							maxWidth: "100vw",
							opacity: 0,
							outline: 0,
							pointerEvents: "auto",
							position: "absolute",
							transform: "translateY(100%)",
							width: "100%",
							zIndex: 2,
							[en.above.mobile]: {
								borderStartStartRadius: B.size.radius.medium,
								borderStartEndRadius: B.size.radius.medium,
								maxWidth: Pn.tablet,
							},
							transition: bt(["opacity", "transform"], {
								easing: "easeIn",
							}),
							'&[data-open="true"]': {
								opacity: 1,
								transform: "translateY(0)",
								transition: bt(["opacity", "transform"], {
									easing: "easeOut",
									delay: "short",
								}),
							},
						}),
					),
					children: r,
				}),
			}),
		],
	});
});
function Bl(t) {
	let [e, n] = Ns(t.isOpen, t.defaultOpen || !1, t.onOpenChange);
	const r = E.useCallback(() => {
			n(!0);
		}, [n]),
		i = E.useCallback(() => {
			n(!1);
		}, [n]),
		o = E.useCallback(() => {
			n(!e);
		}, [n, e]);
	return { isOpen: e, setOpen: n, open: r, close: i, toggle: o };
}
const goe = 1500,
	Z6 = 500;
let cc = {},
	boe = 0,
	Tp = !1,
	_a = null,
	dc = null;
function voe(t = {}) {
	let { delay: e = goe, closeDelay: n = Z6 } = t,
		{ isOpen: r, open: i, close: o } = Bl(t),
		s = E.useMemo(() => `${++boe}`, []),
		a = E.useRef(void 0),
		l = E.useRef(o),
		u = () => {
			cc[s] = f;
		},
		c = () => {
			for (let p in cc) p !== s && (cc[p](!0), delete cc[p]);
		},
		d = () => {
			clearTimeout(a.current),
				(a.current = null),
				c(),
				u(),
				(Tp = !0),
				i(),
				_a && (clearTimeout(_a), (_a = null)),
				dc && (clearTimeout(dc), (dc = null));
		},
		f = (p) => {
			p || n <= 0
				? (clearTimeout(a.current), (a.current = null), l.current())
				: a.current ||
					(a.current = setTimeout(() => {
						(a.current = null), l.current();
					}, n)),
				_a && (clearTimeout(_a), (_a = null)),
				Tp &&
					(dc && clearTimeout(dc),
					(dc = setTimeout(
						() => {
							delete cc[s], (dc = null), (Tp = !1);
						},
						Math.max(Z6, n),
					)));
		},
		h = () => {
			c(),
				u(),
				!r && !_a && !Tp
					? (_a = setTimeout(() => {
							(_a = null), (Tp = !0), d();
						}, e))
					: r || d();
		};
	return (
		E.useEffect(() => {
			l.current = o;
		}, [o]),
		E.useEffect(
			() => () => {
				clearTimeout(a.current), cc[s] && delete cc[s];
			},
			[s],
		),
		{
			isOpen: r,
			open: (p) => {
				!p && e > 0 && !a.current ? h() : d();
			},
			close: f,
		}
	);
}
const MO = le.createContext({}),
	Xe = E.forwardRef(function (e, n) {
		var r, i, o;
		const s = ce(61),
			a = E.useContext(MO);
		let l, u, c, d;
		if (s[0] !== a) {
			const {
				state: se,
				targetRef: re,
				overlayRef: he,
				crossOffset: ye,
				offset: Ae,
				...Pe
			} = a;
			(u = se),
				(d = re),
				(c = he),
				(l = Pe),
				(s[0] = a),
				(s[1] = l),
				(s[2] = u),
				(s[3] = c),
				(s[4] = d);
		} else (l = s[1]), (u = s[2]), (c = s[3]), (d = s[4]);
		let f;
		s[5] !== e || s[6] !== l
			? ((f = xe(e, l)), (s[5] = e), (s[6] = l), (s[7] = f))
			: (f = s[7]),
			(e = f);
		let h, p, g;
		s[8] !== e
			? (({ isOpen: p, tone: g, ...h } = e),
				(s[8] = e),
				(s[9] = h),
				(s[10] = p),
				(s[11] = g))
			: ((h = s[9]), (p = s[10]), (g = s[11]));
		const v = B.size.space.regular,
			{ tooltipProps: b } = loe(l, u),
			y = ht(h),
			x = E.useRef(null);
		let C;
		s[12] !== c || s[13] !== n
			? ((C = c ? IQ(c, n) : n), (s[12] = c), (s[13] = n), (s[14] = C))
			: (C = s[14]);
		const k = Ct(C),
			w = (r = d) !== null && r !== void 0 ? r : x;
		let D, S;
		s[15] === Symbol.for("react.memo_cache_sentinel")
			? ((S = {
					icon: { size: "small", color: "inherit" },
					text: { size: "small", color: "inherit" },
					kbd: { size: "small", color: "inherit" },
				}),
				(s[15] = S))
			: (S = s[15]),
			(D = S);
		const $ = D,
			A = l.placement || "top",
			T = (i = u) === null || i === void 0 ? void 0 : i.isOpen;
		let I;
		s[16] !== l || s[17] !== A || s[18] !== T || s[19] !== k || s[20] !== w
			? ((I = {
					...l,
					placement: A,
					isOpen: T,
					overlayRef: k,
					targetRef: w,
				}),
				(s[16] = l),
				(s[17] = A),
				(s[18] = T),
				(s[19] = k),
				(s[20] = w),
				(s[21] = I))
			: (I = s[21]);
		const { overlayProps: F, arrowProps: N, placement: O } = ZE(I),
			_ = O || A;
		let j, V, K, M;
		s[22] !== _ ||
		s[23] !== F ||
		s[24] !== b ||
		s[25] !== h ||
		s[26] !== p ||
		s[27] !== g
			? ((j = _.split(" ")[0]),
				s[32] !== F || s[33] !== b
					? ((V = xe(F, b)), (s[32] = F), (s[33] = b), (s[34] = V))
					: (V = s[34]),
				s[35] !== h
					? ((K = Ge(h)), (s[35] = h), (s[36] = K))
					: (K = s[36]),
				(M = lt({ placement: j, tone: g, open: p || void 0 })),
				(s[22] = _),
				(s[23] = F),
				(s[24] = b),
				(s[25] = h),
				(s[26] = p),
				(s[27] = g),
				(s[28] = j),
				(s[29] = V),
				(s[30] = K),
				(s[31] = M))
			: ((j = s[28]), (V = s[29]), (K = s[30]), (M = s[31]));
		let G;
		s[37] !== y.className
			? ((G = Se(
					X({
						backgroundColor: B.color.background.inverse,
						color: B.color.foreground.inverse,
						borderRadius: B.size.radius.small,
						maxWidth: B.size.alias.singleLineWidth,
						minHeight: B.size.element.small,
						paddingBlock: B.size.space.regular,
						paddingInline: B.size.space.regular,
						opacity: 0,
						pointerEvents: "none",
						transition: bt(["opacity", "transform"]),
						userSelect: "none",
						'&[data-tone="accent"]': {
							backgroundColor: B.color.background.accentEmphasis,
							color: B.color.foreground.onEmphasis,
						},
						'&[data-tone="critical"]': {
							backgroundColor:
								B.color.background.criticalEmphasis,
							color: B.color.foreground.onEmphasis,
						},
						'&[data-tone="positive"]': {
							backgroundColor:
								B.color.background.positiveEmphasis,
							color: B.color.foreground.onEmphasis,
						},
						'&[data-placement="top"]': {
							marginBottom: v,
							transform: `translateY(calc(${v} * 0.5))`,
						},
						'&[data-placement="bottom"]': {
							marginTop: v,
							transform: `translateY(calc(${v} * -0.5))`,
						},
						'&[data-placement="left"], [dir=ltr] &[data-placement="start"], [dir=rtl] &[data-placement="end"]':
							{
								marginRight: v,
								transform: `translateX(calc(${v} * 0.5))`,
							},
						'&[data-placement="right"], [dir=ltr] &[data-placement="end"], [dir=rtl] &[data-placement="start"]':
							{
								marginLeft: v,
								transform: `translateX(calc(${v} * -0.5))`,
							},
						'&[data-open="true"]': {
							opacity: 1,
							transform: "translate(0)",
						},
					}),
					y.className,
				)),
				(s[37] = y.className),
				(s[38] = G))
			: (G = s[38]);
		let H;
		s[39] !== F.style || s[40] !== b.style || s[41] !== y.style
			? ((H = { ...F.style, ...b.style, ...y.style }),
				(s[39] = F.style),
				(s[40] = b.style),
				(s[41] = y.style),
				(s[42] = H))
			: (H = s[42]);
		let P;
		s[43] === Symbol.for("react.memo_cache_sentinel")
			? ((P = X({
					alignItems: "center",
					boxSizing: "border-box",
					display: "flex",
					gap: B.size.space.small,
				})),
				(s[43] = P))
			: (P = s[43]);
		let q;
		s[44] !== e.children
			? ((q =
					e.children &&
					($n(e.children)
						? m.jsx(ue, { children: e.children })
						: e.children)),
				(s[44] = e.children),
				(s[45] = q))
			: (q = s[45]);
		let J;
		s[46] !== q
			? ((J = m.jsx("div", {
					className: P,
					children: m.jsx(Cn, { slots: $, children: q }),
				})),
				(s[46] = q),
				(s[47] = J))
			: (J = s[47]);
		const Z = yoe[(o = g) !== null && o !== void 0 ? o : "neutral"],
			oe = j;
		let ne;
		s[48] !== N || s[49] !== Z || s[50] !== oe
			? ((ne = m.jsx(NO, {
					...N,
					fill: Z,
					placement: oe,
					size: "xsmall",
				})),
				(s[48] = N),
				(s[49] = Z),
				(s[50] = oe),
				(s[51] = ne))
			: (ne = s[51]);
		let de;
		return (
			s[52] !== V ||
			s[53] !== K ||
			s[54] !== M ||
			s[55] !== k ||
			s[56] !== G ||
			s[57] !== H ||
			s[58] !== J ||
			s[59] !== ne
				? ((de = m.jsxs("div", {
						...V,
						...K,
						...M,
						ref: k,
						className: G,
						style: H,
						children: [J, ne],
					})),
					(s[52] = V),
					(s[53] = K),
					(s[54] = M),
					(s[55] = k),
					(s[56] = G),
					(s[57] = H),
					(s[58] = J),
					(s[59] = ne),
					(s[60] = de))
				: (de = s[60]),
			de
		);
	}),
	yoe = {
		accent: "accent",
		critical: "critical",
		neutral: "inverse",
		positive: "positive",
	},
	xoe = 600;
function bw(t) {
	const e = ce(32);
	let n, r, i, o;
	e[0] !== t
		? (({ children: i, isDisabled: n, trigger: r, ...o } = t),
			(e[0] = t),
			(e[1] = n),
			(e[2] = r),
			(e[3] = i),
			(e[4] = o))
		: ((n = e[1]), (r = e[2]), (i = e[3]), (o = e[4]));
	const s = E.useRef(null),
		a = E.useRef(null);
	let l;
	e[5] !== n || e[6] !== r || e[7] !== t
		? ((l = { isDisabled: n, delay: xoe, trigger: r, ...t }),
			(e[5] = n),
			(e[6] = r),
			(e[7] = t),
			(e[8] = l))
		: (l = e[8]);
	const u = voe(l);
	let c;
	e[9] !== n || e[10] !== r
		? ((c = { isDisabled: n, trigger: r }),
			(e[9] = n),
			(e[10] = r),
			(e[11] = c))
		: (c = e[11]);
	const { triggerProps: d, tooltipProps: f } = uoe(c, u, s);
	let h;
	e[12] !== i
		? ((h = le.Children.toArray(i)), (e[12] = i), (e[13] = h))
		: (h = e[13]);
	const [p, g] = h;
	let v;
	e[14] !== a || e[15] !== s || e[16] !== u || e[17] !== o || e[18] !== f
		? ((v = { overlayRef: a, targetRef: s, state: u, ...o, ...f }),
			(e[14] = a),
			(e[15] = s),
			(e[16] = u),
			(e[17] = o),
			(e[18] = f),
			(e[19] = v))
		: (v = e[19]);
	let b;
	e[20] !== u.isOpen || e[21] !== a || e[22] !== g
		? ((b = m.jsx(m0, { isOpen: u.isOpen, nodeRef: a, children: g })),
			(e[20] = u.isOpen),
			(e[21] = a),
			(e[22] = g),
			(e[23] = b))
		: (b = e[23]);
	let y;
	e[24] !== v || e[25] !== b
		? ((y = m.jsx(MO.Provider, { value: v, children: b })),
			(e[24] = v),
			(e[25] = b),
			(e[26] = y))
		: (y = e[26]);
	let x;
	return (
		e[27] !== d || e[28] !== s || e[29] !== p || e[30] !== y
			? ((x = m.jsxs(rte, { ...d, ref: s, children: [p, y] })),
				(e[27] = d),
				(e[28] = s),
				(e[29] = p),
				(e[30] = y),
				(e[31] = x))
			: (x = e[31]),
		x
	);
}
bw.getCollectionNode = function* (t) {
	let e = [];
	le.Children.forEach(t.children, (i) => {
		le.isValidElement(i) && e.push(i);
	});
	let [n, r] = e;
	yield {
		element: n,
		wrapper: (i) => m.jsxs(bw, { ...t, children: [i, r] }, i.key),
	};
};
let Ze = bw;
const koe = m.jsx("path", { d: "m5 12 7-7 7 7M12 19V5" });
var yn;
(function (t) {
	(t[(t.none = 0)] = "none"),
		(t[(t.cancel = 0)] = "cancel"),
		(t[(t.move = 1)] = "move"),
		(t[(t.copy = 2)] = "copy"),
		(t[(t.link = 4)] = "link"),
		(t[(t.all = 7)] = "all");
})(yn || (yn = {}));
const jO = {
		...yn,
		copyMove: 3,
		copyLink: 6,
		linkMove: 5,
		all: 7,
		uninitialized: 7,
	},
	_O = BD(jO);
_O[7] = "all";
BD(yn);
const gm = { none: "cancel", link: "link", copy: "copy", move: "move" },
	V4 = BD(gm);
function BD(t) {
	let e = {};
	for (let n in t) e[t[n]] = n;
	return e;
}
const Coe = new Set(["text/plain", "text/uri-list", "text/html"]),
	xv = "application/vnd.react-aria.items+json",
	kv = "application/octet-stream",
	ID = new WeakMap(),
	zO = Symbol();
function woe(t) {
	let { id: e } = ID.get(t);
	if (!e) throw new Error("Droppable item outside a droppable collection");
	return e;
}
function Eoe(t) {
	let { ref: e } = ID.get(t);
	if (!e) throw new Error("Droppable item outside a droppable collection");
	return e;
}
function Gc(t) {
	let e = new Set();
	for (let n of t) for (let r of Object.keys(n)) e.add(r);
	return e;
}
function LO(t) {
	return (
		t || (t = "virtual"),
		t === "pointer" && (t = "virtual"),
		t === "virtual" &&
			typeof window < "u" &&
			"ontouchstart" in window &&
			(t = "touch"),
		t
	);
}
function FD() {
	return LO(fx());
}
function VO() {
	return LO(gl());
}
function Doe(t, e) {
	let n = new Map(),
		r = !1,
		i = [];
	for (let o of e) {
		let s = Object.keys(o);
		s.length > 1 && (r = !0);
		let a = {};
		for (let l of s) {
			let u = n.get(l);
			u ? (r = !0) : ((u = []), n.set(l, u));
			let c = o[l];
			(a[l] = c), u.push(c);
		}
		i.push(a);
	}
	for (let [o, s] of n)
		if (Coe.has(o)) {
			let a = s.join(`
`);
			t.items.add(a, o);
		} else t.items.add(s[0], o);
	if (r) {
		let o = JSON.stringify(i);
		t.items.add(o, xv);
	}
}
class g1 {
	has(e) {
		return this.includesUnknownTypes || (e === zO && this.types.has(kv))
			? !0
			: typeof e == "string" && this.types.has(e);
	}
	constructor(e) {
		this.types = new Set();
		let n = !1;
		for (let r of e.items)
			r.type !== xv &&
				(r.kind === "file" && (n = !0),
				r.type ? this.types.add(r.type) : this.types.add(kv));
		this.includesUnknownTypes = !n && e.types.includes("Files");
	}
}
function Soe(t) {
	let e = [],
		n = !1;
	if (t.types.includes(xv))
		try {
			let r = t.getData(xv),
				i = JSON.parse(r);
			for (let o of i)
				e.push({
					kind: "text",
					types: new Set(Object.keys(o)),
					getText: (s) => Promise.resolve(o[s]),
				});
			n = !0;
		} catch {}
	if (!n) {
		let r = new Map();
		for (let i of t.items)
			if (i.kind === "string") r.set(i.type || kv, t.getData(i.type));
			else if (i.kind === "file")
				if (typeof i.webkitGetAsEntry == "function") {
					let o = i.webkitGetAsEntry();
					if (!o) continue;
					o.isFile
						? e.push(vw(i.getAsFile()))
						: o.isDirectory && e.push(KO(o));
				} else e.push(vw(i.getAsFile()));
		r.size > 0 &&
			e.push({
				kind: "text",
				types: new Set(r.keys()),
				getText: (i) => Promise.resolve(r.get(i)),
			});
	}
	return e;
}
function Aoe(t) {
	return typeof t.text == "function"
		? t.text()
		: new Promise((e, n) => {
				let r = new FileReader();
				(r.onload = () => {
					e(r.result);
				}),
					(r.onerror = n),
					r.readAsText(t);
			});
}
function vw(t) {
	return {
		kind: "file",
		type: t.type || kv,
		name: t.name,
		getText: () => Aoe(t),
		getFile: () => Promise.resolve(t),
	};
}
function KO(t) {
	return { kind: "directory", name: t.name, getEntries: () => $oe(t) };
}
async function* $oe(t) {
	let e = t.createReader(),
		n;
	do {
		n = await new Promise((r, i) => {
			e.readEntries(r, i);
		});
		for (let r of n)
			if (r.isFile) {
				let i = await Toe(r);
				yield vw(i);
			} else r.isDirectory && (yield KO(r));
	} while (n.length > 0);
}
function Toe(t) {
	return new Promise((e, n) => t.file(e, n));
}
let Qn = { draggingKeys: new Set() };
function Boe(t) {
	Qn.draggingCollectionRef = t;
}
function Ioe(t) {
	Qn.draggingKeys = t;
}
function ff(t) {
	Qn.dropCollectionRef = t;
}
function UO() {
	Qn = { draggingKeys: new Set() };
}
function Foe(t) {
	Qn = t;
}
function Gs(t) {
	let { draggingCollectionRef: e, dropCollectionRef: n } = Qn;
	return (
		(e == null ? void 0 : e.current) != null &&
		e.current ===
			((t == null ? void 0 : t.current) ||
				(n == null ? void 0 : n.current))
	);
}
let lb;
function Cv(t) {
	lb = t;
}
let yw = yn.none;
function K4(t) {
	yw = t;
}
let xw = new Map(),
	bm = new Map(),
	Bi = null,
	wv = new Set();
function HO(t) {
	return (
		xw.set(t.element, t),
		Bi == null || Bi.updateValidDropTargets(),
		() => {
			xw.delete(t.element), Bi == null || Bi.updateValidDropTargets();
		}
	);
}
function Poe(t) {
	return (
		bm.set(t.element, t),
		() => {
			bm.delete(t.element);
		}
	);
}
function Noe(t, e) {
	if (Bi) throw new Error("Cannot begin dragging while already dragging");
	(Bi = new _oe(t, e)),
		requestAnimationFrame(() => {
			Bi.setup(), VO() === "keyboard" && Bi.next();
		});
	for (let n of wv) n();
}
function PD() {
	let [t, e] = E.useState(Bi);
	return (
		E.useEffect(() => {
			let n = () => e(Bi);
			return (
				wv.add(n),
				() => {
					wv.delete(n);
				}
			);
		}, []),
		t
	);
}
function Roe() {
	return !!Bi;
}
function Ooe() {
	Bi = null;
	for (let t of wv) t();
}
const Q6 = [
		"pointerdown",
		"pointermove",
		"pointerenter",
		"pointerleave",
		"pointerover",
		"pointerout",
		"pointerup",
		"mousedown",
		"mousemove",
		"mouseenter",
		"mouseleave",
		"mouseover",
		"mouseout",
		"mouseup",
		"touchstart",
		"touchmove",
		"touchend",
		"focusin",
		"focusout",
	],
	Moe = ["pointerup", "mouseup", "touchend"],
	joe = {
		keyboard: "dragStartedKeyboard",
		touch: "dragStartedTouch",
		virtual: "dragStartedVirtual",
	};
class _oe {
	setup() {
		document.addEventListener("keydown", this.onKeyDown, !0),
			document.addEventListener("keyup", this.onKeyUp, !0),
			window.addEventListener("focus", this.onFocus, !0),
			window.addEventListener("blur", this.onBlur, !0),
			document.addEventListener("click", this.onClick, !0),
			document.addEventListener("pointerdown", this.onPointerDown, !0);
		for (let e of Q6) document.addEventListener(e, this.cancelEvent, !0);
		(this.mutationObserver = new MutationObserver(() =>
			this.updateValidDropTargets(),
		)),
			this.updateValidDropTargets(),
			xs(this.stringFormatter.format(joe[VO()]));
	}
	teardown() {
		document.removeEventListener("keydown", this.onKeyDown, !0),
			document.removeEventListener("keyup", this.onKeyUp, !0),
			window.removeEventListener("focus", this.onFocus, !0),
			window.removeEventListener("blur", this.onBlur, !0),
			document.removeEventListener("click", this.onClick, !0),
			document.removeEventListener("pointerdown", this.onPointerDown, !0);
		for (let e of Q6) document.removeEventListener(e, this.cancelEvent, !0);
		this.mutationObserver.disconnect(), this.restoreAriaHidden();
	}
	onKeyDown(e) {
		var n;
		if ((this.cancelEvent(e), e.key === "Escape")) {
			this.cancel();
			return;
		}
		e.key === "Tab" &&
			!(e.metaKey || e.altKey || e.ctrlKey) &&
			(e.shiftKey ? this.previous() : this.next()),
			typeof ((n = this.currentDropTarget) === null || n === void 0
				? void 0
				: n.onKeyDown) == "function" &&
				this.currentDropTarget.onKeyDown(e, this.dragTarget);
	}
	onKeyUp(e) {
		this.cancelEvent(e),
			e.key === "Enter" && (e.altKey ? this.activate() : this.drop());
	}
	onFocus(e) {
		if (
			(e.target !== this.dragTarget.element && this.cancelEvent(e),
			!(e.target instanceof HTMLElement) ||
				e.target === this.dragTarget.element)
		)
			return;
		let n =
			this.validDropTargets.find((i) => i.element === e.target) ||
			this.validDropTargets.find((i) => i.element.contains(e.target));
		if (!n) {
			this.currentDropTarget
				? this.currentDropTarget.element.focus()
				: this.dragTarget.element.focus();
			return;
		}
		let r = bm.get(e.target);
		this.setCurrentDropTarget(n, r);
	}
	onBlur(e) {
		e.target !== this.dragTarget.element && this.cancelEvent(e),
			(!e.relatedTarget || !(e.relatedTarget instanceof HTMLElement)) &&
				(this.currentDropTarget
					? this.currentDropTarget.element.focus()
					: this.dragTarget.element.focus());
	}
	onClick(e) {
		if ((this.cancelEvent(e), Vm(e) || this.isVirtualClick)) {
			if (e.target === this.dragTarget.element) {
				this.cancel();
				return;
			}
			let n = this.validDropTargets.find((r) =>
				r.element.contains(e.target),
			);
			if (n) {
				let r = bm.get(e.target);
				this.setCurrentDropTarget(n, r), this.drop(r);
			}
		}
	}
	onPointerDown(e) {
		this.cancelEvent(e), (this.isVirtualClick = XE(e));
	}
	cancelEvent(e) {
		var n;
		((e.type === "focusin" || e.type === "focusout") &&
			e.target ===
				((n = this.dragTarget) === null || n === void 0
					? void 0
					: n.element)) ||
			(Moe.includes(e.type) || e.preventDefault(),
			e.stopPropagation(),
			e.stopImmediatePropagation());
	}
	updateValidDropTargets() {
		if (!this.mutationObserver) return;
		if (
			(this.mutationObserver.disconnect(),
			this.restoreAriaHidden && this.restoreAriaHidden(),
			(this.validDropTargets = zoe(this.dragTarget)),
			this.validDropTargets.length > 0)
		) {
			let i = this.findNearestDropTarget();
			this.validDropTargets = [
				...this.validDropTargets.slice(i),
				...this.validDropTargets.slice(0, i),
			];
		}
		this.currentDropTarget &&
			!this.validDropTargets.includes(this.currentDropTarget) &&
			this.setCurrentDropTarget(this.validDropTargets[0]);
		let e = Gc(this.dragTarget.items),
			n = [...bm.values()].filter((i) =>
				typeof i.getDropOperation == "function"
					? i.getDropOperation(
							e,
							this.dragTarget.allowedDropOperations,
						) !== "cancel"
					: !0,
			),
			r = this.validDropTargets.filter(
				(i) => !n.some((o) => i.element.contains(o.element)),
			);
		(this.restoreAriaHidden = mx([
			this.dragTarget.element,
			...n.map((i) => i.element),
			...r.map((i) => i.element),
		])),
			this.mutationObserver.observe(document.body, {
				subtree: !0,
				attributes: !0,
				attributeFilter: ["aria-hidden"],
			});
	}
	next() {
		if (!this.currentDropTarget) {
			this.setCurrentDropTarget(this.validDropTargets[0]);
			return;
		}
		let e = this.validDropTargets.indexOf(this.currentDropTarget);
		if (e < 0) {
			this.setCurrentDropTarget(this.validDropTargets[0]);
			return;
		}
		e === this.validDropTargets.length - 1
			? this.dragTarget.element.closest('[aria-hidden="true"]')
				? this.setCurrentDropTarget(this.validDropTargets[0])
				: (this.setCurrentDropTarget(null),
					this.dragTarget.element.focus())
			: this.setCurrentDropTarget(this.validDropTargets[e + 1]);
	}
	previous() {
		if (!this.currentDropTarget) {
			this.setCurrentDropTarget(
				this.validDropTargets[this.validDropTargets.length - 1],
			);
			return;
		}
		let e = this.validDropTargets.indexOf(this.currentDropTarget);
		if (e < 0) {
			this.setCurrentDropTarget(
				this.validDropTargets[this.validDropTargets.length - 1],
			);
			return;
		}
		e === 0
			? this.dragTarget.element.closest('[aria-hidden="true"]')
				? this.setCurrentDropTarget(
						this.validDropTargets[this.validDropTargets.length - 1],
					)
				: (this.setCurrentDropTarget(null),
					this.dragTarget.element.focus())
			: this.setCurrentDropTarget(this.validDropTargets[e - 1]);
	}
	findNearestDropTarget() {
		let e = this.dragTarget.element.getBoundingClientRect(),
			n = 1 / 0,
			r = -1;
		for (let i = 0; i < this.validDropTargets.length; i++) {
			let s = this.validDropTargets[i].element.getBoundingClientRect(),
				a = s.left - e.left,
				l = s.top - e.top,
				u = a * a + l * l;
			u < n && ((n = u), (r = i));
		}
		return r;
	}
	setCurrentDropTarget(e, n) {
		if (e !== this.currentDropTarget) {
			if (
				this.currentDropTarget &&
				typeof this.currentDropTarget.onDropExit == "function"
			) {
				let r = this.currentDropTarget.element.getBoundingClientRect();
				this.currentDropTarget.onDropExit({
					type: "dropexit",
					x: r.left + r.width / 2,
					y: r.top + r.height / 2,
				});
			}
			if (((this.currentDropTarget = e), e)) {
				if (typeof e.onDropEnter == "function") {
					let r = e.element.getBoundingClientRect();
					e.onDropEnter(
						{
							type: "dropenter",
							x: r.left + r.width / 2,
							y: r.top + r.height / 2,
						},
						this.dragTarget,
					);
				}
				n || e == null || e.element.focus();
			}
		}
		n !== this.currentDropItem &&
			(n &&
				typeof this.currentDropTarget.onDropTargetEnter == "function" &&
				this.currentDropTarget.onDropTargetEnter(
					n == null ? void 0 : n.target,
				),
			n == null || n.element.focus(),
			(this.currentDropItem = n),
			this.initialFocused ||
				(xs(
					n == null ? void 0 : n.element.getAttribute("aria-label"),
					"polite",
				),
				(this.initialFocused = !0)));
	}
	end() {
		if (
			(this.teardown(),
			Ooe(),
			typeof this.dragTarget.onDragEnd == "function")
		) {
			let n = (
				this.currentDropTarget && this.dropOperation !== "cancel"
					? this.currentDropTarget
					: this.dragTarget
			).element.getBoundingClientRect();
			this.dragTarget.onDragEnd({
				type: "dragend",
				x: n.x + n.width / 2,
				y: n.y + n.height / 2,
				dropOperation: this.dropOperation || "cancel",
			});
		}
		this.currentDropTarget &&
			!this.currentDropTarget.preventFocusOnDrop &&
			document.activeElement.dispatchEvent(
				new FocusEvent("focusin", { bubbles: !0 }),
			),
			this.setCurrentDropTarget(null);
	}
	cancel() {
		this.setCurrentDropTarget(null),
			this.end(),
			this.dragTarget.element.closest('[aria-hidden="true"]') ||
				this.dragTarget.element.focus(),
			xs(this.stringFormatter.format("dropCanceled"));
	}
	drop(e) {
		if (!this.currentDropTarget) {
			this.cancel();
			return;
		}
		if (typeof (e == null ? void 0 : e.getDropOperation) == "function") {
			let n = Gc(this.dragTarget.items);
			this.dropOperation = e.getDropOperation(
				n,
				this.dragTarget.allowedDropOperations,
			);
		} else if (
			typeof this.currentDropTarget.getDropOperation == "function"
		) {
			let n = Gc(this.dragTarget.items);
			this.dropOperation = this.currentDropTarget.getDropOperation(
				n,
				this.dragTarget.allowedDropOperations,
			);
		} else this.dropOperation = this.dragTarget.allowedDropOperations[0];
		if (typeof this.currentDropTarget.onDrop == "function") {
			let n = this.dragTarget.items.map((i) => ({
					kind: "text",
					types: new Set(Object.keys(i)),
					getText: (o) => Promise.resolve(i[o]),
				})),
				r = this.currentDropTarget.element.getBoundingClientRect();
			this.currentDropTarget.onDrop(
				{
					type: "drop",
					x: r.left + r.width / 2,
					y: r.top + r.height / 2,
					items: n,
					dropOperation: this.dropOperation,
				},
				e == null ? void 0 : e.target,
			);
		}
		this.end(), xs(this.stringFormatter.format("dropComplete"));
	}
	activate() {
		if (
			this.currentDropTarget &&
			typeof this.currentDropTarget.onDropActivate == "function"
		) {
			let e = this.currentDropTarget.element.getBoundingClientRect();
			this.currentDropTarget.onDropActivate({
				type: "dropactivate",
				x: e.left + e.width / 2,
				y: e.top + e.height / 2,
			});
		}
	}
	constructor(e, n) {
		(this.dragTarget = e),
			(this.stringFormatter = n),
			(this.onKeyDown = this.onKeyDown.bind(this)),
			(this.onKeyUp = this.onKeyUp.bind(this)),
			(this.onFocus = this.onFocus.bind(this)),
			(this.onBlur = this.onBlur.bind(this)),
			(this.onClick = this.onClick.bind(this)),
			(this.onPointerDown = this.onPointerDown.bind(this)),
			(this.cancelEvent = this.cancelEvent.bind(this)),
			(this.initialFocused = !1);
	}
}
function zoe(t) {
	let e = Gc(t.items);
	return [...xw.values()].filter((n) =>
		n.element.closest('[aria-hidden="true"]')
			? !1
			: typeof n.getDropOperation == "function"
				? n.getDropOperation(e, t.allowedDropOperations) !== "cancel"
				: !0,
	);
}
var WO = {};
WO = {
	dragDescriptionKeyboard: "اضغط Enter لبدء السحب.",
	dragDescriptionKeyboardAlt: "اضغط على Alt + Enter لبدء السحب.",
	dragDescriptionLongPress: "اضغط باستمرار لبدء السحب.",
	dragDescriptionTouch: "اضغط مرتين لبدء السحب.",
	dragDescriptionVirtual: "انقر لبدء السحب.",
	dragItem: (t) => `اسحب ${t.itemText}`,
	dragSelectedItems: (t, e) =>
		`اسحب ${e.plural(t.count, { one: () => `${e.number(t.count)} عنصر محدد`, other: () => `${e.number(t.count)} عناصر محددة` })}`,
	dragSelectedKeyboard: (t, e) =>
		`اضغط على Enter للسحب ${e.plural(t.count, { one: "عدد العناصر المختارة", other: "عدد العناصر المختارة" })}.`,
	dragSelectedKeyboardAlt: (t, e) =>
		`اضغط على مفتاحي Alt + Enter للسحب ${e.plural(t.count, { one: "عدد العناصر المختارة", other: "عدد العناصر المختارة" })}.`,
	dragSelectedLongPress: (t, e) =>
		`اضغط باستمرار للسحب ${e.plural(t.count, { one: "عدد العناصر المختارة", other: "عدد العناصر المختارة" })}.`,
	dragStartedKeyboard:
		"بدأ السحب. اضغط Tab للانتقال إلى موضع الإفلات، ثم اضغط Enter للإفلات، أو اضغط Escape للإلغاء.",
	dragStartedTouch:
		"بدأ السحب. انتقل إلى موضع الإفلات، ثم اضغط مرتين للإفلات.",
	dragStartedVirtual:
		"بدأ السحب. انتقل إلى مكان الإفلات، ثم انقر أو اضغط Enter للإفلات.",
	dropCanceled: "تم إلغاء الإفلات.",
	dropComplete: "اكتمل الإفلات.",
	dropDescriptionKeyboard: "اضغط Enter للإفلات. اضغط Escape لإلغاء السحب.",
	dropDescriptionTouch: "اضغط مرتين للإفلات.",
	dropDescriptionVirtual: "انقر للإفلات.",
	dropIndicator: "مؤشر الإفلات",
	dropOnItem: (t) => `إفلات ${t.itemText}`,
	dropOnRoot: "الإفلات",
	endDragKeyboard: "السحب. اضغط Enter لإلغاء السحب.",
	endDragTouch: "السحب. اضغط مرتين لإلغاء السحب.",
	endDragVirtual: "السحب. انقر لإلغاء السحب.",
	insertAfter: (t) => `أدخل بعد ${t.itemText}`,
	insertBefore: (t) => `أدخل قبل ${t.itemText}`,
	insertBetween: (t) => `أدخل بين ${t.beforeItemText} و ${t.afterItemText}`,
};
var qO = {};
qO = {
	dragDescriptionKeyboard: "Натиснете „Enter“, за да започнете да плъзгате.",
	dragDescriptionKeyboardAlt:
		"Натиснете Alt + Enter, за да започнете да плъзгате.",
	dragDescriptionLongPress:
		"Натиснете продължително, за да започнете да плъзгате.",
	dragDescriptionTouch: "Натиснете двукратно, за да започнете да плъзгате.",
	dragDescriptionVirtual: "Щракнете, за да започнете да плъзгате.",
	dragItem: (t) => `Плъзни ${t.itemText}`,
	dragSelectedItems: (t, e) =>
		`Плъзни ${e.plural(t.count, { one: () => `${e.number(t.count)} избран елемент`, other: () => `${e.number(t.count)} избрани елемента` })}`,
	dragSelectedKeyboard: (t, e) =>
		`Натиснете Enter, за да плъзнете ${e.plural(t.count, { one: () => `${e.number(t.count)} избран елемент`, other: () => `${e.number(t.count)} избрани елементи` })}.`,
	dragSelectedKeyboardAlt: (t, e) =>
		`Натиснете Alt и Enter, за да плъзнете ${e.plural(t.count, { one: () => `${e.number(t.count)} избран елемент`, other: () => `${e.number(t.count)} избрани елементи` })}.`,
	dragSelectedLongPress: (t, e) =>
		`Натиснете продължително, за да плъзнете ${e.plural(t.count, { one: () => `${e.number(t.count)} избран елемент`, other: () => `${e.number(t.count)} избрани елементи` })}.`,
	dragStartedKeyboard:
		"Започна плъзгане. Натиснете „Tab“, за да се придвижите до целта, след което натиснете „Enter“ за пускане или натиснете „Escape“ за отмяна.",
	dragStartedTouch:
		"Започна плъзгане. Придвижете се до целта, след което натиснете двукратно, за да пуснете.",
	dragStartedVirtual:
		"Започна плъзгане. Придвижете се до целта, след което щракнете или натиснете „Enter“ за пускане.",
	dropCanceled: "Пускането е отменено.",
	dropComplete: "Пускането е завършено.",
	dropDescriptionKeyboard:
		"Натиснете „Enter“ за пускане. Натиснете „Escape“ за отмяна на плъзгането.",
	dropDescriptionTouch: "Натиснете двукратно за пускане.",
	dropDescriptionVirtual: "Щракнете за пускане.",
	dropIndicator: "индикатор за пускане",
	dropOnItem: (t) => `Пусни върху ${t.itemText}`,
	dropOnRoot: "Пусни върху",
	endDragKeyboard: "Плъзгане. Натиснете „Enter“ за отмяна на плъзгането.",
	endDragTouch: "Плъзгане. Натиснете двукратно за отмяна на плъзгането.",
	endDragVirtual: "Плъзгане. Щракнете за отмяна.",
	insertAfter: (t) => `Вмъкни след ${t.itemText}`,
	insertBefore: (t) => `Вмъкни преди ${t.itemText}`,
	insertBetween: (t) =>
		`Вмъкни между ${t.beforeItemText} и ${t.afterItemText}`,
};
var GO = {};
GO = {
	dragDescriptionKeyboard: "Stisknutím klávesy Enter začnete s přetahováním.",
	dragDescriptionKeyboardAlt: "Stisknutím Alt + Enter zahájíte přetahování.",
	dragDescriptionLongPress: "Dlouhým stisknutím zahájíte přetahování.",
	dragDescriptionTouch: "Poklepáním začnete s přetahováním.",
	dragDescriptionVirtual: "Kliknutím začnete s přetahováním.",
	dragItem: (t) => `Přetáhnout ${t.itemText}`,
	dragSelectedItems: (t, e) =>
		`Přetáhnout ${e.plural(t.count, { one: () => `${e.number(t.count)} vybranou položku`, few: () => `${e.number(t.count)} vybrané položky`, other: () => `${e.number(t.count)} vybraných položek` })}`,
	dragSelectedKeyboard: (t, e) =>
		`Stisknutím klávesy Enter přetáhněte ${e.plural(t.count, { one: () => `${e.number(t.count)} vybranou položku`, other: () => `${e.number(t.count)} vybrané položky` })}.`,
	dragSelectedKeyboardAlt: (t, e) =>
		`Stisknutím Alt + Enter přetáhněte ${e.plural(t.count, { one: () => `${e.number(t.count)} vybranou položku`, other: () => `${e.number(t.count)} vybrané položky` })}.`,
	dragSelectedLongPress: (t, e) =>
		`Dlouhým stisknutím přetáhnete ${e.plural(t.count, { one: () => `${e.number(t.count)} vybranou položku`, other: () => `${e.number(t.count)} vybrané položky` })}.`,
	dragStartedKeyboard:
		"Začněte s přetahováním. Po stisknutí klávesy Tab najděte požadovaný cíl a stisknutím klávesy Enter přetažení dokončete nebo stisknutím klávesy Esc akci zrušte.",
	dragStartedTouch:
		"Začněte s přetahováním. Najděte požadovaný cíl a poklepáním přetažení dokončete.",
	dragStartedVirtual:
		"Začněte s přetahováním. Najděte požadovaný cíl a kliknutím nebo stisknutím klávesy Enter přetažení dokončete.",
	dropCanceled: "Přetažení bylo zrušeno.",
	dropComplete: "Přetažení bylo dokončeno.",
	dropDescriptionKeyboard:
		"Stisknutím klávesy Enter přetažení dokončete nebo stisknutím klávesy Esc akci zrušte.",
	dropDescriptionTouch: "Poklepáním přetažení dokončete.",
	dropDescriptionVirtual: "Kliknutím objekt přetáhněte.",
	dropIndicator: "indikátor přetažení",
	dropOnItem: (t) => `Přetáhnout na ${t.itemText}`,
	dropOnRoot: "Přetáhnout na",
	endDragKeyboard:
		"Probíhá přetahování. Stisknutím klávesy Enter přetažení zrušíte.",
	endDragTouch: "Probíhá přetahování. Poklepáním přetažení zrušíte.",
	endDragVirtual: "Probíhá přetahování. Kliknutím přetažení zrušíte.",
	insertAfter: (t) => `Vložit za ${t.itemText}`,
	insertBefore: (t) => `Vložit před ${t.itemText}`,
	insertBetween: (t) =>
		`Vložit mezi ${t.beforeItemText} a ${t.afterItemText}`,
};
var YO = {};
YO = {
	dragDescriptionKeyboard: "Tryk på Enter for at starte med at trække.",
	dragDescriptionKeyboardAlt:
		"Tryk på Alt + Enter for at starte med at trække.",
	dragDescriptionLongPress: "Tryk længe for at starte med at trække.",
	dragDescriptionTouch: "Dobbelttryk for at starte med at trække.",
	dragDescriptionVirtual: "Klik for at starte med at trække.",
	dragItem: (t) => `Træk ${t.itemText}`,
	dragSelectedItems: (t, e) =>
		`Træk ${e.plural(t.count, { one: () => `${e.number(t.count)} valgt element`, other: () => `${e.number(t.count)} valgte elementer` })}`,
	dragSelectedKeyboard: (t, e) =>
		`Tryk på Enter for at trække ${e.plural(t.count, { one: () => `${e.number(t.count)} valgte element`, other: () => `${e.number(t.count)} valgte elementer` })}.`,
	dragSelectedKeyboardAlt: (t, e) =>
		`Tryk på Alt + Enter for at trække ${e.plural(t.count, { one: () => `${e.number(t.count)} valgte element`, other: () => `${e.number(t.count)} valgte elementer` })}.`,
	dragSelectedLongPress: (t, e) =>
		`Tryk længe for at trække ${e.plural(t.count, { one: () => `${e.number(t.count)} valgte element`, other: () => `${e.number(t.count)} valgte elementer` })}.`,
	dragStartedKeyboard:
		"Startet med at trække. Tryk på Tab for at gå til et slip-mål, tryk derefter på Enter for at slippe, eller tryk på Escape for at annullere.",
	dragStartedTouch:
		"Startet med at trække. Gå til et slip-mål, og dobbelttryk derefter for at slippe.",
	dragStartedVirtual:
		"Startet med at trække. Gå til et slip-mål, og klik eller tryk derefter på enter for at slippe.",
	dropCanceled: "Slip annulleret.",
	dropComplete: "Slip fuldført.",
	dropDescriptionKeyboard:
		"Tryk på Enter for at slippe. Tryk på Escape for at annullere trækning.",
	dropDescriptionTouch: "Dobbelttryk for at slippe.",
	dropDescriptionVirtual: "Klik for at slippe.",
	dropIndicator: "slip-indikator",
	dropOnItem: (t) => `Slip på ${t.itemText}`,
	dropOnRoot: "Slip på",
	endDragKeyboard: "Trækning. Tryk på enter for at annullere træk.",
	endDragTouch: "Trækning. Dobbelttryk for at annullere træk.",
	endDragVirtual: "Trækning. Klik for at annullere trækning.",
	insertAfter: (t) => `Indsæt efter ${t.itemText}`,
	insertBefore: (t) => `Indsæt før ${t.itemText}`,
	insertBetween: (t) =>
		`Indsæt mellem ${t.beforeItemText} og ${t.afterItemText}`,
};
var JO = {};
JO = {
	dragDescriptionKeyboard:
		"Drücken Sie die Eingabetaste, um den Ziehvorgang zu starten.",
	dragDescriptionKeyboardAlt:
		"Alt + Eingabe drücken, um den Ziehvorgang zu starten.",
	dragDescriptionLongPress: "Lang drücken, um mit dem Ziehen zu beginnen.",
	dragDescriptionTouch: "Tippen Sie doppelt, um den Ziehvorgang zu starten.",
	dragDescriptionVirtual: "Zum Starten des Ziehvorgangs klicken.",
	dragItem: (t) => `${t.itemText} ziehen`,
	dragSelectedItems: (t, e) =>
		`${e.plural(t.count, { one: () => `${e.number(t.count)} ausgewähltes Objekt`, other: () => `${e.number(t.count)} ausgewählte Objekte` })} ziehen`,
	dragSelectedKeyboard: (t, e) =>
		`Eingabetaste drücken, um ${e.plural(t.count, { one: () => `${e.number(t.count)} ausgewähltes Element`, other: () => `${e.number(t.count)} ausgewählte Elemente` })} zu ziehen.`,
	dragSelectedKeyboardAlt: (t, e) =>
		`Alt + Eingabetaste drücken, um ${e.plural(t.count, { one: () => `${e.number(t.count)} ausgewähltes Element`, other: () => `${e.number(t.count)} ausgewählte Elemente` })} zu ziehen.`,
	dragSelectedLongPress: (t, e) =>
		`Lang drücken, um ${e.plural(t.count, { one: () => `${e.number(t.count)} ausgewähltes Element`, other: () => `${e.number(t.count)} ausgewählte Elemente` })} zu ziehen.`,
	dragStartedKeyboard:
		"Ziehvorgang gestartet. Drücken Sie die Tabulatortaste, um zu einem Ablegeziel zu navigieren und drücken Sie dann die Eingabetaste, um das Objekt abzulegen, oder Escape, um den Vorgang abzubrechen.",
	dragStartedTouch:
		"Ziehvorgang gestartet. Navigieren Sie zu einem Ablegeziel und tippen Sie doppelt, um das Objekt abzulegen.",
	dragStartedVirtual:
		"Ziehvorgang gestartet. Navigieren Sie zu einem Ablegeziel und klicken Sie oder drücken Sie die Eingabetaste, um das Objekt abzulegen.",
	dropCanceled: "Ablegen abgebrochen.",
	dropComplete: "Ablegen abgeschlossen.",
	dropDescriptionKeyboard:
		"Drücken Sie die Eingabetaste, um das Objekt abzulegen. Drücken Sie Escape, um den Vorgang abzubrechen.",
	dropDescriptionTouch: "Tippen Sie doppelt, um das Objekt abzulegen.",
	dropDescriptionVirtual: "Zum Ablegen klicken.",
	dropIndicator: "Ablegeanzeiger",
	dropOnItem: (t) => `Auf ${t.itemText} ablegen`,
	dropOnRoot: "Ablegen auf",
	endDragKeyboard:
		"Ziehvorgang läuft. Drücken Sie die Eingabetaste, um den Vorgang abzubrechen.",
	endDragTouch:
		"Ziehvorgang läuft. Tippen Sie doppelt, um den Vorgang abzubrechen.",
	endDragVirtual:
		"Ziehvorgang läuft. Klicken Sie, um den Vorgang abzubrechen.",
	insertAfter: (t) => `Nach ${t.itemText} einfügen`,
	insertBefore: (t) => `Vor ${t.itemText} einfügen`,
	insertBetween: (t) =>
		`Zwischen ${t.beforeItemText} und ${t.afterItemText} einfügen`,
};
var XO = {};
XO = {
	dragDescriptionKeyboard: "Πατήστε Enter για έναρξη της μεταφοράς.",
	dragDescriptionKeyboardAlt: "Πατήστε Alt + Enter για έναρξη της μεταφοράς.",
	dragDescriptionLongPress:
		"Πατήστε παρατεταμένα για να ξεκινήσετε τη μεταφορά.",
	dragDescriptionTouch: "Πατήστε δύο φορές για έναρξη της μεταφοράς.",
	dragDescriptionVirtual: "Κάντε κλικ για να ξεκινήσετε τη μεταφορά.",
	dragItem: (t) => `Μεταφορά ${t.itemText}`,
	dragSelectedItems: (t, e) =>
		`Μεταφορά σε ${e.plural(t.count, { one: () => `${e.number(t.count)} επιλεγμένο στοιχείο`, other: () => `${e.number(t.count)} επιλεγμένα στοιχεία` })}`,
	dragSelectedKeyboard: (t, e) =>
		`Πατήστε Enter για να σύρετε ${e.plural(t.count, { one: () => `${e.number(t.count)} επιλεγμένο στοιχείο`, other: () => `${e.number(t.count)} επιλεγμένα στοιχεία` })}.`,
	dragSelectedKeyboardAlt: (t, e) =>
		`Πατήστε Alt + Enter για να σύρετε ${e.plural(t.count, { one: () => `${e.number(t.count)} επιλεγμένο στοιχείο`, other: () => `${e.number(t.count)} επιλεγμένα στοιχεία` })}.`,
	dragSelectedLongPress: (t, e) =>
		`Πατήστε παρατεταμένα για να σύρετε ${e.plural(t.count, { one: () => `${e.number(t.count)} επιλεγμένο στοιχείο`, other: () => `${e.number(t.count)} επιλεγμένα στοιχεία` })}.`,
	dragStartedKeyboard:
		"Η μεταφορά ξεκίνησε. Πατήστε το πλήκτρο Tab για να μεταβείτε σε έναν προορισμό απόθεσης και, στη συνέχεια, πατήστε Enter για απόθεση ή πατήστε Escape για ακύρωση.",
	dragStartedTouch:
		"Η μεταφορά ξεκίνησε. Μεταβείτε σε έναν προορισμό απόθεσης και, στη συνέχεια, πατήστε δύο φορές για απόθεση.",
	dragStartedVirtual:
		"Η μεταφορά ξεκίνησε. Μεταβείτε σε έναν προορισμό απόθεσης και, στη συνέχεια, κάντε κλικ ή πατήστε Enter για απόθεση.",
	dropCanceled: "Η απόθεση ακυρώθηκε.",
	dropComplete: "Η απόθεση ολοκληρώθηκε.",
	dropDescriptionKeyboard:
		"Πατήστε Enter για απόθεση. Πατήστε Escape για ακύρωση της μεταφοράς.",
	dropDescriptionTouch: "Πατήστε δύο φορές για απόθεση.",
	dropDescriptionVirtual: "Κάντε κλικ για απόθεση.",
	dropIndicator: "δείκτης απόθεσης",
	dropOnItem: (t) => `Απόθεση σε ${t.itemText}`,
	dropOnRoot: "Απόθεση σε",
	endDragKeyboard:
		"Μεταφορά σε εξέλιξη. Πατήστε Enter για ακύρωση της μεταφοράς.",
	endDragTouch:
		"Μεταφορά σε εξέλιξη. Πατήστε δύο φορές για ακύρωση της μεταφοράς.",
	endDragVirtual:
		"Μεταφορά σε εξέλιξη. Κάντε κλικ για ακύρωση της μεταφοράς.",
	insertAfter: (t) => `Εισαγωγή μετά από ${t.itemText}`,
	insertBefore: (t) => `Εισαγωγή πριν από ${t.itemText}`,
	insertBetween: (t) =>
		`Εισαγωγή μεταξύ ${t.beforeItemText} και ${t.afterItemText}`,
};
var ZO = {};
ZO = {
	dragItem: (t) => `Drag ${t.itemText}`,
	dragSelectedItems: (t, e) =>
		`Drag ${e.plural(t.count, { one: () => `${e.number(t.count)} selected item`, other: () => `${e.number(t.count)} selected items` })}`,
	dragDescriptionKeyboard: "Press Enter to start dragging.",
	dragDescriptionKeyboardAlt: "Press Alt + Enter to start dragging.",
	dragDescriptionTouch: "Double tap to start dragging.",
	dragDescriptionVirtual: "Click to start dragging.",
	dragDescriptionLongPress: "Long press to start dragging.",
	dragSelectedKeyboard: (t, e) =>
		`Press Enter to drag ${e.plural(t.count, { one: () => `${e.number(t.count)} selected item`, other: () => `${e.number(t.count)} selected items` })}.`,
	dragSelectedKeyboardAlt: (t, e) =>
		`Press Alt + Enter to drag ${e.plural(t.count, { one: () => `${e.number(t.count)} selected item`, other: () => `${e.number(t.count)} selected items` })}.`,
	dragSelectedLongPress: (t, e) =>
		`Long press to drag ${e.plural(t.count, { one: () => `${e.number(t.count)} selected item`, other: () => `${e.number(t.count)} selected items` })}.`,
	dragStartedKeyboard:
		"Started dragging. Press Tab to navigate to a drop target, then press Enter to drop, or press Escape to cancel.",
	dragStartedTouch:
		"Started dragging. Navigate to a drop target, then double tap to drop.",
	dragStartedVirtual:
		"Started dragging. Navigate to a drop target, then click or press Enter to drop.",
	endDragKeyboard: "Dragging. Press Enter to cancel drag.",
	endDragTouch: "Dragging. Double tap to cancel drag.",
	endDragVirtual: "Dragging. Click to cancel drag.",
	dropDescriptionKeyboard:
		"Press Enter to drop. Press Escape to cancel drag.",
	dropDescriptionTouch: "Double tap to drop.",
	dropDescriptionVirtual: "Click to drop.",
	dropCanceled: "Drop canceled.",
	dropComplete: "Drop complete.",
	dropIndicator: "drop indicator",
	dropOnRoot: "Drop on",
	dropOnItem: (t) => `Drop on ${t.itemText}`,
	insertBefore: (t) => `Insert before ${t.itemText}`,
	insertBetween: (t) =>
		`Insert between ${t.beforeItemText} and ${t.afterItemText}`,
	insertAfter: (t) => `Insert after ${t.itemText}`,
};
var QO = {};
QO = {
	dragDescriptionKeyboard: "Pulse Intro para empezar a arrastrar.",
	dragDescriptionKeyboardAlt: "Pulse Intro para empezar a arrastrar.",
	dragDescriptionLongPress: "Mantenga pulsado para comenzar a arrastrar.",
	dragDescriptionTouch: "Pulse dos veces para iniciar el arrastre.",
	dragDescriptionVirtual: "Haga clic para iniciar el arrastre.",
	dragItem: (t) => `Arrastrar ${t.itemText}`,
	dragSelectedItems: (t, e) =>
		`Arrastrar ${e.plural(t.count, { one: () => `${e.number(t.count)} elemento seleccionado`, other: () => `${e.number(t.count)} elementos seleccionados` })}`,
	dragSelectedKeyboard: (t, e) =>
		`Pulse Intro para arrastrar ${e.plural(t.count, { one: () => `${e.number(t.count)} elemento seleccionado`, other: () => `${e.number(t.count)} elementos seleccionados` })}.`,
	dragSelectedKeyboardAlt: (t, e) =>
		`Pulse Alt + Intro para arrastrar ${e.plural(t.count, { one: () => `${e.number(t.count)} elemento seleccionado`, other: () => `${e.number(t.count)} elementos seleccionados` })}.`,
	dragSelectedLongPress: (t, e) =>
		`Mantenga pulsado para arrastrar ${e.plural(t.count, { one: () => `${e.number(t.count)} elemento seleccionado`, other: () => `${e.number(t.count)} elementos seleccionados` })}.`,
	dragStartedKeyboard:
		"Se ha empezado a arrastrar. Pulse el tabulador para ir al público destinatario donde se vaya a colocar y, a continuación, pulse Intro para soltar, o pulse Escape para cancelar.",
	dragStartedTouch:
		"Se ha empezado a arrastrar. Vaya al público destinatario donde se vaya a colocar y, a continuación, pulse dos veces para soltar.",
	dragStartedVirtual:
		"Se ha empezado a arrastrar. Vaya al público destinatario donde se vaya a colocar y, a continuación, haga clic o pulse Intro para soltar.",
	dropCanceled: "Se ha cancelado la colocación.",
	dropComplete: "Colocación finalizada.",
	dropDescriptionKeyboard:
		"Pulse Intro para soltar. Pulse Escape para cancelar el arrastre.",
	dropDescriptionTouch: "Pulse dos veces para soltar.",
	dropDescriptionVirtual: "Haga clic para soltar.",
	dropIndicator: "indicador de colocación",
	dropOnItem: (t) => `Soltar en ${t.itemText}`,
	dropOnRoot: "Soltar en",
	endDragKeyboard: "Arrastrando. Pulse Intro para cancelar el arrastre.",
	endDragTouch: "Arrastrando. Pulse dos veces para cancelar el arrastre.",
	endDragVirtual: "Arrastrando. Haga clic para cancelar el arrastre.",
	insertAfter: (t) => `Insertar después de ${t.itemText}`,
	insertBefore: (t) => `Insertar antes de ${t.itemText}`,
	insertBetween: (t) =>
		`Insertar entre ${t.beforeItemText} y ${t.afterItemText}`,
};
var eM = {};
eM = {
	dragDescriptionKeyboard: "Lohistamise alustamiseks vajutage klahvi Enter.",
	dragDescriptionKeyboardAlt:
		"Lohistamise alustamiseks vajutage klahvikombinatsiooni Alt + Enter.",
	dragDescriptionLongPress: "Vajutage pikalt lohistamise alustamiseks.",
	dragDescriptionTouch: "Topeltpuudutage lohistamise alustamiseks.",
	dragDescriptionVirtual: "Klõpsake lohistamise alustamiseks.",
	dragItem: (t) => `Lohista ${t.itemText}`,
	dragSelectedItems: (t, e) =>
		`Lohista ${e.plural(t.count, { one: () => `${e.number(t.count)} valitud üksust`, other: () => `${e.number(t.count)} valitud üksust` })}`,
	dragSelectedKeyboard: (t, e) =>
		`${e.plural(t.count, { one: () => `${e.number(t.count)} valitud üksuse`, other: () => `${e.number(t.count)} valitud üksuse` })} lohistamiseks vajutage sisestusklahvi Enter.`,
	dragSelectedKeyboardAlt: (t, e) =>
		`Lohistamiseks vajutage klahvikombinatsiooni Alt + Enter ${e.plural(t.count, { one: () => `${e.number(t.count)} valitud üksuse`, other: () => `${e.number(t.count)} valitud üksuse` })} jaoks.`,
	dragSelectedLongPress: (t, e) =>
		`Pikk vajutus ${e.plural(t.count, { one: () => `${e.number(t.count)} valitud üksuse`, other: () => `${e.number(t.count)} valitud üksuse` })} lohistamiseks.`,
	dragStartedKeyboard:
		"Alustati lohistamist. Kukutamise sihtmärgi juurde navigeerimiseks vajutage klahvi Tab, seejärel vajutage kukutamiseks klahvi Enter või loobumiseks klahvi Escape.",
	dragStartedTouch:
		"Alustati lohistamist. Navigeerige kukutamise sihtmärgi juurde ja topeltpuudutage kukutamiseks.",
	dragStartedVirtual:
		"Alustati lohistamist. Navigeerige kukutamise sihtmärgi juurde ja kukutamiseks klõpsake või vajutage klahvi Enter.",
	dropCanceled: "Lohistamisest loobuti.",
	dropComplete: "Lohistamine on tehtud.",
	dropDescriptionKeyboard:
		"Kukutamiseks vajutage klahvi Enter. Lohistamisest loobumiseks vajutage klahvi Escape.",
	dropDescriptionTouch: "Kukutamiseks topeltpuudutage.",
	dropDescriptionVirtual: "Kukutamiseks klõpsake.",
	dropIndicator: "lohistamise indikaator",
	dropOnItem: (t) => `Kukuta asukohta ${t.itemText}`,
	dropOnRoot: "Kukuta asukohta",
	endDragKeyboard:
		"Lohistamine. Lohistamisest loobumiseks vajutage klahvi Enter.",
	endDragTouch: "Lohistamine. Lohistamisest loobumiseks topeltpuudutage.",
	endDragVirtual: "Lohistamine. Lohistamisest loobumiseks klõpsake.",
	insertAfter: (t) => `Sisesta ${t.itemText} järele`,
	insertBefore: (t) => `Sisesta ${t.itemText} ette`,
	insertBetween: (t) =>
		`Sisesta ${t.beforeItemText} ja ${t.afterItemText} vahele`,
};
var tM = {};
tM = {
	dragDescriptionKeyboard: "Aloita vetäminen painamalla Enter-näppäintä.",
	dragDescriptionKeyboardAlt:
		"Aloita vetäminen painamalla Alt + Enter -näppäinyhdistelmää.",
	dragDescriptionLongPress: "Aloita vetäminen pitämällä painettuna.",
	dragDescriptionTouch: "Aloita vetäminen kaksoisnapauttamalla.",
	dragDescriptionVirtual: "Aloita vetäminen napsauttamalla.",
	dragItem: (t) => `Vedä kohdetta ${t.itemText}`,
	dragSelectedItems: (t, e) =>
		`Vedä ${e.plural(t.count, { one: () => `${e.number(t.count)} valittua kohdetta`, other: () => `${e.number(t.count)} valittua kohdetta` })}`,
	dragSelectedKeyboard: (t, e) =>
		`Vedä painamalla Enter ${e.plural(t.count, { one: () => `${e.number(t.count)} valittu kohde`, other: () => `${e.number(t.count)} valittua kohdetta` })}.`,
	dragSelectedKeyboardAlt: (t, e) =>
		`Vedä painamalla Alt + Enter ${e.plural(t.count, { one: () => `${e.number(t.count)} valittu kohde`, other: () => `${e.number(t.count)} valittua kohdetta` })}.`,
	dragSelectedLongPress: (t, e) =>
		`Vedä pitämällä painettuna ${e.plural(t.count, { one: () => `${e.number(t.count)} valittu kohde`, other: () => `${e.number(t.count)} valittua kohdetta` })}.`,
	dragStartedKeyboard:
		"Vetäminen aloitettu. Siirry pudotuskohteeseen painamalla sarkainnäppäintä ja sitten pudota painamalla Enter-näppäintä tai peruuta painamalla Escape-näppäintä.",
	dragStartedTouch:
		"Vetäminen aloitettu. Siirry pudotuskohteeseen ja pudota kaksoisnapauttamalla.",
	dragStartedVirtual:
		"Vetäminen aloitettu. Siirry pudotuskohteeseen ja pudota napsauttamalla tai painamalla Enter-näppäintä.",
	dropCanceled: "Pudotus peruutettu.",
	dropComplete: "Pudotus suoritettu.",
	dropDescriptionKeyboard:
		"Pudota painamalla Enter-näppäintä. Peruuta vetäminen painamalla Escape-näppäintä.",
	dropDescriptionTouch: "Pudota kaksoisnapauttamalla.",
	dropDescriptionVirtual: "Pudota napsauttamalla.",
	dropIndicator: "pudotuksen ilmaisin",
	dropOnItem: (t) => `Pudota kohteeseen ${t.itemText}`,
	dropOnRoot: "Pudota kohteeseen",
	endDragKeyboard: "Vedetään. Peruuta vetäminen painamalla Enter-näppäintä.",
	endDragTouch: "Vedetään. Peruuta vetäminen kaksoisnapauttamalla.",
	endDragVirtual: "Vedetään. Peruuta vetäminen napsauttamalla.",
	insertAfter: (t) => `Lisää kohteen ${t.itemText} jälkeen`,
	insertBefore: (t) => `Lisää ennen kohdetta ${t.itemText}`,
	insertBetween: (t) =>
		`Lisää kohteiden ${t.beforeItemText} ja ${t.afterItemText} väliin`,
};
var nM = {};
nM = {
	dragDescriptionKeyboard:
		"Appuyez sur Entrée pour commencer le déplacement.",
	dragDescriptionKeyboardAlt:
		"Appuyez sur Alt + Entrée pour commencer à faire glisser.",
	dragDescriptionLongPress:
		"Appuyez de manière prolongée pour commencer à faire glisser.",
	dragDescriptionTouch: "Touchez deux fois pour commencer le déplacement.",
	dragDescriptionVirtual: "Cliquez pour commencer le déplacement.",
	dragItem: (t) => `Déplacer ${t.itemText}`,
	dragSelectedItems: (t, e) =>
		`Déplacer ${e.plural(t.count, { one: () => `${e.number(t.count)} élément sélectionné`, other: () => `${e.number(t.count)} éléments sélectionnés` })}`,
	dragSelectedKeyboard: (t, e) =>
		`Appuyez sur Entrée pour faire glisser ${e.plural(t.count, { one: () => `${e.number(t.count)} élément sélectionné`, other: () => `${e.number(t.count)} éléments sélectionnés` })}.`,
	dragSelectedKeyboardAlt: (t, e) =>
		`Appuyez sur Alt + Entrée pour faire glisser ${e.plural(t.count, { one: () => `${e.number(t.count)} élément sélectionné`, other: () => `${e.number(t.count)} éléments sélectionnés` })}.`,
	dragSelectedLongPress: (t, e) =>
		`Appuyez de manière prolongée pour faire glisser ${e.plural(t.count, { one: () => `${e.number(t.count)} élément sélectionné`, other: () => `${e.number(t.count)} éléments sélectionnés` })}.`,
	dragStartedKeyboard:
		"Déplacement commencé. Appuyez sur Tabulation pour accéder à une cible de dépôt, puis appuyez sur Entrée pour déposer, ou appuyez sur Échap pour annuler.",
	dragStartedTouch:
		"Déplacement commencé. Accédez à une cible de dépôt, puis touchez deux fois pour déposer.",
	dragStartedVirtual:
		"Déplacement commencé. Accédez à une cible de dépôt, puis cliquez ou appuyez sur Entrée pour déposer.",
	dropCanceled: "Dépôt annulé.",
	dropComplete: "Dépôt terminé.",
	dropDescriptionKeyboard:
		"Appuyez sur Entrée pour déposer. Appuyez sur Échap pour annuler le déplacement.",
	dropDescriptionTouch: "Touchez deux fois pour déposer.",
	dropDescriptionVirtual: "Cliquez pour déposer.",
	dropIndicator: "indicateur de dépôt",
	dropOnItem: (t) => `Déposer sur ${t.itemText}`,
	dropOnRoot: "Déposer sur",
	endDragKeyboard:
		"Déplacement. Appuyez sur Entrée pour annuler le déplacement.",
	endDragTouch: "Déplacement. Touchez deux fois pour annuler le déplacement.",
	endDragVirtual: "Déplacement. Cliquez pour annuler le déplacement.",
	insertAfter: (t) => `Insérer après ${t.itemText}`,
	insertBefore: (t) => `Insérer avant ${t.itemText}`,
	insertBetween: (t) =>
		`Insérer entre ${t.beforeItemText} et ${t.afterItemText}`,
};
var rM = {};
rM = {
	dragDescriptionKeyboard: "הקש על Enter כדי להתחיל לגרור.",
	dragDescriptionKeyboardAlt: "הקש Alt + Enter כדי להתחיל לגרור.",
	dragDescriptionLongPress: "לחץ לחיצה ארוכה כדי להתחיל לגרור.",
	dragDescriptionTouch: "הקש פעמיים כדי להתחיל בגרירה.",
	dragDescriptionVirtual: "לחץ כדי להתחיל לגרור.",
	dragItem: (t) => `גרור את ${t.itemText}`,
	dragSelectedItems: (t, e) =>
		`גרור ${e.plural(t.count, { one: () => `פריט נבחר ${e.number(t.count)}`, other: () => `${e.number(t.count)} פריטים שנבחרו` })}`,
	dragSelectedKeyboard: (t, e) =>
		`הקש על Enter כדי לגרור ${e.plural(t.count, { one: () => `${e.number(t.count)} פריט שנבחר`, other: () => `${e.number(t.count)} פריטים שנבחרו` })}.`,
	dragSelectedKeyboardAlt: (t, e) =>
		`הקש Alt + Enter כדי לגרור ${e.plural(t.count, { one: () => `${e.number(t.count)} פריט שנבחר`, other: () => `${e.number(t.count)} פריטים שנבחרו` })}.`,
	dragSelectedLongPress: (t, e) =>
		`לחץ לחיצה ארוכה כדי לגרור ${e.plural(t.count, { one: () => `${e.number(t.count)} פריט שנבחר`, other: () => `${e.number(t.count)} פריטים שנבחרו` })}.`,
	dragStartedKeyboard:
		"התחלת לגרור. הקש על Tab כדי לנווט לנקודת הגרירה ולאחר מכן הקש על Enter כדי לשחרר או על Escape כדי לבטל.",
	dragStartedTouch:
		"התחלת לגרור. נווט לנקודת השחרור ולאחר מכן הקש פעמיים כדי לשחרר.",
	dragStartedVirtual:
		"התחלת לגרור. נווט לנקודת השחרור ולאחר מכן לחץ או הקש על Enter כדי לשחרר.",
	dropCanceled: "השחרור בוטל.",
	dropComplete: "השחרור הושלם.",
	dropDescriptionKeyboard:
		"הקש על Enter כדי לשחרר. הקש על Escape כדי לבטל את הגרירה.",
	dropDescriptionTouch: "הקש פעמיים כדי לשחרר.",
	dropDescriptionVirtual: "לחץ כדי לשחרר.",
	dropIndicator: "מחוון שחרור",
	dropOnItem: (t) => `שחרר על ${t.itemText}`,
	dropOnRoot: "שחרר על",
	endDragKeyboard: "גורר. הקש על Enter כדי לבטל את הגרירה.",
	endDragTouch: "גורר. הקש פעמיים כדי לבטל את הגרירה.",
	endDragVirtual: "גורר. לחץ כדי לבטל את הגרירה.",
	insertAfter: (t) => `הוסף אחרי ${t.itemText}`,
	insertBefore: (t) => `הוסף לפני ${t.itemText}`,
	insertBetween: (t) =>
		`הוסף בין ${t.beforeItemText} לבין ${t.afterItemText}`,
};
var iM = {};
iM = {
	dragDescriptionKeyboard: "Pritisnite Enter da biste počeli povlačiti.",
	dragDescriptionKeyboardAlt: "Pritisnite Alt + Enter za početak povlačenja.",
	dragDescriptionLongPress: "Dugo pritisnite za početak povlačenja.",
	dragDescriptionTouch: "Dvaput dodirnite da biste počeli povlačiti.",
	dragDescriptionVirtual: "Kliknite da biste počeli povlačiti.",
	dragItem: (t) => `Povucite stavku ${t.itemText}`,
	dragSelectedItems: (t, e) =>
		`Povucite ${e.plural(t.count, { one: () => `${e.number(t.count)} odabranu stavku`, other: () => `ovoliko odabranih stavki: ${e.number(t.count)}` })}`,
	dragSelectedKeyboard: (t, e) =>
		`Pritisnite Enter za povlačenje ${e.plural(t.count, { one: () => `${e.number(t.count)} odabrana stavka`, other: () => `${e.number(t.count)} odabrane stavke` })}.`,
	dragSelectedKeyboardAlt: (t, e) =>
		`Pritisnite Alt + Enter za povlačenje ${e.plural(t.count, { one: () => `${e.number(t.count)} odabrana stavka`, other: () => `${e.number(t.count)} odabrane stavke` })}.`,
	dragSelectedLongPress: (t, e) =>
		`Dugo pritisnite za povlačenje ${e.plural(t.count, { one: () => `${e.number(t.count)} odabrana stavka`, other: () => `${e.number(t.count)} odabrane stavke` })}.`,
	dragStartedKeyboard:
		"Počeli ste povlačiti. Pritisnite tipku tabulatora da biste došli do cilja ispuštanja, a zatim Enter da biste ispustili stavku ili Escape da biste prekinuli povlačenje.",
	dragStartedTouch:
		"Počeli ste povlačiti. Dođite do cilja ispuštanja, a zatim dvaput dodirnite da biste ispustili stavku.",
	dragStartedVirtual:
		"Počeli ste povlačiti. Dođite do cilja ispuštanja, a zatim kliknite ili pritisnite Enter da biste ispustili stavku.",
	dropCanceled: "Povlačenje je prekinuto.",
	dropComplete: "Ispuštanje je dovršeno.",
	dropDescriptionKeyboard:
		"Pritisnite Enter da biste ispustili stavku. Pritisnite Escape da biste prekinuli povlačenje.",
	dropDescriptionTouch: "Dvaput dodirnite da biste ispustili stavku.",
	dropDescriptionVirtual: "Kliknite da biste ispustili stavku.",
	dropIndicator: "pokazatelj ispuštanja",
	dropOnItem: (t) => `Ispustite na stavku ${t.itemText}`,
	dropOnRoot: "Ispustite na",
	endDragKeyboard:
		"Povlačenje. Pritisnite Enter da biste prekinuli povlačenje.",
	endDragTouch: "Povlačenje. Dvaput dodirnite da biste prekinuli povlačenje.",
	endDragVirtual: "Povlačenje. Kliknite da biste prekinuli povlačenje.",
	insertAfter: (t) => `Umetnite iza stavke ${t.itemText}`,
	insertBefore: (t) => `Ispustite ispred stavke ${t.itemText}`,
	insertBetween: (t) =>
		`Umetnite između stavki ${t.beforeItemText} i ${t.afterItemText}`,
};
var oM = {};
oM = {
	dragDescriptionKeyboard:
		"Nyomja le az Enter billentyűt a húzás megkezdéséhez.",
	dragDescriptionKeyboardAlt:
		"Nyomja le az Alt + Enter billentyűket a húzás megkezdéséhez.",
	dragDescriptionLongPress: "Hosszan nyomja meg a húzás elindításához.",
	dragDescriptionTouch: "Koppintson duplán a húzás megkezdéséhez.",
	dragDescriptionVirtual: "Kattintson a húzás megkezdéséhez.",
	dragItem: (t) => `${t.itemText} húzása`,
	dragSelectedItems: (t, e) =>
		`${e.plural(t.count, { one: () => `${e.number(t.count)} kijelölt elem`, other: () => `${e.number(t.count)} kijelölt elem` })} húzása`,
	dragSelectedKeyboard: (t, e) =>
		`Nyomja meg az Entert ${e.plural(t.count, { one: () => `${e.number(t.count)} kijelölt elem`, other: () => `${e.number(t.count)} kijelölt elem` })} húzásához.`,
	dragSelectedKeyboardAlt: (t, e) =>
		`Nyomja meg az Alt + Enter billentyűket ${e.plural(t.count, { one: () => `${e.number(t.count)} kijelölt elem`, other: () => `${e.number(t.count)} kijelölt elem` })} húzásához.`,
	dragSelectedLongPress: (t, e) =>
		`Tartsa lenyomva hosszan ${e.plural(t.count, { one: () => `${e.number(t.count)} kijelölt elem`, other: () => `${e.number(t.count)} kijelölt elem` })} húzásához.`,
	dragStartedKeyboard:
		"Húzás megkezdve. Nyomja le a Tab billentyűt az elengedési célhoz navigálásához, majd nyomja le az Enter billentyűt az elengedéshez, vagy nyomja le az Escape billentyűt a megszakításhoz.",
	dragStartedTouch:
		"Húzás megkezdve. Navigáljon egy elengedési célhoz, majd koppintson duplán az elengedéshez.",
	dragStartedVirtual:
		"Húzás megkezdve. Navigáljon egy elengedési célhoz, majd kattintson vagy nyomja le az Enter billentyűt az elengedéshez.",
	dropCanceled: "Elengedés megszakítva.",
	dropComplete: "Elengedés teljesítve.",
	dropDescriptionKeyboard:
		"Nyomja le az Enter billentyűt az elengedéshez. Nyomja le az Escape billentyűt a húzás megszakításához.",
	dropDescriptionTouch: "Koppintson duplán az elengedéshez.",
	dropDescriptionVirtual: "Kattintson az elengedéshez.",
	dropIndicator: "elengedésjelző",
	dropOnItem: (t) => `Elengedés erre: ${t.itemText}`,
	dropOnRoot: "Elengedés erre:",
	endDragKeyboard:
		"Húzás folyamatban. Nyomja le az Enter billentyűt a húzás megszakításához.",
	endDragTouch:
		"Húzás folyamatban. Koppintson duplán a húzás megszakításához.",
	endDragVirtual: "Húzás folyamatban. Kattintson a húzás megszakításához.",
	insertAfter: (t) => `Beszúrás ${t.itemText} után`,
	insertBefore: (t) => `Beszúrás ${t.itemText} elé`,
	insertBetween: (t) =>
		`Beszúrás ${t.beforeItemText} és ${t.afterItemText} közé`,
};
var sM = {};
sM = {
	dragDescriptionKeyboard: "Premi Invio per iniziare a trascinare.",
	dragDescriptionKeyboardAlt: "Premi Alt + Invio per iniziare a trascinare.",
	dragDescriptionLongPress: "Premi a lungo per iniziare a trascinare.",
	dragDescriptionTouch: "Tocca due volte per iniziare a trascinare.",
	dragDescriptionVirtual: "Fai clic per iniziare a trascinare.",
	dragItem: (t) => `Trascina ${t.itemText}`,
	dragSelectedItems: (t, e) =>
		`Trascina ${e.plural(t.count, { one: () => `${e.number(t.count)} altro elemento selezionato`, other: () => `${e.number(t.count)} altri elementi selezionati` })}`,
	dragSelectedKeyboard: (t, e) =>
		`Premi Invio per trascinare ${e.plural(t.count, { one: () => `${e.number(t.count)} elemento selezionato`, other: () => `${e.number(t.count)} elementi selezionati` })}.`,
	dragSelectedKeyboardAlt: (t, e) =>
		`Premi Alt + Invio per trascinare ${e.plural(t.count, { one: () => `${e.number(t.count)} elemento selezionato`, other: () => `${e.number(t.count)} elementi selezionati` })}.`,
	dragSelectedLongPress: (t, e) =>
		`Premi a lungo per trascinare ${e.plural(t.count, { one: () => `${e.number(t.count)} elemento selezionato`, other: () => `${e.number(t.count)} elementi selezionati` })}.`,
	dragStartedKeyboard:
		"Hai iniziato a trascinare. Premi Tab per arrivare sull’area di destinazione, quindi premi Invio per rilasciare o Esc per annullare.",
	dragStartedTouch:
		"Hai iniziato a trascinare. Arriva sull’area di destinazione, quindi tocca due volte per rilasciare.",
	dragStartedVirtual:
		"Hai iniziato a trascinare. Arriva sull’area di destinazione, quindi fai clic o premi Invio per rilasciare.",
	dropCanceled: "Rilascio annullato.",
	dropComplete: "Rilascio completato.",
	dropDescriptionKeyboard:
		"Premi Invio per rilasciare. Premi Esc per annullare.",
	dropDescriptionTouch: "Tocca due volte per rilasciare.",
	dropDescriptionVirtual: "Fai clic per rilasciare.",
	dropIndicator: "indicatore di rilascio",
	dropOnItem: (t) => `Rilascia su ${t.itemText}`,
	dropOnRoot: "Rilascia su",
	endDragKeyboard: "Trascinamento. Premi Invio per annullare.",
	endDragTouch: "Trascinamento. Tocca due volte per annullare.",
	endDragVirtual: "Trascinamento. Fai clic per annullare.",
	insertAfter: (t) => `Inserisci dopo ${t.itemText}`,
	insertBefore: (t) => `Inserisci prima di ${t.itemText}`,
	insertBetween: (t) =>
		`Inserisci tra ${t.beforeItemText} e ${t.afterItemText}`,
};
var aM = {};
aM = {
	dragDescriptionKeyboard: "Enter キーを押してドラッグを開始してください。",
	dragDescriptionKeyboardAlt: "Alt+Enter キーを押してドラッグを開始します。",
	dragDescriptionLongPress: "長押ししてドラッグを開始します。",
	dragDescriptionTouch: "ダブルタップしてドラッグを開始します。",
	dragDescriptionVirtual: "クリックしてドラッグを開始します。",
	dragItem: (t) => `${t.itemText} をドラッグ`,
	dragSelectedItems: (t, e) =>
		`${e.plural(t.count, { one: () => `${e.number(t.count)} 個の選択項目`, other: () => `${e.number(t.count)} 個の選択項目` })} をドラッグ`,
	dragSelectedKeyboard: (t, e) =>
		`Enter キーを押して、${e.plural(t.count, { one: () => `${e.number(t.count)} 選択した項目`, other: () => `${e.number(t.count)} 選択した項目` })}をドラッグします。`,
	dragSelectedKeyboardAlt: (t, e) =>
		`Alt+Enter キーを押して、${e.plural(t.count, { one: () => `${e.number(t.count)} 選択した項目`, other: () => `${e.number(t.count)} 選択した項目` })}をドラッグします。`,
	dragSelectedLongPress: (t, e) =>
		`長押しして、${e.plural(t.count, { one: () => `${e.number(t.count)} 選択した項目`, other: () => `${e.number(t.count)} 選択した項目` })}をドラッグします。`,
	dragStartedKeyboard:
		"ドラッグを開始します。Tab キーを押してドロップターゲットにいどうし、Enter キーを押してドロップするか、Esc キーを押してキャンセルします。",
	dragStartedTouch:
		"ドラッグを開始しました。ドロップのターゲットに移動し、ダブルタップしてドロップします。",
	dragStartedVirtual:
		"ドラッグを開始しました。ドロップのターゲットに移動し、クリックまたは Enter キーを押してドロップします。",
	dropCanceled: "ドロップがキャンセルされました。",
	dropComplete: "ドロップが完了しました。",
	dropDescriptionKeyboard:
		"Enter キーを押してドロップします。Esc キーを押してドラッグをキャンセルします。",
	dropDescriptionTouch: "ダブルタップしてドロップします。",
	dropDescriptionVirtual: "クリックしてドロップします。",
	dropIndicator: "ドロップインジケーター",
	dropOnItem: (t) => `${t.itemText} にドロップ`,
	dropOnRoot: "ドロップ場所",
	endDragKeyboard:
		"ドラッグしています。Enter キーを押してドラッグをキャンセルします。",
	endDragTouch:
		"ドラッグしています。ダブルタップしてドラッグをキャンセルします。",
	endDragVirtual:
		"ドラッグしています。クリックしてドラッグをキャンセルします。",
	insertAfter: (t) => `${t.itemText} の後に挿入`,
	insertBefore: (t) => `${t.itemText} の前に挿入`,
	insertBetween: (t) =>
		`${t.beforeItemText} と ${t.afterItemText} の間に挿入`,
};
var lM = {};
lM = {
	dragDescriptionKeyboard: "드래그를 시작하려면 Enter를 누르세요.",
	dragDescriptionKeyboardAlt: "드래그를 시작하려면 Alt + Enter를 누르십시오.",
	dragDescriptionLongPress: "드래그를 시작하려면 길게 누르십시오.",
	dragDescriptionTouch: "드래그를 시작하려면 더블 탭하세요.",
	dragDescriptionVirtual: "드래그를 시작하려면 클릭하세요.",
	dragItem: (t) => `${t.itemText} 드래그`,
	dragSelectedItems: (t, e) =>
		`${e.plural(t.count, { one: () => `${e.number(t.count)}개 선택 항목`, other: () => `${e.number(t.count)}개 선택 항목` })} 드래그`,
	dragSelectedKeyboard: (t, e) =>
		`${e.plural(t.count, { one: () => `${e.number(t.count)}개 선택 항목`, other: () => `${e.number(t.count)}개 선택 항목` })}을 드래그하려면 Enter를 누르십시오.`,
	dragSelectedKeyboardAlt: (t, e) =>
		`${e.plural(t.count, { one: () => `${e.number(t.count)}개 선택 항목`, other: () => `${e.number(t.count)}개 선택 항목` })}을 드래그하려면 Alt + Enter를 누르십시오.`,
	dragSelectedLongPress: (t, e) =>
		`${e.plural(t.count, { one: () => `${e.number(t.count)}개 선택 항목`, other: () => `${e.number(t.count)}개 선택 항목` })}을 드래그하려면 길게 누르십시오.`,
	dragStartedKeyboard:
		"드래그가 시작되었습니다. Tab을 눌러 드롭 대상으로 이동한 다음 Enter를 눌러 드롭하거나 Esc를 눌러 취소하세요.",
	dragStartedTouch:
		"드래그가 시작되었습니다. 드롭 대상으로 이동한 다음 더블 탭하여 드롭하세요.",
	dragStartedVirtual:
		"드래그가 시작되었습니다. 드롭 대상으로 이동한 다음 클릭하거나 Enter를 눌러 드롭하세요.",
	dropCanceled: "드롭이 취소되었습니다.",
	dropComplete: "드롭이 완료되었습니다.",
	dropDescriptionKeyboard:
		"드롭하려면 Enter를 누르세요. 드래그를 취소하려면 Esc를 누르세요.",
	dropDescriptionTouch: "더블 탭하여 드롭하세요.",
	dropDescriptionVirtual: "드롭하려면 클릭하세요.",
	dropIndicator: "드롭 표시기",
	dropOnItem: (t) => `${t.itemText}에 드롭`,
	dropOnRoot: "드롭 대상",
	endDragKeyboard: "드래그 중입니다. 드래그를 취소하려면 Enter를 누르세요.",
	endDragTouch: "드래그 중입니다. 드래그를 취소하려면 더블 탭하세요.",
	endDragVirtual: "드래그 중입니다. 드래그를 취소하려면 클릭하세요.",
	insertAfter: (t) => `${t.itemText} 이후에 삽입`,
	insertBefore: (t) => `${t.itemText} 이전에 삽입`,
	insertBetween: (t) =>
		`${t.beforeItemText} 및 ${t.afterItemText} 사이에 삽입`,
};
var uM = {};
uM = {
	dragDescriptionKeyboard: "Paspauskite „Enter“, kad pradėtumėte vilkti.",
	dragDescriptionKeyboardAlt:
		"Paspauskite „Alt + Enter“, kad pradėtumėte vilkti.",
	dragDescriptionLongPress: "Palaikykite nuspaudę, kad pradėtumėte vilkti.",
	dragDescriptionTouch: "Palieskite dukart, kad pradėtumėte vilkti.",
	dragDescriptionVirtual: "Spustelėkite, kad pradėtumėte vilkti.",
	dragItem: (t) => `Vilkti ${t.itemText}`,
	dragSelectedItems: (t, e) =>
		`Vilkti ${e.plural(t.count, { one: () => `${e.number(t.count)} pasirinktą elementą`, other: () => `${e.number(t.count)} pasirinktus elementus` })}`,
	dragSelectedKeyboard: (t, e) =>
		`Paspauskite „Enter“, jei norite nuvilkti ${e.plural(t.count, { one: () => `${e.number(t.count)} pasirinktą elementą`, other: () => `${e.number(t.count)} pasirinktus elementus` })}.`,
	dragSelectedKeyboardAlt: (t, e) =>
		`Paspauskite „Alt + Enter“, kad nuvilktumėte ${e.plural(t.count, { one: () => `${e.number(t.count)} pasirinktą elementą`, other: () => `${e.number(t.count)} pasirinktus elementus` })}.`,
	dragSelectedLongPress: (t, e) =>
		`Nuspaudę palaikykite, kad nuvilktumėte ${e.plural(t.count, { one: () => `${e.number(t.count)} pasirinktą elementą`, other: () => `${e.number(t.count)} pasirinktus elementus` })}.`,
	dragStartedKeyboard:
		"Pradėta vilkti. Paspauskite „Tab“, kad pereitumėte į tiesioginę paskirties vietą, tada paspauskite „Enter“, kad numestumėte, arba „Escape“, kad atšauktumėte.",
	dragStartedTouch:
		"Pradėta vilkti. Eikite į tiesioginę paskirties vietą, tada palieskite dukart, kad numestumėte.",
	dragStartedVirtual:
		"Pradėta vilkti. Eikite į tiesioginę paskirties vietą ir spustelėkite arba paspauskite „Enter“, kad numestumėte.",
	dropCanceled: "Numetimas atšauktas.",
	dropComplete: "Numesta.",
	dropDescriptionKeyboard:
		"Paspauskite „Enter“, kad numestumėte. Paspauskite „Escape“, kad atšauktumėte vilkimą.",
	dropDescriptionTouch: "Palieskite dukart, kad numestumėte.",
	dropDescriptionVirtual: "Spustelėkite, kad numestumėte.",
	dropIndicator: "numetimo indikatorius",
	dropOnItem: (t) => `Numesti ant ${t.itemText}`,
	dropOnRoot: "Numesti ant",
	endDragKeyboard: "Velkama. Paspauskite „Enter“, kad atšauktumėte vilkimą.",
	endDragTouch: "Velkama. Spustelėkite dukart, kad atšauktumėte vilkimą.",
	endDragVirtual: "Velkama. Spustelėkite, kad atšauktumėte vilkimą.",
	insertAfter: (t) => `Įterpti po ${t.itemText}`,
	insertBefore: (t) => `Įterpti prieš ${t.itemText}`,
	insertBetween: (t) =>
		`Įterpti tarp ${t.beforeItemText} ir ${t.afterItemText}`,
};
var cM = {};
cM = {
	dragDescriptionKeyboard: "Nospiediet Enter, lai sāktu vilkšanu.",
	dragDescriptionKeyboardAlt:
		"Nospiediet taustiņu kombināciju Alt+Enter, lai sāktu vilkšanu.",
	dragDescriptionLongPress: "Turiet nospiestu, lai sāktu vilkšanu.",
	dragDescriptionTouch: "Veiciet dubultskārienu, lai sāktu vilkšanu.",
	dragDescriptionVirtual: "Noklikšķiniet, lai sāktu vilkšanu.",
	dragItem: (t) => `Velciet ${t.itemText}`,
	dragSelectedItems: (t, e) =>
		`Velciet ${e.plural(t.count, { one: () => `${e.number(t.count)} atlasīto vienumu`, other: () => `${e.number(t.count)} atlasītos vienumus` })}`,
	dragSelectedKeyboard: (t, e) =>
		`Nospiediet taustiņu Enter, lai vilktu ${e.plural(t.count, { one: () => `${e.number(t.count)} atlasīto vienumu`, other: () => `${e.number(t.count)} atlasītos vienumus` })}.`,
	dragSelectedKeyboardAlt: (t, e) =>
		`Nospiediet taustiņu kombināciju Alt+Enter, lai vilktu ${e.plural(t.count, { one: () => `${e.number(t.count)} atlasīto vienumu`, other: () => `${e.number(t.count)} atlasītos vienumus` })}.`,
	dragSelectedLongPress: (t, e) =>
		`Turiet nospiestu, lai vilktu ${e.plural(t.count, { one: () => `${e.number(t.count)} atlasīto vienumu`, other: () => `${e.number(t.count)} atlasītos vienumus` })}.`,
	dragStartedKeyboard:
		"Uzsākta vilkšana. Nospiediet taustiņu Tab, lai pārietu uz nomešanas mērķi, pēc tam nospiediet Enter, lai nomestu, vai nospiediet Escape, lai atceltu.",
	dragStartedTouch:
		"Uzsākta vilkšana. Pārejiet uz nomešanas mērķi, pēc tam veiciet dubultskārienu, lai nomestu.",
	dragStartedVirtual:
		"Uzsākta vilkšana. Pārejiet uz nomešanas mērķi, pēc tam nospiediet Enter, lai nomestu.",
	dropCanceled: "Nomešana atcelta.",
	dropComplete: "Nomešana pabeigta.",
	dropDescriptionKeyboard:
		"Nospiediet Enter, lai nomestu. Nospiediet Escape, lai atceltu vilkšanu.",
	dropDescriptionTouch: "Veiciet dubultskārienu, lai nomestu.",
	dropDescriptionVirtual: "Noklikšķiniet, lai nomestu.",
	dropIndicator: "nomešanas indikators",
	dropOnItem: (t) => `Nometiet uz ${t.itemText}`,
	dropOnRoot: "Nometiet uz",
	endDragKeyboard: "Notiek vilkšana. Nospiediet Enter, lai atceltu vilkšanu.",
	endDragTouch:
		"Notiek vilkšana. Veiciet dubultskārienu, lai atceltu vilkšanu.",
	endDragVirtual: "Notiek vilkšana. Noklikšķiniet, lai atceltu vilkšanu.",
	insertAfter: (t) => `Ievietojiet pēc ${t.itemText}`,
	insertBefore: (t) => `Ievietojiet pirms ${t.itemText}`,
	insertBetween: (t) =>
		`Ievietojiet starp ${t.beforeItemText} un ${t.afterItemText}`,
};
var dM = {};
dM = {
	dragDescriptionKeyboard: "Trykk på Enter for å begynne å dra.",
	dragDescriptionKeyboardAlt: "Trykk på Alt + Enter for å begynne å dra.",
	dragDescriptionLongPress: "Trykk lenge for å begynne å dra.",
	dragDescriptionTouch: "Dobbelttrykk for å begynne å dra.",
	dragDescriptionVirtual: "Klikk for å begynne å dra.",
	dragItem: (t) => `Dra ${t.itemText}`,
	dragSelectedItems: (t, e) =>
		`Dra ${e.plural(t.count, { one: () => `${e.number(t.count)} merket element`, other: () => `${e.number(t.count)} merkede elementer` })}`,
	dragSelectedKeyboard: (t, e) =>
		`Trykk Enter for å dra ${e.plural(t.count, { one: () => `${e.number(t.count)} valgt element`, other: () => `${e.number(t.count)} valgte elementer` })}.`,
	dragSelectedKeyboardAlt: (t, e) =>
		`Trykk på Alt + Enter for å dra ${e.plural(t.count, { one: () => `${e.number(t.count)} valgt element`, other: () => `${e.number(t.count)} valgte elementer` })}.`,
	dragSelectedLongPress: (t, e) =>
		`Trykk lenge for å dra ${e.plural(t.count, { one: () => `${e.number(t.count)} valgt element`, other: () => `${e.number(t.count)} valgte elementer` })}.`,
	dragStartedKeyboard:
		"Begynte å dra. Trykk på Tab for å navigere til et mål, og trykk deretter på Enter for å slippe eller på Esc for å avbryte.",
	dragStartedTouch:
		"Begynte å dra. Naviger til et mål, og dobbelttrykk for å slippe.",
	dragStartedVirtual:
		"Begynte å dra. Naviger til et mål, og klikk eller trykk på Enter for å slippe.",
	dropCanceled: "Avbrøt slipping.",
	dropComplete: "Slippingen er fullført.",
	dropDescriptionKeyboard:
		"Trykk på Enter for å slippe. Trykk på Esc hvis du vil avbryte draingen.",
	dropDescriptionTouch: "Dobbelttrykk for å slippe.",
	dropDescriptionVirtual: "Klikk for å slippe.",
	dropIndicator: "slippeindikator",
	dropOnItem: (t) => `Slipp på ${t.itemText}`,
	dropOnRoot: "Slipp på",
	endDragKeyboard: "Drar. Trykk på Enter hvis du vil avbryte.",
	endDragTouch: "Drar. Dobbelttrykk hvis du vil avbryte.",
	endDragVirtual: "Drar. Klikk hvis du vil avbryte.",
	insertAfter: (t) => `Sett inn etter ${t.itemText}`,
	insertBefore: (t) => `Sett inn før ${t.itemText}`,
	insertBetween: (t) =>
		`Sett inn mellom ${t.beforeItemText} og ${t.afterItemText}`,
};
var fM = {};
fM = {
	dragDescriptionKeyboard: "Druk op Enter om te slepen.",
	dragDescriptionKeyboardAlt: "Druk op Alt + Enter om te slepen.",
	dragDescriptionLongPress: "Houd lang ingedrukt om te slepen.",
	dragDescriptionTouch: "Dubbeltik om te slepen.",
	dragDescriptionVirtual: "Klik om met slepen te starten.",
	dragItem: (t) => `${t.itemText} slepen`,
	dragSelectedItems: (t, e) =>
		`${e.plural(t.count, { one: () => `${e.number(t.count)} geselecteerd item`, other: () => `${e.number(t.count)} geselecteerde items` })} slepen`,
	dragSelectedKeyboard: (t, e) =>
		`Druk op Enter om ${e.plural(t.count, { one: () => `${e.number(t.count)} geselecteerd item`, other: () => `${e.number(t.count)} geselecteerde items` })} te slepen.`,
	dragSelectedKeyboardAlt: (t, e) =>
		`Druk op Alt + Enter om ${e.plural(t.count, { one: () => `${e.number(t.count)} geselecteerd item`, other: () => `${e.number(t.count)} geselecteerde items` })} te slepen.`,
	dragSelectedLongPress: (t, e) =>
		`Houd lang ingedrukt om ${e.plural(t.count, { one: () => `${e.number(t.count)} geselecteerd item`, other: () => `${e.number(t.count)} geselecteerde items` })} te slepen.`,
	dragStartedKeyboard:
		"Begonnen met slepen. Druk op Tab om naar een locatie te gaan. Druk dan op Enter om neer te zetten, of op Esc om te annuleren.",
	dragStartedTouch:
		"Begonnen met slepen. Ga naar de gewenste locatie en dubbeltik om neer te zetten.",
	dragStartedVirtual:
		"Begonnen met slepen. Ga naar de gewenste locatie en klik of druk op Enter om neer te zetten.",
	dropCanceled: "Neerzetten geannuleerd.",
	dropComplete: "Neerzetten voltooid.",
	dropDescriptionKeyboard:
		"Druk op Enter om neer te zetten. Druk op Esc om het slepen te annuleren.",
	dropDescriptionTouch: "Dubbeltik om neer te zetten.",
	dropDescriptionVirtual: "Klik om neer te zetten.",
	dropIndicator: "aanwijzer voor neerzetten",
	dropOnItem: (t) => `Neerzetten op ${t.itemText}`,
	dropOnRoot: "Neerzetten op",
	endDragKeyboard: "Bezig met slepen. Druk op Enter om te annuleren.",
	endDragTouch: "Bezig met slepen. Dubbeltik om te annuleren.",
	endDragVirtual: "Bezig met slepen. Klik om te annuleren.",
	insertAfter: (t) => `Plaatsen na ${t.itemText}`,
	insertBefore: (t) => `Plaatsen vóór ${t.itemText}`,
	insertBetween: (t) =>
		`Plaatsen tussen ${t.beforeItemText} en ${t.afterItemText}`,
};
var hM = {};
hM = {
	dragDescriptionKeyboard: "Naciśnij Enter, aby rozpocząć przeciąganie.",
	dragDescriptionKeyboardAlt:
		"Naciśnij Alt + Enter, aby rozpocząć przeciąganie.",
	dragDescriptionLongPress:
		"Naciśnij i przytrzymaj, aby rozpocząć przeciąganie.",
	dragDescriptionTouch: "Dotknij dwukrotnie, aby rozpocząć przeciąganie.",
	dragDescriptionVirtual: "Kliknij, aby rozpocząć przeciąganie.",
	dragItem: (t) => `Przeciągnij ${t.itemText}`,
	dragSelectedItems: (t, e) =>
		`Przeciągnij ${e.plural(t.count, { one: () => `${e.number(t.count)} wybrany element`, other: () => `${e.number(t.count)} wybranych elementów` })}`,
	dragSelectedKeyboard: (t, e) =>
		`Naciśnij Enter, aby przeciągnąć ${e.plural(t.count, { one: () => `${e.number(t.count)} wybrany element`, other: () => `${e.number(t.count)} wybrane(-ych) elementy(-ów)` })}.`,
	dragSelectedKeyboardAlt: (t, e) =>
		`Naciśnij Alt + Enter, aby przeciągnąć ${e.plural(t.count, { one: () => `${e.number(t.count)} wybrany element`, other: () => `${e.number(t.count)} wybrane(-ych) elementy(-ów)` })}.`,
	dragSelectedLongPress: (t, e) =>
		`Naciśnij i przytrzymaj, aby przeciągnąć ${e.plural(t.count, { one: () => `${e.number(t.count)} wybrany element`, other: () => `${e.number(t.count)} wybrane(-ych) elementy(-ów)` })}.`,
	dragStartedKeyboard:
		"Rozpoczęto przeciąganie. Naciśnij Tab, aby wybrać miejsce docelowe, a następnie naciśnij Enter, aby upuścić, lub Escape, aby anulować.",
	dragStartedTouch:
		"Rozpoczęto przeciąganie. Wybierz miejsce, w którym chcesz upuścić element, a następnie dotknij dwukrotnie, aby upuścić.F",
	dragStartedVirtual:
		"Rozpoczęto przeciąganie. Wybierz miejsce, w którym chcesz upuścić element, a następnie kliknij lub naciśnij Enter, aby upuścić.",
	dropCanceled: "Anulowano upuszczenie.",
	dropComplete: "Zakończono upuszczanie.",
	dropDescriptionKeyboard:
		"Naciśnij Enter, aby upuścić. Naciśnij Escape, aby anulować przeciągnięcie.",
	dropDescriptionTouch: "Dotknij dwukrotnie, aby upuścić.",
	dropDescriptionVirtual: "Kliknij, aby upuścić.",
	dropIndicator: "wskaźnik upuszczenia",
	dropOnItem: (t) => `Upuść na ${t.itemText}`,
	dropOnRoot: "Upuść",
	endDragKeyboard:
		"Przeciąganie. Naciśnij Enter, aby anulować przeciągnięcie.",
	endDragTouch:
		"Przeciąganie. Kliknij dwukrotnie, aby anulować przeciągnięcie.",
	endDragVirtual: "Przeciąganie. Kliknij, aby anulować przeciąganie.",
	insertAfter: (t) => `Umieść za ${t.itemText}`,
	insertBefore: (t) => `Umieść przed ${t.itemText}`,
	insertBetween: (t) =>
		`Umieść między ${t.beforeItemText} i ${t.afterItemText}`,
};
var pM = {};
pM = {
	dragDescriptionKeyboard: "Pressione Enter para começar a arrastar.",
	dragDescriptionKeyboardAlt:
		"Pressione Alt + Enter para começar a arrastar.",
	dragDescriptionLongPress: "Pressione e segure para começar a arrastar.",
	dragDescriptionTouch: "Toque duas vezes para começar a arrastar.",
	dragDescriptionVirtual: "Clique para começar a arrastar.",
	dragItem: (t) => `Arrastar ${t.itemText}`,
	dragSelectedItems: (t, e) =>
		`Arrastar ${e.plural(t.count, { one: () => `${e.number(t.count)} item selecionado`, other: () => `${e.number(t.count)} itens selecionados` })}`,
	dragSelectedKeyboard: (t, e) =>
		`Pressione Enter para arrastar ${e.plural(t.count, { one: () => `${e.number(t.count)} o item selecionado`, other: () => `${e.number(t.count)} os itens selecionados` })}.`,
	dragSelectedKeyboardAlt: (t, e) =>
		`Pressione Alt + Enter para arrastar ${e.plural(t.count, { one: () => `${e.number(t.count)} o item selecionado`, other: () => `${e.number(t.count)} os itens selecionados` })}.`,
	dragSelectedLongPress: (t, e) =>
		`Pressione e segure para arrastar ${e.plural(t.count, { one: () => `${e.number(t.count)} o item selecionado`, other: () => `${e.number(t.count)} os itens selecionados` })}.`,
	dragStartedKeyboard:
		"Comece a arrastar. Pressione Tab para navegar até um alvo e, em seguida, pressione Enter para soltar ou pressione Escape para cancelar.",
	dragStartedTouch:
		"Comece a arrastar. Navegue até um alvo e toque duas vezes para soltar.",
	dragStartedVirtual:
		"Comece a arrastar. Navegue até um alvo e clique ou pressione Enter para soltar.",
	dropCanceled: "Liberação cancelada.",
	dropComplete: "Liberação concluída.",
	dropDescriptionKeyboard:
		"Pressione Enter para soltar. Pressione Escape para cancelar.",
	dropDescriptionTouch: "Toque duas vezes para soltar.",
	dropDescriptionVirtual: "Clique para soltar.",
	dropIndicator: "indicador de liberação",
	dropOnItem: (t) => `Soltar em ${t.itemText}`,
	dropOnRoot: "Soltar",
	endDragKeyboard: "Arrastando. Pressione Enter para cancelar.",
	endDragTouch: "Arrastando. Toque duas vezes para cancelar.",
	endDragVirtual: "Arrastando. Clique para cancelar.",
	insertAfter: (t) => `Inserir após ${t.itemText}`,
	insertBefore: (t) => `Inserir antes de ${t.itemText}`,
	insertBetween: (t) =>
		`Inserir entre ${t.beforeItemText} e ${t.afterItemText}`,
};
var mM = {};
mM = {
	dragDescriptionKeyboard: "Prima Enter para iniciar o arrasto.",
	dragDescriptionKeyboardAlt: "Prima Alt + Enter para iniciar o arrasto.",
	dragDescriptionLongPress: "Prima longamente para começar a arrastar.",
	dragDescriptionTouch: "Faça duplo toque para começar a arrastar.",
	dragDescriptionVirtual: "Clique para iniciar o arrasto.",
	dragItem: (t) => `Arrastar ${t.itemText}`,
	dragSelectedItems: (t, e) =>
		`Arrastar ${e.plural(t.count, { one: () => `${e.number(t.count)} item selecionado`, other: () => `${e.number(t.count)} itens selecionados` })}`,
	dragSelectedKeyboard: (t, e) =>
		`Prima Enter para arrastar ${e.plural(t.count, { one: () => `${e.number(t.count)} o item selecionado`, other: () => `${e.number(t.count)} os itens selecionados` })}.`,
	dragSelectedKeyboardAlt: (t, e) =>
		`Prima Alt + Enter para arrastar ${e.plural(t.count, { one: () => `${e.number(t.count)} o item selecionado`, other: () => `${e.number(t.count)} os itens selecionados` })}.`,
	dragSelectedLongPress: (t, e) =>
		`Prima longamente para arrastar ${e.plural(t.count, { one: () => `${e.number(t.count)} o item selecionado`, other: () => `${e.number(t.count)} os itens selecionados` })}.`,
	dragStartedKeyboard:
		"Arrasto iniciado. Prima a tecla de tabulação para navegar para um destino para largar, e em seguida prima Enter para largar ou prima Escape para cancelar.",
	dragStartedTouch:
		"Arrasto iniciado. Navegue para um destino para largar, e em seguida faça duplo toque para largar.",
	dragStartedVirtual:
		"Arrasto iniciado. Navegue para um destino para largar, e em seguida clique ou prima Enter para largar.",
	dropCanceled: "Largar cancelado.",
	dropComplete: "Largar completo.",
	dropDescriptionKeyboard:
		"Prima Enter para largar. Prima Escape para cancelar o arrasto.",
	dropDescriptionTouch: "Faça duplo toque para largar.",
	dropDescriptionVirtual: "Clique para largar.",
	dropIndicator: "Indicador de largar",
	dropOnItem: (t) => `Largar em ${t.itemText}`,
	dropOnRoot: "Largar em",
	endDragKeyboard: "A arrastar. Prima Enter para cancelar o arrasto.",
	endDragTouch: "A arrastar. Faça duplo toque para cancelar o arrasto.",
	endDragVirtual: "A arrastar. Clique para cancelar o arrasto.",
	insertAfter: (t) => `Inserir depois de ${t.itemText}`,
	insertBefore: (t) => `Inserir antes de ${t.itemText}`,
	insertBetween: (t) =>
		`Inserir entre ${t.beforeItemText} e ${t.afterItemText}`,
};
var gM = {};
gM = {
	dragDescriptionKeyboard: "Apăsați pe Enter pentru a începe glisarea.",
	dragDescriptionKeyboardAlt:
		"Apăsați pe Alt + Enter pentru a începe glisarea.",
	dragDescriptionLongPress: "Apăsați lung pentru a începe glisarea.",
	dragDescriptionTouch: "Atingeți de două ori pentru a începe să glisați.",
	dragDescriptionVirtual: "Faceți clic pentru a începe glisarea.",
	dragItem: (t) => `Glisați ${t.itemText}`,
	dragSelectedItems: (t, e) =>
		`Glisați ${e.plural(t.count, { one: () => `${e.number(t.count)} element selectat`, other: () => `${e.number(t.count)} elemente selectate` })}`,
	dragSelectedKeyboard: (t, e) =>
		`Apăsați pe Enter pentru a glisa ${e.plural(t.count, { one: () => `${e.number(t.count)} element selectat`, other: () => `${e.number(t.count)} elemente selectate` })}.`,
	dragSelectedKeyboardAlt: (t, e) =>
		`Apăsați pe Alt + Enter pentru a glisa ${e.plural(t.count, { one: () => `${e.number(t.count)} element selectat`, other: () => `${e.number(t.count)} elemente selectate` })}.`,
	dragSelectedLongPress: (t, e) =>
		`Apăsați lung pentru a glisa ${e.plural(t.count, { one: () => `${e.number(t.count)} element selectat`, other: () => `${e.number(t.count)} elemente selectate` })}.`,
	dragStartedKeyboard:
		"A început glisarea. Apăsați pe Tab pentru a naviga la o țintă de fixare, apoi apăsați pe Enter pentru a fixa sau apăsați pe Escape pentru a anula glisarea.",
	dragStartedTouch:
		"A început glisarea. Navigați la o țintă de fixare, apoi atingeți de două ori pentru a fixa.",
	dragStartedVirtual:
		"A început glisarea. Navigați la o țintă de fixare, apoi faceți clic sau apăsați pe Enter pentru a fixa.",
	dropCanceled: "Fixare anulată.",
	dropComplete: "Fixare finalizată.",
	dropDescriptionKeyboard:
		"Apăsați pe Enter pentru a fixa. Apăsați pe Escape pentru a anula glisarea.",
	dropDescriptionTouch: "Atingeți de două ori pentru a fixa.",
	dropDescriptionVirtual: "Faceți clic pentru a fixa.",
	dropIndicator: "indicator de fixare",
	dropOnItem: (t) => `Fixați pe ${t.itemText}`,
	dropOnRoot: "Fixare pe",
	endDragKeyboard: "Se glisează. Apăsați pe Enter pentru a anula glisarea.",
	endDragTouch: "Se glisează. Atingeți de două ori pentru a anula glisarea.",
	endDragVirtual: "Se glisează. Faceți clic pentru a anula glisarea.",
	insertAfter: (t) => `Inserați după ${t.itemText}`,
	insertBefore: (t) => `Inserați înainte de ${t.itemText}`,
	insertBetween: (t) =>
		`Inserați între ${t.beforeItemText} și ${t.afterItemText}`,
};
var bM = {};
bM = {
	dragDescriptionKeyboard: "Нажмите клавишу Enter для начала перетаскивания.",
	dragDescriptionKeyboardAlt:
		"Нажмите Alt + Enter, чтобы начать перетаскивать.",
	dragDescriptionLongPress:
		"Нажмите и удерживайте, чтобы начать перетаскивать.",
	dragDescriptionTouch: "Дважды нажмите для начала перетаскивания.",
	dragDescriptionVirtual: "Щелкните для начала перетаскивания.",
	dragItem: (t) => `Перетащить ${t.itemText}`,
	dragSelectedItems: (t, e) =>
		`Перетащить ${e.plural(t.count, { one: () => `${e.number(t.count)} выбранный элемент`, other: () => `${e.number(t.count)} выбранных элем` })}`,
	dragSelectedKeyboard: (t, e) =>
		`Нажмите Enter для перетаскивания ${e.plural(t.count, { one: () => `${e.number(t.count)} выбранного элемента`, other: () => `${e.number(t.count)} выбранных элементов` })}.`,
	dragSelectedKeyboardAlt: (t, e) =>
		`Нажмите Alt + Enter для перетаскивания ${e.plural(t.count, { one: () => `${e.number(t.count)} выбранного элемента`, other: () => `${e.number(t.count)} выбранных элементов` })}.`,
	dragSelectedLongPress: (t, e) =>
		`Нажмите и удерживайте для перетаскивания ${e.plural(t.count, { one: () => `${e.number(t.count)} выбранного элемента`, other: () => `${e.number(t.count)} выбранных элементов` })}.`,
	dragStartedKeyboard:
		"Начато перетаскивание. Нажмите клавишу Tab для выбора цели, затем нажмите клавишу Enter, чтобы применить перетаскивание, или клавишу Escape для отмены действия.",
	dragStartedTouch:
		"Начато перетаскивание. Выберите цель, затем дважды нажмите, чтобы применить перетаскивание.",
	dragStartedVirtual:
		"Начато перетаскивание. Нажмите клавишу Tab для выбора цели, затем нажмите клавишу Enter, чтобы применить перетаскивание.",
	dropCanceled: "Перетаскивание отменено.",
	dropComplete: "Перетаскивание завершено.",
	dropDescriptionKeyboard:
		"Нажмите клавишу Enter, чтобы применить перетаскивание. Нажмите клавишу Escape для отмены.",
	dropDescriptionTouch: "Дважды нажмите, чтобы применить перетаскивание.",
	dropDescriptionVirtual: "Щелкните, чтобы применить перетаскивание.",
	dropIndicator: "индикатор перетаскивания",
	dropOnItem: (t) => `Перетащить на ${t.itemText}`,
	dropOnRoot: "Перетащить на",
	endDragKeyboard: "Перетаскивание. Нажмите клавишу Enter для отмены.",
	endDragTouch: "Перетаскивание. Дважды нажмите для отмены.",
	endDragVirtual: "Перетаскивание. Щелкните для отмены.",
	insertAfter: (t) => `Вставить после ${t.itemText}`,
	insertBefore: (t) => `Вставить перед ${t.itemText}`,
	insertBetween: (t) =>
		`Вставить между ${t.beforeItemText} и ${t.afterItemText}`,
};
var vM = {};
vM = {
	dragDescriptionKeyboard: "Stlačením klávesu Enter začnete presúvanie.",
	dragDescriptionKeyboardAlt:
		"Stlačením klávesov Alt + Enter začnete presúvanie.",
	dragDescriptionLongPress: "Dlhým stlačením začnete presúvanie.",
	dragDescriptionTouch: "Dvojitým kliknutím začnete presúvanie.",
	dragDescriptionVirtual: "Kliknutím začnete presúvanie.",
	dragItem: (t) => `Presunúť položku ${t.itemText}`,
	dragSelectedItems: (t, e) =>
		`Presunúť ${e.plural(t.count, { one: () => `${e.number(t.count)} vybratú položku`, other: () => `${e.number(t.count)} vybraté položky` })}`,
	dragSelectedKeyboard: (t, e) =>
		`Stlačením klávesu Enter presuniete ${e.plural(t.count, { one: () => `${e.number(t.count)} vybratú položku`, other: () => `${e.number(t.count)} vybratých položiek` })}.`,
	dragSelectedKeyboardAlt: (t, e) =>
		`Stlačením klávesov Alt + Enter presuniete ${e.plural(t.count, { one: () => `${e.number(t.count)} vybratú položku`, other: () => `${e.number(t.count)} vybratých položiek` })}.`,
	dragSelectedLongPress: (t, e) =>
		`Dlhým stlačením presuniete ${e.plural(t.count, { one: () => `${e.number(t.count)} vybratú položku`, other: () => `${e.number(t.count)} vybratých položiek` })}.`,
	dragStartedKeyboard:
		"Presúvanie sa začalo. Do cieľového umiestnenia prejdete stlačením klávesu Tab. Ak chcete položku umiestniť, stlačte kláves Enter alebo stlačte kláves Esc, ak chcete presúvanie zrušiť.",
	dragStartedTouch:
		"Presúvanie sa začalo. Prejdite na cieľové umiestnenie a dvojitým kliknutím umiestnite položku.",
	dragStartedVirtual:
		"Presúvanie sa začalo. Prejdite na cieľové umiestnenie a kliknutím alebo stlačením klávesu Enter umiestnite položku.",
	dropCanceled: "Umiestnenie zrušené.",
	dropComplete: "Umiestnenie dokončené.",
	dropDescriptionKeyboard:
		"Stlačením klávesu Enter umiestnite položku. Stlačením klávesu Esc zrušíte presúvanie.",
	dropDescriptionTouch: "Dvojitým kliknutím umiestnite položku.",
	dropDescriptionVirtual: "Kliknutím umiestnite položku.",
	dropIndicator: "indikátor umiestnenia",
	dropOnItem: (t) => `Umiestniť na položku ${t.itemText}`,
	dropOnRoot: "Umiestniť na",
	endDragKeyboard:
		"Prebieha presúvanie. Ak ho chcete zrušiť, stlačte kláves Enter.",
	endDragTouch: "Prebieha presúvanie. Dvojitým kliknutím ho môžete zrušiť.",
	endDragVirtual: "Prebieha presúvanie.",
	insertAfter: (t) => `Vložiť za položku ${t.itemText}`,
	insertBefore: (t) => `Vložiť pred položku ${t.itemText}`,
	insertBetween: (t) =>
		`Vložiť medzi položky ${t.beforeItemText} a ${t.afterItemText}`,
};
var yM = {};
yM = {
	dragDescriptionKeyboard: "Pritisnite tipko Enter za začetek vlečenja.",
	dragDescriptionKeyboardAlt:
		"Pritisnite tipki Alt + Enter za začetek vlečenja.",
	dragDescriptionLongPress: "Pritisnite in zadržite za začetek vlečenja.",
	dragDescriptionTouch: "Dvotapnite za začetek vlečenja.",
	dragDescriptionVirtual: "Kliknite za začetek vlečenja.",
	dragItem: (t) => `Povleci ${t.itemText}`,
	dragSelectedItems: (t, e) =>
		`Povlecite ${e.plural(t.count, { one: () => `${e.number(t.count)} izbran element`, other: () => `izbrane elemente (${e.number(t.count)})` })}`,
	dragSelectedKeyboard: (t, e) =>
		`Pritisnite tipko Enter, da povlečete ${e.plural(t.count, { one: () => `${e.number(t.count)} izbrani element`, other: () => `${e.number(t.count)} izbranih elementov` })}.`,
	dragSelectedKeyboardAlt: (t, e) =>
		`Pritisnite tipki Alt + Enter, da povlečete ${e.plural(t.count, { one: () => `${e.number(t.count)} izbrani element`, other: () => `${e.number(t.count)} izbranih elementov` })}.`,
	dragSelectedLongPress: (t, e) =>
		`Pritisnite in zadržite, da povlečete ${e.plural(t.count, { one: () => `${e.number(t.count)} izbrani element`, other: () => `${e.number(t.count)} izbranih elementov` })}.`,
	dragStartedKeyboard:
		"Vlečenje se je začelo. Pritisnite tipko Tab za pomik na mesto, kamor želite spustiti elemente, in pritisnite tipko Enter, da jih spustite, ali tipko Escape, da prekličete postopek.",
	dragStartedTouch:
		"Vlečenje se je začelo. Pomaknite se na mesto, kamor želite spustiti elemente, in dvotapnite, da jih spustite.",
	dragStartedVirtual:
		"Vlečenje se je začelo. Pomaknite se na mesto, kamor želite spustiti elemente, in kliknite ali pritisnite tipko Enter, da jih spustite.",
	dropCanceled: "Spust je preklican.",
	dropComplete: "Spust je končan.",
	dropDescriptionKeyboard:
		"Pritisnite tipko Enter, da spustite. Pritisnite tipko Escape, da prekličete vlečenje.",
	dropDescriptionTouch: "Dvotapnite, da spustite.",
	dropDescriptionVirtual: "Kliknite, da spustite.",
	dropIndicator: "indikator spusta",
	dropOnItem: (t) => `Spusti na mesto ${t.itemText}`,
	dropOnRoot: "Spusti na mesto",
	endDragKeyboard: "Vlečenje. Pritisnite tipko Enter za preklic vlečenja.",
	endDragTouch: "Vlečenje. Dvotapnite za preklic vlečenja.",
	endDragVirtual: "Vlečenje. Kliknite, da prekličete vlečenje.",
	insertAfter: (t) => `Vstavi za ${t.itemText}`,
	insertBefore: (t) => `Vstavi pred ${t.itemText}`,
	insertBetween: (t) =>
		`Vstavi med ${t.beforeItemText} in ${t.afterItemText}`,
};
var xM = {};
xM = {
	dragDescriptionKeyboard: "Pritisnite Enter da biste započeli prevlačenje.",
	dragDescriptionKeyboardAlt:
		"Pritisnite Alt + Enter da biste započeli prevlačenje.",
	dragDescriptionLongPress: "Pritisnite dugo da biste započeli prevlačenje.",
	dragDescriptionTouch: "Dvaput dodirnite da biste započeli prevlačenje.",
	dragDescriptionVirtual: "Kliknite da biste započeli prevlačenje.",
	dragItem: (t) => `Prevucite ${t.itemText}`,
	dragSelectedItems: (t, e) =>
		`Prevucite ${e.plural(t.count, { one: () => `${e.number(t.count)} izabranu stavku`, other: () => `${e.number(t.count)} izabrane stavke` })}`,
	dragSelectedKeyboard: (t, e) =>
		`Pritisnite Enter da biste prevukli ${e.plural(t.count, { one: () => `${e.number(t.count)} izabranu stavku`, other: () => `${e.number(t.count)} izabranih stavki` })}.`,
	dragSelectedKeyboardAlt: (t, e) =>
		`Pritisnite Alt + Enter da biste prevukli ${e.plural(t.count, { one: () => `${e.number(t.count)} izabranu stavku`, other: () => `${e.number(t.count)} izabranih stavki` })}.`,
	dragSelectedLongPress: (t, e) =>
		`Pritisnite dugo da biste prevukli ${e.plural(t.count, { one: () => `${e.number(t.count)} izabranu stavku`, other: () => `${e.number(t.count)} izabranih stavki` })}.`,
	dragStartedKeyboard:
		"Prevlačenje je započeto. Pritisnite Tab da biste otišli do cilja za otpuštanje, zatim pritisnite Enter za ispuštanje ili pritisnite Escape za otkazivanje.",
	dragStartedTouch:
		"Prevlačenje je započeto. Idite do cilja za otpuštanje, a zatim dvaput dodirnite za otpuštanje.",
	dragStartedVirtual:
		"Prevlačenje je započeto. Idite do cilja za otpuštanje, a zatim kliknite ili pritinite Enter za otpuštanje.",
	dropCanceled: "Otpuštanje je otkazano.",
	dropComplete: "Prevlačenje je završeno.",
	dropDescriptionKeyboard:
		"Pritisnite Enter da biste otpustili. Pritisnite Escape da biste otkazali prevlačenje.",
	dropDescriptionTouch: "Dvaput dodirnite za otpuštanje.",
	dropDescriptionVirtual: "Kliknite za otpuštanje.",
	dropIndicator: "Indikator otpuštanja",
	dropOnItem: (t) => `Otpusti na ${t.itemText}`,
	dropOnRoot: "Otpusti na",
	endDragKeyboard:
		"Prevlačenje u toku. Pritisnite Enter da biste otkazali prevlačenje.",
	endDragTouch:
		"Prevlačenje u toku. Dvaput dodirnite da biste otkazali prevlačenje.",
	endDragVirtual:
		"Prevlačenje u toku. Kliknite da biste otkazali prevlačenje.",
	insertAfter: (t) => `Umetnite posle ${t.itemText}`,
	insertBefore: (t) => `Umetnite ispred ${t.itemText}`,
	insertBetween: (t) =>
		`Umetnite između ${t.beforeItemText} i ${t.afterItemText}`,
};
var kM = {};
kM = {
	dragDescriptionKeyboard: "Tryck på enter för att börja dra.",
	dragDescriptionKeyboardAlt: "Tryck på Alt + Retur för att börja dra.",
	dragDescriptionLongPress: "Tryck länge för att börja dra.",
	dragDescriptionTouch: "Dubbeltryck för att börja dra.",
	dragDescriptionVirtual: "Klicka för att börja dra.",
	dragItem: (t) => `Dra ${t.itemText}`,
	dragSelectedItems: (t, e) =>
		`Dra ${e.plural(t.count, { one: () => `${e.number(t.count)} valt objekt`, other: () => `${e.number(t.count)} valda objekt` })}`,
	dragSelectedKeyboard: (t, e) =>
		`Tryck på Retur för att dra ${e.plural(t.count, { one: () => `${e.number(t.count)} markerat objekt`, other: () => `${e.number(t.count)} markerade objekt` })}.`,
	dragSelectedKeyboardAlt: (t, e) =>
		`Tryck på Alt + Retur för att dra ${e.plural(t.count, { one: () => `${e.number(t.count)} markerat objekt`, other: () => `${e.number(t.count)} markerade objekt` })}.`,
	dragSelectedLongPress: (t, e) =>
		`Tryck länge för att dra ${e.plural(t.count, { one: () => `${e.number(t.count)} markerat objekt`, other: () => `${e.number(t.count)} markerade objekt` })}.`,
	dragStartedKeyboard:
		"Börja dra. Tryck på tabb för att navigera till målet, tryck på enter för att släppa eller på escape för att avbryta.",
	dragStartedTouch:
		"Börja dra. Navigera till ett mål och dubbeltryck för att släppa.",
	dragStartedVirtual:
		"Börja dra. Navigera till ett mål och klicka eller tryck på enter för att släppa.",
	dropCanceled: "Släppåtgärd avbröts.",
	dropComplete: "Släppåtgärd klar.",
	dropDescriptionKeyboard:
		"Tryck på enter för att släppa. Tryck på escape för att avbryta dragåtgärd.",
	dropDescriptionTouch: "Dubbeltryck för att släppa.",
	dropDescriptionVirtual: "Klicka för att släppa.",
	dropIndicator: "släppindikator",
	dropOnItem: (t) => `Släpp på ${t.itemText}`,
	dropOnRoot: "Släpp på",
	endDragKeyboard: "Drar. Tryck på enter för att avbryta dragåtgärd.",
	endDragTouch: "Drar. Dubbeltryck för att avbryta dragåtgärd.",
	endDragVirtual: "Drar. Klicka för att avbryta dragåtgärd.",
	insertAfter: (t) => `Infoga efter ${t.itemText}`,
	insertBefore: (t) => `Infoga före ${t.itemText}`,
	insertBetween: (t) =>
		`Infoga mellan ${t.beforeItemText} och ${t.afterItemText}`,
};
var CM = {};
CM = {
	dragDescriptionKeyboard: "Sürüklemeyi başlatmak için Enter'a basın.",
	dragDescriptionKeyboardAlt:
		"Sürüklemeyi başlatmak için Alt + Enter'a basın.",
	dragDescriptionLongPress: "Sürüklemeye başlamak için uzun basın.",
	dragDescriptionTouch: "Sürüklemeyi başlatmak için çift tıklayın.",
	dragDescriptionVirtual: "Sürüklemeyi başlatmak için tıklayın.",
	dragItem: (t) => `${t.itemText}’i sürükle`,
	dragSelectedItems: (t, e) =>
		`Sürükle ${e.plural(t.count, { one: () => `${e.number(t.count)} seçili öge`, other: () => `${e.number(t.count)} seçili öge` })}`,
	dragSelectedKeyboard: (t, e) =>
		`${e.plural(t.count, { one: () => `${e.number(t.count)} seçilmiş öğe`, other: () => `${e.number(t.count)} seçilmiş öğe` })} öğesini sürüklemek için Enter'a basın.`,
	dragSelectedKeyboardAlt: (t, e) =>
		`${e.plural(t.count, { one: () => `${e.number(t.count)} seçilmiş öğe`, other: () => `${e.number(t.count)} seçilmiş öğe` })} öğesini sürüklemek için Alt + Enter tuşuna basın.`,
	dragSelectedLongPress: (t, e) =>
		`${e.plural(t.count, { one: () => `${e.number(t.count)} seçilmiş öğe`, other: () => `${e.number(t.count)} seçilmiş öğe` })} öğesini sürüklemek için uzun basın.`,
	dragStartedKeyboard:
		"Sürükleme başlatıldı. Bir bırakma hedefine gitmek için Tab’a basın, ardından bırakmak için Enter’a basın veya iptal etmek için Escape’e basın.",
	dragStartedTouch:
		"Sürükleme başlatıldı. Bir bırakma hedefine gidin, ardından bırakmak için çift tıklayın.",
	dragStartedVirtual:
		"Sürükleme başlatıldı. Bir bırakma hedefine gidin, ardından bırakmak için Enter’a tıklayın veya basın.",
	dropCanceled: "Bırakma iptal edildi.",
	dropComplete: "Bırakma tamamlandı.",
	dropDescriptionKeyboard:
		"Bırakmak için Enter'a basın. Sürüklemeyi iptal etmek için Escape'e basın.",
	dropDescriptionTouch: "Bırakmak için çift tıklayın.",
	dropDescriptionVirtual: "Bırakmak için tıklayın.",
	dropIndicator: "bırakma göstergesi",
	dropOnItem: (t) => `${t.itemText} üzerine bırak`,
	dropOnRoot: "Bırakın",
	endDragKeyboard: "Sürükleme. Sürüklemeyi iptal etmek için Enter'a basın.",
	endDragTouch: "Sürükleme. Sürüklemeyi iptal etmek için çift tıklayın.",
	endDragVirtual: "Sürükleme. Sürüklemeyi iptal etmek için tıklayın.",
	insertAfter: (t) => `${t.itemText}’den sonra gir`,
	insertBefore: (t) => `${t.itemText}’den önce gir`,
	insertBetween: (t) =>
		`${t.beforeItemText} ve ${t.afterItemText} arasına gir`,
};
var wM = {};
wM = {
	dragDescriptionKeyboard: "Натисніть Enter, щоб почати перетягування.",
	dragDescriptionKeyboardAlt:
		"Натисніть Alt + Enter, щоб почати перетягування.",
	dragDescriptionLongPress:
		"Натисніть і утримуйте, щоб почати перетягування.",
	dragDescriptionTouch: "Натисніть двічі, щоб почати перетягування.",
	dragDescriptionVirtual: "Натисніть, щоб почати перетягування.",
	dragItem: (t) => `Перетягнути ${t.itemText}`,
	dragSelectedItems: (t, e) =>
		`Перетягніть ${e.plural(t.count, { one: () => `${e.number(t.count)} вибраний елемент`, other: () => `${e.number(t.count)} вибраних елем` })}`,
	dragSelectedKeyboard: (t, e) =>
		`Натисніть Enter, щоб перетягнути ${e.plural(t.count, { one: () => `${e.number(t.count)} вибраний елемент`, other: () => `${e.number(t.count)} вибраних елементи(-ів)` })}.`,
	dragSelectedKeyboardAlt: (t, e) =>
		`Натисніть Alt + Enter, щоб перетягнути ${e.plural(t.count, { one: () => `${e.number(t.count)} вибраний елемент`, other: () => `${e.number(t.count)} вибраних елементи(-ів)` })}.`,
	dragSelectedLongPress: (t, e) =>
		`Утримуйте, щоб перетягнути ${e.plural(t.count, { one: () => `${e.number(t.count)} вибраний елемент`, other: () => `${e.number(t.count)} вибраних елементи(-ів)` })}.`,
	dragStartedKeyboard:
		"Перетягування почалося. Натисніть Tab, щоб перейти до цілі перетягування, потім натисніть Enter, щоб перетягнути, або Escape, щоб скасувати.",
	dragStartedTouch:
		"Перетягування почалося. Перейдіть до цілі перетягування, потім натисніть двічі, щоб перетягнути.",
	dragStartedVirtual:
		"Перетягування почалося. Перейдіть до цілі перетягування, потім натисніть Enter, щоб перетягнути.",
	dropCanceled: "Перетягування скасовано.",
	dropComplete: "Перетягування завершено.",
	dropDescriptionKeyboard:
		"Натисніть Enter, щоб перетягнути. Натисніть Escape, щоб скасувати перетягування.",
	dropDescriptionTouch: "Натисніть двічі, щоб перетягнути.",
	dropDescriptionVirtual: "Натисніть, щоб перетягнути.",
	dropIndicator: "індикатор перетягування",
	dropOnItem: (t) => `Перетягнути на ${t.itemText}`,
	dropOnRoot: "Перетягнути на",
	endDragKeyboard:
		"Триває перетягування. Натисніть Enter, щоб скасувати перетягування.",
	endDragTouch:
		"Триває перетягування. Натисніть двічі, щоб скасувати перетягування.",
	endDragVirtual:
		"Триває перетягування. Натисніть, щоб скасувати перетягування.",
	insertAfter: (t) => `Вставити після ${t.itemText}`,
	insertBefore: (t) => `Вставити перед ${t.itemText}`,
	insertBetween: (t) =>
		`Вставити між ${t.beforeItemText} і ${t.afterItemText}`,
};
var EM = {};
EM = {
	dragDescriptionKeyboard: "按 Enter 开始拖动。",
	dragDescriptionKeyboardAlt: "按 Alt + Enter 开始拖动。",
	dragDescriptionLongPress: "长按以开始拖动。",
	dragDescriptionTouch: "双击开始拖动。",
	dragDescriptionVirtual: "单击开始拖动。",
	dragItem: (t) => `拖动 ${t.itemText}`,
	dragSelectedItems: (t, e) =>
		`拖动 ${e.plural(t.count, { one: () => `${e.number(t.count)} 选中项目`, other: () => `${e.number(t.count)} 选中项目` })}`,
	dragSelectedKeyboard: (t, e) =>
		`按 Enter 以拖动 ${e.plural(t.count, { one: () => `${e.number(t.count)} 个选定项`, other: () => `${e.number(t.count)} 个选定项` })}。`,
	dragSelectedKeyboardAlt: (t, e) =>
		`按 Alt + Enter 以拖动 ${e.plural(t.count, { one: () => `${e.number(t.count)} 个选定项`, other: () => `${e.number(t.count)} 个选定项` })}。`,
	dragSelectedLongPress: (t, e) =>
		`长按以拖动 ${e.plural(t.count, { one: () => `${e.number(t.count)} 个选定项`, other: () => `${e.number(t.count)} 个选定项` })}。`,
	dragStartedKeyboard:
		"已开始拖动。按 Tab 导航到放置目标，然后按 Enter 放置或按 Escape 取消。",
	dragStartedTouch: "已开始拖动。导航到放置目标，然后双击放置。",
	dragStartedVirtual: "已开始拖动。导航到放置目标，然后单击或按 Enter 放置。",
	dropCanceled: "放置已取消。",
	dropComplete: "放置已完成。",
	dropDescriptionKeyboard: "按 Enter 放置。按 Escape 取消拖动。",
	dropDescriptionTouch: "双击放置。",
	dropDescriptionVirtual: "单击放置。",
	dropIndicator: "放置标记",
	dropOnItem: (t) => `放置于 ${t.itemText}`,
	dropOnRoot: "放置于",
	endDragKeyboard: "正在拖动。按 Enter 取消拖动。",
	endDragTouch: "正在拖动。双击取消拖动。",
	endDragVirtual: "正在拖动。单击取消拖动。",
	insertAfter: (t) => `插入到 ${t.itemText} 之后`,
	insertBefore: (t) => `插入到 ${t.itemText} 之前`,
	insertBetween: (t) =>
		`插入到 ${t.beforeItemText} 和 ${t.afterItemText} 之间`,
};
var DM = {};
DM = {
	dragDescriptionKeyboard: "按 Enter 鍵以開始拖曳。",
	dragDescriptionKeyboardAlt: "按 Alt+Enter 鍵以開始拖曳。",
	dragDescriptionLongPress: "長按以開始拖曳。",
	dragDescriptionTouch: "輕點兩下以開始拖曳。",
	dragDescriptionVirtual: "按一下滑鼠以開始拖曳。",
	dragItem: (t) => `拖曳「${t.itemText}」`,
	dragSelectedItems: (t, e) =>
		`拖曳 ${e.plural(t.count, { one: () => `${e.number(t.count)} 個選定項目`, other: () => `${e.number(t.count)} 個選定項目` })}`,
	dragSelectedKeyboard: (t, e) =>
		`按 Enter 鍵以拖曳 ${e.plural(t.count, { one: () => `${e.number(t.count)} 個選定項目`, other: () => `${e.number(t.count)} 個選定項目` })}。`,
	dragSelectedKeyboardAlt: (t, e) =>
		`按 Alt+Enter 鍵以拖曳 ${e.plural(t.count, { one: () => `${e.number(t.count)} 個選定項目`, other: () => `${e.number(t.count)} 個選定項目` })}。`,
	dragSelectedLongPress: (t, e) =>
		`長按以拖曳 ${e.plural(t.count, { one: () => `${e.number(t.count)} 個選定項目`, other: () => `${e.number(t.count)} 個選定項目` })}。`,
	dragStartedKeyboard:
		"已開始拖曳。按 Tab 鍵以瀏覽至放置目標，然後按 Enter 鍵以放置，或按 Escape 鍵以取消。",
	dragStartedTouch: "已開始拖曳。瀏覽至放置目標，然後輕點兩下以放置。",
	dragStartedVirtual:
		"已開始拖曳。瀏覽至放置目標，然後按一下滑鼠或按 Enter 鍵以放置。",
	dropCanceled: "放置已取消。",
	dropComplete: "放置已完成。",
	dropDescriptionKeyboard: "按 Enter 鍵以放置。按 Escape 鍵以取消拖曳。",
	dropDescriptionTouch: "輕點兩下以放置。",
	dropDescriptionVirtual: "按一下滑鼠以放置。",
	dropIndicator: "放置指示器",
	dropOnItem: (t) => `放置在「${t.itemText}」上`,
	dropOnRoot: "放置在",
	endDragKeyboard: "拖曳中。按 Enter 鍵以取消拖曳。",
	endDragTouch: "拖曳中。輕點兩下以取消拖曳。",
	endDragVirtual: "拖曳中。按一下滑鼠以取消拖曳。",
	insertAfter: (t) => `插入至「${t.itemText}」之後`,
	insertBefore: (t) => `插入至「${t.itemText}」之前`,
	insertBetween: (t) =>
		`插入至「${t.beforeItemText}」和「${t.afterItemText}」之間`,
};
var b0 = {};
b0 = {
	"ar-AE": WO,
	"bg-BG": qO,
	"cs-CZ": GO,
	"da-DK": YO,
	"de-DE": JO,
	"el-GR": XO,
	"en-US": ZO,
	"es-ES": QO,
	"et-EE": eM,
	"fi-FI": tM,
	"fr-FR": nM,
	"he-IL": rM,
	"hr-HR": iM,
	"hu-HU": oM,
	"it-IT": sM,
	"ja-JP": aM,
	"ko-KR": lM,
	"lt-LT": uM,
	"lv-LV": cM,
	"nb-NO": dM,
	"nl-NL": fM,
	"pl-PL": hM,
	"pt-BR": pM,
	"pt-PT": mM,
	"ro-RO": gM,
	"ru-RU": bM,
	"sk-SK": vM,
	"sl-SI": yM,
	"sr-SP": xM,
	"sv-SE": kM,
	"tr-TR": CM,
	"uk-UA": wM,
	"zh-CN": EM,
	"zh-TW": DM,
};
function Loe(t) {
	return t && t.__esModule ? t.default : t;
}
const e$ = {
	keyboard: { start: "dragDescriptionKeyboard", end: "endDragKeyboard" },
	touch: { start: "dragDescriptionTouch", end: "endDragTouch" },
	virtual: { start: "dragDescriptionVirtual", end: "endDragVirtual" },
};
function Voe(t) {
	let { hasDragButton: e, isDisabled: n } = t,
		r = Le(Loe(b0), "@react-aria/dnd"),
		i = E.useRef({ options: t, x: 0, y: 0 }).current;
	i.options = t;
	let o = E.useRef(!1),
		[s, a] = E.useState(!1),
		l = (k) => {
			(o.current = k), a(k);
		},
		{ addGlobalListener: u, removeAllGlobalListeners: c } = i0(),
		d = E.useRef(null),
		f = (k) => {
			var w;
			if (k.defaultPrevented) return;
			if ((k.stopPropagation(), d.current === "virtual")) {
				k.preventDefault(), v(k.target), (d.current = null);
				return;
			}
			typeof t.onDragStart == "function" &&
				t.onDragStart({
					type: "dragstart",
					x: k.clientX,
					y: k.clientY,
				});
			let D = t.getItems();
			Doe(k.dataTransfer, D);
			let S = yn.all;
			if (typeof t.getAllowedDropOperations == "function") {
				let $ = t.getAllowedDropOperations();
				S = yn.none;
				for (let A of $) S |= yn[A] || yn.none;
			}
			K4(S),
				(k.dataTransfer.effectAllowed = _O[S] || "none"),
				typeof ((w = t.preview) === null || w === void 0
					? void 0
					: w.current) == "function" &&
					t.preview.current(D, ($) => {
						let A = $.getBoundingClientRect(),
							T = k.currentTarget.getBoundingClientRect(),
							I = k.clientX - T.x,
							F = k.clientY - T.y;
						(I > A.width || F > A.height) &&
							((I = A.width / 2), (F = A.height / 2));
						let N = 2 * Math.round(A.height / 2);
						($.style.height = `${N}px`),
							k.dataTransfer.setDragImage($, I, F);
					}),
				u(
					window,
					"drop",
					($) => {
						$.preventDefault(),
							$.stopPropagation(),
							console.warn(
								"Drags initiated from the React Aria useDrag hook may only be dropped on a target created with useDrop. This ensures that a keyboard and screen reader accessible alternative is available.",
							);
					},
					{ once: !0 },
				),
				(i.x = k.clientX),
				(i.y = k.clientY),
				requestAnimationFrame(() => {
					l(!0);
				});
		},
		h = (k) => {
			k.stopPropagation(),
				!(k.clientX === i.x && k.clientY === i.y) &&
					(typeof t.onDragMove == "function" &&
						t.onDragMove({
							type: "dragmove",
							x: k.clientX,
							y: k.clientY,
						}),
					(i.x = k.clientX),
					(i.y = k.clientY));
		},
		p = (k) => {
			if ((k.stopPropagation(), typeof t.onDragEnd == "function")) {
				let w = {
					type: "dragend",
					x: k.clientX,
					y: k.clientY,
					dropOperation: gm[k.dataTransfer.dropEffect],
				};
				lb && (w.dropOperation = gm[lb]), t.onDragEnd(w);
			}
			l(!1), c(), K4(yn.none), Cv(void 0);
		};
	at(
		() => () => {
			if (o.current) {
				if (typeof i.options.onDragEnd == "function") {
					let k = {
						type: "dragend",
						x: 0,
						y: 0,
						dropOperation: gm[lb || "none"],
					};
					i.options.onDragEnd(k);
				}
				l(!1), K4(yn.none), Cv(void 0);
			}
		},
		[i],
	);
	let g = (k) => {
			(k.pointerType !== "keyboard" && k.pointerType !== "virtual") ||
				v(k.target);
		},
		v = (k) => {
			if (typeof i.options.onDragStart == "function") {
				let w = k.getBoundingClientRect();
				i.options.onDragStart({
					type: "dragstart",
					x: w.x + w.width / 2,
					y: w.y + w.height / 2,
				});
			}
			Noe(
				{
					element: k,
					items: i.options.getItems(),
					allowedDropOperations:
						typeof i.options.getAllowedDropOperations == "function"
							? i.options.getAllowedDropOperations()
							: ["move", "copy", "link"],
					onDragEnd(w) {
						l(!1),
							typeof i.options.onDragEnd == "function" &&
								i.options.onDragEnd(w);
					},
				},
				r,
			),
				l(!0);
		},
		b = FD(),
		y = s ? e$[b].end : e$[b].start,
		x = tc(r.format(y)),
		C;
	return (
		e ||
			(C = {
				...x,
				onPointerDown(k) {
					if (
						((d.current = XE(k.nativeEvent)
							? "virtual"
							: k.pointerType),
						k.width < 1 && k.height < 1)
					)
						d.current = "virtual";
					else {
						let w = k.currentTarget.getBoundingClientRect(),
							D = k.clientX - w.x,
							S = k.clientY - w.y,
							$ = w.width / 2,
							A = w.height / 2;
						Math.abs(D - $) <= 0.5 && Math.abs(S - A) <= 0.5
							? (d.current = "virtual")
							: (d.current = k.pointerType);
					}
				},
				onKeyDownCapture(k) {
					k.target === k.currentTarget &&
						k.key === "Enter" &&
						(k.preventDefault(), k.stopPropagation());
				},
				onKeyUpCapture(k) {
					k.target === k.currentTarget &&
						k.key === "Enter" &&
						(k.preventDefault(), k.stopPropagation(), v(k.target));
				},
				onClick(k) {
					(Vm(k.nativeEvent) || d.current === "virtual") &&
						(k.preventDefault(), k.stopPropagation(), v(k.target));
				},
			}),
		n
			? {
					dragProps: { draggable: "false" },
					dragButtonProps: {},
					isDragging: !1,
				}
			: {
					dragProps: {
						...C,
						draggable: "true",
						onDragStart: f,
						onDrag: h,
						onDragEnd: p,
					},
					dragButtonProps: { ...x, onPress: g },
					isDragging: s,
				}
	);
}
function Koe(t) {
	return t && t.__esModule ? t.default : t;
}
const Uoe = {
	keyboard: "dropDescriptionKeyboard",
	touch: "dropDescriptionTouch",
	virtual: "dropDescriptionVirtual",
};
function SM() {
	let t = Le(Koe(b0), "@react-aria/dnd"),
		e = FD(),
		n = PD();
	return {
		dropProps: { ...tc(n ? t.format(Uoe[e]) : ""), onClick: () => {} },
	};
}
const Hoe = 800;
function Woe(t) {
	let { hasDropButton: e, isDisabled: n } = t,
		[r, i] = E.useState(!1),
		o = E.useRef({
			x: 0,
			y: 0,
			dragOverElements: new Set(),
			dropEffect: "none",
			allowedOperations: yn.all,
			dropActivateTimer: null,
		}).current,
		s = (x) => {
			if ((i(!0), typeof t.onDropEnter == "function")) {
				let C = x.currentTarget.getBoundingClientRect();
				t.onDropEnter({
					type: "dropenter",
					x: x.clientX - C.x,
					y: x.clientY - C.y,
				});
			}
		},
		a = (x) => {
			if ((i(!1), typeof t.onDropExit == "function")) {
				let C = x.currentTarget.getBoundingClientRect();
				t.onDropExit({
					type: "dropexit",
					x: x.clientX - C.x,
					y: x.clientY - C.y,
				});
			}
		},
		l = (x) => {
			x.preventDefault(), x.stopPropagation();
			let C = t$(x);
			if (
				x.clientX === o.x &&
				x.clientY === o.y &&
				C === o.allowedOperations
			) {
				x.dataTransfer.dropEffect = o.dropEffect;
				return;
			}
			(o.x = x.clientX), (o.y = x.clientY);
			let k = o.dropEffect;
			if (C !== o.allowedOperations) {
				let w = U4(C),
					D = w[0];
				if (typeof t.getDropOperation == "function") {
					let S = new g1(x.dataTransfer);
					D = b1(C, t.getDropOperation(S, w));
				}
				o.dropEffect = V4[D] || "none";
			}
			if (typeof t.getDropOperationForPoint == "function") {
				let w = new g1(x.dataTransfer),
					D = x.currentTarget.getBoundingClientRect(),
					S = b1(
						C,
						t.getDropOperationForPoint(
							w,
							U4(C),
							o.x - D.x,
							o.y - D.y,
						),
					);
				o.dropEffect = V4[S] || "none";
			}
			if (
				((o.allowedOperations = C),
				(x.dataTransfer.dropEffect = o.dropEffect),
				o.dropEffect === "none" && k !== "none"
					? a(x)
					: o.dropEffect !== "none" && k === "none" && s(x),
				typeof t.onDropMove == "function" && o.dropEffect !== "none")
			) {
				let w = x.currentTarget.getBoundingClientRect();
				t.onDropMove({ type: "dropmove", x: o.x - w.x, y: o.y - w.y });
			}
			if (
				(clearTimeout(o.dropActivateTimer),
				typeof t.onDropActivate == "function" &&
					o.dropEffect !== "none")
			) {
				let w = x.currentTarget.getBoundingClientRect();
				o.dropActivateTimer = setTimeout(() => {
					t.onDropActivate({
						type: "dropactivate",
						x: o.x - w.x,
						y: o.y - w.y,
					});
				}, Hoe);
			}
		},
		u = (x) => {
			if (
				(x.preventDefault(),
				x.stopPropagation(),
				o.dragOverElements.add(x.target),
				o.dragOverElements.size > 1)
			)
				return;
			let C = t$(x),
				k = U4(C),
				w = k[0];
			if (typeof t.getDropOperation == "function") {
				let D = new g1(x.dataTransfer);
				w = b1(C, t.getDropOperation(D, k));
			}
			if (typeof t.getDropOperationForPoint == "function") {
				let D = new g1(x.dataTransfer),
					S = x.currentTarget.getBoundingClientRect();
				w = b1(
					C,
					t.getDropOperationForPoint(
						D,
						k,
						x.clientX - S.x,
						x.clientY - S.y,
					),
				);
			}
			(o.x = x.clientX),
				(o.y = x.clientY),
				(o.allowedOperations = C),
				(o.dropEffect = V4[w] || "none"),
				(x.dataTransfer.dropEffect = o.dropEffect),
				w !== "cancel" && s(x);
		},
		c = (x) => {
			x.preventDefault(),
				x.stopPropagation(),
				o.dragOverElements.delete(x.target);
			for (let C of o.dragOverElements)
				x.currentTarget.contains(C) || o.dragOverElements.delete(C);
			o.dragOverElements.size > 0 ||
				(o.dropEffect !== "none" && a(x),
				clearTimeout(o.dropActivateTimer));
		},
		d = (x) => {
			if (
				(x.preventDefault(),
				x.stopPropagation(),
				Cv(o.dropEffect),
				typeof t.onDrop == "function")
			) {
				let k = gm[o.dropEffect],
					w = Soe(x.dataTransfer),
					D = x.currentTarget.getBoundingClientRect(),
					S = {
						type: "drop",
						x: x.clientX - D.x,
						y: x.clientY - D.y,
						items: w,
						dropOperation: k,
					};
				t.onDrop(S);
			}
			let C = { ...Qn };
			o.dragOverElements.clear(),
				a(x),
				clearTimeout(o.dropActivateTimer),
				C.draggingCollectionRef == null ? Cv(void 0) : Foe(C);
		},
		f = Pt((x) => {
			typeof t.onDropEnter == "function" && t.onDropEnter(x);
		}),
		h = Pt((x) => {
			typeof t.onDropExit == "function" && t.onDropExit(x);
		}),
		p = Pt((x) => {
			typeof t.onDropActivate == "function" && t.onDropActivate(x);
		}),
		g = Pt((x) => {
			typeof t.onDrop == "function" && t.onDrop(x);
		}),
		v = Pt((x, C) =>
			t.getDropOperation ? t.getDropOperation(x, C) : C[0],
		),
		{ ref: b } = t;
	at(() => {
		if (!n)
			return HO({
				element: b.current,
				getDropOperation: v,
				onDropEnter(x) {
					i(!0), f(x);
				},
				onDropExit(x) {
					i(!1), h(x);
				},
				onDrop: g,
				onDropActivate: p,
			});
	}, [n, b, v, f, h, g, p]);
	let { dropProps: y } = SM();
	return n
		? {
				dropProps: {},
				dropButtonProps: { isDisabled: !0 },
				isDropTarget: !1,
			}
		: {
				dropProps: {
					...(!e && y),
					onDragEnter: u,
					onDragOver: l,
					onDragLeave: c,
					onDrop: d,
				},
				dropButtonProps: { ...(e && y) },
				isDropTarget: r,
			};
}
function t$(t) {
	let e = jO[t.dataTransfer.effectAllowed];
	yw && (e &= yw);
	let n = yn.none;
	return (
		Ss()
			? (t.altKey && (n |= yn.copy),
				t.ctrlKey && !GE() && (n |= yn.link),
				t.metaKey && (n |= yn.move))
			: (t.altKey && (n |= yn.link),
				t.shiftKey && (n |= yn.move),
				t.ctrlKey && (n |= yn.copy)),
		n ? e & n : e
	);
}
function U4(t) {
	let e = [];
	return (
		t & yn.move && e.push("move"),
		t & yn.copy && e.push("copy"),
		t & yn.link && e.push("link"),
		e
	);
}
function b1(t, e) {
	let n = yn[e];
	return t & n ? e : "cancel";
}
const v1 = 20;
function qoe(t) {
	let e = E.useRef(null),
		n = E.useRef(!0),
		r = E.useRef(!0);
	E.useEffect(() => {
		if (t.current) {
			e.current = bh(t.current) ? t.current : li(t.current);
			let s = window.getComputedStyle(e.current);
			(n.current = /(auto|scroll)/.test(s.overflowX)),
				(r.current = /(auto|scroll)/.test(s.overflowY));
		}
	}, [t]);
	let i = E.useRef({ timer: null, dx: 0, dy: 0 }).current;
	E.useEffect(
		() => () => {
			i.timer && (cancelAnimationFrame(i.timer), (i.timer = null));
		},
		[i],
	);
	let o = E.useCallback(() => {
		n.current && (e.current.scrollLeft += i.dx),
			r.current && (e.current.scrollTop += i.dy),
			i.timer && (i.timer = requestAnimationFrame(o));
	}, [e, i]);
	return {
		move(s, a) {
			if (!ax() || Vh() || !e.current) return;
			let l = e.current.getBoundingClientRect(),
				u = v1,
				c = v1,
				d = l.height - v1,
				f = l.width - v1;
			s < u || s > f || a < c || a > d
				? (s < u ? (i.dx = s - u) : s > f && (i.dx = s - f),
					a < c ? (i.dy = a - c) : a > d && (i.dy = a - d),
					i.timer || (i.timer = requestAnimationFrame(o)))
				: this.stop();
		},
		stop() {
			i.timer && (cancelAnimationFrame(i.timer), (i.timer = null));
		},
	};
}
const n$ = ["before", "on", "after"],
	r$ = ["after", "on", "before"];
function Goe(t, e, n) {
	let r = E.useRef({
		props: t,
		state: e,
		nextTarget: null,
		dropOperation: null,
	}).current;
	(r.props = t), (r.state = e);
	let i = E.useCallback(
			async (f) => {
				let {
						onInsert: h,
						onRootDrop: p,
						onItemDrop: g,
						onReorder: v,
						acceptedDragTypes: b = "all",
						shouldAcceptItemDrop: y,
					} = r.props,
					{ draggingKeys: x } = Qn,
					C = Gs(n),
					{ target: k, dropOperation: w, items: D } = f,
					S = D;
				(b !== "all" || y) &&
					(S = D.filter(($) => {
						let A;
						return (
							$.kind === "directory"
								? (A = new Set([zO]))
								: (A =
										$.kind === "file"
											? new Set([$.type])
											: $.types),
							b === "all" || b.some((T) => A.has(T))
								? k.type === "item" &&
									k.dropPosition === "on" &&
									y
									? y(k, A)
									: !0
								: !1
						);
					})),
					S.length > 0 &&
						(k.type === "root" &&
							p &&
							(await p({ items: S, dropOperation: w })),
						k.type === "item" &&
							(k.dropPosition === "on" &&
								g &&
								(await g({
									items: S,
									dropOperation: w,
									isInternal: C,
									target: k,
								})),
							k.dropPosition !== "on" &&
								(!C &&
									h &&
									(await h({
										items: S,
										dropOperation: w,
										target: k,
									})),
								C &&
									v &&
									(await v({
										keys: x,
										dropOperation: w,
										target: k,
									})))));
			},
			[r, n],
		),
		o = qoe(n),
		{ dropProps: s } = Woe({
			ref: n,
			onDropEnter() {
				e.setTarget(r.nextTarget);
			},
			onDropMove(f) {
				e.setTarget(r.nextTarget), o.move(f.x, f.y);
			},
			getDropOperationForPoint(f, h, p, g) {
				let { draggingKeys: v, dropCollectionRef: b } = Qn,
					y = Gs(n),
					x = (k) =>
						e.getDropOperation({
							target: k,
							types: f,
							allowedOperations: h,
							isInternal: y,
							draggingKeys: v,
						}) !== "cancel",
					C = t.dropTargetDelegate.getDropTargetFromPoint(p, g, x);
				if (!C)
					return (
						(r.dropOperation = "cancel"),
						(r.nextTarget = null),
						"cancel"
					);
				if (
					((r.dropOperation = e.getDropOperation({
						target: C,
						types: f,
						allowedOperations: h,
						isInternal: y,
						draggingKeys: v,
					})),
					r.dropOperation === "cancel")
				) {
					let k = { type: "root" },
						w = e.getDropOperation({
							target: k,
							types: f,
							allowedOperations: h,
							isInternal: y,
							draggingKeys: v,
						});
					w !== "cancel" && ((C = k), (r.dropOperation = w));
				}
				return (
					C &&
						r.dropOperation !== "cancel" &&
						(n == null ? void 0 : n.current) !==
							(b == null ? void 0 : b.current) &&
						ff(n),
					(r.nextTarget = r.dropOperation === "cancel" ? null : C),
					r.dropOperation
				);
			},
			onDropExit() {
				ff(void 0), e.setTarget(null), o.stop();
			},
			onDropActivate(f) {
				var h, p;
				((h = e.target) === null || h === void 0 ? void 0 : h.type) ===
					"item" &&
					((p = e.target) === null || p === void 0
						? void 0
						: p.dropPosition) === "on" &&
					typeof t.onDropActivate == "function" &&
					t.onDropActivate({
						type: "dropactivate",
						x: f.x,
						y: f.y,
						target: e.target,
					});
			},
			onDrop(f) {
				ff(n), e.target && u(f, e.target);
				let { draggingCollectionRef: h } = Qn;
				h == null && UO();
			},
		}),
		a = E.useRef(null),
		l = E.useCallback(() => {
			let { state: f } = r;
			if (a.current) {
				var h;
				let {
					target: p,
					collection: g,
					selectedKeys: v,
					focusedKey: b,
					isInternal: y,
					draggingKeys: x,
				} = a.current;
				if (
					f.collection.size > g.size &&
					f.selectionManager.isSelectionEqual(v)
				) {
					let C = new Set();
					for (let k of f.collection.getKeys())
						g.getItem(k) || C.add(k);
					if (
						(f.selectionManager.setSelectedKeys(C),
						f.selectionManager.focusedKey === b)
					) {
						let k = C.keys().next().value,
							w = f.collection.getItem(k);
						(w == null ? void 0 : w.type) === "cell" &&
							(k = w.parentKey),
							f.selectionManager.setFocusedKey(k),
							f.selectionManager.selectionMode === "none" &&
								Ic("keyboard");
					}
				} else
					f.selectionManager.focusedKey === b &&
					y &&
					p.type === "item" &&
					p.dropPosition !== "on" &&
					x.has(
						(h = f.collection.getItem(b)) === null || h === void 0
							? void 0
							: h.parentKey,
					)
						? (f.selectionManager.setFocusedKey(
								f.collection.getItem(b).parentKey,
							),
							Ic("keyboard"))
						: f.selectionManager.focusedKey === b &&
							  p.type === "item" &&
							  p.dropPosition === "on" &&
							  f.collection.getItem(p.key) != null
							? (f.selectionManager.setFocusedKey(p.key),
								Ic("keyboard"))
							: f.selectionManager.isSelected(
									f.selectionManager.focusedKey,
								) || Ic("keyboard");
				f.selectionManager.setFocused(!0);
			}
		}, [r]),
		u = E.useCallback(
			(f, h) => {
				let { state: p } = r;
				(a.current = {
					timeout: null,
					focusedKey: p.selectionManager.focusedKey,
					collection: p.collection,
					selectedKeys: p.selectionManager.selectedKeys,
					draggingKeys: Qn.draggingKeys,
					isInternal: Gs(n),
					target: h,
				}),
					(r.props.onDrop || i)({
						type: "drop",
						x: f.x,
						y: f.y,
						target: h,
						items: f.items,
						dropOperation: f.dropOperation,
					}),
					(a.current.timeout = setTimeout(() => {
						l(), (a.current = null);
					}, 50));
			},
			[r, i, n, l],
		);
	E.useEffect(
		() => () => {
			a.current && clearTimeout(a.current.timeout);
		},
		[],
	),
		at(() => {
			a.current && e.collection !== a.current.collection && l();
		});
	let { direction: c } = Vt();
	E.useEffect(() => {
		let f = (g, v = !0, b = !1) => {
				if (!g) return { type: "root" };
				let { keyboardDelegate: y } = r.props,
					x;
				(g == null ? void 0 : g.type) === "item"
					? (x = b ? y.getKeyRightOf(g.key) : y.getKeyBelow(g.key))
					: (x = b && c === "rtl" ? y.getLastKey() : y.getFirstKey());
				let C = b && c === "rtl" ? r$ : n$,
					k = C[0];
				if (g.type === "item") {
					let w =
						b && c === "rtl"
							? r.state.collection.getKeyBefore(g.key)
							: r.state.collection.getKeyAfter(g.key);
					if (x == null || x === w) {
						let D = C.indexOf(g.dropPosition),
							S = C[D + 1];
						if (D < C.length - 1 && !(S === C[2] && x != null))
							return {
								type: "item",
								key: g.key,
								dropPosition: S,
							};
						g.dropPosition === C[2] && (k = "on");
					} else k = g.dropPosition;
				}
				return x == null
					? v
						? { type: "root" }
						: null
					: { type: "item", key: x, dropPosition: k };
			},
			h = (g, v = !0, b = !1) => {
				let { keyboardDelegate: y } = r.props,
					x;
				(g == null ? void 0 : g.type) === "item"
					? (x = b ? y.getKeyLeftOf(g.key) : y.getKeyAbove(g.key))
					: (x = b && c === "rtl" ? y.getFirstKey() : y.getLastKey());
				let C = b && c === "rtl" ? r$ : n$,
					k = !g || g.type === "root" ? C[2] : "on";
				if ((g == null ? void 0 : g.type) === "item") {
					let w =
						b && c === "rtl"
							? r.state.collection.getKeyAfter(g.key)
							: r.state.collection.getKeyBefore(g.key);
					if (x == null || x === w) {
						let D = C.indexOf(g.dropPosition),
							S = C[D - 1];
						if (D > 0 && S !== C[2])
							return {
								type: "item",
								key: g.key,
								dropPosition: S,
							};
						g.dropPosition === C[0] && (k = "on");
					} else k = g.dropPosition;
				}
				return x == null
					? v
						? { type: "root" }
						: null
					: { type: "item", key: x, dropPosition: k };
			},
			p = (g, v, b, y, x = !0) => {
				let C = 0,
					k,
					{ draggingKeys: w } = Qn,
					D = Gs(n);
				do {
					let S = y(g, x);
					if (!S) return null;
					(g = S),
						(k = r.state.getDropOperation({
							target: S,
							types: v,
							allowedOperations: b,
							isInternal: D,
							draggingKeys: w,
						})),
						g.type === "root" && C++;
				} while (k === "cancel" && !r.state.isDropTarget(g) && C < 2);
				return k === "cancel" ? null : g;
			};
		return HO({
			element: n.current,
			preventFocusOnDrop: !0,
			getDropOperation(g, v) {
				if (r.state.target) {
					let { draggingKeys: y } = Qn,
						x = Gs(n);
					return r.state.getDropOperation({
						target: r.state.target,
						types: g,
						allowedOperations: v,
						isInternal: x,
						draggingKeys: y,
					});
				}
				return p(null, g, v, f) ? "move" : "cancel";
			},
			onDropEnter(g, v) {
				let b = Gc(v.items),
					y = r.state.selectionManager,
					x;
				ff(n);
				let C = y.focusedKey,
					k = "after",
					w = r.state.collection.getItem(C);
				if (
					((w == null ? void 0 : w.type) === "cell" &&
						(C = w.parentKey),
					y.isSelected(C) &&
						(y.selectedKeys.size > 1 && y.firstSelectedKey === C
							? (k = "before")
							: (C = y.lastSelectedKey)),
					C != null)
				) {
					x = { type: "item", key: C, dropPosition: k };
					let { draggingKeys: S } = Qn,
						$ = Gs(n);
					var D;
					r.state.getDropOperation({
						target: x,
						types: b,
						allowedOperations: v.allowedDropOperations,
						isInternal: $,
						draggingKeys: S,
					}) === "cancel" &&
						(x =
							(D = p(x, b, v.allowedDropOperations, f, !1)) !==
								null && D !== void 0
								? D
								: p(x, b, v.allowedDropOperations, h, !1));
				}
				x || (x = p(null, b, v.allowedDropOperations, f)),
					r.state.setTarget(x);
			},
			onDropExit() {
				ff(void 0), r.state.setTarget(null);
			},
			onDropTargetEnter(g) {
				r.state.setTarget(g);
			},
			onDropActivate(g) {
				var v, b;
				((v = r.state.target) === null || v === void 0
					? void 0
					: v.type) === "item" &&
					((b = r.state.target) === null || b === void 0
						? void 0
						: b.dropPosition) === "on" &&
					typeof r.props.onDropActivate == "function" &&
					r.props.onDropActivate({
						type: "dropactivate",
						x: g.x,
						y: g.y,
						target: r.state.target,
					});
			},
			onDrop(g, v) {
				ff(n), r.state.target && u(g, v || r.state.target);
			},
			onKeyDown(g, v) {
				let { keyboardDelegate: b } = r.props,
					y = Gc(v.items);
				switch (g.key) {
					case "ArrowDown":
						if (b.getKeyBelow) {
							let k = p(
								r.state.target,
								y,
								v.allowedDropOperations,
								f,
							);
							r.state.setTarget(k);
						}
						break;
					case "ArrowUp":
						if (b.getKeyAbove) {
							let k = p(
								r.state.target,
								y,
								v.allowedDropOperations,
								h,
							);
							r.state.setTarget(k);
						}
						break;
					case "ArrowLeft":
						if (b.getKeyLeftOf) {
							let k = p(
								r.state.target,
								y,
								v.allowedDropOperations,
								(w, D) => h(w, D, !0),
							);
							r.state.setTarget(k);
						}
						break;
					case "ArrowRight":
						if (b.getKeyRightOf) {
							let k = p(
								r.state.target,
								y,
								v.allowedDropOperations,
								(w, D) => f(w, D, !0),
							);
							r.state.setTarget(k);
						}
						break;
					case "Home":
						if (b.getFirstKey) {
							let k = p(null, y, v.allowedDropOperations, f);
							r.state.setTarget(k);
						}
						break;
					case "End":
						if (b.getLastKey) {
							let k = p(null, y, v.allowedDropOperations, h);
							r.state.setTarget(k);
						}
						break;
					case "PageDown":
						if (b.getKeyPageBelow) {
							let k = r.state.target;
							if (!k) k = p(null, y, v.allowedDropOperations, f);
							else {
								let w = b.getKeyPageBelow(
										k.type === "item"
											? k.key
											: b.getFirstKey(),
									),
									D =
										k.type === "item"
											? k.dropPosition
											: "after";
								(w == null ||
									(k.type === "item" &&
										k.key === b.getLastKey())) &&
									((w = b.getLastKey()), (D = "after")),
									(k = {
										type: "item",
										key: w,
										dropPosition: D,
									});
								let {
										draggingCollectionRef: S,
										draggingKeys: $,
									} = Qn,
									A =
										(S == null ? void 0 : S.current) ===
										(n == null ? void 0 : n.current),
									T = r.state.getDropOperation({
										target: k,
										types: y,
										allowedOperations:
											v.allowedDropOperations,
										isInternal: A,
										draggingKeys: $,
									});
								var x;
								T === "cancel" &&
									(k =
										(x = p(
											k,
											y,
											v.allowedDropOperations,
											f,
											!1,
										)) !== null && x !== void 0
											? x
											: p(
													k,
													y,
													v.allowedDropOperations,
													h,
													!1,
												));
							}
							r.state.setTarget(k ?? r.state.target);
						}
						break;
					case "PageUp": {
						if (!b.getKeyPageAbove) break;
						let k = r.state.target;
						if (!k) k = p(null, y, v.allowedDropOperations, h);
						else if (k.type === "item") {
							if (k.key === b.getFirstKey()) k = { type: "root" };
							else {
								let $ = b.getKeyPageAbove(k.key),
									A = k.dropPosition;
								$ == null &&
									(($ = b.getFirstKey()), (A = "before")),
									(k = {
										type: "item",
										key: $,
										dropPosition: A,
									});
							}
							let { draggingKeys: w } = Qn,
								D = Gs(n),
								S = r.state.getDropOperation({
									target: k,
									types: y,
									allowedOperations: v.allowedDropOperations,
									isInternal: D,
									draggingKeys: w,
								});
							var C;
							S === "cancel" &&
								(k =
									(C = p(
										k,
										y,
										v.allowedDropOperations,
										h,
										!1,
									)) !== null && C !== void 0
										? C
										: p(
												k,
												y,
												v.allowedDropOperations,
												f,
												!1,
											));
						}
						r.state.setTarget(k ?? r.state.target);
						break;
					}
				}
			},
		});
	}, [r, n, u, c]);
	let d = Ot();
	return (
		ID.set(e, { id: d, ref: n }),
		{ collectionProps: xe(s, { id: d, "aria-describedby": null }) }
	);
}
function AM(t, e, n) {
	let { dropProps: r } = SM(),
		i = Eoe(e);
	E.useEffect(() => {
		if (n.current)
			return Poe({
				element: n.current,
				target: t.target,
				getDropOperation(c, d) {
					let { draggingKeys: f } = Qn,
						h = Gs(i);
					return e.getDropOperation({
						target: t.target,
						types: c,
						allowedOperations: d,
						isInternal: h,
						draggingKeys: f,
					});
				},
			});
	}, [n, t.target, e, i]);
	let o = PD(),
		{ draggingKeys: s } = Qn,
		a = Gs(i),
		l =
			o &&
			e.getDropOperation({
				target: t.target,
				types: Gc(o.dragTarget.items),
				allowedOperations: o.dragTarget.allowedDropOperations,
				isInternal: a,
				draggingKeys: s,
			}) !== "cancel",
		u = e.isDropTarget(t.target);
	return (
		E.useEffect(() => {
			o && u && n.current && n.current.focus();
		}, [u, o, n]),
		{
			dropProps: { ...r, "aria-hidden": !o || l ? void 0 : "true" },
			isDropTarget: u,
		}
	);
}
function Yoe(t) {
	return t && t.__esModule ? t.default : t;
}
function Joe(t, e, n) {
	let { target: r } = t,
		{ collection: i } = e,
		o = Le(Yoe(b0), "@react-aria/dnd"),
		s = PD(),
		{ dropProps: a } = AM(t, e, n),
		l = Ot(),
		u = (p) => {
			var g, v, b;
			return (b =
				(g = i.getTextValue) === null || g === void 0
					? void 0
					: g.call(i, p)) !== null && b !== void 0
				? b
				: (v = i.getItem(p)) === null || v === void 0
					? void 0
					: v.textValue;
		},
		c = "",
		d;
	if (r.type === "root") (c = o.format("dropOnRoot")), (d = `${l} ${woe(e)}`);
	else if (r.dropPosition === "on")
		c = o.format("dropOnItem", { itemText: u(r.key) });
	else {
		let p, g;
		i.getFirstKey() === r.key && r.dropPosition === "before"
			? (p = null)
			: (p = r.dropPosition === "before" ? i.getKeyBefore(r.key) : r.key),
			i.getLastKey() === r.key && r.dropPosition === "after"
				? (g = null)
				: (g =
						r.dropPosition === "after"
							? i.getKeyAfter(r.key)
							: r.key),
			p && g
				? (c = o.format("insertBetween", {
						beforeItemText: u(p),
						afterItemText: u(g),
					}))
				: p
					? (c = o.format("insertAfter", { itemText: u(p) }))
					: g && (c = o.format("insertBefore", { itemText: u(g) }));
	}
	let f = e.isDropTarget(r),
		h = s ? a["aria-hidden"] : "true";
	return {
		dropIndicatorProps: {
			...a,
			id: l,
			"aria-roledescription": o.format("dropIndicator"),
			"aria-label": c,
			"aria-labelledby": d,
			"aria-hidden": h,
			tabIndex: -1,
		},
		isDropTarget: f,
		isHidden: !f && !!h,
	};
}
function Xoe(t) {
	return t && t.__esModule ? t.default : t;
}
const Zoe = {
	keyboard: {
		selected: "dragSelectedKeyboard",
		notSelected: "dragDescriptionKeyboard",
	},
	touch: {
		selected: "dragSelectedLongPress",
		notSelected: "dragDescriptionLongPress",
	},
	virtual: {
		selected: "dragDescriptionVirtual",
		notSelected: "dragDescriptionVirtual",
	},
};
function Qoe(t, e) {
	let n = Le(Xoe(b0), "@react-aria/dnd"),
		r = e.isDisabled || e.selectionManager.isDisabled(t.key),
		{ dragProps: i, dragButtonProps: o } = Voe({
			getItems() {
				return e.getItems(t.key);
			},
			preview: e.preview,
			getAllowedDropOperations: e.getAllowedDropOperations,
			hasDragButton: t.hasDragButton,
			onDragStart(b) {
				e.startDrag(t.key, b), Ioe(e.draggingKeys);
			},
			onDragMove(b) {
				e.moveDrag(b);
			},
			onDragEnd(b) {
				let { dropOperation: y } = b,
					x = y === "cancel" ? !1 : Gs();
				e.endDrag({ ...b, keys: e.draggingKeys, isInternal: x }), UO();
			},
		}),
		s = e.collection.getItem(t.key),
		a = e.getKeysForDrag(t.key).size,
		l = a > 1 && e.selectionManager.isSelected(t.key),
		u,
		c,
		d = FD();
	if (!t.hasDragButton && e.selectionManager.selectionMode !== "none") {
		let b = Zoe[d][l ? "selected" : "notSelected"];
		t.hasAction && d === "keyboard" && (b += "Alt"),
			l ? (c = n.format(b, { count: a })) : (c = n.format(b)),
			delete i.onClick;
	} else if (l) u = n.format("dragSelectedItems", { count: a });
	else {
		var f, h, p, g;
		let b =
			(g =
				(p =
					(f = (h = e.collection).getTextValue) === null ||
					f === void 0
						? void 0
						: f.call(h, t.key)) !== null && p !== void 0
					? p
					: s == null
						? void 0
						: s.textValue) !== null && g !== void 0
				? g
				: "";
		u = n.format("dragItem", { itemText: b });
	}
	let v = tc(c);
	if ((c && Object.assign(i, v), !t.hasDragButton && t.hasAction)) {
		let { onKeyDownCapture: b, onKeyUpCapture: y } = i;
		d === "touch" && delete i["aria-describedby"],
			(i.onKeyDownCapture = (x) => {
				x.altKey && (b == null || b(x));
			}),
			(i.onKeyUpCapture = (x) => {
				x.altKey && (y == null || y(x));
			});
	}
	return {
		dragProps: r ? {} : i,
		dragButtonProps: { ...o, isDisabled: r, "aria-label": u },
	};
}
function ese(t, e, n) {
	let { draggingCollectionRef: r } = Qn;
	e.draggingKeys.size > 0 &&
		(r == null ? void 0 : r.current) !== n.current &&
		Boe(n);
}
function tse(t, e) {
	let n = t.children,
		[r, i] = E.useState(null),
		o = E.useRef(null);
	return (
		E.useImperativeHandle(
			e,
			() => (s, a) => {
				nl.flushSync(() => {
					i(n(s));
				}),
					a(o.current),
					requestAnimationFrame(() => {
						i(null);
					});
			},
			[n],
		),
		r
			? le.createElement(
					"div",
					{
						style: {
							zIndex: -100,
							position: "absolute",
							top: 0,
							left: -1e5,
						},
						ref: o,
					},
					r,
				)
			: null
	);
}
let nse = le.forwardRef(tse);
new Gr("DropZone");
function rse(t) {
	let {
			getItems: e,
			isDisabled: n,
			collection: r,
			selectionManager: i,
			onDragStart: o,
			onDragMove: s,
			onDragEnd: a,
			preview: l,
			getAllowedDropOperations: u,
		} = t,
		[, c] = E.useState(!1),
		d = E.useRef(new Set()),
		f = E.useRef(null),
		h = (p) => {
			let g = new Set(
				i.isSelected(p)
					? new Set([...i.selectedKeys].filter((v) => !!r.getItem(v)))
					: [],
			);
			return g.add(p), g;
		};
	return {
		collection: r,
		selectionManager: i,
		get draggedKey() {
			return f.current;
		},
		get draggingKeys() {
			return d.current;
		},
		isDragging(p) {
			return d.current.has(p);
		},
		getKeysForDrag: h,
		getItems(p) {
			return e(h(p));
		},
		isDisabled: n,
		preview: l,
		getAllowedDropOperations: u,
		startDrag(p, g) {
			let v = h(p);
			(d.current = v),
				(f.current = p),
				i.setFocused(!1),
				c(!0),
				typeof o == "function" && o({ ...g, keys: v });
		},
		moveDrag(p) {
			typeof s == "function" && s({ ...p, keys: d.current });
		},
		endDrag(p) {
			let { isInternal: g } = p;
			typeof a == "function" &&
				a({ ...p, keys: d.current, isInternal: g }),
				(d.current = new Set()),
				(f.current = null),
				c(!1);
		},
	};
}
function ise(t) {
	let {
			acceptedDragTypes: e = "all",
			isDisabled: n,
			onInsert: r,
			onRootDrop: i,
			onItemDrop: o,
			onReorder: s,
			shouldAcceptItemDrop: a,
			collection: l,
			selectionManager: u,
			onDropEnter: c,
			getDropOperation: d,
			onDrop: f,
		} = t,
		[h, p] = E.useState(null),
		g = E.useRef(null),
		v = (y) => {
			if (y.dropPosition === "before") {
				let x = l.getKeyBefore(y.key);
				return x != null
					? { type: "item", key: x, dropPosition: "after" }
					: null;
			} else if (y.dropPosition === "after") {
				let x = l.getKeyAfter(y.key);
				return x != null
					? { type: "item", key: x, dropPosition: "before" }
					: null;
			}
		},
		b = E.useCallback(
			(y) => {
				if (n) return "cancel";
				let {
					target: x,
					types: C,
					allowedOperations: k,
					isInternal: w,
					draggingKeys: D,
				} = y;
				if (e === "all" || e.some((S) => C.has(S))) {
					let S =
							r &&
							x.type === "item" &&
							!w &&
							(x.dropPosition === "before" ||
								x.dropPosition === "after"),
						$ =
							s &&
							x.type === "item" &&
							w &&
							(x.dropPosition === "before" ||
								x.dropPosition === "after"),
						A = i && x.type === "root" && !w,
						T =
							o &&
							x.type === "item" &&
							x.dropPosition === "on" &&
							!(w && D.has(x.key)) &&
							(!a || a(x, C));
					if (f || S || $ || A || T) return d ? d(x, C, k) : k[0];
				}
				return "cancel";
			},
			[n, e, d, r, i, o, a, s, f],
		);
	return {
		collection: l,
		selectionManager: u,
		isDisabled: n,
		target: h,
		setTarget(y) {
			if (this.isDropTarget(y)) return;
			let x = g.current;
			x &&
				typeof t.onDropExit == "function" &&
				t.onDropExit({ type: "dropexit", x: 0, y: 0, target: x }),
				y &&
					typeof c == "function" &&
					c({ type: "dropenter", x: 0, y: 0, target: y }),
				(g.current = y),
				p(y);
		},
		isDropTarget(y) {
			let x = g.current;
			return H4(y, x)
				? !0
				: (y == null ? void 0 : y.type) === "item" &&
					  (x == null ? void 0 : x.type) === "item" &&
					  y.key !== x.key &&
					  y.dropPosition !== x.dropPosition &&
					  y.dropPosition !== "on" &&
					  x.dropPosition !== "on"
					? H4(v(y), x) || H4(y, v(x))
					: !1;
		},
		getDropOperation(y) {
			return b(y);
		},
	};
}
function H4(t, e) {
	if (!t) return !e;
	switch (t.type) {
		case "root":
			return (e == null ? void 0 : e.type) === "root";
		case "item":
			return (
				(e == null ? void 0 : e.type) === "item" &&
				(e == null ? void 0 : e.key) === t.key &&
				(e == null ? void 0 : e.dropPosition) === t.dropPosition
			);
	}
}
function ose(t, e) {
	let {
			acceptedFileTypes: n,
			allowsMultiple: r,
			children: i,
			defaultCamera: o,
			onSelect: s,
			...a
		} = t,
		l = Ct(e),
		u = Ge(a);
	return m.jsxs(m.Fragment, {
		children: [
			m.jsx(Al, {
				onPress: () => {
					var c, d;
					(c = l.current) !== null &&
						c !== void 0 &&
						c.value &&
						(l.current.value = ""),
						(d = l.current) === null || d === void 0 || d.click();
				},
				children: i,
			}),
			m.jsx("input", {
				...u,
				accept: n == null ? void 0 : n.toString(),
				capture: o,
				multiple: r,
				onChange: (c) => (s == null ? void 0 : s(c.target.files)),
				ref: l,
				style: { display: "none" },
				type: "file",
			}),
		],
	});
}
const sse = E.forwardRef(ose);
function $M(t) {
	const e = ce(11);
	let n, r, i;
	e[0] !== t
		? (({ children: i, isDropTarget: r, ...n } = t),
			(e[0] = t),
			(e[1] = n),
			(e[2] = r),
			(e[3] = i))
		: ((n = e[1]), (r = e[2]), (i = e[3]));
	const o = B.color.background.canvas,
		s = B.color.background.accentEmphasis,
		a = B.size.border.medium,
		l = B.size.space.regular;
	let u;
	e[4] !== n.className
		? ((u = Se(
				X({
					insetInlineStart: l,
					outline: "none",
					position: "absolute",
					width: `calc(100% - (2 * ${l}))`,
					"&[data-drop-target=true]": {
						borderBottom: `${a} solid ${s}`,
						"&::before": { left: `calc(${l} * -1)` },
						"&::after": { right: `calc(${l} * -1)` },
						"&::before, &::after": {
							backgroundColor: o,
							border: `${a} solid ${s}`,
							borderRadius: "50%",
							content: '" "',
							height: l,
							position: "absolute",
							top: `calc(${l} / -2 - ${a} / 2)`,
							width: l,
							zIndex: 5,
						},
					},
				}),
				n.className,
			)),
			(e[4] = n.className),
			(e[5] = u))
		: (u = e[5]);
	let c;
	return (
		e[6] !== r || e[7] !== n || e[8] !== u || e[9] !== i
			? ((c = m.jsx("div", {
					"data-drop-target": r,
					...n,
					className: u,
					children: i,
				})),
				(e[6] = r),
				(e[7] = n),
				(e[8] = u),
				(e[9] = i),
				(e[10] = c))
			: (c = e[10]),
		c
	);
}
function TM(t) {
	return {
		dragAndDropHooks: E.useMemo(() => {
			let {
					onDrop: n,
					onInsert: r,
					onItemDrop: i,
					onReorder: o,
					onRootDrop: s,
					getItems: a,
					renderPreview: l,
				} = t,
				u = !!a,
				c = !!(n || r || i || o || s),
				d = {};
			return (
				u &&
					((d.useDraggableCollectionState = function (h) {
						return rse({ ...h, ...t });
					}),
					(d.useDraggableCollection = ese),
					(d.useDraggableItem = Qoe),
					(d.DragPreview = nse),
					(d.renderPreview = l)),
				c &&
					((d.useDroppableCollectionState = function (h) {
						return ise({ ...h, ...t });
					}),
					(d.useDroppableItem = AM),
					(d.useDroppableCollection = function (h, p, g) {
						return Goe({ ...h, ...t }, p, g);
					}),
					(d.useDropIndicator = Joe)),
				(u || c) && (d.isVirtualDragging = Roe),
				d
			);
		}, [t]),
	};
}
const i$ = 48;
class ND extends Uie {
	getLayoutInfo(e) {
		var n;
		return (
			this.ensureLayoutInfo(e),
			((n = this.layoutNodes.get(e)) === null || n === void 0
				? void 0
				: n.layoutInfo) || null
		);
	}
	getVisibleLayoutInfos(e) {
		if (e.height > 1) {
			var n;
			let o =
				(n = this.rowHeight) !== null && n !== void 0
					? n
					: this.estimatedRowHeight;
			(e.y = Math.floor(e.y / o) * o),
				(e.height = Math.ceil(e.height / o) * o);
		}
		this.layoutIfNeeded(e);
		let r = [],
			i = (o) => {
				for (let s of o)
					this.isVisible(s, e) &&
						(r.push(s.layoutInfo), s.children && i(s.children));
			};
		return i(this.rootNodes), r;
	}
	layoutIfNeeded(e) {
		if (this.lastCollection) {
			this.requestedRect.containsRect(e) ||
				((this.requestedRect = this.requestedRect.union(e)),
				(this.rootNodes = this.buildCollection()));
			for (let n of this.virtualizer.persistedKeys)
				if (this.ensureLayoutInfo(n)) return;
		}
	}
	ensureLayoutInfo(e) {
		return !this.layoutNodes.has(e) &&
			this.requestedRect.area < this.contentSize.area &&
			this.lastCollection
			? ((this.requestedRect = new St(0, 0, 1 / 0, 1 / 0)),
				(this.rootNodes = this.buildCollection()),
				(this.requestedRect = new St(
					0,
					0,
					this.contentSize.width,
					this.contentSize.height,
				)),
				!0)
			: !1;
	}
	isVisible(e, n) {
		return (
			e.layoutInfo.rect.intersects(n) ||
			e.layoutInfo.isSticky ||
			e.layoutInfo.type === "header" ||
			this.virtualizer.isPersistedKey(e.layoutInfo.key)
		);
	}
	shouldInvalidateEverything(e) {
		return e.sizeChanged;
	}
	update(e) {
		if (
			((this.collection = this.virtualizer.collection),
			(this.invalidateEverything = this.shouldInvalidateEverything(e)),
			this.invalidateEverything &&
				((this.requestedRect = this.virtualizer.visibleRect.copy()),
				this.layoutNodes.clear()),
			(this.rootNodes = this.buildCollection()),
			this.lastCollection && this.collection !== this.lastCollection)
		)
			for (let n of this.lastCollection.getKeys())
				this.collection.getItem(n) ||
					(this.layoutNodes.get(n) && this.layoutNodes.delete(n));
		(this.lastWidth = this.virtualizer.visibleRect.width),
			(this.lastCollection = this.collection),
			(this.invalidateEverything = !1),
			(this.validRect = this.requestedRect.copy());
	}
	buildCollection(e = 0) {
		let n = 0,
			r = [];
		for (let o of this.collection) {
			var i;
			let s =
				(i = this.rowHeight) !== null && i !== void 0
					? i
					: this.estimatedRowHeight;
			if (
				o.type === "item" &&
				e + s < this.requestedRect.y &&
				!this.isValid(o, e)
			) {
				(e += s), n++;
				continue;
			}
			let a = this.buildChild(o, 0, e, null);
			if (
				((e = a.layoutInfo.rect.maxY),
				r.push(a),
				o.type === "item" && e > this.requestedRect.maxY)
			) {
				e += (this.collection.size - (r.length + n)) * s;
				break;
			}
		}
		return (
			(this.contentSize = new bd(this.virtualizer.visibleRect.width, e)),
			r
		);
	}
	isValid(e, n) {
		let r = this.layoutNodes.get(e.key);
		return (
			!this.invalidateEverything &&
			r &&
			r.node === e &&
			n === r.layoutInfo.rect.y &&
			r.layoutInfo.rect.intersects(this.validRect) &&
			r.validRect.containsRect(
				r.layoutInfo.rect.intersection(this.requestedRect),
			)
		);
	}
	buildChild(e, n, r, i) {
		if (this.isValid(e, r)) return this.layoutNodes.get(e.key);
		let o = this.buildNode(e, n, r);
		return (
			(o.layoutInfo.parentKey = i ?? null),
			this.layoutNodes.set(e.key, o),
			o
		);
	}
	buildNode(e, n, r) {
		switch (e.type) {
			case "section":
				return this.buildSection(e, n, r);
			case "item":
				return this.buildItem(e, n, r);
			case "header":
				return this.buildSectionHeader(e, n, r);
			case "loader":
				return this.buildLoader(e, n, r);
		}
	}
	buildLoader(e, n, r) {
		let i = new St(n, r, 0, 0),
			o = new er("loader", e.key, i);
		return (
			(i.width = this.virtualizer.contentSize.width),
			(i.height =
				this.loaderHeight || this.rowHeight || this.estimatedRowHeight),
			{ layoutInfo: o, validRect: i.intersection(this.requestedRect) }
		);
	}
	buildSection(e, n, r) {
		let i = this.virtualizer.visibleRect.width,
			o = new St(0, r, i, 0),
			s = new er(e.type, e.key, o),
			a = r,
			l = 0,
			u = [];
		for (let d of Wt(e, this.collection)) {
			var c;
			let f =
				(c = this.rowHeight) !== null && c !== void 0
					? c
					: this.estimatedRowHeight;
			if (r + f < this.requestedRect.y && !this.isValid(e, r)) {
				(r += f), l++;
				continue;
			}
			let h = this.buildChild(d, n, r, s.key);
			if (
				((r = h.layoutInfo.rect.maxY),
				u.push(h),
				r > this.requestedRect.maxY)
			) {
				r += ([...Wt(e, this.collection)].length - (u.length + l)) * f;
				break;
			}
		}
		return (
			(o.height = r - a),
			{
				layoutInfo: s,
				children: u,
				validRect: s.rect.intersection(this.requestedRect),
				node: e,
			}
		);
	}
	buildSectionHeader(e, n, r) {
		let i = this.virtualizer.visibleRect.width,
			o = this.headingHeight,
			s = !1;
		if (o == null) {
			let u = this.layoutNodes.get(e.key),
				c = u == null ? void 0 : u.layoutInfo;
			if (c) {
				let d = this.collection.getItem(e.key),
					f = this.lastCollection
						? this.lastCollection.getItem(e.key)
						: null;
				(o = c.rect.height),
					(s = i !== this.lastWidth || d !== f || c.estimatedSize);
			} else (o = e.rendered ? this.estimatedHeadingHeight : 0), (s = !0);
		}
		o == null && (o = i$);
		let a = new St(0, r, i, o),
			l = new er("header", e.key, a);
		return (
			(l.estimatedSize = s),
			{
				layoutInfo: l,
				children: [],
				validRect: l.rect.intersection(this.requestedRect),
				node: e,
			}
		);
	}
	buildItem(e, n, r) {
		let i = this.virtualizer.visibleRect.width,
			o = this.rowHeight,
			s = !1;
		if (o == null) {
			let u = this.layoutNodes.get(e.key);
			u
				? ((o = u.layoutInfo.rect.height),
					(s =
						i !== this.lastWidth ||
						e !== u.node ||
						u.layoutInfo.estimatedSize))
				: ((o = this.estimatedRowHeight), (s = !0));
		}
		o == null && (o = i$);
		let a = new St(n, r, i - n, o),
			l = new er(e.type, e.key, a);
		return (
			(l.estimatedSize = s),
			{ layoutInfo: l, children: [], validRect: l.rect, node: e }
		);
	}
	updateItemSize(e, n) {
		let r = this.layoutNodes.get(e);
		if (!r) return !1;
		let i = r.layoutInfo;
		if (((i.estimatedSize = !1), i.rect.height !== n.height)) {
			let o = i.copy();
			(o.rect.height = n.height),
				(r.layoutInfo = o),
				(this.validRect.height = Math.min(
					this.validRect.height,
					i.rect.y - this.validRect.y,
				)),
				(this.requestedRect.height += o.rect.height - i.rect.height),
				this.updateLayoutNode(e, i, o);
			let s = this.collection.getItem(i.parentKey);
			for (; s; )
				this.updateLayoutNode(s.key, i, o),
					(s = this.collection.getItem(s.parentKey));
			return !0;
		}
		return !1;
	}
	updateLayoutNode(e, n, r) {
		let i = this.layoutNodes.get(e);
		i &&
			((i.validRect = i.validRect.intersection(this.validRect)),
			i.layoutInfo === n && (i.layoutInfo = r));
	}
	getContentSize() {
		return this.contentSize;
	}
	getDropTargetFromPoint(e, n, r) {
		(e += this.virtualizer.visibleRect.x),
			(n += this.virtualizer.visibleRect.y);
		let i = this.virtualizer.keyAtPoint(new Za(e, n));
		if (i == null || this.collection.size === 0) return { type: "root" };
		let o = this.getLayoutInfo(i),
			s = o.rect,
			a = { type: "item", key: o.key, dropPosition: "on" };
		return (
			r(a)
				? n <= s.y + 10 && r({ ...a, dropPosition: "before" })
					? (a.dropPosition = "before")
					: n >= s.maxY - 10 &&
						r({ ...a, dropPosition: "after" }) &&
						(a.dropPosition = "after")
				: n <= s.y + s.height / 2 && r({ ...a, dropPosition: "before" })
					? (a.dropPosition = "before")
					: r({ ...a, dropPosition: "after" }) &&
						(a.dropPosition = "after"),
			a
		);
	}
	getDropTargetLayoutInfo(e) {
		let n = this.getLayoutInfo(e.key),
			r;
		return (
			e.dropPosition === "before"
				? (r = new St(
						n.rect.x,
						n.rect.y - this.dropIndicatorThickness / 2,
						n.rect.width,
						this.dropIndicatorThickness,
					))
				: e.dropPosition === "after"
					? (r = new St(
							n.rect.x,
							n.rect.maxY - this.dropIndicatorThickness / 2,
							n.rect.width,
							this.dropIndicatorThickness,
						))
					: (r = n.rect),
			new er("dropIndicator", e.key + ":" + e.dropPosition, r)
		);
	}
	constructor(e = {}) {
		super(),
			(this.rowHeight = e.rowHeight),
			(this.estimatedRowHeight = e.estimatedRowHeight),
			(this.headingHeight = e.headingHeight),
			(this.estimatedHeadingHeight = e.estimatedHeadingHeight),
			(this.loaderHeight = e.loaderHeight),
			(this.dropIndicatorThickness = e.dropIndicatorThickness || 2),
			(this.layoutNodes = new Map()),
			(this.rootNodes = []),
			(this.lastWidth = 0),
			(this.lastCollection = null),
			(this.validRect = new St()),
			(this.requestedRect = new St()),
			(this.contentSize = new bd());
	}
}
class ase extends ND {
	columnsChanged(e, n) {
		return (
			!n ||
			(e.columns !== n.columns &&
				e.columns.length !== n.columns.length) ||
			e.columns.some(
				(r, i) =>
					r.key !== n.columns[i].key ||
					r.props.width !== n.columns[i].props.width ||
					r.props.minWidth !== n.columns[i].props.minWidth ||
					r.props.maxWidth !== n.columns[i].props.maxWidth,
			)
		);
	}
	update(e) {
		var n;
		let r = this.virtualizer.collection;
		if (!((n = e.layoutOptions) === null || n === void 0) && n.columnWidths)
			e.layoutOptions.columnWidths !== this.columnWidths &&
				((this.columnWidths = e.layoutOptions.columnWidths),
				(e.sizeChanged = !0));
		else if (e.sizeChanged || this.columnsChanged(r, this.collection)) {
			let i = new HN({});
			(this.columnWidths = i.buildColumnWidths(
				this.virtualizer.visibleRect.width,
				r,
				new Map(),
			)),
				(e.sizeChanged = !0);
		}
		super.update(e);
	}
	buildCollection() {
		this.stickyColumnIndices = [];
		for (let r of this.collection.columns)
			(this.isStickyColumn(r) ||
				this.collection.rowHeaderColumnKeys.has(r.key)) &&
				this.stickyColumnIndices.push(r.index);
		let e = this.buildTableHeader();
		this.layoutNodes.set(e.layoutInfo.key, e);
		let n = this.buildBody(e.layoutInfo.rect.height);
		return (
			(this.lastPersistedKeys = null),
			(n.layoutInfo.rect.width = Math.max(
				e.layoutInfo.rect.width,
				n.layoutInfo.rect.width,
			)),
			(this.contentSize = new bd(
				n.layoutInfo.rect.width,
				n.layoutInfo.rect.maxY,
			)),
			[e, n]
		);
	}
	buildTableHeader() {
		var e;
		let n = new St(0, 0, 0, 0);
		var r;
		let i = new er(
			"header",
			(r =
				(e = this.collection.head) === null || e === void 0
					? void 0
					: e.key) !== null && r !== void 0
				? r
				: "header",
			n,
		);
		(i.isSticky = !0), (i.zIndex = 1);
		let o = 0,
			s = 0,
			a = [];
		for (let l of this.collection.headerRows) {
			let u = this.buildChild(l, 0, o, i.key);
			(u.layoutInfo.parentKey = i.key),
				(o = u.layoutInfo.rect.maxY),
				(s = Math.max(s, u.layoutInfo.rect.width)),
				(u.index = a.length),
				a.push(u);
		}
		return (
			(n.width = s),
			(n.height = o),
			{
				layoutInfo: i,
				children: a,
				validRect: i.rect,
				node: this.collection.head,
			}
		);
	}
	buildHeaderRow(e, n, r) {
		let i = new St(0, r, 0, 0),
			o = new er("headerrow", e.key, i),
			s = 0,
			a = [];
		for (let l of Wt(e, this.collection)) {
			let u = this.buildChild(l, n, r, o.key);
			(u.layoutInfo.parentKey = o.key),
				(n = u.layoutInfo.rect.maxX),
				(s = Math.max(s, u.layoutInfo.rect.height)),
				(u.index = a.length),
				a.push(u);
		}
		for (let [l, u] of a.entries()) u.layoutInfo.zIndex = a.length - l + 1;
		return (
			this.setChildHeights(a, s),
			(i.height = s),
			(i.width = n),
			{ layoutInfo: o, children: a, validRect: i, node: e }
		);
	}
	setChildHeights(e, n) {
		for (let r of e)
			r.layoutInfo.rect.height !== n &&
				((r.layoutInfo = r.layoutInfo.copy()),
				(r.layoutInfo.rect.height = n));
	}
	getRenderedColumnWidth(e) {
		var n;
		let r = (n = e.colspan) !== null && n !== void 0 ? n : 1;
		var i;
		let o = (i = e.colIndex) !== null && i !== void 0 ? i : e.index,
			s = 0;
		for (let a = o; a < o + r; a++) {
			let l = this.collection.columns[a];
			(l == null ? void 0 : l.key) != null &&
				(s += this.columnWidths.get(l.key));
		}
		return s;
	}
	getEstimatedHeight(e, n, r, i) {
		let o = !1;
		if (r == null) {
			let s = this.layoutNodes.get(e.key);
			s
				? ((r = s.layoutInfo.rect.height),
					(o =
						e !== s.node ||
						n !== s.layoutInfo.rect.width ||
						s.layoutInfo.estimatedSize))
				: ((r = i), (o = !0));
		}
		return { height: r, isEstimated: o };
	}
	getEstimatedRowHeight() {
		var e;
		return (e = this.rowHeight) !== null && e !== void 0
			? e
			: this.estimatedRowHeight;
	}
	buildColumn(e, n, r) {
		let i = this.getRenderedColumnWidth(e),
			{ height: o, isEstimated: s } = this.getEstimatedHeight(
				e,
				i,
				this.headingHeight,
				this.estimatedHeadingHeight,
			),
			a = new St(n, r, i, o),
			l = new er(e.type, e.key, a);
		return (
			(l.isSticky = this.isStickyColumn(e)),
			(l.zIndex = l.isSticky ? 2 : 1),
			(l.estimatedSize = s),
			{ layoutInfo: l, children: [], validRect: l.rect, node: e }
		);
	}
	isStickyColumn(e) {
		return !1;
	}
	buildBody(e) {
		let n = new St(0, e, 0, 0),
			r = new er("rowgroup", this.collection.body.key, n),
			i = e,
			o = 0,
			s = 0,
			a = [],
			l = this.getEstimatedRowHeight();
		for (let u of Wt(this.collection.body, this.collection)) {
			if (e + l < this.requestedRect.y && !this.isValid(u, e)) {
				(e += l), o++;
				continue;
			}
			let c = this.buildChild(u, 0, e, r.key);
			if (
				((c.layoutInfo.parentKey = r.key),
				(c.index = a.length),
				(e = c.layoutInfo.rect.maxY),
				(s = Math.max(s, c.layoutInfo.rect.width)),
				a.push(c),
				e > this.requestedRect.maxY)
			) {
				e += (this.collection.size - (o + a.length)) * l;
				break;
			}
		}
		return (
			a.length === 0 && (e = this.virtualizer.visibleRect.maxY),
			(n.width = s),
			(n.height = e - i),
			{
				layoutInfo: r,
				children: a,
				validRect: r.rect.intersection(this.requestedRect),
				node: this.collection.body,
			}
		);
	}
	buildNode(e, n, r) {
		switch (e.type) {
			case "headerrow":
				return this.buildHeaderRow(e, n, r);
			case "item":
				return this.buildRow(e, n, r);
			case "column":
			case "placeholder":
				return this.buildColumn(e, n, r);
			case "cell":
				return this.buildCell(e, n, r);
			case "loader":
				return this.buildLoader(e, n, r);
			default:
				throw new Error("Unknown node type " + e.type);
		}
	}
	buildRow(e, n, r) {
		var i;
		let o = new St(n, r, 0, 0),
			s = new er("row", e.key, o),
			a = [],
			l = 0;
		for (let c of Wt(e, this.collection))
			if (c.type === "cell")
				if (n > this.requestedRect.maxX) {
					let d = this.layoutNodes.get(c.key);
					if (d)
						(d.layoutInfo.rect.x = n),
							(n += d.layoutInfo.rect.width);
					else break;
				} else {
					let d = this.buildChild(c, n, r, s.key);
					(n = d.layoutInfo.rect.maxX),
						(l = Math.max(l, d.layoutInfo.rect.height)),
						(d.index = a.length),
						a.push(d);
				}
		this.setChildHeights(a, l);
		var u;
		return (
			(o.width = this.layoutNodes.get(
				(u =
					(i = this.collection.head) === null || i === void 0
						? void 0
						: i.key) !== null && u !== void 0
					? u
					: "header",
			).layoutInfo.rect.width),
			(o.height = l),
			{
				layoutInfo: s,
				children: a,
				validRect: o.intersection(this.requestedRect),
				node: e,
			}
		);
	}
	buildCell(e, n, r) {
		let i = this.getRenderedColumnWidth(e),
			{ height: o, isEstimated: s } = this.getEstimatedHeight(
				e,
				i,
				this.rowHeight,
				this.estimatedRowHeight,
			),
			a = new St(n, r, i, o),
			l = new er(e.type, e.key, a);
		return (
			(l.isSticky = this.isStickyColumn(e)),
			(l.zIndex = l.isSticky ? 2 : 1),
			(l.estimatedSize = s),
			{ layoutInfo: l, children: [], validRect: a, node: e }
		);
	}
	getVisibleLayoutInfos(e) {
		if (e.height > 1) {
			let r = this.getEstimatedRowHeight();
			(e.y = Math.floor(e.y / r) * r),
				(e.height = Math.ceil(e.height / r) * r);
		}
		this.layoutIfNeeded(e);
		let n = [];
		this.buildPersistedIndices();
		for (let r of this.rootNodes)
			n.push(r.layoutInfo), this.addVisibleLayoutInfos(n, r, e);
		return n;
	}
	addVisibleLayoutInfos(e, n, r) {
		if (!(!n.children || n.children.length === 0))
			switch (n.layoutInfo.type) {
				case "header":
					for (let i of n.children)
						e.push(i.layoutInfo),
							this.addVisibleLayoutInfos(e, i, r);
					break;
				case "rowgroup": {
					let i = this.binarySearch(n.children, r.topLeft, "y"),
						o = this.binarySearch(n.children, r.bottomRight, "y"),
						s = this.persistedIndices.get(n.layoutInfo.key),
						a = 0;
					for (; s && a < s.length && s[a] < i; ) {
						let l = s[a];
						l < n.children.length &&
							(e.push(n.children[l].layoutInfo),
							this.addVisibleLayoutInfos(e, n.children[l], r)),
							a++;
					}
					for (let l = i; l <= o; l++) {
						for (; s && a < s.length && s[a] < l; ) a++;
						e.push(n.children[l].layoutInfo),
							this.addVisibleLayoutInfos(e, n.children[l], r);
					}
					for (; s && a < s.length; ) {
						let l = s[a++];
						l < n.children.length &&
							(e.push(n.children[l].layoutInfo),
							this.addVisibleLayoutInfos(e, n.children[l], r));
					}
					break;
				}
				case "headerrow":
				case "row": {
					let i = this.binarySearch(n.children, r.topLeft, "x"),
						o = this.binarySearch(n.children, r.topRight, "x"),
						s = 0,
						a =
							this.persistedIndices.get(n.layoutInfo.key) ||
							this.stickyColumnIndices;
					for (; s < a.length && a[s] < i; ) {
						let l = a[s];
						l < n.children.length &&
							e.push(n.children[l].layoutInfo),
							s++;
					}
					for (let l = i; l <= o; l++) {
						for (; s < a.length && a[s] < l; ) s++;
						e.push(n.children[l].layoutInfo);
					}
					for (; s < a.length; ) {
						let l = a[s++];
						l < n.children.length &&
							e.push(n.children[l].layoutInfo);
					}
					break;
				}
				default:
					throw new Error("Unknown node type " + n.layoutInfo.type);
			}
	}
	binarySearch(e, n, r) {
		let i = 0,
			o = e.length - 1;
		for (; i <= o; ) {
			let s = (i + o) >> 1,
				a = e[s];
			if (
				(r === "x" && a.layoutInfo.rect.maxX <= n.x) ||
				(r === "y" && a.layoutInfo.rect.maxY <= n.y)
			)
				i = s + 1;
			else if (
				(r === "x" && a.layoutInfo.rect.x > n.x) ||
				(r === "y" && a.layoutInfo.rect.y > n.y)
			)
				o = s - 1;
			else return s;
		}
		return Math.max(0, Math.min(e.length - 1, i));
	}
	buildPersistedIndices() {
		if (this.virtualizer.persistedKeys !== this.lastPersistedKeys) {
			(this.lastPersistedKeys = this.virtualizer.persistedKeys),
				this.persistedIndices.clear();
			for (let r of this.virtualizer.persistedKeys) {
				var e;
				let i =
					(e = this.layoutNodes.get(r)) === null || e === void 0
						? void 0
						: e.layoutInfo;
				for (; i && i.parentKey; ) {
					var n;
					let o = this.collection.getItem(i.key),
						s = this.persistedIndices.get(i.parentKey);
					s ||
						((s =
							(o == null ? void 0 : o.type) === "cell" ||
							(o == null ? void 0 : o.type) === "column"
								? [...this.stickyColumnIndices]
								: []),
						this.persistedIndices.set(i.parentKey, s));
					let a = this.layoutNodes.get(i.key).index;
					s.includes(a) || s.push(a),
						(i =
							(n = this.layoutNodes.get(i.parentKey)) === null ||
							n === void 0
								? void 0
								: n.layoutInfo);
				}
			}
			for (let r of this.persistedIndices.values())
				r.sort((i, o) => i - o);
		}
	}
	getDropTargetFromPoint(e, n, r) {
		(e += this.virtualizer.visibleRect.x),
			(n += this.virtualizer.visibleRect.y);
		let i,
			o = new Za(e, n),
			s = new St(o.x, o.y, 1, 1),
			a = this.virtualizer.layout
				.getVisibleLayoutInfos(s)
				.filter((d) => d.type === "row");
		for (let d of a) d.rect.intersects(s) && (i = d.key);
		if (i == null || this.collection.size === 0) return { type: "root" };
		let l = this.getLayoutInfo(i),
			u = l.rect,
			c = { type: "item", key: l.key, dropPosition: "on" };
		return (
			r(c)
				? n <= u.y + 10 && r({ ...c, dropPosition: "before" })
					? (c.dropPosition = "before")
					: n >= u.maxY - 10 &&
						r({ ...c, dropPosition: "after" }) &&
						(c.dropPosition = "after")
				: n <= u.y + u.height / 2 && r({ ...c, dropPosition: "before" })
					? (c.dropPosition = "before")
					: r({ ...c, dropPosition: "after" }) &&
						(c.dropPosition = "after"),
			c
		);
	}
	getDropTargetLayoutInfo(e) {
		let n = super.getDropTargetLayoutInfo(e);
		return (n.parentKey = this.collection.body.key), n;
	}
	constructor(e) {
		super(e),
			(this.lastPersistedKeys = null),
			(this.persistedIndices = new Map()),
			(this.stickyColumnIndices = []);
	}
}
const BM = E.createContext(null);
function xi() {
	const t = E.useContext(BM);
	if (t === null) throw new Error("TableContext not found");
	return t;
}
const IM = E.createContext(null);
function lse() {
	const t = E.useContext(IM);
	if (t === null) throw new Error("VirtualizerContext not found");
	return t;
}
const FM = E.createContext(null);
function use() {
	const t = E.useContext(FM);
	if (t === null) throw new Error("TableRowContext not found");
	return t;
}
const ps = new Gr("TableView", [
		"cell",
		"cell-wrapper",
		"row",
		"body",
		"header",
	]),
	PM = () => {
		const t = ce(2),
			e = B.typography.text.regular.capheight;
		let n;
		t[0] === Symbol.for("react.memo_cache_sentinel")
			? ((n = X({
					alignItems: "center",
					display: "flex",
					flexShrink: 0,
					gridArea: "sort-indicator",
					height: e,
					justifyContent: "center",
					marginInline: B.size.space.small,
					opacity: 0,
					position: "relative",
					transition: bt(["opacity", "transform"], {
						easing: "easeOut",
					}),
					width: e,
					svg: { position: "absolute" },
					'[aria-sort="ascending"] &, [aria-sort="descending"] &': {
						opacity: 1,
					},
					'[aria-sort="descending"] &': {
						transform: "rotate(180deg)",
					},
				})),
				(t[0] = n))
			: (n = t[0]);
		let r;
		return (
			t[1] === Symbol.for("react.memo_cache_sentinel")
				? ((r = m.jsx("span", {
						"aria-hidden": "true",
						className: n,
						children: m.jsx(ve, { src: koe }),
					})),
					(t[1] = r))
				: (r = t[1]),
			r
		);
	},
	cse = X({
		display: "flex",
		flexDirection: "column",
		isolation: "isolate",
		minHeight: 0,
		minWidth: 0,
		outline: "none",
		position: "relative",
		userSelect: "none",
	}),
	dse = X({
		boxSizing: "content-box",
		borderLeft: `${B.size.border.regular} solid transparent`,
		borderRight: `${B.size.border.regular} solid transparent`,
	}),
	fse = Se(ps.element("header"), X({ boxSizing: "border-box" })),
	hse = Se(
		ps.element("body"),
		X({
			backgroundColor: B.color.background.canvas,
			border: `${B.size.border.regular} solid ${B.color.border.neutral}`,
			borderRadius: B.size.radius.medium,
			transform: "translate3d(0, 0, 0)",
		}),
	),
	pse = X({
		blockSize: "100%",
		boxSizing: "border-box",
		display: "flex",
		flexShrink: 0,
		inlineSize: 21,
		insetInlineEnd: -10,
		justifyContent: "center",
		outline: 0,
		position: "absolute",
		userSelect: "none",
		"&::after": {
			backgroundColor: B.color.border.neutral,
			blockSize: "100%",
			boxSizing: "border-box",
			content: '""',
			display: "block",
			inlineSize: 1,
		},
	}),
	mse = X({
		blockSize: "100%",
		boxSizing: "border-box",
		flex: "0 0 auto",
		flexShrink: 0,
		inlineSize: 10,
		userSelect: "none",
	}),
	gse = X({
		backgroundColor: B.color.background.accentEmphasis,
		display: "none",
		flexShrink: 0,
		height: "100%",
		insetInlineEnd: 0,
		pointerEvents: "none",
		position: "absolute",
		top: 1,
		width: 2,
		zIndex: 3,
		"&[data-resizing=true]": { display: "block" },
	}),
	bse = X({
		backgroundColor: B.color.background.accentEmphasis,
		display: "none",
		height: "100%",
		position: "absolute",
		top: 0,
		width: 2,
	}),
	vse = X({
		alignItems: "center",
		display: "flex",
		height: "100%",
		justifyContent: "center",
		width: "100%",
	}),
	NM = X({
		boxSizing: "border-box",
		display: "flex",
		position: "relative",
		outline: 0,
		[`${ps.selector("body")} &::after`]: {
			content: '""',
			boxShadow: `inset 0 -1px 0 0 ${B.color.border.muted}`,
			position: "absolute",
			inset: 0,
			pointerEvents: "none",
			zIndex: 2,
		},
		"&[data-flush-with-container-bottom]::after": { display: "none" },
		'&[aria-selected="true"]::after': {
			boxShadow: `inset 0 -1px 0 0 ${B.color.alias.backgroundSelectedHovered}`,
		},
		'&[data-next-selected="true"]::after': {
			boxShadow: `inset 0 -1px 0 0 ${B.color.alias.backgroundSelectedHovered}`,
		},
		[`${ps.selector("root")}:not([data-prominence="low"]) &`]: {
			"&:first-child": {
				borderStartStartRadius: `calc(${B.size.radius.medium} - ${B.size.border.regular})`,
				borderStartEndRadius: `calc(${B.size.radius.medium} - ${B.size.border.regular})`,
			},
			"&:last-child": {
				borderEndStartRadius: `calc(${B.size.radius.medium} - ${B.size.border.regular})`,
				borderEndEndRadius: `calc(${B.size.radius.medium} - ${B.size.border.regular})`,
			},
		},
		"&[data-focus-visible]": {
			"&::before": {
				backgroundColor: B.color.background.accentEmphasis,
				borderRadius: B.size.space.small,
				content: '""',
				insetInlineStart: B.size.space.xsmall,
				marginBlock: B.size.space.xsmall,
				marginInlineEnd: `calc(${B.size.space.small} * -1)`,
				position: "sticky",
				width: B.size.space.small,
				zIndex: 4,
			},
		},
		[`&[data-hovered=true] ${ps.selector("cell")}`]: {
			backgroundColor: B.color.scale.slate2,
		},
		[`&[data-pressed=true] ${ps.selector("cell")}`]: {
			backgroundColor: B.color.scale.slate3,
		},
		[`&[data-disabled] ${ps.selector("cell")}`]: {
			color: B.color.alias.foregroundDisabled,
		},
		[`&[aria-selected="true"] ${ps.selector("cell")}`]: {
			backgroundColor: B.color.alias.backgroundSelected,
		},
		[`&[aria-selected="true"][data-hovered=true] ${ps.selector("cell")}`]: {
			backgroundColor: B.color.alias.backgroundSelectedHovered,
		},
	}),
	yse = X({
		backgroundColor: B.color.background.canvas,
		border: `${B.size.border.regular} solid ${B.color.alias.borderSelected}`,
		borderRadius: B.size.radius.small,
		paddingInline: B.size.space.medium,
		position: "relative",
		outline: 0,
		width: B.size.alias.singleLineWidth,
		"&[data-multi=true]::after": {
			backgroundColor: "inherit",
			border: "inherit",
			borderRadius: "inherit",
			content: '" "',
			display: "block",
			height: "100%",
			insetBlockStart: B.size.space.small,
			insetInlineStart: B.size.space.small,
			position: "absolute",
			width: "100%",
			zIndex: -1,
		},
	}),
	RM = X({
		boxSizing: "border-box",
		cursor: "default",
		display: "flex",
		height: "100%",
		justifyContent: "flex-start",
		minWidth: 0,
		outline: 0,
		paddingInline: B.size.space.medium,
		position: "relative",
		textAlign: "start",
		"&[data-focus=visible]": {
			borderRadius: B.size.radius.small,
			inset: 0,
			outline: `${B.size.alias.focusRing} solid ${B.color.alias.focusRing}`,
			outlineOffset: `calc(${B.size.alias.focusRingGap} * -1)`,
			position: "absolute",
		},
		paddingBlock: B.size.space.regular,
		'&[data-density="compact"]': { paddingBlock: B.size.space.small },
		'&[data-density="spacious"]': { paddingBlock: B.size.space.medium },
		'&[data-align="end"]': { justifyContent: "flex-end", textAlign: "end" },
		'&[data-align="center"]': {
			justifyContent: "center",
			textAlign: "center",
		},
		'&[data-overflow-mode="truncate"]': { alignItems: "center" },
	}),
	xse = X({
		[`${ps.selector("body")} &`]: {
			backgroundColor: B.color.background.canvas,
		},
	}),
	Nx = Se(ps.element("cell"), RM, X({ color: B.color.foreground.neutral }));
X({ minWidth: 0, flex: 1 });
const Rx = Se(
		RM,
		X({
			alignItems: "center",
			backgroundColor: B.color.background.surface,
			color: B.color.foreground.neutralSecondary,
			minWidth: 0,
			flex: 1,
			"&[aria-sort]": {
				display: "grid",
				gridTemplateAreas: '". sort-indicator"',
				'&[data-align="end"]': {
					gridTemplateAreas: '"sort-indicator ."',
				},
				"&[data-hovered=true]": {
					color: B.color.foreground.neutralEmphasis,
				},
			},
		}),
	),
	kse = X({ paddingInlineStart: B.size.space.regular, paddingInlineEnd: 0 }),
	OM = X({
		paddingBlock: 0,
		paddingInlineEnd: B.size.space.regular,
		label: {
			paddingInlineEnd: B.size.space.regular,
			paddingBlock: B.size.space.regular,
		},
		'&[data-density="compact"]': {
			paddingBlock: 0,
			label: { paddingBlock: B.size.space.small },
		},
		'&[data-density="spacious"]': {
			paddingBlock: 0,
			label: { paddingBlock: B.size.space.medium },
		},
	});
function Cse(t) {
	const e = ce(13),
		{ itemText: n, itemCount: r, height: i, maxWidth: o } = t,
		s = r > 1;
	let a;
	e[0] !== i || e[1] !== o
		? ((a = { height: i, maxWidth: o }), (e[0] = i), (e[1] = o), (e[2] = a))
		: (a = e[2]);
	let l;
	e[3] !== n
		? ((l = m.jsx(ue, { children: n })), (e[3] = n), (e[4] = l))
		: (l = e[4]);
	let u;
	e[5] !== s || e[6] !== r
		? ((u =
				s &&
				m.jsx(ke, {
					alignItems: "center",
					backgroundColor: "accentEmphasis",
					borderRadius: "small",
					gridArea: "badge",
					justifyContent: "center",
					minWidth: "element.small",
					padding: "small",
					children: m.jsx(ue, {
						align: "center",
						color: "inverse",
						size: "small",
						weight: "medium",
						children: r,
					}),
				})),
			(e[5] = s),
			(e[6] = r),
			(e[7] = u))
		: (u = e[7]);
	let c;
	return (
		e[8] !== s || e[9] !== a || e[10] !== l || e[11] !== u
			? ((c = m.jsxs(ke, {
					alignItems: "center",
					justifyContent: "space-between",
					"data-multi": s,
					UNSAFE_className: yse,
					UNSAFE_style: a,
					children: [l, u],
				})),
				(e[8] = s),
				(e[9] = a),
				(e[10] = l),
				(e[11] = u),
				(e[12] = c))
			: (c = e[12]),
		c
	);
}
function o$(t) {
	var e, n, r, i;
	let { rowProps: o, target: s, visibleRect: a } = t,
		{ dropState: l, dragAndDropHooks: u } = xi(),
		c = E.useRef(null);
	wt(
		!!(u != null && u.useDropIndicator),
		"dragAndDropHooks.useDropIndicator is not defined.",
	),
		wt(!!l, "dropState is not defined.");
	let { dropIndicatorProps: d } = u.useDropIndicator(t, l, c),
		{ visuallyHiddenProps: f } = Ea(),
		h = l && l.isDropTarget(s);
	if (!h && d["aria-hidden"]) return null;
	let p =
			(e = Number(
				o == null || (n = o.style) === null || n === void 0
					? void 0
					: n.top,
			)) !== null && e !== void 0
				? e
				: 0,
		g =
			(r = Number(
				o == null || (i = o.style) === null || i === void 0
					? void 0
					: i.height,
			)) !== null && r !== void 0
				? r
				: 0;
	return m.jsx("div", {
		style: {
			left: a.x,
			position: "absolute",
			top: p + (s.dropPosition === "after" ? g : 0),
			width: a.width,
			zIndex: 4,
		},
		role: "row",
		"aria-hidden": d["aria-hidden"],
		children: m.jsx($M, {
			role: "gridcell",
			isDropTarget: h,
			children: m.jsx("div", { ...f, role: "button", ...d, ref: c }),
		}),
	});
}
const RD = {
		"ar-AE": {
			collapse: "طي",
			columnResizer: "أداة تغيير حجم العمود",
			drag: "سحب",
			expand: "مد",
			loading: "جارٍ التحميل...",
			loadingMore: "جارٍ تحميل المزيد...",
			resizeColumn: "تغيير حجم العمود",
			sortAscending: "فرز بترتيب تصاعدي",
			sortDescending: "فرز بترتيب تنازلي",
		},
		"bg-BG": {
			collapse: "Свиване",
			columnResizer: "Преоразмеряване на колони",
			drag: "Плъзнете",
			expand: "Разширяване",
			loading: "Зареждане...",
			loadingMore: "Зареждане на още...",
			resizeColumn: "Преоразмеряване на колона",
			sortAscending: "Възходящо сортиране",
			sortDescending: "Низходящо сортиране ",
		},
		"cs-CZ": {
			collapse: "Zmenšit",
			columnResizer: "Změna velikosti sloupce",
			drag: "Přetáhnout",
			expand: "Roztáhnout",
			loading: "Načítání...",
			loadingMore: "Načítání dalších...",
			resizeColumn: "Změnit velikost sloupce",
			sortAscending: "Seřadit vzestupně",
			sortDescending: "Seřadit sestupně",
		},
		"da-DK": {
			collapse: "Skjul",
			columnResizer: "Kolonneændring",
			drag: "Træk",
			expand: "Udvid",
			loading: "Indlæser ...",
			loadingMore: "Indlæser flere ...",
			resizeColumn: "Tilpas størrelse på kolonne",
			sortAscending: "Sorter stigende",
			sortDescending: "Sorter faldende",
		},
		"de-DE": {
			collapse: "Reduzieren",
			columnResizer: "Spaltenanpassung",
			drag: "Ziehen",
			expand: "Erweitern",
			loading: "Laden...",
			loadingMore: "Mehr laden ...",
			resizeColumn: "Spaltengröße ändern",
			sortAscending: "Aufsteigend sortieren",
			sortDescending: "Absteigend sortieren",
		},
		"el-GR": {
			collapse: "Σύμπτυξη",
			columnResizer: "Αλλαγή μεγέθους στήλης",
			drag: "Μεταφορά",
			expand: "Ανάπτυξη",
			loading: "Φόρτωση...",
			loadingMore: "Φόρτωση περισσότερων...",
			resizeColumn: "Αλλαγή μεγέθους στήλης",
			sortAscending: "Ταξινόμηση κατά αύξουσα σειρά",
			sortDescending: "Ταξινόμηση κατά φθίνουσα σειρά",
		},
		"en-US": {
			loading: "Loading…",
			loadingMore: "Loading more…",
			sortAscending: "Sort Ascending",
			sortDescending: "Sort Descending",
			resizeColumn: "Resize column",
			columnResizer: "Column resizer",
			drag: "Drag",
			expand: "Expand",
			collapse: "Collapse",
		},
		"es-ES": {
			collapse: "Contraer",
			columnResizer: "Redimensionador de columnas",
			drag: "Arrastrar",
			expand: "Ampliar",
			loading: "Cargando…",
			loadingMore: "Cargando más…",
			resizeColumn: "Cambiar el tamaño de la columna",
			sortAscending: "Orden de subida",
			sortDescending: "Orden de bajada",
		},
		"et-EE": {
			collapse: "Ahenda",
			columnResizer: "Veeru suuruse muutja",
			drag: "Lohista",
			expand: "Laienda",
			loading: "Laadimine...",
			loadingMore: "Laadi rohkem...",
			resizeColumn: "Muuda veeru suurust",
			sortAscending: "Sordi kasvavalt",
			sortDescending: "Sordi kahanevalt",
		},
		"fi-FI": {
			collapse: "Pienennä",
			columnResizer: "Sarakekoon muuttaja",
			drag: "Vedä",
			expand: "Laajenna",
			loading: "Ladataan…",
			loadingMore: "Ladataan lisää…",
			resizeColumn: "Muuta sarakkeen kokoa",
			sortAscending: "Lajittelujärjestys: nouseva",
			sortDescending: "Lajittelujärjestys: laskeva",
		},
		"fr-FR": {
			collapse: "Réduire",
			columnResizer: "Redimensionnement de colonne",
			drag: "Faire glisser",
			expand: "Développer",
			loading: "Chargement...",
			loadingMore: "Chargement supplémentaire...",
			resizeColumn: "Redimensionner la colonne",
			sortAscending: "Trier par ordre croissant",
			sortDescending: "Trier par ordre décroissant",
		},
		"he-IL": {
			collapse: "כווץ",
			columnResizer: "שינוי גודל עמודה",
			drag: "גרור",
			expand: "הרחב",
			loading: "טוען...",
			loadingMore: "טוען עוד...",
			resizeColumn: "שנה את גודל העמודה",
			sortAscending: "מיין בסדר עולה",
			sortDescending: "מיין בסדר יורד",
		},
		"hr-HR": {
			collapse: "Sažmi",
			columnResizer: "Alat za promjenu veličine stupca",
			drag: "Povucite",
			expand: "Proširi",
			loading: "Učitavam...",
			loadingMore: "Učitavam još...",
			resizeColumn: "Promijeni veličinu stupca",
			sortAscending: "Sortiraj uzlazno",
			sortDescending: "Sortiraj silazno",
		},
		"hu-HU": {
			collapse: "Összecsukás",
			columnResizer: "Oszlopátméretező",
			drag: "Húzás",
			expand: "Kibontás",
			loading: "Betöltés folyamatban…",
			loadingMore: "Továbbiak betöltése folyamatban…",
			resizeColumn: "Oszlop átméretezése",
			sortAscending: "Növekvő rendezés",
			sortDescending: "Csökkenő rendezés",
		},
		"it-IT": {
			collapse: "Comprimi",
			columnResizer: "Ridimensionamento colonne",
			drag: "Trascina",
			expand: "Espandi",
			loading: "Caricamento...",
			loadingMore: "Caricamento altri...",
			resizeColumn: "Ridimensiona colonna",
			sortAscending: "Ordinamento crescente",
			sortDescending: "Ordinamento decrescente",
		},
		"ja-JP": {
			collapse: "折りたたむ",
			columnResizer: "列リサイザー",
			drag: "ドラッグ",
			expand: "展開",
			loading: "読み込み中...",
			loadingMore: "さらに読み込み中...",
			resizeColumn: "列幅を変更",
			sortAscending: "昇順に並べ替え",
			sortDescending: "降順に並べ替え",
		},
		"ko-KR": {
			collapse: "접기",
			columnResizer: "열 크기 조정기",
			drag: "드래그",
			expand: "펼치기",
			loading: "로드 중",
			loadingMore: "추가 로드 중",
			resizeColumn: "열 크기 조정",
			sortAscending: "오름차순 정렬",
			sortDescending: "내림차순 정렬",
		},
		"lt-LT": {
			collapse: "Sutraukti",
			columnResizer: "Stulpelio dydžio keitiklis",
			drag: "Vilkti",
			expand: "Išskleisti",
			loading: "Įkeliama...",
			loadingMore: "Įkeliama daugiau...",
			resizeColumn: "Keisti stulpelio dydį",
			sortAscending: "Rikiuoti didėjimo tvarka",
			sortDescending: "Rikiuoti mažėjimo tvarka",
		},
		"lv-LV": {
			collapse: "Sakļaut",
			columnResizer: "Kolonnas izmēru mainītājs",
			drag: "Vilkšana",
			expand: "Izvērst",
			loading: "Notiek ielāde...",
			loadingMore: "Tiek ielādēts vēl...",
			resizeColumn: "Mainīt kolonnas lielumu",
			sortAscending: "Kārtot augošā secībā",
			sortDescending: "Kārtot dilstošā secībā",
		},
		"nb-NO": {
			collapse: "Skjul",
			columnResizer: "Størrelsesendring av kolonne",
			drag: "Dra",
			expand: "Utvid",
			loading: "Laster inn ...",
			loadingMore: "Laster inn flere ...",
			resizeColumn: "Endre størrelse på kolonne",
			sortAscending: "Sorter stigende",
			sortDescending: "Sorter synkende",
		},
		"nl-NL": {
			collapse: "Samenvouwen",
			columnResizer: "Groottewijziging van kolom",
			drag: "Slepen",
			expand: "Uitvouwen",
			loading: "Laden...",
			loadingMore: "Meer laden...",
			resizeColumn: "Kolomgrootte wijzigen",
			sortAscending: "Oplopend sorteren",
			sortDescending: "Aflopend sorteren",
		},
		"pl-PL": {
			collapse: "Zwiń",
			columnResizer: "Narzędzie zmiany rozmiaru kolumny",
			drag: "Przeciągnij",
			expand: "Rozwiń",
			loading: "Ładowanie...",
			loadingMore: "Wczytywanie większej liczby...",
			resizeColumn: "Zmień rozmiar kolumny",
			sortAscending: "Sortuj rosnąco",
			sortDescending: "Sortuj malejąco",
		},
		"pt-BR": {
			collapse: "Recolher",
			columnResizer: "Redimensionamento de colunas",
			drag: "Arraste",
			expand: "Expandir",
			loading: "Carregando...",
			loadingMore: "Carregando mais...",
			resizeColumn: "Redimensionar coluna",
			sortAscending: "Ordenar por ordem crescente",
			sortDescending: "Ordenar por ordem decrescente",
		},
		"pt-PT": {
			collapse: "Colapsar",
			columnResizer: "Redimensionador de coluna",
			drag: "Arrastar",
			expand: "Expandir",
			loading: "A carregar...",
			loadingMore: "A carregar mais...",
			resizeColumn: "Redimensionar coluna",
			sortAscending: "Ordenar por ordem ascendente",
			sortDescending: "Ordenar por ordem decrescente",
		},
		"ro-RO": {
			collapse: "Restrângeți",
			columnResizer: "Instrument redimensionare coloane",
			drag: "Trageți",
			expand: "Extindeți",
			loading: "Se încarcă...",
			loadingMore: "Se încarcă mai multe...",
			resizeColumn: "Redimensionați coloana",
			sortAscending: "Sortați crescător",
			sortDescending: "Sortați descrescător",
		},
		"ru-RU": {
			collapse: "Свернуть",
			columnResizer: "Средство изменения размера столбцов",
			drag: "Перетаскивание",
			expand: "Развернуть",
			loading: "Загрузка...",
			loadingMore: "Дополнительная загрузка...",
			resizeColumn: "Изменить размер столбца",
			sortAscending: "Сортировать по возрастанию",
			sortDescending: "Сортировать по убыванию",
		},
		"sk-SK": {
			collapse: "Zbaliť",
			columnResizer: "Nástroj na zmenu veľkosti stĺpcov",
			drag: "Presunúť",
			expand: "Rozbaliť",
			loading: "Načítava sa...",
			loadingMore: "Načítava sa viac...",
			resizeColumn: "Zmeniť veľkosť stĺpca",
			sortAscending: "Zoradiť vzostupne",
			sortDescending: "Zoradiť zostupne",
		},
		"sl-SI": {
			collapse: "Strni",
			columnResizer: "Prilagojevalnik velikosti stolpcev",
			drag: "Povleci",
			expand: "Razširi",
			loading: "Nalaganje...",
			loadingMore: "Nalaganje več vsebine...",
			resizeColumn: "Spremeni velikost stolpca",
			sortAscending: "Razvrsti naraščajoče",
			sortDescending: "Razvrsti padajoče",
		},
		"sr-SP": {
			collapse: "Sažmi",
			columnResizer: "Alat za promenu veličine kolone",
			drag: "Prevuci",
			expand: "Proširi",
			loading: "Učitavam...",
			loadingMore: "Učitavam još...",
			resizeColumn: "Promeni veličinu kolone",
			sortAscending: "Sortiraj po rastućem redosledu",
			sortDescending: "Sortiraj po opadajućem redosledu",
		},
		"sv-SE": {
			collapse: "Dölj",
			columnResizer: "Ändra storlek på kolumn",
			drag: "Dra",
			expand: "Expandera",
			loading: "Läser in...",
			loadingMore: "Läser in mer...",
			resizeColumn: "Ändra storlek på kolumn",
			sortAscending: "Sortera i stigande ordning",
			sortDescending: "Sortera i fallande ordning",
		},
		"tr-TR": {
			collapse: "Daralt",
			columnResizer: "Yeniden sütun boyutlandırıcı",
			drag: "Sürükle",
			expand: "Genişlet",
			loading: "Yükleniyor...",
			loadingMore: "Daha fazla yükleniyor...",
			resizeColumn: "Sütunu yeniden boyutlandır",
			sortAscending: "Artan Sıralama",
			sortDescending: "Azalan Sıralama",
		},
		"uk-UA": {
			collapse: "Згорнути",
			columnResizer: "Засіб змінення розміру стовпця",
			drag: "Перетягнути",
			expand: "Розгорнути",
			loading: "Завантаження…",
			loadingMore: "Завантаження інших об’єктів...",
			resizeColumn: "Змінити розмір стовпця",
			sortAscending: "Сортувати за зростанням",
			sortDescending: "Сортувати за спаданням",
		},
		"zh-CN": {
			collapse: "折叠",
			columnResizer: "列尺寸调整器",
			drag: "拖动",
			expand: "扩展",
			loading: "正在加载...",
			loadingMore: "正在加载更多...",
			resizeColumn: "调整列大小",
			sortAscending: "升序排序",
			sortDescending: "降序排序",
		},
		"zh-TW": {
			collapse: "收合",
			columnResizer: "欄大小調整器",
			drag: "拖曳",
			expand: "展開",
			loading: "正在載入",
			loadingMore: "正在載入更多…",
			resizeColumn: "調整欄大小",
			sortAscending: "升序排序",
			sortDescending: "降序排序",
		},
	},
	Bp = { ew: "col-resize", w: "w-resize", e: "e-resize" },
	OD = E.createContext(null);
function wse() {
	const t = E.useContext(OD);
	if (t === null) throw new Error("ResizeStateContext not found");
	return t;
}
function Ese(t, e) {
	const n = ce(29),
		{ column: r, showResizer: i } = t,
		{ isEmpty: o, onFocusedResizer: s } = xi(),
		a = E.useContext(OD);
	lse();
	const l = Le(RD),
		{ direction: u } = Vt(),
		[c, d] = E.useState(!1);
	let f, h;
	n[0] === Symbol.for("react.memo_cache_sentinel")
		? ((f = () => {
				const j = (K) => {
						K.pointerType === "mouse" && d(!0);
					},
					V = (K) => {
						K.pointerType === "mouse" && d(!1);
					};
				return (
					document.addEventListener("pointerdown", j, {
						capture: !0,
					}),
					document.addEventListener("pointerup", V, { capture: !0 }),
					() => {
						document.removeEventListener("pointerdown", j, {
							capture: !0,
						}),
							document.removeEventListener("pointerup", V, {
								capture: !0,
							});
					}
				);
			}),
			(h = []),
			(n[0] = f),
			(n[1] = h))
		: ((f = n[0]), (h = n[1])),
		E.useEffect(f, h);
	const p = Ct(e);
	let g;
	n[2] !== l || n[3] !== o || n[4] !== t
		? ((g = xe(t, {
				"aria-label": l.format("columnResizer"),
				isDisabled: o,
			})),
			(n[2] = l),
			(n[3] = o),
			(n[4] = t),
			(n[5] = g))
		: (g = n[5]);
	const { inputProps: v, resizerProps: b } = Lie(g, a, p),
		y = a.getColumnMinWidth(r.key) >= a.getColumnWidth(r.key),
		x = a.getColumnMaxWidth(r.key) <= a.getColumnWidth(r.key),
		C = a.resizingColumn === r.key;
	let k;
	y
		? (k = u === "rtl" ? Bp.w : Bp.e)
		: x
			? (k = u === "rtl" ? Bp.e : Bp.w)
			: (k = Bp.ew);
	const w = i ? void 0 : "none";
	let D;
	n[6] !== b.style || n[7] !== w || n[8] !== k
		? ((D = { ...b.style, height: "100%", display: w, cursor: k }),
			(n[6] = b.style),
			(n[7] = w),
			(n[8] = k),
			(n[9] = D))
		: (D = n[9]);
	const S = D;
	let $;
	n[10] !== s || n[11] !== v
		? (($ = xe(v, { onFocus: s })), (n[10] = s), (n[11] = v), (n[12] = $))
		: ($ = n[12]);
	let A;
	n[13] !== p || n[14] !== $
		? ((A = m.jsx("input", { ref: p, ...$ })),
			(n[13] = p),
			(n[14] = $),
			(n[15] = A))
		: (A = n[15]);
	let T;
	n[16] !== b || n[17] !== S || n[18] !== A
		? ((T = m.jsx(ete, {
				within: !0,
				focusRingClass: "focus-ring",
				children: m.jsx("div", {
					...b,
					role: "presentation",
					style: S,
					className: pse,
					children: A,
				}),
			})),
			(n[16] = b),
			(n[17] = S),
			(n[18] = A),
			(n[19] = T))
		: (T = n[19]);
	let I;
	n[20] === Symbol.for("react.memo_cache_sentinel")
		? ((I = m.jsx("div", {
				"aria-hidden": !0,
				role: "presentation",
				className: mse,
			})),
			(n[20] = I))
		: (I = n[20]);
	const F = C && c;
	let N;
	n[21] !== k
		? ((N = m.jsx("div", {
				style: {
					bottom: 0,
					cursor: k,
					left: 0,
					position: "fixed",
					right: 0,
					top: 0,
				},
			})),
			(n[21] = k),
			(n[22] = N))
		: (N = n[22]);
	let O;
	n[23] !== F || n[24] !== N
		? ((O = m.jsx(Dse, { show: F, children: N })),
			(n[23] = F),
			(n[24] = N),
			(n[25] = O))
		: (O = n[25]);
	let _;
	return (
		n[26] !== T || n[27] !== O
			? ((_ = m.jsxs(m.Fragment, { children: [T, I, O] })),
				(n[26] = T),
				(n[27] = O),
				(n[28] = _))
			: (_ = n[28]),
		_
	);
}
function Dse(t) {
	const e = ce(4),
		{ show: n, children: r } = t,
		{ getContainer: i } = hP();
	let o;
	if (e[0] !== n || e[1] !== i || e[2] !== r) {
		var s;
		(o = n
			? ix.createPortal(
					r,
					(s = i == null ? void 0 : i()) !== null && s !== void 0
						? s
						: document.body,
				)
			: null),
			(e[0] = n),
			(e[1] = i),
			(e[2] = r),
			(e[3] = o);
	} else o = e[3];
	return o;
}
const Sse = le.forwardRef(Ese);
class Ase extends ase {
	constructor() {
		super(...arguments);
		Fe(this, "isLoading", !1);
	}
	buildCollection() {
		let n = this.collection.body.props.loadingState;
		return (
			(this.isLoading = n === "loading" || n === "loadingMore"),
			super.buildCollection()
		);
	}
	buildColumn(n, r, i) {
		let o = super.buildColumn(n, r, i);
		return (o.layoutInfo.allowOverflow = !0), o;
	}
	buildBody() {
		let n = super.buildBody(0),
			{ children: r, layoutInfo: i } = n,
			o = n.layoutInfo.rect.width;
		if (this.isLoading) {
			let s = new St(
					40,
					(r == null ? void 0 : r.length) === 0 ? 40 : i.rect.maxY,
					(o || this.virtualizer.visibleRect.width) - 80,
					(r == null ? void 0 : r.length) === 0
						? this.virtualizer.visibleRect.height - 80
						: 60,
				),
				a = new er("loader", "loader", s);
			(a.parentKey = i.key),
				(a.isSticky = (r == null ? void 0 : r.length) === 0);
			let l = { layoutInfo: a, validRect: a.rect };
			r == null || r.push(l),
				this.layoutNodes.set(a.key, l),
				(i.rect.height = a.rect.maxY),
				(o = Math.max(o, s.width));
		} else if ((r == null ? void 0 : r.length) === 0) {
			let s = new St(
					40,
					40,
					this.virtualizer.visibleRect.width - 80,
					this.virtualizer.visibleRect.height - 80,
				),
				a = new er("empty", "empty", s);
			(a.parentKey = i.key), (a.isSticky = !0);
			let l = { layoutInfo: a, validRect: a.rect };
			r.push(l),
				(i.rect.height = a.rect.maxY),
				(o = Math.max(o, s.width));
		}
		return n;
	}
	buildRow(n, r, i) {
		let o = super.buildRow(n, r, i);
		return (o.layoutInfo.rect.height += 1), o;
	}
	buildCell(n, r, i) {
		var o;
		let s = super.buildCell(n, r, i);
		return (
			(o = n.column) !== null &&
				o !== void 0 &&
				o.props.hideHeader &&
				(s.layoutInfo.allowOverflow = !0),
			s
		);
	}
	getEstimatedRowHeight() {
		return super.getEstimatedRowHeight() + 1;
	}
	isStickyColumn(n) {
		var r, i;
		return (
			((r = n.props) === null || r === void 0
				? void 0
				: r.isDragButtonCell) ||
			((i = n.props) === null || i === void 0
				? void 0
				: i.isSelectionCell)
		);
	}
	getDropTargetFromPoint(n, r, i) {
		var o;
		let s =
			(o = this.virtualizer.layout
				.getVisibleLayoutInfos(new St(n, r, 1, 1))
				.find((a) => a.type === "headerrow")) === null || o === void 0
				? void 0
				: o.rect.height;
		return s && (r -= s), super.getDropTargetFromPoint(n, r, i);
	}
}
const s$ = 36,
	a$ = 36,
	l$ = 36,
	u$ = 20,
	W4 = { compact: 28, regular: 36, spacious: 44 };
function $se(t) {
	var e, n, r, i, o, s;
	let {
			density: a = "regular",
			prominence: l = "default",
			dragAndDropHooks: u,
			onAction: c,
			onResizeEnd: d,
			onResizeStart: f,
			overflowMode: h = "truncate",
		} = t,
		p = !!(u != null && u.useDraggableCollectionState),
		g = !!(u != null && u.useDroppableCollectionState),
		v = E.useRef(p),
		b = E.useRef(g),
		y = mie({
			...t,
			showSelectionCheckboxes: !0,
			showDragButtons: p,
			selectionBehavior: "toggle",
		});
	E.useEffect(() => {
		v.current !== p &&
			console.warn(
				"Drag hooks were provided during one render, but not another. This should be avoided as it may produce unexpected behavior.",
			),
			b.current !== g &&
				console.warn(
					"Drop hooks were provided during one render, but not another. This should be avoided as it may produce unexpected behavior.",
				),
			"expandedKeys" in y &&
				(p || g) &&
				console.warn(
					"Drag and drop is not yet fully supported with expandable rows and may produce unexpected results.",
				);
	}, [p, g, y]);
	let [x, C] = E.useState(!1),
		[, k] = E.useState(!1),
		w = E.useRef(null),
		D = E.useRef(null),
		S = E.useRef(null),
		$ = ht(t),
		A = E.useMemo(
			() =>
				new Ase({
					rowHeight: t.overflowMode === "wrap" ? void 0 : W4[a],
					estimatedRowHeight:
						t.overflowMode === "wrap" ? W4[a] : void 0,
					headingHeight: t.overflowMode === "wrap" ? void 0 : s$,
					estimatedHeadingHeight:
						t.overflowMode === "wrap" ? s$ : void 0,
				}),
			[t.overflowMode, a],
		),
		T,
		I = E.useRef(null);
	u != null &&
		u.useDraggableCollection &&
		u !== null &&
		u !== void 0 &&
		u.useDraggableCollectionState &&
		((T = u.useDraggableCollectionState({
			collection: y.collection,
			selectionManager: y.selectionManager,
			preview: I,
		})),
		u.useDraggableCollection({}, T, w));
	let F = u == null ? void 0 : u.DragPreview,
		N,
		O,
		_ = !1;
	u != null &&
		u.useDroppableCollection &&
		u !== null &&
		u !== void 0 &&
		u.useDroppableCollectionState &&
		((N = u.useDroppableCollectionState({
			collection: y.collection,
			selectionManager: y.selectionManager,
		})),
		(O = u.useDroppableCollection(
			{
				keyboardDelegate: new Xh({
					collection: y.collection,
					disabledKeys: y.selectionManager.disabledKeys,
					ref: w,
					layoutDelegate: A,
				}),
				dropTargetDelegate: A,
			},
			N,
			w,
		)),
		(_ = N.isDropTarget({ type: "root" })));
	let { gridProps: j } = Pie(
			{
				...t,
				isVirtualized: !0,
				layoutDelegate: A,
				onRowAction: c ?? t.onRowAction,
				scrollRef: S,
			},
			y,
			w,
		),
		[V, K] = E.useState(!1),
		[M, G] = E.useState(!1),
		H = E.useCallback(
			(me, De, _e, We) =>
				De.viewType === "rowgroup"
					? m.jsx(
							Fse,
							{
								layoutInfo: De.layoutInfo,
								parent: me == null ? void 0 : me.layoutInfo,
								role: "presentation",
								children: We(_e),
							},
							De.key,
						)
					: De.viewType === "header"
						? m.jsx(
								Bse,
								{
									layoutInfo: De.layoutInfo,
									parent: me == null ? void 0 : me.layoutInfo,
									children: We(_e),
								},
								De.key,
							)
						: De.viewType === "row"
							? m.jsx(
									Rse,
									{
										item: De.content,
										layoutInfo: De.layoutInfo,
										parent:
											me == null ? void 0 : me.layoutInfo,
										children: We(_e),
									},
									De.key,
								)
							: De.viewType === "headerrow"
								? m.jsx(
										Pse,
										{
											onHoverChange: G,
											layoutInfo: De.layoutInfo,
											parent:
												me == null
													? void 0
													: me.layoutInfo,
											item: De.content,
											children: We(_e),
										},
										De.key,
									)
								: m.jsx(
										zse,
										{
											layoutInfo: De.layoutInfo,
											virtualizer: De.virtualizer,
											parent: me,
											children: De.rendered,
										},
										De.key,
									),
			[],
		),
		P = E.useCallback((me, De) => {
			switch (me) {
				case "header":
				case "rowgroup":
				case "section":
				case "row":
				case "headerrow":
					return null;
				case "cell":
					return De.props.isSelectionCell
						? m.jsx(Lse, { cell: De })
						: De.props.isDragButtonCell
							? m.jsx(Ose, { cell: De })
							: m.jsx(jse, { cell: De });
				case "placeholder":
					return m.jsx("div", {
						role: "gridcell",
						"aria-colindex": De.index && De.index + 1,
						"aria-colspan":
							De.colspan && De.colspan > 1 ? De.colspan : void 0,
					});
				case "column":
					return De.props.isSelectionCell
						? m.jsx(Vse, { column: De })
						: De.props.isDragButtonCell
							? m.jsx(Ise, { column: De })
							: De.props.hideHeader
								? m.jsxs(Ze, {
										placement: "top",
										trigger: "focus",
										children: [
											m.jsx(c$, { column: De }),
											m.jsx(Xe, {
												children: De.rendered,
											}),
										],
									})
								: De.props.allowsResizing && De.nextKey
									? m.jsx(Nse, { column: De })
									: m.jsx(c$, { column: De });
				case "loader":
					return m.jsx(Kse, {});
				case "empty":
					return m.jsx(Use, {});
				default:
					return null;
			}
		}, []),
		[q, J] = E.useState(!1),
		[Z, oe] = E.useState(!1),
		ne = E.useRef({ x: 0, y: 0, width: 0, height: 0 }),
		de = E.useCallback((me) => {
			(ne.current.width === me.width &&
				ne.current.height === me.height) ||
				((ne.current = me),
				S.current &&
					(J(S.current.clientWidth + 2 < S.current.offsetWidth),
					oe(S.current.clientHeight + 2 < S.current.offsetHeight)));
		}, []),
		{ isFocusVisible: se, focusProps: re } = ha(),
		he = y.collection.size === 0,
		ye = () => {
			S.current &&
				D.current &&
				(S.current.scrollLeft = D.current.scrollLeft);
		},
		Ae = E.useCallback(
			(me) => {
				k(!0), f == null || f(me);
			},
			[k, f],
		),
		Pe = E.useCallback(
			(me) => {
				C(!1), k(!1), d == null || d(me);
			},
			[d, C, k],
		),
		we = y.selectionManager.focusedKey,
		Ke = null;
	((e = N) === null || e === void 0 || (e = e.target) === null || e === void 0
		? void 0
		: e.type) === "item" &&
		((Ke = N.target.key),
		N.target.dropPosition === "before" &&
			Ke !== y.collection.getFirstKey() &&
			(Ke = y.collection.getKeyBefore(Ke)));
	let rt = E.useMemo(
			() => new Set([we, Ke].filter((me) => me !== null)),
			[we, Ke],
		),
		Ce = xe(
			g
				? (n = O) === null || n === void 0
					? void 0
					: n.collectionProps
				: {},
			j,
			re,
		);
	u != null &&
		(r = u.isVirtualDragging) !== null &&
		r !== void 0 &&
		r.call(u) &&
		delete Ce.tabIndex;
	let Me = { density: a, overflowMode: h, prominence: l };
	return m.jsxs(BM.Provider, {
		value: {
			cosmeticConfig: Me,
			dragAndDropHooks: u,
			dragState: T,
			dropState: N,
			headerMenuOpen: V,
			headerRowHovered: M,
			isEmpty: he,
			isInResizeMode: x,
			isTableDraggable: p,
			isTableDroppable: g,
			layout: A,
			onFocusedResizer: ye,
			onResize: (i = t.onResize) !== null && i !== void 0 ? i : () => {},
			onResizeEnd: Pe,
			onResizeStart: Ae,
			renderEmptyState: t.renderEmptyState,
			setHeaderMenuOpen: K,
			setIsInResizeMode: C,
			state: y,
		},
		children: [
			m.jsx(Tse, {
				...Ce,
				...$,
				...lt({
					...Me,
					scrollbar:
						q && Z
							? "both"
							: q
								? "vertical"
								: Z
									? "horizontal"
									: void 0,
				}),
				className: Se(cse, $.className),
				tableState: y,
				cosmeticConfig: Me,
				layout: A,
				collection: y.collection,
				persistedKeys: rt,
				renderView: P,
				renderWrapper: H,
				onVisibleRectChange: de,
				domRef: w,
				headerRef: D,
				bodyRef: S,
				isFocusVisible: se,
				isVirtualDragging:
					(o =
						u == null ||
						(s = u.isVirtualDragging) === null ||
						s === void 0
							? void 0
							: s.call(u)) !== null && o !== void 0
						? o
						: !1,
				isRootDropTarget: _,
			}),
			F &&
				p &&
				m.jsx(F, {
					ref: I,
					children: () => {
						var me, De, _e, We, Et, ae, fe;
						if (
							u != null &&
							u.renderPreview &&
							(me = T) !== null &&
							me !== void 0 &&
							me.draggingKeys
						)
							return u.renderPreview(
								T.draggingKeys,
								T.draggedKey,
							);
						let U =
								(De =
									(_e = T) === null || _e === void 0
										? void 0
										: _e.draggingKeys.size) !== null &&
								De !== void 0
									? De
									: 0,
							tt =
								S == null ||
								(We = S.current) === null ||
								We === void 0
									? void 0
									: We.getBoundingClientRect().width,
							Dt = W4[a],
							Xt =
								(Et = (ae = y.collection).getTextValue) ===
									null || Et === void 0
									? void 0
									: Et.call(
											ae,
											(fe = T) === null || fe === void 0
												? void 0
												: fe.draggedKey,
										);
						return m.jsx(Cse, {
							itemText: Xt,
							itemCount: U,
							height: Dt,
							maxWidth: tt,
						});
					},
				}),
		],
	});
}
function Tse(t) {
	var e;
	let {
			cosmeticConfig: n,
			tableState: r,
			layout: i,
			collection: o,
			persistedKeys: s,
			renderView: a,
			renderWrapper: l,
			domRef: u,
			bodyRef: c,
			headerRef: d,
			onVisibleRectChange: f,
			isFocusVisible: h,
			isVirtualDragging: p,
			isRootDropTarget: g,
			...v
		} = t,
		{ direction: b } = Vt(),
		y = o.body.props.loadingState,
		x = y === "loading" || y === "loadingMore",
		C = o.body.props.onLoadMore,
		[k, w] = E.useState(0);
	const D = E.useMemo(
			() => ({ text: { truncate: n.overflowMode === "truncate" } }),
			[n.overflowMode],
		),
		S = E.useCallback(
			({
				props: {
					hideHeader: H,
					isSelectionCell: P,
					showDivider: q,
					isDragButtonCell: J,
				},
			}) => {
				if (H) {
					let Z = a$;
					return q ? Z + 1 : Z;
				} else {
					if (P) return l$;
					if (J) return u$;
				}
			},
			[],
		),
		$ = E.useCallback(
			({
				props: {
					hideHeader: H,
					isSelectionCell: P,
					showDivider: q,
					isDragButtonCell: J,
				},
			}) => {
				if (H) {
					let Z = a$;
					return q ? Z + 1 : Z;
				} else {
					if (P) return l$;
					if (J) return u$;
				}
				return 75;
			},
			[],
		);
	let A = iie(
			{ tableWidth: k, getDefaultWidth: S, getDefaultMinWidth: $ },
			r,
		),
		T = DO({
			layout: i,
			collection: o,
			renderView: a,
			onVisibleRectChange(H) {
				c.current &&
					((c.current.scrollTop = H.y), Kie(c.current, b, H.x));
			},
			persistedKeys: s,
			layoutOptions: E.useMemo(
				() => ({ columnWidths: A.columnWidths }),
				[A.columnWidths],
			),
		});
	a9({ isLoading: x, onLoadMore: C, scrollOffset: 1 }, c);
	let I = E.useCallback(
			(H) => {
				T.setVisibleRect(H);
			},
			[T],
		),
		F = E.useCallback(
			(H) => {
				w(H.width), I(H), f(H);
			},
			[I, f],
		);
	E.useEffect(() => {
		gl() === "keyboard" &&
			c.current &&
			u.current &&
			d.current &&
			d.current.contains(document.activeElement) &&
			document.activeElement instanceof HTMLElement &&
			(JE(d.current, document.activeElement),
			ui(document.activeElement, { containingElement: u.current }),
			(c.current.scrollLeft = d.current.scrollLeft));
	}, [T.contentSize, d, c, u]);
	let N =
			((e = i.getLayoutInfo("header")) === null || e === void 0
				? void 0
				: e.rect.height) || 0,
		O = E.useCallback(() => {
			c.current &&
				d.current &&
				(d.current.scrollLeft = c.current.scrollLeft);
		}, [c, d]),
		_ =
			A.resizingColumn != null
				? i.getLayoutInfo(A.resizingColumn).rect.maxX - 2
				: 0,
		j = A.resizingColumn != null ? A.getColumnWidth(A.resizingColumn) : 0,
		V = E.useMemo(
			() => ({ width: j, key: A.resizingColumn }),
			[j, A.resizingColumn],
		);
	p && delete v.tabIndex;
	let K = o.columns[0],
		M = 0;
	(K.props.isSelectionCell || K.props.isDragButtonCell) &&
		(M = A.getColumnWidth(K.key));
	let G = MM(null, T.visibleViews, l);
	return m.jsx(IM.Provider, {
		value: V,
		children: m.jsx(nc, {
			children: m.jsxs("div", {
				...v,
				ref: u,
				children: [
					m.jsx("div", {
						role: "presentation",
						className: dse,
						style: {
							height: N,
							overflow: "hidden",
							position: "relative",
							willChange: T.isScrolling
								? "scroll-position"
								: void 0,
							scrollPaddingInlineStart: M,
						},
						ref: d,
						children: m.jsx(OD.Provider, {
							value: A,
							children: G[0],
						}),
					}),
					m.jsx(Cn, {
						slots: D,
						children: m.jsxs(SO, {
							"data-focus": h ? "visible" : void 0,
							className: hse,
							role: "rowgroup",
							tabIndex: p ? void 0 : -1,
							style: { flex: 1, scrollPaddingInlineStart: M },
							innerStyle: { overflow: "visible" },
							ref: c,
							contentSize: T.contentSize,
							onVisibleRectChange: F,
							onScrollStart: T.startScrolling,
							onScrollEnd: T.endScrolling,
							onScroll: O,
							children: [
								G[1],
								m.jsx("div", {
									className: bse,
									style: {
										[b === "ltr" ? "left" : "right"]:
											`${_}px`,
										height: `${Math.max(T.virtualizer.contentSize.height, T.virtualizer.visibleRect.height)}px`,
										display: A.resizingColumn
											? "block"
											: "none",
									},
								}),
							],
						}),
					}),
				],
			}),
		}),
	});
}
function MM(t, e, n) {
	return e.map((r) =>
		n(t, r, r.children ? Array.from(r.children) : [], (i) => MM(r, i, n)),
	);
}
function MD(t, e) {
	let { direction: n } = Vt(),
		r = yv(t, n, e);
	return r.overflow === "hidden" && (r.overflow = "visible"), r;
}
function Bse({ children: t, layoutInfo: e, parent: n, ...r }) {
	let { rowGroupProps: i } = wO(),
		o = MD(e, n);
	return m.jsx("div", { ...i, ...r, className: fse, style: o, children: t });
}
function Ise(t) {
	let { column: e } = t,
		n = E.useRef(null),
		{ state: r } = xi(),
		{ columnHeaderProps: i } = Bx({ node: e, isVirtualized: !0 }, r, n),
		o = Le(RD);
	return m.jsx(xn, {
		children: m.jsx("div", {
			...i,
			ref: n,
			className: Rx,
			style: { padding: 0, height: "inherit" },
			children: m.jsx(l0, { children: o.format("drag") }),
		}),
	});
}
function Fse({ children: t, layoutInfo: e, parent: n, ...r }) {
	let { rowGroupProps: i } = wO(),
		o = MD(e, n);
	return m.jsx("div", { ...i, ...r, style: o, children: t });
}
function Pse(t) {
	let e = E.useRef(null),
		{ state: n } = xi(),
		{ hoverProps: r } = gn(t),
		{ rowProps: i } = Oie({ node: t.item, isVirtualized: !0 }, n);
	return m.jsx("div", {
		className: NM,
		...xe(i, r),
		ref: e,
		children: t.children,
	});
}
function c$(t) {
	let { column: e } = t,
		n = e.props,
		r = E.useRef(null),
		{ cosmeticConfig: i, isEmpty: o, state: s } = xi(),
		{ columnHeaderProps: a } = Bx({ node: e, isVirtualized: !0 }, s, r),
		{ hoverProps: l, isHovered: u } = gn({
			...t,
			isDisabled: o || !n.allowsSorting,
		}),
		c = E.useMemo(
			() => ({
				text: { color: "inherit", weight: "medium", truncate: !0 },
			}),
			[],
		);
	return m.jsx(xn, {
		children: m.jsxs("div", {
			...xe(a, l),
			...lt(
				{
					align: n.align,
					isHovered: u,
					overflowMode: "truncate",
					prominence: i.prominence,
				},
				{ omitFalsyValues: !0, trimBooleanKeys: !0 },
			),
			className: Rx,
			ref: r,
			children: [
				m.jsx(Cn, {
					slots: c,
					children: n.hideHeader
						? m.jsx(l0, { children: e.rendered })
						: $n(e.rendered)
							? m.jsx(ue, { children: e.rendered })
							: e.rendered,
				}),
				n.allowsSorting && m.jsx(PM, {}),
			],
		}),
	});
}
function Nse(t) {
	var e, n;
	let { column: r } = t,
		i = E.useRef(null),
		o = E.useRef(null),
		s = E.useRef(null),
		{
			state: a,
			onResizeStart: l,
			onResize: u,
			onResizeEnd: c,
			headerRowHovered: d,
			isEmpty: f,
		} = xi(),
		h = wse(),
		{ pressProps: p, isPressed: g } = zi({ isDisabled: f }),
		{ columnHeaderProps: v } = Bx({ node: r, isVirtualized: !0 }, a, i),
		{ hoverProps: b, isHovered: y } = gn({ ...t, isDisabled: f }),
		x = E.useMemo(
			() => ({
				text: { color: "inherit", weight: "medium", truncate: !0 },
			}),
			[],
		),
		C = h.resizingColumn,
		k = !f && ((d && gl() !== "keyboard") || C != null),
		w = "start";
	return (
		r.props.align === "center" || (r.colspan && r.colspan > 1)
			? (w = "center")
			: r.props.align === "end" && (w = "end"),
		m.jsx(xn, {
			children: m.jsxs("div", {
				...lt(
					{
						align: w,
						sortable: r.props.allowsSorting,
						resizable: r.props.allowsResizing,
						interaction: g ? "press" : y ? "hover" : void 0,
						sort:
							((e = a.sortDescriptor) === null || e === void 0
								? void 0
								: e.column) === r.key
								? (n = a.sortDescriptor) === null ||
									n === void 0
									? void 0
									: n.direction
								: void 0,
					},
					{ omitFalsyValues: !0, trimBooleanKeys: !0 },
				),
				...xe(v, p, b),
				ref: i,
				className: Rx,
				children: [
					m.jsx(Cn, {
						slots: x,
						children: r.props.hideHeader
							? m.jsx(l0, { children: r.rendered })
							: $n(r.rendered)
								? m.jsx(ue, { children: r.rendered })
								: r.rendered,
					}),
					r.props.allowsSorting && m.jsx(PM, {}),
					m.jsx(Sse, {
						ref: s,
						column: r,
						showResizer: k,
						onResizeStart: l,
						onResize: u,
						onResizeEnd: c,
						triggerRef: o,
					}),
					m.jsx("div", {
						"aria-hidden": !0,
						"data-visible": C != null,
						"data-resizing": C === r.key,
						className: gse,
					}),
				],
			}),
		})
	);
}
function Rse(t) {
	var e, n, r, i, o, s, a, l, u, c;
	let { item: d, children: f, layoutInfo: h, parent: p, ...g } = t,
		v = E.useRef(null),
		{
			state: b,
			layout: y,
			dragAndDropHooks: x,
			isTableDraggable: C,
			isTableDroppable: k,
			dragState: w,
			dropState: D,
		} = xi(),
		{
			rowProps: S,
			hasAction: $,
			allowsSelection: A,
		} = Rie({ node: d, isVirtualized: !0, shouldSelectOnPressUp: C }, b, v),
		T = b.selectionManager.isSelected(d.key),
		I = b.selectionManager.isDisabled(d.key),
		F = !I && ($ || A || C),
		N = k && !I,
		{ pressProps: O, isPressed: _ } = zi({ isDisabled: !F }),
		{ isFocusVisible: j, focusProps: V } = ha({ within: !0 }),
		{ isFocusVisible: K, focusProps: M } = ha(),
		{ hoverProps: G, isHovered: H } = gn({ isDisabled: !F }),
		P =
			((e = b.collection.rows.find((Ce) => Ce.level === 1)) === null ||
			e === void 0
				? void 0
				: e.key) === d.key,
		q = d.nextKey == null,
		J = !1;
	if (q) {
		var Z, oe;
		((Z = y.getContentSize()) === null || Z === void 0
			? void 0
			: Z.height) >=
			((oe = y.virtualizer) === null || oe === void 0
				? void 0
				: oe.visibleRect.height) && (J = !0);
	}
	let ne = null;
	C &&
		(wt(!!(x != null && x.useDraggableItem)),
		wt(!!w),
		(ne = x.useDraggableItem({ key: d.key, hasDragButton: !0 }, w)),
		I && (ne = null));
	let de = null,
		se = !1,
		re = null,
		he = E.useRef(null);
	if (k) {
		wt(!!(x != null && x.useDroppableItem)),
			wt(!!(x != null && x.useDropIndicator)),
			wt(!!D);
		let Ce = { type: "item", key: d.key, dropPosition: "on" };
		(se = D.isDropTarget(Ce)),
			(de = x.useDroppableItem({ target: Ce }, D, he)),
			(re = x.useDropIndicator({ target: Ce }, D, he));
	}
	let ye = E.useRef(null),
		{ buttonProps: Ae } = Yo(
			{
				...((n = ne) === null || n === void 0
					? void 0
					: n.dragButtonProps),
				elementType: "div",
			},
			ye,
		),
		Pe = MD(h, p),
		we = xe(
			S,
			g,
			{ style: Pe },
			V,
			M,
			G,
			O,
			(r = ne) === null || r === void 0 ? void 0 : r.dragProps,
		);
	x != null &&
		(i = x.isVirtualDragging) !== null &&
		i !== void 0 &&
		i.call(x) &&
		delete we.tabIndex;
	let Ke = N
			? (o = de) === null || o === void 0
				? void 0
				: o.dropProps
			: {
					"aria-hidden":
						(s = de) === null || s === void 0
							? void 0
							: s.dropProps["aria-hidden"],
				},
		{ visuallyHiddenProps: rt } = Ea();
	return m.jsxs(FM.Provider, {
		value: {
			dragButtonProps: Ae,
			dragButtonRef: ye,
			isHovered: H,
			isFocusVisibleWithin: j,
		},
		children: [
			k &&
				P &&
				m.jsx(
					o$,
					{
						rowProps: we,
						visibleRect:
							(a = y.virtualizer) === null || a === void 0
								? void 0
								: a.visibleRect,
						target: {
							key: d.key,
							type: "item",
							dropPosition: "before",
						},
					},
					`${d.key}-before`,
				),
			k &&
				!((l = re) !== null && l !== void 0 && l.isHidden) &&
				m.jsx("div", {
					role: "row",
					...rt,
					children: m.jsx("div", {
						role: "gridcell",
						children: m.jsx("div", {
							role: "button",
							...((u = re) === null || u === void 0
								? void 0
								: u.dropIndicatorProps),
							ref: he,
						}),
					}),
				}),
			m.jsx("div", {
				...xe(we, Ke),
				...lt(
					{
						isDisabled: I,
						isDropTarget: se,
						isFocusVisible: K,
						isFocusVisibleWithin: j,
						isFlushWithContainerBottom: J,
						isFirstRow: P,
						isLastRow: q,
						isHovered: H,
						isPressed: _,
						isSelected: T,
						isNextSelected:
							d.nextKey &&
							b.selectionManager.isSelected(d.nextKey),
					},
					{ omitFalsyValues: !0, trimBooleanKeys: !0 },
				),
				ref: v,
				className: NM,
				children: f,
			}),
			k &&
				m.jsx(
					o$,
					{
						rowProps: we,
						visibleRect:
							(c = y.virtualizer) === null || c === void 0
								? void 0
								: c.visibleRect,
						target: {
							key: d.key,
							type: "item",
							dropPosition: "after",
						},
					},
					`${d.key}-after`,
				),
		],
	});
}
function Ose(t) {
	let { cell: e } = t,
		n = E.useRef(null),
		{ cosmeticConfig: r, state: i, isTableDraggable: o } = xi(),
		s = e.parentKey && i.selectionManager.isDisabled(e.parentKey),
		{ gridCellProps: a } = AD({ node: e, isVirtualized: !0 }, i, n);
	return m.jsx(xn, {
		children: m.jsx("div", {
			...a,
			...lt(
				{ ...r, isDisabled: s },
				{ omitFalsyValues: !0, trimBooleanKeys: !0 },
			),
			ref: n,
			className: Se(Nx, kse),
			children: o && !s && m.jsx(Mse, {}),
		}),
	});
}
function Mse() {
	let {
			dragButtonProps: t,
			dragButtonRef: e,
			isFocusVisibleWithin: n,
			isHovered: r,
		} = use(),
		{ visuallyHiddenProps: i } = Ea();
	return m.jsx(xn, {
		children: m.jsx("div", {
			...t,
			className: X({
				borderRadius: B.size.radius.xsmall,
				display: "flex",
				justifyContent: "center",
				outline: 0,
				padding: 0,
				height: B.size.icon.regular,
				width: 10,
				"&[data-focus=visible]": {
					outline: `${B.size.alias.focusRing} solid ${B.color.alias.focusRing}`,
				},
			}),
			style: !n && !r ? i.style : {},
			ref: e,
			draggable: "true",
			children: m.jsx(ve, { src: PO, color: "neutral" }),
		}),
	});
}
function jse({ cell: t }) {
	var e, n, r, i;
	let { cosmeticConfig: o, state: s } = xi(),
		a = E.useRef(null),
		{ gridCellProps: l } = AD({ node: t, isVirtualized: !0 }, s, a),
		{ id: u, ...c } = l;
	return m.jsx(xn, {
		children: m.jsx("div", {
			...c,
			...lt({
				...o,
				align:
					(e = t.column) === null || e === void 0
						? void 0
						: e.props.align,
				hideHeader:
					(n = t.column) === null || n === void 0
						? void 0
						: n.props.hideHeader,
				showDivider:
					((r = t.column) === null || r === void 0
						? void 0
						: r.props.showDivider) &&
					((i = t.column) === null || i === void 0
						? void 0
						: i.nextKey) !== null,
			}),
			"aria-labelledby": u,
			ref: a,
			className: Nx,
			children:
				typeof t.rendered == "boolean" || t.rendered == null
					? null
					: m.jsx(_se, {
							id: u,
							children: $n(t.rendered)
								? m.jsx(ue, { children: t.rendered })
								: t.rendered,
						}),
		}),
	});
}
function _se(t) {
	const { children: e, ...n } = t,
		r = E.useMemo(() => ({ text: { color: "inherit" } }), []),
		i = E.Children.only(e);
	return m.jsx(Cn, { slots: r, children: E.cloneElement(i, xe(i.props, n)) });
}
function zse(t) {
	let { layoutInfo: e, virtualizer: n, parent: r, children: i } = t,
		{ isTableDroppable: o, dropState: s } = xi(),
		a = !1,
		l = !1;
	if (o) {
		wt(!!s);
		let u = r.content.key;
		u && (a = s.isDropTarget({ type: "item", dropPosition: "on", key: u })),
			(l = s.isDropTarget({ type: "root" }));
	}
	return m.jsx(TD, {
		layoutInfo: e,
		virtualizer: n,
		parent: r == null ? void 0 : r.layoutInfo,
		className: xse,
		"data-droptarget": a || l,
		children: i,
	});
}
function Lse({ cell: t }) {
	let e = E.useRef(null),
		{ cosmeticConfig: n, state: r } = xi(),
		i = r.disabledKeys.has(t.parentKey),
		o = r.selectionManager.isDisabled(t.parentKey),
		{ gridCellProps: s } = AD({ node: t, isVirtualized: !0 }, r, e),
		{ checkboxProps: a } = jie({ key: t.parentKey }, r);
	return m.jsx("div", {
		...lt(
			{ ...n, isDisabled: o },
			{ trimBooleanKeys: !0, omitFalsyValues: !0 },
		),
		className: Se(Nx, OM),
		ref: e,
		...s,
		children: m.jsx(p0, { ...a, isDisabled: i }),
	});
}
function Vse({ column: t }) {
	let e = E.useRef(null),
		{ state: n } = xi(),
		{ columnHeaderProps: r } = Bx({ node: t, isVirtualized: !0 }, n, e),
		{ checkboxProps: i } = _ie(n);
	return m.jsx("div", {
		className: Se(Nx, OM, Rx),
		ref: e,
		...r,
		children:
			n.selectionManager.selectionMode === "single"
				? m.jsx(l0, { children: i["aria-label"] })
				: m.jsx(p0, { ...i }),
	});
}
function Kse() {
	let { state: t } = xi(),
		e = Le(RD);
	return m.jsx(jM, {
		children: m.jsx(Cr, {
			isIndeterminate: !0,
			"aria-label":
				t.collection.size > 0
					? e.format("loadingMore")
					: e.format("loading"),
		}),
	});
}
function Use() {
	let { renderEmptyState: t } = xi(),
		e = t ? t() : null;
	return e == null ? null : m.jsx(jM, { children: e });
}
function jM({ children: t }) {
	let { state: e } = xi(),
		n = {
			"aria-rowindex":
				e.collection.headerRows.length + e.collection.size + 1,
		};
	return m.jsx("div", {
		role: "row",
		...n,
		className: vse,
		children: m.jsx("div", {
			role: "rowheader",
			"aria-colspan": e.collection.columns.length,
			children: t,
		}),
	});
}
const d$ = vie;
function Dr(t) {
	this.content = t;
}
Dr.prototype = {
	constructor: Dr,
	find: function (t) {
		for (var e = 0; e < this.content.length; e += 2)
			if (this.content[e] === t) return e;
		return -1;
	},
	get: function (t) {
		var e = this.find(t);
		return e == -1 ? void 0 : this.content[e + 1];
	},
	update: function (t, e, n) {
		var r = n && n != t ? this.remove(n) : this,
			i = r.find(t),
			o = r.content.slice();
		return (
			i == -1 ? o.push(n || t, e) : ((o[i + 1] = e), n && (o[i] = n)),
			new Dr(o)
		);
	},
	remove: function (t) {
		var e = this.find(t);
		if (e == -1) return this;
		var n = this.content.slice();
		return n.splice(e, 2), new Dr(n);
	},
	addToStart: function (t, e) {
		return new Dr([t, e].concat(this.remove(t).content));
	},
	addToEnd: function (t, e) {
		var n = this.remove(t).content.slice();
		return n.push(t, e), new Dr(n);
	},
	addBefore: function (t, e, n) {
		var r = this.remove(e),
			i = r.content.slice(),
			o = r.find(t);
		return i.splice(o == -1 ? i.length : o, 0, e, n), new Dr(i);
	},
	forEach: function (t) {
		for (var e = 0; e < this.content.length; e += 2)
			t(this.content[e], this.content[e + 1]);
	},
	prepend: function (t) {
		return (
			(t = Dr.from(t)),
			t.size ? new Dr(t.content.concat(this.subtract(t).content)) : this
		);
	},
	append: function (t) {
		return (
			(t = Dr.from(t)),
			t.size ? new Dr(this.subtract(t).content.concat(t.content)) : this
		);
	},
	subtract: function (t) {
		var e = this;
		t = Dr.from(t);
		for (var n = 0; n < t.content.length; n += 2)
			e = e.remove(t.content[n]);
		return e;
	},
	toObject: function () {
		var t = {};
		return (
			this.forEach(function (e, n) {
				t[e] = n;
			}),
			t
		);
	},
	get size() {
		return this.content.length >> 1;
	},
};
Dr.from = function (t) {
	if (t instanceof Dr) return t;
	var e = [];
	if (t) for (var n in t) e.push(n, t[n]);
	return new Dr(e);
};
function _M(t, e, n) {
	for (let r = 0; ; r++) {
		if (r == t.childCount || r == e.childCount)
			return t.childCount == e.childCount ? null : n;
		let i = t.child(r),
			o = e.child(r);
		if (i == o) {
			n += i.nodeSize;
			continue;
		}
		if (!i.sameMarkup(o)) return n;
		if (i.isText && i.text != o.text) {
			for (let s = 0; i.text[s] == o.text[s]; s++) n++;
			return n;
		}
		if (i.content.size || o.content.size) {
			let s = _M(i.content, o.content, n + 1);
			if (s != null) return s;
		}
		n += i.nodeSize;
	}
}
function zM(t, e, n, r) {
	for (let i = t.childCount, o = e.childCount; ; ) {
		if (i == 0 || o == 0) return i == o ? null : { a: n, b: r };
		let s = t.child(--i),
			a = e.child(--o),
			l = s.nodeSize;
		if (s == a) {
			(n -= l), (r -= l);
			continue;
		}
		if (!s.sameMarkup(a)) return { a: n, b: r };
		if (s.isText && s.text != a.text) {
			let u = 0,
				c = Math.min(s.text.length, a.text.length);
			for (
				;
				u < c &&
				s.text[s.text.length - u - 1] == a.text[a.text.length - u - 1];

			)
				u++, n--, r--;
			return { a: n, b: r };
		}
		if (s.content.size || a.content.size) {
			let u = zM(s.content, a.content, n - 1, r - 1);
			if (u) return u;
		}
		(n -= l), (r -= l);
	}
}
class be {
	constructor(e, n) {
		if (((this.content = e), (this.size = n || 0), n == null))
			for (let r = 0; r < e.length; r++) this.size += e[r].nodeSize;
	}
	nodesBetween(e, n, r, i = 0, o) {
		for (let s = 0, a = 0; a < n; s++) {
			let l = this.content[s],
				u = a + l.nodeSize;
			if (u > e && r(l, i + a, o || null, s) !== !1 && l.content.size) {
				let c = a + 1;
				l.nodesBetween(
					Math.max(0, e - c),
					Math.min(l.content.size, n - c),
					r,
					i + c,
				);
			}
			a = u;
		}
	}
	descendants(e) {
		this.nodesBetween(0, this.size, e);
	}
	textBetween(e, n, r, i) {
		let o = "",
			s = !0;
		return (
			this.nodesBetween(
				e,
				n,
				(a, l) => {
					let u = a.isText
						? a.text.slice(Math.max(e, l) - l, n - l)
						: a.isLeaf
							? i
								? typeof i == "function"
									? i(a)
									: i
								: a.type.spec.leafText
									? a.type.spec.leafText(a)
									: ""
							: "";
					a.isBlock &&
						((a.isLeaf && u) || a.isTextblock) &&
						r &&
						(s ? (s = !1) : (o += r)),
						(o += u);
				},
				0,
			),
			o
		);
	}
	append(e) {
		if (!e.size) return this;
		if (!this.size) return e;
		let n = this.lastChild,
			r = e.firstChild,
			i = this.content.slice(),
			o = 0;
		for (
			n.isText &&
			n.sameMarkup(r) &&
			((i[i.length - 1] = n.withText(n.text + r.text)), (o = 1));
			o < e.content.length;
			o++
		)
			i.push(e.content[o]);
		return new be(i, this.size + e.size);
	}
	cut(e, n = this.size) {
		if (e == 0 && n == this.size) return this;
		let r = [],
			i = 0;
		if (n > e)
			for (let o = 0, s = 0; s < n; o++) {
				let a = this.content[o],
					l = s + a.nodeSize;
				l > e &&
					((s < e || l > n) &&
						(a.isText
							? (a = a.cut(
									Math.max(0, e - s),
									Math.min(a.text.length, n - s),
								))
							: (a = a.cut(
									Math.max(0, e - s - 1),
									Math.min(a.content.size, n - s - 1),
								))),
					r.push(a),
					(i += a.nodeSize)),
					(s = l);
			}
		return new be(r, i);
	}
	cutByIndex(e, n) {
		return e == n
			? be.empty
			: e == 0 && n == this.content.length
				? this
				: new be(this.content.slice(e, n));
	}
	replaceChild(e, n) {
		let r = this.content[e];
		if (r == n) return this;
		let i = this.content.slice(),
			o = this.size + n.nodeSize - r.nodeSize;
		return (i[e] = n), new be(i, o);
	}
	addToStart(e) {
		return new be([e].concat(this.content), this.size + e.nodeSize);
	}
	addToEnd(e) {
		return new be(this.content.concat(e), this.size + e.nodeSize);
	}
	eq(e) {
		if (this.content.length != e.content.length) return !1;
		for (let n = 0; n < this.content.length; n++)
			if (!this.content[n].eq(e.content[n])) return !1;
		return !0;
	}
	get firstChild() {
		return this.content.length ? this.content[0] : null;
	}
	get lastChild() {
		return this.content.length
			? this.content[this.content.length - 1]
			: null;
	}
	get childCount() {
		return this.content.length;
	}
	child(e) {
		let n = this.content[e];
		if (!n)
			throw new RangeError("Index " + e + " out of range for " + this);
		return n;
	}
	maybeChild(e) {
		return this.content[e] || null;
	}
	forEach(e) {
		for (let n = 0, r = 0; n < this.content.length; n++) {
			let i = this.content[n];
			e(i, r, n), (r += i.nodeSize);
		}
	}
	findDiffStart(e, n = 0) {
		return _M(this, e, n);
	}
	findDiffEnd(e, n = this.size, r = e.size) {
		return zM(this, e, n, r);
	}
	findIndex(e, n = -1) {
		if (e == 0) return y1(0, e);
		if (e == this.size) return y1(this.content.length, e);
		if (e > this.size || e < 0)
			throw new RangeError(`Position ${e} outside of fragment (${this})`);
		for (let r = 0, i = 0; ; r++) {
			let o = this.child(r),
				s = i + o.nodeSize;
			if (s >= e) return s == e || n > 0 ? y1(r + 1, s) : y1(r, i);
			i = s;
		}
	}
	toString() {
		return "<" + this.toStringInner() + ">";
	}
	toStringInner() {
		return this.content.join(", ");
	}
	toJSON() {
		return this.content.length ? this.content.map((e) => e.toJSON()) : null;
	}
	static fromJSON(e, n) {
		if (!n) return be.empty;
		if (!Array.isArray(n))
			throw new RangeError("Invalid input for Fragment.fromJSON");
		return new be(n.map(e.nodeFromJSON));
	}
	static fromArray(e) {
		if (!e.length) return be.empty;
		let n,
			r = 0;
		for (let i = 0; i < e.length; i++) {
			let o = e[i];
			(r += o.nodeSize),
				i && o.isText && e[i - 1].sameMarkup(o)
					? (n || (n = e.slice(0, i)),
						(n[n.length - 1] = o.withText(
							n[n.length - 1].text + o.text,
						)))
					: n && n.push(o);
		}
		return new be(n || e, r);
	}
	static from(e) {
		if (!e) return be.empty;
		if (e instanceof be) return e;
		if (Array.isArray(e)) return this.fromArray(e);
		if (e.attrs) return new be([e], e.nodeSize);
		throw new RangeError(
			"Can not convert " +
				e +
				" to a Fragment" +
				(e.nodesBetween
					? " (looks like multiple versions of prosemirror-model were loaded)"
					: ""),
		);
	}
}
be.empty = new be([], 0);
const q4 = { index: 0, offset: 0 };
function y1(t, e) {
	return (q4.index = t), (q4.offset = e), q4;
}
function Ev(t, e) {
	if (t === e) return !0;
	if (!(t && typeof t == "object") || !(e && typeof e == "object")) return !1;
	let n = Array.isArray(t);
	if (Array.isArray(e) != n) return !1;
	if (n) {
		if (t.length != e.length) return !1;
		for (let r = 0; r < t.length; r++) if (!Ev(t[r], e[r])) return !1;
	} else {
		for (let r in t) if (!(r in e) || !Ev(t[r], e[r])) return !1;
		for (let r in e) if (!(r in t)) return !1;
	}
	return !0;
}
class zt {
	constructor(e, n) {
		(this.type = e), (this.attrs = n);
	}
	addToSet(e) {
		let n,
			r = !1;
		for (let i = 0; i < e.length; i++) {
			let o = e[i];
			if (this.eq(o)) return e;
			if (this.type.excludes(o.type)) n || (n = e.slice(0, i));
			else {
				if (o.type.excludes(this.type)) return e;
				!r &&
					o.type.rank > this.type.rank &&
					(n || (n = e.slice(0, i)), n.push(this), (r = !0)),
					n && n.push(o);
			}
		}
		return n || (n = e.slice()), r || n.push(this), n;
	}
	removeFromSet(e) {
		for (let n = 0; n < e.length; n++)
			if (this.eq(e[n])) return e.slice(0, n).concat(e.slice(n + 1));
		return e;
	}
	isInSet(e) {
		for (let n = 0; n < e.length; n++) if (this.eq(e[n])) return !0;
		return !1;
	}
	eq(e) {
		return this == e || (this.type == e.type && Ev(this.attrs, e.attrs));
	}
	toJSON() {
		let e = { type: this.type.name };
		for (let n in this.attrs) {
			e.attrs = this.attrs;
			break;
		}
		return e;
	}
	static fromJSON(e, n) {
		if (!n) throw new RangeError("Invalid input for Mark.fromJSON");
		let r = e.marks[n.type];
		if (!r)
			throw new RangeError(
				`There is no mark type ${n.type} in this schema`,
			);
		let i = r.create(n.attrs);
		return r.checkAttrs(i.attrs), i;
	}
	static sameSet(e, n) {
		if (e == n) return !0;
		if (e.length != n.length) return !1;
		for (let r = 0; r < e.length; r++) if (!e[r].eq(n[r])) return !1;
		return !0;
	}
	static setFrom(e) {
		if (!e || (Array.isArray(e) && e.length == 0)) return zt.none;
		if (e instanceof zt) return [e];
		let n = e.slice();
		return n.sort((r, i) => r.type.rank - i.type.rank), n;
	}
}
zt.none = [];
class Dv extends Error {}
class Ee {
	constructor(e, n, r) {
		(this.content = e), (this.openStart = n), (this.openEnd = r);
	}
	get size() {
		return this.content.size - this.openStart - this.openEnd;
	}
	insertAt(e, n) {
		let r = VM(this.content, e + this.openStart, n);
		return r && new Ee(r, this.openStart, this.openEnd);
	}
	removeBetween(e, n) {
		return new Ee(
			LM(this.content, e + this.openStart, n + this.openStart),
			this.openStart,
			this.openEnd,
		);
	}
	eq(e) {
		return (
			this.content.eq(e.content) &&
			this.openStart == e.openStart &&
			this.openEnd == e.openEnd
		);
	}
	toString() {
		return this.content + "(" + this.openStart + "," + this.openEnd + ")";
	}
	toJSON() {
		if (!this.content.size) return null;
		let e = { content: this.content.toJSON() };
		return (
			this.openStart > 0 && (e.openStart = this.openStart),
			this.openEnd > 0 && (e.openEnd = this.openEnd),
			e
		);
	}
	static fromJSON(e, n) {
		if (!n) return Ee.empty;
		let r = n.openStart || 0,
			i = n.openEnd || 0;
		if (typeof r != "number" || typeof i != "number")
			throw new RangeError("Invalid input for Slice.fromJSON");
		return new Ee(be.fromJSON(e, n.content), r, i);
	}
	static maxOpen(e, n = !0) {
		let r = 0,
			i = 0;
		for (
			let o = e.firstChild;
			o && !o.isLeaf && (n || !o.type.spec.isolating);
			o = o.firstChild
		)
			r++;
		for (
			let o = e.lastChild;
			o && !o.isLeaf && (n || !o.type.spec.isolating);
			o = o.lastChild
		)
			i++;
		return new Ee(e, r, i);
	}
}
Ee.empty = new Ee(be.empty, 0, 0);
function LM(t, e, n) {
	let { index: r, offset: i } = t.findIndex(e),
		o = t.maybeChild(r),
		{ index: s, offset: a } = t.findIndex(n);
	if (i == e || o.isText) {
		if (a != n && !t.child(s).isText)
			throw new RangeError("Removing non-flat range");
		return t.cut(0, e).append(t.cut(n));
	}
	if (r != s) throw new RangeError("Removing non-flat range");
	return t.replaceChild(r, o.copy(LM(o.content, e - i - 1, n - i - 1)));
}
function VM(t, e, n, r) {
	let { index: i, offset: o } = t.findIndex(e),
		s = t.maybeChild(i);
	if (o == e || s.isText) return t.cut(0, e).append(n).append(t.cut(e));
	let a = VM(s.content, e - o - 1, n);
	return a && t.replaceChild(i, s.copy(a));
}
function Hse(t, e, n) {
	if (n.openStart > t.depth)
		throw new Dv("Inserted content deeper than insertion position");
	if (t.depth - n.openStart != e.depth - n.openEnd)
		throw new Dv("Inconsistent open depths");
	return KM(t, e, n, 0);
}
function KM(t, e, n, r) {
	let i = t.index(r),
		o = t.node(r);
	if (i == e.index(r) && r < t.depth - n.openStart) {
		let s = KM(t, e, n, r + 1);
		return o.copy(o.content.replaceChild(i, s));
	} else if (n.content.size)
		if (!n.openStart && !n.openEnd && t.depth == r && e.depth == r) {
			let s = t.parent,
				a = s.content;
			return Jc(
				s,
				a
					.cut(0, t.parentOffset)
					.append(n.content)
					.append(a.cut(e.parentOffset)),
			);
		} else {
			let { start: s, end: a } = Wse(n, t);
			return Jc(o, HM(t, s, a, e, r));
		}
	else return Jc(o, Sv(t, e, r));
}
function UM(t, e) {
	if (!e.type.compatibleContent(t.type))
		throw new Dv("Cannot join " + e.type.name + " onto " + t.type.name);
}
function kw(t, e, n) {
	let r = t.node(n);
	return UM(r, e.node(n)), r;
}
function Yc(t, e) {
	let n = e.length - 1;
	n >= 0 && t.isText && t.sameMarkup(e[n])
		? (e[n] = t.withText(e[n].text + t.text))
		: e.push(t);
}
function vm(t, e, n, r) {
	let i = (e || t).node(n),
		o = 0,
		s = e ? e.index(n) : i.childCount;
	t &&
		((o = t.index(n)),
		t.depth > n ? o++ : t.textOffset && (Yc(t.nodeAfter, r), o++));
	for (let a = o; a < s; a++) Yc(i.child(a), r);
	e && e.depth == n && e.textOffset && Yc(e.nodeBefore, r);
}
function Jc(t, e) {
	return t.type.checkContent(e), t.copy(e);
}
function HM(t, e, n, r, i) {
	let o = t.depth > i && kw(t, e, i + 1),
		s = r.depth > i && kw(n, r, i + 1),
		a = [];
	return (
		vm(null, t, i, a),
		o && s && e.index(i) == n.index(i)
			? (UM(o, s), Yc(Jc(o, HM(t, e, n, r, i + 1)), a))
			: (o && Yc(Jc(o, Sv(t, e, i + 1)), a),
				vm(e, n, i, a),
				s && Yc(Jc(s, Sv(n, r, i + 1)), a)),
		vm(r, null, i, a),
		new be(a)
	);
}
function Sv(t, e, n) {
	let r = [];
	if ((vm(null, t, n, r), t.depth > n)) {
		let i = kw(t, e, n + 1);
		Yc(Jc(i, Sv(t, e, n + 1)), r);
	}
	return vm(e, null, n, r), new be(r);
}
function Wse(t, e) {
	let n = e.depth - t.openStart,
		i = e.node(n).copy(t.content);
	for (let o = n - 1; o >= 0; o--) i = e.node(o).copy(be.from(i));
	return {
		start: i.resolveNoCache(t.openStart + n),
		end: i.resolveNoCache(i.content.size - t.openEnd - n),
	};
}
class Jm {
	constructor(e, n, r) {
		(this.pos = e),
			(this.path = n),
			(this.parentOffset = r),
			(this.depth = n.length / 3 - 1);
	}
	resolveDepth(e) {
		return e == null ? this.depth : e < 0 ? this.depth + e : e;
	}
	get parent() {
		return this.node(this.depth);
	}
	get doc() {
		return this.node(0);
	}
	node(e) {
		return this.path[this.resolveDepth(e) * 3];
	}
	index(e) {
		return this.path[this.resolveDepth(e) * 3 + 1];
	}
	indexAfter(e) {
		return (
			(e = this.resolveDepth(e)),
			this.index(e) + (e == this.depth && !this.textOffset ? 0 : 1)
		);
	}
	start(e) {
		return (
			(e = this.resolveDepth(e)), e == 0 ? 0 : this.path[e * 3 - 1] + 1
		);
	}
	end(e) {
		return (
			(e = this.resolveDepth(e)),
			this.start(e) + this.node(e).content.size
		);
	}
	before(e) {
		if (((e = this.resolveDepth(e)), !e))
			throw new RangeError(
				"There is no position before the top-level node",
			);
		return e == this.depth + 1 ? this.pos : this.path[e * 3 - 1];
	}
	after(e) {
		if (((e = this.resolveDepth(e)), !e))
			throw new RangeError(
				"There is no position after the top-level node",
			);
		return e == this.depth + 1
			? this.pos
			: this.path[e * 3 - 1] + this.path[e * 3].nodeSize;
	}
	get textOffset() {
		return this.pos - this.path[this.path.length - 1];
	}
	get nodeAfter() {
		let e = this.parent,
			n = this.index(this.depth);
		if (n == e.childCount) return null;
		let r = this.pos - this.path[this.path.length - 1],
			i = e.child(n);
		return r ? e.child(n).cut(r) : i;
	}
	get nodeBefore() {
		let e = this.index(this.depth),
			n = this.pos - this.path[this.path.length - 1];
		return n
			? this.parent.child(e).cut(0, n)
			: e == 0
				? null
				: this.parent.child(e - 1);
	}
	posAtIndex(e, n) {
		n = this.resolveDepth(n);
		let r = this.path[n * 3],
			i = n == 0 ? 0 : this.path[n * 3 - 1] + 1;
		for (let o = 0; o < e; o++) i += r.child(o).nodeSize;
		return i;
	}
	marks() {
		let e = this.parent,
			n = this.index();
		if (e.content.size == 0) return zt.none;
		if (this.textOffset) return e.child(n).marks;
		let r = e.maybeChild(n - 1),
			i = e.maybeChild(n);
		if (!r) {
			let a = r;
			(r = i), (i = a);
		}
		let o = r.marks;
		for (var s = 0; s < o.length; s++)
			o[s].type.spec.inclusive === !1 &&
				(!i || !o[s].isInSet(i.marks)) &&
				(o = o[s--].removeFromSet(o));
		return o;
	}
	marksAcross(e) {
		let n = this.parent.maybeChild(this.index());
		if (!n || !n.isInline) return null;
		let r = n.marks,
			i = e.parent.maybeChild(e.index());
		for (var o = 0; o < r.length; o++)
			r[o].type.spec.inclusive === !1 &&
				(!i || !r[o].isInSet(i.marks)) &&
				(r = r[o--].removeFromSet(r));
		return r;
	}
	sharedDepth(e) {
		for (let n = this.depth; n > 0; n--)
			if (this.start(n) <= e && this.end(n) >= e) return n;
		return 0;
	}
	blockRange(e = this, n) {
		if (e.pos < this.pos) return e.blockRange(this);
		for (
			let r =
				this.depth -
				(this.parent.inlineContent || this.pos == e.pos ? 1 : 0);
			r >= 0;
			r--
		)
			if (e.pos <= this.end(r) && (!n || n(this.node(r))))
				return new Av(this, e, r);
		return null;
	}
	sameParent(e) {
		return this.pos - this.parentOffset == e.pos - e.parentOffset;
	}
	max(e) {
		return e.pos > this.pos ? e : this;
	}
	min(e) {
		return e.pos < this.pos ? e : this;
	}
	toString() {
		let e = "";
		for (let n = 1; n <= this.depth; n++)
			e +=
				(e ? "/" : "") +
				this.node(n).type.name +
				"_" +
				this.index(n - 1);
		return e + ":" + this.parentOffset;
	}
	static resolve(e, n) {
		if (!(n >= 0 && n <= e.content.size))
			throw new RangeError("Position " + n + " out of range");
		let r = [],
			i = 0,
			o = n;
		for (let s = e; ; ) {
			let { index: a, offset: l } = s.content.findIndex(o),
				u = o - l;
			if ((r.push(s, a, i + l), !u || ((s = s.child(a)), s.isText)))
				break;
			(o = u - 1), (i += l + 1);
		}
		return new Jm(n, r, o);
	}
	static resolveCached(e, n) {
		let r = f$.get(e);
		if (r)
			for (let o = 0; o < r.elts.length; o++) {
				let s = r.elts[o];
				if (s.pos == n) return s;
			}
		else f$.set(e, (r = new qse()));
		let i = (r.elts[r.i] = Jm.resolve(e, n));
		return (r.i = (r.i + 1) % Gse), i;
	}
}
class qse {
	constructor() {
		(this.elts = []), (this.i = 0);
	}
}
const Gse = 12,
	f$ = new WeakMap();
class Av {
	constructor(e, n, r) {
		(this.$from = e), (this.$to = n), (this.depth = r);
	}
	get start() {
		return this.$from.before(this.depth + 1);
	}
	get end() {
		return this.$to.after(this.depth + 1);
	}
	get parent() {
		return this.$from.node(this.depth);
	}
	get startIndex() {
		return this.$from.index(this.depth);
	}
	get endIndex() {
		return this.$to.indexAfter(this.depth);
	}
}
const Yse = Object.create(null);
let ia = class Cw {
	constructor(e, n, r, i = zt.none) {
		(this.type = e),
			(this.attrs = n),
			(this.marks = i),
			(this.content = r || be.empty);
	}
	get nodeSize() {
		return this.isLeaf ? 1 : 2 + this.content.size;
	}
	get childCount() {
		return this.content.childCount;
	}
	child(e) {
		return this.content.child(e);
	}
	maybeChild(e) {
		return this.content.maybeChild(e);
	}
	forEach(e) {
		this.content.forEach(e);
	}
	nodesBetween(e, n, r, i = 0) {
		this.content.nodesBetween(e, n, r, i, this);
	}
	descendants(e) {
		this.nodesBetween(0, this.content.size, e);
	}
	get textContent() {
		return this.isLeaf && this.type.spec.leafText
			? this.type.spec.leafText(this)
			: this.textBetween(0, this.content.size, "");
	}
	textBetween(e, n, r, i) {
		return this.content.textBetween(e, n, r, i);
	}
	get firstChild() {
		return this.content.firstChild;
	}
	get lastChild() {
		return this.content.lastChild;
	}
	eq(e) {
		return this == e || (this.sameMarkup(e) && this.content.eq(e.content));
	}
	sameMarkup(e) {
		return this.hasMarkup(e.type, e.attrs, e.marks);
	}
	hasMarkup(e, n, r) {
		return (
			this.type == e &&
			Ev(this.attrs, n || e.defaultAttrs || Yse) &&
			zt.sameSet(this.marks, r || zt.none)
		);
	}
	copy(e = null) {
		return e == this.content
			? this
			: new Cw(this.type, this.attrs, e, this.marks);
	}
	mark(e) {
		return e == this.marks
			? this
			: new Cw(this.type, this.attrs, this.content, e);
	}
	cut(e, n = this.content.size) {
		return e == 0 && n == this.content.size
			? this
			: this.copy(this.content.cut(e, n));
	}
	slice(e, n = this.content.size, r = !1) {
		if (e == n) return Ee.empty;
		let i = this.resolve(e),
			o = this.resolve(n),
			s = r ? 0 : i.sharedDepth(n),
			a = i.start(s),
			u = i.node(s).content.cut(i.pos - a, o.pos - a);
		return new Ee(u, i.depth - s, o.depth - s);
	}
	replace(e, n, r) {
		return Hse(this.resolve(e), this.resolve(n), r);
	}
	nodeAt(e) {
		for (let n = this; ; ) {
			let { index: r, offset: i } = n.content.findIndex(e);
			if (((n = n.maybeChild(r)), !n)) return null;
			if (i == e || n.isText) return n;
			e -= i + 1;
		}
	}
	childAfter(e) {
		let { index: n, offset: r } = this.content.findIndex(e);
		return { node: this.content.maybeChild(n), index: n, offset: r };
	}
	childBefore(e) {
		if (e == 0) return { node: null, index: 0, offset: 0 };
		let { index: n, offset: r } = this.content.findIndex(e);
		if (r < e) return { node: this.content.child(n), index: n, offset: r };
		let i = this.content.child(n - 1);
		return { node: i, index: n - 1, offset: r - i.nodeSize };
	}
	resolve(e) {
		return Jm.resolveCached(this, e);
	}
	resolveNoCache(e) {
		return Jm.resolve(this, e);
	}
	rangeHasMark(e, n, r) {
		let i = !1;
		return (
			n > e &&
				this.nodesBetween(
					e,
					n,
					(o) => (r.isInSet(o.marks) && (i = !0), !i),
				),
			i
		);
	}
	get isBlock() {
		return this.type.isBlock;
	}
	get isTextblock() {
		return this.type.isTextblock;
	}
	get inlineContent() {
		return this.type.inlineContent;
	}
	get isInline() {
		return this.type.isInline;
	}
	get isText() {
		return this.type.isText;
	}
	get isLeaf() {
		return this.type.isLeaf;
	}
	get isAtom() {
		return this.type.isAtom;
	}
	toString() {
		if (this.type.spec.toDebugString)
			return this.type.spec.toDebugString(this);
		let e = this.type.name;
		return (
			this.content.size &&
				(e += "(" + this.content.toStringInner() + ")"),
			WM(this.marks, e)
		);
	}
	contentMatchAt(e) {
		let n = this.type.contentMatch.matchFragment(this.content, 0, e);
		if (!n)
			throw new Error(
				"Called contentMatchAt on a node with invalid content",
			);
		return n;
	}
	canReplace(e, n, r = be.empty, i = 0, o = r.childCount) {
		let s = this.contentMatchAt(e).matchFragment(r, i, o),
			a = s && s.matchFragment(this.content, n);
		if (!a || !a.validEnd) return !1;
		for (let l = i; l < o; l++)
			if (!this.type.allowsMarks(r.child(l).marks)) return !1;
		return !0;
	}
	canReplaceWith(e, n, r, i) {
		if (i && !this.type.allowsMarks(i)) return !1;
		let o = this.contentMatchAt(e).matchType(r),
			s = o && o.matchFragment(this.content, n);
		return s ? s.validEnd : !1;
	}
	canAppend(e) {
		return e.content.size
			? this.canReplace(this.childCount, this.childCount, e.content)
			: this.type.compatibleContent(e.type);
	}
	check() {
		this.type.checkContent(this.content), this.type.checkAttrs(this.attrs);
		let e = zt.none;
		for (let n = 0; n < this.marks.length; n++) {
			let r = this.marks[n];
			r.type.checkAttrs(r.attrs), (e = r.addToSet(e));
		}
		if (!zt.sameSet(e, this.marks))
			throw new RangeError(
				`Invalid collection of marks for node ${this.type.name}: ${this.marks.map((n) => n.type.name)}`,
			);
		this.content.forEach((n) => n.check());
	}
	toJSON() {
		let e = { type: this.type.name };
		for (let n in this.attrs) {
			e.attrs = this.attrs;
			break;
		}
		return (
			this.content.size && (e.content = this.content.toJSON()),
			this.marks.length && (e.marks = this.marks.map((n) => n.toJSON())),
			e
		);
	}
	static fromJSON(e, n) {
		if (!n) throw new RangeError("Invalid input for Node.fromJSON");
		let r;
		if (n.marks) {
			if (!Array.isArray(n.marks))
				throw new RangeError("Invalid mark data for Node.fromJSON");
			r = n.marks.map(e.markFromJSON);
		}
		if (n.type == "text") {
			if (typeof n.text != "string")
				throw new RangeError("Invalid text node in JSON");
			return e.text(n.text, r);
		}
		let i = be.fromJSON(e, n.content),
			o = e.nodeType(n.type).create(n.attrs, i, r);
		return o.type.checkAttrs(o.attrs), o;
	}
};
ia.prototype.text = void 0;
class $v extends ia {
	constructor(e, n, r, i) {
		if ((super(e, n, null, i), !r))
			throw new RangeError("Empty text nodes are not allowed");
		this.text = r;
	}
	toString() {
		return this.type.spec.toDebugString
			? this.type.spec.toDebugString(this)
			: WM(this.marks, JSON.stringify(this.text));
	}
	get textContent() {
		return this.text;
	}
	textBetween(e, n) {
		return this.text.slice(e, n);
	}
	get nodeSize() {
		return this.text.length;
	}
	mark(e) {
		return e == this.marks
			? this
			: new $v(this.type, this.attrs, this.text, e);
	}
	withText(e) {
		return e == this.text
			? this
			: new $v(this.type, this.attrs, e, this.marks);
	}
	cut(e = 0, n = this.text.length) {
		return e == 0 && n == this.text.length
			? this
			: this.withText(this.text.slice(e, n));
	}
	eq(e) {
		return this.sameMarkup(e) && this.text == e.text;
	}
	toJSON() {
		let e = super.toJSON();
		return (e.text = this.text), e;
	}
}
function WM(t, e) {
	for (let n = t.length - 1; n >= 0; n--) e = t[n].type.name + "(" + e + ")";
	return e;
}
class vd {
	constructor(e) {
		(this.validEnd = e), (this.next = []), (this.wrapCache = []);
	}
	static parse(e, n) {
		let r = new Jse(e, n);
		if (r.next == null) return vd.empty;
		let i = qM(r);
		r.next && r.err("Unexpected trailing text");
		let o = rae(nae(i));
		return iae(o, r), o;
	}
	matchType(e) {
		for (let n = 0; n < this.next.length; n++)
			if (this.next[n].type == e) return this.next[n].next;
		return null;
	}
	matchFragment(e, n = 0, r = e.childCount) {
		let i = this;
		for (let o = n; i && o < r; o++) i = i.matchType(e.child(o).type);
		return i;
	}
	get inlineContent() {
		return this.next.length != 0 && this.next[0].type.isInline;
	}
	get defaultType() {
		for (let e = 0; e < this.next.length; e++) {
			let { type: n } = this.next[e];
			if (!(n.isText || n.hasRequiredAttrs())) return n;
		}
		return null;
	}
	compatible(e) {
		for (let n = 0; n < this.next.length; n++)
			for (let r = 0; r < e.next.length; r++)
				if (this.next[n].type == e.next[r].type) return !0;
		return !1;
	}
	fillBefore(e, n = !1, r = 0) {
		let i = [this];
		function o(s, a) {
			let l = s.matchFragment(e, r);
			if (l && (!n || l.validEnd))
				return be.from(a.map((u) => u.createAndFill()));
			for (let u = 0; u < s.next.length; u++) {
				let { type: c, next: d } = s.next[u];
				if (!(c.isText || c.hasRequiredAttrs()) && i.indexOf(d) == -1) {
					i.push(d);
					let f = o(d, a.concat(c));
					if (f) return f;
				}
			}
			return null;
		}
		return o(this, []);
	}
	findWrapping(e) {
		for (let r = 0; r < this.wrapCache.length; r += 2)
			if (this.wrapCache[r] == e) return this.wrapCache[r + 1];
		let n = this.computeWrapping(e);
		return this.wrapCache.push(e, n), n;
	}
	computeWrapping(e) {
		let n = Object.create(null),
			r = [{ match: this, type: null, via: null }];
		for (; r.length; ) {
			let i = r.shift(),
				o = i.match;
			if (o.matchType(e)) {
				let s = [];
				for (let a = i; a.type; a = a.via) s.push(a.type);
				return s.reverse();
			}
			for (let s = 0; s < o.next.length; s++) {
				let { type: a, next: l } = o.next[s];
				!a.isLeaf &&
					!a.hasRequiredAttrs() &&
					!(a.name in n) &&
					(!i.type || l.validEnd) &&
					(r.push({ match: a.contentMatch, type: a, via: i }),
					(n[a.name] = !0));
			}
		}
		return null;
	}
	get edgeCount() {
		return this.next.length;
	}
	edge(e) {
		if (e >= this.next.length)
			throw new RangeError(
				`There's no ${e}th edge in this content match`,
			);
		return this.next[e];
	}
	toString() {
		let e = [];
		function n(r) {
			e.push(r);
			for (let i = 0; i < r.next.length; i++)
				e.indexOf(r.next[i].next) == -1 && n(r.next[i].next);
		}
		return (
			n(this),
			e.map((r, i) => {
				let o = i + (r.validEnd ? "*" : " ") + " ";
				for (let s = 0; s < r.next.length; s++)
					o +=
						(s ? ", " : "") +
						r.next[s].type.name +
						"->" +
						e.indexOf(r.next[s].next);
				return o;
			}).join(`
`)
		);
	}
}
vd.empty = new vd(!0);
class Jse {
	constructor(e, n) {
		(this.string = e),
			(this.nodeTypes = n),
			(this.inline = null),
			(this.pos = 0),
			(this.tokens = e.split(/\s*(?=\b|\W|$)/)),
			this.tokens[this.tokens.length - 1] == "" && this.tokens.pop(),
			this.tokens[0] == "" && this.tokens.shift();
	}
	get next() {
		return this.tokens[this.pos];
	}
	eat(e) {
		return this.next == e && (this.pos++ || !0);
	}
	err(e) {
		throw new SyntaxError(
			e + " (in content expression '" + this.string + "')",
		);
	}
}
function qM(t) {
	let e = [];
	do e.push(Xse(t));
	while (t.eat("|"));
	return e.length == 1 ? e[0] : { type: "choice", exprs: e };
}
function Xse(t) {
	let e = [];
	do e.push(Zse(t));
	while (t.next && t.next != ")" && t.next != "|");
	return e.length == 1 ? e[0] : { type: "seq", exprs: e };
}
function Zse(t) {
	let e = tae(t);
	for (;;)
		if (t.eat("+")) e = { type: "plus", expr: e };
		else if (t.eat("*")) e = { type: "star", expr: e };
		else if (t.eat("?")) e = { type: "opt", expr: e };
		else if (t.eat("{")) e = Qse(t, e);
		else break;
	return e;
}
function h$(t) {
	/\D/.test(t.next) && t.err("Expected number, got '" + t.next + "'");
	let e = Number(t.next);
	return t.pos++, e;
}
function Qse(t, e) {
	let n = h$(t),
		r = n;
	return (
		t.eat(",") && (t.next != "}" ? (r = h$(t)) : (r = -1)),
		t.eat("}") || t.err("Unclosed braced range"),
		{ type: "range", min: n, max: r, expr: e }
	);
}
function eae(t, e) {
	let n = t.nodeTypes,
		r = n[e];
	if (r) return [r];
	let i = [];
	for (let o in n) {
		let s = n[o];
		s.groups.indexOf(e) > -1 && i.push(s);
	}
	return i.length == 0 && t.err("No node type or group '" + e + "' found"), i;
}
function tae(t) {
	if (t.eat("(")) {
		let e = qM(t);
		return t.eat(")") || t.err("Missing closing paren"), e;
	} else if (/\W/.test(t.next)) t.err("Unexpected token '" + t.next + "'");
	else {
		let e = eae(t, t.next).map(
			(n) => (
				t.inline == null
					? (t.inline = n.isInline)
					: t.inline != n.isInline &&
						t.err("Mixing inline and block content"),
				{ type: "name", value: n }
			),
		);
		return t.pos++, e.length == 1 ? e[0] : { type: "choice", exprs: e };
	}
}
function nae(t) {
	let e = [[]];
	return i(o(t, 0), n()), e;
	function n() {
		return e.push([]) - 1;
	}
	function r(s, a, l) {
		let u = { term: l, to: a };
		return e[s].push(u), u;
	}
	function i(s, a) {
		s.forEach((l) => (l.to = a));
	}
	function o(s, a) {
		if (s.type == "choice")
			return s.exprs.reduce((l, u) => l.concat(o(u, a)), []);
		if (s.type == "seq")
			for (let l = 0; ; l++) {
				let u = o(s.exprs[l], a);
				if (l == s.exprs.length - 1) return u;
				i(u, (a = n()));
			}
		else if (s.type == "star") {
			let l = n();
			return r(a, l), i(o(s.expr, l), l), [r(l)];
		} else if (s.type == "plus") {
			let l = n();
			return i(o(s.expr, a), l), i(o(s.expr, l), l), [r(l)];
		} else {
			if (s.type == "opt") return [r(a)].concat(o(s.expr, a));
			if (s.type == "range") {
				let l = a;
				for (let u = 0; u < s.min; u++) {
					let c = n();
					i(o(s.expr, l), c), (l = c);
				}
				if (s.max == -1) i(o(s.expr, l), l);
				else
					for (let u = s.min; u < s.max; u++) {
						let c = n();
						r(l, c), i(o(s.expr, l), c), (l = c);
					}
				return [r(l)];
			} else {
				if (s.type == "name") return [r(a, void 0, s.value)];
				throw new Error("Unknown expr type");
			}
		}
	}
}
function GM(t, e) {
	return e - t;
}
function p$(t, e) {
	let n = [];
	return r(e), n.sort(GM);
	function r(i) {
		let o = t[i];
		if (o.length == 1 && !o[0].term) return r(o[0].to);
		n.push(i);
		for (let s = 0; s < o.length; s++) {
			let { term: a, to: l } = o[s];
			!a && n.indexOf(l) == -1 && r(l);
		}
	}
}
function rae(t) {
	let e = Object.create(null);
	return n(p$(t, 0));
	function n(r) {
		let i = [];
		r.forEach((s) => {
			t[s].forEach(({ term: a, to: l }) => {
				if (!a) return;
				let u;
				for (let c = 0; c < i.length; c++)
					i[c][0] == a && (u = i[c][1]);
				p$(t, l).forEach((c) => {
					u || i.push([a, (u = [])]), u.indexOf(c) == -1 && u.push(c);
				});
			});
		});
		let o = (e[r.join(",")] = new vd(r.indexOf(t.length - 1) > -1));
		for (let s = 0; s < i.length; s++) {
			let a = i[s][1].sort(GM);
			o.next.push({ type: i[s][0], next: e[a.join(",")] || n(a) });
		}
		return o;
	}
}
function iae(t, e) {
	for (let n = 0, r = [t]; n < r.length; n++) {
		let i = r[n],
			o = !i.validEnd,
			s = [];
		for (let a = 0; a < i.next.length; a++) {
			let { type: l, next: u } = i.next[a];
			s.push(l.name),
				o && !(l.isText || l.hasRequiredAttrs()) && (o = !1),
				r.indexOf(u) == -1 && r.push(u);
		}
		o &&
			e.err(
				"Only non-generatable nodes (" +
					s.join(", ") +
					") in a required position (see https://prosemirror.net/docs/guide/#generatable)",
			);
	}
}
function YM(t) {
	let e = Object.create(null);
	for (let n in t) {
		let r = t[n];
		if (!r.hasDefault) return null;
		e[n] = r.default;
	}
	return e;
}
function JM(t, e) {
	let n = Object.create(null);
	for (let r in t) {
		let i = e && e[r];
		if (i === void 0) {
			let o = t[r];
			if (o.hasDefault) i = o.default;
			else throw new RangeError("No value supplied for attribute " + r);
		}
		n[r] = i;
	}
	return n;
}
function XM(t, e, n, r) {
	for (let i in e)
		if (!(i in t))
			throw new RangeError(
				`Unsupported attribute ${i} for ${n} of type ${i}`,
			);
	for (let i in t) {
		let o = t[i];
		o.validate && o.validate(e[i]);
	}
}
function ZM(t, e) {
	let n = Object.create(null);
	if (e) for (let r in e) n[r] = new sae(t, r, e[r]);
	return n;
}
let m$ = class QM {
	constructor(e, n, r) {
		(this.name = e),
			(this.schema = n),
			(this.spec = r),
			(this.markSet = null),
			(this.groups = r.group ? r.group.split(" ") : []),
			(this.attrs = ZM(e, r.attrs)),
			(this.defaultAttrs = YM(this.attrs)),
			(this.contentMatch = null),
			(this.inlineContent = null),
			(this.isBlock = !(r.inline || e == "text")),
			(this.isText = e == "text");
	}
	get isInline() {
		return !this.isBlock;
	}
	get isTextblock() {
		return this.isBlock && this.inlineContent;
	}
	get isLeaf() {
		return this.contentMatch == vd.empty;
	}
	get isAtom() {
		return this.isLeaf || !!this.spec.atom;
	}
	get whitespace() {
		return this.spec.whitespace || (this.spec.code ? "pre" : "normal");
	}
	hasRequiredAttrs() {
		for (let e in this.attrs) if (this.attrs[e].isRequired) return !0;
		return !1;
	}
	compatibleContent(e) {
		return this == e || this.contentMatch.compatible(e.contentMatch);
	}
	computeAttrs(e) {
		return !e && this.defaultAttrs ? this.defaultAttrs : JM(this.attrs, e);
	}
	create(e = null, n, r) {
		if (this.isText)
			throw new Error("NodeType.create can't construct text nodes");
		return new ia(this, this.computeAttrs(e), be.from(n), zt.setFrom(r));
	}
	createChecked(e = null, n, r) {
		return (
			(n = be.from(n)),
			this.checkContent(n),
			new ia(this, this.computeAttrs(e), n, zt.setFrom(r))
		);
	}
	createAndFill(e = null, n, r) {
		if (((e = this.computeAttrs(e)), (n = be.from(n)), n.size)) {
			let s = this.contentMatch.fillBefore(n);
			if (!s) return null;
			n = s.append(n);
		}
		let i = this.contentMatch.matchFragment(n),
			o = i && i.fillBefore(be.empty, !0);
		return o ? new ia(this, e, n.append(o), zt.setFrom(r)) : null;
	}
	validContent(e) {
		let n = this.contentMatch.matchFragment(e);
		if (!n || !n.validEnd) return !1;
		for (let r = 0; r < e.childCount; r++)
			if (!this.allowsMarks(e.child(r).marks)) return !1;
		return !0;
	}
	checkContent(e) {
		if (!this.validContent(e))
			throw new RangeError(
				`Invalid content for node ${this.name}: ${e.toString().slice(0, 50)}`,
			);
	}
	checkAttrs(e) {
		XM(this.attrs, e, "node", this.name);
	}
	allowsMarkType(e) {
		return this.markSet == null || this.markSet.indexOf(e) > -1;
	}
	allowsMarks(e) {
		if (this.markSet == null) return !0;
		for (let n = 0; n < e.length; n++)
			if (!this.allowsMarkType(e[n].type)) return !1;
		return !0;
	}
	allowedMarks(e) {
		if (this.markSet == null) return e;
		let n;
		for (let r = 0; r < e.length; r++)
			this.allowsMarkType(e[r].type)
				? n && n.push(e[r])
				: n || (n = e.slice(0, r));
		return n ? (n.length ? n : zt.none) : e;
	}
	static compile(e, n) {
		let r = Object.create(null);
		e.forEach((o, s) => (r[o] = new QM(o, n, s)));
		let i = n.spec.topNode || "doc";
		if (!r[i])
			throw new RangeError(
				"Schema is missing its top node type ('" + i + "')",
			);
		if (!r.text) throw new RangeError("Every schema needs a 'text' type");
		for (let o in r.text.attrs)
			throw new RangeError(
				"The text node type should not have attributes",
			);
		return r;
	}
};
function oae(t, e, n) {
	let r = n.split("|");
	return (i) => {
		let o = i === null ? "null" : typeof i;
		if (r.indexOf(o) < 0)
			throw new RangeError(
				`Expected value of type ${r} for attribute ${e} on type ${t}, got ${o}`,
			);
	};
}
class sae {
	constructor(e, n, r) {
		(this.hasDefault = Object.prototype.hasOwnProperty.call(r, "default")),
			(this.default = r.default),
			(this.validate =
				typeof r.validate == "string"
					? oae(e, n, r.validate)
					: r.validate);
	}
	get isRequired() {
		return !this.hasDefault;
	}
}
class Zh {
	constructor(e, n, r, i) {
		(this.name = e),
			(this.rank = n),
			(this.schema = r),
			(this.spec = i),
			(this.attrs = ZM(e, i.attrs)),
			(this.excluded = null);
		let o = YM(this.attrs);
		this.instance = o ? new zt(this, o) : null;
	}
	create(e = null) {
		return !e && this.instance
			? this.instance
			: new zt(this, JM(this.attrs, e));
	}
	static compile(e, n) {
		let r = Object.create(null),
			i = 0;
		return e.forEach((o, s) => (r[o] = new Zh(o, i++, n, s))), r;
	}
	removeFromSet(e) {
		for (var n = 0; n < e.length; n++)
			e[n].type == this &&
				((e = e.slice(0, n).concat(e.slice(n + 1))), n--);
		return e;
	}
	isInSet(e) {
		for (let n = 0; n < e.length; n++) if (e[n].type == this) return e[n];
	}
	checkAttrs(e) {
		XM(this.attrs, e, "mark", this.name);
	}
	excludes(e) {
		return this.excluded.indexOf(e) > -1;
	}
}
class aae {
	constructor(e) {
		(this.linebreakReplacement = null), (this.cached = Object.create(null));
		let n = (this.spec = {});
		for (let i in e) n[i] = e[i];
		(n.nodes = Dr.from(e.nodes)),
			(n.marks = Dr.from(e.marks || {})),
			(this.nodes = m$.compile(this.spec.nodes, this)),
			(this.marks = Zh.compile(this.spec.marks, this));
		let r = Object.create(null);
		for (let i in this.nodes) {
			if (i in this.marks)
				throw new RangeError(i + " can not be both a node and a mark");
			let o = this.nodes[i],
				s = o.spec.content || "",
				a = o.spec.marks;
			if (
				((o.contentMatch = r[s] || (r[s] = vd.parse(s, this.nodes))),
				(o.inlineContent = o.contentMatch.inlineContent),
				o.spec.linebreakReplacement)
			) {
				if (this.linebreakReplacement)
					throw new RangeError("Multiple linebreak nodes defined");
				if (!o.isInline || !o.isLeaf)
					throw new RangeError(
						"Linebreak replacement nodes must be inline leaf nodes",
					);
				this.linebreakReplacement = o;
			}
			o.markSet =
				a == "_"
					? null
					: a
						? g$(this, a.split(" "))
						: a == "" || !o.inlineContent
							? []
							: null;
		}
		for (let i in this.marks) {
			let o = this.marks[i],
				s = o.spec.excludes;
			o.excluded =
				s == null ? [o] : s == "" ? [] : g$(this, s.split(" "));
		}
		(this.nodeFromJSON = this.nodeFromJSON.bind(this)),
			(this.markFromJSON = this.markFromJSON.bind(this)),
			(this.topNodeType = this.nodes[this.spec.topNode || "doc"]),
			(this.cached.wrappings = Object.create(null));
	}
	node(e, n = null, r, i) {
		if (typeof e == "string") e = this.nodeType(e);
		else if (e instanceof m$) {
			if (e.schema != this)
				throw new RangeError(
					"Node type from different schema used (" + e.name + ")",
				);
		} else throw new RangeError("Invalid node type: " + e);
		return e.createChecked(n, r, i);
	}
	text(e, n) {
		let r = this.nodes.text;
		return new $v(r, r.defaultAttrs, e, zt.setFrom(n));
	}
	mark(e, n) {
		return typeof e == "string" && (e = this.marks[e]), e.create(n);
	}
	nodeFromJSON(e) {
		return ia.fromJSON(this, e);
	}
	markFromJSON(e) {
		return zt.fromJSON(this, e);
	}
	nodeType(e) {
		let n = this.nodes[e];
		if (!n) throw new RangeError("Unknown node type: " + e);
		return n;
	}
}
function g$(t, e) {
	let n = [];
	for (let r = 0; r < e.length; r++) {
		let i = e[r],
			o = t.marks[i],
			s = o;
		if (o) n.push(o);
		else
			for (let a in t.marks) {
				let l = t.marks[a];
				(i == "_" ||
					(l.spec.group &&
						l.spec.group.split(" ").indexOf(i) > -1)) &&
					n.push((s = l));
			}
		if (!s) throw new SyntaxError("Unknown mark type: '" + e[r] + "'");
	}
	return n;
}
function lae(t) {
	return t.tag != null;
}
function uae(t) {
	return t.style != null;
}
let jD = class ww {
	constructor(e, n) {
		(this.schema = e),
			(this.rules = n),
			(this.tags = []),
			(this.styles = []);
		let r = (this.matchedStyles = []);
		n.forEach((i) => {
			if (lae(i)) this.tags.push(i);
			else if (uae(i)) {
				let o = /[^=]*/.exec(i.style)[0];
				r.indexOf(o) < 0 && r.push(o), this.styles.push(i);
			}
		}),
			(this.normalizeLists = !this.tags.some((i) => {
				if (!/^(ul|ol)\b/.test(i.tag) || !i.node) return !1;
				let o = e.nodes[i.node];
				return o.contentMatch.matchType(o);
			}));
	}
	parse(e, n = {}) {
		let r = new v$(this, n, !1);
		return r.addAll(e, zt.none, n.from, n.to), r.finish();
	}
	parseSlice(e, n = {}) {
		let r = new v$(this, n, !0);
		return r.addAll(e, zt.none, n.from, n.to), Ee.maxOpen(r.finish());
	}
	matchTag(e, n, r) {
		for (
			let i = r ? this.tags.indexOf(r) + 1 : 0;
			i < this.tags.length;
			i++
		) {
			let o = this.tags[i];
			if (
				fae(e, o.tag) &&
				(o.namespace === void 0 || e.namespaceURI == o.namespace) &&
				(!o.context || n.matchesContext(o.context))
			) {
				if (o.getAttrs) {
					let s = o.getAttrs(e);
					if (s === !1) continue;
					o.attrs = s || void 0;
				}
				return o;
			}
		}
	}
	matchStyle(e, n, r, i) {
		for (
			let o = i ? this.styles.indexOf(i) + 1 : 0;
			o < this.styles.length;
			o++
		) {
			let s = this.styles[o],
				a = s.style;
			if (
				!(
					a.indexOf(e) != 0 ||
					(s.context && !r.matchesContext(s.context)) ||
					(a.length > e.length &&
						(a.charCodeAt(e.length) != 61 ||
							a.slice(e.length + 1) != n))
				)
			) {
				if (s.getAttrs) {
					let l = s.getAttrs(n);
					if (l === !1) continue;
					s.attrs = l || void 0;
				}
				return s;
			}
		}
	}
	static schemaRules(e) {
		let n = [];
		function r(i) {
			let o = i.priority == null ? 50 : i.priority,
				s = 0;
			for (; s < n.length; s++) {
				let a = n[s];
				if ((a.priority == null ? 50 : a.priority) < o) break;
			}
			n.splice(s, 0, i);
		}
		for (let i in e.marks) {
			let o = e.marks[i].spec.parseDOM;
			o &&
				o.forEach((s) => {
					r((s = y$(s))),
						s.mark || s.ignore || s.clearMark || (s.mark = i);
				});
		}
		for (let i in e.nodes) {
			let o = e.nodes[i].spec.parseDOM;
			o &&
				o.forEach((s) => {
					r((s = y$(s))),
						s.node || s.ignore || s.mark || (s.node = i);
				});
		}
		return n;
	}
	static fromSchema(e) {
		return (
			e.cached.domParser ||
			(e.cached.domParser = new ww(e, ww.schemaRules(e)))
		);
	}
};
const ej = {
		address: !0,
		article: !0,
		aside: !0,
		blockquote: !0,
		canvas: !0,
		dd: !0,
		div: !0,
		dl: !0,
		fieldset: !0,
		figcaption: !0,
		figure: !0,
		footer: !0,
		form: !0,
		h1: !0,
		h2: !0,
		h3: !0,
		h4: !0,
		h5: !0,
		h6: !0,
		header: !0,
		hgroup: !0,
		hr: !0,
		li: !0,
		noscript: !0,
		ol: !0,
		output: !0,
		p: !0,
		pre: !0,
		section: !0,
		table: !0,
		tfoot: !0,
		ul: !0,
	},
	cae = {
		head: !0,
		noscript: !0,
		object: !0,
		script: !0,
		style: !0,
		title: !0,
	},
	tj = { ol: !0, ul: !0 },
	Tv = 1,
	Bv = 2,
	ym = 4;
function b$(t, e, n) {
	return e != null
		? (e ? Tv : 0) | (e === "full" ? Bv : 0)
		: t && t.whitespace == "pre"
			? Tv | Bv
			: n & ~ym;
}
class x1 {
	constructor(e, n, r, i, o, s) {
		(this.type = e),
			(this.attrs = n),
			(this.marks = r),
			(this.solid = i),
			(this.options = s),
			(this.content = []),
			(this.activeMarks = zt.none),
			(this.match = o || (s & ym ? null : e.contentMatch));
	}
	findWrapping(e) {
		if (!this.match) {
			if (!this.type) return [];
			let n = this.type.contentMatch.fillBefore(be.from(e));
			if (n) this.match = this.type.contentMatch.matchFragment(n);
			else {
				let r = this.type.contentMatch,
					i;
				return (i = r.findWrapping(e.type))
					? ((this.match = r), i)
					: null;
			}
		}
		return this.match.findWrapping(e.type);
	}
	finish(e) {
		if (!(this.options & Tv)) {
			let r = this.content[this.content.length - 1],
				i;
			if (r && r.isText && (i = /[ \t\r\n\u000c]+$/.exec(r.text))) {
				let o = r;
				r.text.length == i[0].length
					? this.content.pop()
					: (this.content[this.content.length - 1] = o.withText(
							o.text.slice(0, o.text.length - i[0].length),
						));
			}
		}
		let n = be.from(this.content);
		return (
			!e &&
				this.match &&
				(n = n.append(this.match.fillBefore(be.empty, !0))),
			this.type ? this.type.create(this.attrs, n, this.marks) : n
		);
	}
	inlineContext(e) {
		return this.type
			? this.type.inlineContent
			: this.content.length
				? this.content[0].isInline
				: e.parentNode &&
					!ej.hasOwnProperty(e.parentNode.nodeName.toLowerCase());
	}
}
class v$ {
	constructor(e, n, r) {
		(this.parser = e),
			(this.options = n),
			(this.isOpen = r),
			(this.open = 0);
		let i = n.topNode,
			o,
			s = b$(null, n.preserveWhitespace, 0) | (r ? ym : 0);
		i
			? (o = new x1(
					i.type,
					i.attrs,
					zt.none,
					!0,
					n.topMatch || i.type.contentMatch,
					s,
				))
			: r
				? (o = new x1(null, null, zt.none, !0, null, s))
				: (o = new x1(
						e.schema.topNodeType,
						null,
						zt.none,
						!0,
						null,
						s,
					)),
			(this.nodes = [o]),
			(this.find = n.findPositions),
			(this.needsBlock = !1);
	}
	get top() {
		return this.nodes[this.open];
	}
	addDOM(e, n) {
		e.nodeType == 3
			? this.addTextNode(e, n)
			: e.nodeType == 1 && this.addElement(e, n);
	}
	addTextNode(e, n) {
		let r = e.nodeValue,
			i = this.top;
		if (
			i.options & Bv ||
			i.inlineContext(e) ||
			/[^ \t\r\n\u000c]/.test(r)
		) {
			if (i.options & Tv)
				i.options & Bv
					? (r = r.replace(
							/\r\n?/g,
							`
`,
						))
					: (r = r.replace(/\r?\n|\r/g, " "));
			else if (
				((r = r.replace(/[ \t\r\n\u000c]+/g, " ")),
				/^[ \t\r\n\u000c]/.test(r) &&
					this.open == this.nodes.length - 1)
			) {
				let o = i.content[i.content.length - 1],
					s = e.previousSibling;
				(!o ||
					(s && s.nodeName == "BR") ||
					(o.isText && /[ \t\r\n\u000c]$/.test(o.text))) &&
					(r = r.slice(1));
			}
			r && this.insertNode(this.parser.schema.text(r), n),
				this.findInText(e);
		} else this.findInside(e);
	}
	addElement(e, n, r) {
		let i = e.nodeName.toLowerCase(),
			o;
		tj.hasOwnProperty(i) && this.parser.normalizeLists && dae(e);
		let s =
			(this.options.ruleFromNode && this.options.ruleFromNode(e)) ||
			(o = this.parser.matchTag(e, this, r));
		if (s ? s.ignore : cae.hasOwnProperty(i))
			this.findInside(e), this.ignoreFallback(e, n);
		else if (!s || s.skip || s.closeParent) {
			s && s.closeParent
				? (this.open = Math.max(0, this.open - 1))
				: s && s.skip.nodeType && (e = s.skip);
			let a,
				l = this.top,
				u = this.needsBlock;
			if (ej.hasOwnProperty(i))
				l.content.length &&
					l.content[0].isInline &&
					this.open &&
					(this.open--, (l = this.top)),
					(a = !0),
					l.type || (this.needsBlock = !0);
			else if (!e.firstChild) {
				this.leafFallback(e, n);
				return;
			}
			let c = s && s.skip ? n : this.readStyles(e, n);
			c && this.addAll(e, c), a && this.sync(l), (this.needsBlock = u);
		} else {
			let a = this.readStyles(e, n);
			a &&
				this.addElementByRule(e, s, a, s.consuming === !1 ? o : void 0);
		}
	}
	leafFallback(e, n) {
		e.nodeName == "BR" &&
			this.top.type &&
			this.top.type.inlineContent &&
			this.addTextNode(
				e.ownerDocument.createTextNode(`
`),
				n,
			);
	}
	ignoreFallback(e, n) {
		e.nodeName == "BR" &&
			(!this.top.type || !this.top.type.inlineContent) &&
			this.findPlace(this.parser.schema.text("-"), n);
	}
	readStyles(e, n) {
		let r = e.style;
		if (r && r.length)
			for (let i = 0; i < this.parser.matchedStyles.length; i++) {
				let o = this.parser.matchedStyles[i],
					s = r.getPropertyValue(o);
				if (s)
					for (let a = void 0; ; ) {
						let l = this.parser.matchStyle(o, s, this, a);
						if (!l) break;
						if (l.ignore) return null;
						if (
							(l.clearMark
								? (n = n.filter((u) => !l.clearMark(u)))
								: (n = n.concat(
										this.parser.schema.marks[l.mark].create(
											l.attrs,
										),
									)),
							l.consuming === !1)
						)
							a = l;
						else break;
					}
			}
		return n;
	}
	addElementByRule(e, n, r, i) {
		let o, s;
		if (n.node)
			if (((s = this.parser.schema.nodes[n.node]), s.isLeaf))
				this.insertNode(s.create(n.attrs), r) ||
					this.leafFallback(e, r);
			else {
				let l = this.enter(s, n.attrs || null, r, n.preserveWhitespace);
				l && ((o = !0), (r = l));
			}
		else {
			let l = this.parser.schema.marks[n.mark];
			r = r.concat(l.create(n.attrs));
		}
		let a = this.top;
		if (s && s.isLeaf) this.findInside(e);
		else if (i) this.addElement(e, r, i);
		else if (n.getContent)
			this.findInside(e),
				n
					.getContent(e, this.parser.schema)
					.forEach((l) => this.insertNode(l, r));
		else {
			let l = e;
			typeof n.contentElement == "string"
				? (l = e.querySelector(n.contentElement))
				: typeof n.contentElement == "function"
					? (l = n.contentElement(e))
					: n.contentElement && (l = n.contentElement),
				this.findAround(e, l, !0),
				this.addAll(l, r);
		}
		o && this.sync(a) && this.open--;
	}
	addAll(e, n, r, i) {
		let o = r || 0;
		for (
			let s = r ? e.childNodes[r] : e.firstChild,
				a = i == null ? null : e.childNodes[i];
			s != a;
			s = s.nextSibling, ++o
		)
			this.findAtPoint(e, o), this.addDOM(s, n);
		this.findAtPoint(e, o);
	}
	findPlace(e, n) {
		let r, i;
		for (let o = this.open; o >= 0; o--) {
			let s = this.nodes[o],
				a = s.findWrapping(e);
			if (
				(a &&
					(!r || r.length > a.length) &&
					((r = a), (i = s), !a.length)) ||
				s.solid
			)
				break;
		}
		if (!r) return null;
		this.sync(i);
		for (let o = 0; o < r.length; o++)
			n = this.enterInner(r[o], null, n, !1);
		return n;
	}
	insertNode(e, n) {
		if (e.isInline && this.needsBlock && !this.top.type) {
			let i = this.textblockFromContext();
			i && (n = this.enterInner(i, null, n));
		}
		let r = this.findPlace(e, n);
		if (r) {
			this.closeExtra();
			let i = this.top;
			i.match && (i.match = i.match.matchType(e.type));
			let o = zt.none;
			for (let s of r.concat(e.marks))
				(i.type ? i.type.allowsMarkType(s.type) : x$(s.type, e.type)) &&
					(o = s.addToSet(o));
			return i.content.push(e.mark(o)), !0;
		}
		return !1;
	}
	enter(e, n, r, i) {
		let o = this.findPlace(e.create(n), r);
		return o && (o = this.enterInner(e, n, r, !0, i)), o;
	}
	enterInner(e, n, r, i = !1, o) {
		this.closeExtra();
		let s = this.top;
		s.match = s.match && s.match.matchType(e);
		let a = b$(e, o, s.options);
		s.options & ym && s.content.length == 0 && (a |= ym);
		let l = zt.none;
		return (
			(r = r.filter((u) =>
				(s.type ? s.type.allowsMarkType(u.type) : x$(u.type, e))
					? ((l = u.addToSet(l)), !1)
					: !0,
			)),
			this.nodes.push(new x1(e, n, l, i, null, a)),
			this.open++,
			r
		);
	}
	closeExtra(e = !1) {
		let n = this.nodes.length - 1;
		if (n > this.open) {
			for (; n > this.open; n--)
				this.nodes[n - 1].content.push(this.nodes[n].finish(e));
			this.nodes.length = this.open + 1;
		}
	}
	finish() {
		return (
			(this.open = 0),
			this.closeExtra(this.isOpen),
			this.nodes[0].finish(this.isOpen || this.options.topOpen)
		);
	}
	sync(e) {
		for (let n = this.open; n >= 0; n--)
			if (this.nodes[n] == e) return (this.open = n), !0;
		return !1;
	}
	get currentPos() {
		this.closeExtra();
		let e = 0;
		for (let n = this.open; n >= 0; n--) {
			let r = this.nodes[n].content;
			for (let i = r.length - 1; i >= 0; i--) e += r[i].nodeSize;
			n && e++;
		}
		return e;
	}
	findAtPoint(e, n) {
		if (this.find)
			for (let r = 0; r < this.find.length; r++)
				this.find[r].node == e &&
					this.find[r].offset == n &&
					(this.find[r].pos = this.currentPos);
	}
	findInside(e) {
		if (this.find)
			for (let n = 0; n < this.find.length; n++)
				this.find[n].pos == null &&
					e.nodeType == 1 &&
					e.contains(this.find[n].node) &&
					(this.find[n].pos = this.currentPos);
	}
	findAround(e, n, r) {
		if (e != n && this.find)
			for (let i = 0; i < this.find.length; i++)
				this.find[i].pos == null &&
					e.nodeType == 1 &&
					e.contains(this.find[i].node) &&
					n.compareDocumentPosition(this.find[i].node) &
						(r ? 2 : 4) &&
					(this.find[i].pos = this.currentPos);
	}
	findInText(e) {
		if (this.find)
			for (let n = 0; n < this.find.length; n++)
				this.find[n].node == e &&
					(this.find[n].pos =
						this.currentPos -
						(e.nodeValue.length - this.find[n].offset));
	}
	matchesContext(e) {
		if (e.indexOf("|") > -1)
			return e.split(/\s*\|\s*/).some(this.matchesContext, this);
		let n = e.split("/"),
			r = this.options.context,
			i = !this.isOpen && (!r || r.parent.type == this.nodes[0].type),
			o = -(r ? r.depth + 1 : 0) + (i ? 0 : 1),
			s = (a, l) => {
				for (; a >= 0; a--) {
					let u = n[a];
					if (u == "") {
						if (a == n.length - 1 || a == 0) continue;
						for (; l >= o; l--) if (s(a - 1, l)) return !0;
						return !1;
					} else {
						let c =
							l > 0 || (l == 0 && i)
								? this.nodes[l].type
								: r && l >= o
									? r.node(l - o).type
									: null;
						if (!c || (c.name != u && c.groups.indexOf(u) == -1))
							return !1;
						l--;
					}
				}
				return !0;
			};
		return s(n.length - 1, this.open);
	}
	textblockFromContext() {
		let e = this.options.context;
		if (e)
			for (let n = e.depth; n >= 0; n--) {
				let r = e.node(n).contentMatchAt(e.indexAfter(n)).defaultType;
				if (r && r.isTextblock && r.defaultAttrs) return r;
			}
		for (let n in this.parser.schema.nodes) {
			let r = this.parser.schema.nodes[n];
			if (r.isTextblock && r.defaultAttrs) return r;
		}
	}
}
function dae(t) {
	for (let e = t.firstChild, n = null; e; e = e.nextSibling) {
		let r = e.nodeType == 1 ? e.nodeName.toLowerCase() : null;
		r && tj.hasOwnProperty(r) && n
			? (n.appendChild(e), (e = n))
			: r == "li"
				? (n = e)
				: r && (n = null);
	}
}
function fae(t, e) {
	return (
		t.matches ||
		t.msMatchesSelector ||
		t.webkitMatchesSelector ||
		t.mozMatchesSelector
	).call(t, e);
}
function y$(t) {
	let e = {};
	for (let n in t) e[n] = t[n];
	return e;
}
function x$(t, e) {
	let n = e.schema.nodes;
	for (let r in n) {
		let i = n[r];
		if (!i.allowsMarkType(t)) continue;
		let o = [],
			s = (a) => {
				o.push(a);
				for (let l = 0; l < a.edgeCount; l++) {
					let { type: u, next: c } = a.edge(l);
					if (u == e || (o.indexOf(c) < 0 && s(c))) return !0;
				}
			};
		if (s(i.contentMatch)) return !0;
	}
}
class Jd {
	constructor(e, n) {
		(this.nodes = e), (this.marks = n);
	}
	serializeFragment(e, n = {}, r) {
		r || (r = G4(n).createDocumentFragment());
		let i = r,
			o = [];
		return (
			e.forEach((s) => {
				if (o.length || s.marks.length) {
					let a = 0,
						l = 0;
					for (; a < o.length && l < s.marks.length; ) {
						let u = s.marks[l];
						if (!this.marks[u.type.name]) {
							l++;
							continue;
						}
						if (!u.eq(o[a][0]) || u.type.spec.spanning === !1)
							break;
						a++, l++;
					}
					for (; a < o.length; ) i = o.pop()[1];
					for (; l < s.marks.length; ) {
						let u = s.marks[l++],
							c = this.serializeMark(u, s.isInline, n);
						c &&
							(o.push([u, i]),
							i.appendChild(c.dom),
							(i = c.contentDOM || c.dom));
					}
				}
				i.appendChild(this.serializeNodeInner(s, n));
			}),
			r
		);
	}
	serializeNodeInner(e, n) {
		let { dom: r, contentDOM: i } = ub(
			G4(n),
			this.nodes[e.type.name](e),
			null,
			e.attrs,
		);
		if (i) {
			if (e.isLeaf)
				throw new RangeError(
					"Content hole not allowed in a leaf node spec",
				);
			this.serializeFragment(e.content, n, i);
		}
		return r;
	}
	serializeNode(e, n = {}) {
		let r = this.serializeNodeInner(e, n);
		for (let i = e.marks.length - 1; i >= 0; i--) {
			let o = this.serializeMark(e.marks[i], e.isInline, n);
			o && ((o.contentDOM || o.dom).appendChild(r), (r = o.dom));
		}
		return r;
	}
	serializeMark(e, n, r = {}) {
		let i = this.marks[e.type.name];
		return i && ub(G4(r), i(e, n), null, e.attrs);
	}
	static renderSpec(e, n, r = null, i) {
		return ub(e, n, r, i);
	}
	static fromSchema(e) {
		return (
			e.cached.domSerializer ||
			(e.cached.domSerializer = new Jd(
				this.nodesFromSchema(e),
				this.marksFromSchema(e),
			))
		);
	}
	static nodesFromSchema(e) {
		let n = k$(e.nodes);
		return n.text || (n.text = (r) => r.text), n;
	}
	static marksFromSchema(e) {
		return k$(e.marks);
	}
}
function k$(t) {
	let e = {};
	for (let n in t) {
		let r = t[n].spec.toDOM;
		r && (e[n] = r);
	}
	return e;
}
function G4(t) {
	return t.document || window.document;
}
const C$ = new WeakMap();
function hae(t) {
	let e = C$.get(t);
	return e === void 0 && C$.set(t, (e = pae(t))), e;
}
function pae(t) {
	let e = null;
	function n(r) {
		if (r && typeof r == "object")
			if (Array.isArray(r))
				if (typeof r[0] == "string") e || (e = []), e.push(r);
				else for (let i = 0; i < r.length; i++) n(r[i]);
			else for (let i in r) n(r[i]);
	}
	return n(t), e;
}
function ub(t, e, n, r) {
	if (typeof e == "string") return { dom: t.createTextNode(e) };
	if (e.nodeType != null) return { dom: e };
	if (e.dom && e.dom.nodeType != null) return e;
	let i = e[0],
		o;
	if (typeof i != "string")
		throw new RangeError("Invalid array passed to renderSpec");
	if (r && (o = hae(r)) && o.indexOf(e) > -1)
		throw new RangeError(
			"Using an array from an attribute object as a DOM spec. This may be an attempted cross site scripting attack.",
		);
	let s = i.indexOf(" ");
	s > 0 && ((n = i.slice(0, s)), (i = i.slice(s + 1)));
	let a,
		l = n ? t.createElementNS(n, i) : t.createElement(i),
		u = e[1],
		c = 1;
	if (u && typeof u == "object" && u.nodeType == null && !Array.isArray(u)) {
		c = 2;
		for (let d in u)
			if (u[d] != null) {
				let f = d.indexOf(" ");
				f > 0
					? l.setAttributeNS(d.slice(0, f), d.slice(f + 1), u[d])
					: l.setAttribute(d, u[d]);
			}
	}
	for (let d = c; d < e.length; d++) {
		let f = e[d];
		if (f === 0) {
			if (d < e.length - 1 || d > c)
				throw new RangeError(
					"Content hole must be the only child of its parent node",
				);
			return { dom: l, contentDOM: l };
		} else {
			let { dom: h, contentDOM: p } = ub(t, f, n, r);
			if ((l.appendChild(h), p)) {
				if (a) throw new RangeError("Multiple content holes");
				a = p;
			}
		}
	}
	return { dom: l, contentDOM: a };
}
const nj = 65535,
	rj = Math.pow(2, 16);
function mae(t, e) {
	return t + e * rj;
}
function w$(t) {
	return t & nj;
}
function gae(t) {
	return (t - (t & nj)) / rj;
}
const ij = 1,
	oj = 2,
	cb = 4,
	sj = 8;
class Ew {
	constructor(e, n, r) {
		(this.pos = e), (this.delInfo = n), (this.recover = r);
	}
	get deleted() {
		return (this.delInfo & sj) > 0;
	}
	get deletedBefore() {
		return (this.delInfo & (ij | cb)) > 0;
	}
	get deletedAfter() {
		return (this.delInfo & (oj | cb)) > 0;
	}
	get deletedAcross() {
		return (this.delInfo & cb) > 0;
	}
}
class to {
	constructor(e, n = !1) {
		if (((this.ranges = e), (this.inverted = n), !e.length && to.empty))
			return to.empty;
	}
	recover(e) {
		let n = 0,
			r = w$(e);
		if (!this.inverted)
			for (let i = 0; i < r; i++)
				n += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1];
		return this.ranges[r * 3] + n + gae(e);
	}
	mapResult(e, n = 1) {
		return this._map(e, n, !1);
	}
	map(e, n = 1) {
		return this._map(e, n, !0);
	}
	_map(e, n, r) {
		let i = 0,
			o = this.inverted ? 2 : 1,
			s = this.inverted ? 1 : 2;
		for (let a = 0; a < this.ranges.length; a += 3) {
			let l = this.ranges[a] - (this.inverted ? i : 0);
			if (l > e) break;
			let u = this.ranges[a + o],
				c = this.ranges[a + s],
				d = l + u;
			if (e <= d) {
				let f = u ? (e == l ? -1 : e == d ? 1 : n) : n,
					h = l + i + (f < 0 ? 0 : c);
				if (r) return h;
				let p = e == (n < 0 ? l : d) ? null : mae(a / 3, e - l),
					g = e == l ? oj : e == d ? ij : cb;
				return (n < 0 ? e != l : e != d) && (g |= sj), new Ew(h, g, p);
			}
			i += c - u;
		}
		return r ? e + i : new Ew(e + i, 0, null);
	}
	touches(e, n) {
		let r = 0,
			i = w$(n),
			o = this.inverted ? 2 : 1,
			s = this.inverted ? 1 : 2;
		for (let a = 0; a < this.ranges.length; a += 3) {
			let l = this.ranges[a] - (this.inverted ? r : 0);
			if (l > e) break;
			let u = this.ranges[a + o],
				c = l + u;
			if (e <= c && a == i * 3) return !0;
			r += this.ranges[a + s] - u;
		}
		return !1;
	}
	forEach(e) {
		let n = this.inverted ? 2 : 1,
			r = this.inverted ? 1 : 2;
		for (let i = 0, o = 0; i < this.ranges.length; i += 3) {
			let s = this.ranges[i],
				a = s - (this.inverted ? o : 0),
				l = s + (this.inverted ? 0 : o),
				u = this.ranges[i + n],
				c = this.ranges[i + r];
			e(a, a + u, l, l + c), (o += c - u);
		}
	}
	invert() {
		return new to(this.ranges, !this.inverted);
	}
	toString() {
		return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
	}
	static offset(e) {
		return e == 0 ? to.empty : new to(e < 0 ? [0, -e, 0] : [0, 0, e]);
	}
}
to.empty = new to([]);
class th {
	constructor(e = [], n, r = 0, i = e.length) {
		(this.maps = e), (this.mirror = n), (this.from = r), (this.to = i);
	}
	slice(e = 0, n = this.maps.length) {
		return new th(this.maps, this.mirror, e, n);
	}
	copy() {
		return new th(
			this.maps.slice(),
			this.mirror && this.mirror.slice(),
			this.from,
			this.to,
		);
	}
	appendMap(e, n) {
		(this.to = this.maps.push(e)),
			n != null && this.setMirror(this.maps.length - 1, n);
	}
	appendMapping(e) {
		for (let n = 0, r = this.maps.length; n < e.maps.length; n++) {
			let i = e.getMirror(n);
			this.appendMap(e.maps[n], i != null && i < n ? r + i : void 0);
		}
	}
	getMirror(e) {
		if (this.mirror) {
			for (let n = 0; n < this.mirror.length; n++)
				if (this.mirror[n] == e)
					return this.mirror[n + (n % 2 ? -1 : 1)];
		}
	}
	setMirror(e, n) {
		this.mirror || (this.mirror = []), this.mirror.push(e, n);
	}
	appendMappingInverted(e) {
		for (
			let n = e.maps.length - 1, r = this.maps.length + e.maps.length;
			n >= 0;
			n--
		) {
			let i = e.getMirror(n);
			this.appendMap(
				e.maps[n].invert(),
				i != null && i > n ? r - i - 1 : void 0,
			);
		}
	}
	invert() {
		let e = new th();
		return e.appendMappingInverted(this), e;
	}
	map(e, n = 1) {
		if (this.mirror) return this._map(e, n, !0);
		for (let r = this.from; r < this.to; r++) e = this.maps[r].map(e, n);
		return e;
	}
	mapResult(e, n = 1) {
		return this._map(e, n, !1);
	}
	_map(e, n, r) {
		let i = 0;
		for (let o = this.from; o < this.to; o++) {
			let s = this.maps[o],
				a = s.mapResult(e, n);
			if (a.recover != null) {
				let l = this.getMirror(o);
				if (l != null && l > o && l < this.to) {
					(o = l), (e = this.maps[l].recover(a.recover));
					continue;
				}
			}
			(i |= a.delInfo), (e = a.pos);
		}
		return r ? e : new Ew(e, i, null);
	}
}
const Y4 = Object.create(null);
class Jr {
	getMap() {
		return to.empty;
	}
	merge(e) {
		return null;
	}
	static fromJSON(e, n) {
		if (!n || !n.stepType)
			throw new RangeError("Invalid input for Step.fromJSON");
		let r = Y4[n.stepType];
		if (!r) throw new RangeError(`No step type ${n.stepType} defined`);
		return r.fromJSON(e, n);
	}
	static jsonID(e, n) {
		if (e in Y4) throw new RangeError("Duplicate use of step JSON ID " + e);
		return (Y4[e] = n), (n.prototype.jsonID = e), n;
	}
}
class Un {
	constructor(e, n) {
		(this.doc = e), (this.failed = n);
	}
	static ok(e) {
		return new Un(e, null);
	}
	static fail(e) {
		return new Un(null, e);
	}
	static fromReplace(e, n, r, i) {
		try {
			return Un.ok(e.replace(n, r, i));
		} catch (o) {
			if (o instanceof Dv) return Un.fail(o.message);
			throw o;
		}
	}
}
function _D(t, e, n) {
	let r = [];
	for (let i = 0; i < t.childCount; i++) {
		let o = t.child(i);
		o.content.size && (o = o.copy(_D(o.content, e, o))),
			o.isInline && (o = e(o, n, i)),
			r.push(o);
	}
	return be.fromArray(r);
}
class mu extends Jr {
	constructor(e, n, r) {
		super(), (this.from = e), (this.to = n), (this.mark = r);
	}
	apply(e) {
		let n = e.slice(this.from, this.to),
			r = e.resolve(this.from),
			i = r.node(r.sharedDepth(this.to)),
			o = new Ee(
				_D(
					n.content,
					(s, a) =>
						!s.isAtom || !a.type.allowsMarkType(this.mark.type)
							? s
							: s.mark(this.mark.addToSet(s.marks)),
					i,
				),
				n.openStart,
				n.openEnd,
			);
		return Un.fromReplace(e, this.from, this.to, o);
	}
	invert() {
		return new Qs(this.from, this.to, this.mark);
	}
	map(e) {
		let n = e.mapResult(this.from, 1),
			r = e.mapResult(this.to, -1);
		return (n.deleted && r.deleted) || n.pos >= r.pos
			? null
			: new mu(n.pos, r.pos, this.mark);
	}
	merge(e) {
		return e instanceof mu &&
			e.mark.eq(this.mark) &&
			this.from <= e.to &&
			this.to >= e.from
			? new mu(
					Math.min(this.from, e.from),
					Math.max(this.to, e.to),
					this.mark,
				)
			: null;
	}
	toJSON() {
		return {
			stepType: "addMark",
			mark: this.mark.toJSON(),
			from: this.from,
			to: this.to,
		};
	}
	static fromJSON(e, n) {
		if (typeof n.from != "number" || typeof n.to != "number")
			throw new RangeError("Invalid input for AddMarkStep.fromJSON");
		return new mu(n.from, n.to, e.markFromJSON(n.mark));
	}
}
Jr.jsonID("addMark", mu);
class Qs extends Jr {
	constructor(e, n, r) {
		super(), (this.from = e), (this.to = n), (this.mark = r);
	}
	apply(e) {
		let n = e.slice(this.from, this.to),
			r = new Ee(
				_D(
					n.content,
					(i) => i.mark(this.mark.removeFromSet(i.marks)),
					e,
				),
				n.openStart,
				n.openEnd,
			);
		return Un.fromReplace(e, this.from, this.to, r);
	}
	invert() {
		return new mu(this.from, this.to, this.mark);
	}
	map(e) {
		let n = e.mapResult(this.from, 1),
			r = e.mapResult(this.to, -1);
		return (n.deleted && r.deleted) || n.pos >= r.pos
			? null
			: new Qs(n.pos, r.pos, this.mark);
	}
	merge(e) {
		return e instanceof Qs &&
			e.mark.eq(this.mark) &&
			this.from <= e.to &&
			this.to >= e.from
			? new Qs(
					Math.min(this.from, e.from),
					Math.max(this.to, e.to),
					this.mark,
				)
			: null;
	}
	toJSON() {
		return {
			stepType: "removeMark",
			mark: this.mark.toJSON(),
			from: this.from,
			to: this.to,
		};
	}
	static fromJSON(e, n) {
		if (typeof n.from != "number" || typeof n.to != "number")
			throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
		return new Qs(n.from, n.to, e.markFromJSON(n.mark));
	}
}
Jr.jsonID("removeMark", Qs);
class gu extends Jr {
	constructor(e, n) {
		super(), (this.pos = e), (this.mark = n);
	}
	apply(e) {
		let n = e.nodeAt(this.pos);
		if (!n) return Un.fail("No node at mark step's position");
		let r = n.type.create(n.attrs, null, this.mark.addToSet(n.marks));
		return Un.fromReplace(
			e,
			this.pos,
			this.pos + 1,
			new Ee(be.from(r), 0, n.isLeaf ? 0 : 1),
		);
	}
	invert(e) {
		let n = e.nodeAt(this.pos);
		if (n) {
			let r = this.mark.addToSet(n.marks);
			if (r.length == n.marks.length) {
				for (let i = 0; i < n.marks.length; i++)
					if (!n.marks[i].isInSet(r))
						return new gu(this.pos, n.marks[i]);
				return new gu(this.pos, this.mark);
			}
		}
		return new kh(this.pos, this.mark);
	}
	map(e) {
		let n = e.mapResult(this.pos, 1);
		return n.deletedAfter ? null : new gu(n.pos, this.mark);
	}
	toJSON() {
		return {
			stepType: "addNodeMark",
			pos: this.pos,
			mark: this.mark.toJSON(),
		};
	}
	static fromJSON(e, n) {
		if (typeof n.pos != "number")
			throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON");
		return new gu(n.pos, e.markFromJSON(n.mark));
	}
}
Jr.jsonID("addNodeMark", gu);
class kh extends Jr {
	constructor(e, n) {
		super(), (this.pos = e), (this.mark = n);
	}
	apply(e) {
		let n = e.nodeAt(this.pos);
		if (!n) return Un.fail("No node at mark step's position");
		let r = n.type.create(n.attrs, null, this.mark.removeFromSet(n.marks));
		return Un.fromReplace(
			e,
			this.pos,
			this.pos + 1,
			new Ee(be.from(r), 0, n.isLeaf ? 0 : 1),
		);
	}
	invert(e) {
		let n = e.nodeAt(this.pos);
		return !n || !this.mark.isInSet(n.marks)
			? this
			: new gu(this.pos, this.mark);
	}
	map(e) {
		let n = e.mapResult(this.pos, 1);
		return n.deletedAfter ? null : new kh(n.pos, this.mark);
	}
	toJSON() {
		return {
			stepType: "removeNodeMark",
			pos: this.pos,
			mark: this.mark.toJSON(),
		};
	}
	static fromJSON(e, n) {
		if (typeof n.pos != "number")
			throw new RangeError(
				"Invalid input for RemoveNodeMarkStep.fromJSON",
			);
		return new kh(n.pos, e.markFromJSON(n.mark));
	}
}
Jr.jsonID("removeNodeMark", kh);
class zr extends Jr {
	constructor(e, n, r, i = !1) {
		super(),
			(this.from = e),
			(this.to = n),
			(this.slice = r),
			(this.structure = i);
	}
	apply(e) {
		return this.structure && Dw(e, this.from, this.to)
			? Un.fail("Structure replace would overwrite content")
			: Un.fromReplace(e, this.from, this.to, this.slice);
	}
	getMap() {
		return new to([this.from, this.to - this.from, this.slice.size]);
	}
	invert(e) {
		return new zr(
			this.from,
			this.from + this.slice.size,
			e.slice(this.from, this.to),
		);
	}
	map(e) {
		let n = e.mapResult(this.from, 1),
			r = e.mapResult(this.to, -1);
		return n.deletedAcross && r.deletedAcross
			? null
			: new zr(n.pos, Math.max(n.pos, r.pos), this.slice);
	}
	merge(e) {
		if (!(e instanceof zr) || e.structure || this.structure) return null;
		if (
			this.from + this.slice.size == e.from &&
			!this.slice.openEnd &&
			!e.slice.openStart
		) {
			let n =
				this.slice.size + e.slice.size == 0
					? Ee.empty
					: new Ee(
							this.slice.content.append(e.slice.content),
							this.slice.openStart,
							e.slice.openEnd,
						);
			return new zr(
				this.from,
				this.to + (e.to - e.from),
				n,
				this.structure,
			);
		} else if (
			e.to == this.from &&
			!this.slice.openStart &&
			!e.slice.openEnd
		) {
			let n =
				this.slice.size + e.slice.size == 0
					? Ee.empty
					: new Ee(
							e.slice.content.append(this.slice.content),
							e.slice.openStart,
							this.slice.openEnd,
						);
			return new zr(e.from, this.to, n, this.structure);
		} else return null;
	}
	toJSON() {
		let e = { stepType: "replace", from: this.from, to: this.to };
		return (
			this.slice.size && (e.slice = this.slice.toJSON()),
			this.structure && (e.structure = !0),
			e
		);
	}
	static fromJSON(e, n) {
		if (typeof n.from != "number" || typeof n.to != "number")
			throw new RangeError("Invalid input for ReplaceStep.fromJSON");
		return new zr(n.from, n.to, Ee.fromJSON(e, n.slice), !!n.structure);
	}
}
Jr.jsonID("replace", zr);
class Fr extends Jr {
	constructor(e, n, r, i, o, s, a = !1) {
		super(),
			(this.from = e),
			(this.to = n),
			(this.gapFrom = r),
			(this.gapTo = i),
			(this.slice = o),
			(this.insert = s),
			(this.structure = a);
	}
	apply(e) {
		if (
			this.structure &&
			(Dw(e, this.from, this.gapFrom) || Dw(e, this.gapTo, this.to))
		)
			return Un.fail("Structure gap-replace would overwrite content");
		let n = e.slice(this.gapFrom, this.gapTo);
		if (n.openStart || n.openEnd) return Un.fail("Gap is not a flat range");
		let r = this.slice.insertAt(this.insert, n.content);
		return r
			? Un.fromReplace(e, this.from, this.to, r)
			: Un.fail("Content does not fit in gap");
	}
	getMap() {
		return new to([
			this.from,
			this.gapFrom - this.from,
			this.insert,
			this.gapTo,
			this.to - this.gapTo,
			this.slice.size - this.insert,
		]);
	}
	invert(e) {
		let n = this.gapTo - this.gapFrom;
		return new Fr(
			this.from,
			this.from + this.slice.size + n,
			this.from + this.insert,
			this.from + this.insert + n,
			e
				.slice(this.from, this.to)
				.removeBetween(
					this.gapFrom - this.from,
					this.gapTo - this.from,
				),
			this.gapFrom - this.from,
			this.structure,
		);
	}
	map(e) {
		let n = e.mapResult(this.from, 1),
			r = e.mapResult(this.to, -1),
			i = this.from == this.gapFrom ? n.pos : e.map(this.gapFrom, -1),
			o = this.to == this.gapTo ? r.pos : e.map(this.gapTo, 1);
		return (n.deletedAcross && r.deletedAcross) || i < n.pos || o > r.pos
			? null
			: new Fr(
					n.pos,
					r.pos,
					i,
					o,
					this.slice,
					this.insert,
					this.structure,
				);
	}
	toJSON() {
		let e = {
			stepType: "replaceAround",
			from: this.from,
			to: this.to,
			gapFrom: this.gapFrom,
			gapTo: this.gapTo,
			insert: this.insert,
		};
		return (
			this.slice.size && (e.slice = this.slice.toJSON()),
			this.structure && (e.structure = !0),
			e
		);
	}
	static fromJSON(e, n) {
		if (
			typeof n.from != "number" ||
			typeof n.to != "number" ||
			typeof n.gapFrom != "number" ||
			typeof n.gapTo != "number" ||
			typeof n.insert != "number"
		)
			throw new RangeError(
				"Invalid input for ReplaceAroundStep.fromJSON",
			);
		return new Fr(
			n.from,
			n.to,
			n.gapFrom,
			n.gapTo,
			Ee.fromJSON(e, n.slice),
			n.insert,
			!!n.structure,
		);
	}
}
Jr.jsonID("replaceAround", Fr);
function Dw(t, e, n) {
	let r = t.resolve(e),
		i = n - e,
		o = r.depth;
	for (; i > 0 && o > 0 && r.indexAfter(o) == r.node(o).childCount; )
		o--, i--;
	if (i > 0) {
		let s = r.node(o).maybeChild(r.indexAfter(o));
		for (; i > 0; ) {
			if (!s || s.isLeaf) return !0;
			(s = s.firstChild), i--;
		}
	}
	return !1;
}
function bae(t, e, n, r) {
	let i = [],
		o = [],
		s,
		a;
	t.doc.nodesBetween(e, n, (l, u, c) => {
		if (!l.isInline) return;
		let d = l.marks;
		if (!r.isInSet(d) && c.type.allowsMarkType(r.type)) {
			let f = Math.max(u, e),
				h = Math.min(u + l.nodeSize, n),
				p = r.addToSet(d);
			for (let g = 0; g < d.length; g++)
				d[g].isInSet(p) ||
					(s && s.to == f && s.mark.eq(d[g])
						? (s.to = h)
						: i.push((s = new Qs(f, h, d[g]))));
			a && a.to == f ? (a.to = h) : o.push((a = new mu(f, h, r)));
		}
	}),
		i.forEach((l) => t.step(l)),
		o.forEach((l) => t.step(l));
}
function vae(t, e, n, r) {
	let i = [],
		o = 0;
	t.doc.nodesBetween(e, n, (s, a) => {
		if (!s.isInline) return;
		o++;
		let l = null;
		if (r instanceof Zh) {
			let u = s.marks,
				c;
			for (; (c = r.isInSet(u)); )
				(l || (l = [])).push(c), (u = c.removeFromSet(u));
		} else r ? r.isInSet(s.marks) && (l = [r]) : (l = s.marks);
		if (l && l.length) {
			let u = Math.min(a + s.nodeSize, n);
			for (let c = 0; c < l.length; c++) {
				let d = l[c],
					f;
				for (let h = 0; h < i.length; h++) {
					let p = i[h];
					p.step == o - 1 && d.eq(i[h].style) && (f = p);
				}
				f
					? ((f.to = u), (f.step = o))
					: i.push({
							style: d,
							from: Math.max(a, e),
							to: u,
							step: o,
						});
			}
		}
	}),
		i.forEach((s) => t.step(new Qs(s.from, s.to, s.style)));
}
function aj(t, e, n, r = n.contentMatch, i = !0) {
	let o = t.doc.nodeAt(e),
		s = [],
		a = e + 1;
	for (let l = 0; l < o.childCount; l++) {
		let u = o.child(l),
			c = a + u.nodeSize,
			d = r.matchType(u.type);
		if (!d) s.push(new zr(a, c, Ee.empty));
		else {
			r = d;
			for (let f = 0; f < u.marks.length; f++)
				n.allowsMarkType(u.marks[f].type) ||
					t.step(new Qs(a, c, u.marks[f]));
			if (i && u.isText && n.whitespace != "pre") {
				let f,
					h = /\r?\n|\r/g,
					p;
				for (; (f = h.exec(u.text)); )
					p ||
						(p = new Ee(
							be.from(
								n.schema.text(" ", n.allowedMarks(u.marks)),
							),
							0,
							0,
						)),
						s.push(
							new zr(a + f.index, a + f.index + f[0].length, p),
						);
			}
		}
		a = c;
	}
	if (!r.validEnd) {
		let l = r.fillBefore(be.empty, !0);
		t.replace(a, a, new Ee(l, 0, 0));
	}
	for (let l = s.length - 1; l >= 0; l--) t.step(s[l]);
}
function yae(t, e, n) {
	return (
		(e == 0 || t.canReplace(e, t.childCount)) &&
		(n == t.childCount || t.canReplace(0, n))
	);
}
function v0(t) {
	let n = t.parent.content.cutByIndex(t.startIndex, t.endIndex);
	for (let r = t.depth; ; --r) {
		let i = t.$from.node(r),
			o = t.$from.index(r),
			s = t.$to.indexAfter(r);
		if (r < t.depth && i.canReplace(o, s, n)) return r;
		if (r == 0 || i.type.spec.isolating || !yae(i, o, s)) break;
	}
	return null;
}
function xae(t, e, n) {
	let { $from: r, $to: i, depth: o } = e,
		s = r.before(o + 1),
		a = i.after(o + 1),
		l = s,
		u = a,
		c = be.empty,
		d = 0;
	for (let p = o, g = !1; p > n; p--)
		g || r.index(p) > 0
			? ((g = !0), (c = be.from(r.node(p).copy(c))), d++)
			: l--;
	let f = be.empty,
		h = 0;
	for (let p = o, g = !1; p > n; p--)
		g || i.after(p + 1) < i.end(p)
			? ((g = !0), (f = be.from(i.node(p).copy(f))), h++)
			: u++;
	t.step(new Fr(l, u, s, a, new Ee(c.append(f), d, h), c.size - d, !0));
}
function zD(t, e, n = null, r = t) {
	let i = kae(t, e),
		o = i && Cae(r, e);
	return o ? i.map(E$).concat({ type: e, attrs: n }).concat(o.map(E$)) : null;
}
function E$(t) {
	return { type: t, attrs: null };
}
function kae(t, e) {
	let { parent: n, startIndex: r, endIndex: i } = t,
		o = n.contentMatchAt(r).findWrapping(e);
	if (!o) return null;
	let s = o.length ? o[0] : e;
	return n.canReplaceWith(r, i, s) ? o : null;
}
function Cae(t, e) {
	let { parent: n, startIndex: r, endIndex: i } = t,
		o = n.child(r),
		s = e.contentMatch.findWrapping(o.type);
	if (!s) return null;
	let l = (s.length ? s[s.length - 1] : e).contentMatch;
	for (let u = r; l && u < i; u++) l = l.matchType(n.child(u).type);
	return !l || !l.validEnd ? null : s;
}
function wae(t, e, n) {
	let r = be.empty;
	for (let s = n.length - 1; s >= 0; s--) {
		if (r.size) {
			let a = n[s].type.contentMatch.matchFragment(r);
			if (!a || !a.validEnd)
				throw new RangeError(
					"Wrapper type given to Transform.wrap does not form valid content of its parent wrapper",
				);
		}
		r = be.from(n[s].type.create(n[s].attrs, r));
	}
	let i = e.start,
		o = e.end;
	t.step(new Fr(i, o, i, o, new Ee(r, 0, 0), n.length, !0));
}
function Eae(t, e, n, r, i) {
	if (!r.isTextblock)
		throw new RangeError(
			"Type given to setBlockType should be a textblock",
		);
	let o = t.steps.length;
	t.doc.nodesBetween(e, n, (s, a) => {
		let l = typeof i == "function" ? i(s) : i;
		if (
			s.isTextblock &&
			!s.hasMarkup(r, l) &&
			Aae(t.doc, t.mapping.slice(o).map(a), r)
		) {
			let u = null;
			if (r.schema.linebreakReplacement) {
				let h = r.whitespace == "pre",
					p = !!r.contentMatch.matchType(
						r.schema.linebreakReplacement,
					);
				h && !p ? (u = !1) : !h && p && (u = !0);
			}
			u === !1 && Sae(t, s, a, o),
				aj(t, t.mapping.slice(o).map(a, 1), r, void 0, u === null);
			let c = t.mapping.slice(o),
				d = c.map(a, 1),
				f = c.map(a + s.nodeSize, 1);
			return (
				t.step(
					new Fr(
						d,
						f,
						d + 1,
						f - 1,
						new Ee(be.from(r.create(l, null, s.marks)), 0, 0),
						1,
						!0,
					),
				),
				u === !0 && Dae(t, s, a, o),
				!1
			);
		}
	});
}
function Dae(t, e, n, r) {
	e.forEach((i, o) => {
		if (i.isText) {
			let s,
				a = /\r?\n|\r/g;
			for (; (s = a.exec(i.text)); ) {
				let l = t.mapping.slice(r).map(n + 1 + o + s.index);
				t.replaceWith(
					l,
					l + 1,
					e.type.schema.linebreakReplacement.create(),
				);
			}
		}
	});
}
function Sae(t, e, n, r) {
	e.forEach((i, o) => {
		if (i.type == i.type.schema.linebreakReplacement) {
			let s = t.mapping.slice(r).map(n + 1 + o);
			t.replaceWith(
				s,
				s + 1,
				e.type.schema.text(`
`),
			);
		}
	});
}
function Aae(t, e, n) {
	let r = t.resolve(e),
		i = r.index();
	return r.parent.canReplaceWith(i, i + 1, n);
}
function $ae(t, e, n, r, i) {
	let o = t.doc.nodeAt(e);
	if (!o) throw new RangeError("No node at given position");
	n || (n = o.type);
	let s = n.create(r, null, i || o.marks);
	if (o.isLeaf) return t.replaceWith(e, e + o.nodeSize, s);
	if (!n.validContent(o.content))
		throw new RangeError("Invalid content for node type " + n.name);
	t.step(
		new Fr(
			e,
			e + o.nodeSize,
			e + 1,
			e + o.nodeSize - 1,
			new Ee(be.from(s), 0, 0),
			1,
			!0,
		),
	);
}
function nh(t, e, n = 1, r) {
	let i = t.resolve(e),
		o = i.depth - n,
		s = (r && r[r.length - 1]) || i.parent;
	if (
		o < 0 ||
		i.parent.type.spec.isolating ||
		!i.parent.canReplace(i.index(), i.parent.childCount) ||
		!s.type.validContent(
			i.parent.content.cutByIndex(i.index(), i.parent.childCount),
		)
	)
		return !1;
	for (let u = i.depth - 1, c = n - 2; u > o; u--, c--) {
		let d = i.node(u),
			f = i.index(u);
		if (d.type.spec.isolating) return !1;
		let h = d.content.cutByIndex(f, d.childCount),
			p = r && r[c + 1];
		p && (h = h.replaceChild(0, p.type.create(p.attrs)));
		let g = (r && r[c]) || d;
		if (!d.canReplace(f + 1, d.childCount) || !g.type.validContent(h))
			return !1;
	}
	let a = i.indexAfter(o),
		l = r && r[0];
	return i.node(o).canReplaceWith(a, a, l ? l.type : i.node(o + 1).type);
}
function Tae(t, e, n = 1, r) {
	let i = t.doc.resolve(e),
		o = be.empty,
		s = be.empty;
	for (let a = i.depth, l = i.depth - n, u = n - 1; a > l; a--, u--) {
		o = be.from(i.node(a).copy(o));
		let c = r && r[u];
		s = be.from(c ? c.type.create(c.attrs, s) : i.node(a).copy(s));
	}
	t.step(new zr(e, e, new Ee(o.append(s), n, n), !0));
}
function Qh(t, e) {
	let n = t.resolve(e),
		r = n.index();
	return lj(n.nodeBefore, n.nodeAfter) && n.parent.canReplace(r, r + 1);
}
function lj(t, e) {
	return !!(t && e && !t.isLeaf && t.canAppend(e));
}
function uj(t, e, n = -1) {
	let r = t.resolve(e);
	for (let i = r.depth; ; i--) {
		let o,
			s,
			a = r.index(i);
		if (
			(i == r.depth
				? ((o = r.nodeBefore), (s = r.nodeAfter))
				: n > 0
					? ((o = r.node(i + 1)), a++, (s = r.node(i).maybeChild(a)))
					: ((o = r.node(i).maybeChild(a - 1)), (s = r.node(i + 1))),
			o && !o.isTextblock && lj(o, s) && r.node(i).canReplace(a, a + 1))
		)
			return e;
		if (i == 0) break;
		e = n < 0 ? r.before(i) : r.after(i);
	}
}
function Bae(t, e, n) {
	let r = new zr(e - n, e + n, Ee.empty, !0);
	t.step(r);
}
function Iae(t, e, n) {
	let r = t.resolve(e);
	if (r.parent.canReplaceWith(r.index(), r.index(), n)) return e;
	if (r.parentOffset == 0)
		for (let i = r.depth - 1; i >= 0; i--) {
			let o = r.index(i);
			if (r.node(i).canReplaceWith(o, o, n)) return r.before(i + 1);
			if (o > 0) return null;
		}
	if (r.parentOffset == r.parent.content.size)
		for (let i = r.depth - 1; i >= 0; i--) {
			let o = r.indexAfter(i);
			if (r.node(i).canReplaceWith(o, o, n)) return r.after(i + 1);
			if (o < r.node(i).childCount) return null;
		}
	return null;
}
function Iv(t, e, n) {
	let r = t.resolve(e);
	if (!n.content.size) return e;
	let i = n.content;
	for (let o = 0; o < n.openStart; o++) i = i.firstChild.content;
	for (let o = 1; o <= (n.openStart == 0 && n.size ? 2 : 1); o++)
		for (let s = r.depth; s >= 0; s--) {
			let a =
					s == r.depth
						? 0
						: r.pos <= (r.start(s + 1) + r.end(s + 1)) / 2
							? -1
							: 1,
				l = r.index(s) + (a > 0 ? 1 : 0),
				u = r.node(s),
				c = !1;
			if (o == 1) c = u.canReplace(l, l, i);
			else {
				let d = u.contentMatchAt(l).findWrapping(i.firstChild.type);
				c = d && u.canReplaceWith(l, l, d[0]);
			}
			if (c)
				return a == 0
					? r.pos
					: a < 0
						? r.before(s + 1)
						: r.after(s + 1);
		}
	return null;
}
function LD(t, e, n = e, r = Ee.empty) {
	if (e == n && !r.size) return null;
	let i = t.resolve(e),
		o = t.resolve(n);
	return cj(i, o, r) ? new zr(e, n, r) : new Fae(i, o, r).fit();
}
function cj(t, e, n) {
	return (
		!n.openStart &&
		!n.openEnd &&
		t.start() == e.start() &&
		t.parent.canReplace(t.index(), e.index(), n.content)
	);
}
class Fae {
	constructor(e, n, r) {
		(this.$from = e),
			(this.$to = n),
			(this.unplaced = r),
			(this.frontier = []),
			(this.placed = be.empty);
		for (let i = 0; i <= e.depth; i++) {
			let o = e.node(i);
			this.frontier.push({
				type: o.type,
				match: o.contentMatchAt(e.indexAfter(i)),
			});
		}
		for (let i = e.depth; i > 0; i--)
			this.placed = be.from(e.node(i).copy(this.placed));
	}
	get depth() {
		return this.frontier.length - 1;
	}
	fit() {
		for (; this.unplaced.size; ) {
			let u = this.findFittable();
			u ? this.placeNodes(u) : this.openMore() || this.dropNode();
		}
		let e = this.mustMoveInline(),
			n = this.placed.size - this.depth - this.$from.depth,
			r = this.$from,
			i = this.close(e < 0 ? this.$to : r.doc.resolve(e));
		if (!i) return null;
		let o = this.placed,
			s = r.depth,
			a = i.depth;
		for (; s && a && o.childCount == 1; )
			(o = o.firstChild.content), s--, a--;
		let l = new Ee(o, s, a);
		return e > -1
			? new Fr(r.pos, e, this.$to.pos, this.$to.end(), l, n)
			: l.size || r.pos != this.$to.pos
				? new zr(r.pos, i.pos, l)
				: null;
	}
	findFittable() {
		let e = this.unplaced.openStart;
		for (
			let n = this.unplaced.content, r = 0, i = this.unplaced.openEnd;
			r < e;
			r++
		) {
			let o = n.firstChild;
			if (
				(n.childCount > 1 && (i = 0), o.type.spec.isolating && i <= r)
			) {
				e = r;
				break;
			}
			n = o.content;
		}
		for (let n = 1; n <= 2; n++)
			for (let r = n == 1 ? e : this.unplaced.openStart; r >= 0; r--) {
				let i,
					o = null;
				r
					? ((o = J4(this.unplaced.content, r - 1).firstChild),
						(i = o.content))
					: (i = this.unplaced.content);
				let s = i.firstChild;
				for (let a = this.depth; a >= 0; a--) {
					let { type: l, match: u } = this.frontier[a],
						c,
						d = null;
					if (
						n == 1 &&
						(s
							? u.matchType(s.type) ||
								(d = u.fillBefore(be.from(s), !1))
							: o && l.compatibleContent(o.type))
					)
						return {
							sliceDepth: r,
							frontierDepth: a,
							parent: o,
							inject: d,
						};
					if (n == 2 && s && (c = u.findWrapping(s.type)))
						return {
							sliceDepth: r,
							frontierDepth: a,
							parent: o,
							wrap: c,
						};
					if (o && u.matchType(o.type)) break;
				}
			}
	}
	openMore() {
		let { content: e, openStart: n, openEnd: r } = this.unplaced,
			i = J4(e, n);
		return !i.childCount || i.firstChild.isLeaf
			? !1
			: ((this.unplaced = new Ee(
					e,
					n + 1,
					Math.max(r, i.size + n >= e.size - r ? n + 1 : 0),
				)),
				!0);
	}
	dropNode() {
		let { content: e, openStart: n, openEnd: r } = this.unplaced,
			i = J4(e, n);
		if (i.childCount <= 1 && n > 0) {
			let o = e.size - n <= n + i.size;
			this.unplaced = new Ee(Jp(e, n - 1, 1), n - 1, o ? n - 1 : r);
		} else this.unplaced = new Ee(Jp(e, n, 1), n, r);
	}
	placeNodes({
		sliceDepth: e,
		frontierDepth: n,
		parent: r,
		inject: i,
		wrap: o,
	}) {
		for (; this.depth > n; ) this.closeFrontierNode();
		if (o) for (let g = 0; g < o.length; g++) this.openFrontierNode(o[g]);
		let s = this.unplaced,
			a = r ? r.content : s.content,
			l = s.openStart - e,
			u = 0,
			c = [],
			{ match: d, type: f } = this.frontier[n];
		if (i) {
			for (let g = 0; g < i.childCount; g++) c.push(i.child(g));
			d = d.matchFragment(i);
		}
		let h = a.size + e - (s.content.size - s.openEnd);
		for (; u < a.childCount; ) {
			let g = a.child(u),
				v = d.matchType(g.type);
			if (!v) break;
			u++,
				(u > 1 || l == 0 || g.content.size) &&
					((d = v),
					c.push(
						dj(
							g.mark(f.allowedMarks(g.marks)),
							u == 1 ? l : 0,
							u == a.childCount ? h : -1,
						),
					));
		}
		let p = u == a.childCount;
		p || (h = -1),
			(this.placed = Xp(this.placed, n, be.from(c))),
			(this.frontier[n].match = d),
			p &&
				h < 0 &&
				r &&
				r.type == this.frontier[this.depth].type &&
				this.frontier.length > 1 &&
				this.closeFrontierNode();
		for (let g = 0, v = a; g < h; g++) {
			let b = v.lastChild;
			this.frontier.push({
				type: b.type,
				match: b.contentMatchAt(b.childCount),
			}),
				(v = b.content);
		}
		this.unplaced = p
			? e == 0
				? Ee.empty
				: new Ee(
						Jp(s.content, e - 1, 1),
						e - 1,
						h < 0 ? s.openEnd : e - 1,
					)
			: new Ee(Jp(s.content, e, u), s.openStart, s.openEnd);
	}
	mustMoveInline() {
		if (!this.$to.parent.isTextblock) return -1;
		let e = this.frontier[this.depth],
			n;
		if (
			!e.type.isTextblock ||
			!X4(this.$to, this.$to.depth, e.type, e.match, !1) ||
			(this.$to.depth == this.depth &&
				(n = this.findCloseLevel(this.$to)) &&
				n.depth == this.depth)
		)
			return -1;
		let { depth: r } = this.$to,
			i = this.$to.after(r);
		for (; r > 1 && i == this.$to.end(--r); ) ++i;
		return i;
	}
	findCloseLevel(e) {
		e: for (let n = Math.min(this.depth, e.depth); n >= 0; n--) {
			let { match: r, type: i } = this.frontier[n],
				o = n < e.depth && e.end(n + 1) == e.pos + (e.depth - (n + 1)),
				s = X4(e, n, i, r, o);
			if (s) {
				for (let a = n - 1; a >= 0; a--) {
					let { match: l, type: u } = this.frontier[a],
						c = X4(e, a, u, l, !0);
					if (!c || c.childCount) continue e;
				}
				return {
					depth: n,
					fit: s,
					move: o ? e.doc.resolve(e.after(n + 1)) : e,
				};
			}
		}
	}
	close(e) {
		let n = this.findCloseLevel(e);
		if (!n) return null;
		for (; this.depth > n.depth; ) this.closeFrontierNode();
		n.fit.childCount && (this.placed = Xp(this.placed, n.depth, n.fit)),
			(e = n.move);
		for (let r = n.depth + 1; r <= e.depth; r++) {
			let i = e.node(r),
				o = i.type.contentMatch.fillBefore(i.content, !0, e.index(r));
			this.openFrontierNode(i.type, i.attrs, o);
		}
		return e;
	}
	openFrontierNode(e, n = null, r) {
		let i = this.frontier[this.depth];
		(i.match = i.match.matchType(e)),
			(this.placed = Xp(
				this.placed,
				this.depth,
				be.from(e.create(n, r)),
			)),
			this.frontier.push({ type: e, match: e.contentMatch });
	}
	closeFrontierNode() {
		let n = this.frontier.pop().match.fillBefore(be.empty, !0);
		n.childCount &&
			(this.placed = Xp(this.placed, this.frontier.length, n));
	}
}
function Jp(t, e, n) {
	return e == 0
		? t.cutByIndex(n, t.childCount)
		: t.replaceChild(
				0,
				t.firstChild.copy(Jp(t.firstChild.content, e - 1, n)),
			);
}
function Xp(t, e, n) {
	return e == 0
		? t.append(n)
		: t.replaceChild(
				t.childCount - 1,
				t.lastChild.copy(Xp(t.lastChild.content, e - 1, n)),
			);
}
function J4(t, e) {
	for (let n = 0; n < e; n++) t = t.firstChild.content;
	return t;
}
function dj(t, e, n) {
	if (e <= 0) return t;
	let r = t.content;
	return (
		e > 1 &&
			(r = r.replaceChild(
				0,
				dj(r.firstChild, e - 1, r.childCount == 1 ? n - 1 : 0),
			)),
		e > 0 &&
			((r = t.type.contentMatch.fillBefore(r).append(r)),
			n <= 0 &&
				(r = r.append(
					t.type.contentMatch
						.matchFragment(r)
						.fillBefore(be.empty, !0),
				))),
		t.copy(r)
	);
}
function X4(t, e, n, r, i) {
	let o = t.node(e),
		s = i ? t.indexAfter(e) : t.index(e);
	if (s == o.childCount && !n.compatibleContent(o.type)) return null;
	let a = r.fillBefore(o.content, !0, s);
	return a && !Pae(n, o.content, s) ? a : null;
}
function Pae(t, e, n) {
	for (let r = n; r < e.childCount; r++)
		if (!t.allowsMarks(e.child(r).marks)) return !0;
	return !1;
}
function Nae(t) {
	return t.spec.defining || t.spec.definingForContent;
}
function Rae(t, e, n, r) {
	if (!r.size) return t.deleteRange(e, n);
	let i = t.doc.resolve(e),
		o = t.doc.resolve(n);
	if (cj(i, o, r)) return t.step(new zr(e, n, r));
	let s = hj(i, t.doc.resolve(n));
	s[s.length - 1] == 0 && s.pop();
	let a = -(i.depth + 1);
	s.unshift(a);
	for (let f = i.depth, h = i.pos - 1; f > 0; f--, h--) {
		let p = i.node(f).type.spec;
		if (p.defining || p.definingAsContext || p.isolating) break;
		s.indexOf(f) > -1 ? (a = f) : i.before(f) == h && s.splice(1, 0, -f);
	}
	let l = s.indexOf(a),
		u = [],
		c = r.openStart;
	for (let f = r.content, h = 0; ; h++) {
		let p = f.firstChild;
		if ((u.push(p), h == r.openStart)) break;
		f = p.content;
	}
	for (let f = c - 1; f >= 0; f--) {
		let h = u[f],
			p = Nae(h.type);
		if (p && !h.sameMarkup(i.node(Math.abs(a) - 1))) c = f;
		else if (p || !h.type.isTextblock) break;
	}
	for (let f = r.openStart; f >= 0; f--) {
		let h = (f + c + 1) % (r.openStart + 1),
			p = u[h];
		if (p)
			for (let g = 0; g < s.length; g++) {
				let v = s[(g + l) % s.length],
					b = !0;
				v < 0 && ((b = !1), (v = -v));
				let y = i.node(v - 1),
					x = i.index(v - 1);
				if (y.canReplaceWith(x, x, p.type, p.marks))
					return t.replace(
						i.before(v),
						b ? o.after(v) : n,
						new Ee(fj(r.content, 0, r.openStart, h), h, r.openEnd),
					);
			}
	}
	let d = t.steps.length;
	for (
		let f = s.length - 1;
		f >= 0 && (t.replace(e, n, r), !(t.steps.length > d));
		f--
	) {
		let h = s[f];
		h < 0 || ((e = i.before(h)), (n = o.after(h)));
	}
}
function fj(t, e, n, r, i) {
	if (e < n) {
		let o = t.firstChild;
		t = t.replaceChild(0, o.copy(fj(o.content, e + 1, n, r, o)));
	}
	if (e > r) {
		let o = i.contentMatchAt(0),
			s = o.fillBefore(t).append(t);
		t = s.append(o.matchFragment(s).fillBefore(be.empty, !0));
	}
	return t;
}
function Oae(t, e, n, r) {
	if (!r.isInline && e == n && t.doc.resolve(e).parent.content.size) {
		let i = Iae(t.doc, e, r.type);
		i != null && (e = n = i);
	}
	t.replaceRange(e, n, new Ee(be.from(r), 0, 0));
}
function Mae(t, e, n) {
	let r = t.doc.resolve(e),
		i = t.doc.resolve(n),
		o = hj(r, i);
	for (let s = 0; s < o.length; s++) {
		let a = o[s],
			l = s == o.length - 1;
		if ((l && a == 0) || r.node(a).type.contentMatch.validEnd)
			return t.delete(r.start(a), i.end(a));
		if (
			a > 0 &&
			(l || r.node(a - 1).canReplace(r.index(a - 1), i.indexAfter(a - 1)))
		)
			return t.delete(r.before(a), i.after(a));
	}
	for (let s = 1; s <= r.depth && s <= i.depth; s++)
		if (
			e - r.start(s) == r.depth - s &&
			n > r.end(s) &&
			i.end(s) - n != i.depth - s
		)
			return t.delete(r.before(s), n);
	t.delete(e, n);
}
function hj(t, e) {
	let n = [],
		r = Math.min(t.depth, e.depth);
	for (let i = r; i >= 0; i--) {
		let o = t.start(i);
		if (
			o < t.pos - (t.depth - i) ||
			e.end(i) > e.pos + (e.depth - i) ||
			t.node(i).type.spec.isolating ||
			e.node(i).type.spec.isolating
		)
			break;
		(o == e.start(i) ||
			(i == t.depth &&
				i == e.depth &&
				t.parent.inlineContent &&
				e.parent.inlineContent &&
				i &&
				e.start(i - 1) == o - 1)) &&
			n.push(i);
	}
	return n;
}
class rh extends Jr {
	constructor(e, n, r) {
		super(), (this.pos = e), (this.attr = n), (this.value = r);
	}
	apply(e) {
		let n = e.nodeAt(this.pos);
		if (!n) return Un.fail("No node at attribute step's position");
		let r = Object.create(null);
		for (let o in n.attrs) r[o] = n.attrs[o];
		r[this.attr] = this.value;
		let i = n.type.create(r, null, n.marks);
		return Un.fromReplace(
			e,
			this.pos,
			this.pos + 1,
			new Ee(be.from(i), 0, n.isLeaf ? 0 : 1),
		);
	}
	getMap() {
		return to.empty;
	}
	invert(e) {
		return new rh(this.pos, this.attr, e.nodeAt(this.pos).attrs[this.attr]);
	}
	map(e) {
		let n = e.mapResult(this.pos, 1);
		return n.deletedAfter ? null : new rh(n.pos, this.attr, this.value);
	}
	toJSON() {
		return {
			stepType: "attr",
			pos: this.pos,
			attr: this.attr,
			value: this.value,
		};
	}
	static fromJSON(e, n) {
		if (typeof n.pos != "number" || typeof n.attr != "string")
			throw new RangeError("Invalid input for AttrStep.fromJSON");
		return new rh(n.pos, n.attr, n.value);
	}
}
Jr.jsonID("attr", rh);
class Xm extends Jr {
	constructor(e, n) {
		super(), (this.attr = e), (this.value = n);
	}
	apply(e) {
		let n = Object.create(null);
		for (let i in e.attrs) n[i] = e.attrs[i];
		n[this.attr] = this.value;
		let r = e.type.create(n, e.content, e.marks);
		return Un.ok(r);
	}
	getMap() {
		return to.empty;
	}
	invert(e) {
		return new Xm(this.attr, e.attrs[this.attr]);
	}
	map(e) {
		return this;
	}
	toJSON() {
		return { stepType: "docAttr", attr: this.attr, value: this.value };
	}
	static fromJSON(e, n) {
		if (typeof n.attr != "string")
			throw new RangeError("Invalid input for DocAttrStep.fromJSON");
		return new Xm(n.attr, n.value);
	}
}
Jr.jsonID("docAttr", Xm);
let Ch = class extends Error {};
Ch = function t(e) {
	let n = Error.call(this, e);
	return (n.__proto__ = t.prototype), n;
};
Ch.prototype = Object.create(Error.prototype);
Ch.prototype.constructor = Ch;
Ch.prototype.name = "TransformError";
class pj {
	constructor(e) {
		(this.doc = e),
			(this.steps = []),
			(this.docs = []),
			(this.mapping = new th());
	}
	get before() {
		return this.docs.length ? this.docs[0] : this.doc;
	}
	step(e) {
		let n = this.maybeStep(e);
		if (n.failed) throw new Ch(n.failed);
		return this;
	}
	maybeStep(e) {
		let n = e.apply(this.doc);
		return n.failed || this.addStep(e, n.doc), n;
	}
	get docChanged() {
		return this.steps.length > 0;
	}
	addStep(e, n) {
		this.docs.push(this.doc),
			this.steps.push(e),
			this.mapping.appendMap(e.getMap()),
			(this.doc = n);
	}
	replace(e, n = e, r = Ee.empty) {
		let i = LD(this.doc, e, n, r);
		return i && this.step(i), this;
	}
	replaceWith(e, n, r) {
		return this.replace(e, n, new Ee(be.from(r), 0, 0));
	}
	delete(e, n) {
		return this.replace(e, n, Ee.empty);
	}
	insert(e, n) {
		return this.replaceWith(e, e, n);
	}
	replaceRange(e, n, r) {
		return Rae(this, e, n, r), this;
	}
	replaceRangeWith(e, n, r) {
		return Oae(this, e, n, r), this;
	}
	deleteRange(e, n) {
		return Mae(this, e, n), this;
	}
	lift(e, n) {
		return xae(this, e, n), this;
	}
	join(e, n = 1) {
		return Bae(this, e, n), this;
	}
	wrap(e, n) {
		return wae(this, e, n), this;
	}
	setBlockType(e, n = e, r, i = null) {
		return Eae(this, e, n, r, i), this;
	}
	setNodeMarkup(e, n, r = null, i) {
		return $ae(this, e, n, r, i), this;
	}
	setNodeAttribute(e, n, r) {
		return this.step(new rh(e, n, r)), this;
	}
	setDocAttribute(e, n) {
		return this.step(new Xm(e, n)), this;
	}
	addNodeMark(e, n) {
		return this.step(new gu(e, n)), this;
	}
	removeNodeMark(e, n) {
		if (!(n instanceof zt)) {
			let r = this.doc.nodeAt(e);
			if (!r) throw new RangeError("No node at position " + e);
			if (((n = n.isInSet(r.marks)), !n)) return this;
		}
		return this.step(new kh(e, n)), this;
	}
	split(e, n = 1, r) {
		return Tae(this, e, n, r), this;
	}
	addMark(e, n, r) {
		return bae(this, e, n, r), this;
	}
	removeMark(e, n, r) {
		return vae(this, e, n, r), this;
	}
	clearIncompatible(e, n, r) {
		return aj(this, e, n, r), this;
	}
}
const Z4 = Object.create(null);
class mt {
	constructor(e, n, r) {
		(this.$anchor = e),
			(this.$head = n),
			(this.ranges = r || [new mj(e.min(n), e.max(n))]);
	}
	get anchor() {
		return this.$anchor.pos;
	}
	get head() {
		return this.$head.pos;
	}
	get from() {
		return this.$from.pos;
	}
	get to() {
		return this.$to.pos;
	}
	get $from() {
		return this.ranges[0].$from;
	}
	get $to() {
		return this.ranges[0].$to;
	}
	get empty() {
		let e = this.ranges;
		for (let n = 0; n < e.length; n++)
			if (e[n].$from.pos != e[n].$to.pos) return !1;
		return !0;
	}
	content() {
		return this.$from.doc.slice(this.from, this.to, !0);
	}
	replace(e, n = Ee.empty) {
		let r = n.content.lastChild,
			i = null;
		for (let a = 0; a < n.openEnd; a++) (i = r), (r = r.lastChild);
		let o = e.steps.length,
			s = this.ranges;
		for (let a = 0; a < s.length; a++) {
			let { $from: l, $to: u } = s[a],
				c = e.mapping.slice(o);
			e.replaceRange(c.map(l.pos), c.map(u.pos), a ? Ee.empty : n),
				a == 0 &&
					A$(e, o, (r ? r.isInline : i && i.isTextblock) ? -1 : 1);
		}
	}
	replaceWith(e, n) {
		let r = e.steps.length,
			i = this.ranges;
		for (let o = 0; o < i.length; o++) {
			let { $from: s, $to: a } = i[o],
				l = e.mapping.slice(r),
				u = l.map(s.pos),
				c = l.map(a.pos);
			o
				? e.deleteRange(u, c)
				: (e.replaceRangeWith(u, c, n), A$(e, r, n.isInline ? -1 : 1));
		}
	}
	static findFrom(e, n, r = !1) {
		let i = e.parent.inlineContent
			? new kt(e)
			: $f(e.node(0), e.parent, e.pos, e.index(), n, r);
		if (i) return i;
		for (let o = e.depth - 1; o >= 0; o--) {
			let s =
				n < 0
					? $f(
							e.node(0),
							e.node(o),
							e.before(o + 1),
							e.index(o),
							n,
							r,
						)
					: $f(
							e.node(0),
							e.node(o),
							e.after(o + 1),
							e.index(o) + 1,
							n,
							r,
						);
			if (s) return s;
		}
		return null;
	}
	static near(e, n = 1) {
		return this.findFrom(e, n) || this.findFrom(e, -n) || new ji(e.node(0));
	}
	static atStart(e) {
		return $f(e, e, 0, 0, 1) || new ji(e);
	}
	static atEnd(e) {
		return $f(e, e, e.content.size, e.childCount, -1) || new ji(e);
	}
	static fromJSON(e, n) {
		if (!n || !n.type)
			throw new RangeError("Invalid input for Selection.fromJSON");
		let r = Z4[n.type];
		if (!r) throw new RangeError(`No selection type ${n.type} defined`);
		return r.fromJSON(e, n);
	}
	static jsonID(e, n) {
		if (e in Z4)
			throw new RangeError("Duplicate use of selection JSON ID " + e);
		return (Z4[e] = n), (n.prototype.jsonID = e), n;
	}
	getBookmark() {
		return kt.between(this.$anchor, this.$head).getBookmark();
	}
}
mt.prototype.visible = !0;
class mj {
	constructor(e, n) {
		(this.$from = e), (this.$to = n);
	}
}
let D$ = !1;
function S$(t) {
	!D$ &&
		!t.parent.inlineContent &&
		((D$ = !0),
		console.warn(
			"TextSelection endpoint not pointing into a node with inline content (" +
				t.parent.type.name +
				")",
		));
}
class kt extends mt {
	constructor(e, n = e) {
		S$(e), S$(n), super(e, n);
	}
	get $cursor() {
		return this.$anchor.pos == this.$head.pos ? this.$head : null;
	}
	map(e, n) {
		let r = e.resolve(n.map(this.head));
		if (!r.parent.inlineContent) return mt.near(r);
		let i = e.resolve(n.map(this.anchor));
		return new kt(i.parent.inlineContent ? i : r, r);
	}
	replace(e, n = Ee.empty) {
		if ((super.replace(e, n), n == Ee.empty)) {
			let r = this.$from.marksAcross(this.$to);
			r && e.ensureMarks(r);
		}
	}
	eq(e) {
		return (
			e instanceof kt && e.anchor == this.anchor && e.head == this.head
		);
	}
	getBookmark() {
		return new Ox(this.anchor, this.head);
	}
	toJSON() {
		return { type: "text", anchor: this.anchor, head: this.head };
	}
	static fromJSON(e, n) {
		if (typeof n.anchor != "number" || typeof n.head != "number")
			throw new RangeError("Invalid input for TextSelection.fromJSON");
		return new kt(e.resolve(n.anchor), e.resolve(n.head));
	}
	static create(e, n, r = n) {
		let i = e.resolve(n);
		return new this(i, r == n ? i : e.resolve(r));
	}
	static between(e, n, r) {
		let i = e.pos - n.pos;
		if (((!r || i) && (r = i >= 0 ? 1 : -1), !n.parent.inlineContent)) {
			let o = mt.findFrom(n, r, !0) || mt.findFrom(n, -r, !0);
			if (o) n = o.$head;
			else return mt.near(n, r);
		}
		return (
			e.parent.inlineContent ||
				(i == 0
					? (e = n)
					: ((e = (mt.findFrom(e, -r, !0) || mt.findFrom(e, r, !0))
							.$anchor),
						e.pos < n.pos != i < 0 && (e = n))),
			new kt(e, n)
		);
	}
}
mt.jsonID("text", kt);
class Ox {
	constructor(e, n) {
		(this.anchor = e), (this.head = n);
	}
	map(e) {
		return new Ox(e.map(this.anchor), e.map(this.head));
	}
	resolve(e) {
		return kt.between(e.resolve(this.anchor), e.resolve(this.head));
	}
}
class Qe extends mt {
	constructor(e) {
		let n = e.nodeAfter,
			r = e.node(0).resolve(e.pos + n.nodeSize);
		super(e, r), (this.node = n);
	}
	map(e, n) {
		let { deleted: r, pos: i } = n.mapResult(this.anchor),
			o = e.resolve(i);
		return r ? mt.near(o) : new Qe(o);
	}
	content() {
		return new Ee(be.from(this.node), 0, 0);
	}
	eq(e) {
		return e instanceof Qe && e.anchor == this.anchor;
	}
	toJSON() {
		return { type: "node", anchor: this.anchor };
	}
	getBookmark() {
		return new VD(this.anchor);
	}
	static fromJSON(e, n) {
		if (typeof n.anchor != "number")
			throw new RangeError("Invalid input for NodeSelection.fromJSON");
		return new Qe(e.resolve(n.anchor));
	}
	static create(e, n) {
		return new Qe(e.resolve(n));
	}
	static isSelectable(e) {
		return !e.isText && e.type.spec.selectable !== !1;
	}
}
Qe.prototype.visible = !1;
mt.jsonID("node", Qe);
class VD {
	constructor(e) {
		this.anchor = e;
	}
	map(e) {
		let { deleted: n, pos: r } = e.mapResult(this.anchor);
		return n ? new Ox(r, r) : new VD(r);
	}
	resolve(e) {
		let n = e.resolve(this.anchor),
			r = n.nodeAfter;
		return r && Qe.isSelectable(r) ? new Qe(n) : mt.near(n);
	}
}
class ji extends mt {
	constructor(e) {
		super(e.resolve(0), e.resolve(e.content.size));
	}
	replace(e, n = Ee.empty) {
		if (n == Ee.empty) {
			e.delete(0, e.doc.content.size);
			let r = mt.atStart(e.doc);
			r.eq(e.selection) || e.setSelection(r);
		} else super.replace(e, n);
	}
	toJSON() {
		return { type: "all" };
	}
	static fromJSON(e) {
		return new ji(e);
	}
	map(e) {
		return new ji(e);
	}
	eq(e) {
		return e instanceof ji;
	}
	getBookmark() {
		return jae;
	}
}
mt.jsonID("all", ji);
const jae = {
	map() {
		return this;
	},
	resolve(t) {
		return new ji(t);
	},
};
function $f(t, e, n, r, i, o = !1) {
	if (e.inlineContent) return kt.create(t, n);
	for (
		let s = r - (i > 0 ? 0 : 1);
		i > 0 ? s < e.childCount : s >= 0;
		s += i
	) {
		let a = e.child(s);
		if (a.isAtom) {
			if (!o && Qe.isSelectable(a))
				return Qe.create(t, n - (i < 0 ? a.nodeSize : 0));
		} else {
			let l = $f(t, a, n + i, i < 0 ? a.childCount : 0, i, o);
			if (l) return l;
		}
		n += a.nodeSize * i;
	}
	return null;
}
function A$(t, e, n) {
	let r = t.steps.length - 1;
	if (r < e) return;
	let i = t.steps[r];
	if (!(i instanceof zr || i instanceof Fr)) return;
	let o = t.mapping.maps[r],
		s;
	o.forEach((a, l, u, c) => {
		s == null && (s = c);
	}),
		t.setSelection(mt.near(t.doc.resolve(s), n));
}
const $$ = 1,
	k1 = 2,
	T$ = 4;
let _ae = class extends pj {
	constructor(e) {
		super(e.doc),
			(this.curSelectionFor = 0),
			(this.updated = 0),
			(this.meta = Object.create(null)),
			(this.time = Date.now()),
			(this.curSelection = e.selection),
			(this.storedMarks = e.storedMarks);
	}
	get selection() {
		return (
			this.curSelectionFor < this.steps.length &&
				((this.curSelection = this.curSelection.map(
					this.doc,
					this.mapping.slice(this.curSelectionFor),
				)),
				(this.curSelectionFor = this.steps.length)),
			this.curSelection
		);
	}
	setSelection(e) {
		if (e.$from.doc != this.doc)
			throw new RangeError(
				"Selection passed to setSelection must point at the current document",
			);
		return (
			(this.curSelection = e),
			(this.curSelectionFor = this.steps.length),
			(this.updated = (this.updated | $$) & ~k1),
			(this.storedMarks = null),
			this
		);
	}
	get selectionSet() {
		return (this.updated & $$) > 0;
	}
	setStoredMarks(e) {
		return (this.storedMarks = e), (this.updated |= k1), this;
	}
	ensureMarks(e) {
		return (
			zt.sameSet(this.storedMarks || this.selection.$from.marks(), e) ||
				this.setStoredMarks(e),
			this
		);
	}
	addStoredMark(e) {
		return this.ensureMarks(
			e.addToSet(this.storedMarks || this.selection.$head.marks()),
		);
	}
	removeStoredMark(e) {
		return this.ensureMarks(
			e.removeFromSet(this.storedMarks || this.selection.$head.marks()),
		);
	}
	get storedMarksSet() {
		return (this.updated & k1) > 0;
	}
	addStep(e, n) {
		super.addStep(e, n),
			(this.updated = this.updated & ~k1),
			(this.storedMarks = null);
	}
	setTime(e) {
		return (this.time = e), this;
	}
	replaceSelection(e) {
		return this.selection.replace(this, e), this;
	}
	replaceSelectionWith(e, n = !0) {
		let r = this.selection;
		return (
			n &&
				(e = e.mark(
					this.storedMarks ||
						(r.empty
							? r.$from.marks()
							: r.$from.marksAcross(r.$to) || zt.none),
				)),
			r.replaceWith(this, e),
			this
		);
	}
	deleteSelection() {
		return this.selection.replace(this), this;
	}
	insertText(e, n, r) {
		let i = this.doc.type.schema;
		if (n == null)
			return e
				? this.replaceSelectionWith(i.text(e), !0)
				: this.deleteSelection();
		{
			if ((r == null && (r = n), (r = r ?? n), !e))
				return this.deleteRange(n, r);
			let o = this.storedMarks;
			if (!o) {
				let s = this.doc.resolve(n);
				o = r == n ? s.marks() : s.marksAcross(this.doc.resolve(r));
			}
			return (
				this.replaceRangeWith(n, r, i.text(e, o)),
				this.selection.empty ||
					this.setSelection(mt.near(this.selection.$to)),
				this
			);
		}
	}
	setMeta(e, n) {
		return (this.meta[typeof e == "string" ? e : e.key] = n), this;
	}
	getMeta(e) {
		return this.meta[typeof e == "string" ? e : e.key];
	}
	get isGeneric() {
		for (let e in this.meta) return !1;
		return !0;
	}
	scrollIntoView() {
		return (this.updated |= T$), this;
	}
	get scrolledIntoView() {
		return (this.updated & T$) > 0;
	}
};
function B$(t, e) {
	return !e || !t ? t : t.bind(e);
}
class Zp {
	constructor(e, n, r) {
		(this.name = e),
			(this.init = B$(n.init, r)),
			(this.apply = B$(n.apply, r));
	}
}
const zae = [
	new Zp("doc", {
		init(t) {
			return t.doc || t.schema.topNodeType.createAndFill();
		},
		apply(t) {
			return t.doc;
		},
	}),
	new Zp("selection", {
		init(t, e) {
			return t.selection || mt.atStart(e.doc);
		},
		apply(t) {
			return t.selection;
		},
	}),
	new Zp("storedMarks", {
		init(t) {
			return t.storedMarks || null;
		},
		apply(t, e, n, r) {
			return r.selection.$cursor ? t.storedMarks : null;
		},
	}),
	new Zp("scrollToSelection", {
		init() {
			return 0;
		},
		apply(t, e) {
			return t.scrolledIntoView ? e + 1 : e;
		},
	}),
];
class Q4 {
	constructor(e, n) {
		(this.schema = e),
			(this.plugins = []),
			(this.pluginsByKey = Object.create(null)),
			(this.fields = zae.slice()),
			n &&
				n.forEach((r) => {
					if (this.pluginsByKey[r.key])
						throw new RangeError(
							"Adding different instances of a keyed plugin (" +
								r.key +
								")",
						);
					this.plugins.push(r),
						(this.pluginsByKey[r.key] = r),
						r.spec.state &&
							this.fields.push(new Zp(r.key, r.spec.state, r));
				});
	}
}
class _f {
	constructor(e) {
		this.config = e;
	}
	get schema() {
		return this.config.schema;
	}
	get plugins() {
		return this.config.plugins;
	}
	apply(e) {
		return this.applyTransaction(e).state;
	}
	filterTransaction(e, n = -1) {
		for (let r = 0; r < this.config.plugins.length; r++)
			if (r != n) {
				let i = this.config.plugins[r];
				if (
					i.spec.filterTransaction &&
					!i.spec.filterTransaction.call(i, e, this)
				)
					return !1;
			}
		return !0;
	}
	applyTransaction(e) {
		if (!this.filterTransaction(e))
			return { state: this, transactions: [] };
		let n = [e],
			r = this.applyInner(e),
			i = null;
		for (;;) {
			let o = !1;
			for (let s = 0; s < this.config.plugins.length; s++) {
				let a = this.config.plugins[s];
				if (a.spec.appendTransaction) {
					let l = i ? i[s].n : 0,
						u = i ? i[s].state : this,
						c =
							l < n.length &&
							a.spec.appendTransaction.call(
								a,
								l ? n.slice(l) : n,
								u,
								r,
							);
					if (c && r.filterTransaction(c, s)) {
						if ((c.setMeta("appendedTransaction", e), !i)) {
							i = [];
							for (let d = 0; d < this.config.plugins.length; d++)
								i.push(
									d < s
										? { state: r, n: n.length }
										: { state: this, n: 0 },
								);
						}
						n.push(c), (r = r.applyInner(c)), (o = !0);
					}
					i && (i[s] = { state: r, n: n.length });
				}
			}
			if (!o) return { state: r, transactions: n };
		}
	}
	applyInner(e) {
		if (!e.before.eq(this.doc))
			throw new RangeError("Applying a mismatched transaction");
		let n = new _f(this.config),
			r = this.config.fields;
		for (let i = 0; i < r.length; i++) {
			let o = r[i];
			n[o.name] = o.apply(e, this[o.name], this, n);
		}
		return n;
	}
	get tr() {
		return new _ae(this);
	}
	static create(e) {
		let n = new Q4(e.doc ? e.doc.type.schema : e.schema, e.plugins),
			r = new _f(n);
		for (let i = 0; i < n.fields.length; i++)
			r[n.fields[i].name] = n.fields[i].init(e, r);
		return r;
	}
	reconfigure(e) {
		let n = new Q4(this.schema, e.plugins),
			r = n.fields,
			i = new _f(n);
		for (let o = 0; o < r.length; o++) {
			let s = r[o].name;
			i[s] = this.hasOwnProperty(s) ? this[s] : r[o].init(e, i);
		}
		return i;
	}
	toJSON(e) {
		let n = { doc: this.doc.toJSON(), selection: this.selection.toJSON() };
		if (
			(this.storedMarks &&
				(n.storedMarks = this.storedMarks.map((r) => r.toJSON())),
			e && typeof e == "object")
		)
			for (let r in e) {
				if (r == "doc" || r == "selection")
					throw new RangeError(
						"The JSON fields `doc` and `selection` are reserved",
					);
				let i = e[r],
					o = i.spec.state;
				o && o.toJSON && (n[r] = o.toJSON.call(i, this[i.key]));
			}
		return n;
	}
	static fromJSON(e, n, r) {
		if (!n) throw new RangeError("Invalid input for EditorState.fromJSON");
		if (!e.schema)
			throw new RangeError("Required config field 'schema' missing");
		let i = new Q4(e.schema, e.plugins),
			o = new _f(i);
		return (
			i.fields.forEach((s) => {
				if (s.name == "doc") o.doc = ia.fromJSON(e.schema, n.doc);
				else if (s.name == "selection")
					o.selection = mt.fromJSON(o.doc, n.selection);
				else if (s.name == "storedMarks")
					n.storedMarks &&
						(o.storedMarks = n.storedMarks.map(
							e.schema.markFromJSON,
						));
				else {
					if (r)
						for (let a in r) {
							let l = r[a],
								u = l.spec.state;
							if (
								l.key == s.name &&
								u &&
								u.fromJSON &&
								Object.prototype.hasOwnProperty.call(n, a)
							) {
								o[s.name] = u.fromJSON.call(l, e, n[a], o);
								return;
							}
						}
					o[s.name] = s.init(e, o);
				}
			}),
			o
		);
	}
}
function gj(t, e, n) {
	for (let r in t) {
		let i = t[r];
		i instanceof Function
			? (i = i.bind(e))
			: r == "handleDOMEvents" && (i = gj(i, e, {})),
			(n[r] = i);
	}
	return n;
}
class Gn {
	constructor(e) {
		(this.spec = e),
			(this.props = {}),
			e.props && gj(e.props, this, this.props),
			(this.key = e.key ? e.key.key : bj("plugin"));
	}
	getState(e) {
		return e[this.key];
	}
}
const ek = Object.create(null);
function bj(t) {
	return t in ek ? t + "$" + ++ek[t] : ((ek[t] = 0), t + "$");
}
class Os {
	constructor(e = "key") {
		this.key = bj(e);
	}
	get(e) {
		return e.config.pluginsByKey[this.key];
	}
	getState(e) {
		return e[this.key];
	}
}
const I$ = (t, e) =>
	t.selection.empty
		? !1
		: (e && e(t.tr.deleteSelection().scrollIntoView()), !0);
function Lae(t, e) {
	let { $cursor: n } = t.selection;
	return !n || (e ? !e.endOfTextblock("backward", t) : n.parentOffset > 0)
		? null
		: n;
}
const Vae = (t, e, n) => {
	let r = Lae(t, n);
	if (!r) return !1;
	let i = vj(r);
	if (!i) {
		let s = r.blockRange(),
			a = s && v0(s);
		return a == null ? !1 : (e && e(t.tr.lift(s, a).scrollIntoView()), !0);
	}
	let o = i.nodeBefore;
	if (Ej(t, i, e, -1)) return !0;
	if (r.parent.content.size == 0 && (wh(o, "end") || Qe.isSelectable(o)))
		for (let s = r.depth; ; s--) {
			let a = LD(t.doc, r.before(s), r.after(s), Ee.empty);
			if (a && a.slice.size < a.to - a.from) {
				if (e) {
					let l = t.tr.step(a);
					l.setSelection(
						wh(o, "end")
							? mt.findFrom(
									l.doc.resolve(l.mapping.map(i.pos, -1)),
									-1,
								)
							: Qe.create(l.doc, i.pos - o.nodeSize),
					),
						e(l.scrollIntoView());
				}
				return !0;
			}
			if (s == 1 || r.node(s - 1).childCount > 1) break;
		}
	return o.isAtom && i.depth == r.depth - 1
		? (e && e(t.tr.delete(i.pos - o.nodeSize, i.pos).scrollIntoView()), !0)
		: !1;
};
function wh(t, e, n = !1) {
	for (let r = t; r; r = e == "start" ? r.firstChild : r.lastChild) {
		if (r.isTextblock) return !0;
		if (n && r.childCount != 1) return !1;
	}
	return !1;
}
const Kae = (t, e, n) => {
	let { $head: r, empty: i } = t.selection,
		o = r;
	if (!i) return !1;
	if (r.parent.isTextblock) {
		if (n ? !n.endOfTextblock("backward", t) : r.parentOffset > 0)
			return !1;
		o = vj(r);
	}
	let s = o && o.nodeBefore;
	return !s || !Qe.isSelectable(s)
		? !1
		: (e &&
				e(
					t.tr
						.setSelection(Qe.create(t.doc, o.pos - s.nodeSize))
						.scrollIntoView(),
				),
			!0);
};
function vj(t) {
	if (!t.parent.type.spec.isolating)
		for (let e = t.depth - 1; e >= 0; e--) {
			if (t.index(e) > 0) return t.doc.resolve(t.before(e + 1));
			if (t.node(e).type.spec.isolating) break;
		}
	return null;
}
function Uae(t, e) {
	let { $cursor: n } = t.selection;
	return !n ||
		(e
			? !e.endOfTextblock("forward", t)
			: n.parentOffset < n.parent.content.size)
		? null
		: n;
}
const Hae = (t, e, n) => {
		let r = Uae(t, n);
		if (!r) return !1;
		let i = yj(r);
		if (!i) return !1;
		let o = i.nodeAfter;
		if (Ej(t, i, e, 1)) return !0;
		if (
			r.parent.content.size == 0 &&
			(wh(o, "start") || Qe.isSelectable(o))
		) {
			let s = LD(t.doc, r.before(), r.after(), Ee.empty);
			if (s && s.slice.size < s.to - s.from) {
				if (e) {
					let a = t.tr.step(s);
					a.setSelection(
						wh(o, "start")
							? mt.findFrom(
									a.doc.resolve(a.mapping.map(i.pos)),
									1,
								)
							: Qe.create(a.doc, a.mapping.map(i.pos)),
					),
						e(a.scrollIntoView());
				}
				return !0;
			}
		}
		return o.isAtom && i.depth == r.depth - 1
			? (e && e(t.tr.delete(i.pos, i.pos + o.nodeSize).scrollIntoView()),
				!0)
			: !1;
	},
	Wae = (t, e, n) => {
		let { $head: r, empty: i } = t.selection,
			o = r;
		if (!i) return !1;
		if (r.parent.isTextblock) {
			if (
				n
					? !n.endOfTextblock("forward", t)
					: r.parentOffset < r.parent.content.size
			)
				return !1;
			o = yj(r);
		}
		let s = o && o.nodeAfter;
		return !s || !Qe.isSelectable(s)
			? !1
			: (e &&
					e(
						t.tr
							.setSelection(Qe.create(t.doc, o.pos))
							.scrollIntoView(),
					),
				!0);
	};
function yj(t) {
	if (!t.parent.type.spec.isolating)
		for (let e = t.depth - 1; e >= 0; e--) {
			let n = t.node(e);
			if (t.index(e) + 1 < n.childCount)
				return t.doc.resolve(t.after(e + 1));
			if (n.type.spec.isolating) break;
		}
	return null;
}
const qae = (t, e) => {
		let n = t.selection,
			r = n instanceof Qe,
			i;
		if (r) {
			if (n.node.isTextblock || !Qh(t.doc, n.from)) return !1;
			i = n.from;
		} else if (((i = uj(t.doc, n.from, -1)), i == null)) return !1;
		if (e) {
			let o = t.tr.join(i);
			r &&
				o.setSelection(
					Qe.create(o.doc, i - t.doc.resolve(i).nodeBefore.nodeSize),
				),
				e(o.scrollIntoView());
		}
		return !0;
	},
	Gae = (t, e) => {
		let n = t.selection,
			r;
		if (n instanceof Qe) {
			if (n.node.isTextblock || !Qh(t.doc, n.to)) return !1;
			r = n.to;
		} else if (((r = uj(t.doc, n.to, 1)), r == null)) return !1;
		return e && e(t.tr.join(r).scrollIntoView()), !0;
	},
	Yae = (t, e) => {
		let { $head: n, $anchor: r } = t.selection;
		return !n.parent.type.spec.code || !n.sameParent(r)
			? !1
			: (e &&
					e(
						t.tr
							.insertText(
								`
`,
							)
							.scrollIntoView(),
					),
				!0);
	};
function xj(t) {
	for (let e = 0; e < t.edgeCount; e++) {
		let { type: n } = t.edge(e);
		if (n.isTextblock && !n.hasRequiredAttrs()) return n;
	}
	return null;
}
const kj = (t, e) => {
		let n = t.selection,
			{ $from: r, $to: i } = n;
		if (n instanceof ji || r.parent.inlineContent || i.parent.inlineContent)
			return !1;
		let o = xj(i.parent.contentMatchAt(i.indexAfter()));
		if (!o || !o.isTextblock) return !1;
		if (e) {
			let s = (!r.parentOffset && i.index() < i.parent.childCount ? r : i)
					.pos,
				a = t.tr.insert(s, o.createAndFill());
			a.setSelection(kt.create(a.doc, s + 1)), e(a.scrollIntoView());
		}
		return !0;
	},
	Cj = (t, e) => {
		let { $cursor: n } = t.selection;
		if (!n || n.parent.content.size) return !1;
		if (n.depth > 1 && n.after() != n.end(-1)) {
			let o = n.before();
			if (nh(t.doc, o)) return e && e(t.tr.split(o).scrollIntoView()), !0;
		}
		let r = n.blockRange(),
			i = r && v0(r);
		return i == null ? !1 : (e && e(t.tr.lift(r, i).scrollIntoView()), !0);
	};
function Jae(t) {
	return (e, n) => {
		let { $from: r, $to: i } = e.selection;
		if (e.selection instanceof Qe && e.selection.node.isBlock)
			return !r.parentOffset || !nh(e.doc, r.pos)
				? !1
				: (n && n(e.tr.split(r.pos).scrollIntoView()), !0);
		if (!r.parent.isBlock) return !1;
		if (n) {
			let o = i.parentOffset == i.parent.content.size,
				s = e.tr;
			(e.selection instanceof kt || e.selection instanceof ji) &&
				s.deleteSelection();
			let a =
					r.depth == 0
						? null
						: xj(r.node(-1).contentMatchAt(r.indexAfter(-1))),
				l = o && a ? [{ type: a }] : void 0,
				u = nh(s.doc, s.mapping.map(r.pos), 1, l);
			if (
				(!l &&
					!u &&
					nh(
						s.doc,
						s.mapping.map(r.pos),
						1,
						a ? [{ type: a }] : void 0,
					) &&
					(a && (l = [{ type: a }]), (u = !0)),
				u &&
					(s.split(s.mapping.map(r.pos), 1, l),
					!o && !r.parentOffset && r.parent.type != a))
			) {
				let c = s.mapping.map(r.before()),
					d = s.doc.resolve(c);
				a &&
					r.node(-1).canReplaceWith(d.index(), d.index() + 1, a) &&
					s.setNodeMarkup(s.mapping.map(r.before()), a);
			}
			n(s.scrollIntoView());
		}
		return !0;
	};
}
const wj = Jae(),
	Xae = (t, e) => (e && e(t.tr.setSelection(new ji(t.doc))), !0);
function Zae(t, e, n) {
	let r = e.nodeBefore,
		i = e.nodeAfter,
		o = e.index();
	return !r || !i || !r.type.compatibleContent(i.type)
		? !1
		: !r.content.size && e.parent.canReplace(o - 1, o)
			? (n && n(t.tr.delete(e.pos - r.nodeSize, e.pos).scrollIntoView()),
				!0)
			: !e.parent.canReplace(o, o + 1) ||
				  !(i.isTextblock || Qh(t.doc, e.pos))
				? !1
				: (n &&
						n(
							t.tr
								.clearIncompatible(
									e.pos,
									r.type,
									r.contentMatchAt(r.childCount),
								)
								.join(e.pos)
								.scrollIntoView(),
						),
					!0);
}
function Ej(t, e, n, r) {
	let i = e.nodeBefore,
		o = e.nodeAfter,
		s,
		a,
		l = i.type.spec.isolating || o.type.spec.isolating;
	if (!l && Zae(t, e, n)) return !0;
	let u = !l && e.parent.canReplace(e.index(), e.index() + 1);
	if (
		u &&
		(s = (a = i.contentMatchAt(i.childCount)).findWrapping(o.type)) &&
		a.matchType(s[0] || o.type).validEnd
	) {
		if (n) {
			let h = e.pos + o.nodeSize,
				p = be.empty;
			for (let b = s.length - 1; b >= 0; b--)
				p = be.from(s[b].create(null, p));
			p = be.from(i.copy(p));
			let g = t.tr.step(
					new Fr(
						e.pos - 1,
						h,
						e.pos,
						h,
						new Ee(p, 1, 0),
						s.length,
						!0,
					),
				),
				v = h + 2 * s.length;
			Qh(g.doc, v) && g.join(v), n(g.scrollIntoView());
		}
		return !0;
	}
	let c = o.type.spec.isolating || (r > 0 && l) ? null : mt.findFrom(e, 1),
		d = c && c.$from.blockRange(c.$to),
		f = d && v0(d);
	if (f != null && f >= e.depth)
		return n && n(t.tr.lift(d, f).scrollIntoView()), !0;
	if (u && wh(o, "start", !0) && wh(i, "end")) {
		let h = i,
			p = [];
		for (; p.push(h), !h.isTextblock; ) h = h.lastChild;
		let g = o,
			v = 1;
		for (; !g.isTextblock; g = g.firstChild) v++;
		if (h.canReplace(h.childCount, h.childCount, g.content)) {
			if (n) {
				let b = be.empty;
				for (let x = p.length - 1; x >= 0; x--)
					b = be.from(p[x].copy(b));
				let y = t.tr.step(
					new Fr(
						e.pos - p.length,
						e.pos + o.nodeSize,
						e.pos + v,
						e.pos + o.nodeSize - v,
						new Ee(b, p.length, 0),
						0,
						!0,
					),
				);
				n(y.scrollIntoView());
			}
			return !0;
		}
	}
	return !1;
}
function Dj(t) {
	return function (e, n) {
		let r = e.selection,
			i = t < 0 ? r.$from : r.$to,
			o = i.depth;
		for (; i.node(o).isInline; ) {
			if (!o) return !1;
			o--;
		}
		return i.node(o).isTextblock
			? (n &&
					n(
						e.tr.setSelection(
							kt.create(e.doc, t < 0 ? i.start(o) : i.end(o)),
						),
					),
				!0)
			: !1;
	};
}
const Qae = Dj(-1),
	ele = Dj(1);
function Sj(t, e = null) {
	return function (n, r) {
		let { $from: i, $to: o } = n.selection,
			s = i.blockRange(o),
			a = s && zD(s, t, e);
		return a ? (r && r(n.tr.wrap(s, a).scrollIntoView()), !0) : !1;
	};
}
function yd(t, e = null) {
	return function (n, r) {
		let i = !1;
		for (let o = 0; o < n.selection.ranges.length && !i; o++) {
			let {
				$from: { pos: s },
				$to: { pos: a },
			} = n.selection.ranges[o];
			n.doc.nodesBetween(s, a, (l, u) => {
				if (i) return !1;
				if (!(!l.isTextblock || l.hasMarkup(t, e)))
					if (l.type == t) i = !0;
					else {
						let c = n.doc.resolve(u),
							d = c.index();
						i = c.parent.canReplaceWith(d, d + 1, t);
					}
			});
		}
		if (!i) return !1;
		if (r) {
			let o = n.tr;
			for (let s = 0; s < n.selection.ranges.length; s++) {
				let {
					$from: { pos: a },
					$to: { pos: l },
				} = n.selection.ranges[s];
				o.setBlockType(a, l, t, e);
			}
			r(o.scrollIntoView());
		}
		return !0;
	};
}
function tle(t, e, n, r) {
	for (let i = 0; i < e.length; i++) {
		let { $from: o, $to: s } = e[i],
			a = o.depth == 0 ? t.inlineContent && t.type.allowsMarkType(n) : !1;
		if (
			(t.nodesBetween(o.pos, s.pos, (l, u) => {
				if (a || !r) return !1;
				a = l.inlineContent && l.type.allowsMarkType(n);
			}),
			a)
		)
			return !0;
	}
	return !1;
}
function wc(t, e = null, n) {
	let r = n !== !1;
	return function (i, o) {
		let { empty: s, $cursor: a, ranges: l } = i.selection;
		if ((s && !a) || !tle(i.doc, l, t, r)) return !1;
		if (o)
			if (a)
				t.isInSet(i.storedMarks || a.marks())
					? o(i.tr.removeStoredMark(t))
					: o(i.tr.addStoredMark(t.create(e)));
			else {
				let u,
					c = i.tr;
				u = !l.some((d) =>
					i.doc.rangeHasMark(d.$from.pos, d.$to.pos, t),
				);
				for (let d = 0; d < l.length; d++) {
					let { $from: f, $to: h } = l[d];
					if (!u) c.removeMark(f.pos, h.pos, t);
					else {
						let p = f.pos,
							g = h.pos,
							v = f.nodeAfter,
							b = h.nodeBefore,
							y =
								v && v.isText
									? /^\s*/.exec(v.text)[0].length
									: 0,
							x =
								b && b.isText
									? /\s*$/.exec(b.text)[0].length
									: 0;
						p + y < g && ((p += y), (g -= x)),
							c.addMark(p, g, t.create(e));
					}
				}
				o(c.scrollIntoView());
			}
		return !0;
	};
}
function Qp(...t) {
	return function (e, n, r) {
		for (let i = 0; i < t.length; i++) if (t[i](e, n, r)) return !0;
		return !1;
	};
}
typeof navigator < "u"
	? /Mac|iP(hone|[oa]d)/.test(navigator.platform)
	: typeof os < "u" && os.platform && os.platform() == "darwin";
class Sw {
	*[Symbol.iterator]() {
		yield* this.iterable;
	}
	get size() {
		return this.keyMap.size;
	}
	getKeys() {
		return this.keyMap.keys();
	}
	getKeyBefore(e) {
		let n = this.keyMap.get(e);
		return n ? n.prevKey : null;
	}
	getKeyAfter(e) {
		let n = this.keyMap.get(e);
		return n ? n.nextKey : null;
	}
	getFirstKey() {
		return this.firstKey;
	}
	getLastKey() {
		return this.lastKey;
	}
	getItem(e) {
		return this.keyMap.get(e);
	}
	at(e) {
		const n = [...this.getKeys()];
		return this.getItem(n[e]);
	}
	getChildren(e) {
		let n = this.keyMap.get(e);
		return (n == null ? void 0 : n.childNodes) || [];
	}
	constructor(e) {
		(this.keyMap = new Map()), (this.iterable = e);
		let n = (o) => {
			if (
				(this.keyMap.set(o.key, o),
				o.childNodes && o.type === "section")
			)
				for (let s of o.childNodes) n(s);
		};
		for (let o of e) n(o);
		let r,
			i = 0;
		for (let [o, s] of this.keyMap)
			r
				? ((r.nextKey = o), (s.prevKey = r.key))
				: ((this.firstKey = o), (s.prevKey = void 0)),
				s.type === "item" && (s.index = i++),
				(r = s),
				(r.nextKey = void 0);
		this.lastKey = r == null ? void 0 : r.key;
	}
}
function y0(t) {
	let { filter: e } = t,
		n = CD(t),
		r = E.useMemo(
			() => (t.disabledKeys ? new Set(t.disabledKeys) : new Set()),
			[t.disabledKeys],
		),
		i = E.useCallback((u) => (e ? new Sw(e(u)) : new Sw(u)), [e]),
		o = E.useMemo(
			() => ({ suppressTextValueWarning: t.suppressTextValueWarning }),
			[t.suppressTextValueWarning],
		),
		s = xD(t, i, o),
		a = E.useMemo(() => new wD(s, n), [s, n]);
	const l = E.useRef(null);
	return (
		E.useEffect(() => {
			if (n.focusedKey != null && !s.getItem(n.focusedKey)) {
				const u = l.current.getItem(n.focusedKey),
					c = [...l.current.getKeys()]
						.map((v) => {
							const b = l.current.getItem(v);
							return b.type === "item" ? b : null;
						})
						.filter((v) => v !== null),
					d = [...s.getKeys()]
						.map((v) => {
							const b = s.getItem(v);
							return b.type === "item" ? b : null;
						})
						.filter((v) => v !== null),
					f = c.length - d.length;
				let h = Math.min(
						f > 1 ? Math.max(u.index - f + 1, 0) : u.index,
						d.length - 1,
					),
					p,
					g = !1;
				for (; h >= 0; ) {
					if (!a.isDisabled(d[h].key)) {
						p = d[h];
						break;
					}
					h < d.length - 1 && !g
						? h++
						: ((g = !0), h > u.index && (h = u.index), h--);
				}
				n.setFocusedKey(p ? p.key : null);
			}
			l.current = s;
		}, [s, a, n, n.focusedKey]),
		{ collection: s, disabledKeys: r, selectionManager: a }
	);
}
function Aj(t) {
	var e;
	let [n, r] = Ns(
			t.selectedKey,
			(e = t.defaultSelectedKey) !== null && e !== void 0 ? e : null,
			t.onSelectionChange,
		),
		i = E.useMemo(() => (n != null ? [n] : []), [n]),
		{
			collection: o,
			disabledKeys: s,
			selectionManager: a,
		} = y0({
			...t,
			selectionMode: "single",
			disallowEmptySelection: !0,
			allowDuplicateSelectionEvents: !0,
			selectedKeys: i,
			onSelectionChange: (u) => {
				var c;
				let d =
					(c = u.values().next().value) !== null && c !== void 0
						? c
						: null;
				d === n && t.onSelectionChange && t.onSelectionChange(d), r(d);
			},
		}),
		l = n != null ? o.getItem(n) : null;
	return {
		collection: o,
		disabledKeys: s,
		selectionManager: a,
		selectedKey: n,
		setSelectedKey: r,
		selectedItem: l,
	};
}
const Mx = new WeakMap();
function nle(t) {
	return typeof t == "string" ? t.replace(/\s*/g, "") : "" + t;
}
function $j(t, e) {
	let n = Mx.get(t);
	if (!n) throw new Error("Unknown list");
	return `${n.id}-option-${nle(e)}`;
}
function rle(t, e, n) {
	let r = Ge(t, { labelable: !0 }),
		i = t.selectionBehavior || "toggle",
		o = t.linkBehavior || (i === "replace" ? "action" : "override");
	i === "toggle" && o === "action" && (o = "override");
	let { listProps: s } = ED({
			...t,
			ref: n,
			selectionManager: e.selectionManager,
			collection: e.collection,
			disabledKeys: e.disabledKeys,
			linkBehavior: o,
		}),
		{ focusWithinProps: a } = Ud({
			onFocusWithin: t.onFocus,
			onBlurWithin: t.onBlur,
			onFocusWithinChange: t.onFocusChange,
		}),
		l = Ot(t.id);
	Mx.set(e, {
		id: l,
		shouldUseVirtualFocus: t.shouldUseVirtualFocus,
		shouldSelectOnPressUp: t.shouldSelectOnPressUp,
		shouldFocusOnHover: t.shouldFocusOnHover,
		isVirtualized: t.isVirtualized,
		onAction: t.onAction,
		linkBehavior: o,
	});
	let { labelProps: u, fieldProps: c } = uD({
		...t,
		id: l,
		labelElementType: "span",
	});
	return {
		labelProps: u,
		listBoxProps: xe(
			r,
			a,
			e.selectionManager.selectionMode === "multiple"
				? { "aria-multiselectable": "true" }
				: {},
			{ role: "listbox", ...xe(c, s) },
		),
	};
}
function ile(t, e, n) {
	var r, i;
	let { key: o } = t,
		s = Mx.get(e);
	var a;
	let l =
		(a = t.isDisabled) !== null && a !== void 0
			? a
			: e.selectionManager.isDisabled(o);
	var u;
	let c =
		(u = t.isSelected) !== null && u !== void 0
			? u
			: e.selectionManager.isSelected(o);
	var d;
	let f =
		(d = t.shouldSelectOnPressUp) !== null && d !== void 0
			? d
			: s == null
				? void 0
				: s.shouldSelectOnPressUp;
	var h;
	let p =
		(h = t.shouldFocusOnHover) !== null && h !== void 0
			? h
			: s == null
				? void 0
				: s.shouldFocusOnHover;
	var g;
	let v =
		(g = t.shouldUseVirtualFocus) !== null && g !== void 0
			? g
			: s == null
				? void 0
				: s.shouldUseVirtualFocus;
	var b;
	let y =
			(b = t.isVirtualized) !== null && b !== void 0
				? b
				: s == null
					? void 0
					: s.isVirtualized,
		x = Lo(),
		C = Lo(),
		k = {
			role: "option",
			"aria-disabled": l || void 0,
			"aria-selected":
				e.selectionManager.selectionMode !== "none" ? c : void 0,
		};
	(Ss() && ax()) ||
		((k["aria-label"] = t["aria-label"]),
		(k["aria-labelledby"] = x),
		(k["aria-describedby"] = C));
	let w = e.collection.getItem(o);
	if (y) {
		let _ = Number(w == null ? void 0 : w.index);
		(k["aria-posinset"] = Number.isNaN(_) ? void 0 : _ + 1),
			(k["aria-setsize"] = kD(e.collection));
	}
	let D =
			s != null && s.onAction
				? () => {
						var _;
						return s == null ||
							(_ = s.onAction) === null ||
							_ === void 0
							? void 0
							: _.call(s, o);
					}
				: void 0,
		{
			itemProps: S,
			isPressed: $,
			isFocused: A,
			hasAction: T,
			allowsSelection: I,
		} = f0({
			selectionManager: e.selectionManager,
			key: o,
			ref: n,
			shouldSelectOnPressUp: f,
			allowsDifferentPressOrigin: f && p,
			isVirtualized: y,
			shouldUseVirtualFocus: v,
			isDisabled: l,
			onAction:
				D ||
				(!(w == null || (r = w.props) === null || r === void 0) &&
					r.onAction)
					? hr(
							w == null || (i = w.props) === null || i === void 0
								? void 0
								: i.onAction,
							D,
						)
					: void 0,
			linkBehavior: s == null ? void 0 : s.linkBehavior,
		}),
		{ hoverProps: F } = gn({
			isDisabled: l || !p,
			onHoverStart() {
				ml() ||
					(e.selectionManager.setFocused(!0),
					e.selectionManager.setFocusedKey(o));
			},
		}),
		N = Ge(w == null ? void 0 : w.props);
	delete N.id;
	let O = YE(w == null ? void 0 : w.props);
	return {
		optionProps: { ...k, ...xe(N, S, F, O), id: $j(e, o) },
		labelProps: { id: x },
		descriptionProps: { id: C },
		isFocused: A,
		isFocusVisible: A && ml(),
		isSelected: c,
		isDisabled: l,
		isPressed: $,
		allowsSelection: I,
		hasAction: T,
	};
}
function ole(t) {
	let { heading: e, "aria-label": n } = t,
		r = Ot();
	return {
		itemProps: { role: "presentation" },
		headingProps: e ? { id: r, role: "presentation" } : {},
		groupProps: {
			role: "group",
			"aria-label": n,
			"aria-labelledby": e ? r : void 0,
		},
	};
}
const Tj = yi(function (e, n) {
		let {
				children: r,
				elementType: i = "div",
				descriptionProps: o,
				keyboardShortcutProps: s,
				labelProps: a,
				isFocused: l,
				isHovered: u,
				isPressed: c,
				isSelected: d,
				...f
			} = e,
			h = B.size.space.regular,
			p = B.size.space.medium,
			g = B.size.space.xsmall,
			v = X({
				display: "grid",
				gridTemplateAreas:
					'". icon text . kbd checkmark ." ". icon description . kbd checkmark ."',
				gridTemplateColumns: `${h} auto 1fr ${p} auto ${B.size.icon.regular} ${h}`,
				gridTemplateRows: "1fr auto",
				borderRadius: B.size.radius.small,
				paddingBlock: B.size.space.regular,
			}),
			b = X({
				cursor: "default",
				color: B.color.alias.foregroundIdle,
				display: "block",
				outline: 0,
				position: "relative",
				paddingInline: B.size.space.small,
				"a&": { cursor: "pointer" },
				"& .list-item-text": {
					marginBlock: `calc((${B.size.icon.regular} - ${B.typography.text.regular.capheight}) / 2)`,
				},
				"&:not([aria-disabled=true])": {
					"& .list-item-checkmark": {
						stroke: B.color.alias.foregroundSelected,
					},
					"& .list-item-icon": {
						color: B.color.foreground.neutralSecondary,
					},
				},
				[`&[role=menuitem] .${v}`]: {
					gridTemplateAreas:
						'". icon text . kbd ." ". icon description . kbd ."',
					gridTemplateColumns: `${h} auto 1fr ${p} auto ${h}`,
				},
				[[
					`&[role=menuitemcheckbox] .${v}, &[role=menuitemradio] .${v}`,
					`[data-selection=single] &[role=menuitem] .${v}, [data-selection=multiple] &[role=menuitem] .${v}`,
				].join(", ")]: {
					gridTemplateAreas:
						'". checkmark icon text . kbd ." ". checkmark icon description . kbd ."',
					gridTemplateColumns: `${B.size.space.small} ${B.size.icon.medium} auto 1fr ${p} auto ${h}`,
				},
				[`&[aria-disabled=false]:hover .${v}, &[data-hovered] .${v}`]: {
					backgroundColor: B.color.alias.backgroundHovered,
					color: B.color.alias.foregroundHovered,
				},
				[`&[aria-disabled=false]:focus .${v}, &[data-focused] .${v}`]: {
					backgroundColor: B.color.alias.backgroundHovered,
					color: B.color.alias.foregroundHovered,
				},
				"&[aria-disabled=false]:hover .list-item-icon, &[data-hovered] .list-item-icon, &[aria-disabled=false]:focus .list-item-icon, &[data-focused] .list-item-icon":
					{ color: B.color.alias.foregroundIdle },
				"&[aria-disabled=false]:hover kbd, &[data-hovered] kbd, &[aria-disabled=false]:focus kbd, &[data-focused] kbd":
					{ color: B.color.alias.foregroundIdle },
				[`&[aria-disabled=false]:active .${v}, &[data-pressed] .${v}`]:
					{
						backgroundColor: B.color.alias.backgroundPressed,
						color: B.color.alias.foregroundPressed,
					},
				"&[data-focused]": {
					"&::before": {
						backgroundColor: B.color.background.accentEmphasis,
						borderRadius: g,
						content: '""',
						insetBlock: B.size.space.xsmall,
						insetInlineStart: 0,
						position: "absolute",
						width: g,
					},
				},
				"&[aria-disabled=true]": {
					color: B.color.alias.foregroundDisabled,
					"& kbd": { color: "currentColor" },
					"& .list-item-checkmark": { stroke: "currentColor" },
				},
			});
		const y = {
			text: {
				...a,
				color: "inherit",
				gridArea: "text",
				UNSAFE_className: "list-item-text",
			},
			icon: {
				gridArea: "icon",
				marginEnd: "regular",
				UNSAFE_className: "list-item-icon",
			},
			description: {
				color: "neutralSecondary",
				gridArea: "description",
				marginY: "small",
				size: "small",
				...o,
			},
			kbd: {
				UNSAFE_className: X({
					alignItems: "center",
					color: B.color.foreground.neutralTertiary,
					display: "flex",
					gridArea: "kbd",
					height: B.size.icon.regular,
				}),
				...s,
			},
		};
		return m.jsx(i, {
			...lt({
				focused: l || void 0,
				hovered: u || void 0,
				pressed: c || void 0,
			}),
			...f,
			ref: n,
			className: Se(b),
			children: m.jsx("div", {
				className: v,
				children: m.jsx(c0, {
					children: m.jsxs(Cn, {
						slots: y,
						children: [
							r,
							d &&
								m.jsx(ve, {
									src: IO,
									slot: "checkmark",
									strokeScaling: !1,
									gridArea: "checkmark",
									UNSAFE_className: "list-item-checkmark",
								}),
						],
					}),
				}),
			}),
		});
	}),
	sle = {
		"ar-AE": {
			loading: "جارٍ التحميل...",
			loadingMore: "جارٍ تحميل المزيد...",
		},
		"bg-BG": {
			loading: "Зареждане...",
			loadingMore: "Зареждане на още...",
		},
		"cs-CZ": { loading: "Načítání...", loadingMore: "Načítání dalších..." },
		"da-DK": { loading: "Indlæser ...", loadingMore: "Indlæser flere ..." },
		"de-DE": { loading: "Laden...", loadingMore: "Mehr laden ..." },
		"el-GR": {
			loading: "Φόρτωση...",
			loadingMore: "Φόρτωση περισσότερων...",
		},
		"en-US": { loading: "Loading…", loadingMore: "Loading more…" },
		"es-ES": { loading: "Cargando…", loadingMore: "Cargando más…" },
		"et-EE": { loading: "Laadimine...", loadingMore: "Laadi rohkem..." },
		"fi-FI": { loading: "Ladataan…", loadingMore: "Ladataan lisää…" },
		"fr-FR": {
			loading: "Chargement...",
			loadingMore: "Chargement supplémentaire...",
		},
		"he-IL": { loading: "טוען...", loadingMore: "טוען עוד..." },
		"hr-HR": { loading: "Učitavam...", loadingMore: "Učitavam još..." },
		"hu-HU": {
			loading: "Betöltés folyamatban…",
			loadingMore: "Továbbiak betöltése folyamatban…",
		},
		"it-IT": {
			loading: "Caricamento...",
			loadingMore: "Caricamento altri...",
		},
		"ja-JP": {
			loading: "読み込み中...",
			loadingMore: "さらに読み込み中...",
		},
		"ko-KR": { loading: "로드 중", loadingMore: "추가 로드 중" },
		"lt-LT": { loading: "Įkeliama...", loadingMore: "Įkeliama daugiau..." },
		"lv-LV": {
			loading: "Notiek ielāde...",
			loadingMore: "Tiek ielādēts vēl...",
		},
		"nb-NO": {
			loading: "Laster inn ...",
			loadingMore: "Laster inn flere ...",
		},
		"nl-NL": { loading: "Laden...", loadingMore: "Meer laden..." },
		"pl-PL": {
			loading: "Ładowanie...",
			loadingMore: "Wczytywanie większej liczby...",
		},
		"pt-BR": {
			loading: "Carregando...",
			loadingMore: "Carregando mais...",
		},
		"pt-PT": {
			loading: "A carregar...",
			loadingMore: "A carregar mais...",
		},
		"ro-RO": {
			loading: "Se încarcă...",
			loadingMore: "Se încarcă mai multe...",
		},
		"ru-RU": {
			loading: "Загрузка...",
			loadingMore: "Дополнительная загрузка...",
		},
		"sk-SK": {
			loading: "Načítava sa...",
			loadingMore: "Načítava sa viac...",
		},
		"sl-SI": {
			loading: "Nalaganje...",
			loadingMore: "Nalaganje več vsebine...",
		},
		"sr-SP": { loading: "Učitavam...", loadingMore: "Učitavam još..." },
		"sv-SE": { loading: "Läser in...", loadingMore: "Läser in mer..." },
		"tr-TR": {
			loading: "Yükleniyor...",
			loadingMore: "Daha fazla yükleniyor...",
		},
		"uk-UA": {
			loading: "Завантаження…",
			loadingMore: "Завантаження інших об’єктів...",
		},
		"zh-CN": { loading: "正在加载...", loadingMore: "正在加载更多..." },
		"zh-T": { loading: "正在載入", loadingMore: "正在載入更多…" },
	},
	Bj = E.createContext(null);
function Ij() {
	const t = E.useContext(Bj);
	return wt(!!t, "ListBoxContext is missing"), t;
}
class ale extends ND {
	constructor(n) {
		super(n);
		Fe(this, "isLoading", !1);
		(this.placeholderHeight = n.placeholderHeight),
			(this.padding = n.padding);
	}
	update(n) {
		var r;
		(this.isLoading =
			((r = n.layoutOptions) === null || r === void 0
				? void 0
				: r.isLoading) || !1),
			super.update(n);
	}
	buildCollection() {
		let n = super.buildCollection(this.padding),
			r = this.contentSize.height;
		if (this.isLoading) {
			let o = new St(0, r, this.virtualizer.visibleRect.width, 40),
				s = new er("loader", "loader", o),
				a = { layoutInfo: s, validRect: s.rect };
			n.push(a), this.layoutNodes.set(s.key, a), (r = s.rect.maxY);
		}
		if (n.length === 0) {
			var i;
			let o = new St(
					0,
					r,
					this.virtualizer.visibleRect.width,
					(i = this.placeholderHeight) !== null && i !== void 0
						? i
						: this.virtualizer.visibleRect.height,
				),
				s = new er("placeholder", "placeholder", o),
				a = { layoutInfo: s, validRect: s.rect };
			n.push(a), this.layoutNodes.set(s.key, a), (r = s.rect.maxY);
		}
		return (this.contentSize.height = r + this.padding), n;
	}
	buildSection(n, r, i) {
		var o;
		let s = {
				type: "header",
				key: n.key + ":header",
				parentKey: n.key,
				value: null,
				level: n.level,
				hasChildNodes: !1,
				childNodes: [],
				rendered: n.rendered,
				textValue: n.textValue,
			},
			a = this.buildSectionHeader(s, r, i);
		(a.node = s),
			(a.layoutInfo.parentKey = n.key),
			this.layoutNodes.set(s.key, a),
			(i += a.layoutInfo.rect.height);
		let l = super.buildSection(n, r, i);
		return (o = l.children) === null || o === void 0 || o.unshift(a), l;
	}
}
function lle(t) {
	const e = ce(29),
		{
			item: n,
			shouldSelectOnPressUp: r,
			shouldFocusOnHover: i,
			shouldUseVirtualFocus: o,
		} = t,
		{ rendered: s, key: a } = n,
		{ state: l } = Ij(),
		u = E.useRef(null),
		c = n["aria-label"];
	let d;
	e[0] !== c || e[1] !== a || e[2] !== r || e[3] !== i || e[4] !== o
		? ((d = {
				"aria-label": c,
				key: a,
				shouldSelectOnPressUp: r,
				shouldFocusOnHover: i,
				isVirtualized: !0,
				shouldUseVirtualFocus: o,
			}),
			(e[0] = c),
			(e[1] = a),
			(e[2] = r),
			(e[3] = i),
			(e[4] = o),
			(e[5] = d))
		: (d = e[5]);
	const {
		optionProps: f,
		labelProps: h,
		descriptionProps: p,
		isSelected: g,
		isDisabled: v,
		isFocused: b,
		isPressed: y,
	} = ile(d, l, u);
	let x;
	e[6] !== t || e[7] !== v
		? ((x = { ...t, isDisabled: v }), (e[6] = t), (e[7] = v), (e[8] = x))
		: (x = e[8]);
	const { hoverProps: C, isHovered: k } = gn(x),
		{ isFocusVisible: w, focusProps: D } = ha();
	let S;
	e[9] !== s
		? ((S = $n(s) ? m.jsx(ue, { children: s }) : s),
			(e[9] = s),
			(e[10] = S))
		: (S = e[10]);
	const $ = S;
	let A;
	e[11] === Symbol.for("react.memo_cache_sentinel")
		? ((A = ml()), (e[11] = A))
		: (A = e[11]);
	const T = A,
		I = o ? b && T : w,
		F = (k && !i) || (b && !T);
	let N;
	e[12] !== i || e[13] !== C
		? ((N = i ? {} : C), (e[12] = i), (e[13] = C), (e[14] = N))
		: (N = e[14]);
	let O;
	e[15] !== f || e[16] !== D || e[17] !== N
		? ((O = xe(f, D, N)),
			(e[15] = f),
			(e[16] = D),
			(e[17] = N),
			(e[18] = O))
		: (O = e[18]);
	let _;
	return (
		e[19] !== p ||
		e[20] !== h ||
		e[21] !== I ||
		e[22] !== F ||
		e[23] !== O ||
		e[24] !== y ||
		e[25] !== g ||
		e[26] !== u ||
		e[27] !== $
			? ((_ = m.jsx(Tj, {
					descriptionProps: p,
					labelProps: h,
					isFocused: I,
					isHovered: F,
					...O,
					isPressed: y,
					isSelected: g,
					ref: u,
					children: $,
				})),
				(e[19] = p),
				(e[20] = h),
				(e[21] = I),
				(e[22] = F),
				(e[23] = O),
				(e[24] = y),
				(e[25] = g),
				(e[26] = u),
				(e[27] = $),
				(e[28] = _))
			: (_ = e[28]),
		_
	);
}
function ule(t) {
	const e = ce(32),
		{
			children: n,
			layoutInfo: r,
			headerLayoutInfo: i,
			virtualizer: o,
			item: s,
		} = t,
		a = s["aria-label"];
	let l;
	e[0] !== s.rendered || e[1] !== a
		? ((l = { heading: s.rendered, "aria-label": a }),
			(e[0] = s.rendered),
			(e[1] = a),
			(e[2] = l))
		: (l = e[2]);
	const { headingProps: u, groupProps: c } = ole(l),
		d = E.useRef(null);
	let f;
	e[3] !== i || e[4] !== o || e[5] !== d
		? ((f = { layoutInfo: i, virtualizer: o, ref: d }),
			(e[3] = i),
			(e[4] = o),
			(e[5] = d),
			(e[6] = f))
		: (f = e[6]),
		AO(f);
	const { direction: h } = Vt(),
		{ state: p } = Ij();
	let g;
	e[7] !== i || e[8] !== h
		? ((g = yv(i, h)), (e[7] = i), (e[8] = h), (e[9] = g))
		: (g = e[9]);
	let v;
	e[10] !== p.collection || e[11] !== s.key
		? ((v =
				s.key !== p.collection.getFirstKey() &&
				m.jsx(ra, {
					role: "presentation",
					elementType: "div",
					size: "medium",
					UNSAFE_className: X({ margin: B.size.space.medium }),
				})),
			(e[10] = p.collection),
			(e[11] = s.key),
			(e[12] = v))
		: (v = e[12]);
	let b;
	e[13] !== s.rendered || e[14] !== u
		? ((b =
				s.rendered &&
				m.jsx(ue, {
					...u,
					casing: "uppercase",
					color: "neutralSecondary",
					size: "small",
					weight: "medium",
					UNSAFE_className: X({ padding: B.size.space.medium }),
					children: s.rendered,
				})),
			(e[13] = s.rendered),
			(e[14] = u),
			(e[15] = b))
		: (b = e[15]);
	let y;
	e[16] !== d || e[17] !== g || e[18] !== v || e[19] !== b
		? ((y = m.jsxs("div", {
				role: "presentation",
				ref: d,
				style: g,
				children: [v, b],
			})),
			(e[16] = d),
			(e[17] = g),
			(e[18] = v),
			(e[19] = b),
			(e[20] = y))
		: (y = e[20]);
	let x;
	e[21] !== r || e[22] !== h
		? ((x = yv(r, h)), (e[21] = r), (e[22] = h), (e[23] = x))
		: (x = e[23]);
	let C;
	e[24] === Symbol.for("react.memo_cache_sentinel")
		? ((C = Se(X({}), "ListBoxSection")), (e[24] = C))
		: (C = e[24]);
	let k;
	e[25] !== c || e[26] !== x || e[27] !== n
		? ((k = m.jsx("div", { ...c, style: x, className: C, children: n })),
			(e[25] = c),
			(e[26] = x),
			(e[27] = n),
			(e[28] = k))
		: (k = e[28]);
	let w;
	return (
		e[29] !== y || e[30] !== k
			? ((w = m.jsxs(E.Fragment, { children: [y, k] })),
				(e[29] = y),
				(e[30] = k),
				(e[31] = w))
			: (w = e[31]),
		w
	);
}
function x0() {
	const t = ce(5),
		{ scale: e } = Rs();
	let n;
	const r = e === "large" ? 48 : 32,
		i = e === "large" ? 33 : 26,
		o = e === "large" ? 5 : 4,
		s = e === "large" ? 48 : 32;
	let a;
	return (
		t[0] !== r || t[1] !== i || t[2] !== o || t[3] !== s
			? ((a = new ale({
					estimatedRowHeight: r,
					estimatedHeadingHeight: i,
					padding: o,
					placeholderHeight: s,
				})),
				(t[0] = r),
				(t[1] = i),
				(t[2] = o),
				(t[3] = s),
				(t[4] = a))
			: (a = t[4]),
		(n = a),
		n
	);
}
function cle(t, e) {
	const n = ce(39),
		{
			layout: r,
			state: i,
			shouldFocusOnHover: o,
			shouldUseVirtualFocus: s,
			domProps: a,
			isLoading: l,
			showLoadingSpinner: u,
			onScroll: c,
			renderEmptyState: d,
		} = t,
		f = o === void 0 ? !1 : o,
		h = s === void 0 ? !1 : s;
	let p;
	n[0] !== a
		? ((p = a === void 0 ? {} : a), (n[0] = a), (n[1] = p))
		: (p = n[1]);
	const g = p,
		v = u === void 0 ? l : u;
	let b;
	n[2] !== t || n[3] !== r
		? ((b = { ...t, layoutDelegate: r, isVirtualized: !0 }),
			(n[2] = t),
			(n[3] = r),
			(n[4] = b))
		: (b = n[4]);
	const { listBoxProps: y } = rle(b, i, e),
		x = ht(t),
		C = Le(sle);
	let k;
	n[5] === Symbol.for("react.memo_cache_sentinel")
		? ((k = (K, M, G, H) => {
				if (M.viewType === "section") {
					var P;
					return m.jsx(
						ule,
						{
							item: M.content,
							layoutInfo: M.layoutInfo,
							virtualizer: M.virtualizer,
							headerLayoutInfo:
								(P = G.find((q) => q.viewType === "header")) ===
									null || P === void 0
									? void 0
									: P.layoutInfo,
							children: H(G.filter((q) => q.viewType === "item")),
						},
						M.key,
					);
				}
				return m.jsx(
					TD,
					{
						layoutInfo: M.layoutInfo,
						virtualizer: M.virtualizer,
						parent: K == null ? void 0 : K.layoutInfo,
						children: M.rendered,
					},
					M.key,
				);
			}),
			(n[5] = k))
		: (k = n[5]);
	const w = k,
		D = i.selectionManager.focusedKey;
	let S, $;
	n[6] !== D
		? (($ = D != null ? new Set([D]) : null), (n[6] = D), (n[7] = $))
		: ($ = n[7]),
		(S = $);
	const A = S;
	let T;
	n[8] !== i || n[9] !== d || n[10] !== f || n[11] !== h
		? ((T = {
				state: i,
				renderEmptyState: d,
				shouldFocusOnHover: f,
				shouldUseVirtualFocus: h,
			}),
			(n[8] = i),
			(n[9] = d),
			(n[10] = f),
			(n[11] = h),
			(n[12] = T))
		: (T = n[12]);
	let I;
	n[13] !== y || n[14] !== g
		? ((I = xe(y, g)), (n[13] = y), (n[14] = g), (n[15] = I))
		: (I = n[15]);
	const F = !!t.autoFocus;
	let N, O;
	n[16] !== v
		? ((O = { isLoading: v }), (n[16] = v), (n[17] = O))
		: (O = n[17]),
		(N = O);
	let _;
	n[18] !== h || n[19] !== i.collection.size || n[20] !== C || n[21] !== t
		? ((_ = (K, M) => {
				if (K === "item")
					return m.jsx(lle, { item: M, shouldUseVirtualFocus: h });
				if (K === "loader")
					return m.jsx("div", {
						role: "option",
						style: {
							display: "flex",
							alignItems: "center",
							justifyContent: "center",
							height: "100%",
						},
						children: m.jsx(Cr, {
							isIndeterminate: !0,
							size: "small",
							"aria-label":
								i.collection.size > 0
									? C.format("loadingMore")
									: C.format("loading"),
						}),
					});
				if (K === "placeholder") {
					const G = t.renderEmptyState ? t.renderEmptyState() : null;
					return G == null
						? null
						: m.jsx("div", { role: "option", children: G });
				}
			}),
			(n[18] = h),
			(n[19] = i.collection.size),
			(n[20] = C),
			(n[21] = t),
			(n[22] = _))
		: (_ = n[22]);
	let j;
	n[23] !== x ||
	n[24] !== I ||
	n[25] !== e ||
	n[26] !== A ||
	n[27] !== F ||
	n[28] !== r ||
	n[29] !== N ||
	n[30] !== i.collection ||
	n[31] !== t.isLoading ||
	n[32] !== t.onLoadMore ||
	n[33] !== c ||
	n[34] !== _
		? ((j = m.jsx(nc, {
				children: m.jsx($O, {
					...x,
					...I,
					ref: e,
					persistedKeys: A,
					autoFocus: F,
					scrollDirection: "vertical",
					layout: r,
					layoutOptions: N,
					collection: i.collection,
					renderWrapper: w,
					isLoading: t.isLoading,
					onLoadMore: t.onLoadMore,
					onScroll: c,
					children: _,
				}),
			})),
			(n[23] = x),
			(n[24] = I),
			(n[25] = e),
			(n[26] = A),
			(n[27] = F),
			(n[28] = r),
			(n[29] = N),
			(n[30] = i.collection),
			(n[31] = t.isLoading),
			(n[32] = t.onLoadMore),
			(n[33] = c),
			(n[34] = _),
			(n[35] = j))
		: (j = n[35]);
	let V;
	return (
		n[36] !== T || n[37] !== j
			? ((V = m.jsx(Bj.Provider, { value: T, children: j })),
				(n[36] = T),
				(n[37] = j),
				(n[38] = V))
			: (V = n[38]),
		V
	);
}
const k0 = E.forwardRef(cle),
	jx = X({
		borderRadius: "inherit",
		maxHeight: "inherit",
		outline: 0,
		overflowY: "auto",
		paddingBlock: B.size.space.small,
		userSelect: "none",
	}),
	dle = ["top", "right", "bottom", "left"],
	Eh = Math.min,
	eo = Math.max,
	Fv = Math.round,
	C1 = Math.floor,
	zu = (t) => ({ x: t, y: t }),
	fle = { left: "right", right: "left", bottom: "top", top: "bottom" },
	hle = { start: "end", end: "start" };
function F$(t, e, n) {
	return eo(t, Eh(e, n));
}
function Lu(t, e) {
	return typeof t == "function" ? t(e) : t;
}
function bl(t) {
	return t.split("-")[0];
}
function C0(t) {
	return t.split("-")[1];
}
function KD(t) {
	return t === "x" ? "y" : "x";
}
function Fj(t) {
	return t === "y" ? "height" : "width";
}
function Vu(t) {
	return ["top", "bottom"].includes(bl(t)) ? "y" : "x";
}
function Pj(t) {
	return KD(Vu(t));
}
function ple(t, e, n) {
	n === void 0 && (n = !1);
	const r = C0(t),
		i = Pj(t),
		o = Fj(i);
	let s =
		i === "x"
			? r === (n ? "end" : "start")
				? "right"
				: "left"
			: r === "start"
				? "bottom"
				: "top";
	return e.reference[o] > e.floating[o] && (s = Pv(s)), [s, Pv(s)];
}
function mle(t) {
	const e = Pv(t);
	return [Aw(t), e, Aw(e)];
}
function Aw(t) {
	return t.replace(/start|end/g, (e) => hle[e]);
}
function gle(t, e, n) {
	const r = ["left", "right"],
		i = ["right", "left"],
		o = ["top", "bottom"],
		s = ["bottom", "top"];
	switch (t) {
		case "top":
		case "bottom":
			return n ? (e ? i : r) : e ? r : i;
		case "left":
		case "right":
			return e ? o : s;
		default:
			return [];
	}
}
function ble(t, e, n, r) {
	const i = C0(t);
	let o = gle(bl(t), n === "start", r);
	return (
		i && ((o = o.map((s) => s + "-" + i)), e && (o = o.concat(o.map(Aw)))),
		o
	);
}
function Pv(t) {
	return t.replace(/left|right|bottom|top/g, (e) => fle[e]);
}
function vle(t) {
	return { top: 0, right: 0, bottom: 0, left: 0, ...t };
}
function yle(t) {
	return typeof t != "number"
		? vle(t)
		: { top: t, right: t, bottom: t, left: t };
}
function Nv(t) {
	const { x: e, y: n, width: r, height: i } = t;
	return {
		width: r,
		height: i,
		top: n,
		left: e,
		right: e + r,
		bottom: n + i,
		x: e,
		y: n,
	};
}
function P$(t, e, n) {
	let { reference: r, floating: i } = t;
	const o = Vu(e),
		s = Pj(e),
		a = Fj(s),
		l = bl(e),
		u = o === "y",
		c = r.x + r.width / 2 - i.width / 2,
		d = r.y + r.height / 2 - i.height / 2,
		f = r[a] / 2 - i[a] / 2;
	let h;
	switch (l) {
		case "top":
			h = { x: c, y: r.y - i.height };
			break;
		case "bottom":
			h = { x: c, y: r.y + r.height };
			break;
		case "right":
			h = { x: r.x + r.width, y: d };
			break;
		case "left":
			h = { x: r.x - i.width, y: d };
			break;
		default:
			h = { x: r.x, y: r.y };
	}
	switch (C0(e)) {
		case "start":
			h[s] -= f * (n && u ? -1 : 1);
			break;
		case "end":
			h[s] += f * (n && u ? -1 : 1);
			break;
	}
	return h;
}
const xle = async (t, e, n) => {
	const {
			placement: r = "bottom",
			strategy: i = "absolute",
			middleware: o = [],
			platform: s,
		} = n,
		a = o.filter(Boolean),
		l = await (s.isRTL == null ? void 0 : s.isRTL(e));
	let u = await s.getElementRects({ reference: t, floating: e, strategy: i }),
		{ x: c, y: d } = P$(u, r, l),
		f = r,
		h = {},
		p = 0;
	for (let g = 0; g < a.length; g++) {
		const { name: v, fn: b } = a[g],
			{
				x: y,
				y: x,
				data: C,
				reset: k,
			} = await b({
				x: c,
				y: d,
				initialPlacement: r,
				placement: f,
				strategy: i,
				middlewareData: h,
				rects: u,
				platform: s,
				elements: { reference: t, floating: e },
			});
		(c = y ?? c),
			(d = x ?? d),
			(h = { ...h, [v]: { ...h[v], ...C } }),
			k &&
				p <= 50 &&
				(p++,
				typeof k == "object" &&
					(k.placement && (f = k.placement),
					k.rects &&
						(u =
							k.rects === !0
								? await s.getElementRects({
										reference: t,
										floating: e,
										strategy: i,
									})
								: k.rects),
					({ x: c, y: d } = P$(u, f, l))),
				(g = -1));
	}
	return { x: c, y: d, placement: f, strategy: i, middlewareData: h };
};
async function Zm(t, e) {
	var n;
	e === void 0 && (e = {});
	const { x: r, y: i, platform: o, rects: s, elements: a, strategy: l } = t,
		{
			boundary: u = "clippingAncestors",
			rootBoundary: c = "viewport",
			elementContext: d = "floating",
			altBoundary: f = !1,
			padding: h = 0,
		} = Lu(e, t),
		p = yle(h),
		v = a[f ? (d === "floating" ? "reference" : "floating") : d],
		b = Nv(
			await o.getClippingRect({
				element:
					(n = await (o.isElement == null
						? void 0
						: o.isElement(v))) == null || n
						? v
						: v.contextElement ||
							(await (o.getDocumentElement == null
								? void 0
								: o.getDocumentElement(a.floating))),
				boundary: u,
				rootBoundary: c,
				strategy: l,
			}),
		),
		y =
			d === "floating"
				? {
						x: r,
						y: i,
						width: s.floating.width,
						height: s.floating.height,
					}
				: s.reference,
		x = await (o.getOffsetParent == null
			? void 0
			: o.getOffsetParent(a.floating)),
		C = (await (o.isElement == null ? void 0 : o.isElement(x)))
			? (await (o.getScale == null ? void 0 : o.getScale(x))) || {
					x: 1,
					y: 1,
				}
			: { x: 1, y: 1 },
		k = Nv(
			o.convertOffsetParentRelativeRectToViewportRelativeRect
				? await o.convertOffsetParentRelativeRectToViewportRelativeRect(
						{ elements: a, rect: y, offsetParent: x, strategy: l },
					)
				: y,
		);
	return {
		top: (b.top - k.top + p.top) / C.y,
		bottom: (k.bottom - b.bottom + p.bottom) / C.y,
		left: (b.left - k.left + p.left) / C.x,
		right: (k.right - b.right + p.right) / C.x,
	};
}
const kle = function (t) {
	return (
		t === void 0 && (t = {}),
		{
			name: "flip",
			options: t,
			async fn(e) {
				var n, r;
				const {
						placement: i,
						middlewareData: o,
						rects: s,
						initialPlacement: a,
						platform: l,
						elements: u,
					} = e,
					{
						mainAxis: c = !0,
						crossAxis: d = !0,
						fallbackPlacements: f,
						fallbackStrategy: h = "bestFit",
						fallbackAxisSideDirection: p = "none",
						flipAlignment: g = !0,
						...v
					} = Lu(t, e);
				if ((n = o.arrow) != null && n.alignmentOffset) return {};
				const b = bl(i),
					y = Vu(a),
					x = bl(a) === a,
					C = await (l.isRTL == null ? void 0 : l.isRTL(u.floating)),
					k = f || (x || !g ? [Pv(a)] : mle(a)),
					w = p !== "none";
				!f && w && k.push(...ble(a, g, p, C));
				const D = [a, ...k],
					S = await Zm(e, v),
					$ = [];
				let A = ((r = o.flip) == null ? void 0 : r.overflows) || [];
				if ((c && $.push(S[b]), d)) {
					const N = ple(i, s, C);
					$.push(S[N[0]], S[N[1]]);
				}
				if (
					((A = [...A, { placement: i, overflows: $ }]),
					!$.every((N) => N <= 0))
				) {
					var T, I;
					const N =
							(((T = o.flip) == null ? void 0 : T.index) || 0) +
							1,
						O = D[N];
					if (O)
						return {
							data: { index: N, overflows: A },
							reset: { placement: O },
						};
					let _ =
						(I = A.filter((j) => j.overflows[0] <= 0).sort(
							(j, V) => j.overflows[1] - V.overflows[1],
						)[0]) == null
							? void 0
							: I.placement;
					if (!_)
						switch (h) {
							case "bestFit": {
								var F;
								const j =
									(F = A.filter((V) => {
										if (w) {
											const K = Vu(V.placement);
											return K === y || K === "y";
										}
										return !0;
									})
										.map((V) => [
											V.placement,
											V.overflows
												.filter((K) => K > 0)
												.reduce((K, M) => K + M, 0),
										])
										.sort((V, K) => V[1] - K[1])[0]) == null
										? void 0
										: F[0];
								j && (_ = j);
								break;
							}
							case "initialPlacement":
								_ = a;
								break;
						}
					if (i !== _) return { reset: { placement: _ } };
				}
				return {};
			},
		}
	);
};
function N$(t, e) {
	return {
		top: t.top - e.height,
		right: t.right - e.width,
		bottom: t.bottom - e.height,
		left: t.left - e.width,
	};
}
function R$(t) {
	return dle.some((e) => t[e] >= 0);
}
const Cle = function (t) {
	return (
		t === void 0 && (t = {}),
		{
			name: "hide",
			options: t,
			async fn(e) {
				const { rects: n } = e,
					{ strategy: r = "referenceHidden", ...i } = Lu(t, e);
				switch (r) {
					case "referenceHidden": {
						const o = await Zm(e, {
								...i,
								elementContext: "reference",
							}),
							s = N$(o, n.reference);
						return {
							data: {
								referenceHiddenOffsets: s,
								referenceHidden: R$(s),
							},
						};
					}
					case "escaped": {
						const o = await Zm(e, { ...i, altBoundary: !0 }),
							s = N$(o, n.floating);
						return { data: { escapedOffsets: s, escaped: R$(s) } };
					}
					default:
						return {};
				}
			},
		}
	);
};
async function wle(t, e) {
	const { placement: n, platform: r, elements: i } = t,
		o = await (r.isRTL == null ? void 0 : r.isRTL(i.floating)),
		s = bl(n),
		a = C0(n),
		l = Vu(n) === "y",
		u = ["left", "top"].includes(s) ? -1 : 1,
		c = o && l ? -1 : 1,
		d = Lu(e, t);
	let {
		mainAxis: f,
		crossAxis: h,
		alignmentAxis: p,
	} = typeof d == "number"
		? { mainAxis: d, crossAxis: 0, alignmentAxis: null }
		: {
				mainAxis: d.mainAxis || 0,
				crossAxis: d.crossAxis || 0,
				alignmentAxis: d.alignmentAxis,
			};
	return (
		a && typeof p == "number" && (h = a === "end" ? p * -1 : p),
		l ? { x: h * c, y: f * u } : { x: f * u, y: h * c }
	);
}
const Ele = function (t) {
		return (
			t === void 0 && (t = 0),
			{
				name: "offset",
				options: t,
				async fn(e) {
					var n, r;
					const { x: i, y: o, placement: s, middlewareData: a } = e,
						l = await wle(e, t);
					return s ===
						((n = a.offset) == null ? void 0 : n.placement) &&
						(r = a.arrow) != null &&
						r.alignmentOffset
						? {}
						: {
								x: i + l.x,
								y: o + l.y,
								data: { ...l, placement: s },
							};
				},
			}
		);
	},
	Dle = function (t) {
		return (
			t === void 0 && (t = {}),
			{
				name: "shift",
				options: t,
				async fn(e) {
					const { x: n, y: r, placement: i } = e,
						{
							mainAxis: o = !0,
							crossAxis: s = !1,
							limiter: a = {
								fn: (v) => {
									let { x: b, y } = v;
									return { x: b, y };
								},
							},
							...l
						} = Lu(t, e),
						u = { x: n, y: r },
						c = await Zm(e, l),
						d = Vu(bl(i)),
						f = KD(d);
					let h = u[f],
						p = u[d];
					if (o) {
						const v = f === "y" ? "top" : "left",
							b = f === "y" ? "bottom" : "right",
							y = h + c[v],
							x = h - c[b];
						h = F$(y, h, x);
					}
					if (s) {
						const v = d === "y" ? "top" : "left",
							b = d === "y" ? "bottom" : "right",
							y = p + c[v],
							x = p - c[b];
						p = F$(y, p, x);
					}
					const g = a.fn({ ...e, [f]: h, [d]: p });
					return {
						...g,
						data: {
							x: g.x - n,
							y: g.y - r,
							enabled: { [f]: o, [d]: s },
						},
					};
				},
			}
		);
	},
	Sle = function (t) {
		return (
			t === void 0 && (t = {}),
			{
				options: t,
				fn(e) {
					const {
							x: n,
							y: r,
							placement: i,
							rects: o,
							middlewareData: s,
						} = e,
						{
							offset: a = 0,
							mainAxis: l = !0,
							crossAxis: u = !0,
						} = Lu(t, e),
						c = { x: n, y: r },
						d = Vu(i),
						f = KD(d);
					let h = c[f],
						p = c[d];
					const g = Lu(a, e),
						v =
							typeof g == "number"
								? { mainAxis: g, crossAxis: 0 }
								: { mainAxis: 0, crossAxis: 0, ...g };
					if (l) {
						const x = f === "y" ? "height" : "width",
							C = o.reference[f] - o.floating[x] + v.mainAxis,
							k = o.reference[f] + o.reference[x] - v.mainAxis;
						h < C ? (h = C) : h > k && (h = k);
					}
					if (u) {
						var b, y;
						const x = f === "y" ? "width" : "height",
							C = ["top", "left"].includes(bl(i)),
							k =
								o.reference[d] -
								o.floating[x] +
								((C &&
									((b = s.offset) == null ? void 0 : b[d])) ||
									0) +
								(C ? 0 : v.crossAxis),
							w =
								o.reference[d] +
								o.reference[x] +
								(C
									? 0
									: ((y = s.offset) == null
											? void 0
											: y[d]) || 0) -
								(C ? v.crossAxis : 0);
						p < k ? (p = k) : p > w && (p = w);
					}
					return { [f]: h, [d]: p };
				},
			}
		);
	},
	Ale = function (t) {
		return (
			t === void 0 && (t = {}),
			{
				name: "size",
				options: t,
				async fn(e) {
					var n, r;
					const {
							placement: i,
							rects: o,
							platform: s,
							elements: a,
						} = e,
						{ apply: l = () => {}, ...u } = Lu(t, e),
						c = await Zm(e, u),
						d = bl(i),
						f = C0(i),
						h = Vu(i) === "y",
						{ width: p, height: g } = o.floating;
					let v, b;
					d === "top" || d === "bottom"
						? ((v = d),
							(b =
								f ===
								((await (s.isRTL == null
									? void 0
									: s.isRTL(a.floating)))
									? "start"
									: "end")
									? "left"
									: "right"))
						: ((b = d), (v = f === "end" ? "top" : "bottom"));
					const y = g - c.top - c.bottom,
						x = p - c.left - c.right,
						C = Eh(g - c[v], y),
						k = Eh(p - c[b], x),
						w = !e.middlewareData.shift;
					let D = C,
						S = k;
					if (
						((n = e.middlewareData.shift) != null &&
							n.enabled.x &&
							(S = x),
						(r = e.middlewareData.shift) != null &&
							r.enabled.y &&
							(D = y),
						w && !f)
					) {
						const A = eo(c.left, 0),
							T = eo(c.right, 0),
							I = eo(c.top, 0),
							F = eo(c.bottom, 0);
						h
							? (S =
									p -
									2 *
										(A !== 0 || T !== 0
											? A + T
											: eo(c.left, c.right)))
							: (D =
									g -
									2 *
										(I !== 0 || F !== 0
											? I + F
											: eo(c.top, c.bottom)));
					}
					await l({ ...e, availableWidth: S, availableHeight: D });
					const $ = await s.getDimensions(a.floating);
					return p !== $.width || g !== $.height
						? { reset: { rects: !0 } }
						: {};
				},
			}
		);
	};
function _x() {
	return typeof window < "u";
}
function ep(t) {
	return Nj(t) ? (t.nodeName || "").toLowerCase() : "#document";
}
function so(t) {
	var e;
	return (
		(t == null || (e = t.ownerDocument) == null ? void 0 : e.defaultView) ||
		window
	);
}
function Da(t) {
	var e;
	return (e = (Nj(t) ? t.ownerDocument : t.document) || window.document) ==
		null
		? void 0
		: e.documentElement;
}
function Nj(t) {
	return _x() ? t instanceof Node || t instanceof so(t).Node : !1;
}
function $s(t) {
	return _x() ? t instanceof Element || t instanceof so(t).Element : !1;
}
function pa(t) {
	return _x()
		? t instanceof HTMLElement || t instanceof so(t).HTMLElement
		: !1;
}
function O$(t) {
	return !_x() || typeof ShadowRoot > "u"
		? !1
		: t instanceof ShadowRoot || t instanceof so(t).ShadowRoot;
}
function w0(t) {
	const { overflow: e, overflowX: n, overflowY: r, display: i } = Ts(t);
	return (
		/auto|scroll|overlay|hidden|clip/.test(e + r + n) &&
		!["inline", "contents"].includes(i)
	);
}
function $le(t) {
	return ["table", "td", "th"].includes(ep(t));
}
function zx(t) {
	return [":popover-open", ":modal"].some((e) => {
		try {
			return t.matches(e);
		} catch {
			return !1;
		}
	});
}
function UD(t) {
	const e = HD(),
		n = $s(t) ? Ts(t) : t;
	return (
		n.transform !== "none" ||
		n.perspective !== "none" ||
		(n.containerType ? n.containerType !== "normal" : !1) ||
		(!e && (n.backdropFilter ? n.backdropFilter !== "none" : !1)) ||
		(!e && (n.filter ? n.filter !== "none" : !1)) ||
		["transform", "perspective", "filter"].some((r) =>
			(n.willChange || "").includes(r),
		) ||
		["paint", "layout", "strict", "content"].some((r) =>
			(n.contain || "").includes(r),
		)
	);
}
function Tle(t) {
	let e = Ku(t);
	for (; pa(e) && !Dh(e); ) {
		if (UD(e)) return e;
		if (zx(e)) return null;
		e = Ku(e);
	}
	return null;
}
function HD() {
	return typeof CSS > "u" || !CSS.supports
		? !1
		: CSS.supports("-webkit-backdrop-filter", "none");
}
function Dh(t) {
	return ["html", "body", "#document"].includes(ep(t));
}
function Ts(t) {
	return so(t).getComputedStyle(t);
}
function Lx(t) {
	return $s(t)
		? { scrollLeft: t.scrollLeft, scrollTop: t.scrollTop }
		: { scrollLeft: t.scrollX, scrollTop: t.scrollY };
}
function Ku(t) {
	if (ep(t) === "html") return t;
	const e = t.assignedSlot || t.parentNode || (O$(t) && t.host) || Da(t);
	return O$(e) ? e.host : e;
}
function Rj(t) {
	const e = Ku(t);
	return Dh(e)
		? t.ownerDocument
			? t.ownerDocument.body
			: t.body
		: pa(e) && w0(e)
			? e
			: Rj(e);
}
function Qm(t, e, n) {
	var r;
	e === void 0 && (e = []), n === void 0 && (n = !0);
	const i = Rj(t),
		o = i === ((r = t.ownerDocument) == null ? void 0 : r.body),
		s = so(i);
	if (o) {
		const a = $w(s);
		return e.concat(
			s,
			s.visualViewport || [],
			w0(i) ? i : [],
			a && n ? Qm(a) : [],
		);
	}
	return e.concat(i, Qm(i, [], n));
}
function $w(t) {
	return t.parent && Object.getPrototypeOf(t.parent) ? t.frameElement : null;
}
function Oj(t) {
	const e = Ts(t);
	let n = parseFloat(e.width) || 0,
		r = parseFloat(e.height) || 0;
	const i = pa(t),
		o = i ? t.offsetWidth : n,
		s = i ? t.offsetHeight : r,
		a = Fv(n) !== o || Fv(r) !== s;
	return a && ((n = o), (r = s)), { width: n, height: r, $: a };
}
function WD(t) {
	return $s(t) ? t : t.contextElement;
}
function ih(t) {
	const e = WD(t);
	if (!pa(e)) return zu(1);
	const n = e.getBoundingClientRect(),
		{ width: r, height: i, $: o } = Oj(e);
	let s = (o ? Fv(n.width) : n.width) / r,
		a = (o ? Fv(n.height) : n.height) / i;
	return (
		(!s || !Number.isFinite(s)) && (s = 1),
		(!a || !Number.isFinite(a)) && (a = 1),
		{ x: s, y: a }
	);
}
const Ble = zu(0);
function Mj(t) {
	const e = so(t);
	return !HD() || !e.visualViewport
		? Ble
		: { x: e.visualViewport.offsetLeft, y: e.visualViewport.offsetTop };
}
function Ile(t, e, n) {
	return e === void 0 && (e = !1), !n || (e && n !== so(t)) ? !1 : e;
}
function xd(t, e, n, r) {
	e === void 0 && (e = !1), n === void 0 && (n = !1);
	const i = t.getBoundingClientRect(),
		o = WD(t);
	let s = zu(1);
	e && (r ? $s(r) && (s = ih(r)) : (s = ih(t)));
	const a = Ile(o, n, r) ? Mj(o) : zu(0);
	let l = (i.left + a.x) / s.x,
		u = (i.top + a.y) / s.y,
		c = i.width / s.x,
		d = i.height / s.y;
	if (o) {
		const f = so(o),
			h = r && $s(r) ? so(r) : r;
		let p = f,
			g = $w(p);
		for (; g && r && h !== p; ) {
			const v = ih(g),
				b = g.getBoundingClientRect(),
				y = Ts(g),
				x = b.left + (g.clientLeft + parseFloat(y.paddingLeft)) * v.x,
				C = b.top + (g.clientTop + parseFloat(y.paddingTop)) * v.y;
			(l *= v.x),
				(u *= v.y),
				(c *= v.x),
				(d *= v.y),
				(l += x),
				(u += C),
				(p = so(g)),
				(g = $w(p));
		}
	}
	return Nv({ width: c, height: d, x: l, y: u });
}
function Fle(t) {
	let { elements: e, rect: n, offsetParent: r, strategy: i } = t;
	const o = i === "fixed",
		s = Da(r),
		a = e ? zx(e.floating) : !1;
	if (r === s || (a && o)) return n;
	let l = { scrollLeft: 0, scrollTop: 0 },
		u = zu(1);
	const c = zu(0),
		d = pa(r);
	if (
		(d || (!d && !o)) &&
		((ep(r) !== "body" || w0(s)) && (l = Lx(r)), pa(r))
	) {
		const f = xd(r);
		(u = ih(r)), (c.x = f.x + r.clientLeft), (c.y = f.y + r.clientTop);
	}
	return {
		width: n.width * u.x,
		height: n.height * u.y,
		x: n.x * u.x - l.scrollLeft * u.x + c.x,
		y: n.y * u.y - l.scrollTop * u.y + c.y,
	};
}
function Ple(t) {
	return Array.from(t.getClientRects());
}
function Tw(t, e) {
	const n = Lx(t).scrollLeft;
	return e ? e.left + n : xd(Da(t)).left + n;
}
function Nle(t) {
	const e = Da(t),
		n = Lx(t),
		r = t.ownerDocument.body,
		i = eo(e.scrollWidth, e.clientWidth, r.scrollWidth, r.clientWidth),
		o = eo(e.scrollHeight, e.clientHeight, r.scrollHeight, r.clientHeight);
	let s = -n.scrollLeft + Tw(t);
	const a = -n.scrollTop;
	return (
		Ts(r).direction === "rtl" &&
			(s += eo(e.clientWidth, r.clientWidth) - i),
		{ width: i, height: o, x: s, y: a }
	);
}
function Rle(t, e) {
	const n = so(t),
		r = Da(t),
		i = n.visualViewport;
	let o = r.clientWidth,
		s = r.clientHeight,
		a = 0,
		l = 0;
	if (i) {
		(o = i.width), (s = i.height);
		const u = HD();
		(!u || (u && e === "fixed")) && ((a = i.offsetLeft), (l = i.offsetTop));
	}
	return { width: o, height: s, x: a, y: l };
}
function Ole(t, e) {
	const n = xd(t, !0, e === "fixed"),
		r = n.top + t.clientTop,
		i = n.left + t.clientLeft,
		o = pa(t) ? ih(t) : zu(1),
		s = t.clientWidth * o.x,
		a = t.clientHeight * o.y,
		l = i * o.x,
		u = r * o.y;
	return { width: s, height: a, x: l, y: u };
}
function M$(t, e, n) {
	let r;
	if (e === "viewport") r = Rle(t, n);
	else if (e === "document") r = Nle(Da(t));
	else if ($s(e)) r = Ole(e, n);
	else {
		const i = Mj(t);
		r = { ...e, x: e.x - i.x, y: e.y - i.y };
	}
	return Nv(r);
}
function jj(t, e) {
	const n = Ku(t);
	return n === e || !$s(n) || Dh(n)
		? !1
		: Ts(n).position === "fixed" || jj(n, e);
}
function Mle(t, e) {
	const n = e.get(t);
	if (n) return n;
	let r = Qm(t, [], !1).filter((a) => $s(a) && ep(a) !== "body"),
		i = null;
	const o = Ts(t).position === "fixed";
	let s = o ? Ku(t) : t;
	for (; $s(s) && !Dh(s); ) {
		const a = Ts(s),
			l = UD(s);
		!l && a.position === "fixed" && (i = null),
			(
				o
					? !l && !i
					: (!l &&
							a.position === "static" &&
							!!i &&
							["absolute", "fixed"].includes(i.position)) ||
						(w0(s) && !l && jj(t, s))
			)
				? (r = r.filter((c) => c !== s))
				: (i = a),
			(s = Ku(s));
	}
	return e.set(t, r), r;
}
function jle(t) {
	let { element: e, boundary: n, rootBoundary: r, strategy: i } = t;
	const s = [
			...(n === "clippingAncestors"
				? zx(e)
					? []
					: Mle(e, this._c)
				: [].concat(n)),
			r,
		],
		a = s[0],
		l = s.reduce(
			(u, c) => {
				const d = M$(e, c, i);
				return (
					(u.top = eo(d.top, u.top)),
					(u.right = Eh(d.right, u.right)),
					(u.bottom = Eh(d.bottom, u.bottom)),
					(u.left = eo(d.left, u.left)),
					u
				);
			},
			M$(e, a, i),
		);
	return {
		width: l.right - l.left,
		height: l.bottom - l.top,
		x: l.left,
		y: l.top,
	};
}
function _le(t) {
	const { width: e, height: n } = Oj(t);
	return { width: e, height: n };
}
function zle(t, e, n) {
	const r = pa(e),
		i = Da(e),
		o = n === "fixed",
		s = xd(t, !0, o, e);
	let a = { scrollLeft: 0, scrollTop: 0 };
	const l = zu(0);
	if (r || (!r && !o))
		if (((ep(e) !== "body" || w0(i)) && (a = Lx(e)), r)) {
			const h = xd(e, !0, o, e);
			(l.x = h.x + e.clientLeft), (l.y = h.y + e.clientTop);
		} else i && (l.x = Tw(i));
	let u = 0,
		c = 0;
	if (i && !r && !o) {
		const h = i.getBoundingClientRect();
		(c = h.top + a.scrollTop), (u = h.left + a.scrollLeft - Tw(i, h));
	}
	const d = s.left + a.scrollLeft - l.x - u,
		f = s.top + a.scrollTop - l.y - c;
	return { x: d, y: f, width: s.width, height: s.height };
}
function tk(t) {
	return Ts(t).position === "static";
}
function j$(t, e) {
	if (!pa(t) || Ts(t).position === "fixed") return null;
	if (e) return e(t);
	let n = t.offsetParent;
	return Da(t) === n && (n = n.ownerDocument.body), n;
}
function _j(t, e) {
	const n = so(t);
	if (zx(t)) return n;
	if (!pa(t)) {
		let i = Ku(t);
		for (; i && !Dh(i); ) {
			if ($s(i) && !tk(i)) return i;
			i = Ku(i);
		}
		return n;
	}
	let r = j$(t, e);
	for (; r && $le(r) && tk(r); ) r = j$(r, e);
	return r && Dh(r) && tk(r) && !UD(r) ? n : r || Tle(t) || n;
}
const Lle = async function (t) {
	const e = this.getOffsetParent || _j,
		n = this.getDimensions,
		r = await n(t.floating);
	return {
		reference: zle(t.reference, await e(t.floating), t.strategy),
		floating: { x: 0, y: 0, width: r.width, height: r.height },
	};
};
function Vle(t) {
	return Ts(t).direction === "rtl";
}
const Kle = {
	convertOffsetParentRelativeRectToViewportRelativeRect: Fle,
	getDocumentElement: Da,
	getClippingRect: jle,
	getOffsetParent: _j,
	getElementRects: Lle,
	getClientRects: Ple,
	getDimensions: _le,
	getScale: ih,
	isElement: $s,
	isRTL: Vle,
};
function Ule(t, e) {
	let n = null,
		r;
	const i = Da(t);
	function o() {
		var a;
		clearTimeout(r), (a = n) == null || a.disconnect(), (n = null);
	}
	function s(a, l) {
		a === void 0 && (a = !1), l === void 0 && (l = 1), o();
		const {
			left: u,
			top: c,
			width: d,
			height: f,
		} = t.getBoundingClientRect();
		if ((a || e(), !d || !f)) return;
		const h = C1(c),
			p = C1(i.clientWidth - (u + d)),
			g = C1(i.clientHeight - (c + f)),
			v = C1(u),
			y = {
				rootMargin: -h + "px " + -p + "px " + -g + "px " + -v + "px",
				threshold: eo(0, Eh(1, l)) || 1,
			};
		let x = !0;
		function C(k) {
			const w = k[0].intersectionRatio;
			if (w !== l) {
				if (!x) return s();
				w
					? s(!1, w)
					: (r = setTimeout(() => {
							s(!1, 1e-7);
						}, 1e3));
			}
			x = !1;
		}
		try {
			n = new IntersectionObserver(C, { ...y, root: i.ownerDocument });
		} catch {
			n = new IntersectionObserver(C, y);
		}
		n.observe(t);
	}
	return s(!0), o;
}
function Hle(t, e, n, r) {
	r === void 0 && (r = {});
	const {
			ancestorScroll: i = !0,
			ancestorResize: o = !0,
			elementResize: s = typeof ResizeObserver == "function",
			layoutShift: a = typeof IntersectionObserver == "function",
			animationFrame: l = !1,
		} = r,
		u = WD(t),
		c = i || o ? [...(u ? Qm(u) : []), ...Qm(e)] : [];
	c.forEach((b) => {
		i && b.addEventListener("scroll", n, { passive: !0 }),
			o && b.addEventListener("resize", n);
	});
	const d = u && a ? Ule(u, n) : null;
	let f = -1,
		h = null;
	s &&
		((h = new ResizeObserver((b) => {
			let [y] = b;
			y &&
				y.target === u &&
				h &&
				(h.unobserve(e),
				cancelAnimationFrame(f),
				(f = requestAnimationFrame(() => {
					var x;
					(x = h) == null || x.observe(e);
				}))),
				n();
		})),
		u && !l && h.observe(u),
		h.observe(e));
	let p,
		g = l ? xd(t) : null;
	l && v();
	function v() {
		const b = xd(t);
		g &&
			(b.x !== g.x ||
				b.y !== g.y ||
				b.width !== g.width ||
				b.height !== g.height) &&
			n(),
			(g = b),
			(p = requestAnimationFrame(v));
	}
	return (
		n(),
		() => {
			var b;
			c.forEach((y) => {
				i && y.removeEventListener("scroll", n),
					o && y.removeEventListener("resize", n);
			}),
				d == null || d(),
				(b = h) == null || b.disconnect(),
				(h = null),
				l && cancelAnimationFrame(p);
		}
	);
}
const Wle = Ele,
	qle = Dle,
	Gle = kle,
	Yle = Ale,
	Jle = Cle,
	Xle = Sle,
	Zle = (t, e, n) => {
		const r = new Map(),
			i = { platform: Kle, ...n },
			o = { ...i.platform, _c: r };
		return xle(t, e, { ...i, platform: o });
	};
var db = typeof document < "u" ? E.useLayoutEffect : E.useEffect;
function Rv(t, e) {
	if (t === e) return !0;
	if (typeof t != typeof e) return !1;
	if (typeof t == "function" && t.toString() === e.toString()) return !0;
	let n, r, i;
	if (t && e && typeof t == "object") {
		if (Array.isArray(t)) {
			if (((n = t.length), n !== e.length)) return !1;
			for (r = n; r-- !== 0; ) if (!Rv(t[r], e[r])) return !1;
			return !0;
		}
		if (((i = Object.keys(t)), (n = i.length), n !== Object.keys(e).length))
			return !1;
		for (r = n; r-- !== 0; )
			if (!{}.hasOwnProperty.call(e, i[r])) return !1;
		for (r = n; r-- !== 0; ) {
			const o = i[r];
			if (!(o === "_owner" && t.$$typeof) && !Rv(t[o], e[o])) return !1;
		}
		return !0;
	}
	return t !== t && e !== e;
}
function zj(t) {
	return typeof window > "u"
		? 1
		: (t.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function _$(t, e) {
	const n = zj(t);
	return Math.round(e * n) / n;
}
function nk(t) {
	const e = E.useRef(t);
	return (
		db(() => {
			e.current = t;
		}),
		e
	);
}
function Qle(t) {
	t === void 0 && (t = {});
	const {
			placement: e = "bottom",
			strategy: n = "absolute",
			middleware: r = [],
			platform: i,
			elements: { reference: o, floating: s } = {},
			transform: a = !0,
			whileElementsMounted: l,
			open: u,
		} = t,
		[c, d] = E.useState({
			x: 0,
			y: 0,
			strategy: n,
			placement: e,
			middlewareData: {},
			isPositioned: !1,
		}),
		[f, h] = E.useState(r);
	Rv(f, r) || h(r);
	const [p, g] = E.useState(null),
		[v, b] = E.useState(null),
		y = E.useCallback((V) => {
			V !== w.current && ((w.current = V), g(V));
		}, []),
		x = E.useCallback((V) => {
			V !== D.current && ((D.current = V), b(V));
		}, []),
		C = o || p,
		k = s || v,
		w = E.useRef(null),
		D = E.useRef(null),
		S = E.useRef(c),
		$ = l != null,
		A = nk(l),
		T = nk(i),
		I = nk(u),
		F = E.useCallback(() => {
			if (!w.current || !D.current) return;
			const V = { placement: e, strategy: n, middleware: f };
			T.current && (V.platform = T.current),
				Zle(w.current, D.current, V).then((K) => {
					const M = { ...K, isPositioned: I.current !== !1 };
					N.current &&
						!Rv(S.current, M) &&
						((S.current = M),
						nl.flushSync(() => {
							d(M);
						}));
				});
		}, [f, e, n, T, I]);
	db(() => {
		u === !1 &&
			S.current.isPositioned &&
			((S.current.isPositioned = !1),
			d((V) => ({ ...V, isPositioned: !1 })));
	}, [u]);
	const N = E.useRef(!1);
	db(
		() => (
			(N.current = !0),
			() => {
				N.current = !1;
			}
		),
		[],
	),
		db(() => {
			if ((C && (w.current = C), k && (D.current = k), C && k)) {
				if (A.current) return A.current(C, k, F);
				F();
			}
		}, [C, k, F, A, $]);
	const O = E.useMemo(
			() => ({
				reference: w,
				floating: D,
				setReference: y,
				setFloating: x,
			}),
			[y, x],
		),
		_ = E.useMemo(() => ({ reference: C, floating: k }), [C, k]),
		j = E.useMemo(() => {
			const V = { position: n, left: 0, top: 0 };
			if (!_.floating) return V;
			const K = _$(_.floating, c.x),
				M = _$(_.floating, c.y);
			return a
				? {
						...V,
						transform: "translate(" + K + "px, " + M + "px)",
						...(zj(_.floating) >= 1.5 && {
							willChange: "transform",
						}),
					}
				: { position: n, left: K, top: M };
		}, [n, a, _.floating, c.x, c.y]);
	return E.useMemo(
		() => ({ ...c, update: F, refs: O, elements: _, floatingStyles: j }),
		[c, F, O, _, j],
	);
}
const rk = (t, e) => ({ ...Wle(t), options: [t, e] }),
	z$ = (t, e) => ({ ...qle(t), options: [t, e] }),
	eue = (t, e) => ({ ...Xle(t), options: [t, e] }),
	L$ = (t, e) => ({ ...Gle(t), options: [t, e] }),
	tue = (t, e) => ({ ...Yle(t), options: [t, e] }),
	nue = (t, e) => ({ ...Jle(t), options: [t, e] });
/*!
 * tabbable 6.2.0
 * @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
 */ var rue = [
		"input:not([inert])",
		"select:not([inert])",
		"textarea:not([inert])",
		"a[href]:not([inert])",
		"button:not([inert])",
		"[tabindex]:not(slot):not([inert])",
		"audio[controls]:not([inert])",
		"video[controls]:not([inert])",
		'[contenteditable]:not([contenteditable="false"]):not([inert])',
		"details>summary:first-of-type:not([inert])",
		"details:not([inert])",
	],
	Bw = rue.join(","),
	Lj = typeof Element > "u",
	eg = Lj
		? function () {}
		: Element.prototype.matches ||
			Element.prototype.msMatchesSelector ||
			Element.prototype.webkitMatchesSelector,
	Ov =
		!Lj && Element.prototype.getRootNode
			? function (t) {
					var e;
					return t == null ||
						(e = t.getRootNode) === null ||
						e === void 0
						? void 0
						: e.call(t);
				}
			: function (t) {
					return t == null ? void 0 : t.ownerDocument;
				},
	Mv = function t(e, n) {
		var r;
		n === void 0 && (n = !0);
		var i =
				e == null || (r = e.getAttribute) === null || r === void 0
					? void 0
					: r.call(e, "inert"),
			o = i === "" || i === "true",
			s = o || (n && e && t(e.parentNode));
		return s;
	},
	iue = function (e) {
		var n,
			r =
				e == null || (n = e.getAttribute) === null || n === void 0
					? void 0
					: n.call(e, "contenteditable");
		return r === "" || r === "true";
	},
	oue = function (e, n, r) {
		if (Mv(e)) return [];
		var i = Array.prototype.slice.apply(e.querySelectorAll(Bw));
		return n && eg.call(e, Bw) && i.unshift(e), (i = i.filter(r)), i;
	},
	sue = function t(e, n, r) {
		for (var i = [], o = Array.from(e); o.length; ) {
			var s = o.shift();
			if (!Mv(s, !1))
				if (s.tagName === "SLOT") {
					var a = s.assignedElements(),
						l = a.length ? a : s.children,
						u = t(l, !0, r);
					r.flatten
						? i.push.apply(i, u)
						: i.push({ scopeParent: s, candidates: u });
				} else {
					var c = eg.call(s, Bw);
					c && r.filter(s) && (n || !e.includes(s)) && i.push(s);
					var d =
							s.shadowRoot ||
							(typeof r.getShadowRoot == "function" &&
								r.getShadowRoot(s)),
						f =
							!Mv(d, !1) &&
							(!r.shadowRootFilter || r.shadowRootFilter(s));
					if (d && f) {
						var h = t(d === !0 ? s.children : d.children, !0, r);
						r.flatten
							? i.push.apply(i, h)
							: i.push({ scopeParent: s, candidates: h });
					} else o.unshift.apply(o, s.children);
				}
		}
		return i;
	},
	Vj = function (e) {
		return !isNaN(parseInt(e.getAttribute("tabindex"), 10));
	},
	Kj = function (e) {
		if (!e) throw new Error("No node provided");
		return e.tabIndex < 0 &&
			(/^(AUDIO|VIDEO|DETAILS)$/.test(e.tagName) || iue(e)) &&
			!Vj(e)
			? 0
			: e.tabIndex;
	},
	aue = function (e, n) {
		var r = Kj(e);
		return r < 0 && n && !Vj(e) ? 0 : r;
	},
	lue = function (e, n) {
		return e.tabIndex === n.tabIndex
			? e.documentOrder - n.documentOrder
			: e.tabIndex - n.tabIndex;
	},
	Uj = function (e) {
		return e.tagName === "INPUT";
	},
	uue = function (e) {
		return Uj(e) && e.type === "hidden";
	},
	cue = function (e) {
		var n =
			e.tagName === "DETAILS" &&
			Array.prototype.slice.apply(e.children).some(function (r) {
				return r.tagName === "SUMMARY";
			});
		return n;
	},
	due = function (e, n) {
		for (var r = 0; r < e.length; r++)
			if (e[r].checked && e[r].form === n) return e[r];
	},
	fue = function (e) {
		if (!e.name) return !0;
		var n = e.form || Ov(e),
			r = function (a) {
				return n.querySelectorAll(
					'input[type="radio"][name="' + a + '"]',
				);
			},
			i;
		if (
			typeof window < "u" &&
			typeof window.CSS < "u" &&
			typeof window.CSS.escape == "function"
		)
			i = r(window.CSS.escape(e.name));
		else
			try {
				i = r(e.name);
			} catch (s) {
				return (
					console.error(
						"Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s",
						s.message,
					),
					!1
				);
			}
		var o = due(i, e.form);
		return !o || o === e;
	},
	hue = function (e) {
		return Uj(e) && e.type === "radio";
	},
	pue = function (e) {
		return hue(e) && !fue(e);
	},
	mue = function (e) {
		var n,
			r = e && Ov(e),
			i = (n = r) === null || n === void 0 ? void 0 : n.host,
			o = !1;
		if (r && r !== e) {
			var s, a, l;
			for (
				o = !!(
					((s = i) !== null &&
						s !== void 0 &&
						(a = s.ownerDocument) !== null &&
						a !== void 0 &&
						a.contains(i)) ||
					(e != null &&
						(l = e.ownerDocument) !== null &&
						l !== void 0 &&
						l.contains(e))
				);
				!o && i;

			) {
				var u, c, d;
				(r = Ov(i)),
					(i = (u = r) === null || u === void 0 ? void 0 : u.host),
					(o = !!(
						(c = i) !== null &&
						c !== void 0 &&
						(d = c.ownerDocument) !== null &&
						d !== void 0 &&
						d.contains(i)
					));
			}
		}
		return o;
	},
	V$ = function (e) {
		var n = e.getBoundingClientRect(),
			r = n.width,
			i = n.height;
		return r === 0 && i === 0;
	},
	gue = function (e, n) {
		var r = n.displayCheck,
			i = n.getShadowRoot;
		if (getComputedStyle(e).visibility === "hidden") return !0;
		var o = eg.call(e, "details>summary:first-of-type"),
			s = o ? e.parentElement : e;
		if (eg.call(s, "details:not([open]) *")) return !0;
		if (!r || r === "full" || r === "legacy-full") {
			if (typeof i == "function") {
				for (var a = e; e; ) {
					var l = e.parentElement,
						u = Ov(e);
					if (l && !l.shadowRoot && i(l) === !0) return V$(e);
					e.assignedSlot
						? (e = e.assignedSlot)
						: !l && u !== e.ownerDocument
							? (e = u.host)
							: (e = l);
				}
				e = a;
			}
			if (mue(e)) return !e.getClientRects().length;
			if (r !== "legacy-full") return !0;
		} else if (r === "non-zero-area") return V$(e);
		return !1;
	},
	bue = function (e) {
		if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(e.tagName))
			for (var n = e.parentElement; n; ) {
				if (n.tagName === "FIELDSET" && n.disabled) {
					for (var r = 0; r < n.children.length; r++) {
						var i = n.children.item(r);
						if (i.tagName === "LEGEND")
							return eg.call(n, "fieldset[disabled] *")
								? !0
								: !i.contains(e);
					}
					return !0;
				}
				n = n.parentElement;
			}
		return !1;
	},
	vue = function (e, n) {
		return !(
			n.disabled ||
			Mv(n) ||
			uue(n) ||
			gue(n, e) ||
			cue(n) ||
			bue(n)
		);
	},
	K$ = function (e, n) {
		return !(pue(n) || Kj(n) < 0 || !vue(e, n));
	},
	yue = function (e) {
		var n = parseInt(e.getAttribute("tabindex"), 10);
		return !!(isNaN(n) || n >= 0);
	},
	xue = function t(e) {
		var n = [],
			r = [];
		return (
			e.forEach(function (i, o) {
				var s = !!i.scopeParent,
					a = s ? i.scopeParent : i,
					l = aue(a, s),
					u = s ? t(i.candidates) : a;
				l === 0
					? s
						? n.push.apply(n, u)
						: n.push(a)
					: r.push({
							documentOrder: o,
							tabIndex: l,
							item: i,
							isScope: s,
							content: u,
						});
			}),
			r
				.sort(lue)
				.reduce(function (i, o) {
					return (
						o.isScope
							? i.push.apply(i, o.content)
							: i.push(o.content),
						i
					);
				}, [])
				.concat(n)
		);
	},
	Hj = function (e, n) {
		n = n || {};
		var r;
		return (
			n.getShadowRoot
				? (r = sue([e], n.includeContainer, {
						filter: K$.bind(null, n),
						flatten: !1,
						getShadowRoot: n.getShadowRoot,
						shadowRootFilter: yue,
					}))
				: (r = oue(e, n.includeContainer, K$.bind(null, n))),
			xue(r)
		);
	};
function Iw() {
	return (
		(Iw = Object.assign
			? Object.assign.bind()
			: function (t) {
					for (var e = 1; e < arguments.length; e++) {
						var n = arguments[e];
						for (var r in n)
							Object.prototype.hasOwnProperty.call(n, r) &&
								(t[r] = n[r]);
					}
					return t;
				}),
		Iw.apply(this, arguments)
	);
}
var tg = typeof document < "u" ? E.useLayoutEffect : E.useEffect;
let ik = !1,
	kue = 0;
const U$ = () => "floating-ui-" + kue++;
function Cue() {
	const [t, e] = E.useState(() => (ik ? U$() : void 0));
	return (
		tg(() => {
			t == null && e(U$());
		}, []),
		E.useEffect(() => {
			ik || (ik = !0);
		}, []),
		t
	);
}
const wue = J8.useId,
	Wj = wue || Cue;
function Eue() {
	const t = new Map();
	return {
		emit(e, n) {
			var r;
			(r = t.get(e)) == null || r.forEach((i) => i(n));
		},
		on(e, n) {
			t.set(e, [...(t.get(e) || []), n]);
		},
		off(e, n) {
			var r;
			t.set(
				e,
				((r = t.get(e)) == null ? void 0 : r.filter((i) => i !== n)) ||
					[],
			);
		},
	};
}
const Due = E.createContext(null),
	Sue = () => E.useContext(Due);
function qj(t) {
	return (t == null ? void 0 : t.ownerDocument) || document;
}
function Gj(t) {
	return qj(t).defaultView || window;
}
function em(t) {
	return t ? t instanceof Element || t instanceof Gj(t).Element : !1;
}
function Aue(t) {
	if (typeof ShadowRoot > "u") return !1;
	const e = Gj(t).ShadowRoot;
	return t instanceof e || t instanceof ShadowRoot;
}
function $ue() {
	return /apple/i.test(navigator.vendor);
}
function Tue(t, e) {
	if (!t || !e) return !1;
	const n = e.getRootNode && e.getRootNode();
	if (t.contains(e)) return !0;
	if (n && Aue(n)) {
		let r = e;
		for (; r; ) {
			if (t === r) return !0;
			r = r.parentNode || r.host;
		}
	}
	return !1;
}
function Yj(t) {
	return "data-floating-ui-" + t;
}
function Bue(t) {
	let e = t.activeElement;
	for (
		;
		((n = e) == null || (r = n.shadowRoot) == null
			? void 0
			: r.activeElement) != null;

	) {
		var n, r;
		e = e.shadowRoot.activeElement;
	}
	return e;
}
const Jj = () => ({
	getShadowRoot: !0,
	displayCheck:
		typeof ResizeObserver == "function" &&
		ResizeObserver.toString().includes("[native code]")
			? "full"
			: "none",
});
function Xj(t, e) {
	const n = Hj(t, Jj());
	e === "prev" && n.reverse();
	const r = n.indexOf(Bue(qj(t)));
	return n.slice(r + 1)[0];
}
function Iue() {
	return Xj(document.body, "next");
}
function Fue() {
	return Xj(document.body, "prev");
}
function ok(t, e) {
	const n = e || t.currentTarget,
		r = t.relatedTarget;
	return !r || !Tue(n, r);
}
function Pue(t) {
	Hj(t, Jj()).forEach((n) => {
		(n.dataset.tabindex = n.getAttribute("tabindex") || ""),
			n.setAttribute("tabindex", "-1");
	});
}
function Nue(t) {
	t.querySelectorAll("[data-tabindex]").forEach((n) => {
		const r = n.dataset.tabindex;
		delete n.dataset.tabindex,
			r ? n.setAttribute("tabindex", r) : n.removeAttribute("tabindex");
	});
}
const Zj = {
	border: 0,
	clip: "rect(0 0 0 0)",
	height: "1px",
	margin: "-1px",
	overflow: "hidden",
	padding: 0,
	position: "fixed",
	whiteSpace: "nowrap",
	width: "1px",
	top: 0,
	left: 0,
};
let Rue;
function H$(t) {
	t.key === "Tab" && (t.target, clearTimeout(Rue));
}
const W$ = E.forwardRef(function (e, n) {
		const [r, i] = E.useState();
		tg(
			() => (
				$ue() && i("button"),
				document.addEventListener("keydown", H$),
				() => {
					document.removeEventListener("keydown", H$);
				}
			),
			[],
		);
		const o = {
			ref: n,
			tabIndex: 0,
			role: r,
			"aria-hidden": r ? void 0 : !0,
			[Yj("focus-guard")]: "",
			style: Zj,
		};
		return E.createElement("span", Iw({}, e, o));
	}),
	Qj = E.createContext(null);
function Oue(t) {
	let { id: e, root: n } = t === void 0 ? {} : t;
	const [r, i] = E.useState(null),
		o = Wj(),
		s = jue(),
		a = E.useMemo(
			() => ({ id: e, root: n, portalContext: s, uniqueId: o }),
			[e, n, s, o],
		),
		l = E.useRef();
	return (
		tg(
			() => () => {
				r == null || r.remove();
			},
			[r, a],
		),
		tg(() => {
			if (l.current === a) return;
			l.current = a;
			const { id: u, root: c, portalContext: d, uniqueId: f } = a,
				h = u ? document.getElementById(u) : null,
				p = Yj("portal");
			if (h) {
				const g = document.createElement("div");
				(g.id = f), g.setAttribute(p, ""), h.appendChild(g), i(g);
			} else {
				let g = c || (d == null ? void 0 : d.portalNode);
				g && !em(g) && (g = g.current), (g = g || document.body);
				let v = null;
				u &&
					((v = document.createElement("div")),
					(v.id = u),
					g.appendChild(v));
				const b = document.createElement("div");
				(b.id = f),
					b.setAttribute(p, ""),
					(g = v || g),
					g.appendChild(b),
					i(b);
			}
		}, [a]),
		r
	);
}
function Mue(t) {
	let { children: e, id: n, root: r = null, preserveTabOrder: i = !0 } = t;
	const o = Oue({ id: n, root: r }),
		[s, a] = E.useState(null),
		l = E.useRef(null),
		u = E.useRef(null),
		c = E.useRef(null),
		d = E.useRef(null),
		f = !!s && !s.modal && s.open && i && !!(r || o);
	return (
		E.useEffect(() => {
			if (!o || !i || (s != null && s.modal)) return;
			function h(p) {
				o && ok(p) && (p.type === "focusin" ? Nue : Pue)(o);
			}
			return (
				o.addEventListener("focusin", h, !0),
				o.addEventListener("focusout", h, !0),
				() => {
					o.removeEventListener("focusin", h, !0),
						o.removeEventListener("focusout", h, !0);
				}
			);
		}, [o, i, s == null ? void 0 : s.modal]),
		E.createElement(
			Qj.Provider,
			{
				value: E.useMemo(
					() => ({
						preserveTabOrder: i,
						beforeOutsideRef: l,
						afterOutsideRef: u,
						beforeInsideRef: c,
						afterInsideRef: d,
						portalNode: o,
						setFocusManagerState: a,
					}),
					[i, o],
				),
			},
			f &&
				o &&
				E.createElement(W$, {
					"data-type": "outside",
					ref: l,
					onFocus: (h) => {
						if (ok(h, o)) {
							var p;
							(p = c.current) == null || p.focus();
						} else {
							const g =
								Fue() ||
								(s == null
									? void 0
									: s.refs.domReference.current);
							g == null || g.focus();
						}
					},
				}),
			f && o && E.createElement("span", { "aria-owns": o.id, style: Zj }),
			o && nl.createPortal(e, o),
			f &&
				o &&
				E.createElement(W$, {
					"data-type": "outside",
					ref: u,
					onFocus: (h) => {
						if (ok(h, o)) {
							var p;
							(p = d.current) == null || p.focus();
						} else {
							const g =
								Iue() ||
								(s == null
									? void 0
									: s.refs.domReference.current);
							g == null || g.focus(),
								s != null &&
									s.closeOnFocusOut &&
									(s == null ||
										s.onOpenChange(!1, h.nativeEvent));
						}
					},
				}),
		)
	);
}
const jue = () => E.useContext(Qj),
	_ue = J8.useInsertionEffect,
	zue = _ue || ((t) => t());
function Lue(t) {
	const e = E.useRef(() => {});
	return (
		zue(() => {
			e.current = t;
		}),
		E.useCallback(function () {
			for (var n = arguments.length, r = new Array(n), i = 0; i < n; i++)
				r[i] = arguments[i];
			return e.current == null ? void 0 : e.current(...r);
		}, [])
	);
}
function Vue(t) {
	var e;
	t === void 0 && (t = {});
	const { open: n = !1, onOpenChange: r, nodeId: i } = t,
		[o, s] = E.useState(null),
		a = ((e = t.elements) == null ? void 0 : e.reference) || o,
		l = Qle(t),
		u = Sue(),
		c = Lue((C, k) => {
			C && (f.current.openEvent = k), r == null || r(C, k);
		}),
		d = E.useRef(null),
		f = E.useRef({}),
		h = E.useState(() => Eue())[0],
		p = Wj(),
		g = E.useCallback(
			(C) => {
				const k = em(C)
					? {
							getBoundingClientRect: () =>
								C.getBoundingClientRect(),
							contextElement: C,
						}
					: C;
				l.refs.setReference(k);
			},
			[l.refs],
		),
		v = E.useCallback(
			(C) => {
				(em(C) || C === null) && ((d.current = C), s(C)),
					(em(l.refs.reference.current) ||
						l.refs.reference.current === null ||
						(C !== null && !em(C))) &&
						l.refs.setReference(C);
			},
			[l.refs],
		),
		b = E.useMemo(
			() => ({
				...l.refs,
				setReference: v,
				setPositionReference: g,
				domReference: d,
			}),
			[l.refs, v, g],
		),
		y = E.useMemo(
			() => ({ ...l.elements, domReference: a }),
			[l.elements, a],
		),
		x = E.useMemo(
			() => ({
				...l,
				refs: b,
				elements: y,
				dataRef: f,
				nodeId: i,
				floatingId: p,
				events: h,
				open: n,
				onOpenChange: c,
			}),
			[l, i, p, h, n, c, b, y],
		);
	return (
		tg(() => {
			const C =
				u == null ? void 0 : u.nodesRef.current.find((k) => k.id === i);
			C && (C.context = x);
		}),
		E.useMemo(
			() => ({ ...l, context: x, refs: b, elements: y }),
			[l, b, y, x],
		)
	);
}
const e_ = E.forwardRef(function (e, n) {
	const r = ce(23);
	e = Kue(e);
	const { children: i, reference: o, placement: s, portal: a } = e,
		l = a ? Mue : E.Fragment,
		u = ht(e),
		[c, d] = E.useState(null);
	let f;
	r[0] !== e ? ((f = Hue(e)), (r[0] = e), (r[1] = f)) : (f = r[1]);
	const h = f;
	let p;
	r[2] !== o || r[3] !== c
		? ((p = { reference: o, floating: c }),
			(r[2] = o),
			(r[3] = c),
			(r[4] = p))
		: (p = r[4]);
	let g;
	r[5] !== p || r[6] !== h || r[7] !== s
		? ((g = {
				elements: p,
				middleware: h,
				placement: s,
				whileElementsMounted: Hle,
			}),
			(r[5] = p),
			(r[6] = h),
			(r[7] = s),
			(r[8] = g))
		: (g = r[8]);
	const { floatingStyles: v, context: b, update: y } = Vue(g);
	let x, C;
	r[9] !== b || r[10] !== y
		? ((x = () => ({ context: b, update: y })),
			(C = [b, y]),
			(r[9] = b),
			(r[10] = y),
			(r[11] = x),
			(r[12] = C))
		: ((x = r[11]), (C = r[12])),
		E.useImperativeHandle(n, x, C);
	let k;
	r[13] !== v || r[14] !== u.style
		? ((k = { ...v, ...u.style }),
			(r[13] = v),
			(r[14] = u.style),
			(r[15] = k))
		: (k = r[15]);
	let w;
	r[16] !== u || r[17] !== k || r[18] !== i
		? ((w = m.jsx(Wue, { ref: d, ...u, style: k, children: i })),
			(r[16] = u),
			(r[17] = k),
			(r[18] = i),
			(r[19] = w))
		: (w = r[19]);
	let D;
	return (
		r[20] !== l || r[21] !== w
			? ((D = m.jsx(l, { children: w })),
				(r[20] = l),
				(r[21] = w),
				(r[22] = D))
			: (D = r[22]),
		D
	);
});
function Kue(t) {
	return Object.assign(
		{},
		{ adaptToBoundary: "flip", placement: "bottom", portal: !0 },
		t,
	);
}
const zl = 8;
function Uue() {
	return {
		name: "applyStyles",
		async fn(t) {
			let { elements: e, middlewareData: n } = t;
			return (
				n.hide &&
					Object.assign(e.floating.style, {
						visibility: n.hide.referenceHidden
							? "hidden"
							: "visible",
					}),
				{}
			);
		},
	};
}
function Hue(t) {
	const { adaptToBoundary: e, boundary: n } = t;
	let r = [...(t.portal ? [nue({ boundary: n })] : []), Uue()];
	return e === "stick"
		? [
				rk(zl),
				z$({
					boundary: n,
					crossAxis: !0,
					padding: zl,
					limiter: eue({
						offset: ({
							rects: i,
							middlewareData: o,
							placement: s,
						}) => {
							var a, l;
							return {
								crossAxis:
									i.floating.height +
									((a =
										(l = o.offset) === null || l === void 0
											? void 0
											: l.y) !== null && a !== void 0
										? a
										: 0) *
										(s === "top" ? -1 : 1),
							};
						},
					}),
				}),
				...r,
			]
		: e === "stretch"
			? [
					rk(zl),
					L$({ boundary: n, padding: zl }),
					tue({
						apply({ elements: i, availableHeight: o }) {
							Object.assign(i.floating.style, {
								maxHeight: `${o}px`,
							});
						},
						boundary: n,
						padding: zl,
					}),
					...r,
				]
			: [
					rk(zl),
					L$({ boundary: n, padding: zl }),
					z$({ padding: zl }),
					...r,
				];
}
const Wue = E.forwardRef(function (e, n) {
		const r = ce(6);
		let i;
		r[0] !== e.className
			? ((i = Se(
					X({
						backgroundColor: B.color.background.surface,
						borderRadius: B.size.radius.medium,
						border: `${B.size.border.regular} solid ${B.color.border.emphasis}`,
						boxShadow: `${B.size.shadow.medium} ${B.color.shadow.regular}`,
						boxSizing: "content-box",
						minHeight: B.size.element.regular,
						minWidth: B.size.element.regular,
						outline: 0,
					}),
					e.className,
				)),
				(r[0] = e.className),
				(r[1] = i))
			: (i = r[1]);
		let o;
		return (
			r[2] !== n || r[3] !== e || r[4] !== i
				? ((o = m.jsx("div", {
						role: "dialog",
						ref: n,
						...e,
						className: i,
					})),
					(r[2] = n),
					(r[3] = e),
					(r[4] = i),
					(r[5] = o))
				: (o = r[5]),
			o
		);
	}),
	t_ = E.createContext(null);
function que() {
	const t = ce(2),
		e = E.useContext(t_);
	if (e == null)
		throw new Error(
			"useToolbarContext must be used within a EditorToolbar",
		);
	let n;
	return (
		t[0] !== e ? ((n = { state: e }), (t[0] = e), (t[1] = n)) : (n = t[1]),
		n
	);
}
function Gue(t) {
	const e = ce(7),
		{ children: n } = t,
		r = E.useRef(null),
		{ state: i, toolbarProps: o } = ece(t, r);
	let s;
	e[0] !== r || e[1] !== o || e[2] !== n
		? ((s = m.jsx(nc, {
				children: m.jsx(As, {
					alignItems: "center",
					gap: "regular",
					ref: r,
					...o,
					children: n,
				}),
			})),
			(e[0] = r),
			(e[1] = o),
			(e[2] = n),
			(e[3] = s))
		: (s = e[3]);
	let a;
	return (
		e[4] !== i || e[5] !== s
			? ((a = m.jsx(t_.Provider, { value: i, children: s })),
				(e[4] = i),
				(e[5] = s),
				(e[6] = a))
			: (a = e[6]),
		a
	);
}
const qD = E.createContext(null);
function Yue() {
	const t = ce(3),
		e = E.useContext(qD);
	wt(
		e !== null,
		'An `EditorToolbarItem` is only valid inside an `EditorToolbarGroup` with a `selectionMode` of "single" or "multiple". When no selection is needed, use `EditorToolbarButton` instead.',
	);
	const n = tce(e.disabledKeys);
	let r;
	return (
		t[0] !== e || t[1] !== n
			? ((r = { ...e, disabledKeys: n }),
				(t[0] = e),
				(t[1] = n),
				(t[2] = r))
			: (r = t[2]),
		r
	);
}
function Jue(t) {
	const e = ce(37),
		n = Yue();
	if (n.selectionMode === "single") {
		const { disabledKeys: r, value: i, onChange: o } = n;
		let s;
		e[0] !== r || e[1] !== t.value
			? ((s = r.has(t.value)), (e[0] = r), (e[1] = t.value), (e[2] = s))
			: (s = e[2]);
		const a = s,
			l = i === t.value;
		let u;
		e[3] !== t
			? ((u = Ge(t, { labelable: !0 })), (e[3] = t), (e[4] = u))
			: (u = e[4]);
		let c;
		e[5] !== a || e[6] !== o || e[7] !== t.value
			? ((c = () => {
					a || o(t.value);
				}),
				(e[5] = a),
				(e[6] = o),
				(e[7] = t.value),
				(e[8] = c))
			: (c = e[8]);
		let d;
		e[9] !== u || e[10] !== l || e[11] !== c
			? ((d = { ...u, role: "radio", "aria-checked": l, onPress: c }),
				(e[9] = u),
				(e[10] = l),
				(e[11] = c),
				(e[12] = d))
			: (d = e[12]);
		let f;
		return (
			e[13] !== a || e[14] !== l || e[15] !== d
				? ((f = { isDisabled: a, isSelected: l, buttonProps: d }),
					(e[13] = a),
					(e[14] = l),
					(e[15] = d),
					(e[16] = f))
				: (f = e[16]),
			f
		);
	}
	if (n.selectionMode === "multiple") {
		const { disabledKeys: r, value: i, onChange: o } = n;
		let s;
		e[17] !== r || e[18] !== t.value
			? ((s = r.has(t.value)),
				(e[17] = r),
				(e[18] = t.value),
				(e[19] = s))
			: (s = e[19]);
		const a = s;
		let l;
		e[20] !== i || e[21] !== t.value
			? ((l = i.includes(t.value)),
				(e[20] = i),
				(e[21] = t.value),
				(e[22] = l))
			: (l = e[22]);
		const u = l;
		let c;
		e[23] !== t
			? ((c = Ge(t, { labelable: !0 })), (e[23] = t), (e[24] = c))
			: (c = e[24]);
		let d;
		e[25] !== a || e[26] !== o || e[27] !== t.value
			? ((d = () => {
					a || o(t.value);
				}),
				(e[25] = a),
				(e[26] = o),
				(e[27] = t.value),
				(e[28] = d))
			: (d = e[28]);
		let f;
		e[29] !== c || e[30] !== u || e[31] !== d
			? ((f = { ...c, role: "checkbox", "aria-checked": u, onPress: d }),
				(e[29] = c),
				(e[30] = u),
				(e[31] = d),
				(e[32] = f))
			: (f = e[32]);
		let h;
		return (
			e[33] !== a || e[34] !== u || e[35] !== f
				? ((h = { isDisabled: a, isSelected: u, buttonProps: f }),
					(e[33] = a),
					(e[34] = u),
					(e[35] = f),
					(e[36] = h))
				: (h = e[36]),
			h
		);
	}
	qn(n);
}
function GD(t) {
	const e = ce(9);
	if (t.selectionMode === "single") {
		let i;
		return (
			e[0] !== t
				? ((i = m.jsx(Xue, { ...t })), (e[0] = t), (e[1] = i))
				: (i = e[1]),
			i
		);
	}
	if (t.selectionMode === "multiple") {
		let i;
		return (
			e[2] !== t
				? ((i = m.jsx(Zue, { ...t })), (e[2] = t), (e[3] = i))
				: (i = e[3]),
			i
		);
	}
	let n;
	e[4] !== t ? ((n = Vx(t)), (e[4] = t), (e[5] = n)) : (n = e[5]);
	let r;
	return (
		e[6] !== n || e[7] !== t.children
			? ((r = m.jsx(As, {
					gap: "xsmall",
					role: "group",
					...n,
					children: t.children,
				})),
				(e[6] = n),
				(e[7] = t.children),
				(e[8] = r))
			: (r = e[8]),
		r
	);
}
function Xue(t) {
	const e = ce(11);
	let n, r;
	e[0] !== t
		? (({ children: n, ...r } = t), (e[0] = t), (e[1] = n), (e[2] = r))
		: ((n = e[1]), (r = e[2]));
	let i;
	e[3] !== t ? ((i = Vx(t)), (e[3] = t), (e[4] = i)) : (i = e[4]);
	let o;
	e[5] !== i || e[6] !== n
		? ((o = m.jsx(As, {
				gap: "xsmall",
				role: "radiogroup",
				...i,
				children: n,
			})),
			(e[5] = i),
			(e[6] = n),
			(e[7] = o))
		: (o = e[7]);
	let s;
	return (
		e[8] !== r || e[9] !== o
			? ((s = m.jsx(qD.Provider, { value: r, children: o })),
				(e[8] = r),
				(e[9] = o),
				(e[10] = s))
			: (s = e[10]),
		s
	);
}
function Zue(t) {
	const e = ce(11);
	let n, r;
	e[0] !== t
		? (({ children: n, ...r } = t), (e[0] = t), (e[1] = n), (e[2] = r))
		: ((n = e[1]), (r = e[2]));
	let i;
	e[3] !== t ? ((i = Vx(t)), (e[3] = t), (e[4] = i)) : (i = e[4]);
	let o;
	e[5] !== i || e[6] !== n
		? ((o = m.jsx(As, { gap: "xsmall", role: "group", ...i, children: n })),
			(e[5] = i),
			(e[6] = n),
			(e[7] = o))
		: (o = e[7]);
	let s;
	return (
		e[8] !== r || e[9] !== o
			? ((s = m.jsx(qD.Provider, { value: r, children: o })),
				(e[8] = r),
				(e[9] = o),
				(e[10] = s))
			: (s = e[10]),
		s
	);
}
function n_(t) {
	const e = ce(13),
		{ isDisabled: n, isSelected: r, buttonProps: i } = Jue(t);
	let o;
	e[0] !== t || e[1] !== n
		? ((o = { ...t, isDisabled: n }), (e[0] = t), (e[1] = n), (e[2] = o))
		: (o = e[2]);
	const { itemProps: s } = r_(o);
	let a;
	e[3] !== i || e[4] !== s
		? ((a = xe(i, s)), (e[3] = i), (e[4] = s), (e[5] = a))
		: (a = e[5]);
	let l;
	e[6] !== n || e[7] !== r || e[8] !== t.children
		? ((l = m.jsx(Re, {
				prominence: "low",
				isDisabled: n,
				isSelected: r,
				children: t.children,
			})),
			(e[6] = n),
			(e[7] = r),
			(e[8] = t.children),
			(e[9] = l))
		: (l = e[9]);
	let u;
	return (
		e[10] !== a || e[11] !== l
			? ((u = m.jsx(Al, { ...a, children: l })),
				(e[10] = a),
				(e[11] = l),
				(e[12] = u))
			: (u = e[12]),
		u
	);
}
function Que(t) {
	const e = ce(5),
		{ itemProps: n } = r_(t);
	let r;
	e[0] !== t
		? ((r = m.jsx(WP, { prominence: "low", ...t })), (e[0] = t), (e[1] = r))
		: (r = e[1]);
	let i;
	return (
		e[2] !== n || e[3] !== r
			? ((i = m.jsx(Al, { ...n, children: r })),
				(e[2] = n),
				(e[3] = r),
				(e[4] = i))
			: (i = e[4]),
		i
	);
}
function sk() {
	const t = ce(1);
	let e;
	return (
		t[0] === Symbol.for("react.memo_cache_sentinel")
			? ((e = m.jsx("div", {
					role: "separator",
					"aria-orientation": "vertical",
					className: X({
						alignSelf: "center",
						backgroundColor: B.color.border.muted,
						flexShrink: 0,
						height: B.size.icon.regular,
						width: B.size.border.regular,
					}),
				})),
				(t[0] = e))
			: (e = t[0]),
		e
	);
}
function Vx(t) {
	let { "aria-labelledby": e, "aria-label": n } = t;
	return (
		!e &&
			!n &&
			console.warn(
				"You must specify an aria-label or aria-labelledby attribute for accessibility.",
			),
		{ ...FP(t), ...Ge(t, { labelable: !0 }) }
	);
}
function r_(t) {
	const e = ce(11),
		{ isDisabled: n } = t,
		{ state: r } = que(),
		{ lastFocusedId: i, setLastFocusedId: o } = r,
		s = E.useId(),
		a = i === s || i == null ? 0 : -1;
	let l, u;
	e[0] !== s || e[1] !== n || e[2] !== o
		? ((l = () => {
				const f = (h) => (h === s ? null : h);
				return (
					n && o(f),
					() => {
						o(f);
					}
				);
			}),
			(u = [s, n, o]),
			(e[0] = s),
			(e[1] = n),
			(e[2] = o),
			(e[3] = l),
			(e[4] = u))
		: ((l = e[3]), (u = e[4])),
		E.useEffect(l, u);
	let c;
	e[5] !== o || e[6] !== s
		? ((c = () => {
				o(s);
			}),
			(e[5] = o),
			(e[6] = s),
			(e[7] = c))
		: (c = e[7]);
	let d;
	return (
		e[8] !== a || e[9] !== c
			? ((d = { itemProps: { tabIndex: a, onFocus: c } }),
				(e[8] = a),
				(e[9] = c),
				(e[10] = d))
			: (d = e[10]),
		d
	);
}
function ece(t, e) {
	const n = ce(15),
		[r, i] = E.useState(null),
		{ direction: o } = Vt();
	let s;
	n[0] !== e
		? ((s = $9(e, { wrap: !0 })), (n[0] = e), (n[1] = s))
		: (s = n[1]);
	const a = s,
		l = o === "rtl";
	let u;
	n[2] !== a || n[3] !== l
		? ((u = (v) => {
				if (!v.currentTarget.contains(v.target)) return;
				const b = (x) => {
						var C, k;
						const w =
							((C = x.parentElement) === null || C === void 0
								? void 0
								: C.firstElementChild) === x;
						return (
							!/group/.test(
								((k = x.parentElement) === null || k === void 0
									? void 0
									: k.role) || "",
							) || w
						);
					},
					y = (Ss() ? v.altKey : v.ctrlKey) ? { accept: b } : {};
				e: switch (v.key) {
					case "Home": {
						v.preventDefault(), v.stopPropagation(), a.focusFirst();
						break e;
					}
					case "End": {
						v.preventDefault(), v.stopPropagation(), a.focusLast();
						break e;
					}
					case "ArrowRight":
					case "ArrowDown": {
						v.preventDefault(),
							v.stopPropagation(),
							v.key === "ArrowRight" && l
								? a.focusPrevious(y)
								: a.focusNext(y);
						break e;
					}
					case "ArrowLeft":
					case "ArrowUp":
						v.preventDefault(),
							v.stopPropagation(),
							v.key === "ArrowLeft" && l
								? a.focusNext(y)
								: a.focusPrevious(y);
				}
			}),
			(n[2] = a),
			(n[3] = l),
			(n[4] = u))
		: (u = n[4]);
	const c = u;
	let d;
	n[5] !== t ? ((d = Vx(t)), (n[5] = t), (n[6] = d)) : (d = n[6]);
	let f;
	n[7] !== d || n[8] !== c
		? ((f = {
				...d,
				onKeyDown: c,
				role: "toolbar",
				"aria-orientation": "horizontal",
			}),
			(n[7] = d),
			(n[8] = c),
			(n[9] = f))
		: (f = n[9]);
	let h, p;
	n[10] !== r
		? ((p = { lastFocusedId: r, setLastFocusedId: i }),
			(n[10] = r),
			(n[11] = p))
		: (p = n[11]),
		(h = p);
	let g;
	return (
		n[12] !== f || n[13] !== h
			? ((g = { toolbarProps: f, state: h }),
				(n[12] = f),
				(n[13] = h),
				(n[14] = g))
			: (g = n[14]),
		g
	);
}
function tce(t) {
	const e = ce(2);
	let n, r;
	return (
		e[0] !== t
			? ((r = t == null ? new Set() : new Set(t)), (e[0] = t), (e[1] = r))
			: (r = e[1]),
		(n = r),
		n
	);
}
const i_ = m.jsx("path", {
		d: "M14 12a4 4 0 0 0 0-8H6v8M15 20a4 4 0 0 0 0-8H6v8Z",
	}),
	Il = m.jsx("path", { d: "m6 9 6 6 6-6" }),
	Kx = m.jsx("path", { d: "m16 18 6-6-6-6M8 6l-6 6 6 6" }),
	o_ = m.jsx("path", { d: "M19 4h-9M14 20H5M15 4 9 20" }),
	jv = m.jsx("path", {
		d: "M8 6h13M8 12h13M8 18h13M3 6h.01M3 12h.01M3 18h.01",
	}),
	YD = m.jsx("path", {
		d: "M10 6h11M10 12h11M10 18h11M4 6h1v4M4 10h2M6 18H4c0-1 2-2 2-3s-1-1.5-2-1",
	}),
	Ux = m.jsx("path", { d: "M5 12h14M12 5v14" }),
	JD = m.jsx("path", {
		d: "M3 21c3 0 7-1 7-8V5c0-1.25-.756-2.017-2-2H4c-1.25 0-2 .75-2 1.972V11c0 1.25.75 2 2 2 1 0 1 0 1 1v1c0 1-1 2-2 2s-1 .008-1 1.031V20c0 1 0 1 1 1zM15 21c3 0 7-1 7-8V5c0-1.25-.757-2.017-2-2h-4c-1.25 0-2 .75-2 1.972V11c0 1.25.75 2 2 2h.75c0 2.25.25 4-2.75 4v3c0 1 0 1 1 1z",
	}),
	s_ = m.jsx("path", {
		d: "M4 7V4h16v3M5 20h6M13 4 8 20M15 15l5 5M20 15l-5 5",
	}),
	a_ = m.jsx("path", {
		d: "M16 4H9a3 3 0 0 0-2.83 4M14 12a4 4 0 0 1 0 8H6M4 12h16",
	}),
	XD = m.jsxs(m.Fragment, {
		children: [
			m.jsx("path", { d: "M12 3v18" }),
			m.jsx("rect", { width: 18, height: 18, x: 3, y: 3, rx: 2 }),
			m.jsx("path", { d: "M3 9h18M3 15h18" }),
		],
	});
var l_ = {};
l_ = {
	longPressMessage: "اضغط مطولاً أو اضغط على Alt + السهم لأسفل لفتح القائمة",
};
var u_ = {};
u_ = {
	longPressMessage:
		"Натиснете продължително или натиснете Alt+ стрелка надолу, за да отворите менюто",
};
var c_ = {};
c_ = {
	longPressMessage:
		"Dlouhým stiskem nebo stisknutím kláves Alt + šipka dolů otevřete nabídku",
};
var d_ = {};
d_ = {
	longPressMessage:
		"Langt tryk eller tryk på Alt + pil ned for at åbne menuen",
};
var f_ = {};
f_ = {
	longPressMessage:
		"Drücken Sie lange oder drücken Sie Alt + Nach-unten, um das Menü zu öffnen",
};
var h_ = {};
h_ = {
	longPressMessage:
		"Πιέστε παρατεταμένα ή πατήστε Alt + κάτω βέλος για να ανοίξετε το μενού",
};
var p_ = {};
p_ = { longPressMessage: "Long press or press Alt + ArrowDown to open menu" };
var m_ = {};
m_ = {
	longPressMessage:
		"Mantenga pulsado o pulse Alt + flecha abajo para abrir el menú",
};
var g_ = {};
g_ = {
	longPressMessage:
		"Menüü avamiseks vajutage pikalt või vajutage klahve Alt + allanool",
};
var b_ = {};
b_ = {
	longPressMessage:
		"Avaa valikko painamalla pohjassa tai näppäinyhdistelmällä Alt + Alanuoli",
};
var v_ = {};
v_ = {
	longPressMessage:
		"Appuyez de manière prolongée ou appuyez sur Alt + Flèche vers le bas pour ouvrir le menu.",
};
var y_ = {};
y_ = {
	longPressMessage:
		"לחץ לחיצה ארוכה או הקש Alt + ArrowDown כדי לפתוח את התפריט",
};
var x_ = {};
x_ = {
	longPressMessage:
		"Dugo pritisnite ili pritisnite Alt + strelicu prema dolje za otvaranje izbornika",
};
var k_ = {};
k_ = {
	longPressMessage:
		"Nyomja meg hosszan, vagy nyomja meg az Alt + lefele nyíl gombot a menü megnyitásához",
};
var C_ = {};
C_ = {
	longPressMessage:
		"Premere a lungo o premere Alt + Freccia giù per aprire il menu",
};
var w_ = {};
w_ = { longPressMessage: "長押しまたは Alt+下矢印キーでメニューを開く" };
var E_ = {};
E_ = { longPressMessage: "길게 누르거나 Alt + 아래쪽 화살표를 눌러 메뉴 열기" };
var D_ = {};
D_ = {
	longPressMessage:
		"Norėdami atidaryti meniu, nuspaudę palaikykite arba paspauskite „Alt + ArrowDown“.",
};
var S_ = {};
S_ = {
	longPressMessage:
		"Lai atvērtu izvēlni, turiet nospiestu vai nospiediet taustiņu kombināciju Alt + lejupvērstā bultiņa",
};
var A_ = {};
A_ = {
	longPressMessage: "Langt trykk eller trykk Alt + PilNed for å åpne menyen",
};
var $_ = {};
$_ = {
	longPressMessage:
		"Druk lang op Alt + pijl-omlaag of druk op Alt om het menu te openen",
};
var T_ = {};
T_ = {
	longPressMessage:
		"Naciśnij i przytrzymaj lub naciśnij klawisze Alt + Strzałka w dół, aby otworzyć menu",
};
var B_ = {};
B_ = {
	longPressMessage:
		"Pressione e segure ou pressione Alt + Seta para baixo para abrir o menu",
};
var I_ = {};
I_ = {
	longPressMessage:
		"Prima continuamente ou prima Alt + Seta Para Baixo para abrir o menu",
};
var F_ = {};
F_ = {
	longPressMessage:
		"Apăsați lung sau apăsați pe Alt + săgeată în jos pentru a deschide meniul",
};
var P_ = {};
P_ = {
	longPressMessage:
		"Нажмите и удерживайте или нажмите Alt + Стрелка вниз, чтобы открыть меню",
};
var N_ = {};
N_ = {
	longPressMessage:
		"Ponuku otvoríte dlhým stlačením alebo stlačením klávesu Alt + klávesu so šípkou nadol",
};
var R_ = {};
R_ = {
	longPressMessage:
		"Za odprtje menija pritisnite in držite gumb ali pritisnite Alt+puščica navzdol",
};
var O_ = {};
O_ = {
	longPressMessage:
		"Dugo pritisnite ili pritisnite Alt + strelicu prema dole da otvorite meni",
};
var M_ = {};
M_ = {
	longPressMessage:
		"Håll nedtryckt eller tryck på Alt + pil nedåt för att öppna menyn",
};
var j_ = {};
j_ = {
	longPressMessage:
		"Menüyü açmak için uzun basın veya Alt + Aşağı Ok tuşuna basın",
};
var __ = {};
__ = {
	longPressMessage:
		"Довго або звичайно натисніть комбінацію клавіш Alt і стрілка вниз, щоб відкрити меню",
};
var z_ = {};
z_ = { longPressMessage: "长按或按 Alt + 向下方向键以打开菜单" };
var L_ = {};
L_ = { longPressMessage: "長按或按 Alt+向下鍵以開啟功能表" };
var V_ = {};
V_ = {
	"ar-AE": l_,
	"bg-BG": u_,
	"cs-CZ": c_,
	"da-DK": d_,
	"de-DE": f_,
	"el-GR": h_,
	"en-US": p_,
	"es-ES": m_,
	"et-EE": g_,
	"fi-FI": b_,
	"fr-FR": v_,
	"he-IL": y_,
	"hr-HR": x_,
	"hu-HU": k_,
	"it-IT": C_,
	"ja-JP": w_,
	"ko-KR": E_,
	"lt-LT": D_,
	"lv-LV": S_,
	"nb-NO": A_,
	"nl-NL": $_,
	"pl-PL": T_,
	"pt-BR": B_,
	"pt-PT": I_,
	"ro-RO": F_,
	"ru-RU": P_,
	"sk-SK": N_,
	"sl-SI": R_,
	"sr-SP": O_,
	"sv-SE": M_,
	"tr-TR": j_,
	"uk-UA": __,
	"zh-CN": z_,
	"zh-TW": L_,
};
function nce(t) {
	return t && t.__esModule ? t.default : t;
}
function ZD(t, e, n) {
	let { type: r = "menu", isDisabled: i, trigger: o = "press" } = t,
		s = Ot(),
		{ triggerProps: a, overlayProps: l } = px({ type: r }, e, n),
		u = (h) => {
			if (!i && !(o === "longPress" && !h.altKey) && n && n.current)
				switch (h.key) {
					case "Enter":
					case " ":
						if (o === "longPress") return;
					case "ArrowDown":
						"continuePropagation" in h || h.stopPropagation(),
							h.preventDefault(),
							e.toggle("first");
						break;
					case "ArrowUp":
						"continuePropagation" in h || h.stopPropagation(),
							h.preventDefault(),
							e.toggle("last");
						break;
					default:
						"continuePropagation" in h && h.continuePropagation();
				}
		},
		c = Le(nce(V_), "@react-aria/menu"),
		{ longPressProps: d } = E9({
			isDisabled: i || o !== "longPress",
			accessibilityDescription: c.format("longPressMessage"),
			onLongPressStart() {
				e.close();
			},
			onLongPress() {
				e.open("first");
			},
		}),
		f = {
			onPressStart(h) {
				h.pointerType !== "touch" &&
					h.pointerType !== "keyboard" &&
					!i &&
					e.open(h.pointerType === "virtual" ? "first" : null);
			},
			onPress(h) {
				h.pointerType === "touch" && !i && e.toggle();
			},
		};
	return (
		delete a.onPress,
		{
			menuTriggerProps: {
				...a,
				...(o === "press" ? f : d),
				id: s,
				onKeyDown: u,
			},
			menuProps: {
				...l,
				"aria-labelledby": s,
				autoFocus: e.focusStrategy || !0,
				onClose: e.close,
			},
		}
	);
}
const K_ = new WeakMap();
function rce(t, e, n) {
	let { shouldFocusWrap: r = !0, onKeyDown: i, onKeyUp: o, ...s } = t;
	!t["aria-label"] &&
		!t["aria-labelledby"] &&
		console.warn(
			"An aria-label or aria-labelledby prop is required for accessibility.",
		);
	let a = Ge(t, { labelable: !0 }),
		{ listProps: l } = ED({
			...s,
			ref: n,
			selectionManager: e.selectionManager,
			collection: e.collection,
			disabledKeys: e.disabledKeys,
			shouldFocusWrap: r,
			linkBehavior: "override",
		});
	return (
		K_.set(e, { onClose: t.onClose, onAction: t.onAction }),
		{
			menuProps: xe(
				a,
				{ onKeyDown: i, onKeyUp: o },
				{
					role: "menu",
					...l,
					onKeyDown: (u) => {
						u.key !== "Escape" && l.onKeyDown(u);
					},
				},
			),
		}
	);
}
function ice(t, e, n) {
	let {
			id: r,
			key: i,
			closeOnSelect: o,
			isVirtualized: s,
			"aria-haspopup": a,
			onPressStart: l,
			onPressUp: u,
			onPress: c,
			onPressChange: d,
			onPressEnd: f,
			onHoverStart: h,
			onHoverChange: p,
			onHoverEnd: g,
			onKeyDown: v,
			onKeyUp: b,
			onFocus: y,
			onFocusChange: x,
			onBlur: C,
		} = t,
		k = !!a;
	var w;
	let D =
		(w = t.isDisabled) !== null && w !== void 0
			? w
			: e.selectionManager.isDisabled(i);
	var S;
	let $ =
			(S = t.isSelected) !== null && S !== void 0
				? S
				: e.selectionManager.isSelected(i),
		A = K_.get(e),
		T = e.collection.getItem(i),
		I = t.onClose || A.onClose,
		F = Kd(),
		N = (re) => {
			var he;
			if (!k) {
				if (
					(!(T == null || (he = T.props) === null || he === void 0) &&
					he.onAction
						? T.props.onAction()
						: t.onAction && t.onAction(i),
					A.onAction)
				) {
					let ye = A.onAction;
					ye(i);
				}
				re.target instanceof HTMLAnchorElement &&
					F.open(re.target, re, T.props.href, T.props.routerOptions);
			}
		},
		O = "menuitem";
	k ||
		(e.selectionManager.selectionMode === "single"
			? (O = "menuitemradio")
			: e.selectionManager.selectionMode === "multiple" &&
				(O = "menuitemcheckbox"));
	let _ = Lo(),
		j = Lo(),
		V = Lo(),
		K = {
			id: r,
			"aria-disabled": D || void 0,
			role: O,
			"aria-label": t["aria-label"],
			"aria-labelledby": _,
			"aria-describedby": [j, V].filter(Boolean).join(" ") || void 0,
			"aria-controls": t["aria-controls"],
			"aria-haspopup": a,
			"aria-expanded": t["aria-expanded"],
		};
	e.selectionManager.selectionMode !== "none" &&
		!k &&
		(K["aria-checked"] = $),
		s &&
			((K["aria-posinset"] = T == null ? void 0 : T.index),
			(K["aria-setsize"] = kD(e.collection)));
	let M = (re) => {
			re.pointerType === "keyboard" && N(re), l == null || l(re);
		},
		G = (re) => {
			re.pointerType !== "keyboard" &&
				(N(re),
				!k &&
					I &&
					(o ??
						(e.selectionManager.selectionMode !== "multiple" ||
							e.selectionManager.isLink(i))) &&
					I()),
				u == null || u(re);
		},
		{ itemProps: H, isFocused: P } = f0({
			selectionManager: e.selectionManager,
			key: i,
			ref: n,
			shouldSelectOnPressUp: !0,
			allowsDifferentPressOrigin: !0,
			linkBehavior: "none",
		}),
		{ pressProps: q, isPressed: J } = zi({
			onPressStart: M,
			onPress: c,
			onPressUp: G,
			onPressChange: d,
			onPressEnd: f,
			isDisabled: D,
		}),
		{ hoverProps: Z } = gn({
			isDisabled: D,
			onHoverStart(re) {
				ml() ||
					(e.selectionManager.setFocused(!0),
					e.selectionManager.setFocusedKey(i)),
					h == null || h(re);
			},
			onHoverChange: p,
			onHoverEnd: g,
		}),
		{ keyboardProps: oe } = hx({
			onKeyDown: (re) => {
				if (re.repeat) {
					re.continuePropagation();
					return;
				}
				switch (re.key) {
					case " ":
						!D &&
							e.selectionManager.selectionMode === "none" &&
							!k &&
							o !== !1 &&
							I &&
							I();
						break;
					case "Enter":
						!D && o !== !1 && !k && I && I();
						break;
					default:
						k || re.continuePropagation(), v == null || v(re);
						break;
				}
			},
			onKeyUp: b,
		}),
		{ focusProps: ne } = cx({ onBlur: C, onFocus: y, onFocusChange: x }),
		de = Ge(T.props);
	delete de.id;
	let se = YE(T.props);
	return {
		menuItemProps: {
			...K,
			...xe(
				de,
				se,
				k ? { onFocus: H.onFocus, "data-key": H["data-key"] } : H,
				q,
				Z,
				oe,
				ne,
			),
			tabIndex: H.tabIndex != null ? -1 : void 0,
		},
		labelProps: { id: _ },
		descriptionProps: { id: j },
		keyboardShortcutProps: { id: V },
		isFocused: P,
		isSelected: $,
		isPressed: J,
		isDisabled: D,
	};
}
function oce(t) {
	let { heading: e, "aria-label": n } = t,
		r = Ot();
	return {
		itemProps: { role: "presentation" },
		headingProps: e ? { id: r, role: "presentation" } : {},
		groupProps: {
			role: "group",
			"aria-label": n,
			"aria-labelledby": e ? r : void 0,
		},
	};
}
class sce {
	*[Symbol.iterator]() {
		yield* this.iterable;
	}
	get size() {
		return this.keyMap.size;
	}
	getKeys() {
		return this.keyMap.keys();
	}
	getKeyBefore(e) {
		let n = this.keyMap.get(e);
		return n ? n.prevKey : null;
	}
	getKeyAfter(e) {
		let n = this.keyMap.get(e);
		return n ? n.nextKey : null;
	}
	getFirstKey() {
		return this.firstKey;
	}
	getLastKey() {
		return this.lastKey;
	}
	getItem(e) {
		return this.keyMap.get(e);
	}
	at(e) {
		const n = [...this.getKeys()];
		return this.getItem(n[e]);
	}
	constructor(e, { expandedKeys: n } = {}) {
		(this.keyMap = new Map()), (this.iterable = e), (n = n || new Set());
		let r = (s) => {
			if (
				(this.keyMap.set(s.key, s),
				s.childNodes && (s.type === "section" || n.has(s.key)))
			)
				for (let a of s.childNodes) r(a);
		};
		for (let s of e) r(s);
		let i,
			o = 0;
		for (let [s, a] of this.keyMap)
			i
				? ((i.nextKey = s), (a.prevKey = i.key))
				: ((this.firstKey = s), (a.prevKey = void 0)),
				a.type === "item" && (a.index = o++),
				(i = a),
				(i.nextKey = void 0);
		this.lastKey = i == null ? void 0 : i.key;
	}
}
function ace(t) {
	let { onExpandedChange: e } = t,
		[n, r] = Ns(
			t.expandedKeys ? new Set(t.expandedKeys) : void 0,
			t.defaultExpandedKeys ? new Set(t.defaultExpandedKeys) : new Set(),
			e,
		),
		i = CD(t),
		o = E.useMemo(
			() => (t.disabledKeys ? new Set(t.disabledKeys) : new Set()),
			[t.disabledKeys],
		),
		s = xD(
			t,
			E.useCallback((l) => new sce(l, { expandedKeys: n }), [n]),
			null,
		);
	return (
		E.useEffect(() => {
			i.focusedKey != null &&
				!s.getItem(i.focusedKey) &&
				i.setFocusedKey(null);
		}, [s, i.focusedKey]),
		{
			collection: s,
			expandedKeys: n,
			disabledKeys: o,
			toggleKey: (l) => {
				r(lce(n, l));
			},
			setExpandedKeys: r,
			selectionManager: new wD(s, i),
		}
	);
}
function lce(t, e) {
	let n = new Set(t);
	return n.has(e) ? n.delete(e) : n.add(e), n;
}
function uce(t) {
	let e = Bl(t),
		[n, r] = E.useState(null),
		[i, o] = E.useState([]),
		s = () => {
			o([]), e.close();
		};
	return {
		focusStrategy: n,
		...e,
		open(u = null) {
			r(u), e.open();
		},
		toggle(u = null) {
			r(u), e.toggle();
		},
		close() {
			s();
		},
		expandedKeysStack: i,
		openSubmenu: (u, c) => {
			o((d) => (c > d.length ? d : [...d.slice(0, c), u]));
		},
		closeSubmenu: (u, c) => {
			o((d) => (d[c] === u ? d.slice(0, c) : d));
		},
	};
}
const U_ = m.jsxs(m.Fragment, {
		children: [
			m.jsx("circle", { cx: 12, cy: 12, r: 1 }),
			m.jsx("circle", { cx: 19, cy: 12, r: 1 }),
			m.jsx("circle", { cx: 5, cy: 12, r: 1 }),
		],
	}),
	cce = {
		"ar-AE": { moreActions: "المزيد من الإجراءات" },
		"bg-BG": { moreActions: "Повече действия" },
		"cs-CZ": { moreActions: "Další akce" },
		"da-DK": { moreActions: "Flere handlinger" },
		"de-DE": { moreActions: "Mehr Aktionen" },
		"el-GR": { moreActions: "Περισσότερες ενέργειες" },
		"en-US": { moreActions: "More actions" },
		"es-ES": { moreActions: "Más acciones" },
		"et-EE": { moreActions: "Veel toiminguid" },
		"fi-FI": { moreActions: "Lisää toimintoja" },
		"fr-FR": { moreActions: "Autres actions" },
		"he-IL": { moreActions: "פעולות נוספות" },
		"hr-HR": { moreActions: "Dodatne radnje" },
		"hu-HU": { moreActions: "További lehetőségek" },
		"it-IT": { moreActions: "Altre azioni" },
		"ja-JP": { moreActions: "その他のアクション" },
		"ko-KR": { moreActions: "기타 작업" },
		"lt-LT": { moreActions: "Daugiau veiksmų" },
		"lv-LV": { moreActions: "Citas darbības" },
		"nb-NO": { moreActions: "Flere handlinger" },
		"nl-NL": { moreActions: "Meer handelingen" },
		"pl-PL": { moreActions: "Więcej akcji" },
		"pt-BR": { moreActions: "Mais ações" },
		"pt-PT": { moreActions: "Mais ações" },
		"ro-RO": { moreActions: "Mai multe acțiuni" },
		"ru-RU": { moreActions: "Дополнительные действия" },
		"sk-SK": { moreActions: "Ďalšie akcie" },
		"sl-SI": { moreActions: "Več možnosti" },
		"sr-SP": { moreActions: "Dodatne radnje" },
		"sv-SE": { moreActions: "Fler åtgärder" },
		"tr-TR": { moreActions: "Daha fazla eylem" },
		"uk-UA": { moreActions: "Більше дій" },
		"zh-CN": { moreActions: "更多操作" },
		"zh-TW": { moreActions: "更多動作" },
	},
	QD = le.createContext({});
function dce() {
	return E.useContext(QD);
}
function H_(t) {
	const e = ce(35),
		{ item: n, state: r, isVirtualized: i, onAction: o } = t,
		{ onClose: s, closeOnSelect: a } = dce(),
		{ rendered: l, key: u } = n;
	let c;
	e[0] !== r.selectionManager || e[1] !== u
		? ((c = r.selectionManager.isSelected(u)),
			(e[0] = r.selectionManager),
			(e[1] = u),
			(e[2] = c))
		: (c = e[2]);
	const d = c;
	let f;
	e[3] !== r.selectionManager || e[4] !== u
		? ((f = r.selectionManager.isDisabled(u)),
			(e[3] = r.selectionManager),
			(e[4] = u),
			(e[5] = f))
		: (f = e[5]);
	const h = f,
		p = E.useRef(null),
		g = n["aria-label"];
	let v;
	e[6] !== d ||
	e[7] !== h ||
	e[8] !== g ||
	e[9] !== u ||
	e[10] !== s ||
	e[11] !== a ||
	e[12] !== i ||
	e[13] !== o
		? ((v = {
				isSelected: d,
				isDisabled: h,
				"aria-label": g,
				key: u,
				onClose: s,
				closeOnSelect: a,
				isVirtualized: i,
				onAction: o,
			}),
			(e[6] = d),
			(e[7] = h),
			(e[8] = g),
			(e[9] = u),
			(e[10] = s),
			(e[11] = a),
			(e[12] = i),
			(e[13] = o),
			(e[14] = v))
		: (v = e[14]);
	const {
		menuItemProps: b,
		labelProps: y,
		descriptionProps: x,
		keyboardShortcutProps: C,
	} = ice(v, r, p);
	let k;
	e[15] !== h
		? ((k = { isDisabled: h }), (e[15] = h), (e[16] = k))
		: (k = e[16]);
	const { hoverProps: w, isHovered: D } = gn(k),
		{ focusProps: S, isFocusVisible: $ } = ha();
	let A;
	e[17] !== l
		? ((A = $n(l) ? m.jsx(ue, { children: l }) : l),
			(e[17] = l),
			(e[18] = A))
		: (A = e[18]);
	const T = A,
		I =
			r.selectionManager.disabledBehavior === "selection" &&
			r.disabledKeys.has(u)
				? "menuitem"
				: void 0;
	let F;
	e[19] !== I || e[20] !== b || e[21] !== w || e[22] !== S
		? ((F = xe(b, { role: I }, w, S)),
			(e[19] = I),
			(e[20] = b),
			(e[21] = w),
			(e[22] = S),
			(e[23] = F))
		: (F = e[23]);
	const N = n.props.href ? "a" : "div";
	let O;
	return (
		e[24] !== F ||
		e[25] !== N ||
		e[26] !== x ||
		e[27] !== C ||
		e[28] !== y ||
		e[29] !== D ||
		e[30] !== $ ||
		e[31] !== d ||
		e[32] !== p ||
		e[33] !== T
			? ((O = m.jsx(Tj, {
					...F,
					elementType: N,
					descriptionProps: x,
					keyboardShortcutProps: C,
					labelProps: y,
					isHovered: D,
					isFocused: $,
					isSelected: d,
					ref: p,
					children: T,
				})),
				(e[24] = F),
				(e[25] = N),
				(e[26] = x),
				(e[27] = C),
				(e[28] = y),
				(e[29] = D),
				(e[30] = $),
				(e[31] = d),
				(e[32] = p),
				(e[33] = T),
				(e[34] = O))
			: (O = e[34]),
		O
	);
}
function fce(t) {
	const e = ce(30),
		{ item: n, state: r, onAction: i } = t,
		o = n["aria-label"];
	let s;
	e[0] !== n.rendered || e[1] !== o
		? ((s = { heading: n.rendered, "aria-label": o }),
			(e[0] = n.rendered),
			(e[1] = o),
			(e[2] = s))
		: (s = e[2]);
	const { itemProps: a, headingProps: l, groupProps: u } = oce(s);
	let c;
	e[3] === Symbol.for("react.memo_cache_sentinel")
		? ((c = {}), (e[3] = c))
		: (c = e[3]);
	const { separatorProps: d } = qP(c);
	let f;
	e[4] !== r.collection || e[5] !== n.key || e[6] !== d
		? ((f =
				n.key !== r.collection.getFirstKey() &&
				m.jsx(ra, { ...d, marginY: "small" })),
			(e[4] = r.collection),
			(e[5] = n.key),
			(e[6] = d),
			(e[7] = f))
		: (f = e[7]);
	let h;
	e[8] !== n.rendered || e[9] !== l
		? ((h =
				n.rendered &&
				m.jsx(ue, {
					casing: "uppercase",
					size: "small",
					color: "neutralSecondary",
					weight: "medium",
					UNSAFE_className: X({
						paddingBlock: B.size.space.regular,
						paddingInline: B.size.space.medium,
					}),
					...l,
					children: n.rendered,
				})),
			(e[8] = n.rendered),
			(e[9] = l),
			(e[10] = h))
		: (h = e[10]);
	let p;
	e[11] !== n || e[12] !== r.collection
		? ((p = Wt(n, r.collection)),
			(e[11] = n),
			(e[12] = r.collection),
			(e[13] = p))
		: (p = e[13]);
	let g;
	e[14] !== p ? ((g = [...p]), (e[14] = p), (e[15] = g)) : (g = e[15]);
	let v;
	e[16] !== r || e[17] !== i || e[18] !== g
		? ((v = g.map((C) => {
				let k = m.jsx(H_, { item: C, state: r, onAction: i }, C.key);
				return C.wrapper && (k = C.wrapper(k)), k;
			})),
			(e[16] = r),
			(e[17] = i),
			(e[18] = g),
			(e[19] = v))
		: (v = e[19]);
	let b;
	e[20] !== u || e[21] !== v
		? ((b = m.jsx("div", { ...u, children: v })),
			(e[20] = u),
			(e[21] = v),
			(e[22] = b))
		: (b = e[22]);
	let y;
	e[23] !== a || e[24] !== h || e[25] !== b
		? ((y = m.jsxs("div", { ...a, children: [h, b] })),
			(e[23] = a),
			(e[24] = h),
			(e[25] = b),
			(e[26] = y))
		: (y = e[26]);
	let x;
	return (
		e[27] !== f || e[28] !== y
			? ((x = m.jsxs(E.Fragment, { children: [f, y] })),
				(e[27] = f),
				(e[28] = y),
				(e[29] = x))
			: (x = e[29]),
		x
	);
}
function hce(t, e) {
	const n = ce(20),
		r = E.useContext(QD);
	let i;
	n[0] !== r || n[1] !== t
		? ((i = xe(r, t)), (n[0] = r), (n[1] = t), (n[2] = i))
		: (i = n[2]);
	let o;
	n[3] !== i ? ((o = { ...i }), (n[3] = i), (n[4] = o)) : (o = n[4]);
	const s = o,
		a = Ct(e),
		l = ace(s),
		{ menuProps: u } = rce(s, l, a),
		c = ht(s);
	lx(r, a);
	let d;
	n[5] !== c.className
		? ((d = Se(jx, c.className)), (n[5] = c.className), (n[6] = d))
		: (d = n[6]);
	let f;
	n[7] !== l.collection
		? ((f = [...l.collection]), (n[7] = l.collection), (n[8] = f))
		: (f = n[8]);
	let h;
	n[9] !== l || n[10] !== s.onAction || n[11] !== f
		? ((h = f.map((g) => {
				if (g.type === "section")
					return m.jsx(
						fce,
						{ item: g, state: l, onAction: s.onAction },
						g.key,
					);
				let v = m.jsx(
					H_,
					{ item: g, state: l, onAction: s.onAction },
					g.key,
				);
				return g.wrapper && (v = g.wrapper(v)), v;
			})),
			(n[9] = l),
			(n[10] = s.onAction),
			(n[11] = f),
			(n[12] = h))
		: (h = n[12]);
	let p;
	return (
		n[13] !== u ||
		n[14] !== c ||
		n[15] !== a ||
		n[16] !== d ||
		n[17] !== l.selectionManager.selectionMode ||
		n[18] !== h
			? ((p = m.jsx("div", {
					...u,
					...c,
					ref: a,
					className: d,
					"data-selection": l.selectionManager.selectionMode,
					children: h,
				})),
				(n[13] = u),
				(n[14] = c),
				(n[15] = a),
				(n[16] = d),
				(n[17] = l.selectionManager.selectionMode),
				(n[18] = h),
				(n[19] = p))
			: (p = n[19]),
		p
	);
}
const Jo = le.forwardRef(hce),
	Xo = E.forwardRef(function (e, n) {
		const r = ce(39),
			i = E.useRef(null),
			s = Ct(n) || i,
			a = E.useRef(null),
			{
				children: l,
				align: u,
				shouldFlip: c,
				direction: d,
				closeOnSelect: f,
				trigger: h,
			} = e,
			p = u === void 0 ? "start" : u,
			g = c === void 0 ? !0 : c,
			v = d === void 0 ? "bottom" : d,
			b = h === void 0 ? "press" : h;
		let y;
		r[0] !== l
			? ((y = le.Children.toArray(l)), (r[0] = l), (r[1] = y))
			: (y = r[1]);
		const [x, C] = y,
			k = uce(e);
		let w;
		r[2] !== b
			? ((w = { trigger: b }), (r[2] = b), (r[3] = w))
			: (w = r[3]);
		const { menuTriggerProps: D, menuProps: S } = ZD(w, k, s);
		let $;
		e: switch (v) {
			case "left":
			case "right":
			case "start":
			case "end": {
				$ = `${v} ${p === "end" ? "bottom" : "top"}`;
				break e;
			}
			case "bottom":
			case "top":
			default:
				$ = `${v} ${p}`;
		}
		const A = kx(),
			T = k.focusStrategy || !0;
		let I;
		r[4] !== A
			? ((I = A
					? { width: "100%", maxHeight: "inherit" }
					: { maxWidth: B.size.dialog.xsmall }),
				(r[4] = A),
				(r[5] = I))
			: (I = r[5]);
		let F;
		r[6] !== S ||
		r[7] !== a ||
		r[8] !== k.close ||
		r[9] !== f ||
		r[10] !== T ||
		r[11] !== I
			? ((F = {
					...S,
					ref: a,
					onClose: k.close,
					closeOnSelect: f,
					autoFocus: T,
					UNSAFE_style: I,
				}),
				(r[6] = S),
				(r[7] = a),
				(r[8] = k.close),
				(r[9] = f),
				(r[10] = T),
				(r[11] = I),
				(r[12] = F))
			: (F = r[12]);
		const N = F;
		let O;
		if (A) {
			let H;
			r[13] !== k || r[14] !== C
				? ((H = m.jsx(Px, { state: k, children: C })),
					(r[13] = k),
					(r[14] = C),
					(r[15] = H))
				: (H = r[15]),
				(O = H);
		} else {
			let H;
			r[16] !== k ||
			r[17] !== s ||
			r[18] !== a ||
			r[19] !== $ ||
			r[20] !== g ||
			r[21] !== C
				? ((H = m.jsx(g0, {
						state: k,
						triggerRef: s,
						scrollRef: a,
						placement: $,
						hideArrow: !0,
						shouldFlip: g,
						children: C,
					})),
					(r[16] = k),
					(r[17] = s),
					(r[18] = a),
					(r[19] = $),
					(r[20] = g),
					(r[21] = C),
					(r[22] = H))
				: (H = r[22]),
				(O = H);
		}
		const _ = b === "longPress";
		let j;
		r[23] !== _
			? ((j = { actionButton: { holdAffordance: _ } }),
				(r[23] = _),
				(r[24] = j))
			: (j = r[24]);
		let V;
		r[25] !== D || r[26] !== s || r[27] !== k.isOpen || r[28] !== x
			? ((V = m.jsx(Al, {
					...D,
					ref: s,
					isPressed: k.isOpen,
					children: x,
				})),
				(r[25] = D),
				(r[26] = s),
				(r[27] = k.isOpen),
				(r[28] = x),
				(r[29] = V))
			: (V = r[29]);
		let K;
		r[30] !== j || r[31] !== V
			? ((K = m.jsx(Cn, { slots: j, children: V })),
				(r[30] = j),
				(r[31] = V),
				(r[32] = K))
			: (K = r[32]);
		let M;
		r[33] !== N || r[34] !== O
			? ((M = m.jsx(QD.Provider, { value: N, children: O })),
				(r[33] = N),
				(r[34] = O),
				(r[35] = M))
			: (M = r[35]);
		let G;
		return (
			r[36] !== K || r[37] !== M
				? ((G = m.jsxs(E.Fragment, { children: [K, M] })),
					(r[36] = K),
					(r[37] = M),
					(r[38] = G))
				: (G = r[38]),
			G
		);
	});
function pce(t, e) {
	const n = ce(24);
	t = Yr(t, "actionMenu");
	const r = Le(cce);
	let i;
	if (n[0] !== t || n[1] !== r) {
		if (((i = Ge(t, { labelable: !0 })), i["aria-label"] === void 0)) {
			let u;
			n[3] !== r
				? ((u = r.format("moreActions")), (n[3] = r), (n[4] = u))
				: (u = n[4]),
				(i["aria-label"] = u);
		}
		(n[0] = t), (n[1] = r), (n[2] = i);
	} else i = n[2];
	let o;
	n[5] === Symbol.for("react.memo_cache_sentinel")
		? ((o = m.jsx(ve, { src: U_ })), (n[5] = o))
		: (o = n[5]);
	let s;
	n[6] !== e || n[7] !== t || n[8] !== i
		? ((s = m.jsx(Re, { ref: e, ...t, ...i, children: o })),
			(n[6] = e),
			(n[7] = t),
			(n[8] = i),
			(n[9] = s))
		: (s = n[9]);
	let a;
	n[10] !== t.children ||
	n[11] !== t.items ||
	n[12] !== t.disabledKeys ||
	n[13] !== t.onAction
		? ((a = m.jsx(Jo, {
				children: t.children,
				items: t.items,
				disabledKeys: t.disabledKeys,
				onAction: t.onAction,
			})),
			(n[10] = t.children),
			(n[11] = t.items),
			(n[12] = t.disabledKeys),
			(n[13] = t.onAction),
			(n[14] = a))
		: (a = n[14]);
	let l;
	return (
		n[15] !== t.isOpen ||
		n[16] !== t.defaultOpen ||
		n[17] !== t.onOpenChange ||
		n[18] !== t.align ||
		n[19] !== t.direction ||
		n[20] !== t.shouldFlip ||
		n[21] !== s ||
		n[22] !== a
			? ((l = m.jsxs(Xo, {
					isOpen: t.isOpen,
					defaultOpen: t.defaultOpen,
					onOpenChange: t.onOpenChange,
					align: t.align,
					direction: t.direction,
					shouldFlip: t.shouldFlip,
					children: [s, a],
				})),
				(n[15] = t.isOpen),
				(n[16] = t.defaultOpen),
				(n[17] = t.onOpenChange),
				(n[18] = t.align),
				(n[19] = t.direction),
				(n[20] = t.shouldFlip),
				(n[21] = s),
				(n[22] = a),
				(n[23] = l))
			: (l = n[23]),
		l
	);
}
const mce = E.forwardRef(pce),
	W_ = new WeakMap();
function gce(t, e, n) {
	let {
			keyboardDelegate: r,
			isDisabled: i,
			isRequired: o,
			name: s,
			validationBehavior: a = "aria",
		} = t,
		l = a0({ usage: "search", sensitivity: "base" }),
		u = E.useMemo(
			() => r || new Xh(e.collection, e.disabledKeys, null, l),
			[r, e.collection, e.disabledKeys, l],
		),
		{ menuTriggerProps: c, menuProps: d } = ZD(
			{ isDisabled: i, type: "listbox" },
			e,
			n,
		),
		f = (S) => {
			switch (S.key) {
				case "ArrowLeft": {
					S.preventDefault();
					let $ =
						e.selectedKey != null
							? u.getKeyAbove(e.selectedKey)
							: u.getFirstKey();
					$ && e.setSelectedKey($);
					break;
				}
				case "ArrowRight": {
					S.preventDefault();
					let $ =
						e.selectedKey != null
							? u.getKeyBelow(e.selectedKey)
							: u.getFirstKey();
					$ && e.setSelectedKey($);
					break;
				}
			}
		},
		{ typeSelectProps: h } = QN({
			keyboardDelegate: u,
			selectionManager: e.selectionManager,
			onTypeSelect(S) {
				e.setSelectedKey(S);
			},
		}),
		{
			isInvalid: p,
			validationErrors: g,
			validationDetails: v,
		} = e.displayValidation,
		{
			labelProps: b,
			fieldProps: y,
			descriptionProps: x,
			errorMessageProps: C,
		} = Gd({
			...t,
			labelElementType: "span",
			isInvalid: p,
			errorMessage: t.errorMessage || g,
		});
	(h.onKeyDown = h.onKeyDownCapture), delete h.onKeyDownCapture;
	let k = Ge(t, { labelable: !0 }),
		w = xe(h, c, y),
		D = Ot();
	return (
		W_.set(e, {
			isDisabled: i,
			isRequired: o,
			name: s,
			validationBehavior: a,
		}),
		{
			labelProps: {
				...b,
				onClick: () => {
					t.isDisabled || (n.current.focus(), Ic("keyboard"));
				},
			},
			triggerProps: xe(k, {
				...w,
				isDisabled: i,
				onKeyDown: hr(w.onKeyDown, f, t.onKeyDown),
				onKeyUp: t.onKeyUp,
				"aria-labelledby": [
					D,
					w["aria-labelledby"],
					w["aria-label"] && !w["aria-labelledby"] ? w.id : null,
				]
					.filter(Boolean)
					.join(" "),
				onFocus(S) {
					e.isFocused ||
						(t.onFocus && t.onFocus(S),
						t.onFocusChange && t.onFocusChange(!0),
						e.setFocused(!0));
				},
				onBlur(S) {
					e.isOpen ||
						(t.onBlur && t.onBlur(S),
						t.onFocusChange && t.onFocusChange(!1),
						e.setFocused(!1));
				},
			}),
			valueProps: { id: D },
			menuProps: {
				...d,
				autoFocus: e.focusStrategy || !0,
				shouldSelectOnPressUp: !0,
				shouldFocusOnHover: !0,
				disallowEmptySelection: !0,
				linkBehavior: "selection",
				onBlur: (S) => {
					S.currentTarget.contains(S.relatedTarget) ||
						(t.onBlur && t.onBlur(S),
						t.onFocusChange && t.onFocusChange(!1),
						e.setFocused(!1));
				},
				"aria-labelledby": [
					y["aria-labelledby"],
					w["aria-label"] && !y["aria-labelledby"] ? w.id : null,
				]
					.filter(Boolean)
					.join(" "),
			},
			descriptionProps: x,
			errorMessageProps: C,
			isInvalid: p,
			validationErrors: g,
			validationDetails: v,
		}
	);
}
function bce(t, e, n) {
	let r = W_.get(e) || {},
		{ autoComplete: i, name: o = r.name, isDisabled: s = r.isDisabled } = t,
		{ validationBehavior: a, isRequired: l } = r,
		u = fx(),
		{ visuallyHiddenProps: c } = Ea();
	s0(t.selectRef, e.selectedKey, e.setSelectedKey),
		Ax(
			{ validationBehavior: a, focus: () => n.current.focus() },
			e,
			t.selectRef,
		);
	var d;
	return {
		containerProps: {
			...c,
			"aria-hidden": !0,
			"data-react-aria-prevent-focus": !0,
			"data-a11y-ignore": "aria-hidden-focus",
		},
		inputProps: {
			type: "text",
			tabIndex: u == null || e.isFocused || e.isOpen ? -1 : 0,
			style: { fontSize: 16 },
			onFocus: () => n.current.focus(),
			disabled: s,
		},
		selectProps: {
			tabIndex: -1,
			autoComplete: i,
			disabled: s,
			required: a === "native" && l,
			name: o,
			value: (d = e.selectedKey) !== null && d !== void 0 ? d : "",
			onChange: (f) => e.setSelectedKey(f.target.value),
		},
	};
}
function vce(t) {
	let { state: e, triggerRef: n, label: r, name: i, isDisabled: o } = t,
		s = E.useRef(null),
		{
			containerProps: a,
			inputProps: l,
			selectProps: u,
		} = bce({ ...t, selectRef: s }, e, n);
	var c;
	return e.collection.size <= 300
		? le.createElement(
				"div",
				{ ...a, "data-testid": "hidden-select-container" },
				le.createElement("input", l),
				le.createElement(
					"label",
					null,
					r,
					le.createElement(
						"select",
						{ ...u, ref: s },
						le.createElement("option", null),
						[...e.collection.getKeys()].map((d) => {
							let f = e.collection.getItem(d);
							if (f.type === "item")
								return le.createElement(
									"option",
									{ key: f.key, value: f.key },
									f.textValue,
								);
						}),
					),
				),
			)
		: i
			? le.createElement("input", {
					type: "hidden",
					autoComplete: u.autoComplete,
					name: i,
					disabled: o,
					value:
						(c = e.selectedKey) !== null && c !== void 0 ? c : "",
				})
			: null;
}
function yce(t) {
	let e = Bl(t),
		[n, r] = E.useState(null),
		i = Aj({
			...t,
			onSelectionChange: (l) => {
				t.onSelectionChange != null && t.onSelectionChange(l),
					e.close(),
					o.commitValidation();
			},
		}),
		o = Yd({ ...t, value: i.selectedKey }),
		[s, a] = E.useState(!1);
	return {
		...o,
		...i,
		...e,
		focusStrategy: n,
		open(l = null) {
			i.collection.size !== 0 && (r(l), e.open());
		},
		toggle(l = null) {
			i.collection.size !== 0 && (r(l), e.toggle());
		},
		isFocused: s,
		setFocused: a,
	};
}
const xce = m.jsx("path", { d: "m7 15 5 5 5-5M7 9l5-5 5 5" }),
	kce = {
		"ar-AE": { loading: "جارٍ التحميل...", placeholder: "حدد خيارًا..." },
		"bg-BG": { loading: "Зареждане...", placeholder: "Изберете опция" },
		"cs-CZ": {
			loading: "Načítání...",
			placeholder: "Vyberte vhodnou možnost...",
		},
		"da-DK": {
			loading: "Indlæser ...",
			placeholder: "Vælg en mulighed ...",
		},
		"de-DE": { loading: "Laden...", placeholder: "Option auswählen..." },
		"el-GR": { loading: "Φόρτωση...", placeholder: "Επιλέξτε…" },
		"en-US": { placeholder: "Select an option…", loading: "Loading…" },
		"es-ES": {
			loading: "Cargando…",
			placeholder: "Selecciona una de estas opciones...",
		},
		"et-EE": {
			loading: "Laadimine...",
			placeholder: "Valige valikuline...",
		},
		"fi-FI": { loading: "Ladataan…", placeholder: "Valitse vaihtoehto..." },
		"fr-FR": {
			loading: "Chargement...",
			placeholder: "Sélectionnez une option...",
		},
		"he-IL": { loading: "טוען...", placeholder: "בחר אפשרות..." },
		"hr-HR": { loading: "Učitavam...", placeholder: "Odaberite opciju" },
		"hu-HU": {
			loading: "Betöltés folyamatban…",
			placeholder: "Válasszon egy opciót…",
		},
		"it-IT": {
			loading: "Caricamento...",
			placeholder: "Seleziona un’opzione...",
		},
		"ja-JP": {
			loading: "読み込み中...",
			placeholder: "オプションを選択...",
		},
		"ko-KR": { loading: "로드 중", placeholder: "선택 사항 선택" },
		"lt-LT": {
			loading: "Įkeliama...",
			placeholder: "Pasirinkite parinktį...",
		},
		"lv-LV": {
			loading: "Notiek ielāde...",
			placeholder: "Atlasiet opciju...",
		},
		"nb-NO": {
			loading: "Laster inn ...",
			placeholder: "Velg et alternativ...",
		},
		"nl-NL": { loading: "Laden...", placeholder: "Optie selecteren..." },
		"pl-PL": { loading: "Ładowanie...", placeholder: "Wybierz opcję..." },
		"pt-BR": {
			loading: "Carregando...",
			placeholder: "Selecione uma opção...",
		},
		"pt-PT": {
			loading: "A carregar...",
			placeholder: "Selecionar uma opção...",
		},
		"ro-RO": {
			loading: "Se încarcă...",
			placeholder: "Selectați o opțiune",
		},
		"ru-RU": { loading: "Загрузка...", placeholder: "Выбрать параметр..." },
		"sk-SK": {
			loading: "Načítava sa...",
			placeholder: "Vyberte možnosť...",
		},
		"sl-SI": { loading: "Nalaganje...", placeholder: "Izberite možnost" },
		"sr-SP": { loading: "Učitavam...", placeholder: "Izaberite opciju" },
		"sv-SE": {
			loading: "Läser in...",
			placeholder: "Välj ett alternativ...",
		},
		"tr-TR": { loading: "Yükleniyor...", placeholder: "Bir seçim yapın…" },
		"uk-UA": { loading: "Завантаження…", placeholder: "Виберіть опцію..." },
		"zh-CN": { loading: "正在加载...", placeholder: "选择一个选项..." },
		"zh-T": { loading: "正在載入", placeholder: "選取一個選項" },
	};
function Cce(t, e) {
	(t = Yr(t, "picker")), (t = vo(t));
	let n = Le(kce),
		{
			align: r = "start",
			autoComplete: i,
			autoFocus: o,
			direction: s = "bottom",
			isDisabled: a,
			label: l,
			menuWidth: u,
			name: c,
			placeholder: d = n.format("placeholder"),
			prominence: f,
			shouldFlip: h = !0,
		} = t,
		p = E.useRef(null),
		g = E.useRef(null),
		v = E.useRef(null),
		b = x0(),
		y = yce(t),
		{
			labelProps: x,
			triggerProps: C,
			valueProps: k,
			menuProps: w,
			descriptionProps: D,
			errorMessageProps: S,
		} = gce(t, y, g),
		$ = kx(),
		A = t.isLoading && y.collection.size === 0,
		T = t.isLoading && y.collection.size > 0,
		I = m.jsx(k0, {
			...w,
			ref: v,
			disallowEmptySelection: !0,
			autoFocus: y.focusStrategy || !0,
			shouldSelectOnPressUp: !0,
			focusOnPointerEnter: !0,
			layout: b,
			state: y,
			UNSAFE_className: jx,
			isLoading: T,
			onLoadMore: t.onLoadMore,
		}),
		[F, N] = E.useState(),
		{ scale: O } = Rs(),
		_ = E.useCallback(() => {
			if (!$ && g.current) {
				let M = g.current.offsetWidth;
				N(M);
			}
		}, [g, N, $]);
	fa({ ref: g, onResize: _ }), at(_, [O, y.selectedKey, _]);
	let j;
	if ($) j = m.jsx(Px, { state: y, children: I });
	else {
		let M = { minWidth: F, width: u ?? F };
		j = m.jsx(g0, {
			UNSAFE_style: M,
			ref: p,
			placement: `${s} ${r}`,
			shouldFlip: h,
			hideArrow: !0,
			state: y,
			triggerRef: g,
			scrollRef: v,
			children: I,
		});
	}
	let V = y.selectedItem ? y.selectedItem.rendered : d;
	$n(V) && (V = m.jsx(ue, { children: V }));
	let K = m.jsxs("div", {
		children: [
			m.jsx(vce, {
				autoComplete: i,
				isDisabled: a,
				label: l,
				name: c,
				state: y,
				triggerRef: g,
			}),
			m.jsx(Al, {
				...C,
				children: m.jsxs(UP, {
					"aria-required": !0,
					prominence: f,
					ref: g,
					isActive: y.isOpen,
					isDisabled: a,
					autoFocus: o,
					UNSAFE_className: Se(
						X({
							alignItems: "center",
							display: "flex",
							justifyContent: "space-between",
							position: "relative",
							width: "100%",
							contain: "size",
						}),
					),
					children: [
						m.jsx(Cn, {
							slots: {
								icon: { marginEnd: "small" },
								text: {
									...k,
									color: y.selectedItem
										? "inherit"
										: "neutralSecondary",
								},
								description: { isHidden: !0 },
							},
							children: V,
						}),
						A &&
							m.jsx(Cr, {
								isIndeterminate: !0,
								size: "small",
								"aria-label": n.format("loading"),
								UNSAFE_className: X({
									marginInlineStart: B.size.space.small,
								}),
							}),
						m.jsx(ve, {
							src: xce,
							UNSAFE_className: X({
								marginInlineStart: B.size.space.small,
							}),
						}),
					],
				}),
			}),
			y.collection.size === 0 ? null : j,
		],
	});
	return m.jsx(Yh, {
		width: "alias.singleLineWidth",
		...t,
		ref: e,
		labelProps: x,
		descriptionProps: D,
		errorMessageProps: S,
		supplementRequiredState: !0,
		children: K,
	});
}
const eS = E.forwardRef(Cce),
	wce = m.jsxs(m.Fragment, {
		children: [
			m.jsx("path", {
				d: "M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z",
			}),
			m.jsx("path", {
				d: "M14 2v4a2 2 0 0 0 2 2h4M10 13l-2 2 2 2M14 17l2-2-2-2",
			}),
		],
	}),
	Ece = m.jsx("path", { d: "M4 12h8M4 18V6M12 18V6M17 12l3-2v8" }),
	Dce = m.jsx("path", {
		d: "M4 12h8M4 18V6M12 18V6M21 18h-4c0-4 4-3 4-6 0-1.5-2-2.5-4-1",
	}),
	Sce = m.jsx("path", {
		d: "M4 12h8M4 18V6M12 18V6M17.5 10.5c1.7-1 3.5 0 3.5 1.5a2 2 0 0 1-2 2M17 17.5c2 1.5 4 .3 4-1.5a2 2 0 0 0-2-2",
	}),
	Ace = m.jsx("path", { d: "M4 12h8M4 18V6M12 18V6M17 10v4h4M21 10v8" }),
	$ce = m.jsx("path", {
		d: "M4 12h8M4 18V6M12 18V6M17 13v-3h4M17 17.7c.4.2.8.3 1.3.3 1.5 0 2.7-1.1 2.7-2.5S19.8 13 18.3 13H17",
	}),
	Tce = m.jsxs(m.Fragment, {
		children: [
			m.jsx("path", { d: "M4 12h8M4 18V6M12 18V6" }),
			m.jsx("circle", { cx: 19, cy: 16, r: 2 }),
			m.jsx("path", { d: "M20 10c-2 2-3 3.5-3 6" }),
		],
	}),
	E0 = m.jsxs(m.Fragment, {
		children: [
			m.jsx("rect", { width: 18, height: 18, x: 3, y: 3, rx: 2, ry: 2 }),
			m.jsx("circle", { cx: 9, cy: 9, r: 2 }),
			m.jsx("path", { d: "m21 15-3.086-3.086a2 2 0 0 0-2.828 0L6 21" }),
		],
	}),
	Bce = m.jsx("path", { d: "M3 12h18M8 8l4-4 4 4M16 16l-4 4-4-4" });
function q_(t, e) {
	let { role: n = "dialog" } = t,
		r = Lo();
	r = t["aria-label"] ? void 0 : r;
	let i = E.useRef(!1);
	return (
		E.useEffect(() => {
			if (e.current && !e.current.contains(document.activeElement)) {
				on(e.current);
				let o = setTimeout(() => {
					document.activeElement === e.current &&
						((i.current = !0),
						e.current && (e.current.blur(), on(e.current)),
						(i.current = !1));
				}, 500);
				return () => {
					clearTimeout(o);
				};
			}
		}, [e]),
		mP(),
		{
			dialogProps: {
				...Ge(t, { labelable: !0 }),
				role: n,
				tabIndex: -1,
				"aria-labelledby": t["aria-labelledby"] || r,
				onBlur: (o) => {
					i.current && o.stopPropagation();
				},
			},
			titleProps: { id: r },
		}
	);
}
const D0 = le.createContext(null),
	Ice = {
		"ar-AE": { alert: "تنبيه", dismiss: "تجاهل" },
		"bg-BG": { alert: "Сигнал", dismiss: "Отхвърляне" },
		"cs-CZ": { alert: "Výstraha", dismiss: "Odstranit" },
		"da-DK": { alert: "Advarsel", dismiss: "Luk" },
		"de-DE": { alert: "Warnhinweis", dismiss: "Schließen" },
		"el-GR": { alert: "Ειδοποίηση", dismiss: "Απόρριψη" },
		"en-US": { alert: "Alert", dismiss: "Dismiss" },
		"es-ES": { alert: "Alerta", dismiss: "Descartar" },
		"et-EE": { alert: "Teade", dismiss: "Lõpeta" },
		"fi-FI": { alert: "Hälytys", dismiss: "Hylkää" },
		"fr-FR": { alert: "Alerte", dismiss: "Rejeter" },
		"he-IL": { alert: "התראה", dismiss: "התעלם" },
		"hr-HR": { alert: "Upozorenje", dismiss: "Odbaci" },
		"hu-HU": { alert: "Figyelmeztetés", dismiss: "Elutasítás" },
		"it-IT": { alert: "Avviso", dismiss: "Ignora" },
		"ja-JP": { alert: "アラート", dismiss: "閉じる" },
		"ko-KR": { alert: "경고", dismiss: "무시" },
		"lt-LT": { alert: "Įspėjimas", dismiss: "Atmesti" },
		"lv-LV": { alert: "Brīdinājums", dismiss: "Nerādīt" },
		"nb-NO": { alert: "Varsel", dismiss: "Lukk" },
		"nl-NL": { alert: "Melding", dismiss: "Negeren" },
		"pl-PL": { alert: "Ostrzeżenie", dismiss: "Zignoruj" },
		"pt-BR": { alert: "Alerta", dismiss: "Descartar" },
		"pt-PT": { alert: "Alerta", dismiss: "Dispensar" },
		"ro-RO": { alert: "Alertă", dismiss: "Revocare" },
		"ru-RU": { alert: "Предупреждение", dismiss: "Пропустить" },
		"sk-SK": { alert: "Upozornenie", dismiss: "Zrušiť" },
		"sl-SI": { alert: "Opozorilo", dismiss: "Opusti" },
		"sr-SP": { alert: "Upozorenje", dismiss: "Odbaci" },
		"sv-SE": { alert: "Varning", dismiss: "Avvisa" },
		"tr-TR": { alert: "Uyarı", dismiss: "Kapat" },
		"uk-UA": { alert: "Сигнал тривоги", dismiss: "Скасувати" },
		"zh-CN": { alert: "警报", dismiss: "取消" },
		"zh-T": { alert: "警示", dismiss: "關閉" },
	},
	Zi = new Gr("Dialog", [
		"root",
		"grid",
		"heading",
		"header",
		"footer",
		"button-group",
	]),
	vr = E.forwardRef(function (e, n) {
		let { type: r = "modal", ...i } = E.useContext(D0) || {},
			{
				children: o,
				isDismissable: s = i.isDismissable,
				onDismiss: a = i.onClose,
				size: l,
			} = e,
			u = Le(Ice),
			c = Ct(n),
			d = E.useRef(null),
			{ dialogProps: f, titleProps: h } = q_(xe(i, e), c);
		const p = "regular";
		let g = Yp(Zi.selector("heading"), d),
			v = Yp(Zi.selector("header"), d),
			b = Yp(Zi.selector("footer"), d),
			y = Yp(Zi.selector("button-group"), d),
			x = E.useMemo(
				() => ({
					heading: {
						...lt({ hasHeader: v }),
						UNSAFE_className: Se(Zi.element("heading"), Rce()),
						elementType: "h2",
						size: p,
						...h,
					},
					header: {
						UNSAFE_className: Se(Zi.element("header"), Oce()),
					},
					content: {
						...lt({
							hasHeader: v || g || void 0,
							hasFooter: b || (y && r !== "fullscreen") || void 0,
						}),
						UNSAFE_className: Mce(),
					},
					footer: {
						UNSAFE_className: Se(Zi.element("footer"), _ce()),
					},
					buttonGroup: {
						...lt({ hasFooter: b }),
						UNSAFE_className: Se(Zi.element("button-group"), jce()),
						align: "end",
					},
				}),
				[y, b, v, g, p, h, r],
			);
		const C = Fce(r, l),
			k = Pce(e, { type: r, size: C }),
			w = Nce({ isDismissable: s, size: C });
		return m.jsx("section", {
			...k,
			...f,
			ref: c,
			children: m.jsxs(gd, {
				ref: d,
				...w,
				children: [
					m.jsx(Cn, { slots: x, children: o }),
					s &&
						m.jsx(Re, {
							prominence: "low",
							"aria-label": u.format("dismiss"),
							onPress: a,
							gridArea: "closeButton",
							UNSAFE_className: X({
								placeSelf: "flex-start end",
								paddingInline: 0,
								marginBlock: `calc((${B.size.element.regular} - ${B.typography.heading[p].capheight}) / 2 * -1)`,
								marginInlineEnd: `calc(${B.size.space.medium} * -1)`,
								marginInlineStart: B.size.space.regular,
							}),
							children: m.jsx(ve, { src: cD, size: "medium" }),
						}),
				],
			}),
		});
	});
function Fce(t, e) {
	return t === "fullscreen"
		? "fullscreen"
		: t === "popover"
			? e || "xsmall"
			: e || "medium";
}
function Pce(t, e) {
	const n = ce(8),
		{ size: r, type: i } = e,
		o = ht(t),
		s = i === "tray" ? void 0 : r;
	let a;
	n[0] !== s ? ((a = lt({ size: s })), (n[0] = s), (n[1] = a)) : (a = n[1]);
	let l;
	n[2] !== o.className
		? ((l = Se(
				Zi.element("root"),
				X({
					display: "flex",
					maxHeight: "inherit",
					maxWidth: "100%",
					outline: 0,
					width: "var(--dialog-width)",
					"--dialog-width": "fit-content",
					'&[data-size="xsmall"]': {
						"--dialog-width": B.size.dialog.xsmall,
					},
					'&[data-size="small"]': {
						"--dialog-width": B.size.dialog.small,
					},
					'&[data-size="medium"]': {
						"--dialog-width": B.size.dialog.medium,
					},
					'&[data-size="large"]': {
						"--dialog-width": B.size.dialog.large,
					},
					'&[data-size="fullscreen"]': {
						maxHeight: "none",
						maxWidth: "none",
						height: "100%",
						"--dialog-width": "100%",
					},
				}),
				o.className,
			)),
			(n[2] = o.className),
			(n[3] = l))
		: (l = n[3]);
	let u;
	return (
		n[4] !== a || n[5] !== o || n[6] !== l
			? ((u = { ...a, ...o, className: l }),
				(n[4] = a),
				(n[5] = o),
				(n[6] = l),
				(n[7] = u))
			: (u = n[7]),
		u
	);
}
function Nce({ isDismissable: t, size: e }) {
	let n = X({
		display: "grid",
		padding: B.size.space.xxlarge,
		gridTemplateColumns: "auto minmax(0, 1fr) auto",
		gridTemplateRows: "auto minmax(0, 1fr) auto",
		gridTemplateAreas: `"heading header header"
      "content content content"
      "footer footer buttonGroup"`,
		width: "100%",
		"&[data-dismissable]": {
			gridTemplateColumns: "auto minmax(0, 1fr) auto auto",
			gridTemplateAreas: `"heading header header closeButton"
        "content content content content"
        "footer footer footer footer"`,
			[Zi.selector("button-group")]: { display: "none" },
		},
		[en.below.tablet]: {
			padding: B.size.space.xlarge,
			gridTemplateRows: "auto auto minmax(0, 1fr) auto",
			gridTemplateAreas: `"heading heading heading"
      "header header header"
        "content content content"
        "footer footer buttonGroup"`,
			"&[data-dismissable]": {
				gridTemplateAreas: `"heading heading closeButton"
          "header header header"
            "content content content"
            "footer footer buttonGroup"`,
			},
		},
		[en.above.mobile]: {
			'&[data-size="fullscreen"]': {
				gridTemplateAreas: `"heading header buttonGroup"
          "content content content"
          "footer footer footer"`,
			},
		},
	});
	return {
		...lt({ dismissable: t || void 0, size: e }),
		UNSAFE_className: Se(Zi.element("grid"), n),
	};
}
function Rce() {
	return X({
		alignSelf: "center",
		gridArea: "heading",
		paddingBottom: B.size.space.large,
		[en.above.mobile]: { paddingBottom: B.size.space.xlarge },
		"&[data-has-header=false]": {
			gridArea: "heading-start / heading-start / header-end / header-end",
		},
	});
}
function Oce() {
	return X({
		alignItems: "center",
		boxSizing: "border-box",
		display: "flex",
		gridArea: "header",
		minWidth: "fit-content",
		outline: 0,
		paddingBottom: B.size.space.large,
		[en.above.mobile]: {
			justifyContent: "flex-end",
			paddingBottom: B.size.space.xlarge,
		},
	});
}
function Mce() {
	return X({
		gridArea: "content",
		overflowX: "hidden",
		overflowY: "auto",
		WebkitOverflowScrolling: "touch",
		padding: B.size.space.regular,
		margin: `calc(${B.size.space.regular} * -1)`,
	});
}
function jce() {
	return X({
		gridArea: "buttonGroup",
		minWidth: 0,
		marginInlineStart: B.size.space.regular,
		paddingTop: B.size.space.large,
		[en.above.mobile]: { paddingTop: B.size.space.xlarge },
		[`${Zi.selector("root")}:not([data-size=fullscreen]) &[data-has-footer=false]`]:
			{
				gridArea:
					"footer-start / footer-start / buttonGroup-end / buttonGroup-end",
			},
		[`${Zi.selector("root")}[data-dismissable] &`]: { display: "none" },
	});
}
function _ce() {
	return X({
		alignItems: "center",
		display: "flex",
		flexWrap: "wrap",
		gridArea: "footer",
		minWidth: 0,
		paddingTop: B.size.space.large,
		[en.above.mobile]: { paddingTop: B.size.space.xlarge },
	});
}
const Fw = E.forwardRef(function (e, n) {
	const r = ce(58),
		{ onClose: i } = E.useContext(D0) || {};
	let o;
	r[0] !== i
		? ((o = i === void 0 ? () => {} : i), (r[0] = i), (r[1] = o))
		: (o = r[1]);
	const s = o;
	let a, l, u, c, d, f, h, p, g, v, b, y, x;
	r[2] !== e
		? (({
				autoFocusButton: p,
				cancelLabel: h,
				children: f,
				isPrimaryActionDisabled: y,
				isSecondaryActionDisabled: v,
				onCancel: a,
				onPrimaryAction: l,
				onSecondaryAction: u,
				primaryActionLabel: x,
				secondaryActionLabel: g,
				title: d,
				tone: b,
				...c
			} = e),
			(r[2] = e),
			(r[3] = a),
			(r[4] = l),
			(r[5] = u),
			(r[6] = c),
			(r[7] = d),
			(r[8] = f),
			(r[9] = h),
			(r[10] = p),
			(r[11] = g),
			(r[12] = v),
			(r[13] = b),
			(r[14] = y),
			(r[15] = x))
		: ((a = r[3]),
			(l = r[4]),
			(u = r[5]),
			(c = r[6]),
			(d = r[7]),
			(f = r[8]),
			(h = r[9]),
			(p = r[10]),
			(g = r[11]),
			(v = r[12]),
			(b = r[13]),
			(y = r[14]),
			(x = r[15]));
	let C;
	r[16] !== a
		? ((C = a === void 0 ? () => {} : a), (r[16] = a), (r[17] = C))
		: (C = r[17]);
	const k = C;
	let w;
	r[18] !== l
		? ((w = l === void 0 ? () => {} : l), (r[18] = l), (r[19] = w))
		: (w = r[19]);
	const D = w;
	let S;
	r[20] !== u
		? ((S = u === void 0 ? () => {} : u), (r[20] = u), (r[21] = S))
		: (S = r[21]);
	const $ = S,
		A = ht(c);
	let T;
	r[22] !== d
		? ((T = m.jsx(Ut, { children: d })), (r[22] = d), (r[23] = T))
		: (T = r[23]);
	let I;
	r[24] !== f
		? ((I = m.jsx(Pr, {
				children: $n(f) ? m.jsx(ue, { children: f }) : f,
			})),
			(r[24] = f),
			(r[25] = I))
		: (I = r[25]);
	let F;
	r[26] !== h || r[27] !== s || r[28] !== k || r[29] !== p || r[30] !== g
		? ((F =
				h &&
				m.jsx(vt, {
					onPress: () => hr(s(), k()),
					autoFocus: p === "cancel",
					prominence: g ? "low" : void 0,
					children: h,
				})),
			(r[26] = h),
			(r[27] = s),
			(r[28] = k),
			(r[29] = p),
			(r[30] = g),
			(r[31] = F))
		: (F = r[31]);
	let N;
	r[32] !== g || r[33] !== s || r[34] !== $ || r[35] !== p || r[36] !== v
		? ((N =
				g &&
				m.jsx(vt, {
					onPress: () => hr(s(), $()),
					autoFocus: p === "secondary",
					isDisabled: v,
					children: g,
				})),
			(r[32] = g),
			(r[33] = s),
			(r[34] = $),
			(r[35] = p),
			(r[36] = v),
			(r[37] = N))
		: (N = r[37]);
	let O;
	r[38] !== s || r[39] !== D
		? ((O = () => hr(s(), D())), (r[38] = s), (r[39] = D), (r[40] = O))
		: (O = r[40]);
	const _ = p === "primary";
	let j;
	r[41] !== b || r[42] !== O || r[43] !== y || r[44] !== _ || r[45] !== x
		? ((j = m.jsx(vt, {
				prominence: "high",
				tone: b,
				onPress: O,
				isDisabled: y,
				autoFocus: _,
				children: x,
			})),
			(r[41] = b),
			(r[42] = O),
			(r[43] = y),
			(r[44] = _),
			(r[45] = x),
			(r[46] = j))
		: (j = r[46]);
	let V;
	r[47] !== F || r[48] !== N || r[49] !== j
		? ((V = m.jsxs(Nr, { align: "end", children: [F, N, j] })),
			(r[47] = F),
			(r[48] = N),
			(r[49] = j),
			(r[50] = V))
		: (V = r[50]);
	let K;
	return (
		r[51] !== n ||
		r[52] !== A.className ||
		r[53] !== A.style ||
		r[54] !== T ||
		r[55] !== I ||
		r[56] !== V
			? ((K = m.jsxs(vr, {
					role: "alertdialog",
					ref: n,
					size: "small",
					UNSAFE_className: A.className,
					UNSAFE_style: A.style,
					children: [T, I, V],
				})),
				(r[51] = n),
				(r[52] = A.className),
				(r[53] = A.style),
				(r[54] = T),
				(r[55] = I),
				(r[56] = V),
				(r[57] = K))
			: (K = r[57]),
		K
	);
});
function mn(t) {
	const e = ce(18),
		{
			children: n,
			type: r,
			onDismiss: i,
			isDismissable: o,
			isKeyboardDismissDisabled: s,
		} = t,
		a = r === void 0 ? "modal" : r,
		l = E.isValidElement(n) ? n : null,
		[u, c] = E.useState(l);
	l && l !== u && c(l);
	let d;
	e[0] !== a || e[1] !== i || e[2] !== o
		? ((d = { type: a, onClose: i, isDismissable: o }),
			(e[0] = a),
			(e[1] = i),
			(e[2] = o),
			(e[3] = d))
		: (d = e[3]);
	const f = d,
		h = !!l;
	let p;
	e[4] !== i
		? ((p = (x) => {
				x || i();
			}),
			(e[4] = i),
			(e[5] = p))
		: (p = e[5]);
	let g;
	e[6] !== h || e[7] !== p
		? ((g = { isOpen: h, onOpenChange: p }),
			(e[6] = h),
			(e[7] = p),
			(e[8] = g))
		: (g = e[8]);
	const v = Bl(g);
	let b;
	e[9] !== f || e[10] !== u
		? ((b = m.jsx(D0.Provider, { value: f, children: u })),
			(e[9] = f),
			(e[10] = u),
			(e[11] = b))
		: (b = e[11]);
	let y;
	return (
		e[12] !== v || e[13] !== a || e[14] !== o || e[15] !== s || e[16] !== b
			? ((y = m.jsx(OO, {
					state: v,
					type: a,
					isDismissable: o,
					isKeyboardDismissDisabled: s,
					children: b,
				})),
				(e[12] = v),
				(e[13] = a),
				(e[14] = o),
				(e[15] = s),
				(e[16] = b),
				(e[17] = y))
			: (y = e[17]),
		y
	);
}
function Xd() {
	const t = ce(2),
		e = E.useContext(D0);
	wt(
		!!e,
		"Cannot call `useDialogContext` outside of `<DialogTrigger>` or `<DialogContainer>`.",
	);
	let n;
	return (
		t[0] !== e
			? ((n = {
					type: e.type,
					dismiss() {
						e.onClose();
					},
				}),
				(t[0] = e),
				(t[1] = n))
			: (n = t[1]),
		n
	);
}
function Pw(t) {
	let {
		children: e,
		type: n = "modal",
		mobileType: r = n === "popover" ? "modal" : n,
		hideArrow: i,
		targetRef: o,
		isDismissable: s,
		isKeyboardDismissDisabled: a,
		...l
	} = t;
	if (!Array.isArray(e) || e.length > 2)
		throw new Error("DialogTrigger must have exactly 2 children");
	let [u, c] = e;
	$l(en.below.tablet) &&
		(n !== "modal" && r === "modal" && (s = !0), (n = r));
	let f = Bl(t),
		h = E.useRef(!1);
	h.current = f.isOpen;
	let p = E.useRef(!1),
		g = () => (p.current = !0),
		v = () => (p.current = !1);
	const b = Pt(() => {
		(h.current || p.current) &&
			n !== "popover" &&
			n !== "tray" &&
			console.warn(
				"A DialogTrigger unmounted while open. This is likely due to being placed within a trigger that unmounts or inside a conditional. Consider using a DialogContainer instead.",
			);
	});
	if ((E.useEffect(() => b, [b]), n === "popover"))
		return m.jsx(Lce, {
			...l,
			state: f,
			targetRef: o,
			trigger: u,
			content: c,
			isKeyboardDismissDisabled: a,
			hideArrow: i,
		});
	let y = () => {
		switch (n) {
			case "fullscreen":
			case "modal":
				return m.jsx(OO, {
					state: f,
					isDismissable: n === "modal" ? s : !1,
					type: n,
					isKeyboardDismissDisabled: a,
					onExiting: g,
					onExited: v,
					children: typeof c == "function" ? c(f.close) : c,
				});
			case "tray":
				return m.jsx(Px, {
					state: f,
					isKeyboardDismissDisabled: a,
					children: typeof c == "function" ? c(f.close) : c,
				});
		}
		qn(n);
	};
	return m.jsx(G_, {
		type: n,
		state: f,
		isDismissable: s,
		trigger: u,
		overlay: y(),
	});
}
Pw.getCollectionNode = function* (t) {
	let [e] = E.Children.toArray(t.children),
		[, n] = t.children;
	yield {
		element: e,
		wrapper: (r) => m.jsxs(Pw, { ...t, children: [r, n] }, r.key),
	};
};
let zce = Pw;
function Lce(t) {
	const e = ce(26);
	let n, r, i, o, s, a;
	e[0] !== t
		? (({
				state: n,
				targetRef: r,
				trigger: a,
				content: i,
				hideArrow: s,
				...o
			} = t),
			(e[0] = t),
			(e[1] = n),
			(e[2] = r),
			(e[3] = i),
			(e[4] = o),
			(e[5] = s),
			(e[6] = a))
		: ((n = e[1]),
			(r = e[2]),
			(i = e[3]),
			(o = e[4]),
			(s = e[5]),
			(a = e[6]));
	const l = E.useRef(null);
	let u;
	e[7] === Symbol.for("react.memo_cache_sentinel")
		? ((u = { type: "dialog" }), (e[7] = u))
		: (u = e[7]);
	const { triggerProps: c, overlayProps: d } = px(u, n, l),
		f = r ? void 0 : l;
	let h;
	e[8] !== c || e[9] !== f
		? ((h = { ...c, ref: f }), (e[8] = c), (e[9] = f), (e[10] = h))
		: (h = e[10]);
	const p = h,
		g = r || l;
	let v;
	e[11] !== i || e[12] !== n
		? ((v = typeof i == "function" ? i(n.close) : i),
			(e[11] = i),
			(e[12] = n),
			(e[13] = v))
		: (v = e[13]);
	let b;
	e[14] !== o || e[15] !== s || e[16] !== g || e[17] !== n || e[18] !== v
		? ((b = m.jsx(g0, {
				...o,
				hideArrow: s,
				triggerRef: g,
				state: n,
				children: v,
			})),
			(e[14] = o),
			(e[15] = s),
			(e[16] = g),
			(e[17] = n),
			(e[18] = v),
			(e[19] = b))
		: (b = e[19]);
	const y = b;
	let x;
	return (
		e[20] !== n || e[21] !== p || e[22] !== d || e[23] !== a || e[24] !== y
			? ((x = m.jsx(G_, {
					type: "popover",
					state: n,
					triggerProps: p,
					dialogProps: d,
					trigger: a,
					overlay: y,
				})),
				(e[20] = n),
				(e[21] = p),
				(e[22] = d),
				(e[23] = a),
				(e[24] = y),
				(e[25] = x))
			: (x = e[25]),
		x
	);
}
function G_(t) {
	const e = ce(22),
		{
			type: n,
			state: r,
			isDismissable: i,
			dialogProps: o,
			triggerProps: s,
			overlay: a,
			trigger: l,
		} = t;
	let u;
	e[0] !== o
		? ((u = o === void 0 ? {} : o), (e[0] = o), (e[1] = u))
		: (u = e[1]);
	const c = u;
	let d;
	e[2] !== s
		? ((d = s === void 0 ? {} : s), (e[2] = s), (e[3] = d))
		: (d = e[3]);
	const f = d;
	let h;
	e[4] !== n || e[5] !== r.close || e[6] !== i || e[7] !== c
		? ((h = { type: n, onClose: r.close, isDismissable: i, ...c }),
			(e[4] = n),
			(e[5] = r.close),
			(e[6] = i),
			(e[7] = c),
			(e[8] = h))
		: (h = e[8]);
	const p = h;
	let g;
	e[9] !== r.open || e[10] !== f
		? ((g = xe(f, { onPress: r.open })),
			(e[9] = r.open),
			(e[10] = f),
			(e[11] = g))
		: (g = e[11]);
	const v = r.isOpen && n !== "modal" && n !== "fullscreen";
	let b;
	e[12] !== g || e[13] !== v || e[14] !== l
		? ((b = m.jsx(Al, { ...g, isPressed: v, children: l })),
			(e[12] = g),
			(e[13] = v),
			(e[14] = l),
			(e[15] = b))
		: (b = e[15]);
	let y;
	e[16] !== p || e[17] !== a
		? ((y = m.jsx(D0.Provider, { value: p, children: a })),
			(e[16] = p),
			(e[17] = a),
			(e[18] = y))
		: (y = e[18]);
	let x;
	return (
		e[19] !== b || e[20] !== y
			? ((x = m.jsxs(E.Fragment, { children: [b, y] })),
				(e[19] = b),
				(e[20] = y),
				(e[21] = x))
			: (x = e[21]),
		x
	);
}
var Vce = Hce,
	Y_ = "֑-߿יִ-﷽ﹰ-ﻼ",
	J_ = "A-Za-zÀ-ÖØ-öø-ʸ̀-֐ࠀ-῿‎Ⰰ-﬜︀-﹯﻽-￿",
	Kce = new RegExp("^[^" + J_ + "]*[" + Y_ + "]"),
	Uce = new RegExp("^[^" + Y_ + "]*[" + J_ + "]");
function Hce(t) {
	return (
		(t = String(t || "")),
		Kce.test(t) ? "rtl" : Uce.test(t) ? "ltr" : "neutral"
	);
}
const X_ = Dl(Vce);
function Wce(t) {
	var e = typeof t;
	return t != null && (e == "object" || e == "function");
}
var tS = Wce,
	qce = typeof hu == "object" && hu && hu.Object === Object && hu,
	Gce = qce,
	Yce = Gce,
	Jce = typeof self == "object" && self && self.Object === Object && self,
	Xce = Yce || Jce || Function("return this")(),
	Z_ = Xce,
	Zce = Z_,
	Qce = function () {
		return Zce.Date.now();
	},
	ede = Qce,
	tde = /\s/;
function nde(t) {
	for (var e = t.length; e-- && tde.test(t.charAt(e)); );
	return e;
}
var rde = nde,
	ide = rde,
	ode = /^\s+/;
function sde(t) {
	return t && t.slice(0, ide(t) + 1).replace(ode, "");
}
var ade = sde,
	lde = Z_,
	ude = lde.Symbol,
	Q_ = ude,
	q$ = Q_,
	ez = Object.prototype,
	cde = ez.hasOwnProperty,
	dde = ez.toString,
	Ip = q$ ? q$.toStringTag : void 0;
function fde(t) {
	var e = cde.call(t, Ip),
		n = t[Ip];
	try {
		t[Ip] = void 0;
		var r = !0;
	} catch {}
	var i = dde.call(t);
	return r && (e ? (t[Ip] = n) : delete t[Ip]), i;
}
var hde = fde,
	pde = Object.prototype,
	mde = pde.toString;
function gde(t) {
	return mde.call(t);
}
var bde = gde,
	G$ = Q_,
	vde = hde,
	yde = bde,
	xde = "[object Null]",
	kde = "[object Undefined]",
	Y$ = G$ ? G$.toStringTag : void 0;
function Cde(t) {
	return t == null
		? t === void 0
			? kde
			: xde
		: Y$ && Y$ in Object(t)
			? vde(t)
			: yde(t);
}
var wde = Cde;
function Ede(t) {
	return t != null && typeof t == "object";
}
var Dde = Ede,
	Sde = wde,
	Ade = Dde,
	$de = "[object Symbol]";
function Tde(t) {
	return typeof t == "symbol" || (Ade(t) && Sde(t) == $de);
}
var Bde = Tde,
	Ide = ade,
	J$ = tS,
	Fde = Bde,
	X$ = NaN,
	Pde = /^[-+]0x[0-9a-f]+$/i,
	Nde = /^0b[01]+$/i,
	Rde = /^0o[0-7]+$/i,
	Ode = parseInt;
function Mde(t) {
	if (typeof t == "number") return t;
	if (Fde(t)) return X$;
	if (J$(t)) {
		var e = typeof t.valueOf == "function" ? t.valueOf() : t;
		t = J$(e) ? e + "" : e;
	}
	if (typeof t != "string") return t === 0 ? t : +t;
	t = Ide(t);
	var n = Nde.test(t);
	return n || Rde.test(t)
		? Ode(t.slice(2), n ? 2 : 8)
		: Pde.test(t)
			? X$
			: +t;
}
var jde = Mde,
	_de = tS,
	ak = ede,
	Z$ = jde,
	zde = "Expected a function",
	Lde = Math.max,
	Vde = Math.min;
function Kde(t, e, n) {
	var r,
		i,
		o,
		s,
		a,
		l,
		u = 0,
		c = !1,
		d = !1,
		f = !0;
	if (typeof t != "function") throw new TypeError(zde);
	(e = Z$(e) || 0),
		_de(n) &&
			((c = !!n.leading),
			(d = "maxWait" in n),
			(o = d ? Lde(Z$(n.maxWait) || 0, e) : o),
			(f = "trailing" in n ? !!n.trailing : f));
	function h(w) {
		var D = r,
			S = i;
		return (r = i = void 0), (u = w), (s = t.apply(S, D)), s;
	}
	function p(w) {
		return (u = w), (a = setTimeout(b, e)), c ? h(w) : s;
	}
	function g(w) {
		var D = w - l,
			S = w - u,
			$ = e - D;
		return d ? Vde($, o - S) : $;
	}
	function v(w) {
		var D = w - l,
			S = w - u;
		return l === void 0 || D >= e || D < 0 || (d && S >= o);
	}
	function b() {
		var w = ak();
		if (v(w)) return y(w);
		a = setTimeout(b, g(w));
	}
	function y(w) {
		return (a = void 0), f && r ? h(w) : ((r = i = void 0), s);
	}
	function x() {
		a !== void 0 && clearTimeout(a), (u = 0), (r = l = i = a = void 0);
	}
	function C() {
		return a === void 0 ? s : y(ak());
	}
	function k() {
		var w = ak(),
			D = v(w);
		if (((r = arguments), (i = this), (l = w), D)) {
			if (a === void 0) return p(l);
			if (d) return clearTimeout(a), (a = setTimeout(b, e)), h(l);
		}
		return a === void 0 && (a = setTimeout(b, e)), s;
	}
	return (k.cancel = x), (k.flush = C), k;
}
var tz = Kde;
const Ude = Dl(tz);
var Hde = tz,
	Wde = tS,
	qde = "Expected a function";
function Gde(t, e, n) {
	var r = !0,
		i = !0;
	if (typeof t != "function") throw new TypeError(qde);
	return (
		Wde(n) &&
			((r = "leading" in n ? !!n.leading : r),
			(i = "trailing" in n ? !!n.trailing : i)),
		Hde(t, e, { leading: r, maxWait: e, trailing: i })
	);
}
var Yde = Gde;
const Jde = Dl(Yde);
function Q$(t) {
	return typeof t == "object" && t != null && t.nodeType === 1;
}
function eT(t, e) {
	return (!e || t !== "hidden") && t !== "visible" && t !== "clip";
}
function lk(t, e) {
	if (t.clientHeight < t.scrollHeight || t.clientWidth < t.scrollWidth) {
		var n = getComputedStyle(t, null);
		return (
			eT(n.overflowY, e) ||
			eT(n.overflowX, e) ||
			(function (r) {
				var i = (function (o) {
					if (!o.ownerDocument || !o.ownerDocument.defaultView)
						return null;
					try {
						return o.ownerDocument.defaultView.frameElement;
					} catch {
						return null;
					}
				})(r);
				return (
					!!i &&
					(i.clientHeight < r.scrollHeight ||
						i.clientWidth < r.scrollWidth)
				);
			})(t)
		);
	}
	return !1;
}
function w1(t, e, n, r, i, o, s, a) {
	return (o < t && s > e) || (o > t && s < e)
		? 0
		: (o <= t && a <= n) || (s >= e && a >= n)
			? o - t - r
			: (s > e && a < n) || (o < t && a > n)
				? s - e + i
				: 0;
}
var tT = function (t, e) {
	var n = window,
		r = e.scrollMode,
		i = e.block,
		o = e.inline,
		s = e.boundary,
		a = e.skipOverflowHiddenElements,
		l =
			typeof s == "function"
				? s
				: function (Ae) {
						return Ae !== s;
					};
	if (!Q$(t)) throw new TypeError("Invalid target");
	for (
		var u,
			c,
			d = document.scrollingElement || document.documentElement,
			f = [],
			h = t;
		Q$(h) && l(h);

	) {
		if (
			(h =
				(c = (u = h).parentElement) == null
					? u.getRootNode().host || null
					: c) === d
		) {
			f.push(h);
			break;
		}
		(h != null &&
			h === document.body &&
			lk(h) &&
			!lk(document.documentElement)) ||
			(h != null && lk(h, a) && f.push(h));
	}
	for (
		var p = n.visualViewport ? n.visualViewport.width : innerWidth,
			g = n.visualViewport ? n.visualViewport.height : innerHeight,
			v = window.scrollX || pageXOffset,
			b = window.scrollY || pageYOffset,
			y = t.getBoundingClientRect(),
			x = y.height,
			C = y.width,
			k = y.top,
			w = y.right,
			D = y.bottom,
			S = y.left,
			$ =
				i === "start" || i === "nearest"
					? k
					: i === "end"
						? D
						: k + x / 2,
			A = o === "center" ? S + C / 2 : o === "end" ? w : S,
			T = [],
			I = 0;
		I < f.length;
		I++
	) {
		var F = f[I],
			N = F.getBoundingClientRect(),
			O = N.height,
			_ = N.width,
			j = N.top,
			V = N.right,
			K = N.bottom,
			M = N.left;
		if (
			r === "if-needed" &&
			k >= 0 &&
			S >= 0 &&
			D <= g &&
			w <= p &&
			k >= j &&
			D <= K &&
			S >= M &&
			w <= V
		)
			return T;
		var G = getComputedStyle(F),
			H = parseInt(G.borderLeftWidth, 10),
			P = parseInt(G.borderTopWidth, 10),
			q = parseInt(G.borderRightWidth, 10),
			J = parseInt(G.borderBottomWidth, 10),
			Z = 0,
			oe = 0,
			ne = "offsetWidth" in F ? F.offsetWidth - F.clientWidth - H - q : 0,
			de =
				"offsetHeight" in F
					? F.offsetHeight - F.clientHeight - P - J
					: 0,
			se =
				"offsetWidth" in F
					? F.offsetWidth === 0
						? 0
						: _ / F.offsetWidth
					: 0,
			re =
				"offsetHeight" in F
					? F.offsetHeight === 0
						? 0
						: O / F.offsetHeight
					: 0;
		if (d === F)
			(Z =
				i === "start"
					? $
					: i === "end"
						? $ - g
						: i === "nearest"
							? w1(b, b + g, g, P, J, b + $, b + $ + x, x)
							: $ - g / 2),
				(oe =
					o === "start"
						? A
						: o === "center"
							? A - p / 2
							: o === "end"
								? A - p
								: w1(v, v + p, p, H, q, v + A, v + A + C, C)),
				(Z = Math.max(0, Z + b)),
				(oe = Math.max(0, oe + v));
		else {
			(Z =
				i === "start"
					? $ - j - P
					: i === "end"
						? $ - K + J + de
						: i === "nearest"
							? w1(j, K, O, P, J + de, $, $ + x, x)
							: $ - (j + O / 2) + de / 2),
				(oe =
					o === "start"
						? A - M - H
						: o === "center"
							? A - (M + _ / 2) + ne / 2
							: o === "end"
								? A - V + q + ne
								: w1(M, V, _, H, q + ne, A, A + C, C));
			var he = F.scrollLeft,
				ye = F.scrollTop;
			($ +=
				ye -
				(Z = Math.max(
					0,
					Math.min(ye + Z / re, F.scrollHeight - O / re + de),
				))),
				(A +=
					he -
					(oe = Math.max(
						0,
						Math.min(he + oe / se, F.scrollWidth - _ / se + ne),
					)));
		}
		T.push({ el: F, top: Z, left: oe });
	}
	return T;
};
function nz(t) {
	return t === Object(t) && Object.keys(t).length !== 0;
}
function Xde(t, e) {
	e === void 0 && (e = "auto");
	var n = "scrollBehavior" in document.body.style;
	t.forEach(function (r) {
		var i = r.el,
			o = r.top,
			s = r.left;
		i.scroll && n
			? i.scroll({ top: o, left: s, behavior: e })
			: ((i.scrollTop = o), (i.scrollLeft = s));
	});
}
function Zde(t) {
	return t === !1
		? { block: "end", inline: "nearest" }
		: nz(t)
			? t
			: { block: "start", inline: "nearest" };
}
function Qde(t, e) {
	var n = t.isConnected || t.ownerDocument.documentElement.contains(t);
	if (nz(e) && typeof e.behavior == "function")
		return e.behavior(n ? tT(t, e) : []);
	if (n) {
		var r = Zde(e);
		return Xde(tT(t, r), r.behavior);
	}
}
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */ function nT(t) {
	return Object.prototype.toString.call(t) === "[object Object]";
}
function Ar(t) {
	var e, n;
	return nT(t) === !1
		? !1
		: ((e = t.constructor),
			e === void 0
				? !0
				: ((n = e.prototype),
					!(
						nT(n) === !1 || n.hasOwnProperty("isPrototypeOf") === !1
					)));
}
function gs(t) {
	for (
		var e = arguments.length, n = Array(e > 1 ? e - 1 : 0), r = 1;
		r < e;
		r++
	)
		n[r - 1] = arguments[r];
	throw Error(
		"[Immer] minified error nr: " +
			t +
			(n.length
				? " " +
					n
						.map(function (i) {
							return "'" + i + "'";
						})
						.join(",")
				: "") +
			". Find the full error at: https://bit.ly/3cXEKWf",
	);
}
function kd(t) {
	return !!t && !!t[po];
}
function Cd(t) {
	var e;
	return (
		!!t &&
		((function (n) {
			if (!n || typeof n != "object") return !1;
			var r = Object.getPrototypeOf(n);
			if (r === null) return !0;
			var i =
				Object.hasOwnProperty.call(r, "constructor") && r.constructor;
			return (
				i === Object ||
				(typeof i == "function" && Function.toString.call(i) === afe)
			);
		})(t) ||
			Array.isArray(t) ||
			!!t[cT] ||
			!!(!((e = t.constructor) === null || e === void 0) && e[cT]) ||
			nS(t) ||
			rS(t))
	);
}
function ng(t, e, n) {
	n === void 0 && (n = !1),
		tp(t) === 0
			? (n ? Object.keys : lS)(t).forEach(function (r) {
					(n && typeof r == "symbol") || e(r, t[r], t);
				})
			: t.forEach(function (r, i) {
					return e(i, r, t);
				});
}
function tp(t) {
	var e = t[po];
	return e
		? e.i > 3
			? e.i - 4
			: e.i
		: Array.isArray(t)
			? 1
			: nS(t)
				? 2
				: rS(t)
					? 3
					: 0;
}
function Nw(t, e) {
	return tp(t) === 2 ? t.has(e) : Object.prototype.hasOwnProperty.call(t, e);
}
function efe(t, e) {
	return tp(t) === 2 ? t.get(e) : t[e];
}
function rz(t, e, n) {
	var r = tp(t);
	r === 2 ? t.set(e, n) : r === 3 ? t.add(n) : (t[e] = n);
}
function tfe(t, e) {
	return t === e ? t !== 0 || 1 / t == 1 / e : t != t && e != e;
}
function nS(t) {
	return ofe && t instanceof Map;
}
function rS(t) {
	return sfe && t instanceof Set;
}
function gc(t) {
	return t.o || t.t;
}
function iS(t) {
	if (Array.isArray(t)) return Array.prototype.slice.call(t);
	var e = lfe(t);
	delete e[po];
	for (var n = lS(e), r = 0; r < n.length; r++) {
		var i = n[r],
			o = e[i];
		o.writable === !1 && ((o.writable = !0), (o.configurable = !0)),
			(o.get || o.set) &&
				(e[i] = {
					configurable: !0,
					writable: !0,
					enumerable: o.enumerable,
					value: t[i],
				});
	}
	return Object.create(Object.getPrototypeOf(t), e);
}
function oS(t, e) {
	return (
		e === void 0 && (e = !1),
		sS(t) ||
			kd(t) ||
			!Cd(t) ||
			(tp(t) > 1 && (t.set = t.add = t.clear = t.delete = nfe),
			Object.freeze(t),
			e &&
				ng(
					t,
					function (n, r) {
						return oS(r, !0);
					},
					!0,
				)),
		t
	);
}
function nfe() {
	gs(2);
}
function sS(t) {
	return t == null || typeof t != "object" || Object.isFrozen(t);
}
function oa(t) {
	var e = ufe[t];
	return e || gs(18, t), e;
}
function rT() {
	return rg;
}
function uk(t, e) {
	e && (oa("Patches"), (t.u = []), (t.s = []), (t.v = e));
}
function _v(t) {
	Rw(t), t.p.forEach(rfe), (t.p = null);
}
function Rw(t) {
	t === rg && (rg = t.l);
}
function iT(t) {
	return (rg = { p: [], l: rg, h: t, m: !0, _: 0 });
}
function rfe(t) {
	var e = t[po];
	e.i === 0 || e.i === 1 ? e.j() : (e.g = !0);
}
function ck(t, e) {
	e._ = e.p.length;
	var n = e.p[0],
		r = t !== void 0 && t !== n;
	return (
		e.h.O || oa("ES5").S(e, t, r),
		r
			? (n[po].P && (_v(e), gs(4)),
				Cd(t) && ((t = zv(e, t)), e.l || Lv(e, t)),
				e.u && oa("Patches").M(n[po].t, t, e.u, e.s))
			: (t = zv(e, n, [])),
		_v(e),
		e.u && e.v(e.u, e.s),
		t !== iz ? t : void 0
	);
}
function zv(t, e, n) {
	if (sS(e)) return e;
	var r = e[po];
	if (!r)
		return (
			ng(
				e,
				function (a, l) {
					return oT(t, r, e, a, l, n);
				},
				!0,
			),
			e
		);
	if (r.A !== t) return e;
	if (!r.P) return Lv(t, r.t, !0), r.t;
	if (!r.I) {
		(r.I = !0), r.A._--;
		var i = r.i === 4 || r.i === 5 ? (r.o = iS(r.k)) : r.o,
			o = i,
			s = !1;
		r.i === 3 && ((o = new Set(i)), i.clear(), (s = !0)),
			ng(o, function (a, l) {
				return oT(t, r, i, a, l, n, s);
			}),
			Lv(t, i, !1),
			n && t.u && oa("Patches").N(r, n, t.u, t.s);
	}
	return r.o;
}
function oT(t, e, n, r, i, o, s) {
	if (kd(i)) {
		var a = zv(
			t,
			i,
			o && e && e.i !== 3 && !Nw(e.R, r) ? o.concat(r) : void 0,
		);
		if ((rz(n, r, a), !kd(a))) return;
		t.m = !1;
	} else s && n.add(i);
	if (Cd(i) && !sS(i)) {
		if (!t.h.D && t._ < 1) return;
		zv(t, i), (e && e.A.l) || Lv(t, i);
	}
}
function Lv(t, e, n) {
	n === void 0 && (n = !1), !t.l && t.h.D && t.m && oS(e, n);
}
function dk(t, e) {
	var n = t[po];
	return (n ? gc(n) : t)[e];
}
function sT(t, e) {
	if (e in t)
		for (var n = Object.getPrototypeOf(t); n; ) {
			var r = Object.getOwnPropertyDescriptor(n, e);
			if (r) return r;
			n = Object.getPrototypeOf(n);
		}
}
function Ow(t) {
	t.P || ((t.P = !0), t.l && Ow(t.l));
}
function fk(t) {
	t.o || (t.o = iS(t.t));
}
function Mw(t, e, n) {
	var r = nS(e)
		? oa("MapSet").F(e, n)
		: rS(e)
			? oa("MapSet").T(e, n)
			: t.O
				? (function (i, o) {
						var s = Array.isArray(i),
							a = {
								i: s ? 1 : 0,
								A: o ? o.A : rT(),
								P: !1,
								I: !1,
								R: {},
								l: o,
								t: i,
								k: null,
								o: null,
								j: null,
								C: !1,
							},
							l = a,
							u = jw;
						s && ((l = [a]), (u = tm));
						var c = Proxy.revocable(l, u),
							d = c.revoke,
							f = c.proxy;
						return (a.k = f), (a.j = d), f;
					})(e, n)
				: oa("ES5").J(e, n);
	return (n ? n.A : rT()).p.push(r), r;
}
function ife(t) {
	return (
		kd(t) || gs(22, t),
		(function e(n) {
			if (!Cd(n)) return n;
			var r,
				i = n[po],
				o = tp(n);
			if (i) {
				if (!i.P && (i.i < 4 || !oa("ES5").K(i))) return i.t;
				(i.I = !0), (r = aT(n, o)), (i.I = !1);
			} else r = aT(n, o);
			return (
				ng(r, function (s, a) {
					(i && efe(i.t, s) === a) || rz(r, s, e(a));
				}),
				o === 3 ? new Set(r) : r
			);
		})(t)
	);
}
function aT(t, e) {
	switch (e) {
		case 2:
			return new Map(t);
		case 3:
			return Array.from(t);
	}
	return iS(t);
}
var lT,
	rg,
	aS = typeof Symbol < "u" && typeof Symbol("x") == "symbol",
	ofe = typeof Map < "u",
	sfe = typeof Set < "u",
	uT =
		typeof Proxy < "u" &&
		Proxy.revocable !== void 0 &&
		typeof Reflect < "u",
	iz = aS
		? Symbol.for("immer-nothing")
		: (((lT = {})["immer-nothing"] = !0), lT),
	cT = aS ? Symbol.for("immer-draftable") : "__$immer_draftable",
	po = aS ? Symbol.for("immer-state") : "__$immer_state",
	afe = "" + Object.prototype.constructor,
	lS =
		typeof Reflect < "u" && Reflect.ownKeys
			? Reflect.ownKeys
			: Object.getOwnPropertySymbols !== void 0
				? function (t) {
						return Object.getOwnPropertyNames(t).concat(
							Object.getOwnPropertySymbols(t),
						);
					}
				: Object.getOwnPropertyNames,
	lfe =
		Object.getOwnPropertyDescriptors ||
		function (t) {
			var e = {};
			return (
				lS(t).forEach(function (n) {
					e[n] = Object.getOwnPropertyDescriptor(t, n);
				}),
				e
			);
		},
	ufe = {},
	jw = {
		get: function (t, e) {
			if (e === po) return t;
			var n = gc(t);
			if (!Nw(n, e))
				return (function (i, o, s) {
					var a,
						l = sT(o, s);
					return l
						? "value" in l
							? l.value
							: (a = l.get) === null || a === void 0
								? void 0
								: a.call(i.k)
						: void 0;
				})(t, n, e);
			var r = n[e];
			return t.I || !Cd(r)
				? r
				: r === dk(t.t, e)
					? (fk(t), (t.o[e] = Mw(t.A.h, r, t)))
					: r;
		},
		has: function (t, e) {
			return e in gc(t);
		},
		ownKeys: function (t) {
			return Reflect.ownKeys(gc(t));
		},
		set: function (t, e, n) {
			var r = sT(gc(t), e);
			if (r != null && r.set) return r.set.call(t.k, n), !0;
			if (!t.P) {
				var i = dk(gc(t), e),
					o = i == null ? void 0 : i[po];
				if (o && o.t === n) return (t.o[e] = n), (t.R[e] = !1), !0;
				if (tfe(n, i) && (n !== void 0 || Nw(t.t, e))) return !0;
				fk(t), Ow(t);
			}
			return (
				(t.o[e] === n && (n !== void 0 || e in t.o)) ||
					(Number.isNaN(n) && Number.isNaN(t.o[e])) ||
					((t.o[e] = n), (t.R[e] = !0)),
				!0
			);
		},
		deleteProperty: function (t, e) {
			return (
				dk(t.t, e) !== void 0 || e in t.t
					? ((t.R[e] = !1), fk(t), Ow(t))
					: delete t.R[e],
				t.o && delete t.o[e],
				!0
			);
		},
		getOwnPropertyDescriptor: function (t, e) {
			var n = gc(t),
				r = Reflect.getOwnPropertyDescriptor(n, e);
			return (
				r && {
					writable: !0,
					configurable: t.i !== 1 || e !== "length",
					enumerable: r.enumerable,
					value: n[e],
				}
			);
		},
		defineProperty: function () {
			gs(11);
		},
		getPrototypeOf: function (t) {
			return Object.getPrototypeOf(t.t);
		},
		setPrototypeOf: function () {
			gs(12);
		},
	},
	tm = {};
ng(jw, function (t, e) {
	tm[t] = function () {
		return (arguments[0] = arguments[0][0]), e.apply(this, arguments);
	};
}),
	(tm.deleteProperty = function (t, e) {
		return tm.set.call(this, t, e, void 0);
	}),
	(tm.set = function (t, e, n) {
		return jw.set.call(this, t[0], e, n, t[0]);
	});
var cfe = (function () {
		function t(n) {
			var r = this;
			(this.O = uT),
				(this.D = !0),
				(this.produce = function (i, o, s) {
					if (typeof i == "function" && typeof o != "function") {
						var a = o;
						o = i;
						var l = r;
						return function (g) {
							var v = this;
							g === void 0 && (g = a);
							for (
								var b = arguments.length,
									y = Array(b > 1 ? b - 1 : 0),
									x = 1;
								x < b;
								x++
							)
								y[x - 1] = arguments[x];
							return l.produce(g, function (C) {
								var k;
								return (k = o).call.apply(k, [v, C].concat(y));
							});
						};
					}
					var u;
					if (
						(typeof o != "function" && gs(6),
						s !== void 0 && typeof s != "function" && gs(7),
						Cd(i))
					) {
						var c = iT(r),
							d = Mw(r, i, void 0),
							f = !0;
						try {
							(u = o(d)), (f = !1);
						} finally {
							f ? _v(c) : Rw(c);
						}
						return typeof Promise < "u" && u instanceof Promise
							? u.then(
									function (g) {
										return uk(c, s), ck(g, c);
									},
									function (g) {
										throw (_v(c), g);
									},
								)
							: (uk(c, s), ck(u, c));
					}
					if (!i || typeof i != "object") {
						if (
							((u = o(i)) === void 0 && (u = i),
							u === iz && (u = void 0),
							r.D && oS(u, !0),
							s)
						) {
							var h = [],
								p = [];
							oa("Patches").M(i, u, h, p), s(h, p);
						}
						return u;
					}
					gs(21, i);
				}),
				(this.produceWithPatches = function (i, o) {
					if (typeof i == "function")
						return function (u) {
							for (
								var c = arguments.length,
									d = Array(c > 1 ? c - 1 : 0),
									f = 1;
								f < c;
								f++
							)
								d[f - 1] = arguments[f];
							return r.produceWithPatches(u, function (h) {
								return i.apply(void 0, [h].concat(d));
							});
						};
					var s,
						a,
						l = r.produce(i, o, function (u, c) {
							(s = u), (a = c);
						});
					return typeof Promise < "u" && l instanceof Promise
						? l.then(function (u) {
								return [u, s, a];
							})
						: [l, s, a];
				}),
				typeof (n == null ? void 0 : n.useProxies) == "boolean" &&
					this.setUseProxies(n.useProxies),
				typeof (n == null ? void 0 : n.autoFreeze) == "boolean" &&
					this.setAutoFreeze(n.autoFreeze);
		}
		var e = t.prototype;
		return (
			(e.createDraft = function (n) {
				Cd(n) || gs(8), kd(n) && (n = ife(n));
				var r = iT(this),
					i = Mw(this, n, void 0);
				return (i[po].C = !0), Rw(r), i;
			}),
			(e.finishDraft = function (n, r) {
				var i = n && n[po],
					o = i.A;
				return uk(o, r), ck(void 0, o);
			}),
			(e.setAutoFreeze = function (n) {
				this.D = n;
			}),
			(e.setUseProxies = function (n) {
				n && !uT && gs(20), (this.O = n);
			}),
			(e.applyPatches = function (n, r) {
				var i;
				for (i = r.length - 1; i >= 0; i--) {
					var o = r[i];
					if (o.path.length === 0 && o.op === "replace") {
						n = o.value;
						break;
					}
				}
				i > -1 && (r = r.slice(i + 1));
				var s = oa("Patches").$;
				return kd(n)
					? s(n, r)
					: this.produce(n, function (a) {
							return s(a, r);
						});
			}),
			t
		);
	})(),
	mo = new cfe(),
	uS = mo.produce;
mo.produceWithPatches.bind(mo);
mo.setAutoFreeze.bind(mo);
mo.setUseProxies.bind(mo);
mo.applyPatches.bind(mo);
var dT = mo.createDraft.bind(mo),
	fT = mo.finishDraft.bind(mo);
function Sa(t, e, n) {
	return (
		e in t
			? Object.defineProperty(t, e, {
					value: n,
					enumerable: !0,
					configurable: !0,
					writable: !0,
				})
			: (t[e] = n),
		t
	);
}
var Vv = new WeakMap(),
	Kv = new WeakMap(),
	Fp = new WeakMap(),
	hT = new WeakMap(),
	pT = new WeakMap(),
	mT = new WeakMap(),
	gT = new WeakMap();
function bT(t, e) {
	var n = Object.keys(t);
	if (Object.getOwnPropertySymbols) {
		var r = Object.getOwnPropertySymbols(t);
		e &&
			(r = r.filter(function (i) {
				return Object.getOwnPropertyDescriptor(t, i).enumerable;
			})),
			n.push.apply(n, r);
	}
	return n;
}
function E1(t) {
	for (var e = 1; e < arguments.length; e++) {
		var n = arguments[e] != null ? arguments[e] : {};
		e % 2
			? bT(Object(n), !0).forEach(function (r) {
					Sa(t, r, n[r]);
				})
			: Object.getOwnPropertyDescriptors
				? Object.defineProperties(
						t,
						Object.getOwnPropertyDescriptors(n),
					)
				: bT(Object(n)).forEach(function (r) {
						Object.defineProperty(
							t,
							r,
							Object.getOwnPropertyDescriptor(n, r),
						);
					});
	}
	return t;
}
var oz = () => {
	var t = {
		children: [],
		operations: [],
		selection: null,
		marks: null,
		isInline: () => !1,
		isVoid: () => !1,
		markableVoid: () => !1,
		onChange: () => {},
		apply: (e) => {
			for (var n of R.pathRefs(t)) zfe.transform(n, e);
			for (var r of R.pointRefs(t)) Lfe.transform(r, e);
			for (var i of R.rangeRefs(t)) Ufe.transform(i, e);
			var o = Vv.get(t) || [],
				s = Kv.get(t) || new Set(),
				a,
				l,
				u = (p) => {
					if (p) {
						var g = p.join(",");
						l.has(g) || (l.add(g), a.push(p));
					}
				};
			if (Y.operationCanTransformPath(e)) {
				(a = []), (l = new Set());
				for (var c of o) {
					var d = Y.transform(c, e);
					u(d);
				}
			} else (a = o), (l = s);
			var f = t.getDirtyPaths(e);
			for (var h of f) u(h);
			Vv.set(t, a),
				Kv.set(t, l),
				W.transform(t, e),
				t.operations.push(e),
				R.normalize(t, { operation: e }),
				e.type === "set_selection" && (t.marks = null),
				Fp.get(t) ||
					(Fp.set(t, !0),
					Promise.resolve().then(() => {
						Fp.set(t, !1),
							t.onChange({ operation: e }),
							(t.operations = []);
					}));
		},
		addMark: (e, n) => {
			var { selection: r, markableVoid: i } = t;
			if (r) {
				var o = (f, h) => {
						if (!Be.isText(f)) return !1;
						var [p, g] = R.parent(t, h);
						return !t.isVoid(p) || t.markableVoid(p);
					},
					s = ie.isExpanded(r),
					a = !1;
				if (!s) {
					var [l, u] = R.node(t, r);
					if (l && o(l, u)) {
						var [c] = R.parent(t, u);
						a = c && t.markableVoid(c);
					}
				}
				if (s || a)
					W.setNodes(
						t,
						{ [e]: n },
						{ match: o, split: !0, voids: !0 },
					);
				else {
					var d = E1(E1({}, R.marks(t) || {}), {}, { [e]: n });
					(t.marks = d), Fp.get(t) || t.onChange();
				}
			}
		},
		deleteBackward: (e) => {
			var { selection: n } = t;
			n && ie.isCollapsed(n) && W.delete(t, { unit: e, reverse: !0 });
		},
		deleteForward: (e) => {
			var { selection: n } = t;
			n && ie.isCollapsed(n) && W.delete(t, { unit: e });
		},
		deleteFragment: (e) => {
			var { selection: n } = t;
			n && ie.isExpanded(n) && W.delete(t, { reverse: e === "backward" });
		},
		getFragment: () => {
			var { selection: e } = t;
			return e ? pe.fragment(t, e) : [];
		},
		insertBreak: () => {
			W.splitNodes(t, { always: !0 });
		},
		insertSoftBreak: () => {
			W.splitNodes(t, { always: !0 });
		},
		insertFragment: (e) => {
			W.insertFragment(t, e);
		},
		insertNode: (e) => {
			W.insertNodes(t, e);
		},
		insertText: (e) => {
			var { selection: n, marks: r } = t;
			if (n) {
				if (r) {
					var i = E1({ text: e }, r);
					W.insertNodes(t, i);
				} else W.insertText(t, e);
				t.marks = null;
			}
		},
		normalizeNode: (e) => {
			var [n, r] = e;
			if (!Be.isText(n)) {
				if ($e.isElement(n) && n.children.length === 0) {
					var i = { text: "" };
					W.insertNodes(t, i, { at: r.concat(0), voids: !0 });
					return;
				}
				for (
					var o = R.isEditor(n)
							? !1
							: $e.isElement(n) &&
								(t.isInline(n) ||
									n.children.length === 0 ||
									Be.isText(n.children[0]) ||
									t.isInline(n.children[0])),
						s = 0,
						a = 0;
					a < n.children.length;
					a++, s++
				) {
					var l = pe.get(t, r);
					if (!Be.isText(l)) {
						var u = n.children[a],
							c = l.children[s - 1],
							d = a === n.children.length - 1,
							f =
								Be.isText(u) ||
								($e.isElement(u) && t.isInline(u));
						if (f !== o)
							W.removeNodes(t, { at: r.concat(s), voids: !0 }),
								s--;
						else if ($e.isElement(u)) {
							if (t.isInline(u)) {
								if (c == null || !Be.isText(c)) {
									var h = { text: "" };
									W.insertNodes(t, h, {
										at: r.concat(s),
										voids: !0,
									}),
										s++;
								} else if (d) {
									var p = { text: "" };
									W.insertNodes(t, p, {
										at: r.concat(s + 1),
										voids: !0,
									}),
										s++;
								}
							}
						} else
							c != null &&
								Be.isText(c) &&
								(Be.equals(u, c, { loose: !0 })
									? (W.mergeNodes(t, {
											at: r.concat(s),
											voids: !0,
										}),
										s--)
									: c.text === ""
										? (W.removeNodes(t, {
												at: r.concat(s - 1),
												voids: !0,
											}),
											s--)
										: u.text === "" &&
											(W.removeNodes(t, {
												at: r.concat(s),
												voids: !0,
											}),
											s--));
					}
				}
			}
		},
		removeMark: (e) => {
			var { selection: n } = t;
			if (n) {
				var r = (c, d) => {
						if (!Be.isText(c)) return !1;
						var [f, h] = R.parent(t, d);
						return !t.isVoid(f) || t.markableVoid(f);
					},
					i = ie.isExpanded(n),
					o = !1;
				if (!i) {
					var [s, a] = R.node(t, n);
					if (s && r(s, a)) {
						var [l] = R.parent(t, a);
						o = l && t.markableVoid(l);
					}
				}
				if (i || o)
					W.unsetNodes(t, e, { match: r, split: !0, voids: !0 });
				else {
					var u = E1({}, R.marks(t) || {});
					delete u[e], (t.marks = u), Fp.get(t) || t.onChange();
				}
			}
		},
		getDirtyPaths: (e) => {
			switch (e.type) {
				case "insert_text":
				case "remove_text":
				case "set_node": {
					var { path: n } = e;
					return Y.levels(n);
				}
				case "insert_node": {
					var { node: r, path: i } = e,
						o = Y.levels(i),
						s = Be.isText(r)
							? []
							: Array.from(pe.nodes(r), (A) => {
									var [, T] = A;
									return i.concat(T);
								});
					return [...o, ...s];
				}
				case "merge_node": {
					var { path: a } = e,
						l = Y.ancestors(a),
						u = Y.previous(a);
					return [...l, u];
				}
				case "move_node": {
					var { path: c, newPath: d } = e;
					if (Y.equals(c, d)) return [];
					var f = [],
						h = [];
					for (var p of Y.ancestors(c)) {
						var g = Y.transform(p, e);
						f.push(g);
					}
					for (var v of Y.ancestors(d)) {
						var b = Y.transform(v, e);
						h.push(b);
					}
					var y = h[h.length - 1],
						x = d[d.length - 1],
						C = y.concat(x);
					return [...f, ...h, C];
				}
				case "remove_node": {
					var { path: k } = e,
						w = Y.ancestors(k);
					return [...w];
				}
				case "split_node": {
					var { path: D } = e,
						S = Y.levels(D),
						$ = Y.next(D);
					return [...S, $];
				}
				default:
					return [];
			}
		},
		shouldNormalize: (e) => {
			var { iteration: n, initialDirtyPathsLength: r } = e,
				i = r * 42;
			if (n > i)
				throw new Error(
					"Could not completely normalize the editor after ".concat(
						i,
						" iterations! This is usually due to incorrect normalization logic that leaves a node in an invalid state.",
					),
				);
			return !0;
		},
	};
	return t;
};
function dfe(t, e) {
	if (t == null) return {};
	var n = {},
		r = Object.keys(t),
		i,
		o;
	for (o = 0; o < r.length; o++)
		(i = r[o]), !(e.indexOf(i) >= 0) && (n[i] = t[i]);
	return n;
}
function vl(t, e) {
	if (t == null) return {};
	var n = dfe(t, e),
		r,
		i;
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(t);
		for (i = 0; i < o.length; i++)
			(r = o[i]),
				!(e.indexOf(r) >= 0) &&
					Object.prototype.propertyIsEnumerable.call(t, r) &&
					(n[r] = t[r]);
	}
	return n;
}
var cS = function (e) {
		var n =
				arguments.length > 1 && arguments[1] !== void 0
					? arguments[1]
					: !1,
			r = !n,
			i = n ? bfe(e) : e,
			o = dt.None,
			s = dt.None,
			a = 0,
			l = null,
			u = null;
		for (var c of i) {
			var d = c.codePointAt(0);
			if (!d) break;
			var f = Tfe(c, d);
			if (
				(([o, s] = r ? [s, f] : [f, o]),
				(zf(o, dt.ZWJ) &&
					zf(s, dt.ExtPict) &&
					(r
						? (l = vT(e.substring(0, a)))
						: (l = vT(e.substring(0, e.length - a))),
					!l)) ||
					(zf(o, dt.RI) &&
						zf(s, dt.RI) &&
						(u !== null
							? (u = !u)
							: r
								? (u = !0)
								: (u = Nfe(e.substring(0, e.length - a))),
						!u)) ||
					(o !== dt.None && s !== dt.None && Ife(o, s)))
			)
				break;
			a += c.length;
		}
		return a || 1;
	},
	ffe = /\s/,
	hfe =
		/[\u0021-\u0023\u0025-\u002A\u002C-\u002F\u003A\u003B\u003F\u0040\u005B-\u005D\u005F\u007B\u007D\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E3B\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]/,
	pfe = /['\u2018\u2019]/,
	mfe = function (e) {
		for (
			var n =
					arguments.length > 1 && arguments[1] !== void 0
						? arguments[1]
						: !1,
				r = 0,
				i = !1;
			e.length > 0;

		) {
			var o = cS(e, n),
				[s, a] = dS(e, o, n);
			if (gfe(s, a, n)) (i = !0), (r += o);
			else if (!i) r += o;
			else break;
			e = a;
		}
		return r;
	},
	dS = (t, e, n) => {
		if (n) {
			var r = t.length - e;
			return [t.slice(r, t.length), t.slice(0, r)];
		}
		return [t.slice(0, e), t.slice(e)];
	},
	gfe = function t(e, n) {
		var r =
			arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
		if (ffe.test(e)) return !1;
		if (pfe.test(e)) {
			var i = cS(n, r),
				[o, s] = dS(n, i, r);
			if (t(o, s, r)) return !0;
		}
		return !hfe.test(e);
	},
	bfe = function* (e) {
		for (var n = e.length - 1, r = 0; r < e.length; r++) {
			var i = e.charAt(n - r);
			if (yfe(i.charCodeAt(0))) {
				var o = e.charAt(n - r - 1);
				if (vfe(o.charCodeAt(0))) {
					yield o + i, r++;
					continue;
				}
			}
			yield i;
		}
	},
	vfe = (t) => t >= 55296 && t <= 56319,
	yfe = (t) => t >= 56320 && t <= 57343,
	dt;
(function (t) {
	(t[(t.None = 0)] = "None"),
		(t[(t.Extend = 1)] = "Extend"),
		(t[(t.ZWJ = 2)] = "ZWJ"),
		(t[(t.RI = 4)] = "RI"),
		(t[(t.Prepend = 8)] = "Prepend"),
		(t[(t.SpacingMark = 16)] = "SpacingMark"),
		(t[(t.L = 32)] = "L"),
		(t[(t.V = 64)] = "V"),
		(t[(t.T = 128)] = "T"),
		(t[(t.LV = 256)] = "LV"),
		(t[(t.LVT = 512)] = "LVT"),
		(t[(t.ExtPict = 1024)] = "ExtPict"),
		(t[(t.Any = 2048)] = "Any");
})(dt || (dt = {}));
var xfe =
		/^(?:[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D3-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09BE\u09C1-\u09C4\u09CD\u09D7\u09E2\u09E3\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3E\u0B3F\u0B41-\u0B44\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B82\u0BBE\u0BC0\u0BCD\u0BD7\u0C00\u0C04\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CBF\u0CC2\u0CC6\u0CCC\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D3E\u0D41-\u0D44\u0D4D\u0D57\u0D62\u0D63\u0D81\u0DCA\u0DCF\u0DD2-\u0DD4\u0DD6\u0DDF\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1AC0\u1B00-\u1B03\u1B34-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF9\u1DFB-\u1DFF\u200C\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA82C\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFF9E\uFF9F]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD803[\uDD24-\uDD27\uDEAB\uDEAC\uDF46-\uDF50]|\uD804[\uDC01\uDC38-\uDC46\uDC7F-\uDC81\uDCB3-\uDCB6\uDCB9\uDCBA\uDD00-\uDD02\uDD27-\uDD2B\uDD2D-\uDD34\uDD73\uDD80\uDD81\uDDB6-\uDDBE\uDDC9-\uDDCC\uDDCF\uDE2F-\uDE31\uDE34\uDE36\uDE37\uDE3E\uDEDF\uDEE3-\uDEEA\uDF00\uDF01\uDF3B\uDF3C\uDF3E\uDF40\uDF57\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC38-\uDC3F\uDC42-\uDC44\uDC46\uDC5E\uDCB0\uDCB3-\uDCB8\uDCBA\uDCBD\uDCBF\uDCC0\uDCC2\uDCC3\uDDAF\uDDB2-\uDDB5\uDDBC\uDDBD\uDDBF\uDDC0\uDDDC\uDDDD\uDE33-\uDE3A\uDE3D\uDE3F\uDE40\uDEAB\uDEAD\uDEB0-\uDEB5\uDEB7\uDF1D-\uDF1F\uDF22-\uDF25\uDF27-\uDF2B]|\uD806[\uDC2F-\uDC37\uDC39\uDC3A\uDD30\uDD3B\uDD3C\uDD3E\uDD43\uDDD4-\uDDD7\uDDDA\uDDDB\uDDE0\uDE01-\uDE0A\uDE33-\uDE38\uDE3B-\uDE3E\uDE47\uDE51-\uDE56\uDE59-\uDE5B\uDE8A-\uDE96\uDE98\uDE99]|\uD807[\uDC30-\uDC36\uDC38-\uDC3D\uDC3F\uDC92-\uDCA7\uDCAA-\uDCB0\uDCB2\uDCB3\uDCB5\uDCB6\uDD31-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD45\uDD47\uDD90\uDD91\uDD95\uDD97\uDEF3\uDEF4]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF4F\uDF8F-\uDF92\uDFE4]|\uD82F[\uDC9D\uDC9E]|\uD834[\uDD65\uDD67-\uDD69\uDD6E-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A\uDD30-\uDD36\uDEEC-\uDEEF]|\uD83A[\uDCD0-\uDCD6\uDD44-\uDD4A]|\uD83C[\uDFFB-\uDFFF]|\uDB40[\uDC20-\uDC7F\uDD00-\uDDEF])$/,
	kfe =
		/^(?:[\u0600-\u0605\u06DD\u070F\u0890\u0891\u08E2\u0D4E]|\uD804[\uDCBD\uDCCD\uDDC2\uDDC3]|\uD806[\uDD3F\uDD41\uDE3A\uDE84-\uDE89]|\uD807\uDD46)$/,
	Cfe =
		/^(?:[\u0903\u093B\u093E-\u0940\u0949-\u094C\u094E\u094F\u0982\u0983\u09BF\u09C0\u09C7\u09C8\u09CB\u09CC\u0A03\u0A3E-\u0A40\u0A83\u0ABE-\u0AC0\u0AC9\u0ACB\u0ACC\u0B02\u0B03\u0B40\u0B47\u0B48\u0B4B\u0B4C\u0BBF\u0BC1\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCC\u0C01-\u0C03\u0C41-\u0C44\u0C82\u0C83\u0CBE\u0CC0\u0CC1\u0CC3\u0CC4\u0CC7\u0CC8\u0CCA\u0CCB\u0D02\u0D03\u0D3F\u0D40\u0D46-\u0D48\u0D4A-\u0D4C\u0D82\u0D83\u0DD0\u0DD1\u0DD8-\u0DDE\u0DF2\u0DF3\u0E33\u0EB3\u0F3E\u0F3F\u0F7F\u1031\u103B\u103C\u1056\u1057\u1084\u1715\u1734\u17B6\u17BE-\u17C5\u17C7\u17C8\u1923-\u1926\u1929-\u192B\u1930\u1931\u1933-\u1938\u1A19\u1A1A\u1A55\u1A57\u1A6D-\u1A72\u1B04\u1B3B\u1B3D-\u1B41\u1B43\u1B44\u1B82\u1BA1\u1BA6\u1BA7\u1BAA\u1BE7\u1BEA-\u1BEC\u1BEE\u1BF2\u1BF3\u1C24-\u1C2B\u1C34\u1C35\u1CE1\u1CF7\uA823\uA824\uA827\uA880\uA881\uA8B4-\uA8C3\uA952\uA953\uA983\uA9B4\uA9B5\uA9BA\uA9BB\uA9BE-\uA9C0\uAA2F\uAA30\uAA33\uAA34\uAA4D\uAAEB\uAAEE\uAAEF\uAAF5\uABE3\uABE4\uABE6\uABE7\uABE9\uABEA\uABEC]|\uD804[\uDC00\uDC02\uDC82\uDCB0-\uDCB2\uDCB7\uDCB8\uDD2C\uDD45\uDD46\uDD82\uDDB3-\uDDB5\uDDBF\uDDC0\uDDCE\uDE2C-\uDE2E\uDE32\uDE33\uDE35\uDEE0-\uDEE2\uDF02\uDF03\uDF3F\uDF41-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF62\uDF63]|\uD805[\uDC35-\uDC37\uDC40\uDC41\uDC45\uDCB1\uDCB2\uDCB9\uDCBB\uDCBC\uDCBE\uDCC1\uDDB0\uDDB1\uDDB8-\uDDBB\uDDBE\uDE30-\uDE32\uDE3B\uDE3C\uDE3E\uDEAC\uDEAE\uDEAF\uDEB6\uDF26]|\uD806[\uDC2C-\uDC2E\uDC38\uDD31-\uDD35\uDD37\uDD38\uDD3D\uDD40\uDD42\uDDD1-\uDDD3\uDDDC-\uDDDF\uDDE4\uDE39\uDE57\uDE58\uDE97]|\uD807[\uDC2F\uDC3E\uDCA9\uDCB1\uDCB4\uDD8A-\uDD8E\uDD93\uDD94\uDD96\uDEF5\uDEF6]|\uD81B[\uDF51-\uDF87\uDFF0\uDFF1]|\uD834[\uDD66\uDD6D])$/,
	wfe = /^[\u1100-\u115F\uA960-\uA97C]$/,
	Efe = /^[\u1160-\u11A7\uD7B0-\uD7C6]$/,
	Dfe = /^[\u11A8-\u11FF\uD7CB-\uD7FB]$/,
	Sfe =
		/^[\uAC00\uAC1C\uAC38\uAC54\uAC70\uAC8C\uACA8\uACC4\uACE0\uACFC\uAD18\uAD34\uAD50\uAD6C\uAD88\uADA4\uADC0\uADDC\uADF8\uAE14\uAE30\uAE4C\uAE68\uAE84\uAEA0\uAEBC\uAED8\uAEF4\uAF10\uAF2C\uAF48\uAF64\uAF80\uAF9C\uAFB8\uAFD4\uAFF0\uB00C\uB028\uB044\uB060\uB07C\uB098\uB0B4\uB0D0\uB0EC\uB108\uB124\uB140\uB15C\uB178\uB194\uB1B0\uB1CC\uB1E8\uB204\uB220\uB23C\uB258\uB274\uB290\uB2AC\uB2C8\uB2E4\uB300\uB31C\uB338\uB354\uB370\uB38C\uB3A8\uB3C4\uB3E0\uB3FC\uB418\uB434\uB450\uB46C\uB488\uB4A4\uB4C0\uB4DC\uB4F8\uB514\uB530\uB54C\uB568\uB584\uB5A0\uB5BC\uB5D8\uB5F4\uB610\uB62C\uB648\uB664\uB680\uB69C\uB6B8\uB6D4\uB6F0\uB70C\uB728\uB744\uB760\uB77C\uB798\uB7B4\uB7D0\uB7EC\uB808\uB824\uB840\uB85C\uB878\uB894\uB8B0\uB8CC\uB8E8\uB904\uB920\uB93C\uB958\uB974\uB990\uB9AC\uB9C8\uB9E4\uBA00\uBA1C\uBA38\uBA54\uBA70\uBA8C\uBAA8\uBAC4\uBAE0\uBAFC\uBB18\uBB34\uBB50\uBB6C\uBB88\uBBA4\uBBC0\uBBDC\uBBF8\uBC14\uBC30\uBC4C\uBC68\uBC84\uBCA0\uBCBC\uBCD8\uBCF4\uBD10\uBD2C\uBD48\uBD64\uBD80\uBD9C\uBDB8\uBDD4\uBDF0\uBE0C\uBE28\uBE44\uBE60\uBE7C\uBE98\uBEB4\uBED0\uBEEC\uBF08\uBF24\uBF40\uBF5C\uBF78\uBF94\uBFB0\uBFCC\uBFE8\uC004\uC020\uC03C\uC058\uC074\uC090\uC0AC\uC0C8\uC0E4\uC100\uC11C\uC138\uC154\uC170\uC18C\uC1A8\uC1C4\uC1E0\uC1FC\uC218\uC234\uC250\uC26C\uC288\uC2A4\uC2C0\uC2DC\uC2F8\uC314\uC330\uC34C\uC368\uC384\uC3A0\uC3BC\uC3D8\uC3F4\uC410\uC42C\uC448\uC464\uC480\uC49C\uC4B8\uC4D4\uC4F0\uC50C\uC528\uC544\uC560\uC57C\uC598\uC5B4\uC5D0\uC5EC\uC608\uC624\uC640\uC65C\uC678\uC694\uC6B0\uC6CC\uC6E8\uC704\uC720\uC73C\uC758\uC774\uC790\uC7AC\uC7C8\uC7E4\uC800\uC81C\uC838\uC854\uC870\uC88C\uC8A8\uC8C4\uC8E0\uC8FC\uC918\uC934\uC950\uC96C\uC988\uC9A4\uC9C0\uC9DC\uC9F8\uCA14\uCA30\uCA4C\uCA68\uCA84\uCAA0\uCABC\uCAD8\uCAF4\uCB10\uCB2C\uCB48\uCB64\uCB80\uCB9C\uCBB8\uCBD4\uCBF0\uCC0C\uCC28\uCC44\uCC60\uCC7C\uCC98\uCCB4\uCCD0\uCCEC\uCD08\uCD24\uCD40\uCD5C\uCD78\uCD94\uCDB0\uCDCC\uCDE8\uCE04\uCE20\uCE3C\uCE58\uCE74\uCE90\uCEAC\uCEC8\uCEE4\uCF00\uCF1C\uCF38\uCF54\uCF70\uCF8C\uCFA8\uCFC4\uCFE0\uCFFC\uD018\uD034\uD050\uD06C\uD088\uD0A4\uD0C0\uD0DC\uD0F8\uD114\uD130\uD14C\uD168\uD184\uD1A0\uD1BC\uD1D8\uD1F4\uD210\uD22C\uD248\uD264\uD280\uD29C\uD2B8\uD2D4\uD2F0\uD30C\uD328\uD344\uD360\uD37C\uD398\uD3B4\uD3D0\uD3EC\uD408\uD424\uD440\uD45C\uD478\uD494\uD4B0\uD4CC\uD4E8\uD504\uD520\uD53C\uD558\uD574\uD590\uD5AC\uD5C8\uD5E4\uD600\uD61C\uD638\uD654\uD670\uD68C\uD6A8\uD6C4\uD6E0\uD6FC\uD718\uD734\uD750\uD76C\uD788]$/,
	Afe =
		/^[\uAC01-\uAC1B\uAC1D-\uAC37\uAC39-\uAC53\uAC55-\uAC6F\uAC71-\uAC8B\uAC8D-\uACA7\uACA9-\uACC3\uACC5-\uACDF\uACE1-\uACFB\uACFD-\uAD17\uAD19-\uAD33\uAD35-\uAD4F\uAD51-\uAD6B\uAD6D-\uAD87\uAD89-\uADA3\uADA5-\uADBF\uADC1-\uADDB\uADDD-\uADF7\uADF9-\uAE13\uAE15-\uAE2F\uAE31-\uAE4B\uAE4D-\uAE67\uAE69-\uAE83\uAE85-\uAE9F\uAEA1-\uAEBB\uAEBD-\uAED7\uAED9-\uAEF3\uAEF5-\uAF0F\uAF11-\uAF2B\uAF2D-\uAF47\uAF49-\uAF63\uAF65-\uAF7F\uAF81-\uAF9B\uAF9D-\uAFB7\uAFB9-\uAFD3\uAFD5-\uAFEF\uAFF1-\uB00B\uB00D-\uB027\uB029-\uB043\uB045-\uB05F\uB061-\uB07B\uB07D-\uB097\uB099-\uB0B3\uB0B5-\uB0CF\uB0D1-\uB0EB\uB0ED-\uB107\uB109-\uB123\uB125-\uB13F\uB141-\uB15B\uB15D-\uB177\uB179-\uB193\uB195-\uB1AF\uB1B1-\uB1CB\uB1CD-\uB1E7\uB1E9-\uB203\uB205-\uB21F\uB221-\uB23B\uB23D-\uB257\uB259-\uB273\uB275-\uB28F\uB291-\uB2AB\uB2AD-\uB2C7\uB2C9-\uB2E3\uB2E5-\uB2FF\uB301-\uB31B\uB31D-\uB337\uB339-\uB353\uB355-\uB36F\uB371-\uB38B\uB38D-\uB3A7\uB3A9-\uB3C3\uB3C5-\uB3DF\uB3E1-\uB3FB\uB3FD-\uB417\uB419-\uB433\uB435-\uB44F\uB451-\uB46B\uB46D-\uB487\uB489-\uB4A3\uB4A5-\uB4BF\uB4C1-\uB4DB\uB4DD-\uB4F7\uB4F9-\uB513\uB515-\uB52F\uB531-\uB54B\uB54D-\uB567\uB569-\uB583\uB585-\uB59F\uB5A1-\uB5BB\uB5BD-\uB5D7\uB5D9-\uB5F3\uB5F5-\uB60F\uB611-\uB62B\uB62D-\uB647\uB649-\uB663\uB665-\uB67F\uB681-\uB69B\uB69D-\uB6B7\uB6B9-\uB6D3\uB6D5-\uB6EF\uB6F1-\uB70B\uB70D-\uB727\uB729-\uB743\uB745-\uB75F\uB761-\uB77B\uB77D-\uB797\uB799-\uB7B3\uB7B5-\uB7CF\uB7D1-\uB7EB\uB7ED-\uB807\uB809-\uB823\uB825-\uB83F\uB841-\uB85B\uB85D-\uB877\uB879-\uB893\uB895-\uB8AF\uB8B1-\uB8CB\uB8CD-\uB8E7\uB8E9-\uB903\uB905-\uB91F\uB921-\uB93B\uB93D-\uB957\uB959-\uB973\uB975-\uB98F\uB991-\uB9AB\uB9AD-\uB9C7\uB9C9-\uB9E3\uB9E5-\uB9FF\uBA01-\uBA1B\uBA1D-\uBA37\uBA39-\uBA53\uBA55-\uBA6F\uBA71-\uBA8B\uBA8D-\uBAA7\uBAA9-\uBAC3\uBAC5-\uBADF\uBAE1-\uBAFB\uBAFD-\uBB17\uBB19-\uBB33\uBB35-\uBB4F\uBB51-\uBB6B\uBB6D-\uBB87\uBB89-\uBBA3\uBBA5-\uBBBF\uBBC1-\uBBDB\uBBDD-\uBBF7\uBBF9-\uBC13\uBC15-\uBC2F\uBC31-\uBC4B\uBC4D-\uBC67\uBC69-\uBC83\uBC85-\uBC9F\uBCA1-\uBCBB\uBCBD-\uBCD7\uBCD9-\uBCF3\uBCF5-\uBD0F\uBD11-\uBD2B\uBD2D-\uBD47\uBD49-\uBD63\uBD65-\uBD7F\uBD81-\uBD9B\uBD9D-\uBDB7\uBDB9-\uBDD3\uBDD5-\uBDEF\uBDF1-\uBE0B\uBE0D-\uBE27\uBE29-\uBE43\uBE45-\uBE5F\uBE61-\uBE7B\uBE7D-\uBE97\uBE99-\uBEB3\uBEB5-\uBECF\uBED1-\uBEEB\uBEED-\uBF07\uBF09-\uBF23\uBF25-\uBF3F\uBF41-\uBF5B\uBF5D-\uBF77\uBF79-\uBF93\uBF95-\uBFAF\uBFB1-\uBFCB\uBFCD-\uBFE7\uBFE9-\uC003\uC005-\uC01F\uC021-\uC03B\uC03D-\uC057\uC059-\uC073\uC075-\uC08F\uC091-\uC0AB\uC0AD-\uC0C7\uC0C9-\uC0E3\uC0E5-\uC0FF\uC101-\uC11B\uC11D-\uC137\uC139-\uC153\uC155-\uC16F\uC171-\uC18B\uC18D-\uC1A7\uC1A9-\uC1C3\uC1C5-\uC1DF\uC1E1-\uC1FB\uC1FD-\uC217\uC219-\uC233\uC235-\uC24F\uC251-\uC26B\uC26D-\uC287\uC289-\uC2A3\uC2A5-\uC2BF\uC2C1-\uC2DB\uC2DD-\uC2F7\uC2F9-\uC313\uC315-\uC32F\uC331-\uC34B\uC34D-\uC367\uC369-\uC383\uC385-\uC39F\uC3A1-\uC3BB\uC3BD-\uC3D7\uC3D9-\uC3F3\uC3F5-\uC40F\uC411-\uC42B\uC42D-\uC447\uC449-\uC463\uC465-\uC47F\uC481-\uC49B\uC49D-\uC4B7\uC4B9-\uC4D3\uC4D5-\uC4EF\uC4F1-\uC50B\uC50D-\uC527\uC529-\uC543\uC545-\uC55F\uC561-\uC57B\uC57D-\uC597\uC599-\uC5B3\uC5B5-\uC5CF\uC5D1-\uC5EB\uC5ED-\uC607\uC609-\uC623\uC625-\uC63F\uC641-\uC65B\uC65D-\uC677\uC679-\uC693\uC695-\uC6AF\uC6B1-\uC6CB\uC6CD-\uC6E7\uC6E9-\uC703\uC705-\uC71F\uC721-\uC73B\uC73D-\uC757\uC759-\uC773\uC775-\uC78F\uC791-\uC7AB\uC7AD-\uC7C7\uC7C9-\uC7E3\uC7E5-\uC7FF\uC801-\uC81B\uC81D-\uC837\uC839-\uC853\uC855-\uC86F\uC871-\uC88B\uC88D-\uC8A7\uC8A9-\uC8C3\uC8C5-\uC8DF\uC8E1-\uC8FB\uC8FD-\uC917\uC919-\uC933\uC935-\uC94F\uC951-\uC96B\uC96D-\uC987\uC989-\uC9A3\uC9A5-\uC9BF\uC9C1-\uC9DB\uC9DD-\uC9F7\uC9F9-\uCA13\uCA15-\uCA2F\uCA31-\uCA4B\uCA4D-\uCA67\uCA69-\uCA83\uCA85-\uCA9F\uCAA1-\uCABB\uCABD-\uCAD7\uCAD9-\uCAF3\uCAF5-\uCB0F\uCB11-\uCB2B\uCB2D-\uCB47\uCB49-\uCB63\uCB65-\uCB7F\uCB81-\uCB9B\uCB9D-\uCBB7\uCBB9-\uCBD3\uCBD5-\uCBEF\uCBF1-\uCC0B\uCC0D-\uCC27\uCC29-\uCC43\uCC45-\uCC5F\uCC61-\uCC7B\uCC7D-\uCC97\uCC99-\uCCB3\uCCB5-\uCCCF\uCCD1-\uCCEB\uCCED-\uCD07\uCD09-\uCD23\uCD25-\uCD3F\uCD41-\uCD5B\uCD5D-\uCD77\uCD79-\uCD93\uCD95-\uCDAF\uCDB1-\uCDCB\uCDCD-\uCDE7\uCDE9-\uCE03\uCE05-\uCE1F\uCE21-\uCE3B\uCE3D-\uCE57\uCE59-\uCE73\uCE75-\uCE8F\uCE91-\uCEAB\uCEAD-\uCEC7\uCEC9-\uCEE3\uCEE5-\uCEFF\uCF01-\uCF1B\uCF1D-\uCF37\uCF39-\uCF53\uCF55-\uCF6F\uCF71-\uCF8B\uCF8D-\uCFA7\uCFA9-\uCFC3\uCFC5-\uCFDF\uCFE1-\uCFFB\uCFFD-\uD017\uD019-\uD033\uD035-\uD04F\uD051-\uD06B\uD06D-\uD087\uD089-\uD0A3\uD0A5-\uD0BF\uD0C1-\uD0DB\uD0DD-\uD0F7\uD0F9-\uD113\uD115-\uD12F\uD131-\uD14B\uD14D-\uD167\uD169-\uD183\uD185-\uD19F\uD1A1-\uD1BB\uD1BD-\uD1D7\uD1D9-\uD1F3\uD1F5-\uD20F\uD211-\uD22B\uD22D-\uD247\uD249-\uD263\uD265-\uD27F\uD281-\uD29B\uD29D-\uD2B7\uD2B9-\uD2D3\uD2D5-\uD2EF\uD2F1-\uD30B\uD30D-\uD327\uD329-\uD343\uD345-\uD35F\uD361-\uD37B\uD37D-\uD397\uD399-\uD3B3\uD3B5-\uD3CF\uD3D1-\uD3EB\uD3ED-\uD407\uD409-\uD423\uD425-\uD43F\uD441-\uD45B\uD45D-\uD477\uD479-\uD493\uD495-\uD4AF\uD4B1-\uD4CB\uD4CD-\uD4E7\uD4E9-\uD503\uD505-\uD51F\uD521-\uD53B\uD53D-\uD557\uD559-\uD573\uD575-\uD58F\uD591-\uD5AB\uD5AD-\uD5C7\uD5C9-\uD5E3\uD5E5-\uD5FF\uD601-\uD61B\uD61D-\uD637\uD639-\uD653\uD655-\uD66F\uD671-\uD68B\uD68D-\uD6A7\uD6A9-\uD6C3\uD6C5-\uD6DF\uD6E1-\uD6FB\uD6FD-\uD717\uD719-\uD733\uD735-\uD74F\uD751-\uD76B\uD76D-\uD787\uD789-\uD7A3]$/,
	$fe =
		/^(?:[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u2388\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2605\u2607-\u2612\u2614-\u2685\u2690-\u2705\u2708-\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763-\u2767\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC00-\uDCFF\uDD0D-\uDD0F\uDD2F\uDD6C-\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDAD-\uDDE5\uDE01-\uDE0F\uDE1A\uDE2F\uDE32-\uDE3A\uDE3C-\uDE3F\uDE49-\uDFFA]|\uD83D[\uDC00-\uDD3D\uDD46-\uDE4F\uDE80-\uDEFF\uDF74-\uDF7F\uDFD5-\uDFFF]|\uD83E[\uDC0C-\uDC0F\uDC48-\uDC4F\uDC5A-\uDC5F\uDC88-\uDC8F\uDCAE-\uDCFF\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDEFF]|\uD83F[\uDC00-\uDFFD])$/,
	Tfe = (t, e) => {
		var n = dt.Any;
		return (
			t.search(xfe) !== -1 && (n |= dt.Extend),
			e === 8205 && (n |= dt.ZWJ),
			e >= 127462 && e <= 127487 && (n |= dt.RI),
			t.search(kfe) !== -1 && (n |= dt.Prepend),
			t.search(Cfe) !== -1 && (n |= dt.SpacingMark),
			t.search(wfe) !== -1 && (n |= dt.L),
			t.search(Efe) !== -1 && (n |= dt.V),
			t.search(Dfe) !== -1 && (n |= dt.T),
			t.search(Sfe) !== -1 && (n |= dt.LV),
			t.search(Afe) !== -1 && (n |= dt.LVT),
			t.search($fe) !== -1 && (n |= dt.ExtPict),
			n
		);
	};
function zf(t, e) {
	return (t & e) !== 0;
}
var Bfe = [
	[dt.L, dt.L | dt.V | dt.LV | dt.LVT],
	[dt.LV | dt.V, dt.V | dt.T],
	[dt.LVT | dt.T, dt.T],
	[dt.Any, dt.Extend | dt.ZWJ],
	[dt.Any, dt.SpacingMark],
	[dt.Prepend, dt.Any],
	[dt.ZWJ, dt.ExtPict],
	[dt.RI, dt.RI],
];
function Ife(t, e) {
	return Bfe.findIndex((n) => zf(t, n[0]) && zf(e, n[1])) === -1;
}
var Ffe =
		/(?:[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u2388\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2605\u2607-\u2612\u2614-\u2685\u2690-\u2705\u2708-\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763-\u2767\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC00-\uDCFF\uDD0D-\uDD0F\uDD2F\uDD6C-\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDAD-\uDDE5\uDE01-\uDE0F\uDE1A\uDE2F\uDE32-\uDE3A\uDE3C-\uDE3F\uDE49-\uDFFA]|\uD83D[\uDC00-\uDD3D\uDD46-\uDE4F\uDE80-\uDEFF\uDF74-\uDF7F\uDFD5-\uDFFF]|\uD83E[\uDC0C-\uDC0F\uDC48-\uDC4F\uDC5A-\uDC5F\uDC88-\uDC8F\uDCAE-\uDCFF\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDEFF]|\uD83F[\uDC00-\uDFFD])(?:[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D3-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09BE\u09C1-\u09C4\u09CD\u09D7\u09E2\u09E3\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3E\u0B3F\u0B41-\u0B44\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B82\u0BBE\u0BC0\u0BCD\u0BD7\u0C00\u0C04\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CBF\u0CC2\u0CC6\u0CCC\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D3E\u0D41-\u0D44\u0D4D\u0D57\u0D62\u0D63\u0D81\u0DCA\u0DCF\u0DD2-\u0DD4\u0DD6\u0DDF\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1AC0\u1B00-\u1B03\u1B34-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF9\u1DFB-\u1DFF\u200C\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA82C\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFF9E\uFF9F]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD803[\uDD24-\uDD27\uDEAB\uDEAC\uDF46-\uDF50]|\uD804[\uDC01\uDC38-\uDC46\uDC7F-\uDC81\uDCB3-\uDCB6\uDCB9\uDCBA\uDD00-\uDD02\uDD27-\uDD2B\uDD2D-\uDD34\uDD73\uDD80\uDD81\uDDB6-\uDDBE\uDDC9-\uDDCC\uDDCF\uDE2F-\uDE31\uDE34\uDE36\uDE37\uDE3E\uDEDF\uDEE3-\uDEEA\uDF00\uDF01\uDF3B\uDF3C\uDF3E\uDF40\uDF57\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC38-\uDC3F\uDC42-\uDC44\uDC46\uDC5E\uDCB0\uDCB3-\uDCB8\uDCBA\uDCBD\uDCBF\uDCC0\uDCC2\uDCC3\uDDAF\uDDB2-\uDDB5\uDDBC\uDDBD\uDDBF\uDDC0\uDDDC\uDDDD\uDE33-\uDE3A\uDE3D\uDE3F\uDE40\uDEAB\uDEAD\uDEB0-\uDEB5\uDEB7\uDF1D-\uDF1F\uDF22-\uDF25\uDF27-\uDF2B]|\uD806[\uDC2F-\uDC37\uDC39\uDC3A\uDD30\uDD3B\uDD3C\uDD3E\uDD43\uDDD4-\uDDD7\uDDDA\uDDDB\uDDE0\uDE01-\uDE0A\uDE33-\uDE38\uDE3B-\uDE3E\uDE47\uDE51-\uDE56\uDE59-\uDE5B\uDE8A-\uDE96\uDE98\uDE99]|\uD807[\uDC30-\uDC36\uDC38-\uDC3D\uDC3F\uDC92-\uDCA7\uDCAA-\uDCB0\uDCB2\uDCB3\uDCB5\uDCB6\uDD31-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD45\uDD47\uDD90\uDD91\uDD95\uDD97\uDEF3\uDEF4]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF4F\uDF8F-\uDF92\uDFE4]|\uD82F[\uDC9D\uDC9E]|\uD834[\uDD65\uDD67-\uDD69\uDD6E-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A\uDD30-\uDD36\uDEEC-\uDEEF]|\uD83A[\uDCD0-\uDCD6\uDD44-\uDD4A]|\uD83C[\uDFFB-\uDFFF]|\uDB40[\uDC20-\uDC7F\uDD00-\uDDEF])*\u200D$/,
	vT = (t) => t.search(Ffe) !== -1,
	Pfe = /(?:\uD83C[\uDDE6-\uDDFF])+$/g,
	Nfe = (t) => {
		var e = t.match(Pfe);
		if (e === null) return !1;
		var n = e[0].length / 2;
		return n % 2 === 1;
	},
	yT = (t) => Ar(t) && pe.isNodeList(t.children) && !R.isEditor(t),
	$e = {
		isAncestor(t) {
			return Ar(t) && pe.isNodeList(t.children);
		},
		isElement: yT,
		isElementList(t) {
			return Array.isArray(t) && t.every((e) => $e.isElement(e));
		},
		isElementProps(t) {
			return t.children !== void 0;
		},
		isElementType: function (e, n) {
			var r =
				arguments.length > 2 && arguments[2] !== void 0
					? arguments[2]
					: "type";
			return yT(e) && e[r] === n;
		},
		matches(t, e) {
			for (var n in e) if (n !== "children" && t[n] !== e[n]) return !1;
			return !0;
		},
	},
	Rfe = ["text"],
	Ofe = ["text"];
function xT(t, e) {
	var n = Object.keys(t);
	if (Object.getOwnPropertySymbols) {
		var r = Object.getOwnPropertySymbols(t);
		e &&
			(r = r.filter(function (i) {
				return Object.getOwnPropertyDescriptor(t, i).enumerable;
			})),
			n.push.apply(n, r);
	}
	return n;
}
function hf(t) {
	for (var e = 1; e < arguments.length; e++) {
		var n = arguments[e] != null ? arguments[e] : {};
		e % 2
			? xT(Object(n), !0).forEach(function (r) {
					Sa(t, r, n[r]);
				})
			: Object.getOwnPropertyDescriptors
				? Object.defineProperties(
						t,
						Object.getOwnPropertyDescriptors(n),
					)
				: xT(Object(n)).forEach(function (r) {
						Object.defineProperty(
							t,
							r,
							Object.getOwnPropertyDescriptor(n, r),
						);
					});
	}
	return t;
}
var kT = new WeakMap(),
	R = {
		above(t) {
			var e =
					arguments.length > 1 && arguments[1] !== void 0
						? arguments[1]
						: {},
				{
					voids: n = !1,
					mode: r = "lowest",
					at: i = t.selection,
					match: o,
				} = e;
			if (i) {
				var s = R.path(t, i),
					a = r === "lowest";
				for (var [l, u] of R.levels(t, {
					at: s,
					voids: n,
					match: o,
					reverse: a,
				}))
					if (!Be.isText(l)) {
						if (ie.isRange(i)) {
							if (
								Y.isAncestor(u, i.anchor.path) &&
								Y.isAncestor(u, i.focus.path)
							)
								return [l, u];
						} else if (!Y.equals(s, u)) return [l, u];
					}
			}
		},
		addMark(t, e, n) {
			t.addMark(e, n);
		},
		after(t, e) {
			var n =
					arguments.length > 2 && arguments[2] !== void 0
						? arguments[2]
						: {},
				r = R.point(t, e, { edge: "end" }),
				i = R.end(t, []),
				o = { anchor: r, focus: i },
				{ distance: s = 1 } = n,
				a = 0,
				l;
			for (var u of R.positions(t, hf(hf({}, n), {}, { at: o }))) {
				if (a > s) break;
				a !== 0 && (l = u), a++;
			}
			return l;
		},
		before(t, e) {
			var n =
					arguments.length > 2 && arguments[2] !== void 0
						? arguments[2]
						: {},
				r = R.start(t, []),
				i = R.point(t, e, { edge: "start" }),
				o = { anchor: r, focus: i },
				{ distance: s = 1 } = n,
				a = 0,
				l;
			for (var u of R.positions(
				t,
				hf(hf({}, n), {}, { at: o, reverse: !0 }),
			)) {
				if (a > s) break;
				a !== 0 && (l = u), a++;
			}
			return l;
		},
		deleteBackward(t) {
			var e =
					arguments.length > 1 && arguments[1] !== void 0
						? arguments[1]
						: {},
				{ unit: n = "character" } = e;
			t.deleteBackward(n);
		},
		deleteForward(t) {
			var e =
					arguments.length > 1 && arguments[1] !== void 0
						? arguments[1]
						: {},
				{ unit: n = "character" } = e;
			t.deleteForward(n);
		},
		deleteFragment(t) {
			var e =
					arguments.length > 1 && arguments[1] !== void 0
						? arguments[1]
						: {},
				{ direction: n = "forward" } = e;
			t.deleteFragment(n);
		},
		edges(t, e) {
			return [R.start(t, e), R.end(t, e)];
		},
		end(t, e) {
			return R.point(t, e, { edge: "end" });
		},
		first(t, e) {
			var n = R.path(t, e, { edge: "start" });
			return R.node(t, n);
		},
		fragment(t, e) {
			var n = R.range(t, e),
				r = pe.fragment(t, n);
			return r;
		},
		hasBlocks(t, e) {
			return e.children.some((n) => $e.isElement(n) && R.isBlock(t, n));
		},
		hasInlines(t, e) {
			return e.children.some((n) => Be.isText(n) || R.isInline(t, n));
		},
		hasTexts(t, e) {
			return e.children.every((n) => Be.isText(n));
		},
		insertBreak(t) {
			t.insertBreak();
		},
		insertSoftBreak(t) {
			t.insertSoftBreak();
		},
		insertFragment(t, e) {
			t.insertFragment(e);
		},
		insertNode(t, e) {
			t.insertNode(e);
		},
		insertText(t, e) {
			t.insertText(e);
		},
		isBlock(t, e) {
			return !t.isInline(e);
		},
		isEditor(t) {
			var e = kT.get(t);
			if (e !== void 0) return e;
			if (!Ar(t)) return !1;
			var n =
				typeof t.addMark == "function" &&
				typeof t.apply == "function" &&
				typeof t.deleteBackward == "function" &&
				typeof t.deleteForward == "function" &&
				typeof t.deleteFragment == "function" &&
				typeof t.insertBreak == "function" &&
				typeof t.insertSoftBreak == "function" &&
				typeof t.insertFragment == "function" &&
				typeof t.insertNode == "function" &&
				typeof t.insertText == "function" &&
				typeof t.isInline == "function" &&
				typeof t.isVoid == "function" &&
				typeof t.normalizeNode == "function" &&
				typeof t.onChange == "function" &&
				typeof t.removeMark == "function" &&
				typeof t.getDirtyPaths == "function" &&
				(t.marks === null || Ar(t.marks)) &&
				(t.selection === null || ie.isRange(t.selection)) &&
				pe.isNodeList(t.children) &&
				bu.isOperationList(t.operations);
			return kT.set(t, n), n;
		},
		isEnd(t, e, n) {
			var r = R.end(t, n);
			return ut.equals(e, r);
		},
		isEdge(t, e, n) {
			return R.isStart(t, e, n) || R.isEnd(t, e, n);
		},
		isEmpty(t, e) {
			var { children: n } = e,
				[r] = n;
			return (
				n.length === 0 ||
				(n.length === 1 &&
					Be.isText(r) &&
					r.text === "" &&
					!t.isVoid(e))
			);
		},
		isInline(t, e) {
			return t.isInline(e);
		},
		isNormalizing(t) {
			var e = hT.get(t);
			return e === void 0 ? !0 : e;
		},
		isStart(t, e, n) {
			if (e.offset !== 0) return !1;
			var r = R.start(t, n);
			return ut.equals(e, r);
		},
		isVoid(t, e) {
			return t.isVoid(e);
		},
		last(t, e) {
			var n = R.path(t, e, { edge: "end" });
			return R.node(t, n);
		},
		leaf(t, e) {
			var n =
					arguments.length > 2 && arguments[2] !== void 0
						? arguments[2]
						: {},
				r = R.path(t, e, n),
				i = pe.leaf(t, r);
			return [i, r];
		},
		*levels(t) {
			var e =
					arguments.length > 1 && arguments[1] !== void 0
						? arguments[1]
						: {},
				{ at: n = t.selection, reverse: r = !1, voids: i = !1 } = e,
				{ match: o } = e;
			if ((o == null && (o = () => !0), !!n)) {
				var s = [],
					a = R.path(t, n);
				for (var [l, u] of pe.levels(t, a))
					if (
						o(l, u) &&
						(s.push([l, u]),
						!i && $e.isElement(l) && R.isVoid(t, l))
					)
						break;
				r && s.reverse(), yield* s;
			}
		},
		marks(t) {
			var { marks: e, selection: n } = t;
			if (!n) return null;
			if (e) return e;
			if (ie.isExpanded(n)) {
				var [r] = R.nodes(t, { match: Be.isText });
				if (r) {
					var [i] = r,
						o = vl(i, Rfe);
					return o;
				} else return {};
			}
			var { anchor: s } = n,
				{ path: a } = s,
				[l] = R.leaf(t, a);
			if (s.offset === 0) {
				var u = R.previous(t, { at: a, match: Be.isText }),
					c = R.above(t, {
						match: (v) =>
							$e.isElement(v) &&
							R.isVoid(t, v) &&
							t.markableVoid(v),
					});
				if (!c) {
					var d = R.above(t, {
						match: (v) => $e.isElement(v) && R.isBlock(t, v),
					});
					if (u && d) {
						var [f, h] = u,
							[, p] = d;
						Y.isAncestor(p, h) && (l = f);
					}
				}
			}
			var g = vl(l, Ofe);
			return g;
		},
		next(t) {
			var e =
					arguments.length > 1 && arguments[1] !== void 0
						? arguments[1]
						: {},
				{ mode: n = "lowest", voids: r = !1 } = e,
				{ match: i, at: o = t.selection } = e;
			if (o) {
				var s = R.after(t, o, { voids: r });
				if (s) {
					var [, a] = R.last(t, []),
						l = [s.path, a];
					if (Y.isPath(o) && o.length === 0)
						throw new Error(
							"Cannot get the next node from the root node!",
						);
					if (i == null)
						if (Y.isPath(o)) {
							var [u] = R.parent(t, o);
							i = (d) => u.children.includes(d);
						} else i = () => !0;
					var [c] = R.nodes(t, {
						at: l,
						match: i,
						mode: n,
						voids: r,
					});
					return c;
				}
			}
		},
		node(t, e) {
			var n =
					arguments.length > 2 && arguments[2] !== void 0
						? arguments[2]
						: {},
				r = R.path(t, e, n),
				i = pe.get(t, r);
			return [i, r];
		},
		*nodes(t) {
			var e =
					arguments.length > 1 && arguments[1] !== void 0
						? arguments[1]
						: {},
				{
					at: n = t.selection,
					mode: r = "all",
					universal: i = !1,
					reverse: o = !1,
					voids: s = !1,
				} = e,
				{ match: a } = e;
			if ((a || (a = () => !0), !!n)) {
				var l, u;
				if (Mfe.isSpan(n)) (l = n[0]), (u = n[1]);
				else {
					var c = R.path(t, n, { edge: "start" }),
						d = R.path(t, n, { edge: "end" });
					(l = o ? d : c), (u = o ? c : d);
				}
				var f = pe.nodes(t, {
						reverse: o,
						from: l,
						to: u,
						pass: (x) => {
							var [C] = x;
							return s ? !1 : $e.isElement(C) && R.isVoid(t, C);
						},
					}),
					h = [],
					p;
				for (var [g, v] of f) {
					var b = p && Y.compare(v, p[1]) === 0;
					if (!(r === "highest" && b)) {
						if (!a(g, v)) {
							if (i && !b && Be.isText(g)) return;
							continue;
						}
						if (r === "lowest" && b) {
							p = [g, v];
							continue;
						}
						var y = r === "lowest" ? p : [g, v];
						y && (i ? h.push(y) : yield y), (p = [g, v]);
					}
				}
				r === "lowest" && p && (i ? h.push(p) : yield p),
					i && (yield* h);
			}
		},
		normalize(t) {
			var e =
					arguments.length > 1 && arguments[1] !== void 0
						? arguments[1]
						: {},
				{ force: n = !1, operation: r } = e,
				i = (u) => Vv.get(u) || [],
				o = (u) => Kv.get(u) || new Set(),
				s = (u) => {
					var c = i(u).pop(),
						d = c.join(",");
					return o(u).delete(d), c;
				};
			if (R.isNormalizing(t)) {
				if (n) {
					var a = Array.from(pe.nodes(t), (u) => {
							var [, c] = u;
							return c;
						}),
						l = new Set(a.map((u) => u.join(",")));
					Vv.set(t, a), Kv.set(t, l);
				}
				i(t).length !== 0 &&
					R.withoutNormalizing(t, () => {
						for (var u of i(t))
							if (pe.has(t, u)) {
								var c = R.node(t, u),
									[d, f] = c;
								$e.isElement(d) &&
									d.children.length === 0 &&
									t.normalizeNode(c, { operation: r });
							}
						for (
							var h = i(t), p = h.length, g = 0;
							h.length !== 0;

						) {
							if (
								!t.shouldNormalize({
									dirtyPaths: h,
									iteration: g,
									initialDirtyPathsLength: p,
									operation: r,
								})
							)
								return;
							var v = s(t);
							if (pe.has(t, v)) {
								var b = R.node(t, v);
								t.normalizeNode(b, { operation: r });
							}
							g++, (h = i(t));
						}
					});
			}
		},
		parent(t, e) {
			var n =
					arguments.length > 2 && arguments[2] !== void 0
						? arguments[2]
						: {},
				r = R.path(t, e, n),
				i = Y.parent(r),
				o = R.node(t, i);
			return o;
		},
		path(t, e) {
			var n =
					arguments.length > 2 && arguments[2] !== void 0
						? arguments[2]
						: {},
				{ depth: r, edge: i } = n;
			if (Y.isPath(e)) {
				if (i === "start") {
					var [, o] = pe.first(t, e);
					e = o;
				} else if (i === "end") {
					var [, s] = pe.last(t, e);
					e = s;
				}
			}
			return (
				ie.isRange(e) &&
					(i === "start"
						? (e = ie.start(e))
						: i === "end"
							? (e = ie.end(e))
							: (e = Y.common(e.anchor.path, e.focus.path))),
				ut.isPoint(e) && (e = e.path),
				r != null && (e = e.slice(0, r)),
				e
			);
		},
		hasPath(t, e) {
			return pe.has(t, e);
		},
		pathRef(t, e) {
			var n =
					arguments.length > 2 && arguments[2] !== void 0
						? arguments[2]
						: {},
				{ affinity: r = "forward" } = n,
				i = {
					current: e,
					affinity: r,
					unref() {
						var { current: s } = i,
							a = R.pathRefs(t);
						return a.delete(i), (i.current = null), s;
					},
				},
				o = R.pathRefs(t);
			return o.add(i), i;
		},
		pathRefs(t) {
			var e = pT.get(t);
			return e || ((e = new Set()), pT.set(t, e)), e;
		},
		point(t, e) {
			var n =
					arguments.length > 2 && arguments[2] !== void 0
						? arguments[2]
						: {},
				{ edge: r = "start" } = n;
			if (Y.isPath(e)) {
				var i;
				if (r === "end") {
					var [, o] = pe.last(t, e);
					i = o;
				} else {
					var [, s] = pe.first(t, e);
					i = s;
				}
				var a = pe.get(t, i);
				if (!Be.isText(a))
					throw new Error(
						"Cannot get the "
							.concat(r, " point in the node at path [")
							.concat(e, "] because it has no ")
							.concat(r, " text node."),
					);
				return { path: i, offset: r === "end" ? a.text.length : 0 };
			}
			if (ie.isRange(e)) {
				var [l, u] = ie.edges(e);
				return r === "start" ? l : u;
			}
			return e;
		},
		pointRef(t, e) {
			var n =
					arguments.length > 2 && arguments[2] !== void 0
						? arguments[2]
						: {},
				{ affinity: r = "forward" } = n,
				i = {
					current: e,
					affinity: r,
					unref() {
						var { current: s } = i,
							a = R.pointRefs(t);
						return a.delete(i), (i.current = null), s;
					},
				},
				o = R.pointRefs(t);
			return o.add(i), i;
		},
		pointRefs(t) {
			var e = mT.get(t);
			return e || ((e = new Set()), mT.set(t, e)), e;
		},
		*positions(t) {
			var e =
					arguments.length > 1 && arguments[1] !== void 0
						? arguments[1]
						: {},
				{
					at: n = t.selection,
					unit: r = "offset",
					reverse: i = !1,
					voids: o = !1,
				} = e;
			if (!n) return;
			var s = R.range(t, n),
				[a, l] = ie.edges(s),
				u = i ? l : a,
				c = !1,
				d = "",
				f = 0,
				h = 0,
				p = 0;
			for (var [g, v] of R.nodes(t, { at: n, reverse: i, voids: o })) {
				if ($e.isElement(g)) {
					if (!o && t.isVoid(g)) {
						yield R.start(t, v);
						continue;
					}
					if (t.isInline(g)) continue;
					if (R.hasInlines(t, g)) {
						var b = Y.isAncestor(v, l.path) ? l : R.end(t, v),
							y = Y.isAncestor(v, a.path) ? a : R.start(t, v);
						(d = R.string(
							t,
							{ anchor: y, focus: b },
							{ voids: o },
						)),
							(c = !0);
					}
				}
				if (Be.isText(g)) {
					var x = Y.equals(v, u.path);
					for (
						x
							? ((h = i ? u.offset : g.text.length - u.offset),
								(p = u.offset))
							: ((h = g.text.length), (p = i ? h : 0)),
							(x || c || r === "offset") &&
								(yield { path: v, offset: p }, (c = !1));
						;

					) {
						if (f === 0) {
							if (d === "") break;
							(f = C(d, r, i)), (d = dS(d, f, i)[1]);
						}
						if (((p = i ? p - f : p + f), (h = h - f), h < 0)) {
							f = -h;
							break;
						}
						(f = 0), yield { path: v, offset: p };
					}
				}
			}
			function C(k, w, D) {
				return w === "character"
					? cS(k, D)
					: w === "word"
						? mfe(k, D)
						: w === "line" || w === "block"
							? k.length
							: 1;
			}
		},
		previous(t) {
			var e =
					arguments.length > 1 && arguments[1] !== void 0
						? arguments[1]
						: {},
				{ mode: n = "lowest", voids: r = !1 } = e,
				{ match: i, at: o = t.selection } = e;
			if (o) {
				var s = R.before(t, o, { voids: r });
				if (s) {
					var [, a] = R.first(t, []),
						l = [s.path, a];
					if (Y.isPath(o) && o.length === 0)
						throw new Error(
							"Cannot get the previous node from the root node!",
						);
					if (i == null)
						if (Y.isPath(o)) {
							var [u] = R.parent(t, o);
							i = (d) => u.children.includes(d);
						} else i = () => !0;
					var [c] = R.nodes(t, {
						reverse: !0,
						at: l,
						match: i,
						mode: n,
						voids: r,
					});
					return c;
				}
			}
		},
		range(t, e, n) {
			if (ie.isRange(e) && !n) return e;
			var r = R.start(t, e),
				i = R.end(t, n || e);
			return { anchor: r, focus: i };
		},
		rangeRef(t, e) {
			var n =
					arguments.length > 2 && arguments[2] !== void 0
						? arguments[2]
						: {},
				{ affinity: r = "forward" } = n,
				i = {
					current: e,
					affinity: r,
					unref() {
						var { current: s } = i,
							a = R.rangeRefs(t);
						return a.delete(i), (i.current = null), s;
					},
				},
				o = R.rangeRefs(t);
			return o.add(i), i;
		},
		rangeRefs(t) {
			var e = gT.get(t);
			return e || ((e = new Set()), gT.set(t, e)), e;
		},
		removeMark(t, e) {
			t.removeMark(e);
		},
		setNormalizing(t, e) {
			hT.set(t, e);
		},
		start(t, e) {
			return R.point(t, e, { edge: "start" });
		},
		string(t, e) {
			var n =
					arguments.length > 2 && arguments[2] !== void 0
						? arguments[2]
						: {},
				{ voids: r = !1 } = n,
				i = R.range(t, e),
				[o, s] = ie.edges(i),
				a = "";
			for (var [l, u] of R.nodes(t, {
				at: i,
				match: Be.isText,
				voids: r,
			})) {
				var c = l.text;
				Y.equals(u, s.path) && (c = c.slice(0, s.offset)),
					Y.equals(u, o.path) && (c = c.slice(o.offset)),
					(a += c);
			}
			return a;
		},
		unhangRange(t, e) {
			var n =
					arguments.length > 2 && arguments[2] !== void 0
						? arguments[2]
						: {},
				{ voids: r = !1 } = n,
				[i, o] = ie.edges(e);
			if (
				i.offset !== 0 ||
				o.offset !== 0 ||
				ie.isCollapsed(e) ||
				Y.hasPrevious(o.path)
			)
				return e;
			var s = R.above(t, {
					at: o,
					match: (h) => $e.isElement(h) && R.isBlock(t, h),
					voids: r,
				}),
				a = s ? s[1] : [],
				l = R.start(t, i),
				u = { anchor: l, focus: o },
				c = !0;
			for (var [d, f] of R.nodes(t, {
				at: u,
				match: Be.isText,
				reverse: !0,
				voids: r,
			})) {
				if (c) {
					c = !1;
					continue;
				}
				if (d.text !== "" || Y.isBefore(f, a)) {
					o = { path: f, offset: d.text.length };
					break;
				}
			}
			return { anchor: i, focus: o };
		},
		void(t) {
			var e =
				arguments.length > 1 && arguments[1] !== void 0
					? arguments[1]
					: {};
			return R.above(
				t,
				hf(
					hf({}, e),
					{},
					{ match: (n) => $e.isElement(n) && R.isVoid(t, n) },
				),
			);
		},
		withoutNormalizing(t, e) {
			var n = R.isNormalizing(t);
			R.setNormalizing(t, !1);
			try {
				e();
			} finally {
				R.setNormalizing(t, n);
			}
			R.normalize(t);
		},
	},
	Mfe = {
		isSpan(t) {
			return Array.isArray(t) && t.length === 2 && t.every(Y.isPath);
		},
	},
	jfe = ["children"],
	_fe = ["text"],
	CT = new WeakMap(),
	pe = {
		ancestor(t, e) {
			var n = pe.get(t, e);
			if (Be.isText(n))
				throw new Error(
					"Cannot get the ancestor node at path ["
						.concat(
							e,
							"] because it refers to a text node instead: ",
						)
						.concat(dr.stringify(n)),
				);
			return n;
		},
		*ancestors(t, e) {
			var n =
				arguments.length > 2 && arguments[2] !== void 0
					? arguments[2]
					: {};
			for (var r of Y.ancestors(e, n)) {
				var i = pe.ancestor(t, r),
					o = [i, r];
				yield o;
			}
		},
		child(t, e) {
			if (Be.isText(t))
				throw new Error(
					"Cannot get the child of a text node: ".concat(
						dr.stringify(t),
					),
				);
			var n = t.children[e];
			if (n == null)
				throw new Error(
					"Cannot get child at index `"
						.concat(e, "` in node: ")
						.concat(dr.stringify(t)),
				);
			return n;
		},
		*children(t, e) {
			for (
				var n =
						arguments.length > 2 && arguments[2] !== void 0
							? arguments[2]
							: {},
					{ reverse: r = !1 } = n,
					i = pe.ancestor(t, e),
					{ children: o } = i,
					s = r ? o.length - 1 : 0;
				r ? s >= 0 : s < o.length;

			) {
				var a = pe.child(i, s),
					l = e.concat(s);
				yield [a, l], (s = r ? s - 1 : s + 1);
			}
		},
		common(t, e, n) {
			var r = Y.common(e, n),
				i = pe.get(t, r);
			return [i, r];
		},
		descendant(t, e) {
			var n = pe.get(t, e);
			if (R.isEditor(n))
				throw new Error(
					"Cannot get the descendant node at path ["
						.concat(
							e,
							"] because it refers to the root editor node instead: ",
						)
						.concat(dr.stringify(n)),
				);
			return n;
		},
		*descendants(t) {
			var e =
				arguments.length > 1 && arguments[1] !== void 0
					? arguments[1]
					: {};
			for (var [n, r] of pe.nodes(t, e)) r.length !== 0 && (yield [n, r]);
		},
		*elements(t) {
			var e =
				arguments.length > 1 && arguments[1] !== void 0
					? arguments[1]
					: {};
			for (var [n, r] of pe.nodes(t, e))
				$e.isElement(n) && (yield [n, r]);
		},
		extractProps(t) {
			if ($e.isAncestor(t)) {
				var e = vl(t, jfe);
				return e;
			} else {
				var e = vl(t, _fe);
				return e;
			}
		},
		first(t, e) {
			for (
				var n = e.slice(), r = pe.get(t, n);
				r && !(Be.isText(r) || r.children.length === 0);

			)
				(r = r.children[0]), n.push(0);
			return [r, n];
		},
		fragment(t, e) {
			if (Be.isText(t))
				throw new Error(
					"Cannot get a fragment starting from a root text node: ".concat(
						dr.stringify(t),
					),
				);
			var n = uS({ children: t.children }, (r) => {
				var [i, o] = ie.edges(e),
					s = pe.nodes(r, {
						reverse: !0,
						pass: (f) => {
							var [, h] = f;
							return !ie.includes(e, h);
						},
					});
				for (var [, a] of s) {
					if (!ie.includes(e, a)) {
						var l = pe.parent(r, a),
							u = a[a.length - 1];
						l.children.splice(u, 1);
					}
					if (Y.equals(a, o.path)) {
						var c = pe.leaf(r, a);
						c.text = c.text.slice(0, o.offset);
					}
					if (Y.equals(a, i.path)) {
						var d = pe.leaf(r, a);
						d.text = d.text.slice(i.offset);
					}
				}
				R.isEditor(r) && (r.selection = null);
			});
			return n.children;
		},
		get(t, e) {
			for (var n = t, r = 0; r < e.length; r++) {
				var i = e[r];
				if (Be.isText(n) || !n.children[i])
					throw new Error(
						"Cannot find a descendant at path ["
							.concat(e, "] in node: ")
							.concat(dr.stringify(t)),
					);
				n = n.children[i];
			}
			return n;
		},
		has(t, e) {
			for (var n = t, r = 0; r < e.length; r++) {
				var i = e[r];
				if (Be.isText(n) || !n.children[i]) return !1;
				n = n.children[i];
			}
			return !0;
		},
		isNode(t) {
			return Be.isText(t) || $e.isElement(t) || R.isEditor(t);
		},
		isNodeList(t) {
			if (!Array.isArray(t)) return !1;
			var e = CT.get(t);
			if (e !== void 0) return e;
			var n = t.every((r) => pe.isNode(r));
			return CT.set(t, n), n;
		},
		last(t, e) {
			for (
				var n = e.slice(), r = pe.get(t, n);
				r && !(Be.isText(r) || r.children.length === 0);

			) {
				var i = r.children.length - 1;
				(r = r.children[i]), n.push(i);
			}
			return [r, n];
		},
		leaf(t, e) {
			var n = pe.get(t, e);
			if (!Be.isText(n))
				throw new Error(
					"Cannot get the leaf node at path ["
						.concat(e, "] because it refers to a non-leaf node: ")
						.concat(dr.stringify(n)),
				);
			return n;
		},
		*levels(t, e) {
			var n =
				arguments.length > 2 && arguments[2] !== void 0
					? arguments[2]
					: {};
			for (var r of Y.levels(e, n)) {
				var i = pe.get(t, r);
				yield [i, r];
			}
		},
		matches(t, e) {
			return (
				($e.isElement(t) && $e.isElementProps(e) && $e.matches(t, e)) ||
				(Be.isText(t) && Be.isTextProps(e) && Be.matches(t, e))
			);
		},
		*nodes(t) {
			for (
				var e =
						arguments.length > 1 && arguments[1] !== void 0
							? arguments[1]
							: {},
					{ pass: n, reverse: r = !1 } = e,
					{ from: i = [], to: o } = e,
					s = new Set(),
					a = [],
					l = t;
				!(o && (r ? Y.isBefore(a, o) : Y.isAfter(a, o)));

			) {
				if (
					(s.has(l) || (yield [l, a]),
					!s.has(l) &&
						!Be.isText(l) &&
						l.children.length !== 0 &&
						(n == null || n([l, a]) === !1))
				) {
					s.add(l);
					var u = r ? l.children.length - 1 : 0;
					Y.isAncestor(a, i) && (u = i[a.length]),
						(a = a.concat(u)),
						(l = pe.get(t, a));
					continue;
				}
				if (a.length === 0) break;
				if (!r) {
					var c = Y.next(a);
					if (pe.has(t, c)) {
						(a = c), (l = pe.get(t, a));
						continue;
					}
				}
				if (r && a[a.length - 1] !== 0) {
					var d = Y.previous(a);
					(a = d), (l = pe.get(t, a));
					continue;
				}
				(a = Y.parent(a)), (l = pe.get(t, a)), s.add(l);
			}
		},
		parent(t, e) {
			var n = Y.parent(e),
				r = pe.get(t, n);
			if (Be.isText(r))
				throw new Error(
					"Cannot get the parent of path [".concat(
						e,
						"] because it does not exist in the root.",
					),
				);
			return r;
		},
		string(t) {
			return Be.isText(t) ? t.text : t.children.map(pe.string).join("");
		},
		*texts(t) {
			var e =
				arguments.length > 1 && arguments[1] !== void 0
					? arguments[1]
					: {};
			for (var [n, r] of pe.nodes(t, e)) Be.isText(n) && (yield [n, r]);
		},
	};
function wT(t, e) {
	var n = Object.keys(t);
	if (Object.getOwnPropertySymbols) {
		var r = Object.getOwnPropertySymbols(t);
		e &&
			(r = r.filter(function (i) {
				return Object.getOwnPropertyDescriptor(t, i).enumerable;
			})),
			n.push.apply(n, r);
	}
	return n;
}
function ln(t) {
	for (var e = 1; e < arguments.length; e++) {
		var n = arguments[e] != null ? arguments[e] : {};
		e % 2
			? wT(Object(n), !0).forEach(function (r) {
					Sa(t, r, n[r]);
				})
			: Object.getOwnPropertyDescriptors
				? Object.defineProperties(
						t,
						Object.getOwnPropertyDescriptors(n),
					)
				: wT(Object(n)).forEach(function (r) {
						Object.defineProperty(
							t,
							r,
							Object.getOwnPropertyDescriptor(n, r),
						);
					});
	}
	return t;
}
var bu = {
		isNodeOperation(t) {
			return bu.isOperation(t) && t.type.endsWith("_node");
		},
		isOperation(t) {
			if (!Ar(t)) return !1;
			switch (t.type) {
				case "insert_node":
					return Y.isPath(t.path) && pe.isNode(t.node);
				case "insert_text":
					return (
						typeof t.offset == "number" &&
						typeof t.text == "string" &&
						Y.isPath(t.path)
					);
				case "merge_node":
					return (
						typeof t.position == "number" &&
						Y.isPath(t.path) &&
						Ar(t.properties)
					);
				case "move_node":
					return Y.isPath(t.path) && Y.isPath(t.newPath);
				case "remove_node":
					return Y.isPath(t.path) && pe.isNode(t.node);
				case "remove_text":
					return (
						typeof t.offset == "number" &&
						typeof t.text == "string" &&
						Y.isPath(t.path)
					);
				case "set_node":
					return (
						Y.isPath(t.path) &&
						Ar(t.properties) &&
						Ar(t.newProperties)
					);
				case "set_selection":
					return (
						(t.properties === null &&
							ie.isRange(t.newProperties)) ||
						(t.newProperties === null &&
							ie.isRange(t.properties)) ||
						(Ar(t.properties) && Ar(t.newProperties))
					);
				case "split_node":
					return (
						Y.isPath(t.path) &&
						typeof t.position == "number" &&
						Ar(t.properties)
					);
				default:
					return !1;
			}
		},
		isOperationList(t) {
			return Array.isArray(t) && t.every((e) => bu.isOperation(e));
		},
		isSelectionOperation(t) {
			return bu.isOperation(t) && t.type.endsWith("_selection");
		},
		isTextOperation(t) {
			return bu.isOperation(t) && t.type.endsWith("_text");
		},
		inverse(t) {
			switch (t.type) {
				case "insert_node":
					return ln(ln({}, t), {}, { type: "remove_node" });
				case "insert_text":
					return ln(ln({}, t), {}, { type: "remove_text" });
				case "merge_node":
					return ln(
						ln({}, t),
						{},
						{ type: "split_node", path: Y.previous(t.path) },
					);
				case "move_node": {
					var { newPath: e, path: n } = t;
					if (Y.equals(e, n)) return t;
					if (Y.isSibling(n, e))
						return ln(ln({}, t), {}, { path: e, newPath: n });
					var r = Y.transform(n, t),
						i = Y.transform(Y.next(n), t);
					return ln(ln({}, t), {}, { path: r, newPath: i });
				}
				case "remove_node":
					return ln(ln({}, t), {}, { type: "insert_node" });
				case "remove_text":
					return ln(ln({}, t), {}, { type: "insert_text" });
				case "set_node": {
					var { properties: o, newProperties: s } = t;
					return ln(
						ln({}, t),
						{},
						{ properties: s, newProperties: o },
					);
				}
				case "set_selection": {
					var { properties: a, newProperties: l } = t;
					return a == null
						? ln(
								ln({}, t),
								{},
								{ properties: l, newProperties: null },
							)
						: l == null
							? ln(
									ln({}, t),
									{},
									{ properties: null, newProperties: a },
								)
							: ln(
									ln({}, t),
									{},
									{ properties: l, newProperties: a },
								);
				}
				case "split_node":
					return ln(
						ln({}, t),
						{},
						{ type: "merge_node", path: Y.next(t.path) },
					);
			}
		},
	},
	Y = {
		ancestors(t) {
			var e =
					arguments.length > 1 && arguments[1] !== void 0
						? arguments[1]
						: {},
				{ reverse: n = !1 } = e,
				r = Y.levels(t, e);
			return n ? (r = r.slice(1)) : (r = r.slice(0, -1)), r;
		},
		common(t, e) {
			for (var n = [], r = 0; r < t.length && r < e.length; r++) {
				var i = t[r],
					o = e[r];
				if (i !== o) break;
				n.push(i);
			}
			return n;
		},
		compare(t, e) {
			for (var n = Math.min(t.length, e.length), r = 0; r < n; r++) {
				if (t[r] < e[r]) return -1;
				if (t[r] > e[r]) return 1;
			}
			return 0;
		},
		endsAfter(t, e) {
			var n = t.length - 1,
				r = t.slice(0, n),
				i = e.slice(0, n),
				o = t[n],
				s = e[n];
			return Y.equals(r, i) && o > s;
		},
		endsAt(t, e) {
			var n = t.length,
				r = t.slice(0, n),
				i = e.slice(0, n);
			return Y.equals(r, i);
		},
		endsBefore(t, e) {
			var n = t.length - 1,
				r = t.slice(0, n),
				i = e.slice(0, n),
				o = t[n],
				s = e[n];
			return Y.equals(r, i) && o < s;
		},
		equals(t, e) {
			return t.length === e.length && t.every((n, r) => n === e[r]);
		},
		hasPrevious(t) {
			return t[t.length - 1] > 0;
		},
		isAfter(t, e) {
			return Y.compare(t, e) === 1;
		},
		isAncestor(t, e) {
			return t.length < e.length && Y.compare(t, e) === 0;
		},
		isBefore(t, e) {
			return Y.compare(t, e) === -1;
		},
		isChild(t, e) {
			return t.length === e.length + 1 && Y.compare(t, e) === 0;
		},
		isCommon(t, e) {
			return t.length <= e.length && Y.compare(t, e) === 0;
		},
		isDescendant(t, e) {
			return t.length > e.length && Y.compare(t, e) === 0;
		},
		isParent(t, e) {
			return t.length + 1 === e.length && Y.compare(t, e) === 0;
		},
		isPath(t) {
			return (
				Array.isArray(t) && (t.length === 0 || typeof t[0] == "number")
			);
		},
		isSibling(t, e) {
			if (t.length !== e.length) return !1;
			var n = t.slice(0, -1),
				r = e.slice(0, -1),
				i = t[t.length - 1],
				o = e[e.length - 1];
			return i !== o && Y.equals(n, r);
		},
		levels(t) {
			for (
				var e =
						arguments.length > 1 && arguments[1] !== void 0
							? arguments[1]
							: {},
					{ reverse: n = !1 } = e,
					r = [],
					i = 0;
				i <= t.length;
				i++
			)
				r.push(t.slice(0, i));
			return n && r.reverse(), r;
		},
		next(t) {
			if (t.length === 0)
				throw new Error(
					"Cannot get the next path of a root path [".concat(
						t,
						"], because it has no next index.",
					),
				);
			var e = t[t.length - 1];
			return t.slice(0, -1).concat(e + 1);
		},
		operationCanTransformPath(t) {
			switch (t.type) {
				case "insert_node":
				case "remove_node":
				case "merge_node":
				case "split_node":
				case "move_node":
					return !0;
				default:
					return !1;
			}
		},
		parent(t) {
			if (t.length === 0)
				throw new Error(
					"Cannot get the parent path of the root path [".concat(
						t,
						"].",
					),
				);
			return t.slice(0, -1);
		},
		previous(t) {
			if (t.length === 0)
				throw new Error(
					"Cannot get the previous path of a root path [".concat(
						t,
						"], because it has no previous index.",
					),
				);
			var e = t[t.length - 1];
			if (e <= 0)
				throw new Error(
					"Cannot get the previous path of a first child path [".concat(
						t,
						"] because it would result in a negative index.",
					),
				);
			return t.slice(0, -1).concat(e - 1);
		},
		relative(t, e) {
			if (!Y.isAncestor(e, t) && !Y.equals(t, e))
				throw new Error(
					"Cannot get the relative path of ["
						.concat(t, "] inside ancestor [")
						.concat(
							e,
							"], because it is not above or equal to the path.",
						),
				);
			return t.slice(e.length);
		},
		transform(t, e) {
			var n =
				arguments.length > 2 && arguments[2] !== void 0
					? arguments[2]
					: {};
			if (!t) return null;
			var r = [...t],
				{ affinity: i = "forward" } = n;
			if (t.length === 0) return r;
			switch (e.type) {
				case "insert_node": {
					var { path: o } = e;
					(Y.equals(o, r) ||
						Y.endsBefore(o, r) ||
						Y.isAncestor(o, r)) &&
						(r[o.length - 1] += 1);
					break;
				}
				case "remove_node": {
					var { path: s } = e;
					if (Y.equals(s, r) || Y.isAncestor(s, r)) return null;
					Y.endsBefore(s, r) && (r[s.length - 1] -= 1);
					break;
				}
				case "merge_node": {
					var { path: a, position: l } = e;
					Y.equals(a, r) || Y.endsBefore(a, r)
						? (r[a.length - 1] -= 1)
						: Y.isAncestor(a, r) &&
							((r[a.length - 1] -= 1), (r[a.length] += l));
					break;
				}
				case "split_node": {
					var { path: u, position: c } = e;
					if (Y.equals(u, r)) {
						if (i === "forward") r[r.length - 1] += 1;
						else if (i !== "backward") return null;
					} else
						Y.endsBefore(u, r)
							? (r[u.length - 1] += 1)
							: Y.isAncestor(u, r) &&
								t[u.length] >= c &&
								((r[u.length - 1] += 1), (r[u.length] -= c));
					break;
				}
				case "move_node": {
					var { path: d, newPath: f } = e;
					if (Y.equals(d, f)) return r;
					if (Y.isAncestor(d, r) || Y.equals(d, r)) {
						var h = f.slice();
						return (
							Y.endsBefore(d, f) &&
								d.length < f.length &&
								(h[d.length - 1] -= 1),
							h.concat(r.slice(d.length))
						);
					} else
						Y.isSibling(d, f) &&
						(Y.isAncestor(f, r) || Y.equals(f, r))
							? Y.endsBefore(d, r)
								? (r[d.length - 1] -= 1)
								: (r[d.length - 1] += 1)
							: Y.endsBefore(f, r) ||
								  Y.equals(f, r) ||
								  Y.isAncestor(f, r)
								? (Y.endsBefore(d, r) && (r[d.length - 1] -= 1),
									(r[f.length - 1] += 1))
								: Y.endsBefore(d, r) &&
									(Y.equals(f, r) && (r[f.length - 1] += 1),
									(r[d.length - 1] -= 1));
					break;
				}
			}
			return r;
		},
	},
	zfe = {
		transform(t, e) {
			var { current: n, affinity: r } = t;
			if (n != null) {
				var i = Y.transform(n, e, { affinity: r });
				(t.current = i), i == null && t.unref();
			}
		},
	};
function ET(t, e) {
	var n = Object.keys(t);
	if (Object.getOwnPropertySymbols) {
		var r = Object.getOwnPropertySymbols(t);
		e &&
			(r = r.filter(function (i) {
				return Object.getOwnPropertyDescriptor(t, i).enumerable;
			})),
			n.push.apply(n, r);
	}
	return n;
}
function DT(t) {
	for (var e = 1; e < arguments.length; e++) {
		var n = arguments[e] != null ? arguments[e] : {};
		e % 2
			? ET(Object(n), !0).forEach(function (r) {
					Sa(t, r, n[r]);
				})
			: Object.getOwnPropertyDescriptors
				? Object.defineProperties(
						t,
						Object.getOwnPropertyDescriptors(n),
					)
				: ET(Object(n)).forEach(function (r) {
						Object.defineProperty(
							t,
							r,
							Object.getOwnPropertyDescriptor(n, r),
						);
					});
	}
	return t;
}
var ut = {
		compare(t, e) {
			var n = Y.compare(t.path, e.path);
			return n === 0
				? t.offset < e.offset
					? -1
					: t.offset > e.offset
						? 1
						: 0
				: n;
		},
		isAfter(t, e) {
			return ut.compare(t, e) === 1;
		},
		isBefore(t, e) {
			return ut.compare(t, e) === -1;
		},
		equals(t, e) {
			return t.offset === e.offset && Y.equals(t.path, e.path);
		},
		isPoint(t) {
			return Ar(t) && typeof t.offset == "number" && Y.isPath(t.path);
		},
		transform(t, e) {
			var n =
				arguments.length > 2 && arguments[2] !== void 0
					? arguments[2]
					: {};
			return uS(t, (r) => {
				if (r === null) return null;
				var { affinity: i = "forward" } = n,
					{ path: o, offset: s } = r;
				switch (e.type) {
					case "insert_node":
					case "move_node": {
						r.path = Y.transform(o, e, n);
						break;
					}
					case "insert_text": {
						Y.equals(e.path, o) &&
							(e.offset < s ||
								(e.offset === s && i === "forward")) &&
							(r.offset += e.text.length);
						break;
					}
					case "merge_node": {
						Y.equals(e.path, o) && (r.offset += e.position),
							(r.path = Y.transform(o, e, n));
						break;
					}
					case "remove_text": {
						Y.equals(e.path, o) &&
							e.offset <= s &&
							(r.offset -= Math.min(s - e.offset, e.text.length));
						break;
					}
					case "remove_node": {
						if (Y.equals(e.path, o) || Y.isAncestor(e.path, o))
							return null;
						r.path = Y.transform(o, e, n);
						break;
					}
					case "split_node": {
						if (Y.equals(e.path, o)) {
							if (e.position === s && i == null) return null;
							(e.position < s ||
								(e.position === s && i === "forward")) &&
								((r.offset -= e.position),
								(r.path = Y.transform(
									o,
									e,
									DT(DT({}, n), {}, { affinity: "forward" }),
								)));
						} else r.path = Y.transform(o, e, n);
						break;
					}
				}
			});
		},
	},
	Lfe = {
		transform(t, e) {
			var { current: n, affinity: r } = t;
			if (n != null) {
				var i = ut.transform(n, e, { affinity: r });
				(t.current = i), i == null && t.unref();
			}
		},
	},
	Vfe = ["anchor", "focus"];
function ST(t, e) {
	var n = Object.keys(t);
	if (Object.getOwnPropertySymbols) {
		var r = Object.getOwnPropertySymbols(t);
		e &&
			(r = r.filter(function (i) {
				return Object.getOwnPropertyDescriptor(t, i).enumerable;
			})),
			n.push.apply(n, r);
	}
	return n;
}
function Kfe(t) {
	for (var e = 1; e < arguments.length; e++) {
		var n = arguments[e] != null ? arguments[e] : {};
		e % 2
			? ST(Object(n), !0).forEach(function (r) {
					Sa(t, r, n[r]);
				})
			: Object.getOwnPropertyDescriptors
				? Object.defineProperties(
						t,
						Object.getOwnPropertyDescriptors(n),
					)
				: ST(Object(n)).forEach(function (r) {
						Object.defineProperty(
							t,
							r,
							Object.getOwnPropertyDescriptor(n, r),
						);
					});
	}
	return t;
}
var ie = {
		edges(t) {
			var e =
					arguments.length > 1 && arguments[1] !== void 0
						? arguments[1]
						: {},
				{ reverse: n = !1 } = e,
				{ anchor: r, focus: i } = t;
			return ie.isBackward(t) === n ? [r, i] : [i, r];
		},
		end(t) {
			var [, e] = ie.edges(t);
			return e;
		},
		equals(t, e) {
			return ut.equals(t.anchor, e.anchor) && ut.equals(t.focus, e.focus);
		},
		includes(t, e) {
			if (ie.isRange(e)) {
				if (ie.includes(t, e.anchor) || ie.includes(t, e.focus))
					return !0;
				var [n, r] = ie.edges(t),
					[i, o] = ie.edges(e);
				return ut.isBefore(n, i) && ut.isAfter(r, o);
			}
			var [s, a] = ie.edges(t),
				l = !1,
				u = !1;
			return (
				ut.isPoint(e)
					? ((l = ut.compare(e, s) >= 0), (u = ut.compare(e, a) <= 0))
					: ((l = Y.compare(e, s.path) >= 0),
						(u = Y.compare(e, a.path) <= 0)),
				l && u
			);
		},
		intersection(t, e) {
			var n = vl(t, Vfe),
				[r, i] = ie.edges(t),
				[o, s] = ie.edges(e),
				a = ut.isBefore(r, o) ? o : r,
				l = ut.isBefore(i, s) ? i : s;
			return ut.isBefore(l, a) ? null : Kfe({ anchor: a, focus: l }, n);
		},
		isBackward(t) {
			var { anchor: e, focus: n } = t;
			return ut.isAfter(e, n);
		},
		isCollapsed(t) {
			var { anchor: e, focus: n } = t;
			return ut.equals(e, n);
		},
		isExpanded(t) {
			return !ie.isCollapsed(t);
		},
		isForward(t) {
			return !ie.isBackward(t);
		},
		isRange(t) {
			return Ar(t) && ut.isPoint(t.anchor) && ut.isPoint(t.focus);
		},
		*points(t) {
			yield [t.anchor, "anchor"], yield [t.focus, "focus"];
		},
		start(t) {
			var [e] = ie.edges(t);
			return e;
		},
		transform(t, e) {
			var n =
				arguments.length > 2 && arguments[2] !== void 0
					? arguments[2]
					: {};
			return uS(t, (r) => {
				if (r === null) return null;
				var { affinity: i = "inward" } = n,
					o,
					s;
				if (i === "inward") {
					var a = ie.isCollapsed(r);
					ie.isForward(r)
						? ((o = "forward"), (s = a ? o : "backward"))
						: ((o = "backward"), (s = a ? o : "forward"));
				} else
					i === "outward"
						? ie.isForward(r)
							? ((o = "backward"), (s = "forward"))
							: ((o = "forward"), (s = "backward"))
						: ((o = i), (s = i));
				var l = ut.transform(r.anchor, e, { affinity: o }),
					u = ut.transform(r.focus, e, { affinity: s });
				if (!l || !u) return null;
				(r.anchor = l), (r.focus = u);
			});
		},
	},
	Ufe = {
		transform(t, e) {
			var { current: n, affinity: r } = t;
			if (n != null) {
				var i = ie.transform(n, e, { affinity: r });
				(t.current = i), i == null && t.unref();
			}
		},
	},
	AT = void 0,
	dr = {
		setScrubber(t) {
			AT = t;
		},
		stringify(t) {
			return JSON.stringify(t, AT);
		},
	},
	sz = (t, e) => {
		for (var n in t) {
			var r = t[n],
				i = e[n];
			if (Ar(r) && Ar(i)) {
				if (!sz(r, i)) return !1;
			} else if (Array.isArray(r) && Array.isArray(i)) {
				if (r.length !== i.length) return !1;
				for (var o = 0; o < r.length; o++) if (r[o] !== i[o]) return !1;
			} else if (r !== i) return !1;
		}
		for (var s in e) if (t[s] === void 0 && e[s] !== void 0) return !1;
		return !0;
	},
	Hfe = ["text"],
	Wfe = ["anchor", "focus"];
function $T(t, e) {
	var n = Object.keys(t);
	if (Object.getOwnPropertySymbols) {
		var r = Object.getOwnPropertySymbols(t);
		e &&
			(r = r.filter(function (i) {
				return Object.getOwnPropertyDescriptor(t, i).enumerable;
			})),
			n.push.apply(n, r);
	}
	return n;
}
function za(t) {
	for (var e = 1; e < arguments.length; e++) {
		var n = arguments[e] != null ? arguments[e] : {};
		e % 2
			? $T(Object(n), !0).forEach(function (r) {
					Sa(t, r, n[r]);
				})
			: Object.getOwnPropertyDescriptors
				? Object.defineProperties(
						t,
						Object.getOwnPropertyDescriptors(n),
					)
				: $T(Object(n)).forEach(function (r) {
						Object.defineProperty(
							t,
							r,
							Object.getOwnPropertyDescriptor(n, r),
						);
					});
	}
	return t;
}
var Be = {
	equals(t, e) {
		var n =
				arguments.length > 2 && arguments[2] !== void 0
					? arguments[2]
					: {},
			{ loose: r = !1 } = n;
		function i(o) {
			var s = vl(o, Hfe);
			return s;
		}
		return sz(r ? i(t) : t, r ? i(e) : e);
	},
	isText(t) {
		return Ar(t) && typeof t.text == "string";
	},
	isTextList(t) {
		return Array.isArray(t) && t.every((e) => Be.isText(e));
	},
	isTextProps(t) {
		return t.text !== void 0;
	},
	matches(t, e) {
		for (var n in e)
			if (n !== "text" && (!t.hasOwnProperty(n) || t[n] !== e[n]))
				return !1;
		return !0;
	},
	decorations(t, e) {
		var n = [za({}, t)];
		for (var r of e) {
			var i = vl(r, Wfe),
				[o, s] = ie.edges(r),
				a = [],
				l = 0,
				u = o.offset,
				c = s.offset;
			for (var d of n) {
				var { length: f } = d.text,
					h = l;
				if (((l += f), u <= h && l <= c)) {
					Object.assign(d, i), a.push(d);
					continue;
				}
				if (
					(u !== c && (u === l || c === h)) ||
					u > l ||
					c < h ||
					(c === h && h !== 0)
				) {
					a.push(d);
					continue;
				}
				var p = d,
					g = void 0,
					v = void 0;
				if (c < l) {
					var b = c - h;
					(v = za(za({}, p), {}, { text: p.text.slice(b) })),
						(p = za(za({}, p), {}, { text: p.text.slice(0, b) }));
				}
				if (u > h) {
					var y = u - h;
					(g = za(za({}, p), {}, { text: p.text.slice(0, y) })),
						(p = za(za({}, p), {}, { text: p.text.slice(y) }));
				}
				Object.assign(p, i), g && a.push(g), a.push(p), v && a.push(v);
			}
			n = a;
		}
		return n;
	},
};
function TT(t, e) {
	var n = Object.keys(t);
	if (Object.getOwnPropertySymbols) {
		var r = Object.getOwnPropertySymbols(t);
		e &&
			(r = r.filter(function (i) {
				return Object.getOwnPropertyDescriptor(t, i).enumerable;
			})),
			n.push.apply(n, r);
	}
	return n;
}
function Pp(t) {
	for (var e = 1; e < arguments.length; e++) {
		var n = arguments[e] != null ? arguments[e] : {};
		e % 2
			? TT(Object(n), !0).forEach(function (r) {
					Sa(t, r, n[r]);
				})
			: Object.getOwnPropertyDescriptors
				? Object.defineProperties(
						t,
						Object.getOwnPropertyDescriptors(n),
					)
				: TT(Object(n)).forEach(function (r) {
						Object.defineProperty(
							t,
							r,
							Object.getOwnPropertyDescriptor(n, r),
						);
					});
	}
	return t;
}
var qfe = (t, e, n) => {
		switch (n.type) {
			case "insert_node": {
				var { path: r, node: i } = n,
					o = pe.parent(t, r),
					s = r[r.length - 1];
				if (s > o.children.length)
					throw new Error(
						'Cannot apply an "insert_node" operation at path ['.concat(
							r,
							"] because the destination is past the end of the node.",
						),
					);
				if ((o.children.splice(s, 0, i), e))
					for (var [a, l] of ie.points(e)) e[l] = ut.transform(a, n);
				break;
			}
			case "insert_text": {
				var { path: u, offset: c, text: d } = n;
				if (d.length === 0) break;
				var f = pe.leaf(t, u),
					h = f.text.slice(0, c),
					p = f.text.slice(c);
				if (((f.text = h + d + p), e))
					for (var [g, v] of ie.points(e)) e[v] = ut.transform(g, n);
				break;
			}
			case "merge_node": {
				var { path: b } = n,
					y = pe.get(t, b),
					x = Y.previous(b),
					C = pe.get(t, x),
					k = pe.parent(t, b),
					w = b[b.length - 1];
				if (Be.isText(y) && Be.isText(C)) C.text += y.text;
				else if (!Be.isText(y) && !Be.isText(C))
					C.children.push(...y.children);
				else
					throw new Error(
						'Cannot apply a "merge_node" operation at path ['
							.concat(b, "] to nodes of different interfaces: ")
							.concat(dr.stringify(y), " ")
							.concat(dr.stringify(C)),
					);
				if ((k.children.splice(w, 1), e))
					for (var [D, S] of ie.points(e)) e[S] = ut.transform(D, n);
				break;
			}
			case "move_node": {
				var { path: $, newPath: A } = n;
				if (Y.isAncestor($, A))
					throw new Error(
						"Cannot move a path ["
							.concat($, "] to new path [")
							.concat(
								A,
								"] because the destination is inside itself.",
							),
					);
				var T = pe.get(t, $),
					I = pe.parent(t, $),
					F = $[$.length - 1];
				I.children.splice(F, 1);
				var N = Y.transform($, n),
					O = pe.get(t, Y.parent(N)),
					_ = N[N.length - 1];
				if ((O.children.splice(_, 0, T), e))
					for (var [j, V] of ie.points(e)) e[V] = ut.transform(j, n);
				break;
			}
			case "remove_node": {
				var { path: K } = n,
					M = K[K.length - 1],
					G = pe.parent(t, K);
				if ((G.children.splice(M, 1), e))
					for (var [H, P] of ie.points(e)) {
						var q = ut.transform(H, n);
						if (e != null && q != null) e[P] = q;
						else {
							var J = void 0,
								Z = void 0;
							for (var [oe, ne] of pe.texts(t))
								if (Y.compare(ne, K) === -1) J = [oe, ne];
								else {
									Z = [oe, ne];
									break;
								}
							var de = !1;
							J &&
								Z &&
								(Y.equals(Z[1], K)
									? (de = !Y.hasPrevious(Z[1]))
									: (de =
											Y.common(J[1], K).length <
											Y.common(Z[1], K).length)),
								J && !de
									? ((H.path = J[1]),
										(H.offset = J[0].text.length))
									: Z
										? ((H.path = Z[1]), (H.offset = 0))
										: (e = null);
						}
					}
				break;
			}
			case "remove_text": {
				var { path: se, offset: re, text: he } = n;
				if (he.length === 0) break;
				var ye = pe.leaf(t, se),
					Ae = ye.text.slice(0, re),
					Pe = ye.text.slice(re + he.length);
				if (((ye.text = Ae + Pe), e))
					for (var [we, Ke] of ie.points(e))
						e[Ke] = ut.transform(we, n);
				break;
			}
			case "set_node": {
				var { path: rt, properties: Ce, newProperties: Me } = n;
				if (rt.length === 0)
					throw new Error("Cannot set properties on the root node!");
				var me = pe.get(t, rt);
				for (var De in Me) {
					if (De === "children" || De === "text")
						throw new Error(
							'Cannot set the "'.concat(
								De,
								'" property of nodes!',
							),
						);
					var _e = Me[De];
					_e == null ? delete me[De] : (me[De] = _e);
				}
				for (var We in Ce) Me.hasOwnProperty(We) || delete me[We];
				break;
			}
			case "set_selection": {
				var { newProperties: Et } = n;
				if (Et == null) e = Et;
				else {
					if (e == null) {
						if (!ie.isRange(Et))
							throw new Error(
								'Cannot apply an incomplete "set_selection" operation properties '.concat(
									dr.stringify(Et),
									" when there is no current selection.",
								),
							);
						e = Pp({}, Et);
					}
					for (var ae in Et) {
						var fe = Et[ae];
						if (fe == null) {
							if (ae === "anchor" || ae === "focus")
								throw new Error(
									'Cannot remove the "'.concat(
										ae,
										'" selection property',
									),
								);
							delete e[ae];
						} else e[ae] = fe;
					}
				}
				break;
			}
			case "split_node": {
				var { path: U, position: tt, properties: Dt } = n;
				if (U.length === 0)
					throw new Error(
						'Cannot apply a "split_node" operation at path ['.concat(
							U,
							"] because the root node cannot be split.",
						),
					);
				var Xt = pe.get(t, U),
					bn = pe.parent(t, U),
					Qr = U[U.length - 1],
					Na;
				if (Be.isText(Xt)) {
					var lc = Xt.text.slice(0, tt),
						ei = Xt.text.slice(tt);
					(Xt.text = lc), (Na = Pp(Pp({}, Dt), {}, { text: ei }));
				} else {
					var jl = Xt.children.slice(0, tt),
						ts = Xt.children.slice(tt);
					(Xt.children = jl),
						(Na = Pp(Pp({}, Dt), {}, { children: ts }));
				}
				if ((bn.children.splice(Qr + 1, 0, Na), e))
					for (var [mQ, gQ] of ie.points(e))
						e[gQ] = ut.transform(mQ, n);
				break;
			}
		}
		return e;
	},
	Gfe = {
		transform(t, e) {
			t.children = dT(t.children);
			var n = t.selection && dT(t.selection);
			try {
				n = qfe(t, n, e);
			} finally {
				(t.children = fT(t.children)),
					n
						? (t.selection = kd(n) ? fT(n) : n)
						: (t.selection = null);
			}
		},
	},
	Yfe = ["text"],
	Jfe = ["children"];
function BT(t, e) {
	var n = Object.keys(t);
	if (Object.getOwnPropertySymbols) {
		var r = Object.getOwnPropertySymbols(t);
		e &&
			(r = r.filter(function (i) {
				return Object.getOwnPropertyDescriptor(t, i).enumerable;
			})),
			n.push.apply(n, r);
	}
	return n;
}
function IT(t) {
	for (var e = 1; e < arguments.length; e++) {
		var n = arguments[e] != null ? arguments[e] : {};
		e % 2
			? BT(Object(n), !0).forEach(function (r) {
					Sa(t, r, n[r]);
				})
			: Object.getOwnPropertyDescriptors
				? Object.defineProperties(
						t,
						Object.getOwnPropertyDescriptors(n),
					)
				: BT(Object(n)).forEach(function (r) {
						Object.defineProperty(
							t,
							r,
							Object.getOwnPropertyDescriptor(n, r),
						);
					});
	}
	return t;
}
var Xfe = {
		insertNodes(t, e) {
			var n =
				arguments.length > 2 && arguments[2] !== void 0
					? arguments[2]
					: {};
			R.withoutNormalizing(t, () => {
				var { hanging: r = !1, voids: i = !1, mode: o = "lowest" } = n,
					{ at: s, match: a, select: l } = n;
				if ((pe.isNode(e) && (e = [e]), e.length !== 0)) {
					var [u] = e;
					if (
						(s ||
							(t.selection
								? (s = t.selection)
								: t.children.length > 0
									? (s = R.end(t, []))
									: (s = [0]),
							(l = !0)),
						l == null && (l = !1),
						ie.isRange(s))
					)
						if (
							(r || (s = R.unhangRange(t, s, { voids: i })),
							ie.isCollapsed(s))
						)
							s = s.anchor;
						else {
							var [, c] = ie.edges(s),
								d = R.pointRef(t, c);
							W.delete(t, { at: s }), (s = d.unref());
						}
					if (ut.isPoint(s)) {
						a == null &&
							(Be.isText(u)
								? (a = (w) => Be.isText(w))
								: t.isInline(u)
									? (a = (w) =>
											Be.isText(w) || R.isInline(t, w))
									: (a = (w) =>
											$e.isElement(w) &&
											R.isBlock(t, w)));
						var [f] = R.nodes(t, {
							at: s.path,
							match: a,
							mode: o,
							voids: i,
						});
						if (f) {
							var [, h] = f,
								p = R.pathRef(t, h),
								g = R.isEnd(t, s, h);
							W.splitNodes(t, {
								at: s,
								match: a,
								mode: o,
								voids: i,
							});
							var v = p.unref();
							s = g ? Y.next(v) : v;
						} else return;
					}
					var b = Y.parent(s),
						y = s[s.length - 1];
					if (!(!i && R.void(t, { at: b }))) {
						for (var x of e) {
							var C = b.concat(y);
							y++,
								t.apply({
									type: "insert_node",
									path: C,
									node: x,
								}),
								(s = Y.next(s));
						}
						if (((s = Y.previous(s)), l)) {
							var k = R.end(t, s);
							k && W.select(t, k);
						}
					}
				}
			});
		},
		liftNodes(t) {
			var e =
				arguments.length > 1 && arguments[1] !== void 0
					? arguments[1]
					: {};
			R.withoutNormalizing(t, () => {
				var {
						at: n = t.selection,
						mode: r = "lowest",
						voids: i = !1,
					} = e,
					{ match: o } = e;
				if (
					(o == null &&
						(o = Y.isPath(n)
							? pf(t, n)
							: (x) => $e.isElement(x) && R.isBlock(t, x)),
					!!n)
				) {
					var s = R.nodes(t, { at: n, match: o, mode: r, voids: i }),
						a = Array.from(s, (x) => {
							var [, C] = x;
							return R.pathRef(t, C);
						});
					for (var l of a) {
						var u = l.unref();
						if (u.length < 2)
							throw new Error(
								"Cannot lift node at a path [".concat(
									u,
									"] because it has a depth of less than `2`.",
								),
							);
						var c = R.node(t, Y.parent(u)),
							[d, f] = c,
							h = u[u.length - 1],
							{ length: p } = d.children;
						if (p === 1) {
							var g = Y.next(f);
							W.moveNodes(t, { at: u, to: g, voids: i }),
								W.removeNodes(t, { at: f, voids: i });
						} else if (h === 0)
							W.moveNodes(t, { at: u, to: f, voids: i });
						else if (h === p - 1) {
							var v = Y.next(f);
							W.moveNodes(t, { at: u, to: v, voids: i });
						} else {
							var b = Y.next(u),
								y = Y.next(f);
							W.splitNodes(t, { at: b, voids: i }),
								W.moveNodes(t, { at: u, to: y, voids: i });
						}
					}
				}
			});
		},
		mergeNodes(t) {
			var e =
				arguments.length > 1 && arguments[1] !== void 0
					? arguments[1]
					: {};
			R.withoutNormalizing(t, () => {
				var { match: n, at: r = t.selection } = e,
					{ hanging: i = !1, voids: o = !1, mode: s = "lowest" } = e;
				if (r) {
					if (n == null)
						if (Y.isPath(r)) {
							var [a] = R.parent(t, r);
							n = ($) => a.children.includes($);
						} else n = ($) => $e.isElement($) && R.isBlock(t, $);
					if (
						(!i &&
							ie.isRange(r) &&
							(r = R.unhangRange(t, r, { voids: o })),
						ie.isRange(r))
					)
						if (ie.isCollapsed(r)) r = r.anchor;
						else {
							var [, l] = ie.edges(r),
								u = R.pointRef(t, l);
							W.delete(t, { at: r }),
								(r = u.unref()),
								e.at == null && W.select(t, r);
						}
					var [c] = R.nodes(t, {
							at: r,
							match: n,
							voids: o,
							mode: s,
						}),
						d = R.previous(t, {
							at: r,
							match: n,
							voids: o,
							mode: s,
						});
					if (!(!c || !d)) {
						var [f, h] = c,
							[p, g] = d;
						if (!(h.length === 0 || g.length === 0)) {
							var v = Y.next(g),
								b = Y.common(h, g),
								y = Y.isSibling(h, g),
								x = Array.from(R.levels(t, { at: h }), ($) => {
									var [A] = $;
									return A;
								})
									.slice(b.length)
									.slice(0, -1),
								C = R.above(t, {
									at: h,
									mode: "highest",
									match: ($) => x.includes($) && az(t, $),
								}),
								k = C && R.pathRef(t, C[1]),
								w,
								D;
							if (Be.isText(f) && Be.isText(p)) {
								var S = vl(f, Yfe);
								(D = p.text.length), (w = S);
							} else if ($e.isElement(f) && $e.isElement(p)) {
								var S = vl(f, Jfe);
								(D = p.children.length), (w = S);
							} else
								throw new Error(
									"Cannot merge the node at path ["
										.concat(
											h,
											"] with the previous sibling because it is not the same kind: ",
										)
										.concat(dr.stringify(f), " ")
										.concat(dr.stringify(p)),
								);
							y || W.moveNodes(t, { at: h, to: v, voids: o }),
								k &&
									W.removeNodes(t, {
										at: k.current,
										voids: o,
									}),
								($e.isElement(p) && R.isEmpty(t, p)) ||
								(Be.isText(p) &&
									p.text === "" &&
									g[g.length - 1] !== 0)
									? W.removeNodes(t, { at: g, voids: o })
									: t.apply({
											type: "merge_node",
											path: v,
											position: D,
											properties: w,
										}),
								k && k.unref();
						}
					}
				}
			});
		},
		moveNodes(t, e) {
			R.withoutNormalizing(t, () => {
				var {
						to: n,
						at: r = t.selection,
						mode: i = "lowest",
						voids: o = !1,
					} = e,
					{ match: s } = e;
				if (r) {
					s == null &&
						(s = Y.isPath(r)
							? pf(t, r)
							: (h) => $e.isElement(h) && R.isBlock(t, h));
					var a = R.pathRef(t, n),
						l = R.nodes(t, { at: r, match: s, mode: i, voids: o }),
						u = Array.from(l, (h) => {
							var [, p] = h;
							return R.pathRef(t, p);
						});
					for (var c of u) {
						var d = c.unref(),
							f = a.current;
						d.length !== 0 &&
							t.apply({ type: "move_node", path: d, newPath: f }),
							a.current &&
								Y.isSibling(f, d) &&
								Y.isAfter(f, d) &&
								(a.current = Y.next(a.current));
					}
					a.unref();
				}
			});
		},
		removeNodes(t) {
			var e =
				arguments.length > 1 && arguments[1] !== void 0
					? arguments[1]
					: {};
			R.withoutNormalizing(t, () => {
				var { hanging: n = !1, voids: r = !1, mode: i = "lowest" } = e,
					{ at: o = t.selection, match: s } = e;
				if (o) {
					s == null &&
						(s = Y.isPath(o)
							? pf(t, o)
							: (f) => $e.isElement(f) && R.isBlock(t, f)),
						!n &&
							ie.isRange(o) &&
							(o = R.unhangRange(t, o, { voids: r }));
					var a = R.nodes(t, { at: o, match: s, mode: i, voids: r }),
						l = Array.from(a, (f) => {
							var [, h] = f;
							return R.pathRef(t, h);
						});
					for (var u of l) {
						var c = u.unref();
						if (c) {
							var [d] = R.node(t, c);
							t.apply({ type: "remove_node", path: c, node: d });
						}
					}
				}
			});
		},
		setNodes(t, e) {
			var n =
				arguments.length > 2 && arguments[2] !== void 0
					? arguments[2]
					: {};
			R.withoutNormalizing(t, () => {
				var { match: r, at: i = t.selection, compare: o, merge: s } = n,
					{
						hanging: a = !1,
						mode: l = "lowest",
						split: u = !1,
						voids: c = !1,
					} = n;
				if (i) {
					if (
						(r == null &&
							(r = Y.isPath(i)
								? pf(t, i)
								: (D) => $e.isElement(D) && R.isBlock(t, D)),
						!a &&
							ie.isRange(i) &&
							(i = R.unhangRange(t, i, { voids: c })),
						u && ie.isRange(i))
					) {
						if (
							ie.isCollapsed(i) &&
							R.leaf(t, i.anchor)[0].text.length > 0
						)
							return;
						var d = R.rangeRef(t, i, { affinity: "inward" }),
							[f, h] = ie.edges(i),
							p = l === "lowest" ? "lowest" : "highest",
							g = R.isEnd(t, h, h.path);
						W.splitNodes(t, {
							at: h,
							match: r,
							mode: p,
							voids: c,
							always: !g,
						});
						var v = R.isStart(t, f, f.path);
						W.splitNodes(t, {
							at: f,
							match: r,
							mode: p,
							voids: c,
							always: !v,
						}),
							(i = d.unref()),
							n.at == null && W.select(t, i);
					}
					o || (o = (D, S) => D !== S);
					for (var [b, y] of R.nodes(t, {
						at: i,
						match: r,
						mode: l,
						voids: c,
					})) {
						var x = {},
							C = {};
						if (y.length !== 0) {
							var k = !1;
							for (var w in e)
								w === "children" ||
									w === "text" ||
									(o(e[w], b[w]) &&
										((k = !0),
										b.hasOwnProperty(w) && (x[w] = b[w]),
										s
											? e[w] != null &&
												(C[w] = s(b[w], e[w]))
											: e[w] != null && (C[w] = e[w])));
							k &&
								t.apply({
									type: "set_node",
									path: y,
									properties: x,
									newProperties: C,
								});
						}
					}
				}
			});
		},
		splitNodes(t) {
			var e =
				arguments.length > 1 && arguments[1] !== void 0
					? arguments[1]
					: {};
			R.withoutNormalizing(t, () => {
				var { mode: n = "lowest", voids: r = !1 } = e,
					{
						match: i,
						at: o = t.selection,
						height: s = 0,
						always: a = !1,
					} = e;
				if (
					(i == null &&
						(i = (V) => $e.isElement(V) && R.isBlock(t, V)),
					ie.isRange(o) && (o = Zfe(t, o)),
					Y.isPath(o))
				) {
					var l = o,
						u = R.point(t, l),
						[c] = R.parent(t, l);
					(i = (V) => V === c),
						(s = u.path.length - l.length + 1),
						(o = u),
						(a = !0);
				}
				if (o) {
					var d = R.pointRef(t, o, { affinity: "backward" }),
						f;
					try {
						var [h] = R.nodes(t, {
							at: o,
							match: i,
							mode: n,
							voids: r,
						});
						if (!h) return;
						var p = R.void(t, { at: o, mode: "highest" }),
							g = 0;
						if (!r && p) {
							var [v, b] = p;
							if ($e.isElement(v) && t.isInline(v)) {
								var y = R.after(t, b);
								if (!y) {
									var x = { text: "" },
										C = Y.next(b);
									W.insertNodes(t, x, { at: C, voids: r }),
										(y = R.point(t, C));
								}
								(o = y), (a = !0);
							}
							var k = o.path.length - b.length;
							(s = k + 1), (a = !0);
						}
						f = R.pointRef(t, o);
						var w = o.path.length - s,
							[, D] = h,
							S = o.path.slice(0, w),
							$ = s === 0 ? o.offset : o.path[w] + g;
						for (var [A, T] of R.levels(t, {
							at: S,
							reverse: !0,
							voids: r,
						})) {
							var I = !1;
							if (
								T.length < D.length ||
								T.length === 0 ||
								(!r && $e.isElement(A) && R.isVoid(t, A))
							)
								break;
							var F = d.current,
								N = R.isEnd(t, F, T);
							if (a || !d || !R.isEdge(t, F, T)) {
								I = !0;
								var O = pe.extractProps(A);
								t.apply({
									type: "split_node",
									path: T,
									position: $,
									properties: O,
								});
							}
							$ = T[T.length - 1] + (I || N ? 1 : 0);
						}
						if (e.at == null) {
							var _ = f.current || R.end(t, []);
							W.select(t, _);
						}
					} finally {
						var j;
						d.unref(),
							(j = f) === null || j === void 0 || j.unref();
					}
				}
			});
		},
		unsetNodes(t, e) {
			var n =
				arguments.length > 2 && arguments[2] !== void 0
					? arguments[2]
					: {};
			Array.isArray(e) || (e = [e]);
			var r = {};
			for (var i of e) r[i] = null;
			W.setNodes(t, r, n);
		},
		unwrapNodes(t) {
			var e =
				arguments.length > 1 && arguments[1] !== void 0
					? arguments[1]
					: {};
			R.withoutNormalizing(t, () => {
				var { mode: n = "lowest", split: r = !1, voids: i = !1 } = e,
					{ at: o = t.selection, match: s } = e;
				if (o) {
					s == null &&
						(s = Y.isPath(o)
							? pf(t, o)
							: (f) => $e.isElement(f) && R.isBlock(t, f)),
						Y.isPath(o) && (o = R.range(t, o));
					var a = ie.isRange(o) ? R.rangeRef(t, o) : null,
						l = R.nodes(t, { at: o, match: s, mode: n, voids: i }),
						u = Array.from(l, (f) => {
							var [, h] = f;
							return R.pathRef(t, h);
						}).reverse(),
						c = function (h) {
							var p = h.unref(),
								[g] = R.node(t, p),
								v = R.range(t, p);
							r && a && (v = ie.intersection(a.current, v)),
								W.liftNodes(t, {
									at: v,
									match: (b) =>
										$e.isAncestor(g) &&
										g.children.includes(b),
									voids: i,
								});
						};
					for (var d of u) c(d);
					a && a.unref();
				}
			});
		},
		wrapNodes(t, e) {
			var n =
				arguments.length > 2 && arguments[2] !== void 0
					? arguments[2]
					: {};
			R.withoutNormalizing(t, () => {
				var { mode: r = "lowest", split: i = !1, voids: o = !1 } = n,
					{ match: s, at: a = t.selection } = n;
				if (a) {
					if (
						(s == null &&
							(Y.isPath(a)
								? (s = pf(t, a))
								: t.isInline(e)
									? (s = (v) =>
											($e.isElement(v) &&
												R.isInline(t, v)) ||
											Be.isText(v))
									: (s = (v) =>
											$e.isElement(v) &&
											R.isBlock(t, v))),
						i && ie.isRange(a))
					) {
						var [l, u] = ie.edges(a),
							c = R.rangeRef(t, a, { affinity: "inward" });
						W.splitNodes(t, { at: u, match: s, voids: o }),
							W.splitNodes(t, { at: l, match: s, voids: o }),
							(a = c.unref()),
							n.at == null && W.select(t, a);
					}
					var d = Array.from(
						R.nodes(t, {
							at: a,
							match: t.isInline(e)
								? (v) => $e.isElement(v) && R.isBlock(t, v)
								: (v) => R.isEditor(v),
							mode: "lowest",
							voids: o,
						}),
					);
					for (var [, f] of d) {
						var h = ie.isRange(a)
							? ie.intersection(a, R.range(t, f))
							: a;
						if (h) {
							var p = Array.from(
								R.nodes(t, {
									at: h,
									match: s,
									mode: r,
									voids: o,
								}),
							);
							if (p.length > 0) {
								var g = (function () {
									var [v] = p,
										b = p[p.length - 1],
										[, y] = v,
										[, x] = b;
									if (y.length === 0 && x.length === 0)
										return "continue";
									var C = Y.equals(y, x)
											? Y.parent(y)
											: Y.common(y, x),
										k = R.range(t, y, x),
										w = R.node(t, C),
										[D] = w,
										S = C.length + 1,
										$ = Y.next(x.slice(0, S)),
										A = IT(IT({}, e), {}, { children: [] });
									W.insertNodes(t, A, { at: $, voids: o }),
										W.moveNodes(t, {
											at: k,
											match: (T) =>
												$e.isAncestor(D) &&
												D.children.includes(T),
											to: $.concat(0),
											voids: o,
										});
								})();
								if (g === "continue") continue;
							}
						}
					}
				}
			});
		},
	},
	az = (t, e) => {
		if ($e.isElement(e)) {
			var n = e;
			return R.isVoid(t, e)
				? !0
				: n.children.length === 1
					? az(t, n.children[0])
					: !1;
		} else return !R.isEditor(e);
	},
	Zfe = (t, e) => {
		if (ie.isCollapsed(e)) return e.anchor;
		var [, n] = ie.edges(e),
			r = R.pointRef(t, n);
		return W.delete(t, { at: e }), r.unref();
	},
	pf = (t, e) => {
		var [n] = R.node(t, e);
		return (r) => r === n;
	};
function FT(t, e) {
	var n = Object.keys(t);
	if (Object.getOwnPropertySymbols) {
		var r = Object.getOwnPropertySymbols(t);
		e &&
			(r = r.filter(function (i) {
				return Object.getOwnPropertyDescriptor(t, i).enumerable;
			})),
			n.push.apply(n, r);
	}
	return n;
}
function PT(t) {
	for (var e = 1; e < arguments.length; e++) {
		var n = arguments[e] != null ? arguments[e] : {};
		e % 2
			? FT(Object(n), !0).forEach(function (r) {
					Sa(t, r, n[r]);
				})
			: Object.getOwnPropertyDescriptors
				? Object.defineProperties(
						t,
						Object.getOwnPropertyDescriptors(n),
					)
				: FT(Object(n)).forEach(function (r) {
						Object.defineProperty(
							t,
							r,
							Object.getOwnPropertyDescriptor(n, r),
						);
					});
	}
	return t;
}
var Qfe = {
		collapse(t) {
			var e =
					arguments.length > 1 && arguments[1] !== void 0
						? arguments[1]
						: {},
				{ edge: n = "anchor" } = e,
				{ selection: r } = t;
			if (r) {
				if (n === "anchor") W.select(t, r.anchor);
				else if (n === "focus") W.select(t, r.focus);
				else if (n === "start") {
					var [i] = ie.edges(r);
					W.select(t, i);
				} else if (n === "end") {
					var [, o] = ie.edges(r);
					W.select(t, o);
				}
			} else return;
		},
		deselect(t) {
			var { selection: e } = t;
			e &&
				t.apply({
					type: "set_selection",
					properties: e,
					newProperties: null,
				});
		},
		move(t) {
			var e =
					arguments.length > 1 && arguments[1] !== void 0
						? arguments[1]
						: {},
				{ selection: n } = t,
				{ distance: r = 1, unit: i = "character", reverse: o = !1 } = e,
				{ edge: s = null } = e;
			if (n) {
				s === "start" && (s = ie.isBackward(n) ? "focus" : "anchor"),
					s === "end" && (s = ie.isBackward(n) ? "anchor" : "focus");
				var { anchor: a, focus: l } = n,
					u = { distance: r, unit: i },
					c = {};
				if (s == null || s === "anchor") {
					var d = o ? R.before(t, a, u) : R.after(t, a, u);
					d && (c.anchor = d);
				}
				if (s == null || s === "focus") {
					var f = o ? R.before(t, l, u) : R.after(t, l, u);
					f && (c.focus = f);
				}
				W.setSelection(t, c);
			}
		},
		select(t, e) {
			var { selection: n } = t;
			if (((e = R.range(t, e)), n)) {
				W.setSelection(t, e);
				return;
			}
			if (!ie.isRange(e))
				throw new Error(
					"When setting the selection and the current selection is `null` you must provide at least an `anchor` and `focus`, but you passed: ".concat(
						dr.stringify(e),
					),
				);
			t.apply({ type: "set_selection", properties: n, newProperties: e });
		},
		setPoint(t, e) {
			var n =
					arguments.length > 2 && arguments[2] !== void 0
						? arguments[2]
						: {},
				{ selection: r } = t,
				{ edge: i = "both" } = n;
			if (r) {
				i === "start" && (i = ie.isBackward(r) ? "focus" : "anchor"),
					i === "end" && (i = ie.isBackward(r) ? "anchor" : "focus");
				var { anchor: o, focus: s } = r,
					a = i === "anchor" ? o : s;
				W.setSelection(t, {
					[i === "anchor" ? "anchor" : "focus"]: PT(PT({}, a), e),
				});
			}
		},
		setSelection(t, e) {
			var { selection: n } = t,
				r = {},
				i = {};
			if (n) {
				for (var o in e)
					((o === "anchor" &&
						e.anchor != null &&
						!ut.equals(e.anchor, n.anchor)) ||
						(o === "focus" &&
							e.focus != null &&
							!ut.equals(e.focus, n.focus)) ||
						(o !== "anchor" && o !== "focus" && e[o] !== n[o])) &&
						((r[o] = n[o]), (i[o] = e[o]));
				Object.keys(r).length > 0 &&
					t.apply({
						type: "set_selection",
						properties: r,
						newProperties: i,
					});
			}
		},
	},
	ehe = {
		delete(t) {
			var e =
				arguments.length > 1 && arguments[1] !== void 0
					? arguments[1]
					: {};
			R.withoutNormalizing(t, () => {
				var {
						reverse: n = !1,
						unit: r = "character",
						distance: i = 1,
						voids: o = !1,
					} = e,
					{ at: s = t.selection, hanging: a = !1 } = e;
				if (s) {
					var l = !1;
					if (
						(ie.isRange(s) &&
							ie.isCollapsed(s) &&
							((l = !0), (s = s.anchor)),
						ut.isPoint(s))
					) {
						var u = R.void(t, { at: s, mode: "highest" });
						if (!o && u) {
							var [, c] = u;
							s = c;
						} else {
							var d = { unit: r, distance: i },
								f = n
									? R.before(t, s, d) || R.start(t, [])
									: R.after(t, s, d) || R.end(t, []);
							(s = { anchor: s, focus: f }), (a = !0);
						}
					}
					if (Y.isPath(s)) {
						W.removeNodes(t, { at: s, voids: o });
						return;
					}
					if (!ie.isCollapsed(s)) {
						if (!a) {
							var [, h] = ie.edges(s),
								p = R.end(t, []);
							ut.equals(h, p) ||
								(s = R.unhangRange(t, s, { voids: o }));
						}
						var [g, v] = ie.edges(s),
							b = R.above(t, {
								match: (re) =>
									$e.isElement(re) && R.isBlock(t, re),
								at: g,
								voids: o,
							}),
							y = R.above(t, {
								match: (re) =>
									$e.isElement(re) && R.isBlock(t, re),
								at: v,
								voids: o,
							}),
							x = b && y && !Y.equals(b[1], y[1]),
							C = Y.equals(g.path, v.path),
							k = o
								? null
								: R.void(t, { at: g, mode: "highest" }),
							w = o
								? null
								: R.void(t, { at: v, mode: "highest" });
						if (k) {
							var D = R.before(t, g);
							D && b && Y.isAncestor(b[1], D.path) && (g = D);
						}
						if (w) {
							var S = R.after(t, v);
							S && y && Y.isAncestor(y[1], S.path) && (v = S);
						}
						var $ = [],
							A;
						for (var T of R.nodes(t, { at: s, voids: o })) {
							var [I, F] = T;
							(A && Y.compare(F, A) === 0) ||
								(((!o && $e.isElement(I) && R.isVoid(t, I)) ||
									(!Y.isCommon(F, g.path) &&
										!Y.isCommon(F, v.path))) &&
									($.push(T), (A = F)));
						}
						var N = Array.from($, (re) => {
								var [, he] = re;
								return R.pathRef(t, he);
							}),
							O = R.pointRef(t, g),
							_ = R.pointRef(t, v),
							j = "";
						if (!C && !k) {
							var V = O.current,
								[K] = R.leaf(t, V),
								{ path: M } = V,
								{ offset: G } = g,
								H = K.text.slice(G);
							H.length > 0 &&
								(t.apply({
									type: "remove_text",
									path: M,
									offset: G,
									text: H,
								}),
								(j = H));
						}
						if (
							(N.reverse()
								.map((re) => re.unref())
								.filter((re) => re !== null)
								.forEach((re) =>
									W.removeNodes(t, { at: re, voids: o }),
								),
							!w)
						) {
							var P = _.current,
								[q] = R.leaf(t, P),
								{ path: J } = P,
								Z = C ? g.offset : 0,
								oe = q.text.slice(Z, v.offset);
							oe.length > 0 &&
								(t.apply({
									type: "remove_text",
									path: J,
									offset: Z,
									text: oe,
								}),
								(j = oe));
						}
						!C &&
							x &&
							_.current &&
							O.current &&
							W.mergeNodes(t, {
								at: _.current,
								hanging: !0,
								voids: o,
							}),
							l &&
								n &&
								r === "character" &&
								j.length > 1 &&
								j.match(/[\u0E00-\u0E7F]+/) &&
								W.insertText(t, j.slice(0, j.length - i));
						var ne = O.unref(),
							de = _.unref(),
							se = n ? ne || de : de || ne;
						e.at == null && se && W.select(t, se);
					}
				}
			});
		},
		insertFragment(t, e) {
			var n =
				arguments.length > 2 && arguments[2] !== void 0
					? arguments[2]
					: {};
			R.withoutNormalizing(t, () => {
				var { hanging: r = !1, voids: i = !1 } = n,
					{ at: o = t.selection } = n;
				if (e.length) {
					if (o)
						if (ie.isRange(o))
							if (
								(r || (o = R.unhangRange(t, o, { voids: i })),
								ie.isCollapsed(o))
							)
								o = o.anchor;
							else {
								var [, s] = ie.edges(o);
								if (!i && R.void(t, { at: s })) return;
								var a = R.pointRef(t, s);
								W.delete(t, { at: o }), (o = a.unref());
							}
						else Y.isPath(o) && (o = R.start(t, o));
					else return;
					if (!(!i && R.void(t, { at: o }))) {
						var l = R.above(t, {
							at: o,
							match: (P) => $e.isElement(P) && R.isInline(t, P),
							mode: "highest",
							voids: i,
						});
						if (l) {
							var [, u] = l;
							if (R.isEnd(t, o, u)) {
								var c = R.after(t, u);
								o = c;
							} else if (R.isStart(t, o, u)) {
								var d = R.before(t, u);
								o = d;
							}
						}
						var f = R.above(t, {
								match: (P) =>
									$e.isElement(P) && R.isBlock(t, P),
								at: o,
								voids: i,
							}),
							[, h] = f,
							p = R.isStart(t, o, h),
							g = R.isEnd(t, o, h),
							v = p && g,
							b = !p || (p && g),
							y = !g,
							[, x] = pe.first({ children: e }, []),
							[, C] = pe.last({ children: e }, []),
							k = [],
							w = (P) => {
								var [q, J] = P,
									Z = J.length === 0;
								return Z
									? !1
									: v
										? !0
										: !(
												(b &&
													Y.isAncestor(J, x) &&
													$e.isElement(q) &&
													!t.isVoid(q) &&
													!t.isInline(q)) ||
												(y &&
													Y.isAncestor(J, C) &&
													$e.isElement(q) &&
													!t.isVoid(q) &&
													!t.isInline(q))
											);
							};
						for (var D of pe.nodes({ children: e }, { pass: w }))
							w(D) && k.push(D);
						var S = [],
							$ = [],
							A = [],
							T = !0,
							I = !1;
						for (var [F] of k)
							$e.isElement(F) && !t.isInline(F)
								? ((T = !1), (I = !0), $.push(F))
								: T
									? S.push(F)
									: A.push(F);
						var [N] = R.nodes(t, {
								at: o,
								match: (P) => Be.isText(P) || R.isInline(t, P),
								mode: "highest",
								voids: i,
							}),
							[, O] = N,
							_ = R.isStart(t, o, O),
							j = R.isEnd(t, o, O),
							V = R.pathRef(t, g && !A.length ? Y.next(h) : h),
							K = R.pathRef(t, j ? Y.next(O) : O);
						W.splitNodes(t, {
							at: o,
							match: (P) =>
								I
									? $e.isElement(P) && R.isBlock(t, P)
									: Be.isText(P) || R.isInline(t, P),
							mode: I ? "lowest" : "highest",
							always:
								I &&
								(!p || S.length > 0) &&
								(!g || A.length > 0),
							voids: i,
						});
						var M = R.pathRef(t, !_ || (_ && j) ? Y.next(O) : O);
						if (
							(W.insertNodes(t, S, {
								at: M.current,
								match: (P) => Be.isText(P) || R.isInline(t, P),
								mode: "highest",
								voids: i,
							}),
							v &&
								!S.length &&
								$.length &&
								!A.length &&
								W.delete(t, { at: h, voids: i }),
							W.insertNodes(t, $, {
								at: V.current,
								match: (P) =>
									$e.isElement(P) && R.isBlock(t, P),
								mode: "lowest",
								voids: i,
							}),
							W.insertNodes(t, A, {
								at: K.current,
								match: (P) => Be.isText(P) || R.isInline(t, P),
								mode: "highest",
								voids: i,
							}),
							!n.at)
						) {
							var G;
							if (
								(A.length > 0 && K.current
									? (G = Y.previous(K.current))
									: $.length > 0 && V.current
										? (G = Y.previous(V.current))
										: M.current &&
											(G = Y.previous(M.current)),
								G)
							) {
								var H = R.end(t, G);
								W.select(t, H);
							}
						}
						M.unref(), V.unref(), K.unref();
					}
				}
			});
		},
		insertText(t, e) {
			var n =
				arguments.length > 2 && arguments[2] !== void 0
					? arguments[2]
					: {};
			R.withoutNormalizing(t, () => {
				var { voids: r = !1 } = n,
					{ at: i = t.selection } = n;
				if (i) {
					if ((Y.isPath(i) && (i = R.range(t, i)), ie.isRange(i)))
						if (ie.isCollapsed(i)) i = i.anchor;
						else {
							var o = ie.end(i);
							if (!r && R.void(t, { at: o })) return;
							var s = ie.start(i),
								a = R.pointRef(t, s),
								l = R.pointRef(t, o);
							W.delete(t, { at: i, voids: r });
							var u = a.unref(),
								c = l.unref();
							(i = u || c),
								W.setSelection(t, { anchor: i, focus: i });
						}
					if (!(!r && R.void(t, { at: i }))) {
						var { path: d, offset: f } = i;
						e.length > 0 &&
							t.apply({
								type: "insert_text",
								path: d,
								offset: f,
								text: e,
							});
					}
				}
			});
		},
	};
function NT(t, e) {
	var n = Object.keys(t);
	if (Object.getOwnPropertySymbols) {
		var r = Object.getOwnPropertySymbols(t);
		e &&
			(r = r.filter(function (i) {
				return Object.getOwnPropertyDescriptor(t, i).enumerable;
			})),
			n.push.apply(n, r);
	}
	return n;
}
function D1(t) {
	for (var e = 1; e < arguments.length; e++) {
		var n = arguments[e] != null ? arguments[e] : {};
		e % 2
			? NT(Object(n), !0).forEach(function (r) {
					Sa(t, r, n[r]);
				})
			: Object.getOwnPropertyDescriptors
				? Object.defineProperties(
						t,
						Object.getOwnPropertyDescriptors(n),
					)
				: NT(Object(n)).forEach(function (r) {
						Object.defineProperty(
							t,
							r,
							Object.getOwnPropertyDescriptor(n, r),
						);
					});
	}
	return t;
}
var W = D1(D1(D1(D1({}, Gfe), Xfe), Qfe), ehe),
	Xc = [],
	the = function () {
		return Xc.some(function (t) {
			return t.activeTargets.length > 0;
		});
	},
	nhe = function () {
		return Xc.some(function (t) {
			return t.skippedTargets.length > 0;
		});
	},
	RT = "ResizeObserver loop completed with undelivered notifications.",
	rhe = function () {
		var t;
		typeof ErrorEvent == "function"
			? (t = new ErrorEvent("error", { message: RT }))
			: ((t = document.createEvent("Event")),
				t.initEvent("error", !1, !1),
				(t.message = RT)),
			window.dispatchEvent(t);
	},
	ig;
(function (t) {
	(t.BORDER_BOX = "border-box"),
		(t.CONTENT_BOX = "content-box"),
		(t.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box");
})(ig || (ig = {}));
var Zc = function (t) {
		return Object.freeze(t);
	},
	ihe = (function () {
		function t(e, n) {
			(this.inlineSize = e), (this.blockSize = n), Zc(this);
		}
		return t;
	})(),
	lz = (function () {
		function t(e, n, r, i) {
			return (
				(this.x = e),
				(this.y = n),
				(this.width = r),
				(this.height = i),
				(this.top = this.y),
				(this.left = this.x),
				(this.bottom = this.top + this.height),
				(this.right = this.left + this.width),
				Zc(this)
			);
		}
		return (
			(t.prototype.toJSON = function () {
				var e = this,
					n = e.x,
					r = e.y,
					i = e.top,
					o = e.right,
					s = e.bottom,
					a = e.left,
					l = e.width,
					u = e.height;
				return {
					x: n,
					y: r,
					top: i,
					right: o,
					bottom: s,
					left: a,
					width: l,
					height: u,
				};
			}),
			(t.fromRect = function (e) {
				return new t(e.x, e.y, e.width, e.height);
			}),
			t
		);
	})(),
	fS = function (t) {
		return t instanceof SVGElement && "getBBox" in t;
	},
	uz = function (t) {
		if (fS(t)) {
			var e = t.getBBox(),
				n = e.width,
				r = e.height;
			return !n && !r;
		}
		var i = t,
			o = i.offsetWidth,
			s = i.offsetHeight;
		return !(o || s || t.getClientRects().length);
	},
	OT = function (t) {
		var e;
		if (t instanceof Element) return !0;
		var n =
			(e = t == null ? void 0 : t.ownerDocument) === null || e === void 0
				? void 0
				: e.defaultView;
		return !!(n && t instanceof n.Element);
	},
	ohe = function (t) {
		switch (t.tagName) {
			case "INPUT":
				if (t.type !== "image") break;
			case "VIDEO":
			case "AUDIO":
			case "EMBED":
			case "OBJECT":
			case "CANVAS":
			case "IFRAME":
			case "IMG":
				return !0;
		}
		return !1;
	},
	xm = typeof window < "u" ? window : {},
	S1 = new WeakMap(),
	MT = /auto|scroll/,
	she = /^tb|vertical/,
	ahe = /msie|trident/i.test(xm.navigator && xm.navigator.userAgent),
	Vs = function (t) {
		return parseFloat(t || "0");
	},
	oh = function (t, e, n) {
		return (
			t === void 0 && (t = 0),
			e === void 0 && (e = 0),
			n === void 0 && (n = !1),
			new ihe((n ? e : t) || 0, (n ? t : e) || 0)
		);
	},
	jT = Zc({
		devicePixelContentBoxSize: oh(),
		borderBoxSize: oh(),
		contentBoxSize: oh(),
		contentRect: new lz(0, 0, 0, 0),
	}),
	cz = function (t, e) {
		if ((e === void 0 && (e = !1), S1.has(t) && !e)) return S1.get(t);
		if (uz(t)) return S1.set(t, jT), jT;
		var n = getComputedStyle(t),
			r = fS(t) && t.ownerSVGElement && t.getBBox(),
			i = !ahe && n.boxSizing === "border-box",
			o = she.test(n.writingMode || ""),
			s = !r && MT.test(n.overflowY || ""),
			a = !r && MT.test(n.overflowX || ""),
			l = r ? 0 : Vs(n.paddingTop),
			u = r ? 0 : Vs(n.paddingRight),
			c = r ? 0 : Vs(n.paddingBottom),
			d = r ? 0 : Vs(n.paddingLeft),
			f = r ? 0 : Vs(n.borderTopWidth),
			h = r ? 0 : Vs(n.borderRightWidth),
			p = r ? 0 : Vs(n.borderBottomWidth),
			g = r ? 0 : Vs(n.borderLeftWidth),
			v = d + u,
			b = l + c,
			y = g + h,
			x = f + p,
			C = a ? t.offsetHeight - x - t.clientHeight : 0,
			k = s ? t.offsetWidth - y - t.clientWidth : 0,
			w = i ? v + y : 0,
			D = i ? b + x : 0,
			S = r ? r.width : Vs(n.width) - w - k,
			$ = r ? r.height : Vs(n.height) - D - C,
			A = S + v + k + y,
			T = $ + b + C + x,
			I = Zc({
				devicePixelContentBoxSize: oh(
					Math.round(S * devicePixelRatio),
					Math.round($ * devicePixelRatio),
					o,
				),
				borderBoxSize: oh(A, T, o),
				contentBoxSize: oh(S, $, o),
				contentRect: new lz(d, l, S, $),
			});
		return S1.set(t, I), I;
	},
	dz = function (t, e, n) {
		var r = cz(t, n),
			i = r.borderBoxSize,
			o = r.contentBoxSize,
			s = r.devicePixelContentBoxSize;
		switch (e) {
			case ig.DEVICE_PIXEL_CONTENT_BOX:
				return s;
			case ig.BORDER_BOX:
				return i;
			default:
				return o;
		}
	},
	lhe = (function () {
		function t(e) {
			var n = cz(e);
			(this.target = e),
				(this.contentRect = n.contentRect),
				(this.borderBoxSize = Zc([n.borderBoxSize])),
				(this.contentBoxSize = Zc([n.contentBoxSize])),
				(this.devicePixelContentBoxSize = Zc([
					n.devicePixelContentBoxSize,
				]));
		}
		return t;
	})(),
	fz = function (t) {
		if (uz(t)) return 1 / 0;
		for (var e = 0, n = t.parentNode; n; ) (e += 1), (n = n.parentNode);
		return e;
	},
	uhe = function () {
		var t = 1 / 0,
			e = [];
		Xc.forEach(function (s) {
			if (s.activeTargets.length !== 0) {
				var a = [];
				s.activeTargets.forEach(function (u) {
					var c = new lhe(u.target),
						d = fz(u.target);
					a.push(c),
						(u.lastReportedSize = dz(u.target, u.observedBox)),
						d < t && (t = d);
				}),
					e.push(function () {
						s.callback.call(s.observer, a, s.observer);
					}),
					s.activeTargets.splice(0, s.activeTargets.length);
			}
		});
		for (var n = 0, r = e; n < r.length; n++) {
			var i = r[n];
			i();
		}
		return t;
	},
	_T = function (t) {
		Xc.forEach(function (n) {
			n.activeTargets.splice(0, n.activeTargets.length),
				n.skippedTargets.splice(0, n.skippedTargets.length),
				n.observationTargets.forEach(function (i) {
					i.isActive() &&
						(fz(i.target) > t
							? n.activeTargets.push(i)
							: n.skippedTargets.push(i));
				});
		});
	},
	che = function () {
		var t = 0;
		for (_T(t); the(); ) (t = uhe()), _T(t);
		return nhe() && rhe(), t > 0;
	},
	hk,
	hz = [],
	dhe = function () {
		return hz.splice(0).forEach(function (t) {
			return t();
		});
	},
	fhe = function (t) {
		if (!hk) {
			var e = 0,
				n = document.createTextNode(""),
				r = { characterData: !0 };
			new MutationObserver(function () {
				return dhe();
			}).observe(n, r),
				(hk = function () {
					n.textContent = "".concat(e ? e-- : e++);
				});
		}
		hz.push(t), hk();
	},
	hhe = function (t) {
		fhe(function () {
			requestAnimationFrame(t);
		});
	},
	fb = 0,
	phe = function () {
		return !!fb;
	},
	mhe = 250,
	ghe = { attributes: !0, characterData: !0, childList: !0, subtree: !0 },
	zT = [
		"resize",
		"load",
		"transitionend",
		"animationend",
		"animationstart",
		"animationiteration",
		"keyup",
		"keydown",
		"mouseup",
		"mousedown",
		"mouseover",
		"mouseout",
		"blur",
		"focus",
	],
	LT = function (t) {
		return t === void 0 && (t = 0), Date.now() + t;
	},
	pk = !1,
	bhe = (function () {
		function t() {
			var e = this;
			(this.stopped = !0),
				(this.listener = function () {
					return e.schedule();
				});
		}
		return (
			(t.prototype.run = function (e) {
				var n = this;
				if ((e === void 0 && (e = mhe), !pk)) {
					pk = !0;
					var r = LT(e);
					hhe(function () {
						var i = !1;
						try {
							i = che();
						} finally {
							if (((pk = !1), (e = r - LT()), !phe())) return;
							i ? n.run(1e3) : e > 0 ? n.run(e) : n.start();
						}
					});
				}
			}),
			(t.prototype.schedule = function () {
				this.stop(), this.run();
			}),
			(t.prototype.observe = function () {
				var e = this,
					n = function () {
						return (
							e.observer && e.observer.observe(document.body, ghe)
						);
					};
				document.body
					? n()
					: xm.addEventListener("DOMContentLoaded", n);
			}),
			(t.prototype.start = function () {
				var e = this;
				this.stopped &&
					((this.stopped = !1),
					(this.observer = new MutationObserver(this.listener)),
					this.observe(),
					zT.forEach(function (n) {
						return xm.addEventListener(n, e.listener, !0);
					}));
			}),
			(t.prototype.stop = function () {
				var e = this;
				this.stopped ||
					(this.observer && this.observer.disconnect(),
					zT.forEach(function (n) {
						return xm.removeEventListener(n, e.listener, !0);
					}),
					(this.stopped = !0));
			}),
			t
		);
	})(),
	_w = new bhe(),
	VT = function (t) {
		!fb && t > 0 && _w.start(), (fb += t), !fb && _w.stop();
	},
	vhe = function (t) {
		return !fS(t) && !ohe(t) && getComputedStyle(t).display === "inline";
	},
	yhe = (function () {
		function t(e, n) {
			(this.target = e),
				(this.observedBox = n || ig.CONTENT_BOX),
				(this.lastReportedSize = { inlineSize: 0, blockSize: 0 });
		}
		return (
			(t.prototype.isActive = function () {
				var e = dz(this.target, this.observedBox, !0);
				return (
					vhe(this.target) && (this.lastReportedSize = e),
					this.lastReportedSize.inlineSize !== e.inlineSize ||
						this.lastReportedSize.blockSize !== e.blockSize
				);
			}),
			t
		);
	})(),
	xhe = (function () {
		function t(e, n) {
			(this.activeTargets = []),
				(this.skippedTargets = []),
				(this.observationTargets = []),
				(this.observer = e),
				(this.callback = n);
		}
		return t;
	})(),
	A1 = new WeakMap(),
	KT = function (t, e) {
		for (var n = 0; n < t.length; n += 1) if (t[n].target === e) return n;
		return -1;
	},
	$1 = (function () {
		function t() {}
		return (
			(t.connect = function (e, n) {
				var r = new xhe(e, n);
				A1.set(e, r);
			}),
			(t.observe = function (e, n, r) {
				var i = A1.get(e),
					o = i.observationTargets.length === 0;
				KT(i.observationTargets, n) < 0 &&
					(o && Xc.push(i),
					i.observationTargets.push(new yhe(n, r && r.box)),
					VT(1),
					_w.schedule());
			}),
			(t.unobserve = function (e, n) {
				var r = A1.get(e),
					i = KT(r.observationTargets, n),
					o = r.observationTargets.length === 1;
				i >= 0 &&
					(o && Xc.splice(Xc.indexOf(r), 1),
					r.observationTargets.splice(i, 1),
					VT(-1));
			}),
			(t.disconnect = function (e) {
				var n = this,
					r = A1.get(e);
				r.observationTargets.slice().forEach(function (i) {
					return n.unobserve(e, i.target);
				}),
					r.activeTargets.splice(0, r.activeTargets.length);
			}),
			t
		);
	})(),
	khe = (function () {
		function t(e) {
			if (arguments.length === 0)
				throw new TypeError(
					"Failed to construct 'ResizeObserver': 1 argument required, but only 0 present.",
				);
			if (typeof e != "function")
				throw new TypeError(
					"Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function.",
				);
			$1.connect(this, e);
		}
		return (
			(t.prototype.observe = function (e, n) {
				if (arguments.length === 0)
					throw new TypeError(
						"Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present.",
					);
				if (!OT(e))
					throw new TypeError(
						"Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element",
					);
				$1.observe(this, e, n);
			}),
			(t.prototype.unobserve = function (e) {
				if (arguments.length === 0)
					throw new TypeError(
						"Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present.",
					);
				if (!OT(e))
					throw new TypeError(
						"Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element",
					);
				$1.unobserve(this, e);
			}),
			(t.prototype.disconnect = function () {
				$1.disconnect(this);
			}),
			(t.toString = function () {
				return "function ResizeObserver () { [polyfill code] }";
			}),
			t
		);
	})(),
	Fl = {};
Object.defineProperty(Fl, "__esModule", { value: !0 });
var Che =
		typeof window < "u" &&
		/Mac|iPod|iPhone|iPad/.test(window.navigator.platform),
	mk = {
		alt: "altKey",
		control: "ctrlKey",
		meta: "metaKey",
		shift: "shiftKey",
	},
	whe = {
		add: "+",
		break: "pause",
		cmd: "meta",
		command: "meta",
		ctl: "control",
		ctrl: "control",
		del: "delete",
		down: "arrowdown",
		esc: "escape",
		ins: "insert",
		left: "arrowleft",
		mod: Che ? "meta" : "control",
		opt: "alt",
		option: "alt",
		return: "enter",
		right: "arrowright",
		space: " ",
		spacebar: " ",
		up: "arrowup",
		win: "meta",
		windows: "meta",
	},
	pz = {
		backspace: 8,
		tab: 9,
		enter: 13,
		shift: 16,
		control: 17,
		alt: 18,
		pause: 19,
		capslock: 20,
		escape: 27,
		" ": 32,
		pageup: 33,
		pagedown: 34,
		end: 35,
		home: 36,
		arrowleft: 37,
		arrowup: 38,
		arrowright: 39,
		arrowdown: 40,
		insert: 45,
		delete: 46,
		meta: 91,
		numlock: 144,
		scrolllock: 145,
		";": 186,
		"=": 187,
		",": 188,
		"-": 189,
		".": 190,
		"/": 191,
		"`": 192,
		"[": 219,
		"\\": 220,
		"]": 221,
		"'": 222,
	};
for (var T1 = 1; T1 < 20; T1++) pz["f" + T1] = 111 + T1;
function Hx(t, e, n) {
	e && !("byKey" in e) && ((n = e), (e = null)),
		Array.isArray(t) || (t = [t]);
	var r = t.map(function (s) {
			return mz(s, e);
		}),
		i = function (a) {
			return r.some(function (l) {
				return gz(l, a);
			});
		},
		o = n == null ? i : i(n);
	return o;
}
function Ehe(t, e) {
	return Hx(t, e);
}
function Dhe(t, e) {
	return Hx(t, { byKey: !0 }, e);
}
function mz(t, e) {
	var n = e && e.byKey,
		r = {};
	t = t.replace("++", "+add");
	var i = t.split("+"),
		o = i.length;
	for (var s in mk) r[mk[s]] = !1;
	var a = !0,
		l = !1,
		u = void 0;
	try {
		for (
			var c = i[Symbol.iterator](), d;
			!(a = (d = c.next()).done);
			a = !0
		) {
			var f = d.value,
				h = f.endsWith("?") && f.length > 1;
			h && (f = f.slice(0, -1));
			var p = hS(f),
				g = mk[p];
			(o === 1 || !g) && (n ? (r.key = p) : (r.which = bz(f))),
				g && (r[g] = h ? null : !0);
		}
	} catch (v) {
		(l = !0), (u = v);
	} finally {
		try {
			!a && c.return && c.return();
		} finally {
			if (l) throw u;
		}
	}
	return r;
}
function gz(t, e) {
	for (var n in t) {
		var r = t[n],
			i = void 0;
		if (
			r != null &&
			(n === "key" && e.key != null
				? (i = e.key.toLowerCase())
				: n === "which"
					? (i = r === 91 && e.which === 93 ? 91 : e.which)
					: (i = e[n]),
			!(i == null && r === !1) && i !== r)
		)
			return !1;
	}
	return !0;
}
function bz(t) {
	t = hS(t);
	var e = pz[t] || t.toUpperCase().charCodeAt(0);
	return e;
}
function hS(t) {
	return (t = t.toLowerCase()), (t = whe[t] || t), t;
}
Fl.default = Hx;
Fl.isHotkey = Hx;
Fl.isCodeHotkey = Ehe;
var gk = (Fl.isKeyHotkey = Dhe);
Fl.parseHotkey = mz;
Fl.compareHotkey = gz;
Fl.toKeyCode = bz;
Fl.toKeyName = hS;
function Wx(t, e, n) {
	return (
		e in t
			? Object.defineProperty(t, e, {
					value: n,
					enumerable: !0,
					configurable: !0,
					writable: !0,
				})
			: (t[e] = n),
		t
	);
}
function She(t, e) {
	if (t == null) return {};
	var n = {},
		r = Object.keys(t),
		i,
		o;
	for (o = 0; o < r.length; o++)
		(i = r[o]), !(e.indexOf(i) >= 0) && (n[i] = t[i]);
	return n;
}
function Sh(t, e) {
	if (t == null) return {};
	var n = She(t, e),
		r,
		i;
	if (Object.getOwnPropertySymbols) {
		var o = Object.getOwnPropertySymbols(t);
		for (i = 0; i < o.length; i++)
			(r = o[i]),
				!(e.indexOf(r) >= 0) &&
					Object.prototype.propertyIsEnumerable.call(t, r) &&
					(n[r] = t[r]);
	}
	return n;
}
var Ahe = 0;
class $he {
	constructor() {
		this.id = "".concat(Ahe++);
	}
}
var pS = new WeakMap(),
	mS = new WeakMap(),
	vz = new WeakMap(),
	hb = new WeakMap(),
	km = new WeakMap(),
	og = new WeakMap(),
	Qc = new WeakMap(),
	zw = new WeakMap(),
	qx = new WeakMap(),
	Lw = new WeakMap(),
	Pc = new WeakMap(),
	Nc = new WeakMap(),
	Cm = new WeakMap(),
	Vw = new WeakMap(),
	gS = new WeakMap(),
	ks = new WeakMap(),
	Qa = new WeakMap(),
	Ti = new WeakMap(),
	Ql = new WeakMap(),
	eu = new WeakMap(),
	Uv = new WeakMap(),
	Ah = Symbol("placeholder"),
	yz = Symbol("mark-placeholder"),
	The = globalThis.Text,
	bS = (t) => (t && t.ownerDocument && t.ownerDocument.defaultView) || null,
	Bhe = (t) => wd(t) && t.nodeType === 8,
	No = (t) => wd(t) && t.nodeType === 1,
	wd = (t) => {
		var e = bS(t);
		return !!e && t instanceof e.Node;
	},
	Kw = (t) => {
		var e = t && t.anchorNode && bS(t.anchorNode);
		return !!e && t instanceof e.Selection;
	},
	xz = (t) => wd(t) && t.nodeType === 3,
	Ihe = (t) =>
		t.clipboardData &&
		t.clipboardData.getData("text/plain") !== "" &&
		t.clipboardData.types.length === 1,
	Fhe = (t) => {
		var [e, n] = t;
		if (No(e) && e.childNodes.length) {
			var r = n === e.childNodes.length,
				i = r ? n - 1 : n;
			for (
				[e, i] = kz(e, i, r ? "backward" : "forward"), r = i < n;
				No(e) && e.childNodes.length;

			) {
				var o = r ? e.childNodes.length - 1 : 0;
				e = Nhe(e, o, r ? "backward" : "forward");
			}
			n = r && e.textContent != null ? e.textContent.length : 0;
		}
		return [e, n];
	},
	Phe = (t) => {
		for (var e = t && t.parentNode; e; ) {
			if (e.toString() === "[object ShadowRoot]") return !0;
			e = e.parentNode;
		}
		return !1;
	},
	kz = (t, e, n) => {
		for (
			var { childNodes: r } = t, i = r[e], o = e, s = !1, a = !1;
			(Bhe(i) ||
				(No(i) && i.childNodes.length === 0) ||
				(No(i) && i.getAttribute("contenteditable") === "false")) &&
			!(s && a);

		) {
			if (o >= r.length) {
				(s = !0), (o = e - 1), (n = "backward");
				continue;
			}
			if (o < 0) {
				(a = !0), (o = e + 1), (n = "forward");
				continue;
			}
			(i = r[o]), (e = o), (o += n === "forward" ? 1 : -1);
		}
		return [i, e];
	},
	Nhe = (t, e, n) => {
		var [r] = kz(t, e, n);
		return r;
	},
	Cz = (t) => {
		var e = "";
		if (xz(t) && t.nodeValue) return t.nodeValue;
		if (No(t)) {
			for (var n of Array.from(t.childNodes)) e += Cz(n);
			var r = getComputedStyle(t).getPropertyValue("display");
			(r === "block" || r === "list" || t.tagName === "BR") &&
				(e += `
`);
		}
		return e;
	},
	Rhe = /data-slate-fragment="(.+?)"/m,
	Ohe = (t) => {
		var e = t.getData("text/html"),
			[, n] = e.match(Rhe) || [];
		return n;
	},
	vS = (t, e, n) => {
		var { target: r } = e;
		if (No(r) && r.matches('[contentEditable="false"]')) return !1;
		var { document: i } = te.getWindow(t);
		if (i.contains(r)) return te.hasDOMNode(t, r, { editable: !0 });
		var o = n.find((s) => {
			var { addedNodes: a, removedNodes: l } = s;
			for (var u of a) if (u === r || u.contains(r)) return !0;
			for (var c of l) if (c === r || c.contains(r)) return !0;
		});
		return !o || o === e ? !1 : vS(t, o, n);
	},
	Mhe = parseInt(le.version.split(".")[0], 10) >= 17,
	jhe =
		typeof navigator < "u" &&
		typeof window < "u" &&
		/iPad|iPhone|iPod/.test(navigator.userAgent) &&
		!window.MSStream,
	UT = typeof navigator < "u" && /Mac OS X/.test(navigator.userAgent),
	_o = typeof navigator < "u" && /Android/.test(navigator.userAgent),
	Hv =
		typeof navigator < "u" &&
		/^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent),
	B1 =
		typeof navigator < "u" &&
		/Version\/[\d\.]+.*Safari/.test(navigator.userAgent),
	_he =
		typeof navigator < "u" &&
		/Edge?\/(?:[0-6][0-9]|[0-7][0-8])(?:\.)/i.test(navigator.userAgent),
	wz = typeof navigator < "u" && /Chrome/i.test(navigator.userAgent),
	zhe =
		typeof navigator < "u" &&
		/Chrome?\/(?:[0-7][0-5]|[0-6][0-9])(?:\.)/i.test(navigator.userAgent),
	Lhe =
		_o &&
		typeof navigator < "u" &&
		/Chrome?\/(?:[0-5]?\d)(?:\.)/i.test(navigator.userAgent),
	Vhe =
		typeof navigator < "u" &&
		/^(?!.*Seamonkey)(?=.*Firefox\/(?:[0-7][0-9]|[0-8][0-6])(?:\.)).*/i.test(
			navigator.userAgent,
		),
	Khe = typeof navigator < "u" && /.*UCBrowser/.test(navigator.userAgent),
	Uhe = typeof navigator < "u" && /.*Wechat/.test(navigator.userAgent),
	pb =
		typeof window < "u" &&
		typeof window.document < "u" &&
		typeof window.document.createElement < "u",
	Ll =
		(!zhe || !Lhe) &&
		!_he &&
		typeof globalThis < "u" &&
		globalThis.InputEvent &&
		typeof globalThis.InputEvent.prototype.getTargetRanges == "function",
	te = {
		isComposing(t) {
			return !!Nc.get(t);
		},
		getWindow(t) {
			var e = vz.get(t);
			if (!e)
				throw new Error(
					"Unable to find a host window element for this editor",
				);
			return e;
		},
		findKey(t, e) {
			var n = zw.get(e);
			return n || ((n = new $he()), zw.set(e, n)), n;
		},
		findPath(t, e) {
			for (var n = [], r = e; ; ) {
				var i = mS.get(r);
				if (i == null) {
					if (R.isEditor(r)) return n;
					break;
				}
				var o = pS.get(r);
				if (o == null) break;
				n.unshift(o), (r = i);
			}
			throw new Error(
				"Unable to find the path for Slate node: ".concat(
					dr.stringify(e),
				),
			);
		},
		findDocumentOrShadowRoot(t) {
			var e = te.toDOMNode(t, t),
				n = e.getRootNode();
			return (n instanceof Document || n instanceof ShadowRoot) &&
				n.getSelection != null
				? n
				: e.ownerDocument;
		},
		isFocused(t) {
			return !!Pc.get(t);
		},
		isReadOnly(t) {
			return !!Lw.get(t);
		},
		blur(t) {
			var e = te.toDOMNode(t, t),
				n = te.findDocumentOrShadowRoot(t);
			Pc.set(t, !1), n.activeElement === e && e.blur();
		},
		focus(t) {
			var e = te.toDOMNode(t, t),
				n = te.findDocumentOrShadowRoot(t);
			Pc.set(t, !0),
				n.activeElement !== e && e.focus({ preventScroll: !0 });
		},
		deselect(t) {
			var { selection: e } = t,
				n = te.findDocumentOrShadowRoot(t),
				r = n.getSelection();
			r && r.rangeCount > 0 && r.removeAllRanges(), e && W.deselect(t);
		},
		hasDOMNode(t, e) {
			var n =
					arguments.length > 2 && arguments[2] !== void 0
						? arguments[2]
						: {},
				{ editable: r = !1 } = n,
				i = te.toDOMNode(t, t),
				o;
			try {
				o = No(e) ? e : e.parentElement;
			} catch (s) {
				if (
					!s.message.includes(
						'Permission denied to access property "nodeType"',
					)
				)
					throw s;
			}
			return o
				? o.closest("[data-slate-editor]") === i &&
						(!r || o.isContentEditable
							? !0
							: (typeof o.isContentEditable == "boolean" &&
									o.closest('[contenteditable="false"]') ===
										i) ||
								!!o.getAttribute("data-slate-zero-width"))
				: !1;
		},
		insertData(t, e) {
			t.insertData(e);
		},
		insertFragmentData(t, e) {
			return t.insertFragmentData(e);
		},
		insertTextData(t, e) {
			return t.insertTextData(e);
		},
		setFragmentData(t, e, n) {
			t.setFragmentData(e, n);
		},
		toDOMNode(t, e) {
			var n = qx.get(t),
				r = R.isEditor(e)
					? hb.get(t)
					: n == null
						? void 0
						: n.get(te.findKey(t, e));
			if (!r)
				throw new Error(
					"Cannot resolve a DOM node from Slate node: ".concat(
						dr.stringify(e),
					),
				);
			return r;
		},
		toDOMPoint(t, e) {
			var [n] = R.node(t, e.path),
				r = te.toDOMNode(t, n),
				i;
			R.void(t, { at: e }) && (e = { path: e.path, offset: 0 });
			for (
				var o = "[data-slate-string], [data-slate-zero-width]",
					s = Array.from(r.querySelectorAll(o)),
					a = 0,
					l = 0;
				l < s.length;
				l++
			) {
				var u = s[l],
					c = u.childNodes[0];
				if (!(c == null || c.textContent == null)) {
					var { length: d } = c.textContent,
						f = u.getAttribute("data-slate-length"),
						h = f == null ? d : parseInt(f, 10),
						p = a + h,
						g = s[l + 1];
					if (
						e.offset === p &&
						g !== null &&
						g !== void 0 &&
						g.hasAttribute("data-slate-mark-placeholder")
					) {
						var v,
							b = g.childNodes[0];
						i = [
							b instanceof The ? b : g,
							(v = g.textContent) !== null &&
							v !== void 0 &&
							v.startsWith("\uFEFF")
								? 1
								: 0,
						];
						break;
					}
					if (e.offset <= p) {
						var y = Math.min(d, Math.max(0, e.offset - a));
						i = [c, y];
						break;
					}
					a = p;
				}
			}
			if (!i)
				throw new Error(
					"Cannot resolve a DOM point from Slate point: ".concat(
						dr.stringify(e),
					),
				);
			return i;
		},
		toDOMRange(t, e) {
			var { anchor: n, focus: r } = e,
				i = ie.isBackward(e),
				o = te.toDOMPoint(t, n),
				s = ie.isCollapsed(e) ? o : te.toDOMPoint(t, r),
				a = te.getWindow(t),
				l = a.document.createRange(),
				[u, c] = i ? s : o,
				[d, f] = i ? o : s,
				h = No(u) ? u : u.parentElement,
				p = !!h.getAttribute("data-slate-zero-width"),
				g = No(d) ? d : d.parentElement,
				v = !!g.getAttribute("data-slate-zero-width");
			return l.setStart(u, p ? 1 : c), l.setEnd(d, v ? 1 : f), l;
		},
		toSlateNode(t, e) {
			var n = No(e) ? e : e.parentElement;
			n &&
				!n.hasAttribute("data-slate-node") &&
				(n = n.closest("[data-slate-node]"));
			var r = n ? og.get(n) : null;
			if (!r)
				throw new Error(
					"Cannot resolve a Slate node from DOM node: ".concat(n),
				);
			return r;
		},
		findEventRange(t, e) {
			"nativeEvent" in e && (e = e.nativeEvent);
			var { clientX: n, clientY: r, target: i } = e;
			if (n == null || r == null)
				throw new Error(
					"Cannot resolve a Slate range from a DOM event: ".concat(e),
				);
			var o = te.toSlateNode(t, e.target),
				s = te.findPath(t, o);
			if ($e.isElement(o) && R.isVoid(t, o)) {
				var a = i.getBoundingClientRect(),
					l = t.isInline(o)
						? n - a.left < a.left + a.width - n
						: r - a.top < a.top + a.height - r,
					u = R.point(t, s, { edge: l ? "start" : "end" }),
					c = l ? R.before(t, u) : R.after(t, u);
				if (c) {
					var d = R.range(t, c);
					return d;
				}
			}
			var f,
				{ document: h } = te.getWindow(t);
			if (h.caretRangeFromPoint) f = h.caretRangeFromPoint(n, r);
			else {
				var p = h.caretPositionFromPoint(n, r);
				p &&
					((f = h.createRange()),
					f.setStart(p.offsetNode, p.offset),
					f.setEnd(p.offsetNode, p.offset));
			}
			if (!f)
				throw new Error(
					"Cannot resolve a Slate range from a DOM event: ".concat(e),
				);
			var g = te.toSlateRange(t, f, {
				exactMatch: !1,
				suppressThrow: !1,
			});
			return g;
		},
		toSlatePoint(t, e, n) {
			var { exactMatch: r, suppressThrow: i } = n,
				[o, s] = r ? e : Fhe(e),
				a = o.parentNode,
				l = null,
				u = 0;
			if (a) {
				var c,
					d,
					f = te.toDOMNode(t, t),
					h = a.closest('[data-slate-void="true"]'),
					p = h && f.contains(h) ? h : null,
					g = a.closest("[data-slate-leaf]"),
					v = null;
				if (g) {
					if (((l = g.closest('[data-slate-node="text"]')), l)) {
						var b = te.getWindow(t),
							y = b.document.createRange();
						y.setStart(l, 0), y.setEnd(o, s);
						var x = y.cloneContents(),
							C = [
								...Array.prototype.slice.call(
									x.querySelectorAll(
										"[data-slate-zero-width]",
									),
								),
								...Array.prototype.slice.call(
									x.querySelectorAll(
										"[contenteditable=false]",
									),
								),
							];
						C.forEach((N) => {
							if (
								_o &&
								!r &&
								N.hasAttribute("data-slate-zero-width") &&
								N.textContent.length > 0 &&
								N.textContext !== "\uFEFF"
							) {
								N.textContent.startsWith("\uFEFF") &&
									(N.textContent = N.textContent.slice(1));
								return;
							}
							N.parentNode.removeChild(N);
						}),
							(u = x.textContent.length),
							(v = l);
					}
				} else if (p) {
					for (
						var k = p.querySelectorAll("[data-slate-leaf]"), w = 0;
						w < k.length;
						w++
					) {
						var D = k[w];
						if (te.hasDOMNode(t, D)) {
							g = D;
							break;
						}
					}
					g
						? ((l = g.closest('[data-slate-node="text"]')),
							(v = g),
							(u = v.textContent.length),
							v
								.querySelectorAll("[data-slate-zero-width]")
								.forEach((N) => {
									u -= N.textContent.length;
								}))
						: (u = 1);
				}
				v &&
					u === v.textContent.length &&
					_o &&
					v.getAttribute("data-slate-zero-width") === "z" &&
					(c = v.textContent) !== null &&
					c !== void 0 &&
					c.startsWith("\uFEFF") &&
					(a.hasAttribute("data-slate-zero-width") ||
						(Hv &&
							(d = v.textContent) !== null &&
							d !== void 0 &&
							d.endsWith(`

`))) &&
					u--;
			}
			if (_o && !l && !r) {
				var S = a.hasAttribute("data-slate-node")
					? a
					: a.closest("[data-slate-node]");
				if (S && te.hasDOMNode(t, S, { editable: !0 })) {
					var $ = te.toSlateNode(t, S),
						{ path: A, offset: T } = R.start(t, te.findPath(t, $));
					return (
						S.querySelector("[data-slate-leaf]") || (T = s),
						{ path: A, offset: T }
					);
				}
			}
			if (!l) {
				if (i) return null;
				throw new Error(
					"Cannot resolve a Slate point from DOM point: ".concat(e),
				);
			}
			var I = te.toSlateNode(t, l),
				F = te.findPath(t, I);
			return { path: F, offset: u };
		},
		toSlateRange(t, e, n) {
			var { exactMatch: r, suppressThrow: i } = n,
				o = Kw(e) ? e.anchorNode : e.startContainer,
				s,
				a,
				l,
				u,
				c;
			if (
				(o &&
					(Kw(e)
						? ((s = e.anchorNode),
							(a = e.anchorOffset),
							(l = e.focusNode),
							(u = e.focusOffset),
							wz && Phe(s)
								? (c =
										e.anchorNode === e.focusNode &&
										e.anchorOffset === e.focusOffset)
								: (c = e.isCollapsed))
						: ((s = e.startContainer),
							(a = e.startOffset),
							(l = e.endContainer),
							(u = e.endOffset),
							(c = e.collapsed))),
				s == null || l == null || a == null || u == null)
			)
				throw new Error(
					"Cannot resolve a Slate range from DOM range: ".concat(e),
				);
			if (
				"getAttribute" in l &&
				l.getAttribute("contenteditable") === "false"
			) {
				var d;
				(l = s),
					(u =
						((d = s.textContent) === null || d === void 0
							? void 0
							: d.length) || 0);
			}
			var f = te.toSlatePoint(t, [s, a], {
				exactMatch: r,
				suppressThrow: i,
			});
			if (!f) return null;
			var h = c
				? f
				: te.toSlatePoint(t, [l, u], {
						exactMatch: r,
						suppressThrow: i,
					});
			if (!h) return null;
			if (Hv && !c && s !== l) {
				var p = R.isEnd(t, f, f.path),
					g = R.isStart(t, h, h.path);
				if (p) {
					var v = R.after(t, f);
					f = v || f;
				}
				if (g) {
					var b = R.before(t, h);
					h = b || h;
				}
			}
			var y = { anchor: f, focus: h };
			return (
				ie.isExpanded(y) &&
					ie.isForward(y) &&
					No(l) &&
					R.void(t, { at: y.focus, mode: "highest" }) &&
					(y = R.unhangRange(t, y, { voids: !0 })),
				y
			);
		},
		hasRange(t, e) {
			var { anchor: n, focus: r } = e;
			return R.hasPath(t, n.path) && R.hasPath(t, r.path);
		},
		hasTarget(t, e) {
			return wd(e) && te.hasDOMNode(t, e);
		},
		hasEditableTarget(t, e) {
			return wd(e) && te.hasDOMNode(t, e, { editable: !0 });
		},
		hasSelectableTarget(t, e) {
			return (
				te.hasEditableTarget(t, e) ||
				te.isTargetInsideNonReadonlyVoid(t, e)
			);
		},
		isTargetInsideNonReadonlyVoid(t, e) {
			if (Lw.get(t)) return !1;
			var n = te.hasTarget(t, e) && te.toSlateNode(t, e);
			return $e.isElement(n) && R.isVoid(t, n);
		},
		androidScheduleFlush(t) {
			var e;
			(e = gS.get(t)) === null || e === void 0 || e();
		},
		androidPendingDiffs(t) {
			return Ti.get(t);
		},
	},
	Hhe = ["anchor", "focus"],
	Whe = ["anchor", "focus"],
	qhe = (t, e) =>
		Object.keys(t).length === Object.keys(e).length &&
		Object.keys(t).every((n) => e.hasOwnProperty(n) && t[n] === e[n]),
	Ez = (t, e) => {
		var n = Sh(t, Hhe),
			r = Sh(e, Whe);
		return t[Ah] === e[Ah] && qhe(n, r);
	},
	Ghe = (t, e) => {
		if (t.length !== e.length) return !1;
		for (var n = 0; n < t.length; n++) {
			var r = t[n],
				i = e[n];
			if (!ie.equals(r, i) || !Ez(r, i)) return !1;
		}
		return !0;
	},
	Yhe = (t, e) => {
		if (t.length !== e.length) return !1;
		for (var n = 0; n < t.length; n++) {
			var r = t[n],
				i = e[n];
			if (
				r.anchor.offset !== i.anchor.offset ||
				r.focus.offset !== i.focus.offset ||
				!Ez(r, i)
			)
				return !1;
		}
		return !0;
	},
	sg = pb ? E.useLayoutEffect : E.useEffect,
	Jhe = (t) => {
		var { isLast: e, leaf: n, parent: r, text: i } = t,
			o = wn(),
			s = te.findPath(o, i),
			a = Y.parent(s),
			l = n[yz] === !0;
		return o.isVoid(r)
			? le.createElement(bk, { length: pe.string(r).length })
			: n.text === "" &&
				  r.children[r.children.length - 1] === i &&
				  !o.isInline(r) &&
				  R.string(o, a) === ""
				? le.createElement(bk, {
						isLineBreak: !0,
						isMarkPlaceholder: l,
					})
				: n.text === ""
					? le.createElement(bk, { isMarkPlaceholder: l })
					: e &&
						  n.text.slice(-1) ===
								`
`
						? le.createElement(HT, { isTrailing: !0, text: n.text })
						: le.createElement(HT, { text: n.text });
	},
	HT = (t) => {
		var { text: e, isTrailing: n = !1 } = t,
			r = E.useRef(null),
			i = () =>
				"".concat(e ?? "").concat(
					n
						? `
`
						: "",
				),
			[o] = E.useState(i);
		return (
			sg(() => {
				var s = i();
				r.current &&
					r.current.textContent !== s &&
					(r.current.textContent = s);
			}),
			le.createElement(Xhe, { ref: r }, o)
		);
	},
	Xhe = E.memo(
		E.forwardRef((t, e) =>
			le.createElement(
				"span",
				{ "data-slate-string": !0, ref: e },
				t.children,
			),
		),
	),
	bk = (t) => {
		var {
				length: e = 0,
				isLineBreak: n = !1,
				isMarkPlaceholder: r = !1,
			} = t,
			i = {
				"data-slate-zero-width": n ? "n" : "z",
				"data-slate-length": e,
			};
		return (
			r && (i["data-slate-mark-placeholder"] = !0),
			le.createElement(
				"span",
				Object.assign({}, i),
				!_o || !n ? "\uFEFF" : null,
				n ? le.createElement("br", null) : null,
			)
		);
	},
	yS = E.createContext(null),
	wn = () => {
		var t = E.useContext(yS);
		if (!t)
			throw new Error(
				"The `useSlateStatic` hook must be used inside the <Slate> component's context.",
			);
		return t;
	},
	Zhe = (t) => {
		var {
				leaf: e,
				isLast: n,
				text: r,
				parent: i,
				renderPlaceholder: o,
				renderLeaf: s = (p) =>
					le.createElement(epe, Object.assign({}, p)),
			} = t,
			a = E.useRef(null),
			l = E.useRef(null),
			u = wn(),
			c = E.useRef(null);
		E.useEffect(
			() => () => {
				c.current && c.current.disconnect();
			},
			[],
		),
			E.useEffect(() => {
				var p = l == null ? void 0 : l.current;
				if ((p ? km.set(u, p) : km.delete(u), c.current))
					c.current.disconnect(), p && c.current.observe(p);
				else if (p) {
					var g = window.ResizeObserver || khe;
					(c.current = new g(() => {
						var b = Uv.get(u);
						b == null || b();
					})),
						c.current.observe(p);
				}
				if (!p && a.current) {
					var v = Uv.get(u);
					v == null || v();
				}
				return (
					(a.current = l.current),
					() => {
						km.delete(u);
					}
				);
			}, [l, e]);
		var d = le.createElement(Jhe, {
			isLast: n,
			leaf: e,
			parent: i,
			text: r,
		});
		if (e[Ah]) {
			var f = {
				children: e.placeholder,
				attributes: {
					"data-slate-placeholder": !0,
					style: {
						position: "absolute",
						pointerEvents: "none",
						width: "100%",
						maxWidth: "100%",
						display: "block",
						opacity: "0.333",
						userSelect: "none",
						textDecoration: "none",
					},
					contentEditable: !1,
					ref: l,
				},
			};
			d = le.createElement(le.Fragment, null, o(f), d);
		}
		var h = { "data-slate-leaf": !0 };
		return s({ attributes: h, children: d, leaf: e, text: r });
	},
	Qhe = le.memo(
		Zhe,
		(t, e) =>
			e.parent === t.parent &&
			e.isLast === t.isLast &&
			e.renderLeaf === t.renderLeaf &&
			e.renderPlaceholder === t.renderPlaceholder &&
			e.text === t.text &&
			Be.equals(e.leaf, t.leaf) &&
			e.leaf[Ah] === t.leaf[Ah],
	),
	epe = (t) => {
		var { attributes: e, children: n } = t;
		return le.createElement("span", Object.assign({}, e), n);
	},
	tpe = (t) => {
		for (
			var {
					decorations: e,
					isLast: n,
					parent: r,
					renderPlaceholder: i,
					renderLeaf: o,
					text: s,
				} = t,
				a = wn(),
				l = E.useRef(null),
				u = Be.decorations(s, e),
				c = te.findKey(a, s),
				d = [],
				f = 0;
			f < u.length;
			f++
		) {
			var h = u[f];
			d.push(
				le.createElement(Qhe, {
					isLast: n && f === u.length - 1,
					key: "".concat(c.id, "-").concat(f),
					renderPlaceholder: i,
					leaf: h,
					text: s,
					parent: r,
					renderLeaf: o,
				}),
			);
		}
		var p = E.useCallback(
			(g) => {
				var v = qx.get(a);
				g
					? (v == null || v.set(c, g), Qc.set(s, g), og.set(g, s))
					: (v == null || v.delete(c),
						Qc.delete(s),
						l.current && og.delete(l.current)),
					(l.current = g);
			},
			[l, a, c, s],
		);
		return le.createElement(
			"span",
			{ "data-slate-node": "text", ref: p },
			d,
		);
	},
	Dz = le.memo(
		tpe,
		(t, e) =>
			e.parent === t.parent &&
			e.isLast === t.isLast &&
			e.renderLeaf === t.renderLeaf &&
			e.renderPlaceholder === t.renderPlaceholder &&
			e.text === t.text &&
			Yhe(e.decorations, t.decorations),
	),
	npe = (t) => {
		var {
				decorations: e,
				element: n,
				renderElement: r = (y) =>
					le.createElement(ipe, Object.assign({}, y)),
				renderPlaceholder: i,
				renderLeaf: o,
				selection: s,
			} = t,
			a = wn(),
			l = spe(),
			u = a.isInline(n),
			c = te.findKey(a, n),
			d = E.useCallback(
				(y) => {
					var x = qx.get(a);
					y
						? (x == null || x.set(c, y), Qc.set(n, y), og.set(y, n))
						: (x == null || x.delete(c), Qc.delete(n));
				},
				[a, c, n],
			),
			f = Tz({
				decorations: e,
				node: n,
				renderElement: r,
				renderPlaceholder: i,
				renderLeaf: o,
				selection: s,
			}),
			h = { "data-slate-node": "element", ref: d };
		if ((u && (h["data-slate-inline"] = !0), !u && R.hasInlines(a, n))) {
			var p = pe.string(n),
				g = X_(p);
			g === "rtl" && (h.dir = g);
		}
		if (R.isVoid(a, n)) {
			(h["data-slate-void"] = !0), !l && u && (h.contentEditable = !1);
			var v = u ? "span" : "div",
				[[b]] = pe.texts(n);
			(f = le.createElement(
				v,
				{
					"data-slate-spacer": !0,
					style: {
						height: "0",
						color: "transparent",
						outline: "none",
						position: "absolute",
					},
				},
				le.createElement(Dz, {
					renderPlaceholder: i,
					decorations: [],
					isLast: !1,
					parent: n,
					text: b,
				}),
			)),
				pS.set(b, 0),
				mS.set(b, n);
		}
		return r({ attributes: h, children: f, element: n });
	},
	rpe = le.memo(
		npe,
		(t, e) =>
			t.element === e.element &&
			t.renderElement === e.renderElement &&
			t.renderLeaf === e.renderLeaf &&
			t.renderPlaceholder === e.renderPlaceholder &&
			Ghe(t.decorations, e.decorations) &&
			(t.selection === e.selection ||
				(!!t.selection &&
					!!e.selection &&
					ie.equals(t.selection, e.selection))),
	),
	ipe = (t) => {
		var { attributes: e, children: n, element: r } = t,
			i = wn(),
			o = i.isInline(r) ? "span" : "div";
		return le.createElement(
			o,
			Object.assign({}, e, { style: { position: "relative" } }),
			n,
		);
	},
	Sz = E.createContext(() => []),
	ope = () => E.useContext(Sz),
	Az = E.createContext(!1),
	$z = () => E.useContext(Az),
	Tz = (t) => {
		for (
			var {
					decorations: e,
					node: n,
					renderElement: r,
					renderPlaceholder: i,
					renderLeaf: o,
					selection: s,
				} = t,
				a = ope(),
				l = wn(),
				u = te.findPath(l, n),
				c = [],
				d = $e.isElement(n) && !l.isInline(n) && R.hasInlines(l, n),
				f = 0;
			f < n.children.length;
			f++
		) {
			var h = u.concat(f),
				p = n.children[f],
				g = te.findKey(l, p),
				v = R.range(l, h),
				b = s && ie.intersection(v, s),
				y = a([p, h]);
			for (var x of e) {
				var C = ie.intersection(x, v);
				C && y.push(C);
			}
			$e.isElement(p)
				? c.push(
						le.createElement(
							Az.Provider,
							{ key: "provider-".concat(g.id), value: !!b },
							le.createElement(rpe, {
								decorations: y,
								element: p,
								key: g.id,
								renderElement: r,
								renderPlaceholder: i,
								renderLeaf: o,
								selection: b,
							}),
						),
					)
				: c.push(
						le.createElement(Dz, {
							decorations: y,
							key: g.id,
							isLast: d && f === n.children.length - 1,
							parent: n,
							renderPlaceholder: i,
							renderLeaf: o,
							text: p,
						}),
					),
				pS.set(p, f),
				mS.set(p, n);
		}
		return c;
	},
	Bz = E.createContext(!1),
	spe = () => E.useContext(Bz),
	Iz = E.createContext(null),
	Gx = () => {
		var t = E.useContext(Iz);
		if (!t)
			throw new Error(
				"The `useSlate` hook must be used inside the <Slate> component's context.",
			);
		var { editor: e } = t;
		return e;
	},
	ape = 3,
	lpe = {
		bold: "mod+b",
		compose: ["down", "left", "right", "up", "backspace", "enter"],
		moveBackward: "left",
		moveForward: "right",
		moveWordBackward: "ctrl+left",
		moveWordForward: "ctrl+right",
		deleteBackward: "shift?+backspace",
		deleteForward: "shift?+delete",
		extendBackward: "shift+left",
		extendForward: "shift+right",
		italic: "mod+i",
		insertSoftBreak: "shift+enter",
		splitBlock: "enter",
		undo: "mod+z",
	},
	upe = {
		moveLineBackward: "opt+up",
		moveLineForward: "opt+down",
		moveWordBackward: "opt+left",
		moveWordForward: "opt+right",
		deleteBackward: ["ctrl+backspace", "ctrl+h"],
		deleteForward: ["ctrl+delete", "ctrl+d"],
		deleteLineBackward: "cmd+shift?+backspace",
		deleteLineForward: ["cmd+shift?+delete", "ctrl+k"],
		deleteWordBackward: "opt+shift?+backspace",
		deleteWordForward: "opt+shift?+delete",
		extendLineBackward: "opt+shift+up",
		extendLineForward: "opt+shift+down",
		redo: "cmd+shift+z",
		transposeCharacter: "ctrl+t",
	},
	cpe = {
		deleteWordBackward: "ctrl+shift?+backspace",
		deleteWordForward: "ctrl+shift?+delete",
		redo: ["ctrl+y", "ctrl+shift+z"],
	},
	un = (t) => {
		var e = lpe[t],
			n = upe[t],
			r = cpe[t],
			i = e && gk(e),
			o = n && gk(n),
			s = r && gk(r);
		return (a) =>
			!!((i && i(a)) || (UT && o && o(a)) || (!UT && s && s(a)));
	},
	vn = {
		isBold: un("bold"),
		isCompose: un("compose"),
		isMoveBackward: un("moveBackward"),
		isMoveForward: un("moveForward"),
		isDeleteBackward: un("deleteBackward"),
		isDeleteForward: un("deleteForward"),
		isDeleteLineBackward: un("deleteLineBackward"),
		isDeleteLineForward: un("deleteLineForward"),
		isDeleteWordBackward: un("deleteWordBackward"),
		isDeleteWordForward: un("deleteWordForward"),
		isExtendBackward: un("extendBackward"),
		isExtendForward: un("extendForward"),
		isExtendLineBackward: un("extendLineBackward"),
		isExtendLineForward: un("extendLineForward"),
		isItalic: un("italic"),
		isMoveLineBackward: un("moveLineBackward"),
		isMoveLineForward: un("moveLineForward"),
		isMoveWordBackward: un("moveWordBackward"),
		isMoveWordForward: un("moveWordForward"),
		isRedo: un("redo"),
		isSoftBreak: un("insertSoftBreak"),
		isSplitBlock: un("splitBlock"),
		isTransposeCharacter: un("transposeCharacter"),
		isUndo: un("undo"),
	},
	dpe = (t, e) => {
		var n = [],
			r = () => {
				n = [];
			},
			i = (s) => {
				if (e.current) {
					var a = s.filter((l) => vS(t, l, s));
					n.push(...a);
				}
			};
		function o() {
			n.length > 0 &&
				(n.reverse().forEach((s) => {
					s.type !== "characterData" &&
						(s.removedNodes.forEach((a) => {
							s.target.insertBefore(a, s.nextSibling);
						}),
						s.addedNodes.forEach((a) => {
							s.target.removeChild(a);
						}));
				}),
				r());
		}
		return { registerMutations: i, restoreDOM: o, clear: r };
	},
	fpe = {
		subtree: !0,
		childList: !0,
		characterData: !0,
		characterDataOldValue: !0,
	};
class Fz extends E.Component {
	constructor() {
		super(...arguments),
			(this.context = null),
			(this.manager = null),
			(this.mutationObserver = null);
	}
	observe() {
		var e,
			{ node: n } = this.props;
		if (!n.current)
			throw new Error(
				"Failed to attach MutationObserver, `node` is undefined",
			);
		(e = this.mutationObserver) === null ||
			e === void 0 ||
			e.observe(n.current, fpe);
	}
	componentDidMount() {
		var { receivedUserInput: e } = this.props,
			n = this.context;
		(this.manager = dpe(n, e)),
			(this.mutationObserver = new MutationObserver(
				this.manager.registerMutations,
			)),
			this.observe();
	}
	getSnapshotBeforeUpdate() {
		var e,
			n,
			r,
			i =
				(e = this.mutationObserver) === null || e === void 0
					? void 0
					: e.takeRecords();
		if (i != null && i.length) {
			var o;
			(o = this.manager) === null ||
				o === void 0 ||
				o.registerMutations(i);
		}
		return (
			(n = this.mutationObserver) === null ||
				n === void 0 ||
				n.disconnect(),
			(r = this.manager) === null || r === void 0 || r.restoreDOM(),
			null
		);
	}
	componentDidUpdate() {
		var e;
		(e = this.manager) === null || e === void 0 || e.clear(),
			this.observe();
	}
	componentWillUnmount() {
		var e;
		(e = this.mutationObserver) === null || e === void 0 || e.disconnect();
	}
	render() {
		return this.props.children;
	}
}
Fz.contextType = yS;
var hpe = _o
	? Fz
	: (t) => {
			var { children: e } = t;
			return le.createElement(le.Fragment, null, e);
		};
function ppe(t, e) {
	var { path: n, diff: r } = e;
	if (!R.hasPath(t, n)) return !1;
	var i = pe.get(t, n);
	if (!Be.isText(i)) return !1;
	if (r.start !== i.text.length || r.text.length === 0)
		return i.text.slice(r.start, r.start + r.text.length) === r.text;
	var o = Y.next(n);
	if (!R.hasPath(t, o)) return !1;
	var s = pe.get(t, o);
	return Be.isText(s) && s.text.startsWith(r.text);
}
function Pz(t) {
	for (
		var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), r = 1;
		r < e;
		r++
	)
		n[r - 1] = arguments[r];
	return n.reduce((i, o) => i.slice(0, o.start) + o.text + i.slice(o.end), t);
}
function mpe(t, e) {
	for (var n = Math.min(t.length, e.length), r = 0; r < n; r++)
		if (t.charAt(r) !== e.charAt(r)) return r;
	return n;
}
function gpe(t, e, n) {
	for (var r = Math.min(t.length, e.length, n), i = 0; i < r; i++)
		if (t.charAt(t.length - i - 1) !== e.charAt(e.length - i - 1)) return i;
	return r;
}
function Nz(t, e) {
	var { start: n, end: r, text: i } = e,
		o = t.slice(n, r),
		s = mpe(o, i),
		a = Math.min(o.length - s, i.length - s),
		l = gpe(o, i, a),
		u = { start: n + s, end: r - l, text: i.slice(s, i.length - l) };
	return u.start === u.end && u.text.length === 0 ? null : u;
}
function bpe(t, e, n) {
	var r = Math.min(e.start, n.start),
		i = Math.max(0, Math.min(e.start + e.text.length, n.end) - n.start),
		o = Pz(t, e, n),
		s = Math.max(
			n.start + n.text.length,
			e.start +
				e.text.length +
				(e.start + e.text.length > n.start ? n.text.length : 0) -
				i,
		),
		a = o.slice(r, s),
		l = Math.max(e.end, n.end - e.text.length + (e.end - e.start));
	return Nz(t, { start: r, end: l, text: a });
}
function vpe(t) {
	var { path: e, diff: n } = t;
	return {
		anchor: { path: e, offset: n.start },
		focus: { path: e, offset: n.end },
	};
}
function Uw(t, e) {
	var { path: n, offset: r } = e;
	if (!R.hasPath(t, n)) return null;
	var i = pe.get(t, n);
	if (!Be.isText(i)) return null;
	var o = R.above(t, {
		match: (a) => $e.isElement(a) && R.isBlock(t, a),
		at: n,
	});
	if (!o) return null;
	for (; r > i.text.length; ) {
		var s = R.next(t, { at: n, match: Be.isText });
		if (!s || !Y.isDescendant(s[1], o[1])) return null;
		(r -= i.text.length), (i = s[0]), (n = s[1]);
	}
	return { path: n, offset: r };
}
function WT(t, e) {
	var n = Uw(t, e.anchor);
	if (!n) return null;
	if (ie.isCollapsed(e)) return { anchor: n, focus: n };
	var r = Uw(t, e.focus);
	return r ? { anchor: n, focus: r } : null;
}
function Hw(t, e, n) {
	var r = Ti.get(t),
		i =
			r == null
				? void 0
				: r.find((c) => {
						var { path: d } = c;
						return Y.equals(d, e.path);
					});
	if (!i || e.offset <= i.diff.start)
		return ut.transform(e, n, { affinity: "backward" });
	var { diff: o } = i;
	if (e.offset <= o.start + o.text.length) {
		var s = { path: e.path, offset: o.start },
			a = ut.transform(s, n, { affinity: "backward" });
		return a
			? { path: a.path, offset: a.offset + e.offset - o.start }
			: null;
	}
	var l = {
			path: e.path,
			offset: e.offset - o.text.length + o.end - o.start,
		},
		u = ut.transform(l, n, { affinity: "backward" });
	return u
		? n.type === "split_node" &&
			Y.equals(n.path, e.path) &&
			l.offset < n.position &&
			o.start < n.position
			? u
			: {
					path: u.path,
					offset: u.offset + o.text.length - o.end + o.start,
				}
		: null;
}
function qT(t, e, n) {
	var r = Hw(t, e.anchor, n);
	if (!r) return null;
	if (ie.isCollapsed(e)) return { anchor: r, focus: r };
	var i = Hw(t, e.focus, n);
	return i ? { anchor: r, focus: i } : null;
}
function ype(t, e) {
	var { path: n, diff: r, id: i } = t;
	switch (e.type) {
		case "insert_text":
			return !Y.equals(e.path, n) || e.offset >= r.end
				? t
				: e.offset <= r.start
					? {
							diff: {
								start: e.text.length + r.start,
								end: e.text.length + r.end,
								text: r.text,
							},
							id: i,
							path: n,
						}
					: {
							diff: {
								start: r.start,
								end: r.end + e.text.length,
								text: r.text,
							},
							id: i,
							path: n,
						};
		case "remove_text":
			return !Y.equals(e.path, n) || e.offset >= r.end
				? t
				: e.offset + e.text.length <= r.start
					? {
							diff: {
								start: r.start - e.text.length,
								end: r.end - e.text.length,
								text: r.text,
							},
							id: i,
							path: n,
						}
					: {
							diff: {
								start: r.start,
								end: r.end - e.text.length,
								text: r.text,
							},
							id: i,
							path: n,
						};
		case "split_node":
			return !Y.equals(e.path, n) || e.position >= r.end
				? {
						diff: r,
						id: i,
						path: Y.transform(n, e, { affinity: "backward" }),
					}
				: e.position > r.start
					? {
							diff: {
								start: r.start,
								end: Math.min(e.position, r.end),
								text: r.text,
							},
							id: i,
							path: n,
						}
					: {
							diff: {
								start: r.start - e.position,
								end: r.end - e.position,
								text: r.text,
							},
							id: i,
							path: Y.transform(n, e, { affinity: "forward" }),
						};
		case "merge_node":
			return Y.equals(e.path, n)
				? {
						diff: {
							start: r.start + e.position,
							end: r.end + e.position,
							text: r.text,
						},
						id: i,
						path: Y.transform(n, e),
					}
				: { diff: r, id: i, path: Y.transform(n, e) };
	}
	var o = Y.transform(n, e);
	return o ? { diff: r, path: o, id: i } : null;
}
function GT(t, e) {
	var n = Object.keys(t);
	if (Object.getOwnPropertySymbols) {
		var r = Object.getOwnPropertySymbols(t);
		e &&
			(r = r.filter(function (i) {
				return Object.getOwnPropertyDescriptor(t, i).enumerable;
			})),
			n.push.apply(n, r);
	}
	return n;
}
function I1(t) {
	for (var e = 1; e < arguments.length; e++) {
		var n = arguments[e] != null ? arguments[e] : {};
		e % 2
			? GT(Object(n), !0).forEach(function (r) {
					Wx(t, r, n[r]);
				})
			: Object.getOwnPropertyDescriptors
				? Object.defineProperties(
						t,
						Object.getOwnPropertyDescriptors(n),
					)
				: GT(Object(n)).forEach(function (r) {
						Object.defineProperty(
							t,
							r,
							Object.getOwnPropertyDescriptor(n, r),
						);
					});
	}
	return t;
}
var xpe = 25,
	kpe = 200,
	Cpe = function () {},
	wpe = (t) => (t == null ? void 0 : t.constructor.name) === "DataTransfer";
function Epe(t) {
	var {
			editor: e,
			scheduleOnDOMSelectionChange: n,
			onDOMSelectionChange: r,
		} = t,
		i = !1,
		o = null,
		s = null,
		a = null,
		l = 0,
		u = !1,
		c = () => {
			var I = eu.get(e);
			if ((eu.delete(e), I)) {
				var { selection: F } = e,
					N = WT(e, I);
				N && (!F || !ie.equals(N, F)) && W.select(e, N);
			}
		},
		d = () => {
			var I = Ql.get(e);
			if ((Ql.delete(e), !!I)) {
				if (I.at) {
					var F = ut.isPoint(I.at) ? Uw(e, I.at) : WT(e, I.at);
					if (!F) return;
					var N = R.range(e, F);
					(!e.selection || !ie.equals(e.selection, N)) &&
						W.select(e, F);
				}
				I.run();
			}
		},
		f = () => {
			if (
				(s && (clearTimeout(s), (s = null)),
				a && (clearTimeout(a), (a = null)),
				!C() && !x())
			) {
				c();
				return;
			}
			i || ((i = !0), setTimeout(() => (i = !1))), x() && (i = "action");
			var I =
				e.selection &&
				R.rangeRef(e, e.selection, { affinity: "forward" });
			Qa.set(e, e.marks), Cpe("flush", Ql.get(e), Ti.get(e));
			for (
				var F = C(), N;
				(N = (O = Ti.get(e)) === null || O === void 0 ? void 0 : O[0]);

			) {
				var O,
					_,
					j = ks.get(e);
				j !== void 0 && (ks.delete(e), (e.marks = j)),
					j && u === !1 && (u = null);
				var V = vpe(N);
				(!e.selection || !ie.equals(e.selection, V)) && W.select(e, V),
					N.diff.text
						? R.insertText(e, N.diff.text)
						: R.deleteFragment(e),
					Ti.set(
						e,
						(_ = Ti.get(e)) === null || _ === void 0
							? void 0
							: _.filter((G) => {
									var { id: H } = G;
									return H !== N.id;
								}),
					),
					ppe(e, N) ||
						((F = !1),
						Ql.delete(e),
						Qa.delete(e),
						(i = "action"),
						eu.delete(e),
						n.cancel(),
						r.cancel(),
						I == null || I.unref());
			}
			var K = I == null ? void 0 : I.unref();
			if (
				(K &&
					!eu.get(e) &&
					(!e.selection || !ie.equals(K, e.selection)) &&
					W.select(e, K),
				x())
			) {
				d();
				return;
			}
			F && n(), n.flush(), r.flush(), c();
			var M = Qa.get(e);
			Qa.delete(e), M !== void 0 && ((e.marks = M), e.onChange());
		},
		h = (I) => {
			o && clearTimeout(o),
				(o = setTimeout(() => {
					Nc.set(e, !1), f();
				}, xpe));
		},
		p = (I) => {
			Nc.set(e, !0), o && (clearTimeout(o), (o = null));
		},
		g = function () {
			var F =
					arguments.length > 0 && arguments[0] !== void 0
						? arguments[0]
						: !1,
				N = km.get(e);
			if (N) {
				if (C() || F) {
					N.style.display = "none";
					return;
				}
				N.style.removeProperty("display");
			}
		},
		v = (I, F) => {
			var N,
				O = (N = Ti.get(e)) !== null && N !== void 0 ? N : [];
			Ti.set(e, O);
			var _ = pe.leaf(e, I),
				j = O.findIndex((M) => Y.equals(M.path, I));
			if (j < 0) {
				var V = Nz(_.text, F);
				V && O.push({ path: I, diff: F, id: l++ }), g();
				return;
			}
			var K = bpe(_.text, O[j].diff, F);
			if (!K) {
				O.splice(j, 1), g();
				return;
			}
			O[j] = I1(I1({}, O[j]), {}, { diff: K });
		},
		b = function (F) {
			var { at: N } =
				arguments.length > 1 && arguments[1] !== void 0
					? arguments[1]
					: {};
			(u = !1),
				eu.delete(e),
				n.cancel(),
				r.cancel(),
				x() && f(),
				Ql.set(e, { at: N, run: F }),
				(a = setTimeout(f));
		},
		y = (I) => {
			var F;
			s && (clearTimeout(s), (s = null));
			var { inputType: N } = I,
				O = null,
				_ = I.dataTransfer || I.data || void 0;
			u !== !1 &&
				N !== "insertText" &&
				N !== "insertCompositionText" &&
				(u = !1);
			var [j] = I.getTargetRanges();
			j &&
				(O = te.toSlateRange(e, j, {
					exactMatch: !1,
					suppressThrow: !0,
				}));
			var V = te.getWindow(e),
				K = V.getSelection();
			if (
				(!O &&
					K &&
					((j = K),
					(O = te.toSlateRange(e, K, {
						exactMatch: !1,
						suppressThrow: !0,
					}))),
				(O = (F = O) !== null && F !== void 0 ? F : e.selection),
				!!O)
			) {
				var M = !0;
				if (N.startsWith("delete")) {
					if (ie.isExpanded(O)) {
						var [G, H] = ie.edges(O),
							P = pe.leaf(e, G.path);
						if (P.text.length === G.offset && H.offset === 0) {
							var q = R.next(e, { at: G.path, match: Be.isText });
							q &&
								Y.equals(q[1], H.path) &&
								(O = { anchor: H, focus: H });
						}
					}
					var J = N.endsWith("Backward") ? "backward" : "forward",
						[Z, oe] = ie.edges(O),
						[ne, de] = R.leaf(e, Z.path),
						se = { text: "", start: Z.offset, end: oe.offset },
						re = Ti.get(e),
						he =
							re == null
								? void 0
								: re.find((U) => Y.equals(U.path, de)),
						ye = he ? [he.diff, se] : [se],
						Ae = Pz(ne.text, ...ye);
					if ((Ae.length === 0 && (M = !1), ie.isExpanded(O))) {
						if (M && Y.equals(O.anchor.path, O.focus.path)) {
							var Pe = { path: O.anchor.path, offset: Z.offset },
								we = R.range(e, Pe, Pe);
							return (
								D(we),
								v(O.anchor.path, {
									text: "",
									end: oe.offset,
									start: Z.offset,
								})
							);
						}
						return b(() => R.deleteFragment(e, { direction: J }), {
							at: O,
						});
					}
				}
				switch (N) {
					case "deleteByComposition":
					case "deleteByCut":
					case "deleteByDrag":
						return b(() => R.deleteFragment(e), { at: O });
					case "deleteContent":
					case "deleteContentForward": {
						var { anchor: Ke } = O;
						if (M && ie.isCollapsed(O)) {
							var rt = pe.leaf(e, Ke.path);
							if (Ke.offset < rt.text.length)
								return v(Ke.path, {
									text: "",
									start: Ke.offset,
									end: Ke.offset + 1,
								});
						}
						return b(() => R.deleteForward(e), { at: O });
					}
					case "deleteContentBackward": {
						var Ce,
							{ anchor: Me } = O,
							me = Kw(j)
								? j.isCollapsed
								: !!(
										(Ce = j) !== null &&
										Ce !== void 0 &&
										Ce.collapsed
									);
						return M && me && ie.isCollapsed(O) && Me.offset > 0
							? v(Me.path, {
									text: "",
									start: Me.offset - 1,
									end: Me.offset,
								})
							: b(() => R.deleteBackward(e), { at: O });
					}
					case "deleteEntireSoftLine":
						return b(
							() => {
								R.deleteBackward(e, { unit: "line" }),
									R.deleteForward(e, { unit: "line" });
							},
							{ at: O },
						);
					case "deleteHardLineBackward":
						return b(() => R.deleteBackward(e, { unit: "block" }), {
							at: O,
						});
					case "deleteSoftLineBackward":
						return b(() => R.deleteBackward(e, { unit: "line" }), {
							at: O,
						});
					case "deleteHardLineForward":
						return b(() => R.deleteForward(e, { unit: "block" }), {
							at: O,
						});
					case "deleteSoftLineForward":
						return b(() => R.deleteForward(e, { unit: "line" }), {
							at: O,
						});
					case "deleteWordBackward":
						return b(() => R.deleteBackward(e, { unit: "word" }), {
							at: O,
						});
					case "deleteWordForward":
						return b(() => R.deleteForward(e, { unit: "word" }), {
							at: O,
						});
					case "insertLineBreak":
						return b(() => R.insertSoftBreak(e), { at: O });
					case "insertParagraph":
						return b(() => R.insertBreak(e), { at: O });
					case "insertCompositionText":
					case "deleteCompositionText":
					case "insertFromComposition":
					case "insertFromDrop":
					case "insertFromPaste":
					case "insertFromYank":
					case "insertReplacementText":
					case "insertText": {
						if (wpe(_))
							return b(() => te.insertData(e, _), { at: O });
						var De = _ ?? "";
						if (
							(ks.get(e) && (De = De.replace("\uFEFF", "")),
							N === "insertText" &&
								/.*\n.*\n$/.test(De) &&
								(De = De.slice(0, -1)),
							De.includes(`
`))
						)
							return b(
								() => {
									var U = De.split(`
`);
									U.forEach((tt, Dt) => {
										tt && R.insertText(e, tt),
											Dt !== U.length - 1 &&
												R.insertSoftBreak(e);
									});
								},
								{ at: O },
							);
						if (Y.equals(O.anchor.path, O.focus.path)) {
							var [_e, We] = ie.edges(O),
								Et = {
									start: _e.offset,
									end: We.offset,
									text: De,
								};
							if (De && u && N === "insertCompositionText") {
								var ae = u.start + u.text.search(/\S|$/),
									fe = Et.start + Et.text.search(/\S|$/);
								fe === ae + 1 &&
								Et.end === u.start + u.text.length
									? ((Et.start -= 1), (u = null), A())
									: (u = !1);
							} else
								N === "insertText"
									? u === null
										? (u = Et)
										: u &&
											  ie.isCollapsed(O) &&
											  u.end + u.text.length ===
													_e.offset
											? (u = I1(
													I1({}, u),
													{},
													{ text: u.text + De },
												))
											: (u = !1)
									: (u = !1);
							if (M) {
								v(_e.path, Et);
								return;
							}
						}
						return b(() => R.insertText(e, De), { at: O });
					}
				}
			}
		},
		x = () => !!Ql.get(e),
		C = () => {
			var I;
			return !!((I = Ti.get(e)) !== null && I !== void 0 && I.length);
		},
		k = () => x() || C(),
		w = () => i,
		D = (I) => {
			eu.set(e, I), s && (clearTimeout(s), (s = null));
			var { selection: F } = e;
			if (I) {
				var N = !F || !Y.equals(F.anchor.path, I.anchor.path),
					O =
						!F ||
						!Y.equals(
							F.anchor.path.slice(0, -1),
							I.anchor.path.slice(0, -1),
						);
				((N && u) || O) && (u = !1),
					(N || C()) && (s = setTimeout(f, kpe));
			}
		},
		S = () => {
			(x() || !C()) && f();
		},
		$ = (I) => {
			C() || (g(!0), setTimeout(g));
		},
		A = () => {
			x() || (a = setTimeout(f));
		},
		T = (I) => {
			if (!(C() || x()) && I.some((N) => vS(e, N, I))) {
				var F;
				(F = Uv.get(e)) === null || F === void 0 || F();
			}
		};
	return {
		flush: f,
		scheduleFlush: A,
		hasPendingDiffs: C,
		hasPendingAction: x,
		hasPendingChanges: k,
		isFlushing: w,
		handleUserSelect: D,
		handleCompositionEnd: h,
		handleCompositionStart: p,
		handleDOMBeforeInput: y,
		handleKeyDown: $,
		handleDomMutations: T,
		handleInput: S,
	};
}
function Dpe() {
	var t = E.useRef(!1);
	return (
		E.useEffect(
			() => (
				(t.current = !0),
				() => {
					t.current = !1;
				}
			),
			[],
		),
		t.current
	);
}
function Spe(t, e, n) {
	var [r] = E.useState(() => new MutationObserver(e));
	sg(() => {
		r.takeRecords();
	}),
		E.useEffect(() => {
			if (!t.current)
				throw new Error(
					"Failed to attach MutationObserver, `node` is undefined",
				);
			return r.observe(t.current, n), () => r.disconnect();
		}, []);
}
var Ape = ["node"];
function YT(t, e) {
	var n = Object.keys(t);
	if (Object.getOwnPropertySymbols) {
		var r = Object.getOwnPropertySymbols(t);
		e &&
			(r = r.filter(function (i) {
				return Object.getOwnPropertyDescriptor(t, i).enumerable;
			})),
			n.push.apply(n, r);
	}
	return n;
}
function $pe(t) {
	for (var e = 1; e < arguments.length; e++) {
		var n = arguments[e] != null ? arguments[e] : {};
		e % 2
			? YT(Object(n), !0).forEach(function (r) {
					Wx(t, r, n[r]);
				})
			: Object.getOwnPropertyDescriptors
				? Object.defineProperties(
						t,
						Object.getOwnPropertyDescriptors(n),
					)
				: YT(Object(n)).forEach(function (r) {
						Object.defineProperty(
							t,
							r,
							Object.getOwnPropertyDescriptor(n, r),
						);
					});
	}
	return t;
}
var Tpe = { subtree: !0, childList: !0, characterData: !0 };
function Bpe(t) {
	var { node: e } = t,
		n = Sh(t, Ape);
	if (!_o) return null;
	var r = wn(),
		i = Dpe(),
		[o] = E.useState(() => Epe($pe({ editor: r }, n)));
	return (
		Spe(e, o.handleDomMutations, Tpe),
		gS.set(r, o.scheduleFlush),
		i && o.flush(),
		o
	);
}
function Ipe() {
	var t = wn(),
		e = E.useRef(!1),
		n = E.useRef(0),
		r = E.useCallback(() => {
			if (!e.current) {
				e.current = !0;
				var i = te.getWindow(t);
				i.cancelAnimationFrame(n.current),
					(n.current = i.requestAnimationFrame(() => {
						e.current = !1;
					}));
			}
		}, []);
	return (
		E.useEffect(() => () => cancelAnimationFrame(n.current), []),
		{ receivedUserInput: e, onUserInput: r }
	);
}
var Fpe = [
		"autoFocus",
		"decorate",
		"onDOMBeforeInput",
		"placeholder",
		"readOnly",
		"renderElement",
		"renderLeaf",
		"renderPlaceholder",
		"scrollSelectionIntoView",
		"style",
		"as",
		"disableDefaultStyles",
	],
	Ppe = ["text"];
function JT(t, e) {
	var n = Object.keys(t);
	if (Object.getOwnPropertySymbols) {
		var r = Object.getOwnPropertySymbols(t);
		e &&
			(r = r.filter(function (i) {
				return Object.getOwnPropertyDescriptor(t, i).enumerable;
			})),
			n.push.apply(n, r);
	}
	return n;
}
function mf(t) {
	for (var e = 1; e < arguments.length; e++) {
		var n = arguments[e] != null ? arguments[e] : {};
		e % 2
			? JT(Object(n), !0).forEach(function (r) {
					Wx(t, r, n[r]);
				})
			: Object.getOwnPropertyDescriptors
				? Object.defineProperties(
						t,
						Object.getOwnPropertyDescriptors(n),
					)
				: JT(Object(n)).forEach(function (r) {
						Object.defineProperty(
							t,
							r,
							Object.getOwnPropertyDescriptor(n, r),
						);
					});
	}
	return t;
}
var Npe = (t) => le.createElement(le.Fragment, null, Tz(t)),
	Rpe = (t) => {
		var e,
			n,
			r = E.useCallback(
				(P) => le.createElement(Ope, Object.assign({}, P)),
				[],
			),
			{
				autoFocus: i,
				decorate: o = Mpe,
				onDOMBeforeInput: s,
				placeholder: a,
				readOnly: l = !1,
				renderElement: u,
				renderLeaf: c,
				renderPlaceholder: d = r,
				scrollSelectionIntoView: f = jpe,
				style: h = {},
				as: p = "div",
				disableDefaultStyles: g = !1,
			} = t,
			v = Sh(t, Fpe),
			b = Gx(),
			[y, x] = E.useState(!1),
			C = E.useRef(null),
			k = E.useRef([]),
			{ onUserInput: w, receivedUserInput: D } = Ipe(),
			[, S] = E.useReducer((P) => P + 1, 0);
		Uv.set(b, S), Lw.set(b, l);
		var $ = E.useMemo(
			() => ({
				isDraggingInternally: !1,
				isUpdatingSelection: !1,
				latestElement: null,
				hasMarkPlaceholder: !1,
			}),
			[],
		);
		E.useEffect(() => {
			C.current && i && C.current.focus();
		}, [i]);
		var A = E.useCallback(
				Jde(() => {
					if (
						(_o || !te.isComposing(b)) &&
						(!$.isUpdatingSelection ||
							(I != null && I.isFlushing())) &&
						!$.isDraggingInternally
					) {
						var P = te.findDocumentOrShadowRoot(b),
							{ activeElement: q } = P,
							J = te.toDOMNode(b, b),
							Z = P.getSelection();
						if (
							(q === J
								? (($.latestElement = q), Pc.set(b, !0))
								: Pc.delete(b),
							!Z)
						)
							return W.deselect(b);
						var { anchorNode: oe, focusNode: ne } = Z,
							de =
								te.hasEditableTarget(b, oe) ||
								te.isTargetInsideNonReadonlyVoid(b, oe),
							se =
								te.hasEditableTarget(b, ne) ||
								te.isTargetInsideNonReadonlyVoid(b, ne);
						if (de && se) {
							var re = te.toSlateRange(b, Z, {
								exactMatch: !1,
								suppressThrow: !0,
							});
							re &&
								(!te.isComposing(b) &&
								!(I != null && I.hasPendingChanges()) &&
								!(I != null && I.isFlushing())
									? W.select(b, re)
									: I == null || I.handleUserSelect(re));
						}
						l && (!de || !se) && W.deselect(b);
					}
				}, 100),
				[l],
			),
			T = E.useMemo(() => Ude(A, 0), [A]),
			I = Bpe({
				node: C,
				onDOMSelectionChange: A,
				scheduleOnDOMSelectionChange: T,
			});
		sg(() => {
			var P;
			C.current && (P = bS(C.current))
				? (vz.set(b, P),
					hb.set(b, C.current),
					Qc.set(b, C.current),
					og.set(C.current, b))
				: Qc.delete(b);
			var { selection: q } = b,
				J = te.findDocumentOrShadowRoot(b),
				Z = J.getSelection();
			if (
				!(!Z || !te.isFocused(b) || (I != null && I.hasPendingAction()))
			) {
				var oe = (he) => {
						var ye = Z.type !== "None";
						if (!(!q && !ye)) {
							var Ae = hb.get(b),
								Pe = !1;
							if (
								(Ae.contains(Z.anchorNode) &&
									Ae.contains(Z.focusNode) &&
									(Pe = !0),
								ye && Pe && q && !he)
							) {
								var we = te.toSlateRange(b, Z, {
									exactMatch: !0,
									suppressThrow: !0,
								});
								if (we && ie.equals(we, q)) {
									var Ke;
									if (!$.hasMarkPlaceholder) return;
									var { anchorNode: rt } = Z;
									if (
										rt != null &&
										(Ke = rt.parentElement) !== null &&
										Ke !== void 0 &&
										Ke.hasAttribute(
											"data-slate-mark-placeholder",
										)
									)
										return;
								}
							}
							if (q && !te.hasRange(b, q)) {
								b.selection = te.toSlateRange(b, Z, {
									exactMatch: !1,
									suppressThrow: !0,
								});
								return;
							}
							$.isUpdatingSelection = !0;
							var Ce = q && te.toDOMRange(b, q);
							return (
								Ce
									? (ie.isBackward(q)
											? Z.setBaseAndExtent(
													Ce.endContainer,
													Ce.endOffset,
													Ce.startContainer,
													Ce.startOffset,
												)
											: Z.setBaseAndExtent(
													Ce.startContainer,
													Ce.startOffset,
													Ce.endContainer,
													Ce.endOffset,
												),
										f(b, Ce))
									: Z.removeAllRanges(),
								Ce
							);
						}
					},
					ne = oe(),
					de = (I == null ? void 0 : I.isFlushing()) === "action";
				if (!_o || !de) {
					setTimeout(() => {
						if (ne && Hv) {
							var he = te.toDOMNode(b, b);
							he.focus();
						}
						$.isUpdatingSelection = !1;
					});
					return;
				}
				var se = null,
					re = requestAnimationFrame(() => {
						if (de) {
							var he = (ye) => {
								try {
									var Ae = te.toDOMNode(b, b);
									Ae.focus(), oe(ye);
								} catch {}
							};
							he(),
								(se = setTimeout(() => {
									he(!0), ($.isUpdatingSelection = !1);
								}));
						}
					});
				return () => {
					cancelAnimationFrame(re), se && clearTimeout(se);
				};
			}
		});
		var F = E.useCallback(
				(P) => {
					if (
						(w(),
						!l && te.hasEditableTarget(b, P.target) && !_pe(P, s))
					) {
						var q;
						if (I) return I.handleDOMBeforeInput(P);
						T.flush(), A.flush();
						var { selection: J } = b,
							{ inputType: Z } = P,
							oe = P.dataTransfer || P.data || void 0,
							ne =
								Z === "insertCompositionText" ||
								Z === "deleteCompositionText";
						if (ne && te.isComposing(b)) return;
						var de = !1;
						if (
							Z === "insertText" &&
							J &&
							ie.isCollapsed(J) &&
							P.data &&
							P.data.length === 1 &&
							/[a-z ]/i.test(P.data) &&
							J.anchor.offset !== 0
						) {
							var se, re;
							(de = !0), b.marks && (de = !1);
							var { anchor: he } = J,
								[ye, Ae] = te.toDOMPoint(b, he),
								Pe =
									(se = ye.parentElement) === null ||
									se === void 0
										? void 0
										: se.closest("a"),
								we = te.getWindow(b);
							if (de && Pe && te.hasDOMNode(b, Pe)) {
								var Ke,
									rt =
										we == null
											? void 0
											: we.document
													.createTreeWalker(
														Pe,
														NodeFilter.SHOW_TEXT,
													)
													.lastChild();
								rt === ye &&
									((Ke = rt.textContent) === null ||
									Ke === void 0
										? void 0
										: Ke.length) === Ae &&
									(de = !1);
							}
							if (
								de &&
								ye.parentElement &&
								(we == null ||
								(re = we.getComputedStyle(ye.parentElement)) ===
									null ||
								re === void 0
									? void 0
									: re.whiteSpace) === "pre"
							) {
								var Ce = R.above(b, {
									at: he.path,
									match: (Et) =>
										$e.isElement(Et) && R.isBlock(b, Et),
								});
								Ce &&
									pe.string(Ce[0]).includes("	") &&
									(de = !1);
							}
						}
						if (
							!Z.startsWith("delete") ||
							Z.startsWith("deleteBy")
						) {
							var [Me] = P.getTargetRanges();
							if (Me) {
								var me = te.toSlateRange(b, Me, {
									exactMatch: !1,
									suppressThrow: !1,
								});
								if (!J || !ie.equals(J, me)) {
									de = !1;
									var De =
										!ne &&
										b.selection &&
										R.rangeRef(b, b.selection);
									W.select(b, me), De && Cm.set(b, De);
								}
							}
						}
						if (ne) return;
						if (
							(de || P.preventDefault(),
							J && ie.isExpanded(J) && Z.startsWith("delete"))
						) {
							var _e = Z.endsWith("Backward")
								? "backward"
								: "forward";
							R.deleteFragment(b, { direction: _e });
							return;
						}
						switch (Z) {
							case "deleteByComposition":
							case "deleteByCut":
							case "deleteByDrag": {
								R.deleteFragment(b);
								break;
							}
							case "deleteContent":
							case "deleteContentForward": {
								R.deleteForward(b);
								break;
							}
							case "deleteContentBackward": {
								R.deleteBackward(b);
								break;
							}
							case "deleteEntireSoftLine": {
								R.deleteBackward(b, { unit: "line" }),
									R.deleteForward(b, { unit: "line" });
								break;
							}
							case "deleteHardLineBackward": {
								R.deleteBackward(b, { unit: "block" });
								break;
							}
							case "deleteSoftLineBackward": {
								R.deleteBackward(b, { unit: "line" });
								break;
							}
							case "deleteHardLineForward": {
								R.deleteForward(b, { unit: "block" });
								break;
							}
							case "deleteSoftLineForward": {
								R.deleteForward(b, { unit: "line" });
								break;
							}
							case "deleteWordBackward": {
								R.deleteBackward(b, { unit: "word" });
								break;
							}
							case "deleteWordForward": {
								R.deleteForward(b, { unit: "word" });
								break;
							}
							case "insertLineBreak":
								R.insertSoftBreak(b);
								break;
							case "insertParagraph": {
								R.insertBreak(b);
								break;
							}
							case "insertFromComposition":
							case "insertFromDrop":
							case "insertFromPaste":
							case "insertFromYank":
							case "insertReplacementText":
							case "insertText": {
								Z === "insertFromComposition" &&
									te.isComposing(b) &&
									(x(!1), Nc.set(b, !1)),
									(oe == null
										? void 0
										: oe.constructor.name) ===
									"DataTransfer"
										? te.insertData(b, oe)
										: typeof oe == "string" &&
											(de
												? k.current.push(() =>
														R.insertText(b, oe),
													)
												: R.insertText(b, oe));
								break;
							}
						}
						var We =
							(q = Cm.get(b)) === null || q === void 0
								? void 0
								: q.unref();
						Cm.delete(b),
							We &&
								(!b.selection || !ie.equals(b.selection, We)) &&
								W.select(b, We);
					}
				},
				[l, s],
			),
			N = E.useCallback(
				(P) => {
					P == null
						? (A.cancel(),
							T.cancel(),
							hb.delete(b),
							Qc.delete(b),
							C.current &&
								Ll &&
								C.current.removeEventListener("beforeinput", F))
						: Ll && P.addEventListener("beforeinput", F),
						(C.current = P);
				},
				[C, F, A, T],
			);
		sg(() => {
			var P = te.getWindow(b);
			return (
				P.document.addEventListener("selectionchange", T),
				() => {
					P.document.removeEventListener("selectionchange", T);
				}
			);
		}, [T]);
		var O = o([b, []]);
		if (
			a &&
			b.children.length === 1 &&
			Array.from(pe.texts(b)).length === 1 &&
			pe.string(b) === "" &&
			!y
		) {
			var _ = R.start(b, []);
			O.push({ [Ah]: !0, placeholder: a, anchor: _, focus: _ });
		}
		var { marks: j } = b;
		if (
			(($.hasMarkPlaceholder = !1),
			b.selection && ie.isCollapsed(b.selection) && j)
		) {
			var { anchor: V } = b.selection,
				K = pe.leaf(b, V.path),
				M = Sh(K, Ppe);
			if (!Be.equals(K, j, { loose: !0 })) {
				$.hasMarkPlaceholder = !0;
				var G = Object.fromEntries(
					Object.keys(M).map((P) => [P, null]),
				);
				O.push(
					mf(mf(mf({ [yz]: !0 }, G), j), {}, { anchor: V, focus: V }),
				);
			}
		}
		E.useEffect(() => {
			setTimeout(() => {
				var { selection: P } = b;
				if (P) {
					var { anchor: q } = P,
						J = pe.leaf(b, q.path);
					if (j && !Be.equals(J, j, { loose: !0 })) {
						ks.set(b, j);
						return;
					}
				}
				ks.delete(b);
			});
		});
		var H =
			(e = km.get(b)) === null ||
			e === void 0 ||
			(n = e.getBoundingClientRect()) === null ||
			n === void 0
				? void 0
				: n.height;
		return le.createElement(
			Bz.Provider,
			{ value: l },
			le.createElement(
				Sz.Provider,
				{ value: o },
				le.createElement(
					hpe,
					{ node: C, receivedUserInput: D },
					le.createElement(
						p,
						Object.assign(
							{
								role: l ? void 0 : "textbox",
								"aria-multiline": l ? void 0 : !0,
							},
							v,
							{
								spellCheck: Ll || !pb ? v.spellCheck : !1,
								autoCorrect:
									Ll || !pb ? v.autoCorrect : "false",
								autoCapitalize:
									Ll || !pb ? v.autoCapitalize : "false",
								"data-slate-editor": !0,
								"data-slate-node": "value",
								contentEditable: !l,
								zindex: -1,
								suppressContentEditableWarning: !0,
								ref: N,
								style: mf(
									mf(
										{},
										g
											? {}
											: mf(
													{
														position: "relative",
														outline: "none",
														whiteSpace: "pre-wrap",
														wordWrap: "break-word",
													},
													H ? { minHeight: H } : {},
												),
									),
									h,
								),
								onBeforeInput: E.useCallback(
									(P) => {
										if (
											!Ll &&
											!l &&
											!ni(P, v.onBeforeInput) &&
											te.hasSelectableTarget(
												b,
												P.target,
											) &&
											(P.preventDefault(),
											!te.isComposing(b))
										) {
											var q = P.data;
											R.insertText(b, q);
										}
									},
									[l],
								),
								onInput: E.useCallback((P) => {
									if (!ni(P, v.onInput)) {
										if (I) {
											I.handleInput();
											return;
										}
										for (var q of k.current) q();
										k.current = [];
									}
								}, []),
								onBlur: E.useCallback(
									(P) => {
										if (
											!(
												l ||
												$.isUpdatingSelection ||
												!te.hasSelectableTarget(
													b,
													P.target,
												) ||
												ni(P, v.onBlur)
											)
										) {
											var q =
												te.findDocumentOrShadowRoot(b);
											if (
												$.latestElement !==
												q.activeElement
											) {
												var { relatedTarget: J } = P,
													Z = te.toDOMNode(b, b);
												if (
													J !== Z &&
													!(
														No(J) &&
														J.hasAttribute(
															"data-slate-spacer",
														)
													)
												) {
													if (
														J != null &&
														wd(J) &&
														te.hasDOMNode(b, J)
													) {
														var oe = te.toSlateNode(
															b,
															J,
														);
														if (
															$e.isElement(oe) &&
															!b.isVoid(oe)
														)
															return;
													}
													if (B1) {
														var ne =
															q.getSelection();
														ne == null ||
															ne.removeAllRanges();
													}
													Pc.delete(b);
												}
											}
										}
									},
									[l, v.onBlur],
								),
								onClick: E.useCallback(
									(P) => {
										if (
											te.hasTarget(b, P.target) &&
											!ni(P, v.onClick) &&
											wd(P.target)
										) {
											var q = te.toSlateNode(b, P.target),
												J = te.findPath(b, q);
											if (
												!R.hasPath(b, J) ||
												pe.get(b, J) !== q
											)
												return;
											if (
												P.detail === ape &&
												J.length >= 1
											) {
												var Z = J;
												if (
													!(
														$e.isElement(q) &&
														R.isBlock(b, q)
													)
												) {
													var oe,
														ne = R.above(b, {
															match: (Pe) =>
																$e.isElement(
																	Pe,
																) &&
																R.isBlock(
																	b,
																	Pe,
																),
															at: J,
														});
													Z =
														(oe =
															ne == null
																? void 0
																: ne[1]) !==
															null &&
														oe !== void 0
															? oe
															: J.slice(0, 1);
												}
												var de = R.range(b, Z);
												W.select(b, de);
												return;
											}
											if (l) return;
											var se = R.start(b, J),
												re = R.end(b, J),
												he = R.void(b, { at: se }),
												ye = R.void(b, { at: re });
											if (
												he &&
												ye &&
												Y.equals(he[1], ye[1])
											) {
												var Ae = R.range(b, se);
												W.select(b, Ae);
											}
										}
									},
									[l, v.onClick],
								),
								onCompositionEnd: E.useCallback(
									(P) => {
										if (
											te.hasSelectableTarget(b, P.target)
										) {
											if (
												(te.isComposing(b) &&
													(x(!1), Nc.set(b, !1)),
												I == null ||
													I.handleCompositionEnd(P),
												ni(P, v.onCompositionEnd) || _o)
											)
												return;
											if (
												!B1 &&
												!Vhe &&
												!jhe &&
												!Uhe &&
												!Khe &&
												P.data
											) {
												var q = ks.get(b);
												ks.delete(b),
													q !== void 0 &&
														(Qa.set(b, b.marks),
														(b.marks = q)),
													R.insertText(b, P.data);
												var J = Qa.get(b);
												Qa.delete(b),
													J !== void 0 &&
														(b.marks = J);
											}
										}
									},
									[v.onCompositionEnd],
								),
								onCompositionUpdate: E.useCallback(
									(P) => {
										te.hasSelectableTarget(b, P.target) &&
											!ni(P, v.onCompositionUpdate) &&
											(te.isComposing(b) ||
												(x(!0), Nc.set(b, !0)));
									},
									[v.onCompositionUpdate],
								),
								onCompositionStart: E.useCallback(
									(P) => {
										if (
											te.hasSelectableTarget(b, P.target)
										) {
											if (
												(I == null ||
													I.handleCompositionStart(P),
												ni(P, v.onCompositionStart) ||
													_o)
											)
												return;
											x(!0);
											var { selection: q } = b;
											if (q) {
												if (ie.isExpanded(q)) {
													R.deleteFragment(b);
													return;
												}
												var J = R.above(b, {
													match: (ne) =>
														$e.isElement(ne) &&
														R.isInline(b, ne),
													mode: "highest",
												});
												if (J) {
													var [, Z] = J;
													if (
														R.isEnd(b, q.anchor, Z)
													) {
														var oe = R.after(b, Z);
														W.setSelection(b, {
															anchor: oe,
															focus: oe,
														});
													}
												}
											}
										}
									},
									[v.onCompositionStart],
								),
								onCopy: E.useCallback(
									(P) => {
										te.hasSelectableTarget(b, P.target) &&
											!ni(P, v.onCopy) &&
											(P.preventDefault(),
											te.setFragmentData(
												b,
												P.clipboardData,
												"copy",
											));
									},
									[v.onCopy],
								),
								onCut: E.useCallback(
									(P) => {
										if (
											!l &&
											te.hasSelectableTarget(
												b,
												P.target,
											) &&
											!ni(P, v.onCut)
										) {
											P.preventDefault(),
												te.setFragmentData(
													b,
													P.clipboardData,
													"cut",
												);
											var { selection: q } = b;
											if (q)
												if (ie.isExpanded(q))
													R.deleteFragment(b);
												else {
													var J = pe.parent(
														b,
														q.anchor.path,
													);
													R.isVoid(b, J) &&
														W.delete(b);
												}
										}
									},
									[l, v.onCut],
								),
								onDragOver: E.useCallback(
									(P) => {
										if (
											te.hasTarget(b, P.target) &&
											!ni(P, v.onDragOver)
										) {
											var q = te.toSlateNode(b, P.target);
											$e.isElement(q) &&
												R.isVoid(b, q) &&
												P.preventDefault();
										}
									},
									[v.onDragOver],
								),
								onDragStart: E.useCallback(
									(P) => {
										if (
											!l &&
											te.hasTarget(b, P.target) &&
											!ni(P, v.onDragStart)
										) {
											var q = te.toSlateNode(b, P.target),
												J = te.findPath(b, q),
												Z =
													($e.isElement(q) &&
														R.isVoid(b, q)) ||
													R.void(b, {
														at: J,
														voids: !0,
													});
											if (Z) {
												var oe = R.range(b, J);
												W.select(b, oe);
											}
											($.isDraggingInternally = !0),
												te.setFragmentData(
													b,
													P.dataTransfer,
													"drag",
												);
										}
									},
									[l, v.onDragStart],
								),
								onDrop: E.useCallback(
									(P) => {
										if (
											!l &&
											te.hasTarget(b, P.target) &&
											!ni(P, v.onDrop)
										) {
											P.preventDefault();
											var q = b.selection,
												J = te.findEventRange(b, P),
												Z = P.dataTransfer;
											W.select(b, J),
												$.isDraggingInternally &&
													q &&
													!ie.equals(q, J) &&
													!R.void(b, {
														at: J,
														voids: !0,
													}) &&
													W.delete(b, { at: q }),
												te.insertData(b, Z),
												te.isFocused(b) || te.focus(b);
										}
										$.isDraggingInternally = !1;
									},
									[l, v.onDrop],
								),
								onDragEnd: E.useCallback(
									(P) => {
										!l &&
											$.isDraggingInternally &&
											v.onDragEnd &&
											te.hasTarget(b, P.target) &&
											v.onDragEnd(P),
											($.isDraggingInternally = !1);
									},
									[l, v.onDragEnd],
								),
								onFocus: E.useCallback(
									(P) => {
										if (
											!l &&
											!$.isUpdatingSelection &&
											te.hasEditableTarget(b, P.target) &&
											!ni(P, v.onFocus)
										) {
											var q = te.toDOMNode(b, b),
												J =
													te.findDocumentOrShadowRoot(
														b,
													);
											if (
												(($.latestElement =
													J.activeElement),
												Hv && P.target !== q)
											) {
												q.focus();
												return;
											}
											Pc.set(b, !0);
										}
									},
									[l, v.onFocus],
								),
								onKeyDown: E.useCallback(
									(P) => {
										if (
											!l &&
											te.hasEditableTarget(b, P.target)
										) {
											I == null || I.handleKeyDown(P);
											var { nativeEvent: q } = P;
											if (
												(te.isComposing(b) &&
													q.isComposing === !1 &&
													(Nc.set(b, !1), x(!1)),
												ni(P, v.onKeyDown) ||
													te.isComposing(b))
											)
												return;
											var { selection: J } = b,
												Z =
													b.children[
														J !== null
															? J.focus.path[0]
															: 0
													],
												oe = X_(pe.string(Z)) === "rtl";
											if (vn.isRedo(q)) {
												P.preventDefault();
												var ne = b;
												typeof ne.redo == "function" &&
													ne.redo();
												return;
											}
											if (vn.isUndo(q)) {
												P.preventDefault();
												var de = b;
												typeof de.undo == "function" &&
													de.undo();
												return;
											}
											if (vn.isMoveLineBackward(q)) {
												P.preventDefault(),
													W.move(b, {
														unit: "line",
														reverse: !0,
													});
												return;
											}
											if (vn.isMoveLineForward(q)) {
												P.preventDefault(),
													W.move(b, { unit: "line" });
												return;
											}
											if (vn.isExtendLineBackward(q)) {
												P.preventDefault(),
													W.move(b, {
														unit: "line",
														edge: "focus",
														reverse: !0,
													});
												return;
											}
											if (vn.isExtendLineForward(q)) {
												P.preventDefault(),
													W.move(b, {
														unit: "line",
														edge: "focus",
													});
												return;
											}
											if (vn.isMoveBackward(q)) {
												P.preventDefault(),
													J && ie.isCollapsed(J)
														? W.move(b, {
																reverse: !oe,
															})
														: W.collapse(b, {
																edge: "start",
															});
												return;
											}
											if (vn.isMoveForward(q)) {
												P.preventDefault(),
													J && ie.isCollapsed(J)
														? W.move(b, {
																reverse: oe,
															})
														: W.collapse(b, {
																edge: "end",
															});
												return;
											}
											if (vn.isMoveWordBackward(q)) {
												P.preventDefault(),
													J &&
														ie.isExpanded(J) &&
														W.collapse(b, {
															edge: "focus",
														}),
													W.move(b, {
														unit: "word",
														reverse: !oe,
													});
												return;
											}
											if (vn.isMoveWordForward(q)) {
												P.preventDefault(),
													J &&
														ie.isExpanded(J) &&
														W.collapse(b, {
															edge: "focus",
														}),
													W.move(b, {
														unit: "word",
														reverse: oe,
													});
												return;
											}
											if (Ll) {
												if (
													(wz || B1) &&
													J &&
													(vn.isDeleteBackward(q) ||
														vn.isDeleteForward(
															q,
														)) &&
													ie.isCollapsed(J)
												) {
													var se = pe.parent(
														b,
														J.anchor.path,
													);
													if (
														$e.isElement(se) &&
														R.isVoid(b, se) &&
														(R.isInline(b, se) ||
															R.isBlock(b, se))
													) {
														P.preventDefault(),
															R.deleteBackward(
																b,
																{
																	unit: "block",
																},
															);
														return;
													}
												}
											} else {
												if (
													vn.isBold(q) ||
													vn.isItalic(q) ||
													vn.isTransposeCharacter(q)
												) {
													P.preventDefault();
													return;
												}
												if (vn.isSoftBreak(q)) {
													P.preventDefault(),
														R.insertSoftBreak(b);
													return;
												}
												if (vn.isSplitBlock(q)) {
													P.preventDefault(),
														R.insertBreak(b);
													return;
												}
												if (vn.isDeleteBackward(q)) {
													P.preventDefault(),
														J && ie.isExpanded(J)
															? R.deleteFragment(
																	b,
																	{
																		direction:
																			"backward",
																	},
																)
															: R.deleteBackward(
																	b,
																);
													return;
												}
												if (vn.isDeleteForward(q)) {
													P.preventDefault(),
														J && ie.isExpanded(J)
															? R.deleteFragment(
																	b,
																	{
																		direction:
																			"forward",
																	},
																)
															: R.deleteForward(
																	b,
																);
													return;
												}
												if (
													vn.isDeleteLineBackward(q)
												) {
													P.preventDefault(),
														J && ie.isExpanded(J)
															? R.deleteFragment(
																	b,
																	{
																		direction:
																			"backward",
																	},
																)
															: R.deleteBackward(
																	b,
																	{
																		unit: "line",
																	},
																);
													return;
												}
												if (vn.isDeleteLineForward(q)) {
													P.preventDefault(),
														J && ie.isExpanded(J)
															? R.deleteFragment(
																	b,
																	{
																		direction:
																			"forward",
																	},
																)
															: R.deleteForward(
																	b,
																	{
																		unit: "line",
																	},
																);
													return;
												}
												if (
													vn.isDeleteWordBackward(q)
												) {
													P.preventDefault(),
														J && ie.isExpanded(J)
															? R.deleteFragment(
																	b,
																	{
																		direction:
																			"backward",
																	},
																)
															: R.deleteBackward(
																	b,
																	{
																		unit: "word",
																	},
																);
													return;
												}
												if (vn.isDeleteWordForward(q)) {
													P.preventDefault(),
														J && ie.isExpanded(J)
															? R.deleteFragment(
																	b,
																	{
																		direction:
																			"forward",
																	},
																)
															: R.deleteForward(
																	b,
																	{
																		unit: "word",
																	},
																);
													return;
												}
											}
										}
									},
									[l, v.onKeyDown],
								),
								onPaste: E.useCallback(
									(P) => {
										!l &&
											te.hasEditableTarget(b, P.target) &&
											!ni(P, v.onPaste) &&
											(!Ll || Ihe(P.nativeEvent) || B1) &&
											(P.preventDefault(),
											te.insertData(b, P.clipboardData));
									},
									[l, v.onPaste],
								),
							},
						),
						le.createElement(Npe, {
							decorations: O,
							node: b,
							renderElement: u,
							renderPlaceholder: d,
							renderLeaf: c,
							selection: b.selection,
						}),
					),
				),
			),
		);
	},
	Ope = (t) => {
		var { attributes: e, children: n } = t;
		return le.createElement(
			"span",
			Object.assign({}, e),
			n,
			_o && le.createElement("br", null),
		);
	},
	Mpe = () => [],
	jpe = (t, e) => {
		if (
			e.getBoundingClientRect &&
			(!t.selection || (t.selection && ie.isCollapsed(t.selection)))
		) {
			var n = e.startContainer.parentElement;
			(n.getBoundingClientRect = e.getBoundingClientRect.bind(e)),
				Qde(n, { scrollMode: "if-needed" }),
				delete n.getBoundingClientRect;
		}
	},
	ni = (t, e) => {
		if (!e) return !1;
		var n = e(t);
		return n ?? (t.isDefaultPrevented() || t.isPropagationStopped());
	},
	_pe = (t, e) => {
		if (!e) return !1;
		var n = e(t);
		return n ?? t.defaultPrevented;
	},
	zpe = E.createContext(!1),
	Lpe = E.createContext({});
function Vpe(t) {
	var e = E.useRef([]).current,
		n = E.useRef({ editor: t }).current,
		r = E.useCallback((o) => {
			(n.editor = o), e.forEach((s) => s(o));
		}, []),
		i = E.useMemo(
			() => ({
				getSlate: () => n.editor,
				addEventListener: (o) => (
					e.push(o),
					() => {
						e.splice(e.indexOf(o), 1);
					}
				),
			}),
			[e, n],
		);
	return { selectorContext: i, onChange: r };
}
var Kpe = ["editor", "children", "onChange", "value"],
	Upe = (t) => {
		var { editor: e, children: n, onChange: r, value: i } = t,
			o = Sh(t, Kpe),
			s = E.useRef(!1),
			[a, l] = le.useState(() => {
				if (!pe.isNodeList(i))
					throw new Error(
						"[Slate] value is invalid! Expected a list of elements but got: ".concat(
							dr.stringify(i),
						),
					);
				if (!R.isEditor(e))
					throw new Error(
						"[Slate] editor is invalid! You passed: ".concat(
							dr.stringify(e),
						),
					);
				return (
					(e.children = i), Object.assign(e, o), { v: 0, editor: e }
				);
			}),
			{ selectorContext: u, onChange: c } = Vpe(e),
			d = E.useCallback(() => {
				r && r(e.children), l((p) => ({ v: p.v + 1, editor: e })), c(e);
			}, [r]);
		E.useEffect(
			() => (
				Vw.set(e, d),
				() => {
					Vw.set(e, () => {}), (s.current = !0);
				}
			),
			[d],
		);
		var [f, h] = E.useState(te.isFocused(e));
		return (
			E.useEffect(() => {
				h(te.isFocused(e));
			}),
			sg(() => {
				var p = () => h(te.isFocused(e));
				return Mhe
					? (document.addEventListener("focusin", p),
						document.addEventListener("focusout", p),
						() => {
							document.removeEventListener("focusin", p),
								document.removeEventListener("focusout", p);
						})
					: (document.addEventListener("focus", p, !0),
						document.addEventListener("blur", p, !0),
						() => {
							document.removeEventListener("focus", p, !0),
								document.removeEventListener("blur", p, !0);
						});
			}, []),
			le.createElement(
				Lpe.Provider,
				{ value: u },
				le.createElement(
					Iz.Provider,
					{ value: a },
					le.createElement(
						yS.Provider,
						{ value: a.editor },
						le.createElement(zpe.Provider, { value: f }, n),
					),
				),
			)
		);
	},
	XT = (t, e) => {
		var n = (e.top + e.bottom) / 2;
		return t.top <= n && t.bottom >= n;
	},
	ZT = (t, e, n) => {
		var r = te.toDOMRange(t, e).getBoundingClientRect(),
			i = te.toDOMRange(t, n).getBoundingClientRect();
		return XT(r, i) && XT(i, r);
	},
	Hpe = (t, e) => {
		var n = R.range(t, ie.end(e)),
			r = Array.from(R.positions(t, { at: e })),
			i = 0,
			o = r.length,
			s = Math.floor(o / 2);
		if (ZT(t, R.range(t, r[i]), n)) return R.range(t, r[i], n);
		if (r.length < 2) return R.range(t, r[r.length - 1], n);
		for (; s !== r.length && s !== i; )
			ZT(t, R.range(t, r[s]), n) ? (o = s) : (i = s),
				(s = Math.floor((i + o) / 2));
		return R.range(t, r[o], n);
	};
function QT(t, e) {
	var n = Object.keys(t);
	if (Object.getOwnPropertySymbols) {
		var r = Object.getOwnPropertySymbols(t);
		e &&
			(r = r.filter(function (i) {
				return Object.getOwnPropertyDescriptor(t, i).enumerable;
			})),
			n.push.apply(n, r);
	}
	return n;
}
function eB(t) {
	for (var e = 1; e < arguments.length; e++) {
		var n = arguments[e] != null ? arguments[e] : {};
		e % 2
			? QT(Object(n), !0).forEach(function (r) {
					Wx(t, r, n[r]);
				})
			: Object.getOwnPropertyDescriptors
				? Object.defineProperties(
						t,
						Object.getOwnPropertyDescriptors(n),
					)
				: QT(Object(n)).forEach(function (r) {
						Object.defineProperty(
							t,
							r,
							Object.getOwnPropertyDescriptor(n, r),
						);
					});
	}
	return t;
}
var Wpe = function (e) {
		var n =
				arguments.length > 1 && arguments[1] !== void 0
					? arguments[1]
					: "x-slate-fragment",
			r = e,
			{
				apply: i,
				onChange: o,
				deleteBackward: s,
				addMark: a,
				removeMark: l,
			} = r;
		return (
			qx.set(r, new WeakMap()),
			(r.addMark = (u, c) => {
				var d, f;
				(d = gS.get(r)) === null || d === void 0 || d(),
					!ks.get(r) &&
						(f = Ti.get(r)) !== null &&
						f !== void 0 &&
						f.length &&
						ks.set(r, null),
					Qa.delete(r),
					a(u, c);
			}),
			(r.removeMark = (u) => {
				var c;
				!ks.get(r) &&
					(c = Ti.get(r)) !== null &&
					c !== void 0 &&
					c.length &&
					ks.set(r, null),
					Qa.delete(r),
					l(u);
			}),
			(r.deleteBackward = (u) => {
				if (u !== "line") return s(u);
				if (r.selection && ie.isCollapsed(r.selection)) {
					var c = R.above(r, {
						match: (p) => $e.isElement(p) && R.isBlock(r, p),
						at: r.selection,
					});
					if (c) {
						var [, d] = c,
							f = R.range(r, d, r.selection.anchor),
							h = Hpe(r, f);
						ie.isCollapsed(h) || W.delete(r, { at: h });
					}
				}
			}),
			(r.apply = (u) => {
				var c = [],
					d = Ti.get(r);
				if (d != null && d.length) {
					var f = d.map((w) => ype(w, u)).filter(Boolean);
					Ti.set(r, f);
				}
				var h = eu.get(r);
				h && eu.set(r, qT(r, h, u));
				var p = Ql.get(r);
				if (p != null && p.at) {
					var g = ut.isPoint(p == null ? void 0 : p.at)
						? Hw(r, p.at, u)
						: qT(r, p.at, u);
					Ql.set(r, g ? eB(eB({}, p), {}, { at: g }) : null);
				}
				switch (u.type) {
					case "insert_text":
					case "remove_text":
					case "set_node":
					case "split_node": {
						c.push(...F1(r, u.path));
						break;
					}
					case "set_selection": {
						var v;
						(v = Cm.get(r)) === null || v === void 0 || v.unref(),
							Cm.delete(r);
						break;
					}
					case "insert_node":
					case "remove_node": {
						c.push(...F1(r, Y.parent(u.path)));
						break;
					}
					case "merge_node": {
						var b = Y.previous(u.path);
						c.push(...F1(r, b));
						break;
					}
					case "move_node": {
						var y = Y.common(Y.parent(u.path), Y.parent(u.newPath));
						c.push(...F1(r, y));
						break;
					}
				}
				i(u);
				for (var [x, C] of c) {
					var [k] = R.node(r, x);
					zw.set(k, C);
				}
			}),
			(r.setFragmentData = (u) => {
				var { selection: c } = r;
				if (c) {
					var [d, f] = ie.edges(c),
						h = R.void(r, { at: d.path }),
						p = R.void(r, { at: f.path });
					if (!(ie.isCollapsed(c) && !h)) {
						var g = te.toDOMRange(r, c),
							v = g.cloneContents(),
							b = v.childNodes[0];
						if (
							(v.childNodes.forEach((A) => {
								A.textContent &&
									A.textContent.trim() !== "" &&
									(b = A);
							}),
							p)
						) {
							var [y] = p,
								x = g.cloneRange(),
								C = te.toDOMNode(r, y);
							x.setEndAfter(C), (v = x.cloneContents());
						}
						if (
							(h && (b = v.querySelector("[data-slate-spacer]")),
							Array.from(
								v.querySelectorAll("[data-slate-zero-width]"),
							).forEach((A) => {
								var T =
									A.getAttribute("data-slate-zero-width") ===
									"n";
								A.textContent = T
									? `
`
									: "";
							}),
							xz(b))
						) {
							var k = b.ownerDocument.createElement("span");
							(k.style.whiteSpace = "pre"),
								k.appendChild(b),
								v.appendChild(k),
								(b = k);
						}
						var w = r.getFragment(),
							D = JSON.stringify(w),
							S = window.btoa(encodeURIComponent(D));
						b.setAttribute("data-slate-fragment", S),
							u.setData("application/".concat(n), S);
						var $ = v.ownerDocument.createElement("div");
						return (
							$.appendChild(v),
							$.setAttribute("hidden", "true"),
							v.ownerDocument.body.appendChild($),
							u.setData("text/html", $.innerHTML),
							u.setData("text/plain", Cz($)),
							v.ownerDocument.body.removeChild($),
							u
						);
					}
				}
			}),
			(r.insertData = (u) => {
				r.insertFragmentData(u) || r.insertTextData(u);
			}),
			(r.insertFragmentData = (u) => {
				var c = u.getData("application/".concat(n)) || Ohe(u);
				if (c) {
					var d = decodeURIComponent(window.atob(c)),
						f = JSON.parse(d);
					return r.insertFragment(f), !0;
				}
				return !1;
			}),
			(r.insertTextData = (u) => {
				var c = u.getData("text/plain");
				if (c) {
					var d = c.split(/\r\n|\r|\n/),
						f = !1;
					for (var h of d)
						f && W.splitNodes(r, { always: !0 }),
							r.insertText(h),
							(f = !0);
					return !0;
				}
				return !1;
			}),
			(r.onChange = (u) => {
				ix.unstable_batchedUpdates(() => {
					var c = Vw.get(r);
					c && c(), o(u);
				});
			}),
			r
		);
	},
	F1 = (t, e) => {
		var n = [];
		for (var [r, i] of R.levels(t, { at: e })) {
			var o = te.findKey(t, r);
			n.push([i, o]);
		}
		return n;
	};
class qpe extends TypeError {
	constructor(e, n) {
		let r;
		const { message: i, explanation: o, ...s } = e,
			{ path: a } = e,
			l = a.length === 0 ? i : `At path: ${a.join(".")} -- ${i}`;
		super(o ?? l),
			o != null && (this.cause = l),
			Object.assign(this, s),
			(this.name = this.constructor.name),
			(this.failures = () => r ?? (r = [e, ...n()]));
	}
}
function Gpe(t) {
	return Vo(t) && typeof t[Symbol.iterator] == "function";
}
function Vo(t) {
	return typeof t == "object" && t != null;
}
function Wo(t) {
	return typeof t == "symbol"
		? t.toString()
		: typeof t == "string"
			? JSON.stringify(t)
			: `${t}`;
}
function Ype(t) {
	const { done: e, value: n } = t.next();
	return e ? void 0 : n;
}
function Jpe(t, e, n, r) {
	if (t === !0) return;
	t === !1 ? (t = {}) : typeof t == "string" && (t = { message: t });
	const { path: i, branch: o } = e,
		{ type: s } = n,
		{
			refinement: a,
			message:
				l = `Expected a value of type \`${s}\`${a ? ` with refinement \`${a}\`` : ""}, but received: \`${Wo(r)}\``,
		} = t;
	return {
		value: r,
		type: s,
		refinement: a,
		key: i[i.length - 1],
		path: i,
		branch: o,
		...t,
		message: l,
	};
}
function* tB(t, e, n, r) {
	Gpe(t) || (t = [t]);
	for (const i of t) {
		const o = Jpe(i, e, n, r);
		o && (yield o);
	}
}
function* Rz(t, e, n = {}) {
	const { path: r = [], branch: i = [t], coerce: o = !1, mask: s = !1 } = n,
		a = { path: r, branch: i };
	if (
		o &&
		((t = e.coercer(t, a)),
		s && e.type !== "type" && Vo(e.schema) && Vo(t) && !Array.isArray(t))
	)
		for (const u in t) e.schema[u] === void 0 && delete t[u];
	let l = "valid";
	for (const u of e.validator(t, a))
		(u.explanation = n.message), (l = "not_valid"), yield [u, void 0];
	for (let [u, c, d] of e.entries(t, a)) {
		const f = Rz(c, d, {
			path: u === void 0 ? r : [...r, u],
			branch: u === void 0 ? i : [...i, c],
			coerce: o,
			mask: s,
			message: n.message,
		});
		for (const h of f)
			h[0]
				? ((l = h[0].refinement != null ? "not_refined" : "not_valid"),
					yield [h[0], void 0])
				: o &&
					((c = h[1]),
					u === void 0
						? (t = c)
						: t instanceof Map
							? t.set(u, c)
							: t instanceof Set
								? t.add(c)
								: Vo(t) &&
									(c !== void 0 || u in t) &&
									(t[u] = c));
	}
	if (l !== "not_valid")
		for (const u of e.refiner(t, a))
			(u.explanation = n.message), (l = "not_refined"), yield [u, void 0];
	l === "valid" && (yield [void 0, t]);
}
class Pl {
	constructor(e) {
		const {
			type: n,
			schema: r,
			validator: i,
			refiner: o,
			coercer: s = (l) => l,
			entries: a = function* () {},
		} = e;
		(this.type = n),
			(this.schema = r),
			(this.entries = a),
			(this.coercer = s),
			i
				? (this.validator = (l, u) => {
						const c = i(l, u);
						return tB(c, u, this, l);
					})
				: (this.validator = () => []),
			o
				? (this.refiner = (l, u) => {
						const c = o(l, u);
						return tB(c, u, this, l);
					})
				: (this.refiner = () => []);
	}
	assert(e, n) {
		return Xpe(e, this, n);
	}
	create(e, n) {
		return Zpe(e, this, n);
	}
	is(e) {
		return Oz(e, this);
	}
	mask(e, n) {
		return Qpe(e, this, n);
	}
	validate(e, n = {}) {
		return S0(e, this, n);
	}
}
function Xpe(t, e, n) {
	const r = S0(t, e, { message: n });
	if (r[0]) throw r[0];
}
function Zpe(t, e, n) {
	const r = S0(t, e, { coerce: !0, message: n });
	if (r[0]) throw r[0];
	return r[1];
}
function Qpe(t, e, n) {
	const r = S0(t, e, { coerce: !0, mask: !0, message: n });
	if (r[0]) throw r[0];
	return r[1];
}
function Oz(t, e) {
	return !S0(t, e)[0];
}
function S0(t, e, n = {}) {
	const r = Rz(t, e, n),
		i = Ype(r);
	return i[0]
		? [
				new qpe(i[0], function* () {
					for (const s of r) s[0] && (yield s[0]);
				}),
				void 0,
			]
		: [void 0, i[1]];
}
function np(t, e) {
	return new Pl({ type: t, schema: null, validator: e });
}
function eme(t) {
	return new Pl({
		type: "array",
		schema: t,
		*entries(e) {
			if (t && Array.isArray(e))
				for (const [n, r] of e.entries()) yield [n, r, t];
		},
		coercer(e) {
			return Array.isArray(e) ? e.slice() : e;
		},
		validator(e) {
			return (
				Array.isArray(e) ||
				`Expected an array value, but received: ${Wo(e)}`
			);
		},
	});
}
function nB() {
	return np("boolean", (t) => typeof t == "boolean");
}
function Yx() {
	return np(
		"date",
		(t) =>
			(t instanceof Date && !isNaN(t.getTime())) ||
			`Expected a valid \`Date\` object, but received: ${Wo(t)}`,
	);
}
function Jx(t) {
	return np(
		"instance",
		(e) =>
			e instanceof t ||
			`Expected a \`${t.name}\` instance, but received: ${Wo(e)}`,
	);
}
function xS(t) {
	const e = Wo(t);
	return new Pl({
		type: "literal",
		schema: t,
		validator(n) {
			return (
				n === t ||
				`Expected the literal \`${e}\`, but received: ${Wo(n)}`
			);
		},
	});
}
function kS(t, e) {
	return new Pl({
		type: "map",
		schema: null,
		*entries(n) {
			if (t && e && n instanceof Map)
				for (const [r, i] of n.entries())
					yield [r, r, t], yield [r, i, e];
		},
		coercer(n) {
			return n instanceof Map ? new Map(n) : n;
		},
		validator(n) {
			return (
				n instanceof Map ||
				`Expected a \`Map\` object, but received: ${Wo(n)}`
			);
		},
	});
}
function tme() {
	return np("never", () => !1);
}
function $h() {
	return np(
		"number",
		(t) =>
			(typeof t == "number" && !isNaN(t)) ||
			`Expected a number, but received: ${Wo(t)}`,
	);
}
function Xx(t) {
	const e = t ? Object.keys(t) : [],
		n = tme();
	return new Pl({
		type: "object",
		schema: t || null,
		*entries(r) {
			if (t && Vo(r)) {
				const i = new Set(Object.keys(r));
				for (const o of e) i.delete(o), yield [o, r[o], t[o]];
				for (const o of i) yield [o, r[o], n];
			}
		},
		validator(r) {
			return Vo(r) || `Expected an object, but received: ${Wo(r)}`;
		},
		coercer(r) {
			return Vo(r) ? { ...r } : r;
		},
	});
}
function CS(t) {
	return new Pl({
		...t,
		validator: (e, n) => e === void 0 || t.validator(e, n),
		refiner: (e, n) => e === void 0 || t.refiner(e, n),
	});
}
function nme(t, e) {
	return new Pl({
		type: "record",
		schema: null,
		*entries(n) {
			if (Vo(n))
				for (const r in n) {
					const i = n[r];
					yield [r, r, t], yield [r, i, e];
				}
		},
		validator(n) {
			return Vo(n) || `Expected an object, but received: ${Wo(n)}`;
		},
	});
}
function jt() {
	return np(
		"string",
		(t) =>
			typeof t == "string" || `Expected a string, but received: ${Wo(t)}`,
	);
}
function sa(t) {
	const e = Object.keys(t);
	return new Pl({
		type: "type",
		schema: t,
		*entries(n) {
			if (Vo(n)) for (const r of e) yield [r, n[r], t[r]];
		},
		validator(n) {
			return Vo(n) || `Expected an object, but received: ${Wo(n)}`;
		},
		coercer(n) {
			return Vo(n) ? { ...n } : n;
		},
	});
}
function Mz(t, e, n) {
	return new Pl({
		...t,
		coercer: (r, i) => (Oz(r, e) ? t.coercer(n(r, i), i) : t.coercer(r, i)),
	});
}
const rme = m.jsx("path", {
		d: "M9 17H7A5 5 0 0 1 7 7h2M15 7h2a5 5 0 1 1 0 10h-2M8 12h8",
	}),
	ime = m.jsx("path", {
		d: "M9 17H7A5 5 0 0 1 7 7M15 7h2a5 5 0 0 1 4 8M8 12h4M2 2l20 20",
	}),
	wS = m.jsx("path", {
		d: "M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5ZM15 5l4 4",
	}),
	Wr = m.jsx("path", {
		d: "M3 6h18M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2M10 11v6M14 11v6",
	}),
	ome = m.jsxs(m.Fragment, {
		children: [
			m.jsx("path", { d: "M9 14 4 9l5-5" }),
			m.jsx("path", {
				d: "M4 9h10.5a5.5 5.5 0 0 1 5.5 5.5v0a5.5 5.5 0 0 1-5.5 5.5H11",
			}),
		],
	});
var jz = {};
jz = {
	decrease: (t) => `خفض ${t.fieldLabel}`,
	increase: (t) => `زيادة ${t.fieldLabel}`,
	numberField: "حقل رقمي",
};
var _z = {};
_z = {
	decrease: (t) => `Намаляване ${t.fieldLabel}`,
	increase: (t) => `Усилване ${t.fieldLabel}`,
	numberField: "Номер на полето",
};
var zz = {};
zz = {
	decrease: (t) => `Snížit ${t.fieldLabel}`,
	increase: (t) => `Zvýšit ${t.fieldLabel}`,
	numberField: "Číselné pole",
};
var Lz = {};
Lz = {
	decrease: (t) => `Reducer ${t.fieldLabel}`,
	increase: (t) => `Øg ${t.fieldLabel}`,
	numberField: "Talfelt",
};
var Vz = {};
Vz = {
	decrease: (t) => `${t.fieldLabel} verringern`,
	increase: (t) => `${t.fieldLabel} erhöhen`,
	numberField: "Nummernfeld",
};
var Kz = {};
Kz = {
	decrease: (t) => `Μείωση ${t.fieldLabel}`,
	increase: (t) => `Αύξηση ${t.fieldLabel}`,
	numberField: "Πεδίο αριθμού",
};
var Uz = {};
Uz = {
	decrease: (t) => `Decrease ${t.fieldLabel}`,
	increase: (t) => `Increase ${t.fieldLabel}`,
	numberField: "Number field",
};
var Hz = {};
Hz = {
	decrease: (t) => `Reducir ${t.fieldLabel}`,
	increase: (t) => `Aumentar ${t.fieldLabel}`,
	numberField: "Campo de número",
};
var Wz = {};
Wz = {
	decrease: (t) => `Vähenda ${t.fieldLabel}`,
	increase: (t) => `Suurenda ${t.fieldLabel}`,
	numberField: "Numbri väli",
};
var qz = {};
qz = {
	decrease: (t) => `Vähennä ${t.fieldLabel}`,
	increase: (t) => `Lisää ${t.fieldLabel}`,
	numberField: "Numerokenttä",
};
var Gz = {};
Gz = {
	decrease: (t) => `Diminuer ${t.fieldLabel}`,
	increase: (t) => `Augmenter ${t.fieldLabel}`,
	numberField: "Champ de nombre",
};
var Yz = {};
Yz = {
	decrease: (t) => `הקטן ${t.fieldLabel}`,
	increase: (t) => `הגדל ${t.fieldLabel}`,
	numberField: "שדה מספר",
};
var Jz = {};
Jz = {
	decrease: (t) => `Smanji ${t.fieldLabel}`,
	increase: (t) => `Povećaj ${t.fieldLabel}`,
	numberField: "Polje broja",
};
var Xz = {};
Xz = {
	decrease: (t) => `${t.fieldLabel} csökkentése`,
	increase: (t) => `${t.fieldLabel} növelése`,
	numberField: "Számmező",
};
var Zz = {};
Zz = {
	decrease: (t) => `Riduci ${t.fieldLabel}`,
	increase: (t) => `Aumenta ${t.fieldLabel}`,
	numberField: "Campo numero",
};
var Qz = {};
Qz = {
	decrease: (t) => `${t.fieldLabel}を縮小`,
	increase: (t) => `${t.fieldLabel}を拡大`,
	numberField: "数値フィールド",
};
var eL = {};
eL = {
	decrease: (t) => `${t.fieldLabel} 감소`,
	increase: (t) => `${t.fieldLabel} 증가`,
	numberField: "번호 필드",
};
var tL = {};
tL = {
	decrease: (t) => `Sumažinti ${t.fieldLabel}`,
	increase: (t) => `Padidinti ${t.fieldLabel}`,
	numberField: "Numerio laukas",
};
var nL = {};
nL = {
	decrease: (t) => `Samazināšana ${t.fieldLabel}`,
	increase: (t) => `Palielināšana ${t.fieldLabel}`,
	numberField: "Skaitļu lauks",
};
var rL = {};
rL = {
	decrease: (t) => `Reduser ${t.fieldLabel}`,
	increase: (t) => `Øk ${t.fieldLabel}`,
	numberField: "Tallfelt",
};
var iL = {};
iL = {
	decrease: (t) => `${t.fieldLabel} verlagen`,
	increase: (t) => `${t.fieldLabel} verhogen`,
	numberField: "Getalveld",
};
var oL = {};
oL = {
	decrease: (t) => `Zmniejsz ${t.fieldLabel}`,
	increase: (t) => `Zwiększ ${t.fieldLabel}`,
	numberField: "Pole numeru",
};
var sL = {};
sL = {
	decrease: (t) => `Diminuir ${t.fieldLabel}`,
	increase: (t) => `Aumentar ${t.fieldLabel}`,
	numberField: "Campo de número",
};
var aL = {};
aL = {
	decrease: (t) => `Diminuir ${t.fieldLabel}`,
	increase: (t) => `Aumentar ${t.fieldLabel}`,
	numberField: "Campo numérico",
};
var lL = {};
lL = {
	decrease: (t) => `Scădere ${t.fieldLabel}`,
	increase: (t) => `Creștere ${t.fieldLabel}`,
	numberField: "Câmp numeric",
};
var uL = {};
uL = {
	decrease: (t) => `Уменьшение ${t.fieldLabel}`,
	increase: (t) => `Увеличение ${t.fieldLabel}`,
	numberField: "Числовое поле",
};
var cL = {};
cL = {
	decrease: (t) => `Znížiť ${t.fieldLabel}`,
	increase: (t) => `Zvýšiť ${t.fieldLabel}`,
	numberField: "Číselné pole",
};
var dL = {};
dL = {
	decrease: (t) => `Upadati ${t.fieldLabel}`,
	increase: (t) => `Povečajte ${t.fieldLabel}`,
	numberField: "Številčno polje",
};
var fL = {};
fL = {
	decrease: (t) => `Smanji ${t.fieldLabel}`,
	increase: (t) => `Povećaj ${t.fieldLabel}`,
	numberField: "Polje broja",
};
var hL = {};
hL = {
	decrease: (t) => `Minska ${t.fieldLabel}`,
	increase: (t) => `Öka ${t.fieldLabel}`,
	numberField: "Nummerfält",
};
var pL = {};
pL = {
	decrease: (t) => `${t.fieldLabel} azalt`,
	increase: (t) => `${t.fieldLabel} arttır`,
	numberField: "Sayı alanı",
};
var mL = {};
mL = {
	decrease: (t) => `Зменшити ${t.fieldLabel}`,
	increase: (t) => `Збільшити ${t.fieldLabel}`,
	numberField: "Поле номера",
};
var gL = {};
gL = {
	decrease: (t) => `降低 ${t.fieldLabel}`,
	increase: (t) => `提高 ${t.fieldLabel}`,
	numberField: "数字字段",
};
var bL = {};
bL = {
	decrease: (t) => `縮小 ${t.fieldLabel}`,
	increase: (t) => `放大 ${t.fieldLabel}`,
	numberField: "數字欄位",
};
var vL = {};
vL = {
	"ar-AE": jz,
	"bg-BG": _z,
	"cs-CZ": zz,
	"da-DK": Lz,
	"de-DE": Vz,
	"el-GR": Kz,
	"en-US": Uz,
	"es-ES": Hz,
	"et-EE": Wz,
	"fi-FI": qz,
	"fr-FR": Gz,
	"he-IL": Yz,
	"hr-HR": Jz,
	"hu-HU": Xz,
	"it-IT": Zz,
	"ja-JP": Qz,
	"ko-KR": eL,
	"lt-LT": tL,
	"lv-LV": nL,
	"nb-NO": rL,
	"nl-NL": iL,
	"pl-PL": oL,
	"pt-BR": sL,
	"pt-PT": aL,
	"ro-RO": lL,
	"ru-RU": uL,
	"sk-SK": cL,
	"sl-SI": dL,
	"sr-SP": fL,
	"sv-SE": hL,
	"tr-TR": pL,
	"uk-UA": mL,
	"zh-CN": gL,
	"zh-TW": bL,
};
var yL = {};
yL = { Empty: "فارغ" };
var xL = {};
xL = { Empty: "Изпразни" };
var kL = {};
kL = { Empty: "Prázdné" };
var CL = {};
CL = { Empty: "Tom" };
var wL = {};
wL = { Empty: "Leer" };
var EL = {};
EL = { Empty: "Άδειο" };
var DL = {};
DL = { Empty: "Empty" };
var SL = {};
SL = { Empty: "Vacío" };
var AL = {};
AL = { Empty: "Tühjenda" };
var $L = {};
$L = { Empty: "Tyhjä" };
var TL = {};
TL = { Empty: "Vide" };
var BL = {};
BL = { Empty: "ריק" };
var IL = {};
IL = { Empty: "Prazno" };
var FL = {};
FL = { Empty: "Üres" };
var PL = {};
PL = { Empty: "Vuoto" };
var NL = {};
NL = { Empty: "空" };
var RL = {};
RL = { Empty: "비어 있음" };
var OL = {};
OL = { Empty: "Tuščias" };
var ML = {};
ML = { Empty: "Tukšs" };
var jL = {};
jL = { Empty: "Tom" };
var _L = {};
_L = { Empty: "Leeg" };
var zL = {};
zL = { Empty: "Pusty" };
var LL = {};
LL = { Empty: "Vazio" };
var VL = {};
VL = { Empty: "Vazio" };
var KL = {};
KL = { Empty: "Gol" };
var UL = {};
UL = { Empty: "Не заполнено" };
var HL = {};
HL = { Empty: "Prázdne" };
var WL = {};
WL = { Empty: "Prazen" };
var qL = {};
qL = { Empty: "Prazno" };
var GL = {};
GL = { Empty: "Tomt" };
var YL = {};
YL = { Empty: "Boş" };
var JL = {};
JL = { Empty: "Пусто" };
var XL = {};
XL = { Empty: "空" };
var ZL = {};
ZL = { Empty: "空白" };
var QL = {};
QL = {
	"ar-AE": yL,
	"bg-BG": xL,
	"cs-CZ": kL,
	"da-DK": CL,
	"de-DE": wL,
	"el-GR": EL,
	"en-US": DL,
	"es-ES": SL,
	"et-EE": AL,
	"fi-FI": $L,
	"fr-FR": TL,
	"he-IL": BL,
	"hr-HR": IL,
	"hu-HU": FL,
	"it-IT": PL,
	"ja-JP": NL,
	"ko-KR": RL,
	"lt-LT": OL,
	"lv-LV": ML,
	"nb-NO": jL,
	"nl-NL": _L,
	"pl-PL": zL,
	"pt-BR": LL,
	"pt-PT": VL,
	"ro-RO": KL,
	"ru-RU": UL,
	"sk-SK": HL,
	"sl-SI": WL,
	"sr-SP": qL,
	"sv-SE": GL,
	"tr-TR": YL,
	"uk-UA": JL,
	"zh-CN": XL,
	"zh-TW": ZL,
};
function sme(t) {
	return t && t.__esModule ? t.default : t;
}
function ame(t) {
	const e = E.useRef(void 0);
	let {
		value: n,
		textValue: r,
		minValue: i,
		maxValue: o,
		isDisabled: s,
		isReadOnly: a,
		isRequired: l,
		onIncrement: u,
		onIncrementPage: c,
		onDecrement: d,
		onDecrementPage: f,
		onDecrementToMin: h,
		onIncrementToMax: p,
	} = t;
	const g = Le(sme(QL), "@react-aria/spinbutton"),
		v = () => clearTimeout(e.current);
	E.useEffect(() => () => v(), []);
	let b = (T) => {
			if (!(T.ctrlKey || T.metaKey || T.shiftKey || T.altKey || a))
				switch (T.key) {
					case "PageUp":
						if (c) {
							T.preventDefault(), c == null || c();
							break;
						}
					case "ArrowUp":
					case "Up":
						u && (T.preventDefault(), u == null || u());
						break;
					case "PageDown":
						if (f) {
							T.preventDefault(), f == null || f();
							break;
						}
					case "ArrowDown":
					case "Down":
						d && (T.preventDefault(), d == null || d());
						break;
					case "Home":
						h && (T.preventDefault(), h == null || h());
						break;
					case "End":
						p && (T.preventDefault(), p == null || p());
						break;
				}
		},
		y = E.useRef(!1),
		x = () => {
			y.current = !0;
		},
		C = () => {
			y.current = !1;
		},
		k = r === "" ? g.format("Empty") : (r || `${n}`).replace("-", "−");
	E.useEffect(() => {
		y.current && (wie("assertive"), xs(k, "assertive"));
	}, [k]);
	const w = Pt((T) => {
			v(),
				u == null || u(),
				(e.current = window.setTimeout(() => {
					(o === void 0 ||
						isNaN(o) ||
						n === void 0 ||
						isNaN(n) ||
						n < o) &&
						w(60);
				}, T));
		}),
		D = Pt((T) => {
			v(),
				d == null || d(),
				(e.current = window.setTimeout(() => {
					(i === void 0 ||
						isNaN(i) ||
						n === void 0 ||
						isNaN(n) ||
						n > i) &&
						D(60);
				}, T));
		});
	let S = (T) => {
			T.preventDefault();
		},
		{ addGlobalListener: $, removeAllGlobalListeners: A } = i0();
	return {
		spinButtonProps: {
			role: "spinbutton",
			"aria-valuenow": n !== void 0 && !isNaN(n) ? n : void 0,
			"aria-valuetext": k,
			"aria-valuemin": i,
			"aria-valuemax": o,
			"aria-disabled": s || void 0,
			"aria-readonly": a || void 0,
			"aria-required": l || void 0,
			onKeyDown: b,
			onFocus: x,
			onBlur: C,
		},
		incrementButtonProps: {
			onPressStart: () => {
				w(400), $(window, "contextmenu", S);
			},
			onPressEnd: () => {
				v(), A();
			},
			onFocus: x,
			onBlur: C,
		},
		decrementButtonProps: {
			onPressStart: () => {
				D(400), $(window, "contextmenu", S);
			},
			onPressEnd: () => {
				v(), A();
			},
			onFocus: x,
			onBlur: C,
		},
	};
}
function lme(t) {
	return t && t.__esModule ? t.default : t;
}
function ume(t, e, n) {
	let {
			id: r,
			decrementAriaLabel: i,
			incrementAriaLabel: o,
			isDisabled: s,
			isReadOnly: a,
			isRequired: l,
			minValue: u,
			maxValue: c,
			autoFocus: d,
			label: f,
			formatOptions: h,
			onBlur: p = () => {},
			onFocus: g,
			onFocusChange: v,
			onKeyDown: b,
			onKeyUp: y,
			description: x,
			errorMessage: C,
			isWheelDisabled: k,
			...w
		} = t,
		{
			increment: D,
			incrementToMax: S,
			decrement: $,
			decrementToMin: A,
			numberValue: T,
			inputValue: I,
			commit: F,
			commitValidation: N,
		} = e;
	const O = Le(lme(vL), "@react-aria/numberfield");
	let _ = Ot(r),
		{ focusProps: j } = cx({
			onBlur() {
				F();
			},
		}),
		V = ZC(h),
		K = E.useMemo(() => V.resolvedOptions(), [V]),
		M = ZC({ ...h, currencySign: void 0 }),
		G = E.useMemo(() => (isNaN(T) ? "" : M.format(T)), [M, T]),
		{
			spinButtonProps: H,
			incrementButtonProps: P,
			decrementButtonProps: q,
		} = ame({
			isDisabled: s,
			isReadOnly: a,
			isRequired: l,
			maxValue: c,
			minValue: u,
			onIncrement: D,
			onIncrementToMax: S,
			onDecrement: $,
			onDecrementToMin: A,
			value: T,
			textValue: G,
		}),
		[J, Z] = E.useState(!1),
		{ focusWithinProps: oe } = Ud({
			isDisabled: s,
			onFocusWithinChange: Z,
		}),
		ne = E.useCallback(
			(bn) => {
				Math.abs(bn.deltaY) <= Math.abs(bn.deltaX) ||
					(bn.deltaY > 0 ? D() : bn.deltaY < 0 && $());
			},
			[$, D],
		);
	Lee({ onScroll: ne, isDisabled: k || s || a || !J }, n);
	var se;
	let re =
			((se = K.maximumFractionDigits) !== null && se !== void 0
				? se
				: 0) > 0,
		he = e.minValue === void 0 || isNaN(e.minValue) || e.minValue < 0,
		ye = "numeric";
	e9()
		? he
			? (ye = "text")
			: re && (ye = "decimal")
		: zm() && (he ? (ye = "numeric") : re && (ye = "decimal"));
	let Ae = (bn) => {
			e.validate(bn) && e.setInputValue(bn);
		},
		Pe = Ge(t),
		we = E.useCallback(
			(bn) => {
				bn.key === "Enter" ? (F(), N()) : bn.continuePropagation();
			},
			[F, N],
		),
		{
			isInvalid: Ke,
			validationErrors: rt,
			validationDetails: Ce,
		} = e.displayValidation,
		{
			labelProps: Me,
			inputProps: me,
			descriptionProps: De,
			errorMessageProps: _e,
		} = Ure(
			{
				...w,
				...Pe,
				name: void 0,
				label: f,
				autoFocus: d,
				isDisabled: s,
				isReadOnly: a,
				isRequired: l,
				validate: void 0,
				[Ym]: e,
				value: I,
				defaultValue: void 0,
				autoComplete: "off",
				"aria-label": t["aria-label"] || void 0,
				"aria-labelledby": t["aria-labelledby"] || void 0,
				id: _,
				type: "text",
				inputMode: ye,
				onChange: Ae,
				onBlur: p,
				onFocus: g,
				onFocusChange: v,
				onKeyDown: E.useMemo(() => hr(we, b), [we, b]),
				onKeyUp: y,
				description: x,
				errorMessage: C,
			},
			e,
			n,
		);
	s0(n, e.numberValue, e.setNumberValue);
	let We = xe(H, j, me, {
		role: null,
		"aria-roledescription": Vh() ? null : O.format("numberField"),
		"aria-valuemax": null,
		"aria-valuemin": null,
		"aria-valuenow": null,
		"aria-valuetext": null,
		autoCorrect: "off",
		spellCheck: "false",
	});
	t.validationBehavior === "native" && (We["aria-required"] = void 0);
	let Et = (bn) => {
			var Qr;
			document.activeElement !== n.current &&
				(bn.pointerType === "mouse"
					? (Qr = n.current) === null || Qr === void 0 || Qr.focus()
					: bn.target.focus());
		},
		ae = t["aria-label"] || (typeof t.label == "string" ? t.label : ""),
		fe;
	ae || (fe = t.label != null ? Me.id : t["aria-labelledby"]);
	let U = Ot(),
		tt = Ot(),
		Dt = xe(P, {
			"aria-label": o || O.format("increase", { fieldLabel: ae }).trim(),
			id: fe && !o ? U : null,
			"aria-labelledby": fe && !o ? `${U} ${fe}` : null,
			"aria-controls": _,
			excludeFromTabOrder: !0,
			preventFocusOnPress: !0,
			allowFocusWhenDisabled: !0,
			isDisabled: !e.canIncrement,
			onPressStart: Et,
		}),
		Xt = xe(q, {
			"aria-label": i || O.format("decrease", { fieldLabel: ae }).trim(),
			id: fe && !i ? tt : null,
			"aria-labelledby": fe && !i ? `${tt} ${fe}` : null,
			"aria-controls": _,
			excludeFromTabOrder: !0,
			preventFocusOnPress: !0,
			allowFocusWhenDisabled: !0,
			isDisabled: !e.canDecrement,
			onPressStart: Et,
		});
	return {
		groupProps: {
			...oe,
			role: "group",
			"aria-disabled": s,
			"aria-invalid": Ke ? "true" : void 0,
		},
		labelProps: Me,
		inputProps: We,
		incrementButtonProps: Dt,
		decrementButtonProps: Xt,
		errorMessageProps: _e,
		descriptionProps: De,
		isInvalid: Ke,
		validationErrors: rt,
		validationDetails: Ce,
	};
}
function cme(t) {
	let {
		minValue: e,
		maxValue: n,
		step: r,
		formatOptions: i,
		value: o,
		defaultValue: s = NaN,
		onChange: a,
		locale: l,
		isDisabled: u,
		isReadOnly: c,
	} = t;
	o === null && (o = NaN),
		o !== void 0 &&
			!isNaN(o) &&
			(r !== void 0 && !isNaN(r)
				? (o = Ra(o, e, n, r))
				: (o = rl(o, e, n))),
		isNaN(s) ||
			(r !== void 0 && !isNaN(r)
				? (s = Ra(s, e, n, r))
				: (s = rl(s, e, n)));
	let [d, f] = Ns(o, isNaN(s) ? NaN : s, a),
		[h, p] = E.useState(() => (isNaN(d) ? "" : new iv(l, i).format(d))),
		g = E.useMemo(() => new h9(l, i), [l, i]),
		v = E.useMemo(() => g.getNumberingSystem(h), [g, h]),
		b = E.useMemo(() => new iv(l, { ...i, numberingSystem: v }), [l, i, v]),
		y = E.useMemo(() => b.resolvedOptions(), [b]),
		x = E.useCallback(
			(H) => (isNaN(H) || H === null ? "" : b.format(H)),
			[b],
		),
		C = Yd({ ...t, value: d }),
		k = r !== void 0 && !isNaN(r) ? r : 1;
	y.style === "percent" && (r === void 0 || isNaN(r)) && (k = 0.01);
	let [w, D] = E.useState(d),
		[S, $] = E.useState(l),
		[A, T] = E.useState(i);
	(!Object.is(d, w) || l !== S || i !== A) && (p(x(d)), D(d), $(l), T(i));
	let I = E.useMemo(() => g.parse(h), [g, h]),
		F = () => {
			if (!h.length) {
				f(NaN), p(o === void 0 ? "" : x(d));
				return;
			}
			if (isNaN(I)) {
				p(x(d));
				return;
			}
			let H;
			r === void 0 || isNaN(r) ? (H = rl(I, e, n)) : (H = Ra(I, e, n, r)),
				(H = g.parse(x(H))),
				f(H),
				p(x(o === void 0 ? H : d));
		},
		N = (H, P = 0) => {
			let q = I;
			if (isNaN(q)) {
				let J = isNaN(P) ? 0 : P;
				return Ra(J, e, n, k);
			} else {
				let J = Ra(q, e, n, k);
				return (H === "+" && J > q) || (H === "-" && J < q)
					? J
					: Ra(vk(H, q, k), e, n, k);
			}
		},
		O = () => {
			let H = N("+", e);
			H === d && p(x(H)), f(H), C.commitValidation();
		},
		_ = () => {
			let H = N("-", n);
			H === d && p(x(H)), f(H), C.commitValidation();
		},
		j = () => {
			n != null && (f(Ra(n, e, n, k)), C.commitValidation());
		},
		V = () => {
			e != null && (f(e), C.commitValidation());
		},
		K = E.useMemo(
			() =>
				!u &&
				!c &&
				(isNaN(I) ||
					n === void 0 ||
					isNaN(n) ||
					Ra(I, e, n, k) > I ||
					vk("+", I, k) <= n),
			[u, c, e, n, k, I],
		),
		M = E.useMemo(
			() =>
				!u &&
				!c &&
				(isNaN(I) ||
					e === void 0 ||
					isNaN(e) ||
					Ra(I, e, n, k) < I ||
					vk("-", I, k) >= e),
			[u, c, e, n, k, I],
		);
	return {
		...C,
		validate: (H) => g.isValidPartialNumber(H, e, n),
		increment: O,
		incrementToMax: j,
		decrement: _,
		decrementToMin: V,
		canIncrement: K,
		canDecrement: M,
		minValue: e,
		maxValue: n,
		numberValue: I,
		setNumberValue: f,
		setInputValue: p,
		inputValue: h,
		commit: F,
	};
}
function vk(t, e, n) {
	let r = t === "+" ? e + n : e - n;
	if (e % 1 !== 0 || n % 1 !== 0) {
		const i = e.toString().split("."),
			o = n.toString().split("."),
			s = (i[1] && i[1].length) || 0,
			a = (o[1] && o[1].length) || 0,
			l = Math.pow(10, Math.max(s, a));
		(e = Math.round(e * l)),
			(n = Math.round(n * l)),
			(r = t === "+" ? e + n : e - n),
			(r /= l);
	}
	return r;
}
const dme = m.jsx("path", { d: "m18 15-6-6-6 6" }),
	rB = E.forwardRef(function (e, n) {
		const r = ce(23);
		e = vo(e);
		const { scale: i } = Rs(),
			{ direction: o } = e,
			s = Ct(n);
		let a;
		r[0] !== e
			? ((a = { ...e, elementType: "div" }), (r[0] = e), (r[1] = a))
			: (a = r[1]);
		const { buttonProps: l, isPressed: u } = Yo(a, s),
			{ hoverProps: c, isHovered: d } = gn(e),
			f = i === "large" ? Ux : dme,
			h = i === "large" ? Ix : Il,
			p = d || void 0,
			g = u || void 0;
		let v;
		r[2] !== o || r[3] !== p || r[4] !== g || r[5] !== i
			? ((v = lt({ direction: o, hovered: p, pressed: g, scale: i })),
				(r[2] = o),
				(r[3] = p),
				(r[4] = g),
				(r[5] = i),
				(r[6] = v))
			: (v = r[6]);
		let b;
		r[7] !== c || r[8] !== l
			? ((b = xe(c, l)), (r[7] = c), (r[8] = l), (r[9] = b))
			: (b = r[9]);
		let y;
		r[10] === Symbol.for("react.memo_cache_sentinel")
			? ((y = Se(
					X({
						alignItems: "center",
						color: B.color.alias.foregroundIdle,
						cursor: "default",
						display: "flex",
						justifyContent: "center",
						transition: bt("border-color"),
						svg: { position: "absolute" },
						"&[data-hovered]": {
							backgroundColor: B.color.alias.backgroundHovered,
							color: B.color.alias.foregroundHovered,
						},
						"&[data-pressed]": {
							backgroundColor: B.color.alias.backgroundPressed,
						},
						"&[aria-disabled=true]": {
							backgroundColor:
								B.color.background.surfaceSecondary,
							color: B.color.alias.foregroundDisabled,
						},
						"&[data-direction=up]": { gridArea: "increment" },
						"&[data-direction=down]": { gridArea: "decrement" },
						"&:not([data-scale=large])": {
							"&[data-direction=up]": {
								borderStartStartRadius: B.size.radius.small,
								borderStartEndRadius: B.size.radius.small,
							},
							"&[data-direction=down]": {
								borderEndStartRadius: B.size.radius.small,
								borderEndEndRadius: B.size.radius.small,
							},
							svg: { width: B.size.icon.small },
						},
						"&[data-scale=large]": {
							"&[data-direction=up]": {
								borderStartEndRadius: B.size.radius.regular,
								borderEndEndRadius: B.size.radius.regular,
							},
							"&[data-direction=down]": {
								borderEndStartRadius: B.size.radius.regular,
								borderStartStartRadius: B.size.radius.regular,
							},
							"input:enabled ~ &": {
								border: `${B.size.border.regular} solid ${B.color.alias.borderIdle}`,
							},
							"input:focus ~ &": {
								borderColor: B.color.alias.borderFocused,
							},
						},
					}),
				)),
				(r[10] = y))
			: (y = r[10]);
		let x;
		r[11] !== o || r[12] !== f
			? ((x = o === "up" && m.jsx(ve, { src: f })),
				(r[11] = o),
				(r[12] = f),
				(r[13] = x))
			: (x = r[13]);
		let C;
		r[14] !== o || r[15] !== h
			? ((C = o === "down" && m.jsx(ve, { src: h })),
				(r[14] = o),
				(r[15] = h),
				(r[16] = C))
			: (C = r[16]);
		let k;
		return (
			r[17] !== v ||
			r[18] !== b ||
			r[19] !== s ||
			r[20] !== x ||
			r[21] !== C
				? ((k = m.jsxs("div", {
						...v,
						...b,
						ref: s,
						className: y,
						children: [x, C],
					})),
					(r[17] = v),
					(r[18] = b),
					(r[19] = s),
					(r[20] = x),
					(r[21] = C),
					(r[22] = k))
				: (k = r[22]),
			k
		);
	}),
	Wv = E.forwardRef(function (e, n) {
		const r = ce(29);
		e = vo(e);
		const {
				isReadOnly: i,
				isDisabled: o,
				hideStepper: s,
				label: a,
				description: l,
			} = e,
			{ locale: u } = Vt();
		let c;
		r[0] !== e || r[1] !== u
			? ((c = { ...e, locale: u }), (r[0] = e), (r[1] = u), (r[2] = c))
			: (c = r[2]);
		const d = cme(c),
			f = Ct(n),
			{
				groupProps: h,
				labelProps: p,
				inputProps: g,
				incrementButtonProps: v,
				decrementButtonProps: b,
				descriptionProps: y,
				errorMessageProps: x,
			} = ume(e, d, f),
			C = fme();
		let k;
		r[3] !== e ? ((k = Ge(e)), (r[3] = e), (r[4] = k)) : (k = r[4]);
		let w;
		r[5] !== e ? ((w = FP(e)), (r[5] = e), (r[6] = w)) : (w = r[6]);
		let D;
		r[7] !== h || r[8] !== C
			? ((D = { ...h, ...C }), (r[7] = h), (r[8] = C), (r[9] = D))
			: (D = r[9]);
		let S;
		r[10] !== s || r[11] !== v || r[12] !== b
			? ((S =
					!s &&
					m.jsxs(m.Fragment, {
						children: [
							m.jsx(rB, { direction: "up", ...v }),
							m.jsx(rB, { direction: "down", ...b }),
						],
					})),
				(r[10] = s),
				(r[11] = v),
				(r[12] = b),
				(r[13] = S))
			: (S = r[13]);
		let $;
		return (
			r[14] !== k ||
			r[15] !== w ||
			r[16] !== a ||
			r[17] !== l ||
			r[18] !== e.errorMessage ||
			r[19] !== y ||
			r[20] !== x ||
			r[21] !== p ||
			r[22] !== D ||
			r[23] !== f ||
			r[24] !== g ||
			r[25] !== o ||
			r[26] !== i ||
			r[27] !== S
				? (($ = m.jsx(Jh, {
						width: "alias.singleLineWidth",
						...k,
						...w,
						label: a,
						description: l,
						errorMessage: e.errorMessage,
						descriptionProps: y,
						errorMessageProps: x,
						labelProps: p,
						inputWrapperProps: D,
						ref: f,
						inputProps: g,
						isDisabled: o,
						isReadOnly: i,
						endElement: S,
					})),
					(r[14] = k),
					(r[15] = w),
					(r[16] = a),
					(r[17] = l),
					(r[18] = e.errorMessage),
					(r[19] = y),
					(r[20] = x),
					(r[21] = p),
					(r[22] = D),
					(r[23] = f),
					(r[24] = g),
					(r[25] = o),
					(r[26] = i),
					(r[27] = S),
					(r[28] = $))
				: ($ = r[28]),
			$
		);
	});
function fme() {
	const t = ce(5),
		{ scale: e } = Rs();
	let n;
	t[0] === Symbol.for("react.memo_cache_sentinel")
		? ((n = X({
				display: "grid",
				gap: B.size.border.regular,
				gridTemplateColumns: `1fr calc(${B.size.element.regular} - ${B.size.border.regular} * 2) ${B.size.border.regular}`,
				gridTemplateRows: `${B.size.border.regular} auto auto ${B.size.border.regular}`,
				gridTemplateAreas:
					'"field . ." "field increment ." "field decrement ." "field . ."',
				'&[data-scale="large"]': {
					gridTemplateColumns: `${B.size.element.regular} 1fr ${B.size.element.regular}`,
					gridTemplateRows: "auto",
					gridTemplateAreas: '"decrement field increment"',
				},
				input: { gridArea: "field" },
			})),
			(t[0] = n))
		: (n = t[0]);
	const r = n;
	let i;
	t[1] !== e ? ((i = lt({ scale: e })), (t[1] = e), (t[2] = i)) : (i = t[2]);
	let o;
	return (
		t[3] !== i
			? ((o = { ...i, className: r }), (t[3] = i), (t[4] = o))
			: (o = t[4]),
		o
	);
}
var eV = { exports: {} },
	tV = {};
/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var Th = E;
function hme(t, e) {
	return (t === e && (t !== 0 || 1 / t === 1 / e)) || (t !== t && e !== e);
}
var pme = typeof Object.is == "function" ? Object.is : hme,
	mme = Th.useState,
	gme = Th.useEffect,
	bme = Th.useLayoutEffect,
	vme = Th.useDebugValue;
function yme(t, e) {
	var n = e(),
		r = mme({ inst: { value: n, getSnapshot: e } }),
		i = r[0].inst,
		o = r[1];
	return (
		bme(
			function () {
				(i.value = n), (i.getSnapshot = e), yk(i) && o({ inst: i });
			},
			[t, n, e],
		),
		gme(
			function () {
				return (
					yk(i) && o({ inst: i }),
					t(function () {
						yk(i) && o({ inst: i });
					})
				);
			},
			[t],
		),
		vme(n),
		n
	);
}
function yk(t) {
	var e = t.getSnapshot;
	t = t.value;
	try {
		var n = e();
		return !pme(t, n);
	} catch {
		return !0;
	}
}
function xme(t, e) {
	return e();
}
var kme =
	typeof window > "u" ||
	typeof window.document > "u" ||
	typeof window.document.createElement > "u"
		? xme
		: yme;
tV.useSyncExternalStore =
	Th.useSyncExternalStore !== void 0 ? Th.useSyncExternalStore : kme;
eV.exports = tV;
var nV = eV.exports;
function Cme(t) {
	let e = E.useCallback((i) => t.subscribe(i), [t]),
		n = E.useCallback(() => t.visibleToasts, [t]);
	return {
		visibleToasts: nV.useSyncExternalStore(e, n, n),
		add: (i, o) => t.add(i, o),
		close: (i) => t.close(i),
		remove: (i) => t.remove(i),
		pauseAll: () => t.pauseAll(),
		resumeAll: () => t.resumeAll(),
	};
}
class wme {
	subscribe(e) {
		return this.subscriptions.add(e), () => this.subscriptions.delete(e);
	}
	add(e, n = {}) {
		let r = Math.random().toString(36),
			i = {
				...n,
				content: e,
				key: r,
				timer: n.timeout
					? new Eme(() => this.close(r), n.timeout)
					: null,
			},
			o = 0,
			s = this.queue.length;
		for (; o < s; ) {
			let l = Math.floor((o + s) / 2);
			(i.priority || 0) > (this.queue[l].priority || 0)
				? (s = l)
				: (o = l + 1);
		}
		this.queue.splice(o, 0, i),
			(i.animation = o < this.maxVisibleToasts ? "entering" : "queued");
		let a = this.maxVisibleToasts;
		for (; a < this.queue.length; ) this.queue[a++].animation = "queued";
		return this.updateVisibleToasts({ action: "add" }), r;
	}
	close(e) {
		let n = this.queue.findIndex((o) => o.key === e);
		if (n >= 0) {
			var r, i;
			(r = (i = this.queue[n]).onClose) === null ||
				r === void 0 ||
				r.call(i),
				this.queue.splice(n, 1);
		}
		this.updateVisibleToasts({ action: "close", key: e });
	}
	remove(e) {
		this.updateVisibleToasts({ action: "remove", key: e });
	}
	updateVisibleToasts(e) {
		let { action: n, key: r } = e,
			i = this.queue.slice(0, this.maxVisibleToasts);
		if (n === "add" && this.hasExitAnimation) {
			let o = this.visibleToasts
				.filter((s) => !i.some((a) => s.key === a.key))
				.map((s) => ({ ...s, animation: "exiting" }));
			this.visibleToasts = o
				.concat(i)
				.sort((s, a) => a.priority - s.priority);
		} else
			n === "close" && this.hasExitAnimation
				? (this.visibleToasts = this.visibleToasts.map((o) =>
						o.key !== r ? o : { ...o, animation: "exiting" },
					))
				: (this.visibleToasts = i);
		for (let o of this.subscriptions) o();
	}
	pauseAll() {
		for (let e of this.visibleToasts) e.timer && e.timer.pause();
	}
	resumeAll() {
		for (let e of this.visibleToasts) e.timer && e.timer.resume();
	}
	constructor(e) {
		(this.queue = []),
			(this.subscriptions = new Set()),
			(this.visibleToasts = []);
		var n;
		this.maxVisibleToasts =
			(n = e == null ? void 0 : e.maxVisibleToasts) !== null &&
			n !== void 0
				? n
				: 1;
		var r;
		this.hasExitAnimation =
			(r = e == null ? void 0 : e.hasExitAnimation) !== null &&
			r !== void 0
				? r
				: !1;
	}
}
class Eme {
	reset(e) {
		(this.remaining = e), this.resume();
	}
	pause() {
		this.timerId != null &&
			(clearTimeout(this.timerId),
			(this.timerId = null),
			(this.remaining -= Date.now() - this.startTime));
	}
	resume() {
		this.remaining <= 0 ||
			((this.startTime = Date.now()),
			(this.timerId = setTimeout(() => {
				(this.timerId = null), (this.remaining = 0), this.callback();
			}, this.remaining)));
	}
	constructor(e, n) {
		(this.remaining = n), (this.callback = e);
	}
}
var rV = {};
rV = {
	close: "إغلاق",
	notifications: (t, e) =>
		`${e.plural(t.count, { one: () => `${e.number(t.count)} إشعار`, other: () => `${e.number(t.count)} إشعارات` })}.`,
};
var iV = {};
iV = {
	close: "Затвори",
	notifications: (t, e) =>
		`${e.plural(t.count, { one: () => `${e.number(t.count)} известие`, other: () => `${e.number(t.count)} известия` })}.`,
};
var oV = {};
oV = {
	close: "Zavřít",
	notifications: (t, e) =>
		`${e.plural(t.count, { one: () => `${e.number(t.count)} oznámení`, other: () => `${e.number(t.count)} oznámení` })}.`,
};
var sV = {};
sV = {
	close: "Luk",
	notifications: (t, e) =>
		`${e.plural(t.count, { one: () => `${e.number(t.count)} besked`, other: () => `${e.number(t.count)} beskeder` })}.`,
};
var aV = {};
aV = {
	close: "Schließen",
	notifications: (t, e) =>
		`${e.plural(t.count, { one: () => `${e.number(t.count)} Benachrichtigung`, other: () => `${e.number(t.count)} Benachrichtigungen` })}.`,
};
var lV = {};
lV = {
	close: "Κλείσιμο",
	notifications: (t, e) =>
		`${e.plural(t.count, { one: () => `${e.number(t.count)} ειδοποίηση`, other: () => `${e.number(t.count)} ειδοποιήσεις` })}.`,
};
var uV = {};
uV = {
	close: "Close",
	notifications: (t, e) =>
		`${e.plural(t.count, { one: () => `${e.number(t.count)} notification`, other: () => `${e.number(t.count)} notifications` })}.`,
};
var cV = {};
cV = {
	close: "Cerrar",
	notifications: (t, e) =>
		`${e.plural(t.count, { one: () => `${e.number(t.count)} notificación`, other: () => `${e.number(t.count)} notificaciones` })}.`,
};
var dV = {};
dV = {
	close: "Sule",
	notifications: (t, e) =>
		`${e.plural(t.count, { one: () => `${e.number(t.count)} teatis`, other: () => `${e.number(t.count)} teatist` })}.`,
};
var fV = {};
fV = {
	close: "Sulje",
	notifications: (t, e) =>
		`${e.plural(t.count, { one: () => `${e.number(t.count)} ilmoitus`, other: () => `${e.number(t.count)} ilmoitusta` })}.`,
};
var hV = {};
hV = {
	close: "Fermer",
	notifications: (t, e) =>
		`${e.plural(t.count, { one: () => `${e.number(t.count)} notification`, other: () => `${e.number(t.count)} notifications` })}.`,
};
var pV = {};
pV = {
	close: "סגור",
	notifications: (t, e) =>
		`${e.plural(t.count, { one: () => `${e.number(t.count)} התראה`, other: () => `${e.number(t.count)} התראות` })}.`,
};
var mV = {};
mV = {
	close: "Zatvori",
	notifications: (t, e) =>
		`${e.plural(t.count, { one: () => `${e.number(t.count)} obavijest`, other: () => `${e.number(t.count)} obavijesti` })}.`,
};
var gV = {};
gV = {
	close: "Bezárás",
	notifications: (t, e) =>
		`${e.plural(t.count, { one: () => `${e.number(t.count)} értesítés`, other: () => `${e.number(t.count)} értesítés` })}.`,
};
var bV = {};
bV = {
	close: "Chiudi",
	notifications: (t, e) =>
		`${e.plural(t.count, { one: () => `${e.number(t.count)} notifica`, other: () => `${e.number(t.count)} notifiche` })}.`,
};
var vV = {};
vV = {
	close: "閉じる",
	notifications: (t, e) =>
		`${e.plural(t.count, { one: () => `${e.number(t.count)} 個の通知`, other: () => `${e.number(t.count)} 個の通知` })}。`,
};
var yV = {};
yV = {
	close: "닫기",
	notifications: (t, e) =>
		`${e.plural(t.count, { one: () => `${e.number(t.count)}개 알림`, other: () => `${e.number(t.count)}개 알림` })}.`,
};
var xV = {};
xV = {
	close: "Uždaryti",
	notifications: (t, e) =>
		`${e.plural(t.count, { one: () => `${e.number(t.count)} pranešimas`, other: () => `${e.number(t.count)} pranešimai` })}.`,
};
var kV = {};
kV = {
	close: "Aizvērt",
	notifications: (t, e) =>
		`${e.plural(t.count, { one: () => `${e.number(t.count)} paziņojums`, other: () => `${e.number(t.count)} paziņojumi` })}.`,
};
var CV = {};
CV = {
	close: "Lukk",
	notifications: (t, e) =>
		`${e.plural(t.count, { one: () => `${e.number(t.count)} varsling`, other: () => `${e.number(t.count)} varsler` })}.`,
};
var wV = {};
wV = {
	close: "Sluiten",
	notifications: (t, e) =>
		`${e.plural(t.count, { one: () => `${e.number(t.count)} melding`, other: () => `${e.number(t.count)} meldingen` })}.`,
};
var EV = {};
EV = {
	close: "Zamknij",
	notifications: (t, e) =>
		`${e.plural(t.count, { one: () => `${e.number(t.count)} powiadomienie`, few: () => `${e.number(t.count)} powiadomienia`, many: () => `${e.number(t.count)} powiadomień`, other: () => `${e.number(t.count)} powiadomienia` })}.`,
};
var DV = {};
DV = {
	close: "Fechar",
	notifications: (t, e) =>
		`${e.plural(t.count, { one: () => `${e.number(t.count)} notificação`, other: () => `${e.number(t.count)} notificações` })}.`,
};
var SV = {};
SV = {
	close: "Fechar",
	notifications: (t, e) =>
		`${e.plural(t.count, { one: () => `${e.number(t.count)} notificação`, other: () => `${e.number(t.count)} notificações` })}.`,
};
var AV = {};
AV = {
	close: "Închideţi",
	notifications: (t, e) =>
		`${e.plural(t.count, { one: () => `${e.number(t.count)} notificare`, other: () => `${e.number(t.count)} notificări` })}.`,
};
var $V = {};
$V = {
	close: "Закрыть",
	notifications: (t, e) =>
		`${e.plural(t.count, { one: () => `${e.number(t.count)} уведомление`, other: () => `${e.number(t.count)} уведомления` })}.`,
};
var TV = {};
TV = {
	close: "Zatvoriť",
	notifications: (t, e) =>
		`${e.plural(t.count, { one: () => `${e.number(t.count)} oznámenie`, few: () => `${e.number(t.count)} oznámenia`, other: () => `${e.number(t.count)} oznámení` })}.`,
};
var BV = {};
BV = {
	close: "Zapri",
	notifications: (t, e) =>
		`${e.plural(t.count, { one: () => `${e.number(t.count)} obvestilo`, two: () => `${e.number(t.count)} obvestili`, few: () => `${e.number(t.count)} obvestila`, other: () => `${e.number(t.count)} obvestil` })}.`,
};
var IV = {};
IV = {
	close: "Zatvori",
	notifications: (t, e) =>
		`${e.plural(t.count, { one: () => `${e.number(t.count)} obaveštenje`, other: () => `${e.number(t.count)} obaveštenja` })}.`,
};
var FV = {};
FV = {
	close: "Stäng",
	notifications: (t, e) =>
		`${e.plural(t.count, { one: () => `${e.number(t.count)} meddelande`, other: () => `${e.number(t.count)} meddelanden` })}.`,
};
var PV = {};
PV = {
	close: "Kapat",
	notifications: (t, e) =>
		`${e.plural(t.count, { one: () => `${e.number(t.count)} bildirim`, other: () => `${e.number(t.count)} bildirim` })}.`,
};
var NV = {};
NV = {
	close: "Закрити",
	notifications: (t, e) =>
		`${e.plural(t.count, { one: () => `${e.number(t.count)} сповіщення`, other: () => `${e.number(t.count)} сповіщення` })}.`,
};
var RV = {};
RV = {
	close: "关闭",
	notifications: (t, e) =>
		`${e.plural(t.count, { one: () => `${e.number(t.count)} 个通知`, other: () => `${e.number(t.count)} 个通知` })}。`,
};
var OV = {};
OV = {
	close: "關閉",
	notifications: (t, e) =>
		`${e.plural(t.count, { one: () => `${e.number(t.count)} 個通知`, other: () => `${e.number(t.count)} 個通知` })}。`,
};
var ES = {};
ES = {
	"ar-AE": rV,
	"bg-BG": iV,
	"cs-CZ": oV,
	"da-DK": sV,
	"de-DE": aV,
	"el-GR": lV,
	"en-US": uV,
	"es-ES": cV,
	"et-EE": dV,
	"fi-FI": fV,
	"fr-FR": hV,
	"he-IL": pV,
	"hr-HR": mV,
	"hu-HU": gV,
	"it-IT": bV,
	"ja-JP": vV,
	"ko-KR": yV,
	"lt-LT": xV,
	"lv-LV": kV,
	"nb-NO": CV,
	"nl-NL": wV,
	"pl-PL": EV,
	"pt-BR": DV,
	"pt-PT": SV,
	"ro-RO": AV,
	"ru-RU": $V,
	"sk-SK": TV,
	"sl-SI": BV,
	"sr-SP": IV,
	"sv-SE": FV,
	"tr-TR": PV,
	"uk-UA": NV,
	"zh-CN": RV,
	"zh-TW": OV,
};
function Dme(t) {
	return t && t.__esModule ? t.default : t;
}
function Sme(t, e, n) {
	let { key: r, timer: i, timeout: o, animation: s } = t.toast;
	E.useEffect(() => {
		if (i)
			return (
				i.reset(o),
				() => {
					i.pause();
				}
			);
	}, [i, o]);
	let [a, l] = le.useState(!1);
	E.useEffect(() => {
		(s === "entering" || s === "queued") && l(!0);
	}, [s]);
	let u = Ot(),
		c = Lo(),
		d = Le(Dme(ES), "@react-aria/toast");
	return {
		toastProps: {
			role: "alertdialog",
			"aria-modal": "false",
			"aria-label": t["aria-label"],
			"aria-labelledby": t["aria-labelledby"] || u,
			"aria-describedby": t["aria-describedby"] || c,
			"aria-details": t["aria-details"],
			"aria-hidden": s === "exiting" ? "true" : void 0,
			tabIndex: 0,
		},
		contentProps: {
			role: "alert",
			"aria-atomic": "true",
			style: { visibility: a || s === null ? "visible" : "hidden" },
		},
		titleProps: { id: u },
		descriptionProps: { id: c },
		closeButtonProps: {
			"aria-label": d.format("close"),
			onPress: () => e.close(r),
		},
	};
}
const MV = 1,
	xk = Symbol.for("react-aria-landmark-manager");
function Ame(t) {
	return (
		document.addEventListener("react-aria-landmark-manager-change", t),
		() =>
			document.removeEventListener(
				"react-aria-landmark-manager-change",
				t,
			)
	);
}
function iB() {
	if (typeof document > "u") return null;
	let t = document[xk];
	return t && t.version >= MV
		? t
		: ((document[xk] = new Tme()),
			document.dispatchEvent(
				new CustomEvent("react-aria-landmark-manager-change"),
			),
			document[xk]);
}
function $me() {
	return nV.useSyncExternalStore(Ame, iB, iB);
}
class Tme {
	setupIfNeeded() {
		this.isListening ||
			(document.addEventListener("keydown", this.f6Handler, {
				capture: !0,
			}),
			document.addEventListener("focusin", this.focusinHandler, {
				capture: !0,
			}),
			document.addEventListener("focusout", this.focusoutHandler, {
				capture: !0,
			}),
			(this.isListening = !0));
	}
	teardownIfNeeded() {
		!this.isListening ||
			this.landmarks.length > 0 ||
			this.refCount > 0 ||
			(document.removeEventListener("keydown", this.f6Handler, {
				capture: !0,
			}),
			document.removeEventListener("focusin", this.focusinHandler, {
				capture: !0,
			}),
			document.removeEventListener("focusout", this.focusoutHandler, {
				capture: !0,
			}),
			(this.isListening = !1));
	}
	focusLandmark(e, n) {
		var r, i;
		(i = this.landmarks.find((o) => o.ref.current === e)) === null ||
			i === void 0 ||
			(r = i.focus) === null ||
			r === void 0 ||
			r.call(i, n);
	}
	getLandmarksByRole(e) {
		return new Set(this.landmarks.filter((n) => n.role === e));
	}
	getLandmarkByRole(e) {
		return this.landmarks.find((n) => n.role === e);
	}
	addLandmark(e) {
		if (
			(this.setupIfNeeded(),
			this.landmarks.find((i) => i.ref === e.ref) || !e.ref.current)
		)
			return;
		if (
			(this.landmarks.filter((i) => i.role === "main").length > 1 &&
				console.error(
					'Page can contain no more than one landmark with the role "main".',
				),
			this.landmarks.length === 0)
		) {
			(this.landmarks = [e]), this.checkLabels(e.role);
			return;
		}
		let n = 0,
			r = this.landmarks.length - 1;
		for (; n <= r; ) {
			let i = Math.floor((n + r) / 2),
				o = e.ref.current.compareDocumentPosition(
					this.landmarks[i].ref.current,
				);
			!!(
				o & Node.DOCUMENT_POSITION_PRECEDING ||
				o & Node.DOCUMENT_POSITION_CONTAINS
			)
				? (n = i + 1)
				: (r = i - 1);
		}
		this.landmarks.splice(n, 0, e), this.checkLabels(e.role);
	}
	updateLandmark(e) {
		let n = this.landmarks.findIndex((r) => r.ref === e.ref);
		n >= 0 &&
			((this.landmarks[n] = { ...this.landmarks[n], ...e }),
			this.checkLabels(this.landmarks[n].role));
	}
	removeLandmark(e) {
		(this.landmarks = this.landmarks.filter((n) => n.ref !== e)),
			this.teardownIfNeeded();
	}
	checkLabels(e) {
		let n = this.getLandmarksByRole(e);
		if (n.size > 1) {
			let r = [...n].filter((i) => !i.label);
			if (r.length > 0)
				console.warn(
					`Page contains more than one landmark with the '${e}' role. If two or more landmarks on a page share the same role, all must be labeled with an aria-label or aria-labelledby attribute: `,
					r.map((i) => i.ref.current),
				);
			else {
				let i = [...n].map((s) => s.label);
				i.filter((s, a) => i.indexOf(s) !== a).forEach((s) => {
					console.warn(
						`Page contains more than one landmark with the '${e}' role and '${s}' label. If two or more landmarks on a page share the same role, they must have unique labels: `,
						[...n]
							.filter((a) => a.label === s)
							.map((a) => a.ref.current),
					);
				});
			}
		}
	}
	closestLandmark(e) {
		let n = new Map(this.landmarks.map((i) => [i.ref.current, i])),
			r = e;
		for (; r && !n.has(r) && r !== document.body && r.parentElement; )
			r = r.parentElement;
		return n.get(r);
	}
	getNextLandmark(e, { backward: n }) {
		var r;
		let i = this.closestLandmark(e),
			o = n ? this.landmarks.length - 1 : 0;
		i && (o = this.landmarks.indexOf(i) + (n ? -1 : 1));
		let s = () => {
			if (o < 0) {
				if (
					!e.dispatchEvent(
						new CustomEvent("react-aria-landmark-navigation", {
							detail: { direction: "backward" },
							bubbles: !0,
							cancelable: !0,
						}),
					)
				)
					return !0;
				o = this.landmarks.length - 1;
			} else if (o >= this.landmarks.length) {
				if (
					!e.dispatchEvent(
						new CustomEvent("react-aria-landmark-navigation", {
							detail: { direction: "forward" },
							bubbles: !0,
							cancelable: !0,
						}),
					)
				)
					return !0;
				o = 0;
			}
			return o < 0 || o >= this.landmarks.length;
		};
		if (s()) return;
		let a = o;
		for (
			;
			!((r = this.landmarks[o].ref.current) === null || r === void 0) &&
			r.closest("[aria-hidden=true]");

		) {
			if (((o += n ? -1 : 1), s())) return;
			if (o === a) break;
		}
		return this.landmarks[o];
	}
	f6Handler(e) {
		e.key === "F6" &&
			(e.altKey
				? this.focusMain()
				: this.navigate(e.target, e.shiftKey)) &&
			(e.preventDefault(), e.stopPropagation());
	}
	focusMain() {
		let e = this.getLandmarkByRole("main");
		return e && e.ref.current && document.contains(e.ref.current)
			? (this.focusLandmark(e.ref.current, "forward"), !0)
			: !1;
	}
	navigate(e, n) {
		let r = this.getNextLandmark(e, { backward: n });
		if (!r) return !1;
		if (r.lastFocused) {
			let i = r.lastFocused;
			if (document.body.contains(i)) return i.focus(), !0;
		}
		return r.ref.current && document.contains(r.ref.current)
			? (this.focusLandmark(r.ref.current, n ? "backward" : "forward"),
				!0)
			: !1;
	}
	focusinHandler(e) {
		let n = this.closestLandmark(e.target);
		n &&
			n.ref.current !== e.target &&
			this.updateLandmark({ ref: n.ref, lastFocused: e.target });
		let r = e.relatedTarget;
		if (r) {
			let i = this.closestLandmark(r);
			i && i.ref.current === r && i.blur();
		}
	}
	focusoutHandler(e) {
		let n = e.target,
			r = e.relatedTarget;
		if (!r || r === document) {
			let i = this.closestLandmark(n);
			i && i.ref.current === n && i.blur();
		}
	}
	createLandmarkController() {
		let e = this;
		return (
			e.refCount++,
			e.setupIfNeeded(),
			{
				navigate(n, r) {
					let i =
						(r == null ? void 0 : r.from) || document.activeElement;
					return e.navigate(i, n === "backward");
				},
				focusNext(n) {
					let r =
						(n == null ? void 0 : n.from) || document.activeElement;
					return e.navigate(r, !1);
				},
				focusPrevious(n) {
					let r =
						(n == null ? void 0 : n.from) || document.activeElement;
					return e.navigate(r, !0);
				},
				focusMain() {
					return e.focusMain();
				},
				dispose() {
					e && (e.refCount--, e.teardownIfNeeded(), (e = null));
				},
			}
		);
	}
	registerLandmark(e) {
		return (
			this.landmarks.find((n) => n.ref === e.ref)
				? this.updateLandmark(e)
				: this.addLandmark(e),
			() => this.removeLandmark(e.ref)
		);
	}
	constructor() {
		(this.landmarks = []),
			(this.isListening = !1),
			(this.refCount = 0),
			(this.version = MV),
			(this.f6Handler = this.f6Handler.bind(this)),
			(this.focusinHandler = this.focusinHandler.bind(this)),
			(this.focusoutHandler = this.focusoutHandler.bind(this));
	}
}
function Bme(t, e) {
	const { role: n, "aria-label": r, "aria-labelledby": i, focus: o } = t;
	let s = $me(),
		a = r || i,
		[l, u] = E.useState(!1),
		c = E.useCallback(() => {
			u(!0);
		}, [u]),
		d = E.useCallback(() => {
			u(!1);
		}, [u]);
	return (
		at(() => {
			if (s)
				return s.registerLandmark({
					ref: e,
					label: a,
					role: n,
					focus: o || c,
					blur: d,
				});
		}, [s, a, e, n, o, c, d]),
		E.useEffect(() => {
			var f;
			l && ((f = e.current) === null || f === void 0 || f.focus());
		}, [l, e]),
		{
			landmarkProps: {
				role: n,
				tabIndex: l ? -1 : void 0,
				"aria-label": r,
				"aria-labelledby": i,
			},
		}
	);
}
function Ime(t) {
	return t && t.__esModule ? t.default : t;
}
function Fme(t, e, n) {
	let r = Le(Ime(ES), "@react-aria/toast"),
		{ landmarkProps: i } = Bme(
			{
				role: "region",
				"aria-label":
					t["aria-label"] ||
					r.format("notifications", {
						count: e.visibleToasts.length,
					}),
			},
			n,
		),
		{ hoverProps: o } = gn({
			onHoverStart: e.pauseAll,
			onHoverEnd: e.resumeAll,
		}),
		s = E.useRef([]),
		a = E.useRef(e.visibleToasts),
		l = E.useRef(null);
	at(() => {
		if (l.current === -1 || e.visibleToasts.length === 0) {
			(s.current = []), (a.current = e.visibleToasts);
			return;
		}
		if (
			((s.current = [
				...n.current.querySelectorAll('[role="alertdialog"]'),
			]),
			a.current.length === e.visibleToasts.length &&
				e.visibleToasts.every((h, p) => h.key === a.current[p].key))
		) {
			a.current = e.visibleToasts;
			return;
		}
		let d = a.current.map((h, p) => ({
				...h,
				i: p,
				isRemoved: !e.visibleToasts.some((g) => h.key === g.key),
			})),
			f = d.findIndex((h) => h.i === l.current);
		if (f > -1) {
			let h = 0,
				p,
				g;
			for (; h <= f; ) d[h].isRemoved || (g = Math.max(0, h - 1)), h++;
			for (; h < d.length; ) {
				if (!d[h].isRemoved) {
					p = h - 1;
					break;
				}
				h++;
			}
			g === void 0 && p === void 0 && (g = 0),
				g >= 0 && g < s.current.length
					? io(s.current[g])
					: p >= 0 && p < s.current.length && io(s.current[p]);
		}
		a.current = e.visibleToasts;
	}, [e.visibleToasts, n]);
	let u = E.useRef(null),
		{ focusWithinProps: c } = Ud({
			onFocusWithin: (d) => {
				e.pauseAll(), (u.current = d.relatedTarget);
			},
			onBlurWithin: () => {
				e.resumeAll(), (u.current = null);
			},
		});
	return (
		E.useEffect(() => {
			e.visibleToasts.length === 0 &&
				u.current &&
				document.body.contains(u.current) &&
				(gl() === "pointer" ? io(u.current) : u.current.focus(),
				(u.current = null));
		}, [n, e.visibleToasts.length]),
		E.useEffect(
			() => () => {
				u.current &&
					document.body.contains(u.current) &&
					(gl() === "pointer" ? io(u.current) : u.current.focus(),
					(u.current = null));
			},
			[n],
		),
		{
			regionProps: xe(i, o, c, {
				tabIndex: -1,
				"data-react-aria-top-layer": !0,
				onFocus: (d) => {
					let f = d.target.closest('[role="alertdialog"]');
					l.current = s.current.findIndex((h) => h === f);
				},
				onBlur: () => {
					l.current = -1;
				},
			}),
		}
	);
}
const jV = m.jsxs(m.Fragment, {
		children: [
			m.jsx("circle", { cx: 12, cy: 12, r: 10 }),
			m.jsx("path", { d: "m9 12 2 2 4-4" }),
		],
	}),
	_V = m.jsxs(m.Fragment, {
		children: [
			m.jsx("circle", { cx: 12, cy: 12, r: 10 }),
			m.jsx("path", { d: "M12 16v-4M12 8h.01" }),
		],
	}),
	Pme = {
		"ar-AE": { info: "معلومات", critical: "خطأ", positive: "تم بنجاح" },
		"bg-BG": { info: "Инфо", critical: "Грешка", positive: "Успех" },
		"cs-CZ": { info: "Informace", critical: "Chyba", positive: "Úspěch" },
		"da-DK": { info: "Info", critical: "Fejl", positive: "Fuldført" },
		"de-DE": {
			info: "Informationen",
			critical: "Fehler",
			positive: "Erfolg",
		},
		"el-GR": {
			info: "Πληροφορίες",
			critical: "Σφάλμα",
			positive: "Επιτυχία",
		},
		"en-US": { info: "Info", critical: "Error", positive: "Success" },
		"es-ES": { info: "Información", critical: "Error", positive: "Éxito" },
		"et-EE": { info: "Teave", critical: "Viga", positive: "Valmis" },
		"fi-FI": { info: "Tiedot", critical: "Virhe", positive: "Onnistui" },
		"fr-FR": { info: "Infos", critical: "Erreur", positive: "Succès" },
		"he-IL": { info: "מידע", critical: "שגיאה", positive: "הצלחה" },
		"hr-HR": {
			info: "Informacije",
			critical: "Pogreška",
			positive: "Uspješno",
		},
		"hu-HU": { info: "Információ", critical: "Hiba", positive: "Siker" },
		"it-IT": {
			info: "Informazioni",
			critical: "Errore",
			positive: "Operazione riuscita",
		},
		"ja-JP": { info: "情報", critical: "エラー", positive: "成功" },
		"ko-KR": { info: "정보", critical: "오류", positive: "성공" },
		"lt-LT": {
			info: "Informacija",
			critical: "Klaida",
			positive: "Sėkmingai",
		},
		"lv-LV": {
			info: "Informācija",
			critical: "Kļūda",
			positive: "Izdevās",
		},
		"nb-NO": { info: "Info", critical: "Feil", positive: "Vellykket" },
		"nl-NL": { info: "Info", critical: "Fout", positive: "Geslaagd" },
		"pl-PL": {
			info: "Informacje",
			critical: "Błąd",
			positive: "Powodzenie",
		},
		"pt-BR": { info: "Informações", critical: "Erro", positive: "Sucesso" },
		"pt-PT": { info: "Informação", critical: "Erro", positive: "Sucesso" },
		"ro-RO": { info: "Informaţii", critical: "Eroare", positive: "Succes" },
		"ru-RU": {
			info: "Информация",
			critical: "Ошибка",
			positive: "Успешно",
		},
		"sk-SK": { info: "Informácie", critical: "Chyba", positive: "Úspech" },
		"sl-SI": {
			info: "Informacije",
			critical: "Napaka",
			positive: "Uspešno",
		},
		"sr-SP": {
			info: "Informacije",
			critical: "Greška",
			positive: "Uspešno",
		},
		"sv-SE": { info: "Info", critical: "Fel", positive: "Lyckades" },
		"tr-TR": { info: "Bilgiler", critical: "Hata", positive: "Başarılı" },
		"uk-UA": {
			info: "Інформація",
			critical: "Помилка",
			positive: "Успішно",
		},
		"zh-CN": { info: "信息", critical: "错误", positive: "成功" },
		"zh-TW": { info: "資訊", critical: "錯誤", positive: "成功" },
	},
	Nme = { info: _V, critical: bv, positive: jV };
function Rme(t, e) {
	const n = ce(59);
	let r, i, o;
	n[0] !== t
		? (({ toast: r, state: i, ...o } = t),
			(n[0] = t),
			(n[1] = r),
			(n[2] = i),
			(n[3] = o))
		: ((r = n[1]), (i = n[2]), (o = n[3]));
	const { key: s, animation: a, content: l } = r,
		{
			children: u,
			tone: c,
			actionLabel: d,
			onAction: f,
			shouldCloseOnAction: h,
		} = l,
		p = Ct(e),
		{
			closeButtonProps: g,
			titleProps: v,
			toastProps: b,
			contentProps: y,
		} = Sme(t, i),
		x = ht(o),
		C = Le(Pme);
	let k;
	n[4] !== c || n[5] !== C
		? ((k = c && c !== "neutral" ? C.format(c) : null),
			(n[4] = c),
			(n[5] = C),
			(n[6] = k))
		: (k = n[6]);
	const w = k,
		D = c && c !== "neutral" ? Nme[c] : null;
	let S;
	n[7] !== f || n[8] !== h || n[9] !== i || n[10] !== s
		? ((S = () => {
				f && f(), h && i.close(s);
			}),
			(n[7] = f),
			(n[8] = h),
			(n[9] = i),
			(n[10] = s),
			(n[11] = S))
		: (S = n[11]);
	const $ = S;
	let A, T;
	n[12] === Symbol.for("react.memo_cache_sentinel")
		? ((T = { text: { color: "inherit" } }), (n[12] = T))
		: (T = n[12]),
		(A = T);
	const I = A;
	let F;
	n[13] !== x.className
		? ((F = Se(
				X({
					borderRadius: B.size.radius.regular,
					display: "flex",
					margin: B.size.space.large,
					maxWidth: B.size.container.xsmall,
					minHeight: B.size.element.large,
					padding: B.size.space.regular,
					paddingInlineStart: B.size.space.large,
					pointerEvents: "auto",
					position: "absolute",
					color: B.color.foreground.onEmphasis,
					"&[data-tone=neutral]": {
						background: B.color.scale.slate9,
					},
					"&[data-tone=info]": {
						background: B.color.background.accentEmphasis,
					},
					"&[data-tone=positive]": {
						background: B.color.background.positiveEmphasis,
					},
					"&[data-tone=critical]": {
						background: B.color.background.criticalEmphasis,
					},
					"&[data-animation=entering]": { animation: `${Ome} 300ms` },
					"&[data-animation=exiting]": {
						animation: `${Mme} 300ms forwards`,
					},
				}),
				x.className,
			)),
			(n[13] = x.className),
			(n[14] = F))
		: (F = n[14]);
	let N;
	n[15] !== x.style || n[16] !== t.toast.priority
		? ((N = { ...x.style, zIndex: t.toast.priority }),
			(n[15] = x.style),
			(n[16] = t.toast.priority),
			(n[17] = N))
		: (N = n[17]);
	let O;
	n[18] !== a || n[19] !== i || n[20] !== s
		? ((O = () => {
				a === "exiting" && i.remove(s);
			}),
			(n[18] = a),
			(n[19] = i),
			(n[20] = s),
			(n[21] = O))
		: (O = n[21]);
	let _;
	n[22] === Symbol.for("react.memo_cache_sentinel")
		? ((_ = X({ display: "flex" })), (n[22] = _))
		: (_ = n[22]);
	let j;
	n[23] !== D || n[24] !== w
		? ((j =
				D &&
				m.jsx(ve, {
					"aria-label": w,
					src: D,
					size: "medium",
					marginTop: "small",
					marginEnd: "regular",
				})),
			(n[23] = D),
			(n[24] = w),
			(n[25] = j))
		: (j = n[25]);
	let V;
	n[26] === Symbol.for("react.memo_cache_sentinel")
		? ((V = Se(
				X({
					alignItems: "center",
					display: "flex",
					columnGap: B.size.space.large,
					flex: 1,
					flexWrap: "wrap",
					justifyContent: "flex-end",
					paddingInlineEnd: B.size.space.large,
				}),
			)),
			(n[26] = V))
		: (V = n[26]);
	let K;
	n[27] === Symbol.for("react.memo_cache_sentinel")
		? ((K = Se(X({ flexGrow: 1, paddingBlock: B.size.space.regular }))),
			(n[27] = K))
		: (K = n[27]);
	let M;
	n[28] !== u
		? ((M = $n(u) ? m.jsx(ue, { children: u }) : u),
			(n[28] = u),
			(n[29] = M))
		: (M = n[29]);
	let G;
	n[30] !== v || n[31] !== M
		? ((G = m.jsx("div", { className: K, ...v, children: M })),
			(n[30] = v),
			(n[31] = M),
			(n[32] = G))
		: (G = n[32]);
	let H;
	n[33] !== d || n[34] !== $
		? ((H = d && m.jsx(vt, { onPress: $, static: "light", children: d })),
			(n[33] = d),
			(n[34] = $),
			(n[35] = H))
		: (H = n[35]);
	let P;
	n[36] !== G || n[37] !== H
		? ((P = m.jsxs("div", { className: V, children: [G, H] })),
			(n[36] = G),
			(n[37] = H),
			(n[38] = P))
		: (P = n[38]);
	let q;
	n[39] !== y || n[40] !== j || n[41] !== P
		? ((q = m.jsxs("div", { ...y, className: _, children: [j, P] })),
			(n[39] = y),
			(n[40] = j),
			(n[41] = P),
			(n[42] = q))
		: (q = n[42]);
	let J;
	n[43] === Symbol.for("react.memo_cache_sentinel")
		? ((J = X({
				borderInlineStart: `${B.size.border.regular} solid #fff3`,
				paddingInlineStart: B.size.space.regular,
			})),
			(n[43] = J))
		: (J = n[43]);
	let Z;
	n[44] !== g
		? ((Z = m.jsx("div", {
				className: J,
				children: m.jsx(wx, { static: "light", ...g }),
			})),
			(n[44] = g),
			(n[45] = Z))
		: (Z = n[45]);
	let oe;
	n[46] !== q || n[47] !== Z
		? ((oe = m.jsxs(Cn, { slots: I, children: [q, Z] })),
			(n[46] = q),
			(n[47] = Z),
			(n[48] = oe))
		: (oe = n[48]);
	let ne;
	return (
		n[49] !== x ||
		n[50] !== b ||
		n[51] !== p ||
		n[52] !== c ||
		n[53] !== F ||
		n[54] !== N ||
		n[55] !== a ||
		n[56] !== O ||
		n[57] !== oe
			? ((ne = m.jsx("div", {
					...x,
					...b,
					ref: p,
					"data-tone": c,
					className: F,
					style: N,
					"data-animation": a,
					onAnimationEnd: O,
					children: oe,
				})),
				(n[49] = x),
				(n[50] = b),
				(n[51] = p),
				(n[52] = c),
				(n[53] = F),
				(n[54] = N),
				(n[55] = a),
				(n[56] = O),
				(n[57] = oe),
				(n[58] = ne))
			: (ne = n[58]),
		ne
	);
}
let Ome = Uh({
		from: { transform: "var(--slide-from)" },
		to: { transform: "var(--slide-to)" },
	}),
	Mme = Uh({ from: { opacity: 1 }, to: { opacity: 0 } }),
	jme = E.forwardRef(Rme);
function _me(t) {
	const e = ce(11),
		{ children: n, state: r } = t,
		{ direction: i } = Vt(),
		o = kx(),
		s = o ? "center" : t.placement || "end",
		a = o ? "bottom" : t.position || "bottom",
		l = E.useRef(null),
		{ regionProps: u } = Fme(t, r, l);
	let c;
	e[0] === Symbol.for("react.memo_cache_sentinel")
		? ((c = { background: "transparent" }), (e[0] = c))
		: (c = e[0]);
	let d;
	e[1] === Symbol.for("react.memo_cache_sentinel")
		? ((d = X({
				display: "flex",
				insetInline: 0,
				outline: "none",
				pointerEvents: "none",
				position: "fixed",
				zIndex: 100,
				"&[data-focus=visible] > :first-child:after": {
					borderRadius: `calc(${B.size.radius.regular} + ${B.size.alias.focusRingGap})`,
					boxShadow: `0 0 0 ${B.size.alias.focusRing} ${B.color.alias.focusRing}`,
					content: '""',
					inset: 0,
					margin: `calc(-1 * ${B.size.alias.focusRingGap})`,
					pointerEvents: "none",
					position: "absolute",
				},
				"&[data-position=top]": {
					top: 0,
					flexDirection: "column",
					"--slide-from": "translateY(-100%)",
					"--slide-to": "translateY(0)",
				},
				"&[data-position=bottom]": {
					bottom: 0,
					flexDirection: "column-reverse",
					"--slide-from": "translateY(100%)",
					"--slide-to": "translateY(0)",
				},
				"&[data-placement=start]": {
					alignItems: "flex-start",
					"--slide-from": "translateX(-100%)",
					"--slide-to": "translateX(0)",
					"&[data-direction=rtl]": {
						"--slide-from": "translateX(100%)",
					},
				},
				"&[data-placement=center]": { alignItems: "center" },
				"&[data-placement=end]": {
					alignItems: "flex-end",
					"--slide-from": "translateX(100%)",
					"--slide-to": "translateX(0)",
					"&[data-direction=rtl]": {
						"--slide-from": "translateX(-100%)",
					},
				},
			})),
			(e[1] = d))
		: (d = e[1]);
	let f;
	e[2] !== u ||
	e[3] !== l ||
	e[4] !== i ||
	e[5] !== a ||
	e[6] !== s ||
	e[7] !== n
		? ((f = m.jsx(Hh, {
				UNSAFE_style: c,
				children: m.jsx(xn, {
					children: m.jsx("div", {
						...u,
						ref: l,
						"data-direction": i,
						"data-position": a,
						"data-placement": s,
						className: d,
						children: n,
					}),
				}),
			})),
			(e[2] = u),
			(e[3] = l),
			(e[4] = i),
			(e[5] = a),
			(e[6] = s),
			(e[7] = n),
			(e[8] = f))
		: (f = e[8]);
	const h = f;
	let p;
	return (
		e[9] !== h
			? ((p = ix.createPortal(h, document.body)), (e[9] = h), (e[10] = p))
			: (p = e[10]),
		p
	);
}
let kk = null;
function Ww() {
	return (
		kk || (kk = new wme({ maxVisibleToasts: 1, hasExitAnimation: !0 })), kk
	);
}
let qw = new Set(),
	Gw = new Set();
function zme(t) {
	return Gw.add(t), () => Gw.delete(t);
}
function oB() {
	return qw.values().next().value;
}
function Lme() {
	return E.useSyncExternalStore(zme, oB, oB);
}
function Vme(t) {
	const e = ce(10),
		n = E.useRef();
	qw.add(n);
	let r;
	e[0] !== n
		? ((r = () => () => {
				for (const l of Ww().visibleToasts) l.animation = void 0;
				qw.delete(n);
				for (const l of Gw) l();
			}),
			(e[0] = n),
			(e[1] = r))
		: (r = e[1]);
	let i;
	e[2] === Symbol.for("react.memo_cache_sentinel")
		? ((i = []), (e[2] = i))
		: (i = e[2]),
		E.useEffect(r, i);
	const o = Lme();
	let s;
	e[3] === Symbol.for("react.memo_cache_sentinel")
		? ((s = Ww()), (e[3] = s))
		: (s = e[3]);
	const a = Cme(s);
	if (n === o && a.visibleToasts.length > 0) {
		let l;
		e[4] !== a
			? ((l = a.visibleToasts.map((c) =>
					m.jsx(jme, { toast: c, state: a }, c.key),
				)),
				(e[4] = a),
				(e[5] = l))
			: (l = e[5]);
		let u;
		return (
			e[6] !== a || e[7] !== t || e[8] !== l
				? ((u = m.jsx(_me, { state: a, ...t, children: l })),
					(e[6] = a),
					(e[7] = t),
					(e[8] = l),
					(e[9] = u))
				: (u = e[9]),
			u
		);
	}
	return null;
}
function P1(t, e, n = {}) {
	if (typeof CustomEvent < "u" && typeof window < "u") {
		let a = new CustomEvent("keystar-ui-toast", {
			cancelable: !0,
			bubbles: !0,
			detail: { children: t, tone: e, options: n },
		});
		if (!window.dispatchEvent(a)) return () => {};
	}
	let r = {
		children: t,
		tone: e,
		actionLabel: n.actionLabel,
		onAction: n.onAction,
		shouldCloseOnAction: n.shouldCloseOnAction,
	};
	typeof n.timeout == "number" && n.timeout >= 5e3;
	let i = n.timeout ? Math.max(n.timeout, 5e3) : void 0,
		o = Ww(),
		s = o.add(r, { priority: Ume(e, n), timeout: i, onClose: n.onClose });
	return () => o.close(s);
}
const il = {
		neutral(t, e = {}) {
			return P1(t, "neutral", e);
		},
		positive(t, e = {}) {
			return P1(t, "positive", e);
		},
		critical(t, e = {}) {
			return P1(t, "critical", e);
		},
		info(t, e = {}) {
			return P1(t, "info", e);
		},
	},
	Kme = { critical: 10, positive: 3, info: 2, neutral: 1 };
function Ume(t, e) {
	let n = Kme[t] || 1;
	return e.onAction && (n += 4), n;
}
const ma = Math.floor,
	mb = Math.abs,
	Hme = Math.log10,
	Su = (t, e) => (t < e ? t : e),
	yl = (t, e) => (t > e ? t : e),
	zV = (t) => (t !== 0 ? t < 0 : 1 / t < 0),
	sB = 1,
	aB = 2,
	Ck = 4,
	wk = 8,
	ag = 32,
	ol = 64,
	ao = 128,
	Zx = 31,
	Yw = 63,
	ed = 127,
	Wme = 2147483647,
	LV = Number.MAX_SAFE_INTEGER,
	qme =
		Number.isInteger ||
		((t) => typeof t == "number" && isFinite(t) && ma(t) === t),
	xl = () => new Set(),
	Ek = (t) => t[t.length - 1],
	Gme = (t, e) => {
		for (let n = 0; n < e.length; n++) t.push(e[n]);
	},
	kl = Array.from,
	Yme = (t, e) => {
		for (let n = 0; n < t.length; n++) if (e(t[n], n, t)) return !0;
		return !1;
	},
	Jw = Array.isArray,
	Jme = String.fromCharCode,
	Xme = (t) => t.toLowerCase(),
	Zme = /^\s*/g,
	Qme = (t) => t.replace(Zme, ""),
	ege = /([A-Z])/g,
	lB = (t, e) => Qme(t.replace(ege, (n) => `${e}${Xme(n)}`)),
	tge = (t) => {
		const e = unescape(encodeURIComponent(t)),
			n = e.length,
			r = new Uint8Array(n);
		for (let i = 0; i < n; i++) r[i] = e.codePointAt(i);
		return r;
	},
	lg = typeof TextEncoder < "u" ? new TextEncoder() : null,
	nge = (t) => lg.encode(t),
	rge = lg ? nge : tge;
let wm =
	typeof TextDecoder > "u"
		? null
		: new TextDecoder("utf-8", { fatal: !0, ignoreBOM: !0 });
wm && wm.decode(new Uint8Array()).length === 1 && (wm = null);
class A0 {
	constructor() {
		(this.cpos = 0), (this.cbuf = new Uint8Array(100)), (this.bufs = []);
	}
}
const In = () => new A0(),
	qv = (t) => {
		let e = t.cpos;
		for (let n = 0; n < t.bufs.length; n++) e += t.bufs[n].length;
		return e;
	},
	Kt = (t) => {
		const e = new Uint8Array(qv(t));
		let n = 0;
		for (let r = 0; r < t.bufs.length; r++) {
			const i = t.bufs[r];
			e.set(i, n), (n += i.length);
		}
		return e.set(new Uint8Array(t.cbuf.buffer, 0, t.cpos), n), e;
	},
	ige = (t, e) => {
		const n = t.cbuf.length;
		n - t.cpos < e &&
			(t.bufs.push(new Uint8Array(t.cbuf.buffer, 0, t.cpos)),
			(t.cbuf = new Uint8Array(yl(n, e) * 2)),
			(t.cpos = 0));
	},
	lr = (t, e) => {
		const n = t.cbuf.length;
		t.cpos === n &&
			(t.bufs.push(t.cbuf),
			(t.cbuf = new Uint8Array(n * 2)),
			(t.cpos = 0)),
			(t.cbuf[t.cpos++] = e);
	},
	Xw = lr,
	Oe = (t, e) => {
		for (; e > ed; ) lr(t, ao | (ed & e)), (e = ma(e / 128));
		lr(t, ed & e);
	},
	DS = (t, e) => {
		const n = zV(e);
		for (
			n && (e = -e),
				lr(t, (e > Yw ? ao : 0) | (n ? ol : 0) | (Yw & e)),
				e = ma(e / 64);
			e > 0;

		)
			lr(t, (e > ed ? ao : 0) | (ed & e)), (e = ma(e / 128));
	},
	Zw = new Uint8Array(3e4),
	oge = Zw.length / 3,
	sge = (t, e) => {
		if (e.length < oge) {
			const n = lg.encodeInto(e, Zw).written || 0;
			Oe(t, n);
			for (let r = 0; r < n; r++) lr(t, Zw[r]);
		} else Fn(t, rge(e));
	},
	age = (t, e) => {
		const n = unescape(encodeURIComponent(e)),
			r = n.length;
		Oe(t, r);
		for (let i = 0; i < r; i++) lr(t, n.codePointAt(i));
	},
	aa = lg && lg.encodeInto ? sge : age,
	lge = (t, e) => $0(t, Kt(e)),
	$0 = (t, e) => {
		const n = t.cbuf.length,
			r = t.cpos,
			i = Su(n - r, e.length),
			o = e.length - i;
		t.cbuf.set(e.subarray(0, i), r),
			(t.cpos += i),
			o > 0 &&
				(t.bufs.push(t.cbuf),
				(t.cbuf = new Uint8Array(yl(n * 2, o))),
				t.cbuf.set(e.subarray(i)),
				(t.cpos = o));
	},
	Fn = (t, e) => {
		Oe(t, e.byteLength), $0(t, e);
	},
	SS = (t, e) => {
		ige(t, e);
		const n = new DataView(t.cbuf.buffer, t.cpos, e);
		return (t.cpos += e), n;
	},
	uge = (t, e) => SS(t, 4).setFloat32(0, e, !1),
	cge = (t, e) => SS(t, 8).setFloat64(0, e, !1),
	dge = (t, e) => SS(t, 8).setBigInt64(0, e, !1),
	uB = new DataView(new ArrayBuffer(4)),
	fge = (t) => (uB.setFloat32(0, t), uB.getFloat32(0) === t),
	ug = (t, e) => {
		switch (typeof e) {
			case "string":
				lr(t, 119), aa(t, e);
				break;
			case "number":
				qme(e) && mb(e) <= Wme
					? (lr(t, 125), DS(t, e))
					: fge(e)
						? (lr(t, 124), uge(t, e))
						: (lr(t, 123), cge(t, e));
				break;
			case "bigint":
				lr(t, 122), dge(t, e);
				break;
			case "object":
				if (e === null) lr(t, 126);
				else if (Jw(e)) {
					lr(t, 117), Oe(t, e.length);
					for (let n = 0; n < e.length; n++) ug(t, e[n]);
				} else if (e instanceof Uint8Array) lr(t, 116), Fn(t, e);
				else {
					lr(t, 118);
					const n = Object.keys(e);
					Oe(t, n.length);
					for (let r = 0; r < n.length; r++) {
						const i = n[r];
						aa(t, i), ug(t, e[i]);
					}
				}
				break;
			case "boolean":
				lr(t, e ? 120 : 121);
				break;
			default:
				lr(t, 127);
		}
	};
class cB extends A0 {
	constructor(e) {
		super(), (this.w = e), (this.s = null), (this.count = 0);
	}
	write(e) {
		this.s === e
			? this.count++
			: (this.count > 0 && Oe(this, this.count - 1),
				(this.count = 1),
				this.w(this, e),
				(this.s = e));
	}
}
const dB = (t) => {
	t.count > 0 &&
		(DS(t.encoder, t.count === 1 ? t.s : -t.s),
		t.count > 1 && Oe(t.encoder, t.count - 2));
};
class gb {
	constructor() {
		(this.encoder = new A0()), (this.s = 0), (this.count = 0);
	}
	write(e) {
		this.s === e
			? this.count++
			: (dB(this), (this.count = 1), (this.s = e));
	}
	toUint8Array() {
		return dB(this), Kt(this.encoder);
	}
}
const fB = (t) => {
	if (t.count > 0) {
		const e = t.diff * 2 + (t.count === 1 ? 0 : 1);
		DS(t.encoder, e), t.count > 1 && Oe(t.encoder, t.count - 2);
	}
};
class Dk {
	constructor() {
		(this.encoder = new A0()),
			(this.s = 0),
			(this.count = 0),
			(this.diff = 0);
	}
	write(e) {
		this.diff === e - this.s
			? ((this.s = e), this.count++)
			: (fB(this),
				(this.count = 1),
				(this.diff = e - this.s),
				(this.s = e));
	}
	toUint8Array() {
		return fB(this), Kt(this.encoder);
	}
}
class hge {
	constructor() {
		(this.sarr = []), (this.s = ""), (this.lensE = new gb());
	}
	write(e) {
		(this.s += e),
			this.s.length > 19 && (this.sarr.push(this.s), (this.s = "")),
			this.lensE.write(e.length);
	}
	toUint8Array() {
		const e = new A0();
		return (
			this.sarr.push(this.s),
			(this.s = ""),
			aa(e, this.sarr.join("")),
			$0(e, this.lensE.toUint8Array()),
			Kt(e)
		);
	}
}
const Uu = (t) => new Error(t),
	ws = () => {
		throw Uu("Method unimplemented");
	},
	go = () => {
		throw Uu("Unexpected case");
	},
	VV = Uu("Unexpected end of array"),
	KV = Uu("Integer out of Range");
class Qx {
	constructor(e) {
		(this.arr = e), (this.pos = 0);
	}
}
const Vi = (t) => new Qx(t),
	pge = (t) => t.pos !== t.arr.length,
	mge = (t, e) => {
		const n = new Uint8Array(t.arr.buffer, t.pos + t.arr.byteOffset, e);
		return (t.pos += e), n;
	},
	ur = (t) => mge(t, nt(t)),
	Bh = (t) => t.arr[t.pos++],
	nt = (t) => {
		let e = 0,
			n = 1;
		const r = t.arr.length;
		for (; t.pos < r; ) {
			const i = t.arr[t.pos++];
			if (((e = e + (i & ed) * n), (n *= 128), i < ao)) return e;
			if (e > LV) throw KV;
		}
		throw VV;
	},
	cg = (t) => {
		let e = t.arr[t.pos++],
			n = e & Yw,
			r = 64;
		const i = (e & ol) > 0 ? -1 : 1;
		if (!(e & ao)) return i * n;
		const o = t.arr.length;
		for (; t.pos < o; ) {
			if (
				((e = t.arr[t.pos++]),
				(n = n + (e & ed) * r),
				(r *= 128),
				e < ao)
			)
				return i * n;
			if (n > LV) throw KV;
		}
		throw VV;
	},
	gge = (t) => {
		let e = nt(t);
		if (e === 0) return "";
		{
			let n = String.fromCodePoint(Bh(t));
			if (--e < 100) for (; e--; ) n += String.fromCodePoint(Bh(t));
			else
				for (; e > 0; ) {
					const r = e < 1e4 ? e : 1e4,
						i = t.arr.subarray(t.pos, t.pos + r);
					(t.pos += r),
						(n += String.fromCodePoint.apply(null, i)),
						(e -= r);
				}
			return decodeURIComponent(escape(n));
		}
	},
	bge = (t) => wm.decode(ur(t)),
	Es = wm ? bge : gge,
	AS = (t, e) => {
		const n = new DataView(t.arr.buffer, t.arr.byteOffset + t.pos, e);
		return (t.pos += e), n;
	},
	vge = (t) => AS(t, 4).getFloat32(0, !1),
	yge = (t) => AS(t, 8).getFloat64(0, !1),
	xge = (t) => AS(t, 8).getBigInt64(0, !1),
	kge = [
		(t) => {},
		(t) => null,
		cg,
		vge,
		yge,
		xge,
		(t) => !1,
		(t) => !0,
		Es,
		(t) => {
			const e = nt(t),
				n = {};
			for (let r = 0; r < e; r++) {
				const i = Es(t);
				n[i] = dg(t);
			}
			return n;
		},
		(t) => {
			const e = nt(t),
				n = [];
			for (let r = 0; r < e; r++) n.push(dg(t));
			return n;
		},
		ur,
	],
	dg = (t) => kge[127 - Bh(t)](t);
class hB extends Qx {
	constructor(e, n) {
		super(e), (this.reader = n), (this.s = null), (this.count = 0);
	}
	read() {
		return (
			this.count === 0 &&
				((this.s = this.reader(this)),
				pge(this) ? (this.count = nt(this) + 1) : (this.count = -1)),
			this.count--,
			this.s
		);
	}
}
class bb extends Qx {
	constructor(e) {
		super(e), (this.s = 0), (this.count = 0);
	}
	read() {
		if (this.count === 0) {
			this.s = cg(this);
			const e = zV(this.s);
			(this.count = 1),
				e && ((this.s = -this.s), (this.count = nt(this) + 2));
		}
		return this.count--, this.s;
	}
}
class Sk extends Qx {
	constructor(e) {
		super(e), (this.s = 0), (this.count = 0), (this.diff = 0);
	}
	read() {
		if (this.count === 0) {
			const e = cg(this),
				n = e & 1;
			(this.diff = ma(e / 2)),
				(this.count = 1),
				n && (this.count = nt(this) + 2);
		}
		return (this.s += this.diff), this.count--, this.s;
	}
}
class Cge {
	constructor(e) {
		(this.decoder = new bb(e)),
			(this.str = Es(this.decoder)),
			(this.spos = 0);
	}
	read() {
		const e = this.spos + this.decoder.read(),
			n = this.str.slice(this.spos, e);
		return (this.spos = e), n;
	}
}
const Hu = Date.now,
	hi = () => new Map(),
	Qw = (t) => {
		const e = hi();
		return (
			t.forEach((n, r) => {
				e.set(r, n);
			}),
			e
		);
	},
	Ms = (t, e, n) => {
		let r = t.get(e);
		return r === void 0 && t.set(e, (r = n())), r;
	},
	wge = (t, e) => {
		const n = [];
		for (const [r, i] of t) n.push(e(i, r));
		return n;
	},
	Ege = (t, e) => {
		for (const [n, r] of t) if (e(r, n)) return !0;
		return !1;
	};
class UV {
	constructor() {
		this._observers = hi();
	}
	on(e, n) {
		return Ms(this._observers, e, xl).add(n), n;
	}
	once(e, n) {
		const r = (...i) => {
			this.off(e, r), n(...i);
		};
		this.on(e, r);
	}
	off(e, n) {
		const r = this._observers.get(e);
		r !== void 0 &&
			(r.delete(n), r.size === 0 && this._observers.delete(e));
	}
	emit(e, n) {
		return kl((this._observers.get(e) || hi()).values()).forEach((r) =>
			r(...n),
		);
	}
	destroy() {
		this._observers = hi();
	}
}
class Dge {
	constructor() {
		this._observers = hi();
	}
	on(e, n) {
		Ms(this._observers, e, xl).add(n);
	}
	once(e, n) {
		const r = (...i) => {
			this.off(e, r), n(...i);
		};
		this.on(e, r);
	}
	off(e, n) {
		const r = this._observers.get(e);
		r !== void 0 &&
			(r.delete(n), r.size === 0 && this._observers.delete(e));
	}
	emit(e, n) {
		return kl((this._observers.get(e) || hi()).values()).forEach((r) =>
			r(...n),
		);
	}
	destroy() {
		this._observers = hi();
	}
}
const Sge = Object.assign,
	$S = Object.keys,
	Age = (t, e) => {
		for (const n in t) e(t[n], n);
	},
	pB = (t) => $S(t).length,
	mB = (t) => $S(t).length,
	$ge = (t) => {
		for (const e in t) return !1;
		return !0;
	},
	Tge = (t, e) => {
		for (const n in t) if (!e(t[n], n)) return !1;
		return !0;
	},
	HV = (t, e) => Object.prototype.hasOwnProperty.call(t, e),
	Bge = (t, e) =>
		t === e ||
		(mB(t) === mB(e) &&
			Tge(t, (n, r) => (n !== void 0 || HV(e, r)) && e[r] === n)),
	TS = (t, e, n = 0) => {
		try {
			for (; n < t.length; n++) t[n](...e);
		} finally {
			n < t.length && TS(t, e, n + 1);
		}
	},
	Ige = (t) => t,
	Fge = (t, e) => t === e,
	Em = (t, e) => {
		if (t == null || e == null) return Fge(t, e);
		if (t.constructor !== e.constructor) return !1;
		if (t === e) return !0;
		switch (t.constructor) {
			case ArrayBuffer:
				(t = new Uint8Array(t)), (e = new Uint8Array(e));
			case Uint8Array: {
				if (t.byteLength !== e.byteLength) return !1;
				for (let n = 0; n < t.length; n++) if (t[n] !== e[n]) return !1;
				break;
			}
			case Set: {
				if (t.size !== e.size) return !1;
				for (const n of t) if (!e.has(n)) return !1;
				break;
			}
			case Map: {
				if (t.size !== e.size) return !1;
				for (const n of t.keys())
					if (!e.has(n) || !Em(t.get(n), e.get(n))) return !1;
				break;
			}
			case Object:
				if (pB(t) !== pB(e)) return !1;
				for (const n in t) if (!HV(t, n) || !Em(t[n], e[n])) return !1;
				break;
			case Array:
				if (t.length !== e.length) return !1;
				for (let n = 0; n < t.length; n++)
					if (!Em(t[n], e[n])) return !1;
				break;
			default:
				return !1;
		}
		return !0;
	},
	Pge = (t, e) => e.includes(t),
	Nge = crypto.getRandomValues.bind(crypto),
	Rge = Math.random,
	WV = () => Nge(new Uint32Array(1))[0],
	Oge = (t) => t[ma(Rge() * t.length)],
	Mge = "10000000-1000-4000-8000" + -1e11,
	jge = () =>
		Mge.replace(/[018]/g, (t) =>
			(t ^ (WV() & (15 >> (t / 4)))).toString(16),
		),
	gB = (t) => new Promise(t);
Promise.all.bind(Promise);
const bB = (t) => (t === void 0 ? null : t);
class _ge {
	constructor() {
		this.map = new Map();
	}
	setItem(e, n) {
		this.map.set(e, n);
	}
	getItem(e) {
		return this.map.get(e);
	}
}
let qV = new _ge(),
	BS = !0;
try {
	typeof localStorage < "u" &&
		localStorage &&
		((qV = localStorage), (BS = !1));
} catch {}
const GV = qV,
	zge = (t) => BS || addEventListener("storage", t),
	Lge = (t) => BS || removeEventListener("storage", t);
var YV = {};
const Ih =
		typeof process < "u" &&
		process.release &&
		/node|io\.js/.test(process.release.name) &&
		Object.prototype.toString.call(typeof process < "u" ? process : 0) ===
			"[object process]",
	IS = typeof window < "u" && typeof document < "u" && !Ih;
let Ks;
const Vge = () => {
		if (Ks === void 0)
			if (Ih) {
				Ks = hi();
				const t = process.argv;
				let e = null;
				for (let n = 0; n < t.length; n++) {
					const r = t[n];
					r[0] === "-"
						? (e !== null && Ks.set(e, ""), (e = r))
						: e !== null && (Ks.set(e, r), (e = null));
				}
				e !== null && Ks.set(e, "");
			} else
				typeof location == "object"
					? ((Ks = hi()),
						(location.search || "?")
							.slice(1)
							.split("&")
							.forEach((t) => {
								if (t.length !== 0) {
									const [e, n] = t.split("=");
									Ks.set(`--${lB(e, "-")}`, n),
										Ks.set(`-${lB(e, "-")}`, n);
								}
							}))
					: (Ks = hi());
		return Ks;
	},
	e2 = (t) => Vge().has(t),
	t2 = (t) =>
		bB(Ih ? YV[t.toUpperCase().replaceAll("-", "_")] : GV.getItem(t)),
	JV = (t) => e2("--" + t) || t2(t) !== null;
JV("production");
const Kge = Ih && Pge(YV.FORCE_COLOR, ["true", "1", "2"]),
	Uge =
		Kge ||
		(!e2("--no-colors") &&
			!JV("no-color") &&
			(!Ih || process.stdout.isTTY) &&
			(!Ih ||
				e2("--color") ||
				t2("COLORTERM") !== null ||
				(t2("TERM") || "").includes("color"))),
	XV = (t) => new Uint8Array(t),
	Hge = (t, e, n) => new Uint8Array(t, e, n),
	Wge = (t) => new Uint8Array(t),
	qge = (t) => {
		let e = "";
		for (let n = 0; n < t.byteLength; n++) e += Jme(t[n]);
		return btoa(e);
	},
	Gge = (t) =>
		Buffer.from(t.buffer, t.byteOffset, t.byteLength).toString("base64"),
	Yge = (t) => {
		const e = atob(t),
			n = XV(e.length);
		for (let r = 0; r < e.length; r++) n[r] = e.charCodeAt(r);
		return n;
	},
	Jge = (t) => {
		const e = Buffer.from(t, "base64");
		return Hge(e.buffer, e.byteOffset, e.byteLength);
	},
	Xge = IS ? qge : Gge,
	Zge = IS ? Yge : Jge,
	Qge = (t) => {
		const e = XV(t.byteLength);
		return e.set(t), e;
	};
class e0e {
	constructor(e, n) {
		(this.left = e), (this.right = n);
	}
}
const La = (t, e) => new e0e(t, e),
	t0e = typeof document < "u" ? document : {};
typeof DOMParser < "u" && new DOMParser();
const n0e = (t) => wge(t, (e, n) => `${n}:${e};`).join(""),
	r0e = (t) =>
		class {
			constructor(n) {
				this._ = n;
			}
			destroy() {
				t(this._);
			}
		},
	i0e = r0e(clearTimeout),
	FS = (t, e) => new i0e(setTimeout(e, t)),
	Nl = Symbol,
	ZV = Nl(),
	QV = Nl(),
	o0e = Nl(),
	s0e = Nl(),
	a0e = Nl(),
	eK = Nl(),
	l0e = Nl(),
	PS = Nl(),
	u0e = Nl(),
	c0e = (t) => {
		var i;
		t.length === 1 &&
			((i = t[0]) == null ? void 0 : i.constructor) === Function &&
			(t = t[0]());
		const e = [],
			n = [];
		let r = 0;
		for (; r < t.length; r++) {
			const o = t[r];
			if (o === void 0) break;
			if (o.constructor === String || o.constructor === Number) e.push(o);
			else if (o.constructor === Object) break;
		}
		for (r > 0 && n.push(e.join("")); r < t.length; r++) {
			const o = t[r];
			o instanceof Symbol || n.push(o);
		}
		return n;
	},
	d0e = {
		[ZV]: La("font-weight", "bold"),
		[QV]: La("font-weight", "normal"),
		[o0e]: La("color", "blue"),
		[a0e]: La("color", "green"),
		[s0e]: La("color", "grey"),
		[eK]: La("color", "red"),
		[l0e]: La("color", "purple"),
		[PS]: La("color", "orange"),
		[u0e]: La("color", "black"),
	},
	f0e = (t) => {
		var s;
		t.length === 1 &&
			((s = t[0]) == null ? void 0 : s.constructor) === Function &&
			(t = t[0]());
		const e = [],
			n = [],
			r = hi();
		let i = [],
			o = 0;
		for (; o < t.length; o++) {
			const a = t[o],
				l = d0e[a];
			if (l !== void 0) r.set(l.left, l.right);
			else {
				if (a === void 0) break;
				if (a.constructor === String || a.constructor === Number) {
					const u = n0e(r);
					o > 0 || u.length > 0
						? (e.push("%c" + a), n.push(u))
						: e.push(a);
				} else break;
			}
		}
		for (o > 0 && ((i = n), i.unshift(e.join(""))); o < t.length; o++) {
			const a = t[o];
			a instanceof Symbol || i.push(a);
		}
		return i;
	},
	tK = Uge ? f0e : c0e,
	h0e = (...t) => {
		console.log(...tK(t)), nK.forEach((e) => e.print(t));
	},
	p0e = (...t) => {
		console.warn(...tK(t)), t.unshift(PS), nK.forEach((e) => e.print(t));
	},
	nK = xl(),
	rK = (t) => ({
		[Symbol.iterator]() {
			return this;
		},
		next: t,
	}),
	m0e = (t, e) =>
		rK(() => {
			let n;
			do n = t.next();
			while (!n.done && !e(n.value));
			return n;
		}),
	Ak = (t, e) =>
		rK(() => {
			const { done: n, value: r } = t.next();
			return { done: n, value: n ? void 0 : e(r) };
		});
class NS {
	constructor(e, n) {
		(this.clock = e), (this.len = n);
	}
}
class rp {
	constructor() {
		this.clients = new Map();
	}
}
const Wu = (t, e, n) =>
		e.clients.forEach((r, i) => {
			const o = t.doc.store.clients.get(i);
			for (let s = 0; s < r.length; s++) {
				const a = r[s];
				mK(t, o, a.clock, a.len, n);
			}
		}),
	g0e = (t, e) => {
		let n = 0,
			r = t.length - 1;
		for (; n <= r; ) {
			const i = ma((n + r) / 2),
				o = t[i],
				s = o.clock;
			if (s <= e) {
				if (e < s + o.len) return i;
				n = i + 1;
			} else r = i - 1;
		}
		return null;
	},
	ip = (t, e) => {
		const n = t.clients.get(e.client);
		return n !== void 0 && g0e(n, e.clock) !== null;
	},
	RS = (t) => {
		t.clients.forEach((e) => {
			e.sort((i, o) => i.clock - o.clock);
			let n, r;
			for (n = 1, r = 1; n < e.length; n++) {
				const i = e[r - 1],
					o = e[n];
				i.clock + i.len >= o.clock
					? (i.len = yl(i.len, o.clock + o.len - i.clock))
					: (r < n && (e[r] = o), r++);
			}
			e.length = r;
		});
	},
	n2 = (t) => {
		const e = new rp();
		for (let n = 0; n < t.length; n++)
			t[n].clients.forEach((r, i) => {
				if (!e.clients.has(i)) {
					const o = r.slice();
					for (let s = n + 1; s < t.length; s++)
						Gme(o, t[s].clients.get(i) || []);
					e.clients.set(i, o);
				}
			});
		return RS(e), e;
	},
	fg = (t, e, n, r) => {
		Ms(t.clients, e, () => []).push(new NS(n, r));
	},
	iK = () => new rp(),
	oK = (t) => {
		const e = iK();
		return (
			t.clients.forEach((n, r) => {
				const i = [];
				for (let o = 0; o < n.length; o++) {
					const s = n[o];
					if (s.deleted) {
						const a = s.id.clock;
						let l = s.length;
						if (o + 1 < n.length)
							for (
								let u = n[o + 1];
								o + 1 < n.length && u.deleted;
								u = n[++o + 1]
							)
								l += u.length;
						i.push(new NS(a, l));
					}
				}
				i.length > 0 && e.clients.set(r, i);
			}),
			e
		);
	},
	op = (t, e) => {
		Oe(t.restEncoder, e.clients.size),
			kl(e.clients.entries())
				.sort((n, r) => r[0] - n[0])
				.forEach(([n, r]) => {
					t.resetDsCurVal(), Oe(t.restEncoder, n);
					const i = r.length;
					Oe(t.restEncoder, i);
					for (let o = 0; o < i; o++) {
						const s = r[o];
						t.writeDsClock(s.clock), t.writeDsLen(s.len);
					}
				});
	},
	OS = (t) => {
		const e = new rp(),
			n = nt(t.restDecoder);
		for (let r = 0; r < n; r++) {
			t.resetDsCurVal();
			const i = nt(t.restDecoder),
				o = nt(t.restDecoder);
			if (o > 0) {
				const s = Ms(e.clients, i, () => []);
				for (let a = 0; a < o; a++)
					s.push(new NS(t.readDsClock(), t.readDsLen()));
			}
		}
		return e;
	},
	vB = (t, e, n) => {
		const r = new rp(),
			i = nt(t.restDecoder);
		for (let o = 0; o < i; o++) {
			t.resetDsCurVal();
			const s = nt(t.restDecoder),
				a = nt(t.restDecoder),
				l = n.clients.get(s) || [],
				u = Nn(n, s);
			for (let c = 0; c < a; c++) {
				const d = t.readDsClock(),
					f = d + t.readDsLen();
				if (d < u) {
					u < f && fg(r, s, u, f - u);
					let h = ga(l, d),
						p = l[h];
					for (
						!p.deleted &&
						p.id.clock < d &&
						(l.splice(h + 1, 0, ty(e, p, d - p.id.clock)), h++);
						h < l.length && ((p = l[h++]), p.id.clock < f);

					)
						p.deleted ||
							(f < p.id.clock + p.length &&
								l.splice(h, 0, ty(e, p, f - p.id.clock)),
							p.delete(e));
				} else fg(r, s, d, f - d);
			}
		}
		if (r.clients.size > 0) {
			const o = new Dd();
			return Oe(o.restEncoder, 0), op(o, r), o.toUint8Array();
		}
		return null;
	},
	sK = WV;
class Ki extends UV {
	constructor({
		guid: e = jge(),
		collectionid: n = null,
		gc: r = !0,
		gcFilter: i = () => !0,
		meta: o = null,
		autoLoad: s = !1,
		shouldLoad: a = !0,
	} = {}) {
		super(),
			(this.gc = r),
			(this.gcFilter = i),
			(this.clientID = sK()),
			(this.guid = e),
			(this.collectionid = n),
			(this.share = new Map()),
			(this.store = new hK()),
			(this._transaction = null),
			(this._transactionCleanups = []),
			(this.subdocs = new Set()),
			(this._item = null),
			(this.shouldLoad = a),
			(this.autoLoad = s),
			(this.meta = o),
			(this.isLoaded = !1),
			(this.isSynced = !1),
			(this.isDestroyed = !1),
			(this.whenLoaded = gB((u) => {
				this.on("load", () => {
					(this.isLoaded = !0), u(this);
				});
			}));
		const l = () =>
			gB((u) => {
				const c = (d) => {
					(d === void 0 || d === !0) && (this.off("sync", c), u());
				};
				this.on("sync", c);
			});
		this.on("sync", (u) => {
			u === !1 && this.isSynced && (this.whenSynced = l()),
				(this.isSynced = u === void 0 || u === !0),
				this.isSynced && !this.isLoaded && this.emit("load", [this]);
		}),
			(this.whenSynced = l());
	}
	load() {
		const e = this._item;
		e !== null &&
			!this.shouldLoad &&
			Gt(
				e.parent.doc,
				(n) => {
					n.subdocsLoaded.add(this);
				},
				null,
				!0,
			),
			(this.shouldLoad = !0);
	}
	getSubdocs() {
		return this.subdocs;
	}
	getSubdocGuids() {
		return new Set(kl(this.subdocs).map((e) => e.guid));
	}
	transact(e, n = null) {
		return Gt(this, e, n);
	}
	get(e, n = ir) {
		const r = Ms(this.share, e, () => {
				const o = new n();
				return o._integrate(this, null), o;
			}),
			i = r.constructor;
		if (n !== ir && i !== n)
			if (i === ir) {
				const o = new n();
				(o._map = r._map),
					r._map.forEach((s) => {
						for (; s !== null; s = s.left) s.parent = o;
					}),
					(o._start = r._start);
				for (let s = o._start; s !== null; s = s.right) s.parent = o;
				return (
					(o._length = r._length),
					this.share.set(e, o),
					o._integrate(this, null),
					o
				);
			} else
				throw new Error(
					`Type with the name ${e} has already been defined with a different constructor`,
				);
		return r;
	}
	getArray(e = "") {
		return this.get(e, Au);
	}
	getText(e = "") {
		return this.get(e, qu);
	}
	getMap(e = "") {
		return this.get(e, ba);
	}
	getXmlElement(e = "") {
		return this.get(e, ci);
	}
	getXmlFragment(e = "") {
		return this.get(e, Gu);
	}
	toJSON() {
		const e = {};
		return (
			this.share.forEach((n, r) => {
				e[r] = n.toJSON();
			}),
			e
		);
	}
	destroy() {
		(this.isDestroyed = !0), kl(this.subdocs).forEach((n) => n.destroy());
		const e = this._item;
		if (e !== null) {
			this._item = null;
			const n = e.content;
			(n.doc = new Ki({ guid: this.guid, ...n.opts, shouldLoad: !1 })),
				(n.doc._item = e),
				Gt(
					e.parent.doc,
					(r) => {
						const i = n.doc;
						e.deleted || r.subdocsAdded.add(i),
							r.subdocsRemoved.add(this);
					},
					null,
					!0,
				);
		}
		this.emit("destroyed", [!0]),
			this.emit("destroy", [this]),
			super.destroy();
	}
}
class aK {
	constructor(e) {
		this.restDecoder = e;
	}
	resetDsCurVal() {}
	readDsClock() {
		return nt(this.restDecoder);
	}
	readDsLen() {
		return nt(this.restDecoder);
	}
}
class e3 extends aK {
	readLeftID() {
		return gt(nt(this.restDecoder), nt(this.restDecoder));
	}
	readRightID() {
		return gt(nt(this.restDecoder), nt(this.restDecoder));
	}
	readClient() {
		return nt(this.restDecoder);
	}
	readInfo() {
		return Bh(this.restDecoder);
	}
	readString() {
		return Es(this.restDecoder);
	}
	readParentInfo() {
		return nt(this.restDecoder) === 1;
	}
	readTypeRef() {
		return nt(this.restDecoder);
	}
	readLen() {
		return nt(this.restDecoder);
	}
	readAny() {
		return dg(this.restDecoder);
	}
	readBuf() {
		return Qge(ur(this.restDecoder));
	}
	readJSON() {
		return JSON.parse(Es(this.restDecoder));
	}
	readKey() {
		return Es(this.restDecoder);
	}
}
class b0e {
	constructor(e) {
		(this.dsCurrVal = 0), (this.restDecoder = e);
	}
	resetDsCurVal() {
		this.dsCurrVal = 0;
	}
	readDsClock() {
		return (this.dsCurrVal += nt(this.restDecoder)), this.dsCurrVal;
	}
	readDsLen() {
		const e = nt(this.restDecoder) + 1;
		return (this.dsCurrVal += e), e;
	}
}
class Ed extends b0e {
	constructor(e) {
		super(e),
			(this.keys = []),
			nt(e),
			(this.keyClockDecoder = new Sk(ur(e))),
			(this.clientDecoder = new bb(ur(e))),
			(this.leftClockDecoder = new Sk(ur(e))),
			(this.rightClockDecoder = new Sk(ur(e))),
			(this.infoDecoder = new hB(ur(e), Bh)),
			(this.stringDecoder = new Cge(ur(e))),
			(this.parentInfoDecoder = new hB(ur(e), Bh)),
			(this.typeRefDecoder = new bb(ur(e))),
			(this.lenDecoder = new bb(ur(e)));
	}
	readLeftID() {
		return new sh(this.clientDecoder.read(), this.leftClockDecoder.read());
	}
	readRightID() {
		return new sh(this.clientDecoder.read(), this.rightClockDecoder.read());
	}
	readClient() {
		return this.clientDecoder.read();
	}
	readInfo() {
		return this.infoDecoder.read();
	}
	readString() {
		return this.stringDecoder.read();
	}
	readParentInfo() {
		return this.parentInfoDecoder.read() === 1;
	}
	readTypeRef() {
		return this.typeRefDecoder.read();
	}
	readLen() {
		return this.lenDecoder.read();
	}
	readAny() {
		return dg(this.restDecoder);
	}
	readBuf() {
		return ur(this.restDecoder);
	}
	readJSON() {
		return dg(this.restDecoder);
	}
	readKey() {
		const e = this.keyClockDecoder.read();
		if (e < this.keys.length) return this.keys[e];
		{
			const n = this.stringDecoder.read();
			return this.keys.push(n), n;
		}
	}
}
class MS {
	constructor() {
		this.restEncoder = In();
	}
	toUint8Array() {
		return Kt(this.restEncoder);
	}
	resetDsCurVal() {}
	writeDsClock(e) {
		Oe(this.restEncoder, e);
	}
	writeDsLen(e) {
		Oe(this.restEncoder, e);
	}
}
class sp extends MS {
	writeLeftID(e) {
		Oe(this.restEncoder, e.client), Oe(this.restEncoder, e.clock);
	}
	writeRightID(e) {
		Oe(this.restEncoder, e.client), Oe(this.restEncoder, e.clock);
	}
	writeClient(e) {
		Oe(this.restEncoder, e);
	}
	writeInfo(e) {
		Xw(this.restEncoder, e);
	}
	writeString(e) {
		aa(this.restEncoder, e);
	}
	writeParentInfo(e) {
		Oe(this.restEncoder, e ? 1 : 0);
	}
	writeTypeRef(e) {
		Oe(this.restEncoder, e);
	}
	writeLen(e) {
		Oe(this.restEncoder, e);
	}
	writeAny(e) {
		ug(this.restEncoder, e);
	}
	writeBuf(e) {
		Fn(this.restEncoder, e);
	}
	writeJSON(e) {
		aa(this.restEncoder, JSON.stringify(e));
	}
	writeKey(e) {
		aa(this.restEncoder, e);
	}
}
class jS {
	constructor() {
		(this.restEncoder = In()), (this.dsCurrVal = 0);
	}
	toUint8Array() {
		return Kt(this.restEncoder);
	}
	resetDsCurVal() {
		this.dsCurrVal = 0;
	}
	writeDsClock(e) {
		const n = e - this.dsCurrVal;
		(this.dsCurrVal = e), Oe(this.restEncoder, n);
	}
	writeDsLen(e) {
		e === 0 && go(), Oe(this.restEncoder, e - 1), (this.dsCurrVal += e);
	}
}
class Dd extends jS {
	constructor() {
		super(),
			(this.keyMap = new Map()),
			(this.keyClock = 0),
			(this.keyClockEncoder = new Dk()),
			(this.clientEncoder = new gb()),
			(this.leftClockEncoder = new Dk()),
			(this.rightClockEncoder = new Dk()),
			(this.infoEncoder = new cB(Xw)),
			(this.stringEncoder = new hge()),
			(this.parentInfoEncoder = new cB(Xw)),
			(this.typeRefEncoder = new gb()),
			(this.lenEncoder = new gb());
	}
	toUint8Array() {
		const e = In();
		return (
			Oe(e, 0),
			Fn(e, this.keyClockEncoder.toUint8Array()),
			Fn(e, this.clientEncoder.toUint8Array()),
			Fn(e, this.leftClockEncoder.toUint8Array()),
			Fn(e, this.rightClockEncoder.toUint8Array()),
			Fn(e, Kt(this.infoEncoder)),
			Fn(e, this.stringEncoder.toUint8Array()),
			Fn(e, Kt(this.parentInfoEncoder)),
			Fn(e, this.typeRefEncoder.toUint8Array()),
			Fn(e, this.lenEncoder.toUint8Array()),
			$0(e, Kt(this.restEncoder)),
			Kt(e)
		);
	}
	writeLeftID(e) {
		this.clientEncoder.write(e.client),
			this.leftClockEncoder.write(e.clock);
	}
	writeRightID(e) {
		this.clientEncoder.write(e.client),
			this.rightClockEncoder.write(e.clock);
	}
	writeClient(e) {
		this.clientEncoder.write(e);
	}
	writeInfo(e) {
		this.infoEncoder.write(e);
	}
	writeString(e) {
		this.stringEncoder.write(e);
	}
	writeParentInfo(e) {
		this.parentInfoEncoder.write(e ? 1 : 0);
	}
	writeTypeRef(e) {
		this.typeRefEncoder.write(e);
	}
	writeLen(e) {
		this.lenEncoder.write(e);
	}
	writeAny(e) {
		ug(this.restEncoder, e);
	}
	writeBuf(e) {
		Fn(this.restEncoder, e);
	}
	writeJSON(e) {
		ug(this.restEncoder, e);
	}
	writeKey(e) {
		const n = this.keyMap.get(e);
		n === void 0
			? (this.keyClockEncoder.write(this.keyClock++),
				this.stringEncoder.write(e))
			: this.keyClockEncoder.write(n);
	}
}
const v0e = (t, e, n, r) => {
		r = yl(r, e[0].id.clock);
		const i = ga(e, r);
		Oe(t.restEncoder, e.length - i), t.writeClient(n), Oe(t.restEncoder, r);
		const o = e[i];
		o.write(t, r - o.id.clock);
		for (let s = i + 1; s < e.length; s++) e[s].write(t, 0);
	},
	_S = (t, e, n) => {
		const r = new Map();
		n.forEach((i, o) => {
			Nn(e, o) > i && r.set(o, i);
		}),
			T0(e).forEach((i, o) => {
				n.has(o) || r.set(o, 0);
			}),
			Oe(t.restEncoder, r.size),
			kl(r.entries())
				.sort((i, o) => o[0] - i[0])
				.forEach(([i, o]) => {
					v0e(t, e.clients.get(i), i, o);
				});
	},
	y0e = (t, e) => {
		const n = hi(),
			r = nt(t.restDecoder);
		for (let i = 0; i < r; i++) {
			const o = nt(t.restDecoder),
				s = new Array(o),
				a = t.readClient();
			let l = nt(t.restDecoder);
			n.set(a, { i: 0, refs: s });
			for (let u = 0; u < o; u++) {
				const c = t.readInfo();
				switch (Zx & c) {
					case 0: {
						const d = t.readLen();
						(s[u] = new Ro(gt(a, l), d)), (l += d);
						break;
					}
					case 10: {
						const d = nt(t.restDecoder);
						(s[u] = new no(gt(a, l), d)), (l += d);
						break;
					}
					default: {
						const d = (c & (ol | ao)) === 0,
							f = new Qt(
								gt(a, l),
								null,
								(c & ao) === ao ? t.readLeftID() : null,
								null,
								(c & ol) === ol ? t.readRightID() : null,
								d
									? t.readParentInfo()
										? e.get(t.readString())
										: t.readLeftID()
									: null,
								d && (c & ag) === ag ? t.readString() : null,
								jK(t, c),
							);
						(s[u] = f), (l += f.length);
					}
				}
			}
		}
		return n;
	},
	x0e = (t, e, n) => {
		const r = [];
		let i = kl(n.keys()).sort((h, p) => h - p);
		if (i.length === 0) return null;
		const o = () => {
			if (i.length === 0) return null;
			let h = n.get(i[i.length - 1]);
			for (; h.refs.length === h.i; )
				if ((i.pop(), i.length > 0)) h = n.get(i[i.length - 1]);
				else return null;
			return h;
		};
		let s = o();
		if (s === null) return null;
		const a = new hK(),
			l = new Map(),
			u = (h, p) => {
				const g = l.get(h);
				(g == null || g > p) && l.set(h, p);
			};
		let c = s.refs[s.i++];
		const d = new Map(),
			f = () => {
				for (const h of r) {
					const p = h.id.client,
						g = n.get(p);
					g
						? (g.i--,
							a.clients.set(p, g.refs.slice(g.i)),
							n.delete(p),
							(g.i = 0),
							(g.refs = []))
						: a.clients.set(p, [h]),
						(i = i.filter((v) => v !== p));
				}
				r.length = 0;
			};
		for (;;) {
			if (c.constructor !== no) {
				const p =
					Ms(d, c.id.client, () => Nn(e, c.id.client)) - c.id.clock;
				if (p < 0) r.push(c), u(c.id.client, c.id.clock - 1), f();
				else {
					const g = c.getMissing(t, e);
					if (g !== null) {
						r.push(c);
						const v = n.get(g) || { refs: [], i: 0 };
						if (v.refs.length === v.i) u(g, Nn(e, g)), f();
						else {
							c = v.refs[v.i++];
							continue;
						}
					} else
						(p === 0 || p < c.length) &&
							(c.integrate(t, p),
							d.set(c.id.client, c.id.clock + c.length));
				}
			}
			if (r.length > 0) c = r.pop();
			else if (s !== null && s.i < s.refs.length) c = s.refs[s.i++];
			else {
				if (((s = o()), s === null)) break;
				c = s.refs[s.i++];
			}
		}
		if (a.clients.size > 0) {
			const h = new Dd();
			return (
				_S(h, a, new Map()),
				Oe(h.restEncoder, 0),
				{ missing: l, update: h.toUint8Array() }
			);
		}
		return null;
	},
	k0e = (t, e) => _S(t, e.doc.store, e.beforeState),
	C0e = (t, e, n, r = new Ed(t)) =>
		Gt(
			e,
			(i) => {
				i.local = !1;
				let o = !1;
				const s = i.doc,
					a = s.store,
					l = y0e(r, s),
					u = x0e(i, a, l),
					c = a.pendingStructs;
				if (c) {
					for (const [f, h] of c.missing)
						if (h < Nn(a, f)) {
							o = !0;
							break;
						}
					if (u) {
						for (const [f, h] of u.missing) {
							const p = c.missing.get(f);
							(p == null || p > h) && c.missing.set(f, h);
						}
						c.update = Jv([c.update, u.update]);
					}
				} else a.pendingStructs = u;
				const d = vB(r, i, a);
				if (a.pendingDs) {
					const f = new Ed(Vi(a.pendingDs));
					nt(f.restDecoder);
					const h = vB(f, i, a);
					d && h
						? (a.pendingDs = Jv([d, h]))
						: (a.pendingDs = d || h);
				} else a.pendingDs = d;
				if (o) {
					const f = a.pendingStructs.update;
					(a.pendingStructs = null), Gv(i.doc, f);
				}
			},
			n,
			!1,
		),
	Gv = (t, e, n, r = Ed) => {
		const i = Vi(e);
		C0e(i, t, n, new r(i));
	},
	Ec = (t, e, n) => Gv(t, e, n, e3),
	w0e = (t, e, n = new Map()) => {
		_S(t, e.store, n), op(t, oK(e.store));
	},
	E0e = (t, e = new Uint8Array([0]), n = new Dd()) => {
		const r = lK(e);
		w0e(n, t, r);
		const i = [n.toUint8Array()];
		if (
			(t.store.pendingDs && i.push(t.store.pendingDs),
			t.store.pendingStructs &&
				i.push(vK(t.store.pendingStructs.update, e)),
			i.length > 1)
		) {
			if (n.constructor === sp)
				return _0e(i.map((o, s) => (s === 0 ? o : H0e(o))));
			if (n.constructor === Dd) return Jv(i);
		}
		return i[0];
	},
	Yv = (t, e) => E0e(t, e, new sp()),
	D0e = (t) => {
		const e = new Map(),
			n = nt(t.restDecoder);
		for (let r = 0; r < n; r++) {
			const i = nt(t.restDecoder),
				o = nt(t.restDecoder);
			e.set(i, o);
		}
		return e;
	},
	lK = (t) => D0e(new aK(Vi(t))),
	uK = (t, e) => (
		Oe(t.restEncoder, e.size),
		kl(e.entries())
			.sort((n, r) => r[0] - n[0])
			.forEach(([n, r]) => {
				Oe(t.restEncoder, n), Oe(t.restEncoder, r);
			}),
		t
	),
	S0e = (t, e) => uK(t, T0(e.store)),
	A0e = (t, e = new jS()) => (
		t instanceof Map ? uK(e, t) : S0e(e, t), e.toUint8Array()
	),
	cK = (t) => A0e(t, new MS());
class $0e {
	constructor() {
		this.l = [];
	}
}
const yB = () => new $0e(),
	xB = (t, e) => t.l.push(e),
	kB = (t, e) => {
		const n = t.l,
			r = n.length;
		(t.l = n.filter((i) => e !== i)),
			r === t.l.length &&
				console.error(
					"[yjs] Tried to remove event handler that doesn't exist.",
				);
	},
	dK = (t, e, n) => TS(t.l, [e, n]);
class sh {
	constructor(e, n) {
		(this.client = e), (this.clock = n);
	}
}
const Lf = (t, e) =>
		t === e ||
		(t !== null &&
			e !== null &&
			t.client === e.client &&
			t.clock === e.clock),
	gt = (t, e) => new sh(t, e),
	hg = (t) => {
		for (const [e, n] of t.doc.share.entries()) if (n === t) return e;
		throw go();
	},
	pg = (t, e) => {
		for (; e !== null; ) {
			if (e.parent === t) return !0;
			e = e.parent._item;
		}
		return !1;
	};
class mg {
	constructor(e, n, r, i = 0) {
		(this.type = e), (this.tname = n), (this.item = r), (this.assoc = i);
	}
}
const Dm = (t) =>
	new mg(
		t.type == null ? null : gt(t.type.client, t.type.clock),
		t.tname ?? null,
		t.item == null ? null : gt(t.item.client, t.item.clock),
		t.assoc == null ? 0 : t.assoc,
	);
class T0e {
	constructor(e, n, r = 0) {
		(this.type = e), (this.index = n), (this.assoc = r);
	}
}
const B0e = (t, e, n = 0) => new T0e(t, e, n),
	N1 = (t, e, n) => {
		let r = null,
			i = null;
		return (
			t._item === null
				? (i = hg(t))
				: (r = gt(t._item.id.client, t._item.id.clock)),
			new mg(r, i, e, n)
		);
	},
	$k = (t, e, n = 0) => {
		let r = t._start;
		if (n < 0) {
			if (e === 0) return N1(t, null, n);
			e--;
		}
		for (; r !== null; ) {
			if (!r.deleted && r.countable) {
				if (r.length > e)
					return N1(t, gt(r.id.client, r.id.clock + e), n);
				e -= r.length;
			}
			if (r.right === null && n < 0) return N1(t, r.lastId, n);
			r = r.right;
		}
		return N1(t, null, n);
	},
	I0e = (t, e, n = !0) => {
		const r = e.store,
			i = t.item,
			o = t.type,
			s = t.tname,
			a = t.assoc;
		let l = null,
			u = 0;
		if (i !== null) {
			if (Nn(r, i.client) <= i.clock) return null;
			const c = n ? s2(r, i) : { item: ah(r, i), diff: 0 },
				d = c.item;
			if (!(d instanceof Qt)) return null;
			if (((l = d.parent), l._item === null || !l._item.deleted)) {
				u = d.deleted || !d.countable ? 0 : c.diff + (a >= 0 ? 0 : 1);
				let f = d.left;
				for (; f !== null; )
					!f.deleted && f.countable && (u += f.length), (f = f.left);
			}
		} else {
			if (s !== null) l = e.get(s);
			else if (o !== null) {
				if (Nn(r, o.client) <= o.clock) return null;
				const { item: c } = n ? s2(r, o) : { item: ah(r, o) };
				if (c instanceof Qt && c.content instanceof js)
					l = c.content.type;
				else return null;
			} else throw go();
			a >= 0 ? (u = l._length) : (u = 0);
		}
		return B0e(l, u, t.assoc);
	},
	CB = (t, e) =>
		t === e ||
		(t !== null &&
			e !== null &&
			t.tname === e.tname &&
			Lf(t.item, e.item) &&
			Lf(t.type, e.type) &&
			t.assoc === e.assoc);
class zS {
	constructor(e, n) {
		(this.ds = e), (this.sv = n);
	}
}
const fK = (t, e) => new zS(t, e),
	Tk = (t) => fK(oK(t.store), T0(t.store)),
	Dc = (t, e) =>
		e === void 0
			? !t.deleted
			: e.sv.has(t.id.client) &&
				(e.sv.get(t.id.client) || 0) > t.id.clock &&
				!ip(e.ds, t.id),
	r2 = (t, e) => {
		const n = Ms(t.meta, r2, xl),
			r = t.doc.store;
		n.has(e) ||
			(e.sv.forEach((i, o) => {
				i < Nn(r, o) && Fi(t, gt(o, i));
			}),
			Wu(t, e.ds, (i) => {}),
			n.add(e));
	};
class hK {
	constructor() {
		(this.clients = new Map()),
			(this.pendingStructs = null),
			(this.pendingDs = null);
	}
}
const T0 = (t) => {
		const e = new Map();
		return (
			t.clients.forEach((n, r) => {
				const i = n[n.length - 1];
				e.set(r, i.id.clock + i.length);
			}),
			e
		);
	},
	Nn = (t, e) => {
		const n = t.clients.get(e);
		if (n === void 0) return 0;
		const r = n[n.length - 1];
		return r.id.clock + r.length;
	},
	pK = (t, e) => {
		let n = t.clients.get(e.id.client);
		if (n === void 0) (n = []), t.clients.set(e.id.client, n);
		else {
			const r = n[n.length - 1];
			if (r.id.clock + r.length !== e.id.clock) throw go();
		}
		n.push(e);
	},
	ga = (t, e) => {
		let n = 0,
			r = t.length - 1,
			i = t[r],
			o = i.id.clock;
		if (o === e) return r;
		let s = ma((e / (o + i.length - 1)) * r);
		for (; n <= r; ) {
			if (((i = t[s]), (o = i.id.clock), o <= e)) {
				if (e < o + i.length) return s;
				n = s + 1;
			} else r = s - 1;
			s = ma((n + r) / 2);
		}
		throw go();
	},
	F0e = (t, e) => {
		const n = t.clients.get(e.client);
		return n[ga(n, e.clock)];
	},
	ah = F0e,
	i2 = (t, e, n) => {
		const r = ga(e, n),
			i = e[r];
		return i.id.clock < n && i instanceof Qt
			? (e.splice(r + 1, 0, ty(t, i, n - i.id.clock)), r + 1)
			: r;
	},
	Fi = (t, e) => {
		const n = t.doc.store.clients.get(e.client);
		return n[i2(t, n, e.clock)];
	},
	wB = (t, e, n) => {
		const r = e.clients.get(n.client),
			i = ga(r, n.clock),
			o = r[i];
		return (
			n.clock !== o.id.clock + o.length - 1 &&
				o.constructor !== Ro &&
				r.splice(i + 1, 0, ty(t, o, n.clock - o.id.clock + 1)),
			o
		);
	},
	P0e = (t, e, n) => {
		const r = t.clients.get(e.id.client);
		r[ga(r, e.id.clock)] = n;
	},
	mK = (t, e, n, r, i) => {
		if (r === 0) return;
		const o = n + r;
		let s = i2(t, e, n),
			a;
		do (a = e[s++]), o < a.id.clock + a.length && i2(t, e, o), i(a);
		while (s < e.length && e[s].id.clock < o);
	};
class N0e {
	constructor(e, n, r) {
		(this.doc = e),
			(this.deleteSet = new rp()),
			(this.beforeState = T0(e.store)),
			(this.afterState = new Map()),
			(this.changed = new Map()),
			(this.changedParentTypes = new Map()),
			(this._mergeStructs = []),
			(this.origin = n),
			(this.meta = new Map()),
			(this.local = r),
			(this.subdocsAdded = new Set()),
			(this.subdocsRemoved = new Set()),
			(this.subdocsLoaded = new Set()),
			(this._needFormattingCleanup = !1);
	}
}
const EB = (t, e) =>
		e.deleteSet.clients.size === 0 &&
		!Ege(e.afterState, (n, r) => e.beforeState.get(r) !== n)
			? !1
			: (RS(e.deleteSet), k0e(t, e), op(t, e.deleteSet), !0),
	DB = (t, e, n) => {
		const r = e._item;
		(r === null ||
			(r.id.clock < (t.beforeState.get(r.id.client) || 0) &&
				!r.deleted)) &&
			Ms(t.changed, e, xl).add(n);
	},
	vb = (t, e) => {
		let n = t[e],
			r = t[e - 1],
			i = e;
		for (; i > 0; n = r, r = t[--i - 1]) {
			if (
				r.deleted === n.deleted &&
				r.constructor === n.constructor &&
				r.mergeWith(n)
			) {
				n instanceof Qt &&
					n.parentSub !== null &&
					n.parent._map.get(n.parentSub) === n &&
					n.parent._map.set(n.parentSub, r);
				continue;
			}
			break;
		}
		const o = e - i;
		return o && t.splice(e + 1 - o, o), o;
	},
	R0e = (t, e, n) => {
		for (const [r, i] of t.clients.entries()) {
			const o = e.clients.get(r);
			for (let s = i.length - 1; s >= 0; s--) {
				const a = i[s],
					l = a.clock + a.len;
				for (
					let u = ga(o, a.clock), c = o[u];
					u < o.length && c.id.clock < l;
					c = o[++u]
				) {
					const d = o[u];
					if (a.clock + a.len <= d.id.clock) break;
					d instanceof Qt &&
						d.deleted &&
						!d.keep &&
						n(d) &&
						d.gc(e, !1);
				}
			}
		}
	},
	O0e = (t, e) => {
		t.clients.forEach((n, r) => {
			const i = e.clients.get(r);
			for (let o = n.length - 1; o >= 0; o--) {
				const s = n[o],
					a = Su(i.length - 1, 1 + ga(i, s.clock + s.len - 1));
				for (
					let l = a, u = i[l];
					l > 0 && u.id.clock >= s.clock;
					u = i[l]
				)
					l -= 1 + vb(i, l);
			}
		});
	},
	gK = (t, e) => {
		if (e < t.length) {
			const n = t[e],
				r = n.doc,
				i = r.store,
				o = n.deleteSet,
				s = n._mergeStructs;
			try {
				RS(o),
					(n.afterState = T0(n.doc.store)),
					r.emit("beforeObserverCalls", [n, r]);
				const a = [];
				n.changed.forEach((l, u) =>
					a.push(() => {
						(u._item === null || !u._item.deleted) &&
							u._callObserver(n, l);
					}),
				),
					a.push(() => {
						n.changedParentTypes.forEach((l, u) => {
							u._dEH.l.length > 0 &&
								(u._item === null || !u._item.deleted) &&
								((l = l.filter(
									(c) =>
										c.target._item === null ||
										!c.target._item.deleted,
								)),
								l.forEach((c) => {
									(c.currentTarget = u), (c._path = null);
								}),
								l.sort((c, d) => c.path.length - d.path.length),
								dK(u._dEH, l, n));
						});
					}),
					a.push(() => r.emit("afterTransaction", [n, r])),
					TS(a, []),
					n._needFormattingCleanup && o1e(n);
			} finally {
				r.gc && R0e(o, i, r.gcFilter),
					O0e(o, i),
					n.afterState.forEach((c, d) => {
						const f = n.beforeState.get(d) || 0;
						if (f !== c) {
							const h = i.clients.get(d),
								p = yl(ga(h, f), 1);
							for (let g = h.length - 1; g >= p; )
								g -= 1 + vb(h, g);
						}
					});
				for (let c = s.length - 1; c >= 0; c--) {
					const { client: d, clock: f } = s[c].id,
						h = i.clients.get(d),
						p = ga(h, f);
					(p + 1 < h.length && vb(h, p + 1) > 1) ||
						(p > 0 && vb(h, p));
				}
				if (
					(!n.local &&
						n.afterState.get(r.clientID) !==
							n.beforeState.get(r.clientID) &&
						(h0e(
							PS,
							ZV,
							"[yjs] ",
							QV,
							eK,
							"Changed the client-id because another client seems to be using it.",
						),
						(r.clientID = sK())),
					r.emit("afterTransactionCleanup", [n, r]),
					r._observers.has("update"))
				) {
					const c = new sp();
					EB(c, n) &&
						r.emit("update", [c.toUint8Array(), n.origin, r, n]);
				}
				if (r._observers.has("updateV2")) {
					const c = new Dd();
					EB(c, n) &&
						r.emit("updateV2", [c.toUint8Array(), n.origin, r, n]);
				}
				const {
					subdocsAdded: a,
					subdocsLoaded: l,
					subdocsRemoved: u,
				} = n;
				(a.size > 0 || u.size > 0 || l.size > 0) &&
					(a.forEach((c) => {
						(c.clientID = r.clientID),
							c.collectionid == null &&
								(c.collectionid = r.collectionid),
							r.subdocs.add(c);
					}),
					u.forEach((c) => r.subdocs.delete(c)),
					r.emit("subdocs", [
						{ loaded: l, added: a, removed: u },
						r,
						n,
					]),
					u.forEach((c) => c.destroy())),
					t.length <= e + 1
						? ((r._transactionCleanups = []),
							r.emit("afterAllTransactions", [r, t]))
						: gK(t, e + 1);
			}
		}
	},
	Gt = (t, e, n = null, r = !0) => {
		const i = t._transactionCleanups;
		let o = !1,
			s = null;
		t._transaction === null &&
			((o = !0),
			(t._transaction = new N0e(t, n, r)),
			i.push(t._transaction),
			i.length === 1 && t.emit("beforeAllTransactions", [t]),
			t.emit("beforeTransaction", [t._transaction, t]));
		try {
			s = e(t._transaction);
		} finally {
			if (o) {
				const a = t._transaction === i[0];
				(t._transaction = null), a && gK(i, 0);
			}
		}
		return s;
	};
class M0e {
	constructor(e, n) {
		(this.insertions = n), (this.deletions = e), (this.meta = new Map());
	}
}
const SB = (t, e, n) => {
		Wu(t, n.deletions, (r) => {
			r instanceof Qt && e.scope.some((i) => pg(i, r)) && qS(r, !1);
		});
	},
	AB = (t, e, n) => {
		let r = null;
		const i = t.doc,
			o = t.scope;
		Gt(
			i,
			(a) => {
				for (; e.length > 0 && t.currStackItem === null; ) {
					const l = i.store,
						u = e.pop(),
						c = new Set(),
						d = [];
					let f = !1;
					Wu(a, u.insertions, (h) => {
						if (h instanceof Qt) {
							if (h.redone !== null) {
								let { item: p, diff: g } = s2(l, h.id);
								g > 0 &&
									(p = Fi(
										a,
										gt(p.id.client, p.id.clock + g),
									)),
									(h = p);
							}
							!h.deleted && o.some((p) => pg(p, h)) && d.push(h);
						}
					}),
						Wu(a, u.deletions, (h) => {
							h instanceof Qt &&
								o.some((p) => pg(p, h)) &&
								!ip(u.insertions, h.id) &&
								c.add(h);
						}),
						c.forEach((h) => {
							f =
								MK(
									a,
									h,
									c,
									u.insertions,
									t.ignoreRemoteMapChanges,
									t,
								) !== null || f;
						});
					for (let h = d.length - 1; h >= 0; h--) {
						const p = d[h];
						t.deleteFilter(p) && (p.delete(a), (f = !0));
					}
					t.currStackItem = f ? u : null;
				}
				a.changed.forEach((l, u) => {
					l.has(null) &&
						u._searchMarker &&
						(u._searchMarker.length = 0);
				}),
					(r = a);
			},
			t,
		);
		const s = t.currStackItem;
		if (s != null) {
			const a = r.changedParentTypes;
			t.emit("stack-item-popped", [
				{ stackItem: s, type: n, changedParentTypes: a, origin: t },
				t,
			]),
				(t.currStackItem = null);
		}
		return s;
	};
class bK extends UV {
	constructor(
		e,
		{
			captureTimeout: n = 500,
			captureTransaction: r = (l) => !0,
			deleteFilter: i = () => !0,
			trackedOrigins: o = new Set([null]),
			ignoreRemoteMapChanges: s = !1,
			doc: a = Jw(e) ? e[0].doc : e.doc,
		} = {},
	) {
		super(),
			(this.scope = []),
			(this.doc = a),
			this.addToScope(e),
			(this.deleteFilter = i),
			o.add(this),
			(this.trackedOrigins = o),
			(this.captureTransaction = r),
			(this.undoStack = []),
			(this.redoStack = []),
			(this.undoing = !1),
			(this.redoing = !1),
			(this.currStackItem = null),
			(this.lastChange = 0),
			(this.ignoreRemoteMapChanges = s),
			(this.captureTimeout = n),
			(this.afterTransactionHandler = (l) => {
				if (
					!this.captureTransaction(l) ||
					!this.scope.some((v) => l.changedParentTypes.has(v)) ||
					(!this.trackedOrigins.has(l.origin) &&
						(!l.origin ||
							!this.trackedOrigins.has(l.origin.constructor)))
				)
					return;
				const u = this.undoing,
					c = this.redoing,
					d = u ? this.redoStack : this.undoStack;
				u ? this.stopCapturing() : c || this.clear(!1, !0);
				const f = new rp();
				l.afterState.forEach((v, b) => {
					const y = l.beforeState.get(b) || 0,
						x = v - y;
					x > 0 && fg(f, b, y, x);
				});
				const h = Hu();
				let p = !1;
				if (
					this.lastChange > 0 &&
					h - this.lastChange < this.captureTimeout &&
					d.length > 0 &&
					!u &&
					!c
				) {
					const v = d[d.length - 1];
					(v.deletions = n2([v.deletions, l.deleteSet])),
						(v.insertions = n2([v.insertions, f]));
				} else d.push(new M0e(l.deleteSet, f)), (p = !0);
				!u && !c && (this.lastChange = h),
					Wu(l, l.deleteSet, (v) => {
						v instanceof Qt &&
							this.scope.some((b) => pg(b, v)) &&
							qS(v, !0);
					});
				const g = [
					{
						stackItem: d[d.length - 1],
						origin: l.origin,
						type: u ? "redo" : "undo",
						changedParentTypes: l.changedParentTypes,
					},
					this,
				];
				p
					? this.emit("stack-item-added", g)
					: this.emit("stack-item-updated", g);
			}),
			this.doc.on("afterTransaction", this.afterTransactionHandler),
			this.doc.on("destroy", () => {
				this.destroy();
			});
	}
	addToScope(e) {
		(e = Jw(e) ? e : [e]),
			e.forEach((n) => {
				this.scope.every((r) => r !== n) &&
					(n.doc !== this.doc && p0e("[yjs#509] Not same Y.Doc"),
					this.scope.push(n));
			});
	}
	addTrackedOrigin(e) {
		this.trackedOrigins.add(e);
	}
	removeTrackedOrigin(e) {
		this.trackedOrigins.delete(e);
	}
	clear(e = !0, n = !0) {
		((e && this.canUndo()) || (n && this.canRedo())) &&
			this.doc.transact((r) => {
				e &&
					(this.undoStack.forEach((i) => SB(r, this, i)),
					(this.undoStack = [])),
					n &&
						(this.redoStack.forEach((i) => SB(r, this, i)),
						(this.redoStack = [])),
					this.emit("stack-cleared", [
						{ undoStackCleared: e, redoStackCleared: n },
					]);
			});
	}
	stopCapturing() {
		this.lastChange = 0;
	}
	undo() {
		this.undoing = !0;
		let e;
		try {
			e = AB(this, this.undoStack, "undo");
		} finally {
			this.undoing = !1;
		}
		return e;
	}
	redo() {
		this.redoing = !0;
		let e;
		try {
			e = AB(this, this.redoStack, "redo");
		} finally {
			this.redoing = !1;
		}
		return e;
	}
	canUndo() {
		return this.undoStack.length > 0;
	}
	canRedo() {
		return this.redoStack.length > 0;
	}
	destroy() {
		this.trackedOrigins.delete(this),
			this.doc.off("afterTransaction", this.afterTransactionHandler),
			super.destroy();
	}
}
function* j0e(t) {
	const e = nt(t.restDecoder);
	for (let n = 0; n < e; n++) {
		const r = nt(t.restDecoder),
			i = t.readClient();
		let o = nt(t.restDecoder);
		for (let s = 0; s < r; s++) {
			const a = t.readInfo();
			if (a === 10) {
				const l = nt(t.restDecoder);
				yield new no(gt(i, o), l), (o += l);
			} else if (Zx & a) {
				const l = (a & (ol | ao)) === 0,
					u = new Qt(
						gt(i, o),
						null,
						(a & ao) === ao ? t.readLeftID() : null,
						null,
						(a & ol) === ol ? t.readRightID() : null,
						l
							? t.readParentInfo()
								? t.readString()
								: t.readLeftID()
							: null,
						l && (a & ag) === ag ? t.readString() : null,
						jK(t, a),
					);
				yield u, (o += u.length);
			} else {
				const l = t.readLen();
				yield new Ro(gt(i, o), l), (o += l);
			}
		}
	}
}
class t3 {
	constructor(e, n) {
		(this.gen = j0e(e)),
			(this.curr = null),
			(this.done = !1),
			(this.filterSkips = n),
			this.next();
	}
	next() {
		do this.curr = this.gen.next().value || null;
		while (
			this.filterSkips &&
			this.curr !== null &&
			this.curr.constructor === no
		);
		return this.curr;
	}
}
class LS {
	constructor(e) {
		(this.currClient = 0),
			(this.startClock = 0),
			(this.written = 0),
			(this.encoder = e),
			(this.clientStructs = []);
	}
}
const _0e = (t) => Jv(t, e3, sp),
	z0e = (t, e = jS, n = Ed) => {
		const r = new e(),
			i = new t3(new n(Vi(t)), !1);
		let o = i.curr;
		if (o !== null) {
			let s = 0,
				a = o.id.client,
				l = o.id.clock !== 0,
				u = l ? 0 : o.id.clock + o.length;
			for (; o !== null; o = i.next())
				a !== o.id.client &&
					(u !== 0 &&
						(s++, Oe(r.restEncoder, a), Oe(r.restEncoder, u)),
					(a = o.id.client),
					(u = 0),
					(l = o.id.clock !== 0)),
					o.constructor === no && (l = !0),
					l || (u = o.id.clock + o.length);
			u !== 0 && (s++, Oe(r.restEncoder, a), Oe(r.restEncoder, u));
			const c = In();
			return (
				Oe(c, s),
				lge(c, r.restEncoder),
				(r.restEncoder = c),
				r.toUint8Array()
			);
		} else return Oe(r.restEncoder, 0), r.toUint8Array();
	},
	L0e = (t) => z0e(t, MS, e3),
	V0e = (t, e) => {
		if (t.constructor === Ro) {
			const { client: n, clock: r } = t.id;
			return new Ro(gt(n, r + e), t.length - e);
		} else if (t.constructor === no) {
			const { client: n, clock: r } = t.id;
			return new no(gt(n, r + e), t.length - e);
		} else {
			const n = t,
				{ client: r, clock: i } = n.id;
			return new Qt(
				gt(r, i + e),
				null,
				gt(r, i + e - 1),
				null,
				n.rightOrigin,
				n.parent,
				n.parentSub,
				n.content.splice(e),
			);
		}
	},
	Jv = (t, e = Ed, n = Dd) => {
		if (t.length === 1) return t[0];
		const r = t.map((c) => new e(Vi(c)));
		let i = r.map((c) => new t3(c, !0)),
			o = null;
		const s = new n(),
			a = new LS(s);
		for (
			;
			(i = i.filter((f) => f.curr !== null)),
				i.sort((f, h) => {
					if (f.curr.id.client === h.curr.id.client) {
						const p = f.curr.id.clock - h.curr.id.clock;
						return p === 0
							? f.curr.constructor === h.curr.constructor
								? 0
								: f.curr.constructor === no
									? 1
									: -1
							: p;
					} else return h.curr.id.client - f.curr.id.client;
				}),
				i.length !== 0;

		) {
			const c = i[0],
				d = c.curr.id.client;
			if (o !== null) {
				let f = c.curr,
					h = !1;
				for (
					;
					f !== null &&
					f.id.clock + f.length <=
						o.struct.id.clock + o.struct.length &&
					f.id.client >= o.struct.id.client;

				)
					(f = c.next()), (h = !0);
				if (
					f === null ||
					f.id.client !== d ||
					(h && f.id.clock > o.struct.id.clock + o.struct.length)
				)
					continue;
				if (d !== o.struct.id.client)
					iu(a, o.struct, o.offset),
						(o = { struct: f, offset: 0 }),
						c.next();
				else if (o.struct.id.clock + o.struct.length < f.id.clock)
					if (o.struct.constructor === no)
						o.struct.length =
							f.id.clock + f.length - o.struct.id.clock;
					else {
						iu(a, o.struct, o.offset);
						const p =
							f.id.clock - o.struct.id.clock - o.struct.length;
						o = {
							struct: new no(
								gt(d, o.struct.id.clock + o.struct.length),
								p,
							),
							offset: 0,
						};
					}
				else {
					const p = o.struct.id.clock + o.struct.length - f.id.clock;
					p > 0 &&
						(o.struct.constructor === no
							? (o.struct.length -= p)
							: (f = V0e(f, p))),
						o.struct.mergeWith(f) ||
							(iu(a, o.struct, o.offset),
							(o = { struct: f, offset: 0 }),
							c.next());
				}
			} else (o = { struct: c.curr, offset: 0 }), c.next();
			for (
				let f = c.curr;
				f !== null &&
				f.id.client === d &&
				f.id.clock === o.struct.id.clock + o.struct.length &&
				f.constructor !== no;
				f = c.next()
			)
				iu(a, o.struct, o.offset), (o = { struct: f, offset: 0 });
		}
		o !== null && (iu(a, o.struct, o.offset), (o = null)), VS(a);
		const l = r.map((c) => OS(c)),
			u = n2(l);
		return op(s, u), s.toUint8Array();
	},
	vK = (t, e, n = Ed, r = Dd) => {
		const i = lK(e),
			o = new r(),
			s = new LS(o),
			a = new n(Vi(t)),
			l = new t3(a, !1);
		for (; l.curr; ) {
			const c = l.curr,
				d = c.id.client,
				f = i.get(d) || 0;
			if (l.curr.constructor === no) {
				l.next();
				continue;
			}
			if (c.id.clock + c.length > f)
				for (
					iu(s, c, yl(f - c.id.clock, 0)), l.next();
					l.curr && l.curr.id.client === d;

				)
					iu(s, l.curr, 0), l.next();
			else
				for (
					;
					l.curr &&
					l.curr.id.client === d &&
					l.curr.id.clock + l.curr.length <= f;

				)
					l.next();
		}
		VS(s);
		const u = OS(a);
		return op(o, u), o.toUint8Array();
	},
	K0e = (t, e) => vK(t, e, e3, sp),
	yK = (t) => {
		t.written > 0 &&
			(t.clientStructs.push({
				written: t.written,
				restEncoder: Kt(t.encoder.restEncoder),
			}),
			(t.encoder.restEncoder = In()),
			(t.written = 0));
	},
	iu = (t, e, n) => {
		t.written > 0 && t.currClient !== e.id.client && yK(t),
			t.written === 0 &&
				((t.currClient = e.id.client),
				t.encoder.writeClient(e.id.client),
				Oe(t.encoder.restEncoder, e.id.clock + n)),
			e.write(t.encoder, n),
			t.written++;
	},
	VS = (t) => {
		yK(t);
		const e = t.encoder.restEncoder;
		Oe(e, t.clientStructs.length);
		for (let n = 0; n < t.clientStructs.length; n++) {
			const r = t.clientStructs[n];
			Oe(e, r.written), $0(e, r.restEncoder);
		}
	},
	U0e = (t, e, n, r) => {
		const i = new n(Vi(t)),
			o = new t3(i, !1),
			s = new r(),
			a = new LS(s);
		for (let u = o.curr; u !== null; u = o.next()) iu(a, e(u), 0);
		VS(a);
		const l = OS(i);
		return op(s, l), s.toUint8Array();
	},
	H0e = (t) => U0e(t, Ige, Ed, sp),
	$B = "You must not compute changes after the event-handler fired.";
class n3 {
	constructor(e, n) {
		(this.target = e),
			(this.currentTarget = e),
			(this.transaction = n),
			(this._changes = null),
			(this._keys = null),
			(this._delta = null),
			(this._path = null);
	}
	get path() {
		return (
			this._path || (this._path = W0e(this.currentTarget, this.target))
		);
	}
	deletes(e) {
		return ip(this.transaction.deleteSet, e.id);
	}
	get keys() {
		if (this._keys === null) {
			if (this.transaction.doc._transactionCleanups.length === 0)
				throw Uu($B);
			const e = new Map(),
				n = this.target;
			this.transaction.changed.get(n).forEach((i) => {
				if (i !== null) {
					const o = n._map.get(i);
					let s, a;
					if (this.adds(o)) {
						let l = o.left;
						for (; l !== null && this.adds(l); ) l = l.left;
						if (this.deletes(o))
							if (l !== null && this.deletes(l))
								(s = "delete"),
									(a = Ek(l.content.getContent()));
							else return;
						else
							l !== null && this.deletes(l)
								? ((s = "update"),
									(a = Ek(l.content.getContent())))
								: ((s = "add"), (a = void 0));
					} else if (this.deletes(o))
						(s = "delete"), (a = Ek(o.content.getContent()));
					else return;
					e.set(i, { action: s, oldValue: a });
				}
			}),
				(this._keys = e);
		}
		return this._keys;
	}
	get delta() {
		return this.changes.delta;
	}
	adds(e) {
		return (
			e.id.clock >= (this.transaction.beforeState.get(e.id.client) || 0)
		);
	}
	get changes() {
		let e = this._changes;
		if (e === null) {
			if (this.transaction.doc._transactionCleanups.length === 0)
				throw Uu($B);
			const n = this.target,
				r = xl(),
				i = xl(),
				o = [];
			if (
				((e = { added: r, deleted: i, delta: o, keys: this.keys }),
				this.transaction.changed.get(n).has(null))
			) {
				let a = null;
				const l = () => {
					a && o.push(a);
				};
				for (let u = n._start; u !== null; u = u.right)
					u.deleted
						? this.deletes(u) &&
							!this.adds(u) &&
							((a === null || a.delete === void 0) &&
								(l(), (a = { delete: 0 })),
							(a.delete += u.length),
							i.add(u))
						: this.adds(u)
							? ((a === null || a.insert === void 0) &&
									(l(), (a = { insert: [] })),
								(a.insert = a.insert.concat(
									u.content.getContent(),
								)),
								r.add(u))
							: ((a === null || a.retain === void 0) &&
									(l(), (a = { retain: 0 })),
								(a.retain += u.length));
				a !== null && a.retain === void 0 && l();
			}
			this._changes = e;
		}
		return e;
	}
}
const W0e = (t, e) => {
		const n = [];
		for (; e._item !== null && e !== t; ) {
			if (e._item.parentSub !== null) n.unshift(e._item.parentSub);
			else {
				let r = 0,
					i = e._item.parent._start;
				for (; i !== e._item && i !== null; )
					!i.deleted && i.countable && (r += i.length), (i = i.right);
				n.unshift(r);
			}
			e = e._item.parent;
		}
		return n;
	},
	xK = 80;
let KS = 0;
class q0e {
	constructor(e, n) {
		(e.marker = !0),
			(this.p = e),
			(this.index = n),
			(this.timestamp = KS++);
	}
}
const G0e = (t) => {
		t.timestamp = KS++;
	},
	kK = (t, e, n) => {
		(t.p.marker = !1),
			(t.p = e),
			(e.marker = !0),
			(t.index = n),
			(t.timestamp = KS++);
	},
	Y0e = (t, e, n) => {
		if (t.length >= xK) {
			const r = t.reduce((i, o) => (i.timestamp < o.timestamp ? i : o));
			return kK(r, e, n), r;
		} else {
			const r = new q0e(e, n);
			return t.push(r), r;
		}
	},
	r3 = (t, e) => {
		if (t._start === null || e === 0 || t._searchMarker === null)
			return null;
		const n =
			t._searchMarker.length === 0
				? null
				: t._searchMarker.reduce((o, s) =>
						mb(e - o.index) < mb(e - s.index) ? o : s,
					);
		let r = t._start,
			i = 0;
		for (
			n !== null && ((r = n.p), (i = n.index), G0e(n));
			r.right !== null && i < e;

		) {
			if (!r.deleted && r.countable) {
				if (e < i + r.length) break;
				i += r.length;
			}
			r = r.right;
		}
		for (; r.left !== null && i > e; )
			(r = r.left), !r.deleted && r.countable && (i -= r.length);
		for (
			;
			r.left !== null &&
			r.left.id.client === r.id.client &&
			r.left.id.clock + r.left.length === r.id.clock;

		)
			(r = r.left), !r.deleted && r.countable && (i -= r.length);
		return n !== null && mb(n.index - i) < r.parent.length / xK
			? (kK(n, r, i), n)
			: Y0e(t._searchMarker, r, i);
	},
	gg = (t, e, n) => {
		for (let r = t.length - 1; r >= 0; r--) {
			const i = t[r];
			if (n > 0) {
				let o = i.p;
				for (o.marker = !1; o && (o.deleted || !o.countable); )
					(o = o.left),
						o && !o.deleted && o.countable && (i.index -= o.length);
				if (o === null || o.marker === !0) {
					t.splice(r, 1);
					continue;
				}
				(i.p = o), (o.marker = !0);
			}
			(e < i.index || (n > 0 && e === i.index)) &&
				(i.index = yl(e, i.index + n));
		}
	},
	i3 = (t, e, n) => {
		const r = t,
			i = e.changedParentTypes;
		for (; Ms(i, t, () => []).push(n), t._item !== null; )
			t = t._item.parent;
		dK(r._eH, n, e);
	};
class ir {
	constructor() {
		(this._item = null),
			(this._map = new Map()),
			(this._start = null),
			(this.doc = null),
			(this._length = 0),
			(this._eH = yB()),
			(this._dEH = yB()),
			(this._searchMarker = null);
	}
	get parent() {
		return this._item ? this._item.parent : null;
	}
	_integrate(e, n) {
		(this.doc = e), (this._item = n);
	}
	_copy() {
		throw ws();
	}
	clone() {
		throw ws();
	}
	_write(e) {}
	get _first() {
		let e = this._start;
		for (; e !== null && e.deleted; ) e = e.right;
		return e;
	}
	_callObserver(e, n) {
		!e.local && this._searchMarker && (this._searchMarker.length = 0);
	}
	observe(e) {
		xB(this._eH, e);
	}
	observeDeep(e) {
		xB(this._dEH, e);
	}
	unobserve(e) {
		kB(this._eH, e);
	}
	unobserveDeep(e) {
		kB(this._dEH, e);
	}
	toJSON() {}
}
const CK = (t, e, n) => {
		e < 0 && (e = t._length + e), n < 0 && (n = t._length + n);
		let r = n - e;
		const i = [];
		let o = t._start;
		for (; o !== null && r > 0; ) {
			if (o.countable && !o.deleted) {
				const s = o.content.getContent();
				if (s.length <= e) e -= s.length;
				else {
					for (let a = e; a < s.length && r > 0; a++)
						i.push(s[a]), r--;
					e = 0;
				}
			}
			o = o.right;
		}
		return i;
	},
	wK = (t) => {
		const e = [];
		let n = t._start;
		for (; n !== null; ) {
			if (n.countable && !n.deleted) {
				const r = n.content.getContent();
				for (let i = 0; i < r.length; i++) e.push(r[i]);
			}
			n = n.right;
		}
		return e;
	},
	EK = (t, e) => {
		const n = [];
		let r = t._start;
		for (; r !== null; ) {
			if (r.countable && Dc(r, e)) {
				const i = r.content.getContent();
				for (let o = 0; o < i.length; o++) n.push(i[o]);
			}
			r = r.right;
		}
		return n;
	},
	bg = (t, e) => {
		let n = 0,
			r = t._start;
		for (; r !== null; ) {
			if (r.countable && !r.deleted) {
				const i = r.content.getContent();
				for (let o = 0; o < i.length; o++) e(i[o], n++, t);
			}
			r = r.right;
		}
	},
	DK = (t, e) => {
		const n = [];
		return (
			bg(t, (r, i) => {
				n.push(e(r, i, t));
			}),
			n
		);
	},
	J0e = (t) => {
		let e = t._start,
			n = null,
			r = 0;
		return {
			[Symbol.iterator]() {
				return this;
			},
			next: () => {
				if (n === null) {
					for (; e !== null && e.deleted; ) e = e.right;
					if (e === null) return { done: !0, value: void 0 };
					(n = e.content.getContent()), (r = 0), (e = e.right);
				}
				const i = n[r++];
				return n.length <= r && (n = null), { done: !1, value: i };
			},
		};
	},
	SK = (t, e) => {
		const n = r3(t, e);
		let r = t._start;
		for (n !== null && ((r = n.p), (e -= n.index)); r !== null; r = r.right)
			if (!r.deleted && r.countable) {
				if (e < r.length) return r.content.getContent()[e];
				e -= r.length;
			}
	},
	Xv = (t, e, n, r) => {
		let i = n;
		const o = t.doc,
			s = o.clientID,
			a = o.store,
			l = n === null ? e._start : n.right;
		let u = [];
		const c = () => {
			u.length > 0 &&
				((i = new Qt(
					gt(s, Nn(a, s)),
					i,
					i && i.lastId,
					l,
					l && l.id,
					e,
					null,
					new Sd(u),
				)),
				i.integrate(t, 0),
				(u = []));
		};
		r.forEach((d) => {
			if (d === null) u.push(d);
			else
				switch (d.constructor) {
					case Number:
					case Object:
					case Boolean:
					case Array:
					case String:
						u.push(d);
						break;
					default:
						switch ((c(), d.constructor)) {
							case Uint8Array:
							case ArrayBuffer:
								(i = new Qt(
									gt(s, Nn(a, s)),
									i,
									i && i.lastId,
									l,
									l && l.id,
									e,
									null,
									new B0(new Uint8Array(d)),
								)),
									i.integrate(t, 0);
								break;
							case Ki:
								(i = new Qt(
									gt(s, Nn(a, s)),
									i,
									i && i.lastId,
									l,
									l && l.id,
									e,
									null,
									new I0(d),
								)),
									i.integrate(t, 0);
								break;
							default:
								if (d instanceof ir)
									(i = new Qt(
										gt(s, Nn(a, s)),
										i,
										i && i.lastId,
										l,
										l && l.id,
										e,
										null,
										new js(d),
									)),
										i.integrate(t, 0);
								else
									throw new Error(
										"Unexpected content type in insert operation",
									);
						}
				}
		}),
			c();
	},
	AK = () => Uu("Length exceeded!"),
	$K = (t, e, n, r) => {
		if (n > e._length) throw AK();
		if (n === 0)
			return (
				e._searchMarker && gg(e._searchMarker, n, r.length),
				Xv(t, e, null, r)
			);
		const i = n,
			o = r3(e, n);
		let s = e._start;
		for (
			o !== null &&
			((s = o.p),
			(n -= o.index),
			n === 0 &&
				((s = s.prev),
				(n += s && s.countable && !s.deleted ? s.length : 0)));
			s !== null;
			s = s.right
		)
			if (!s.deleted && s.countable) {
				if (n <= s.length) {
					n < s.length && Fi(t, gt(s.id.client, s.id.clock + n));
					break;
				}
				n -= s.length;
			}
		return (
			e._searchMarker && gg(e._searchMarker, i, r.length), Xv(t, e, s, r)
		);
	},
	X0e = (t, e, n) => {
		let i = (e._searchMarker || []).reduce(
			(o, s) => (s.index > o.index ? s : o),
			{ index: 0, p: e._start },
		).p;
		if (i) for (; i.right; ) i = i.right;
		return Xv(t, e, i, n);
	},
	TK = (t, e, n, r) => {
		if (r === 0) return;
		const i = n,
			o = r,
			s = r3(e, n);
		let a = e._start;
		for (
			s !== null && ((a = s.p), (n -= s.index));
			a !== null && n > 0;
			a = a.right
		)
			!a.deleted &&
				a.countable &&
				(n < a.length && Fi(t, gt(a.id.client, a.id.clock + n)),
				(n -= a.length));
		for (; r > 0 && a !== null; )
			a.deleted ||
				(r < a.length && Fi(t, gt(a.id.client, a.id.clock + r)),
				a.delete(t),
				(r -= a.length)),
				(a = a.right);
		if (r > 0) throw AK();
		e._searchMarker && gg(e._searchMarker, i, -o + r);
	},
	Zv = (t, e, n) => {
		const r = e._map.get(n);
		r !== void 0 && r.delete(t);
	},
	US = (t, e, n, r) => {
		const i = e._map.get(n) || null,
			o = t.doc,
			s = o.clientID;
		let a;
		if (r == null) a = new Sd([r]);
		else
			switch (r.constructor) {
				case Number:
				case Object:
				case Boolean:
				case Array:
				case String:
					a = new Sd([r]);
					break;
				case Uint8Array:
					a = new B0(r);
					break;
				case Ki:
					a = new I0(r);
					break;
				default:
					if (r instanceof ir) a = new js(r);
					else throw new Error("Unexpected content type");
			}
		new Qt(
			gt(s, Nn(o.store, s)),
			i,
			i && i.lastId,
			null,
			null,
			e,
			n,
			a,
		).integrate(t, 0);
	},
	HS = (t, e) => {
		const n = t._map.get(e);
		return n !== void 0 && !n.deleted
			? n.content.getContent()[n.length - 1]
			: void 0;
	},
	BK = (t) => {
		const e = {};
		return (
			t._map.forEach((n, r) => {
				n.deleted || (e[r] = n.content.getContent()[n.length - 1]);
			}),
			e
		);
	},
	IK = (t, e) => {
		const n = t._map.get(e);
		return n !== void 0 && !n.deleted;
	},
	Z0e = (t, e) => {
		const n = {};
		return (
			t._map.forEach((r, i) => {
				let o = r;
				for (
					;
					o !== null &&
					(!e.sv.has(o.id.client) ||
						o.id.clock >= (e.sv.get(o.id.client) || 0));

				)
					o = o.left;
				o !== null &&
					Dc(o, e) &&
					(n[i] = o.content.getContent()[o.length - 1]);
			}),
			n
		);
	},
	R1 = (t) => m0e(t.entries(), (e) => !e[1].deleted);
class Q0e extends n3 {}
class Au extends ir {
	constructor() {
		super(), (this._prelimContent = []), (this._searchMarker = []);
	}
	static from(e) {
		const n = new Au();
		return n.push(e), n;
	}
	_integrate(e, n) {
		super._integrate(e, n),
			this.insert(0, this._prelimContent),
			(this._prelimContent = null);
	}
	_copy() {
		return new Au();
	}
	clone() {
		const e = new Au();
		return (
			e.insert(
				0,
				this.toArray().map((n) => (n instanceof ir ? n.clone() : n)),
			),
			e
		);
	}
	get length() {
		return this._prelimContent === null
			? this._length
			: this._prelimContent.length;
	}
	_callObserver(e, n) {
		super._callObserver(e, n), i3(this, e, new Q0e(this, e));
	}
	insert(e, n) {
		this.doc !== null
			? Gt(this.doc, (r) => {
					$K(r, this, e, n);
				})
			: this._prelimContent.splice(e, 0, ...n);
	}
	push(e) {
		this.doc !== null
			? Gt(this.doc, (n) => {
					X0e(n, this, e);
				})
			: this._prelimContent.push(...e);
	}
	unshift(e) {
		this.insert(0, e);
	}
	delete(e, n = 1) {
		this.doc !== null
			? Gt(this.doc, (r) => {
					TK(r, this, e, n);
				})
			: this._prelimContent.splice(e, n);
	}
	get(e) {
		return SK(this, e);
	}
	toArray() {
		return wK(this);
	}
	slice(e = 0, n = this.length) {
		return CK(this, e, n);
	}
	toJSON() {
		return this.map((e) => (e instanceof ir ? e.toJSON() : e));
	}
	map(e) {
		return DK(this, e);
	}
	forEach(e) {
		bg(this, e);
	}
	[Symbol.iterator]() {
		return J0e(this);
	}
	_write(e) {
		e.writeTypeRef(w1e);
	}
}
const e1e = (t) => new Au();
class t1e extends n3 {
	constructor(e, n, r) {
		super(e, n), (this.keysChanged = r);
	}
}
class ba extends ir {
	constructor(e) {
		super(),
			(this._prelimContent = null),
			e === void 0
				? (this._prelimContent = new Map())
				: (this._prelimContent = new Map(e));
	}
	_integrate(e, n) {
		super._integrate(e, n),
			this._prelimContent.forEach((r, i) => {
				this.set(i, r);
			}),
			(this._prelimContent = null);
	}
	_copy() {
		return new ba();
	}
	clone() {
		const e = new ba();
		return (
			this.forEach((n, r) => {
				e.set(r, n instanceof ir ? n.clone() : n);
			}),
			e
		);
	}
	_callObserver(e, n) {
		i3(this, e, new t1e(this, e, n));
	}
	toJSON() {
		const e = {};
		return (
			this._map.forEach((n, r) => {
				if (!n.deleted) {
					const i = n.content.getContent()[n.length - 1];
					e[r] = i instanceof ir ? i.toJSON() : i;
				}
			}),
			e
		);
	}
	get size() {
		return [...R1(this._map)].length;
	}
	keys() {
		return Ak(R1(this._map), (e) => e[0]);
	}
	values() {
		return Ak(
			R1(this._map),
			(e) => e[1].content.getContent()[e[1].length - 1],
		);
	}
	entries() {
		return Ak(R1(this._map), (e) => [
			e[0],
			e[1].content.getContent()[e[1].length - 1],
		]);
	}
	forEach(e) {
		this._map.forEach((n, r) => {
			n.deleted || e(n.content.getContent()[n.length - 1], r, this);
		});
	}
	[Symbol.iterator]() {
		return this.entries();
	}
	delete(e) {
		this.doc !== null
			? Gt(this.doc, (n) => {
					Zv(n, this, e);
				})
			: this._prelimContent.delete(e);
	}
	set(e, n) {
		return (
			this.doc !== null
				? Gt(this.doc, (r) => {
						US(r, this, e, n);
					})
				: this._prelimContent.set(e, n),
			n
		);
	}
	get(e) {
		return HS(this, e);
	}
	has(e) {
		return IK(this, e);
	}
	clear() {
		this.doc !== null
			? Gt(this.doc, (e) => {
					this.forEach(function (n, r, i) {
						Zv(e, i, r);
					});
				})
			: this._prelimContent.clear();
	}
	_write(e) {
		e.writeTypeRef(E1e);
	}
}
const n1e = (t) => new ba(),
	vu = (t, e) =>
		t === e ||
		(typeof t == "object" && typeof e == "object" && t && e && Bge(t, e));
class o2 {
	constructor(e, n, r, i) {
		(this.left = e),
			(this.right = n),
			(this.index = r),
			(this.currentAttributes = i);
	}
	forward() {
		switch ((this.right === null && go(), this.right.content.constructor)) {
			case Yn:
				this.right.deleted ||
					ap(this.currentAttributes, this.right.content);
				break;
			default:
				this.right.deleted || (this.index += this.right.length);
				break;
		}
		(this.left = this.right), (this.right = this.right.right);
	}
}
const TB = (t, e, n) => {
		for (; e.right !== null && n > 0; ) {
			switch (e.right.content.constructor) {
				case Yn:
					e.right.deleted || ap(e.currentAttributes, e.right.content);
					break;
				default:
					e.right.deleted ||
						(n < e.right.length &&
							Fi(t, gt(e.right.id.client, e.right.id.clock + n)),
						(e.index += e.right.length),
						(n -= e.right.length));
					break;
			}
			(e.left = e.right), (e.right = e.right.right);
		}
		return e;
	},
	O1 = (t, e, n, r) => {
		const i = new Map(),
			o = r ? r3(e, n) : null;
		if (o) {
			const s = new o2(o.p.left, o.p, o.index, i);
			return TB(t, s, n - o.index);
		} else {
			const s = new o2(null, e._start, 0, i);
			return TB(t, s, n);
		}
	},
	FK = (t, e, n, r) => {
		for (
			;
			n.right !== null &&
			(n.right.deleted === !0 ||
				(n.right.content.constructor === Yn &&
					vu(r.get(n.right.content.key), n.right.content.value)));

		)
			n.right.deleted || r.delete(n.right.content.key), n.forward();
		const i = t.doc,
			o = i.clientID;
		r.forEach((s, a) => {
			const l = n.left,
				u = n.right,
				c = new Qt(
					gt(o, Nn(i.store, o)),
					l,
					l && l.lastId,
					u,
					u && u.id,
					e,
					null,
					new Yn(a, s),
				);
			c.integrate(t, 0), (n.right = c), n.forward();
		});
	},
	ap = (t, e) => {
		const { key: n, value: r } = e;
		r === null ? t.delete(n) : t.set(n, r);
	},
	PK = (t, e) => {
		for (; t.right !== null; ) {
			if (
				!(
					t.right.deleted ||
					(t.right.content.constructor === Yn &&
						vu(
							e[t.right.content.key] ?? null,
							t.right.content.value,
						))
				)
			)
				break;
			t.forward();
		}
	},
	NK = (t, e, n, r) => {
		const i = t.doc,
			o = i.clientID,
			s = new Map();
		for (const a in r) {
			const l = r[a],
				u = n.currentAttributes.get(a) ?? null;
			if (!vu(u, l)) {
				s.set(a, u);
				const { left: c, right: d } = n;
				(n.right = new Qt(
					gt(o, Nn(i.store, o)),
					c,
					c && c.lastId,
					d,
					d && d.id,
					e,
					null,
					new Yn(a, l),
				)),
					n.right.integrate(t, 0),
					n.forward();
			}
		}
		return s;
	},
	Bk = (t, e, n, r, i) => {
		n.currentAttributes.forEach((f, h) => {
			i[h] === void 0 && (i[h] = null);
		});
		const o = t.doc,
			s = o.clientID;
		PK(n, i);
		const a = NK(t, e, n, i),
			l =
				r.constructor === String
					? new Bs(r)
					: r instanceof ir
						? new js(r)
						: new Zd(r);
		let { left: u, right: c, index: d } = n;
		e._searchMarker && gg(e._searchMarker, n.index, l.getLength()),
			(c = new Qt(
				gt(s, Nn(o.store, s)),
				u,
				u && u.lastId,
				c,
				c && c.id,
				e,
				null,
				l,
			)),
			c.integrate(t, 0),
			(n.right = c),
			(n.index = d),
			n.forward(),
			FK(t, e, n, a);
	},
	BB = (t, e, n, r, i) => {
		const o = t.doc,
			s = o.clientID;
		PK(n, i);
		const a = NK(t, e, n, i);
		e: for (
			;
			n.right !== null &&
			(r > 0 ||
				(a.size > 0 &&
					(n.right.deleted || n.right.content.constructor === Yn)));

		) {
			if (!n.right.deleted)
				switch (n.right.content.constructor) {
					case Yn: {
						const { key: l, value: u } = n.right.content,
							c = i[l];
						if (c !== void 0) {
							if (vu(c, u)) a.delete(l);
							else {
								if (r === 0) break e;
								a.set(l, u);
							}
							n.right.delete(t);
						} else n.currentAttributes.set(l, u);
						break;
					}
					default:
						r < n.right.length &&
							Fi(t, gt(n.right.id.client, n.right.id.clock + r)),
							(r -= n.right.length);
						break;
				}
			n.forward();
		}
		if (r > 0) {
			let l = "";
			for (; r > 0; r--)
				l += `
`;
			(n.right = new Qt(
				gt(s, Nn(o.store, s)),
				n.left,
				n.left && n.left.lastId,
				n.right,
				n.right && n.right.id,
				e,
				null,
				new Bs(l),
			)),
				n.right.integrate(t, 0),
				n.forward();
		}
		FK(t, e, n, a);
	},
	RK = (t, e, n, r, i) => {
		let o = e;
		const s = hi();
		for (; o && (!o.countable || o.deleted); ) {
			if (!o.deleted && o.content.constructor === Yn) {
				const u = o.content;
				s.set(u.key, u);
			}
			o = o.right;
		}
		let a = 0,
			l = !1;
		for (; e !== o; ) {
			if ((n === e && (l = !0), !e.deleted)) {
				const u = e.content;
				switch (u.constructor) {
					case Yn: {
						const { key: c, value: d } = u,
							f = r.get(c) ?? null;
						(s.get(c) !== u || f === d) &&
							(e.delete(t),
							a++,
							!l &&
								(i.get(c) ?? null) === d &&
								f !== d &&
								(f === null ? i.delete(c) : i.set(c, f))),
							!l && !e.deleted && ap(i, u);
						break;
					}
				}
			}
			e = e.right;
		}
		return a;
	},
	r1e = (t, e) => {
		for (; e && e.right && (e.right.deleted || !e.right.countable); )
			e = e.right;
		const n = new Set();
		for (; e && (e.deleted || !e.countable); ) {
			if (!e.deleted && e.content.constructor === Yn) {
				const r = e.content.key;
				n.has(r) ? e.delete(t) : n.add(r);
			}
			e = e.left;
		}
	},
	i1e = (t) => {
		let e = 0;
		return (
			Gt(t.doc, (n) => {
				let r = t._start,
					i = t._start,
					o = hi();
				const s = Qw(o);
				for (; i; ) {
					if (i.deleted === !1)
						switch (i.content.constructor) {
							case Yn:
								ap(s, i.content);
								break;
							default:
								(e += RK(n, r, i, o, s)), (o = Qw(s)), (r = i);
								break;
						}
					i = i.right;
				}
			}),
			e
		);
	},
	o1e = (t) => {
		const e = new Set(),
			n = t.doc;
		for (const [r, i] of t.afterState.entries()) {
			const o = t.beforeState.get(r) || 0;
			i !== o &&
				mK(t, n.store.clients.get(r), o, i, (s) => {
					!s.deleted &&
						s.content.constructor === Yn &&
						s.constructor !== Ro &&
						e.add(s.parent);
				});
		}
		Gt(n, (r) => {
			Wu(t, t.deleteSet, (i) => {
				if (
					i instanceof Ro ||
					!i.parent._hasFormatting ||
					e.has(i.parent)
				)
					return;
				const o = i.parent;
				i.content.constructor === Yn ? e.add(o) : r1e(r, i);
			});
			for (const i of e) i1e(i);
		});
	},
	IB = (t, e, n) => {
		const r = n,
			i = Qw(e.currentAttributes),
			o = e.right;
		for (; n > 0 && e.right !== null; ) {
			if (e.right.deleted === !1)
				switch (e.right.content.constructor) {
					case js:
					case Zd:
					case Bs:
						n < e.right.length &&
							Fi(t, gt(e.right.id.client, e.right.id.clock + n)),
							(n -= e.right.length),
							e.right.delete(t);
						break;
				}
			e.forward();
		}
		o && RK(t, o, e.right, i, e.currentAttributes);
		const s = (e.left || e.right).parent;
		return s._searchMarker && gg(s._searchMarker, e.index, -r + n), e;
	};
class s1e extends n3 {
	constructor(e, n, r) {
		super(e, n),
			(this.childListChanged = !1),
			(this.keysChanged = new Set()),
			r.forEach((i) => {
				i === null
					? (this.childListChanged = !0)
					: this.keysChanged.add(i);
			});
	}
	get changes() {
		if (this._changes === null) {
			const e = {
				keys: this.keys,
				delta: this.delta,
				added: new Set(),
				deleted: new Set(),
			};
			this._changes = e;
		}
		return this._changes;
	}
	get delta() {
		if (this._delta === null) {
			const e = this.target.doc,
				n = [];
			Gt(e, (r) => {
				const i = new Map(),
					o = new Map();
				let s = this.target._start,
					a = null;
				const l = {};
				let u = "",
					c = 0,
					d = 0;
				const f = () => {
					if (a !== null) {
						let h = null;
						switch (a) {
							case "delete":
								d > 0 && (h = { delete: d }), (d = 0);
								break;
							case "insert":
								(typeof u == "object" || u.length > 0) &&
									((h = { insert: u }),
									i.size > 0 &&
										((h.attributes = {}),
										i.forEach((p, g) => {
											p !== null && (h.attributes[g] = p);
										}))),
									(u = "");
								break;
							case "retain":
								c > 0 &&
									((h = { retain: c }),
									$ge(l) || (h.attributes = Sge({}, l))),
									(c = 0);
								break;
						}
						h && n.push(h), (a = null);
					}
				};
				for (; s !== null; ) {
					switch (s.content.constructor) {
						case js:
						case Zd:
							this.adds(s)
								? this.deletes(s) ||
									(f(),
									(a = "insert"),
									(u = s.content.getContent()[0]),
									f())
								: this.deletes(s)
									? (a !== "delete" && (f(), (a = "delete")),
										(d += 1))
									: s.deleted ||
										(a !== "retain" &&
											(f(), (a = "retain")),
										(c += 1));
							break;
						case Bs:
							this.adds(s)
								? this.deletes(s) ||
									(a !== "insert" && (f(), (a = "insert")),
									(u += s.content.str))
								: this.deletes(s)
									? (a !== "delete" && (f(), (a = "delete")),
										(d += s.length))
									: s.deleted ||
										(a !== "retain" &&
											(f(), (a = "retain")),
										(c += s.length));
							break;
						case Yn: {
							const { key: h, value: p } = s.content;
							if (this.adds(s)) {
								if (!this.deletes(s)) {
									const g = i.get(h) ?? null;
									vu(g, p)
										? p !== null && s.delete(r)
										: (a === "retain" && f(),
											vu(p, o.get(h) ?? null)
												? delete l[h]
												: (l[h] = p));
								}
							} else if (this.deletes(s)) {
								o.set(h, p);
								const g = i.get(h) ?? null;
								vu(g, p) || (a === "retain" && f(), (l[h] = g));
							} else if (!s.deleted) {
								o.set(h, p);
								const g = l[h];
								g !== void 0 &&
									(vu(g, p)
										? g !== null && s.delete(r)
										: (a === "retain" && f(),
											p === null
												? delete l[h]
												: (l[h] = p)));
							}
							s.deleted ||
								(a === "insert" && f(), ap(i, s.content));
							break;
						}
					}
					s = s.right;
				}
				for (f(); n.length > 0; ) {
					const h = n[n.length - 1];
					if (h.retain !== void 0 && h.attributes === void 0) n.pop();
					else break;
				}
			}),
				(this._delta = n);
		}
		return this._delta;
	}
}
class qu extends ir {
	constructor(e) {
		super(),
			(this._pending = e !== void 0 ? [() => this.insert(0, e)] : []),
			(this._searchMarker = []),
			(this._hasFormatting = !1);
	}
	get length() {
		return this._length;
	}
	_integrate(e, n) {
		super._integrate(e, n);
		try {
			this._pending.forEach((r) => r());
		} catch (r) {
			console.error(r);
		}
		this._pending = null;
	}
	_copy() {
		return new qu();
	}
	clone() {
		const e = new qu();
		return e.applyDelta(this.toDelta()), e;
	}
	_callObserver(e, n) {
		super._callObserver(e, n);
		const r = new s1e(this, e, n);
		i3(this, e, r),
			!e.local && this._hasFormatting && (e._needFormattingCleanup = !0);
	}
	toString() {
		let e = "",
			n = this._start;
		for (; n !== null; )
			!n.deleted &&
				n.countable &&
				n.content.constructor === Bs &&
				(e += n.content.str),
				(n = n.right);
		return e;
	}
	toJSON() {
		return this.toString();
	}
	applyDelta(e, { sanitize: n = !0 } = {}) {
		this.doc !== null
			? Gt(this.doc, (r) => {
					const i = new o2(null, this._start, 0, new Map());
					for (let o = 0; o < e.length; o++) {
						const s = e[o];
						if (s.insert !== void 0) {
							const a =
								!n &&
								typeof s.insert == "string" &&
								o === e.length - 1 &&
								i.right === null &&
								s.insert.slice(-1) ===
									`
`
									? s.insert.slice(0, -1)
									: s.insert;
							(typeof a != "string" || a.length > 0) &&
								Bk(r, this, i, a, s.attributes || {});
						} else
							s.retain !== void 0
								? BB(r, this, i, s.retain, s.attributes || {})
								: s.delete !== void 0 && IB(r, i, s.delete);
					}
				})
			: this._pending.push(() => this.applyDelta(e));
	}
	toDelta(e, n, r) {
		const i = [],
			o = new Map(),
			s = this.doc;
		let a = "",
			l = this._start;
		function u() {
			if (a.length > 0) {
				const d = {};
				let f = !1;
				o.forEach((p, g) => {
					(f = !0), (d[g] = p);
				});
				const h = { insert: a };
				f && (h.attributes = d), i.push(h), (a = "");
			}
		}
		const c = () => {
			for (; l !== null; ) {
				if (Dc(l, e) || (n !== void 0 && Dc(l, n)))
					switch (l.content.constructor) {
						case Bs: {
							const d = o.get("ychange");
							e !== void 0 && !Dc(l, e)
								? (d === void 0 ||
										d.user !== l.id.client ||
										d.type !== "removed") &&
									(u(),
									o.set(
										"ychange",
										r
											? r("removed", l.id)
											: { type: "removed" },
									))
								: n !== void 0 && !Dc(l, n)
									? (d === void 0 ||
											d.user !== l.id.client ||
											d.type !== "added") &&
										(u(),
										o.set(
											"ychange",
											r
												? r("added", l.id)
												: { type: "added" },
										))
									: d !== void 0 &&
										(u(), o.delete("ychange")),
								(a += l.content.str);
							break;
						}
						case js:
						case Zd: {
							u();
							const d = { insert: l.content.getContent()[0] };
							if (o.size > 0) {
								const f = {};
								(d.attributes = f),
									o.forEach((h, p) => {
										f[p] = h;
									});
							}
							i.push(d);
							break;
						}
						case Yn:
							Dc(l, e) && (u(), ap(o, l.content));
							break;
					}
				l = l.right;
			}
			u();
		};
		return (
			e || n
				? Gt(
						s,
						(d) => {
							e && r2(d, e), n && r2(d, n), c();
						},
						"cleanup",
					)
				: c(),
			i
		);
	}
	insert(e, n, r) {
		if (n.length <= 0) return;
		const i = this.doc;
		i !== null
			? Gt(i, (o) => {
					const s = O1(o, this, e, !r);
					r ||
						((r = {}),
						s.currentAttributes.forEach((a, l) => {
							r[l] = a;
						})),
						Bk(o, this, s, n, r);
				})
			: this._pending.push(() => this.insert(e, n, r));
	}
	insertEmbed(e, n, r) {
		const i = this.doc;
		i !== null
			? Gt(i, (o) => {
					const s = O1(o, this, e, !r);
					Bk(o, this, s, n, r || {});
				})
			: this._pending.push(() => this.insertEmbed(e, n, r || {}));
	}
	delete(e, n) {
		if (n === 0) return;
		const r = this.doc;
		r !== null
			? Gt(r, (i) => {
					IB(i, O1(i, this, e, !0), n);
				})
			: this._pending.push(() => this.delete(e, n));
	}
	format(e, n, r) {
		if (n === 0) return;
		const i = this.doc;
		i !== null
			? Gt(i, (o) => {
					const s = O1(o, this, e, !1);
					s.right !== null && BB(o, this, s, n, r);
				})
			: this._pending.push(() => this.format(e, n, r));
	}
	removeAttribute(e) {
		this.doc !== null
			? Gt(this.doc, (n) => {
					Zv(n, this, e);
				})
			: this._pending.push(() => this.removeAttribute(e));
	}
	setAttribute(e, n) {
		this.doc !== null
			? Gt(this.doc, (r) => {
					US(r, this, e, n);
				})
			: this._pending.push(() => this.setAttribute(e, n));
	}
	getAttribute(e) {
		return HS(this, e);
	}
	getAttributes() {
		return BK(this);
	}
	_write(e) {
		e.writeTypeRef(D1e);
	}
}
const a1e = (t) => new qu();
class Ik {
	constructor(e, n = () => !0) {
		(this._filter = n),
			(this._root = e),
			(this._currentNode = e._start),
			(this._firstCall = !0);
	}
	[Symbol.iterator]() {
		return this;
	}
	next() {
		let e = this._currentNode,
			n = e && e.content && e.content.type;
		if (e !== null && (!this._firstCall || e.deleted || !this._filter(n)))
			do
				if (
					((n = e.content.type),
					!e.deleted &&
						(n.constructor === ci || n.constructor === Gu) &&
						n._start !== null)
				)
					e = n._start;
				else
					for (; e !== null; )
						if (e.right !== null) {
							e = e.right;
							break;
						} else
							e.parent === this._root
								? (e = null)
								: (e = e.parent._item);
			while (e !== null && (e.deleted || !this._filter(e.content.type)));
		return (
			(this._firstCall = !1),
			e === null
				? { value: void 0, done: !0 }
				: ((this._currentNode = e), { value: e.content.type, done: !1 })
		);
	}
}
class Gu extends ir {
	constructor() {
		super(), (this._prelimContent = []);
	}
	get firstChild() {
		const e = this._first;
		return e ? e.content.getContent()[0] : null;
	}
	_integrate(e, n) {
		super._integrate(e, n),
			this.insert(0, this._prelimContent),
			(this._prelimContent = null);
	}
	_copy() {
		return new Gu();
	}
	clone() {
		const e = new Gu();
		return (
			e.insert(
				0,
				this.toArray().map((n) => (n instanceof ir ? n.clone() : n)),
			),
			e
		);
	}
	get length() {
		return this._prelimContent === null
			? this._length
			: this._prelimContent.length;
	}
	createTreeWalker(e) {
		return new Ik(this, e);
	}
	querySelector(e) {
		e = e.toUpperCase();
		const r = new Ik(
			this,
			(i) => i.nodeName && i.nodeName.toUpperCase() === e,
		).next();
		return r.done ? null : r.value;
	}
	querySelectorAll(e) {
		return (
			(e = e.toUpperCase()),
			kl(
				new Ik(
					this,
					(n) => n.nodeName && n.nodeName.toUpperCase() === e,
				),
			)
		);
	}
	_callObserver(e, n) {
		i3(this, e, new c1e(this, n, e));
	}
	toString() {
		return DK(this, (e) => e.toString()).join("");
	}
	toJSON() {
		return this.toString();
	}
	toDOM(e = document, n = {}, r) {
		const i = e.createDocumentFragment();
		return (
			r !== void 0 && r._createAssociation(i, this),
			bg(this, (o) => {
				i.insertBefore(o.toDOM(e, n, r), null);
			}),
			i
		);
	}
	insert(e, n) {
		this.doc !== null
			? Gt(this.doc, (r) => {
					$K(r, this, e, n);
				})
			: this._prelimContent.splice(e, 0, ...n);
	}
	insertAfter(e, n) {
		if (this.doc !== null)
			Gt(this.doc, (r) => {
				const i = e && e instanceof ir ? e._item : e;
				Xv(r, this, i, n);
			});
		else {
			const r = this._prelimContent,
				i = e === null ? 0 : r.findIndex((o) => o === e) + 1;
			if (i === 0 && e !== null) throw Uu("Reference item not found");
			r.splice(i, 0, ...n);
		}
	}
	delete(e, n = 1) {
		this.doc !== null
			? Gt(this.doc, (r) => {
					TK(r, this, e, n);
				})
			: this._prelimContent.splice(e, n);
	}
	toArray() {
		return wK(this);
	}
	push(e) {
		this.insert(this.length, e);
	}
	unshift(e) {
		this.insert(0, e);
	}
	get(e) {
		return SK(this, e);
	}
	slice(e = 0, n = this.length) {
		return CK(this, e, n);
	}
	forEach(e) {
		bg(this, e);
	}
	_write(e) {
		e.writeTypeRef(A1e);
	}
}
const l1e = (t) => new Gu();
class ci extends Gu {
	constructor(e = "UNDEFINED") {
		super(), (this.nodeName = e), (this._prelimAttrs = new Map());
	}
	get nextSibling() {
		const e = this._item ? this._item.next : null;
		return e ? e.content.type : null;
	}
	get prevSibling() {
		const e = this._item ? this._item.prev : null;
		return e ? e.content.type : null;
	}
	_integrate(e, n) {
		super._integrate(e, n),
			this._prelimAttrs.forEach((r, i) => {
				this.setAttribute(i, r);
			}),
			(this._prelimAttrs = null);
	}
	_copy() {
		return new ci(this.nodeName);
	}
	clone() {
		const e = new ci(this.nodeName),
			n = this.getAttributes();
		return (
			Age(n, (r, i) => {
				typeof r == "string" && e.setAttribute(i, r);
			}),
			e.insert(
				0,
				this.toArray().map((r) => (r instanceof ir ? r.clone() : r)),
			),
			e
		);
	}
	toString() {
		const e = this.getAttributes(),
			n = [],
			r = [];
		for (const a in e) r.push(a);
		r.sort();
		const i = r.length;
		for (let a = 0; a < i; a++) {
			const l = r[a];
			n.push(l + '="' + e[l] + '"');
		}
		const o = this.nodeName.toLocaleLowerCase(),
			s = n.length > 0 ? " " + n.join(" ") : "";
		return `<${o}${s}>${super.toString()}</${o}>`;
	}
	removeAttribute(e) {
		this.doc !== null
			? Gt(this.doc, (n) => {
					Zv(n, this, e);
				})
			: this._prelimAttrs.delete(e);
	}
	setAttribute(e, n) {
		this.doc !== null
			? Gt(this.doc, (r) => {
					US(r, this, e, n);
				})
			: this._prelimAttrs.set(e, n);
	}
	getAttribute(e) {
		return HS(this, e);
	}
	hasAttribute(e) {
		return IK(this, e);
	}
	getAttributes(e) {
		return e ? Z0e(this, e) : BK(this);
	}
	toDOM(e = document, n = {}, r) {
		const i = e.createElement(this.nodeName),
			o = this.getAttributes();
		for (const s in o) {
			const a = o[s];
			typeof a == "string" && i.setAttribute(s, a);
		}
		return (
			bg(this, (s) => {
				i.appendChild(s.toDOM(e, n, r));
			}),
			r !== void 0 && r._createAssociation(i, this),
			i
		);
	}
	_write(e) {
		e.writeTypeRef(S1e), e.writeKey(this.nodeName);
	}
}
const u1e = (t) => new ci(t.readKey());
class c1e extends n3 {
	constructor(e, n, r) {
		super(e, r),
			(this.childListChanged = !1),
			(this.attributesChanged = new Set()),
			n.forEach((i) => {
				i === null
					? (this.childListChanged = !0)
					: this.attributesChanged.add(i);
			});
	}
}
class Qv extends ba {
	constructor(e) {
		super(), (this.hookName = e);
	}
	_copy() {
		return new Qv(this.hookName);
	}
	clone() {
		const e = new Qv(this.hookName);
		return (
			this.forEach((n, r) => {
				e.set(r, n);
			}),
			e
		);
	}
	toDOM(e = document, n = {}, r) {
		const i = n[this.hookName];
		let o;
		return (
			i !== void 0
				? (o = i.createDom(this))
				: (o = document.createElement(this.hookName)),
			o.setAttribute("data-yjs-hook", this.hookName),
			r !== void 0 && r._createAssociation(o, this),
			o
		);
	}
	_write(e) {
		e.writeTypeRef($1e), e.writeKey(this.hookName);
	}
}
const d1e = (t) => new Qv(t.readKey());
class lo extends qu {
	get nextSibling() {
		const e = this._item ? this._item.next : null;
		return e ? e.content.type : null;
	}
	get prevSibling() {
		const e = this._item ? this._item.prev : null;
		return e ? e.content.type : null;
	}
	_copy() {
		return new lo();
	}
	clone() {
		const e = new lo();
		return e.applyDelta(this.toDelta()), e;
	}
	toDOM(e = document, n, r) {
		const i = e.createTextNode(this.toString());
		return r !== void 0 && r._createAssociation(i, this), i;
	}
	toString() {
		return this.toDelta()
			.map((e) => {
				const n = [];
				for (const i in e.attributes) {
					const o = [];
					for (const s in e.attributes[i])
						o.push({ key: s, value: e.attributes[i][s] });
					o.sort((s, a) => (s.key < a.key ? -1 : 1)),
						n.push({ nodeName: i, attrs: o });
				}
				n.sort((i, o) => (i.nodeName < o.nodeName ? -1 : 1));
				let r = "";
				for (let i = 0; i < n.length; i++) {
					const o = n[i];
					r += `<${o.nodeName}`;
					for (let s = 0; s < o.attrs.length; s++) {
						const a = o.attrs[s];
						r += ` ${a.key}="${a.value}"`;
					}
					r += ">";
				}
				r += e.insert;
				for (let i = n.length - 1; i >= 0; i--)
					r += `</${n[i].nodeName}>`;
				return r;
			})
			.join("");
	}
	toJSON() {
		return this.toString();
	}
	_write(e) {
		e.writeTypeRef(T1e);
	}
}
const f1e = (t) => new lo();
class WS {
	constructor(e, n) {
		(this.id = e), (this.length = n);
	}
	get deleted() {
		throw ws();
	}
	mergeWith(e) {
		return !1;
	}
	write(e, n, r) {
		throw ws();
	}
	integrate(e, n) {
		throw ws();
	}
}
const h1e = 0;
class Ro extends WS {
	get deleted() {
		return !0;
	}
	delete() {}
	mergeWith(e) {
		return this.constructor !== e.constructor
			? !1
			: ((this.length += e.length), !0);
	}
	integrate(e, n) {
		n > 0 && ((this.id.clock += n), (this.length -= n)),
			pK(e.doc.store, this);
	}
	write(e, n) {
		e.writeInfo(h1e), e.writeLen(this.length - n);
	}
	getMissing(e, n) {
		return null;
	}
}
class B0 {
	constructor(e) {
		this.content = e;
	}
	getLength() {
		return 1;
	}
	getContent() {
		return [this.content];
	}
	isCountable() {
		return !0;
	}
	copy() {
		return new B0(this.content);
	}
	splice(e) {
		throw ws();
	}
	mergeWith(e) {
		return !1;
	}
	integrate(e, n) {}
	delete(e) {}
	gc(e) {}
	write(e, n) {
		e.writeBuf(this.content);
	}
	getRef() {
		return 3;
	}
}
const p1e = (t) => new B0(t.readBuf());
class vg {
	constructor(e) {
		this.len = e;
	}
	getLength() {
		return this.len;
	}
	getContent() {
		return [];
	}
	isCountable() {
		return !1;
	}
	copy() {
		return new vg(this.len);
	}
	splice(e) {
		const n = new vg(this.len - e);
		return (this.len = e), n;
	}
	mergeWith(e) {
		return (this.len += e.len), !0;
	}
	integrate(e, n) {
		fg(e.deleteSet, n.id.client, n.id.clock, this.len), n.markDeleted();
	}
	delete(e) {}
	gc(e) {}
	write(e, n) {
		e.writeLen(this.len - n);
	}
	getRef() {
		return 1;
	}
}
const m1e = (t) => new vg(t.readLen()),
	OK = (t, e) =>
		new Ki({ guid: t, ...e, shouldLoad: e.shouldLoad || e.autoLoad || !1 });
class I0 {
	constructor(e) {
		e._item &&
			console.error(
				"This document was already integrated as a sub-document. You should create a second instance instead with the same guid.",
			),
			(this.doc = e);
		const n = {};
		(this.opts = n),
			e.gc || (n.gc = !1),
			e.autoLoad && (n.autoLoad = !0),
			e.meta !== null && (n.meta = e.meta);
	}
	getLength() {
		return 1;
	}
	getContent() {
		return [this.doc];
	}
	isCountable() {
		return !0;
	}
	copy() {
		return new I0(OK(this.doc.guid, this.opts));
	}
	splice(e) {
		throw ws();
	}
	mergeWith(e) {
		return !1;
	}
	integrate(e, n) {
		(this.doc._item = n),
			e.subdocsAdded.add(this.doc),
			this.doc.shouldLoad && e.subdocsLoaded.add(this.doc);
	}
	delete(e) {
		e.subdocsAdded.has(this.doc)
			? e.subdocsAdded.delete(this.doc)
			: e.subdocsRemoved.add(this.doc);
	}
	gc(e) {}
	write(e, n) {
		e.writeString(this.doc.guid), e.writeAny(this.opts);
	}
	getRef() {
		return 9;
	}
}
const g1e = (t) => new I0(OK(t.readString(), t.readAny()));
class Zd {
	constructor(e) {
		this.embed = e;
	}
	getLength() {
		return 1;
	}
	getContent() {
		return [this.embed];
	}
	isCountable() {
		return !0;
	}
	copy() {
		return new Zd(this.embed);
	}
	splice(e) {
		throw ws();
	}
	mergeWith(e) {
		return !1;
	}
	integrate(e, n) {}
	delete(e) {}
	gc(e) {}
	write(e, n) {
		e.writeJSON(this.embed);
	}
	getRef() {
		return 5;
	}
}
const b1e = (t) => new Zd(t.readJSON());
class Yn {
	constructor(e, n) {
		(this.key = e), (this.value = n);
	}
	getLength() {
		return 1;
	}
	getContent() {
		return [];
	}
	isCountable() {
		return !1;
	}
	copy() {
		return new Yn(this.key, this.value);
	}
	splice(e) {
		throw ws();
	}
	mergeWith(e) {
		return !1;
	}
	integrate(e, n) {
		const r = n.parent;
		(r._searchMarker = null), (r._hasFormatting = !0);
	}
	delete(e) {}
	gc(e) {}
	write(e, n) {
		e.writeKey(this.key), e.writeJSON(this.value);
	}
	getRef() {
		return 6;
	}
}
const v1e = (t) => new Yn(t.readKey(), t.readJSON());
class ey {
	constructor(e) {
		this.arr = e;
	}
	getLength() {
		return this.arr.length;
	}
	getContent() {
		return this.arr;
	}
	isCountable() {
		return !0;
	}
	copy() {
		return new ey(this.arr);
	}
	splice(e) {
		const n = new ey(this.arr.slice(e));
		return (this.arr = this.arr.slice(0, e)), n;
	}
	mergeWith(e) {
		return (this.arr = this.arr.concat(e.arr)), !0;
	}
	integrate(e, n) {}
	delete(e) {}
	gc(e) {}
	write(e, n) {
		const r = this.arr.length;
		e.writeLen(r - n);
		for (let i = n; i < r; i++) {
			const o = this.arr[i];
			e.writeString(o === void 0 ? "undefined" : JSON.stringify(o));
		}
	}
	getRef() {
		return 2;
	}
}
const y1e = (t) => {
	const e = t.readLen(),
		n = [];
	for (let r = 0; r < e; r++) {
		const i = t.readString();
		i === "undefined" ? n.push(void 0) : n.push(JSON.parse(i));
	}
	return new ey(n);
};
class Sd {
	constructor(e) {
		this.arr = e;
	}
	getLength() {
		return this.arr.length;
	}
	getContent() {
		return this.arr;
	}
	isCountable() {
		return !0;
	}
	copy() {
		return new Sd(this.arr);
	}
	splice(e) {
		const n = new Sd(this.arr.slice(e));
		return (this.arr = this.arr.slice(0, e)), n;
	}
	mergeWith(e) {
		return (this.arr = this.arr.concat(e.arr)), !0;
	}
	integrate(e, n) {}
	delete(e) {}
	gc(e) {}
	write(e, n) {
		const r = this.arr.length;
		e.writeLen(r - n);
		for (let i = n; i < r; i++) {
			const o = this.arr[i];
			e.writeAny(o);
		}
	}
	getRef() {
		return 8;
	}
}
const x1e = (t) => {
	const e = t.readLen(),
		n = [];
	for (let r = 0; r < e; r++) n.push(t.readAny());
	return new Sd(n);
};
class Bs {
	constructor(e) {
		this.str = e;
	}
	getLength() {
		return this.str.length;
	}
	getContent() {
		return this.str.split("");
	}
	isCountable() {
		return !0;
	}
	copy() {
		return new Bs(this.str);
	}
	splice(e) {
		const n = new Bs(this.str.slice(e));
		this.str = this.str.slice(0, e);
		const r = this.str.charCodeAt(e - 1);
		return (
			r >= 55296 &&
				r <= 56319 &&
				((this.str = this.str.slice(0, e - 1) + "�"),
				(n.str = "�" + n.str.slice(1))),
			n
		);
	}
	mergeWith(e) {
		return (this.str += e.str), !0;
	}
	integrate(e, n) {}
	delete(e) {}
	gc(e) {}
	write(e, n) {
		e.writeString(n === 0 ? this.str : this.str.slice(n));
	}
	getRef() {
		return 4;
	}
}
const k1e = (t) => new Bs(t.readString()),
	C1e = [e1e, n1e, a1e, u1e, l1e, d1e, f1e],
	w1e = 0,
	E1e = 1,
	D1e = 2,
	S1e = 3,
	A1e = 4,
	$1e = 5,
	T1e = 6;
class js {
	constructor(e) {
		this.type = e;
	}
	getLength() {
		return 1;
	}
	getContent() {
		return [this.type];
	}
	isCountable() {
		return !0;
	}
	copy() {
		return new js(this.type._copy());
	}
	splice(e) {
		throw ws();
	}
	mergeWith(e) {
		return !1;
	}
	integrate(e, n) {
		this.type._integrate(e.doc, n);
	}
	delete(e) {
		let n = this.type._start;
		for (; n !== null; )
			n.deleted
				? n.id.clock < (e.beforeState.get(n.id.client) || 0) &&
					e._mergeStructs.push(n)
				: n.delete(e),
				(n = n.right);
		this.type._map.forEach((r) => {
			r.deleted
				? r.id.clock < (e.beforeState.get(r.id.client) || 0) &&
					e._mergeStructs.push(r)
				: r.delete(e);
		}),
			e.changed.delete(this.type);
	}
	gc(e) {
		let n = this.type._start;
		for (; n !== null; ) n.gc(e, !0), (n = n.right);
		(this.type._start = null),
			this.type._map.forEach((r) => {
				for (; r !== null; ) r.gc(e, !0), (r = r.left);
			}),
			(this.type._map = new Map());
	}
	write(e, n) {
		this.type._write(e);
	}
	getRef() {
		return 7;
	}
}
const B1e = (t) => new js(C1e[t.readTypeRef()](t)),
	s2 = (t, e) => {
		let n = e,
			r = 0,
			i;
		do
			r > 0 && (n = gt(n.client, n.clock + r)),
				(i = ah(t, n)),
				(r = n.clock - i.id.clock),
				(n = i.redone);
		while (n !== null && i instanceof Qt);
		return { item: i, diff: r };
	},
	qS = (t, e) => {
		for (; t !== null && t.keep !== e; ) (t.keep = e), (t = t.parent._item);
	},
	ty = (t, e, n) => {
		const { client: r, clock: i } = e.id,
			o = new Qt(
				gt(r, i + n),
				e,
				gt(r, i + n - 1),
				e.right,
				e.rightOrigin,
				e.parent,
				e.parentSub,
				e.content.splice(n),
			);
		return (
			e.deleted && o.markDeleted(),
			e.keep && (o.keep = !0),
			e.redone !== null &&
				(o.redone = gt(e.redone.client, e.redone.clock + n)),
			(e.right = o),
			o.right !== null && (o.right.left = o),
			t._mergeStructs.push(o),
			o.parentSub !== null &&
				o.right === null &&
				o.parent._map.set(o.parentSub, o),
			(e.length = n),
			o
		);
	},
	FB = (t, e) => Yme(t, (n) => ip(n.deletions, e)),
	MK = (t, e, n, r, i, o) => {
		const s = t.doc,
			a = s.store,
			l = s.clientID,
			u = e.redone;
		if (u !== null) return Fi(t, u);
		let c = e.parent._item,
			d = null,
			f;
		if (c !== null && c.deleted === !0) {
			if (
				c.redone === null &&
				(!n.has(c) || MK(t, c, n, r, i, o) === null)
			)
				return null;
			for (; c.redone !== null; ) c = Fi(t, c.redone);
		}
		const h = c === null ? e.parent : c.content.type;
		if (e.parentSub === null) {
			for (d = e.left, f = e; d !== null; ) {
				let b = d;
				for (; b !== null && b.parent._item !== c; )
					b = b.redone === null ? null : Fi(t, b.redone);
				if (b !== null && b.parent._item === c) {
					d = b;
					break;
				}
				d = d.left;
			}
			for (; f !== null; ) {
				let b = f;
				for (; b !== null && b.parent._item !== c; )
					b = b.redone === null ? null : Fi(t, b.redone);
				if (b !== null && b.parent._item === c) {
					f = b;
					break;
				}
				f = f.right;
			}
		} else if (((f = null), e.right && !i)) {
			for (
				d = e;
				d !== null &&
				d.right !== null &&
				(d.right.redone ||
					ip(r, d.right.id) ||
					FB(o.undoStack, d.right.id) ||
					FB(o.redoStack, d.right.id));

			)
				for (d = d.right; d.redone; ) d = Fi(t, d.redone);
			if (d && d.right !== null) return null;
		} else d = h._map.get(e.parentSub) || null;
		const p = Nn(a, l),
			g = gt(l, p),
			v = new Qt(
				g,
				d,
				d && d.lastId,
				f,
				f && f.id,
				h,
				e.parentSub,
				e.content.copy(),
			);
		return (e.redone = g), qS(v, !0), v.integrate(t, 0), v;
	};
let Qt = class a2 extends WS {
	constructor(e, n, r, i, o, s, a, l) {
		super(e, l.getLength()),
			(this.origin = r),
			(this.left = n),
			(this.right = i),
			(this.rightOrigin = o),
			(this.parent = s),
			(this.parentSub = a),
			(this.redone = null),
			(this.content = l),
			(this.info = this.content.isCountable() ? aB : 0);
	}
	set marker(e) {
		(this.info & wk) > 0 !== e && (this.info ^= wk);
	}
	get marker() {
		return (this.info & wk) > 0;
	}
	get keep() {
		return (this.info & sB) > 0;
	}
	set keep(e) {
		this.keep !== e && (this.info ^= sB);
	}
	get countable() {
		return (this.info & aB) > 0;
	}
	get deleted() {
		return (this.info & Ck) > 0;
	}
	set deleted(e) {
		this.deleted !== e && (this.info ^= Ck);
	}
	markDeleted() {
		this.info |= Ck;
	}
	getMissing(e, n) {
		if (
			this.origin &&
			this.origin.client !== this.id.client &&
			this.origin.clock >= Nn(n, this.origin.client)
		)
			return this.origin.client;
		if (
			this.rightOrigin &&
			this.rightOrigin.client !== this.id.client &&
			this.rightOrigin.clock >= Nn(n, this.rightOrigin.client)
		)
			return this.rightOrigin.client;
		if (
			this.parent &&
			this.parent.constructor === sh &&
			this.id.client !== this.parent.client &&
			this.parent.clock >= Nn(n, this.parent.client)
		)
			return this.parent.client;
		if (
			(this.origin &&
				((this.left = wB(e, n, this.origin)),
				(this.origin = this.left.lastId)),
			this.rightOrigin &&
				((this.right = Fi(e, this.rightOrigin)),
				(this.rightOrigin = this.right.id)),
			(this.left && this.left.constructor === Ro) ||
				(this.right && this.right.constructor === Ro))
		)
			this.parent = null;
		else if (!this.parent)
			this.left &&
				this.left.constructor === a2 &&
				((this.parent = this.left.parent),
				(this.parentSub = this.left.parentSub)),
				this.right &&
					this.right.constructor === a2 &&
					((this.parent = this.right.parent),
					(this.parentSub = this.right.parentSub));
		else if (this.parent.constructor === sh) {
			const r = ah(n, this.parent);
			r.constructor === Ro
				? (this.parent = null)
				: (this.parent = r.content.type);
		}
		return null;
	}
	integrate(e, n) {
		if (
			(n > 0 &&
				((this.id.clock += n),
				(this.left = wB(
					e,
					e.doc.store,
					gt(this.id.client, this.id.clock - 1),
				)),
				(this.origin = this.left.lastId),
				(this.content = this.content.splice(n)),
				(this.length -= n)),
			this.parent)
		) {
			if (
				(!this.left && (!this.right || this.right.left !== null)) ||
				(this.left && this.left.right !== this.right)
			) {
				let r = this.left,
					i;
				if (r !== null) i = r.right;
				else if (this.parentSub !== null)
					for (
						i = this.parent._map.get(this.parentSub) || null;
						i !== null && i.left !== null;

					)
						i = i.left;
				else i = this.parent._start;
				const o = new Set(),
					s = new Set();
				for (; i !== null && i !== this.right; ) {
					if ((s.add(i), o.add(i), Lf(this.origin, i.origin))) {
						if (i.id.client < this.id.client) (r = i), o.clear();
						else if (Lf(this.rightOrigin, i.rightOrigin)) break;
					} else if (
						i.origin !== null &&
						s.has(ah(e.doc.store, i.origin))
					)
						o.has(ah(e.doc.store, i.origin)) ||
							((r = i), o.clear());
					else break;
					i = i.right;
				}
				this.left = r;
			}
			if (this.left !== null) {
				const r = this.left.right;
				(this.right = r), (this.left.right = this);
			} else {
				let r;
				if (this.parentSub !== null)
					for (
						r = this.parent._map.get(this.parentSub) || null;
						r !== null && r.left !== null;

					)
						r = r.left;
				else (r = this.parent._start), (this.parent._start = this);
				this.right = r;
			}
			this.right !== null
				? (this.right.left = this)
				: this.parentSub !== null &&
					(this.parent._map.set(this.parentSub, this),
					this.left !== null && this.left.delete(e)),
				this.parentSub === null &&
					this.countable &&
					!this.deleted &&
					(this.parent._length += this.length),
				pK(e.doc.store, this),
				this.content.integrate(e, this),
				DB(e, this.parent, this.parentSub),
				((this.parent._item !== null && this.parent._item.deleted) ||
					(this.parentSub !== null && this.right !== null)) &&
					this.delete(e);
		} else new Ro(this.id, this.length).integrate(e, 0);
	}
	get next() {
		let e = this.right;
		for (; e !== null && e.deleted; ) e = e.right;
		return e;
	}
	get prev() {
		let e = this.left;
		for (; e !== null && e.deleted; ) e = e.left;
		return e;
	}
	get lastId() {
		return this.length === 1
			? this.id
			: gt(this.id.client, this.id.clock + this.length - 1);
	}
	mergeWith(e) {
		if (
			this.constructor === e.constructor &&
			Lf(e.origin, this.lastId) &&
			this.right === e &&
			Lf(this.rightOrigin, e.rightOrigin) &&
			this.id.client === e.id.client &&
			this.id.clock + this.length === e.id.clock &&
			this.deleted === e.deleted &&
			this.redone === null &&
			e.redone === null &&
			this.content.constructor === e.content.constructor &&
			this.content.mergeWith(e.content)
		) {
			const n = this.parent._searchMarker;
			return (
				n &&
					n.forEach((r) => {
						r.p === e &&
							((r.p = this),
							!this.deleted &&
								this.countable &&
								(r.index -= this.length));
					}),
				e.keep && (this.keep = !0),
				(this.right = e.right),
				this.right !== null && (this.right.left = this),
				(this.length += e.length),
				!0
			);
		}
		return !1;
	}
	delete(e) {
		if (!this.deleted) {
			const n = this.parent;
			this.countable &&
				this.parentSub === null &&
				(n._length -= this.length),
				this.markDeleted(),
				fg(e.deleteSet, this.id.client, this.id.clock, this.length),
				DB(e, n, this.parentSub),
				this.content.delete(e);
		}
	}
	gc(e, n) {
		if (!this.deleted) throw go();
		this.content.gc(e),
			n
				? P0e(e, this, new Ro(this.id, this.length))
				: (this.content = new vg(this.length));
	}
	write(e, n) {
		const r =
				n > 0 ? gt(this.id.client, this.id.clock + n - 1) : this.origin,
			i = this.rightOrigin,
			o = this.parentSub,
			s =
				(this.content.getRef() & Zx) |
				(r === null ? 0 : ao) |
				(i === null ? 0 : ol) |
				(o === null ? 0 : ag);
		if (
			(e.writeInfo(s),
			r !== null && e.writeLeftID(r),
			i !== null && e.writeRightID(i),
			r === null && i === null)
		) {
			const a = this.parent;
			if (a._item !== void 0) {
				const l = a._item;
				if (l === null) {
					const u = hg(a);
					e.writeParentInfo(!0), e.writeString(u);
				} else e.writeParentInfo(!1), e.writeLeftID(l.id);
			} else
				a.constructor === String
					? (e.writeParentInfo(!0), e.writeString(a))
					: a.constructor === sh
						? (e.writeParentInfo(!1), e.writeLeftID(a))
						: go();
			o !== null && e.writeString(o);
		}
		this.content.write(e, n);
	}
};
const jK = (t, e) => I1e[e & Zx](t),
	I1e = [
		() => {
			go();
		},
		m1e,
		y1e,
		p1e,
		k1e,
		b1e,
		v1e,
		B1e,
		x1e,
		g1e,
		() => {
			go();
		},
	],
	F1e = 10;
class no extends WS {
	get deleted() {
		return !0;
	}
	delete() {}
	mergeWith(e) {
		return this.constructor !== e.constructor
			? !1
			: ((this.length += e.length), !0);
	}
	integrate(e, n) {
		go();
	}
	write(e, n) {
		e.writeInfo(F1e), Oe(e.restEncoder, this.length - n);
	}
	getMissing(e, n) {
		return null;
	}
}
const _K =
		typeof globalThis < "u"
			? globalThis
			: typeof window < "u"
				? window
				: typeof global < "u"
					? global
					: {},
	zK = "__ $YJS$ __";
_K[zK] === !0 &&
	console.error(
		"Yjs was already imported. This breaks constructor checks and will lead to issues! - https://github.com/yjs/yjs/issues/438",
	);
_K[zK] = !0;
const Fk = 3e4;
class P1e extends Dge {
	constructor(e) {
		super(),
			(this.doc = e),
			(this.clientID = e.clientID),
			(this.states = new Map()),
			(this.meta = new Map()),
			(this._checkInterval = setInterval(
				() => {
					const n = Hu();
					this.getLocalState() !== null &&
						Fk / 2 <=
							n - this.meta.get(this.clientID).lastUpdated &&
						this.setLocalState(this.getLocalState());
					const r = [];
					this.meta.forEach((i, o) => {
						o !== this.clientID &&
							Fk <= n - i.lastUpdated &&
							this.states.has(o) &&
							r.push(o);
					}),
						r.length > 0 && GS(this, r, "timeout");
				},
				ma(Fk / 10),
			)),
			e.on("destroy", () => {
				this.destroy();
			}),
			this.setLocalState({});
	}
	destroy() {
		this.emit("destroy", [this]),
			this.setLocalState(null),
			super.destroy(),
			clearInterval(this._checkInterval);
	}
	getLocalState() {
		return this.states.get(this.clientID) || null;
	}
	setLocalState(e) {
		const n = this.clientID,
			r = this.meta.get(n),
			i = r === void 0 ? 0 : r.clock + 1,
			o = this.states.get(n);
		e === null ? this.states.delete(n) : this.states.set(n, e),
			this.meta.set(n, { clock: i, lastUpdated: Hu() });
		const s = [],
			a = [],
			l = [],
			u = [];
		e === null
			? u.push(n)
			: o == null
				? e != null && s.push(n)
				: (a.push(n), Em(o, e) || l.push(n)),
			(s.length > 0 || l.length > 0 || u.length > 0) &&
				this.emit("change", [
					{ added: s, updated: l, removed: u },
					"local",
				]),
			this.emit("update", [
				{ added: s, updated: a, removed: u },
				"local",
			]);
	}
	setLocalStateField(e, n) {
		const r = this.getLocalState();
		r !== null && this.setLocalState({ ...r, [e]: n });
	}
	getStates() {
		return this.states;
	}
}
const GS = (t, e, n) => {
		const r = [];
		for (let i = 0; i < e.length; i++) {
			const o = e[i];
			if (t.states.has(o)) {
				if ((t.states.delete(o), o === t.clientID)) {
					const s = t.meta.get(o);
					t.meta.set(o, { clock: s.clock + 1, lastUpdated: Hu() });
				}
				r.push(o);
			}
		}
		r.length > 0 &&
			(t.emit("change", [{ added: [], updated: [], removed: r }, n]),
			t.emit("update", [{ added: [], updated: [], removed: r }, n]));
	},
	nm = (t, e, n = t.states) => {
		const r = e.length,
			i = In();
		Oe(i, r);
		for (let o = 0; o < r; o++) {
			const s = e[o],
				a = n.get(s) || null,
				l = t.meta.get(s).clock;
			Oe(i, s), Oe(i, l), aa(i, JSON.stringify(a));
		}
		return Kt(i);
	},
	N1e = (t, e, n) => {
		const r = Vi(e),
			i = Hu(),
			o = [],
			s = [],
			a = [],
			l = [],
			u = nt(r);
		for (let c = 0; c < u; c++) {
			const d = nt(r);
			let f = nt(r);
			const h = JSON.parse(Es(r)),
				p = t.meta.get(d),
				g = t.states.get(d),
				v = p === void 0 ? 0 : p.clock;
			(v < f || (v === f && h === null && t.states.has(d))) &&
				(h === null
					? d === t.clientID && t.getLocalState() != null
						? f++
						: t.states.delete(d)
					: t.states.set(d, h),
				t.meta.set(d, { clock: f, lastUpdated: i }),
				p === void 0 && h !== null
					? o.push(d)
					: p !== void 0 && h === null
						? l.push(d)
						: h !== null && (Em(h, g) || a.push(d), s.push(d)));
		}
		(o.length > 0 || a.length > 0 || l.length > 0) &&
			t.emit("change", [{ added: o, updated: a, removed: l }, n]),
			(o.length > 0 || s.length > 0 || l.length > 0) &&
				t.emit("update", [{ added: o, updated: s, removed: l }, n]);
	},
	R1e = (t, e) => e.some((n) => t instanceof n);
let PB, NB;
function O1e() {
	return (
		PB ||
		(PB = [
			IDBDatabase,
			IDBObjectStore,
			IDBIndex,
			IDBCursor,
			IDBTransaction,
		])
	);
}
function M1e() {
	return (
		NB ||
		(NB = [
			IDBCursor.prototype.advance,
			IDBCursor.prototype.continue,
			IDBCursor.prototype.continuePrimaryKey,
		])
	);
}
const LK = new WeakMap(),
	l2 = new WeakMap(),
	VK = new WeakMap(),
	Pk = new WeakMap(),
	YS = new WeakMap();
function j1e(t) {
	const e = new Promise((n, r) => {
		const i = () => {
				t.removeEventListener("success", o),
					t.removeEventListener("error", s);
			},
			o = () => {
				n($u(t.result)), i();
			},
			s = () => {
				r(t.error), i();
			};
		t.addEventListener("success", o), t.addEventListener("error", s);
	});
	return (
		e
			.then((n) => {
				n instanceof IDBCursor && LK.set(n, t);
			})
			.catch(() => {}),
		YS.set(e, t),
		e
	);
}
function _1e(t) {
	if (l2.has(t)) return;
	const e = new Promise((n, r) => {
		const i = () => {
				t.removeEventListener("complete", o),
					t.removeEventListener("error", s),
					t.removeEventListener("abort", s);
			},
			o = () => {
				n(), i();
			},
			s = () => {
				r(t.error || new DOMException("AbortError", "AbortError")), i();
			};
		t.addEventListener("complete", o),
			t.addEventListener("error", s),
			t.addEventListener("abort", s);
	});
	l2.set(t, e);
}
let u2 = {
	get(t, e, n) {
		if (t instanceof IDBTransaction) {
			if (e === "done") return l2.get(t);
			if (e === "objectStoreNames")
				return t.objectStoreNames || VK.get(t);
			if (e === "store")
				return n.objectStoreNames[1]
					? void 0
					: n.objectStore(n.objectStoreNames[0]);
		}
		return $u(t[e]);
	},
	set(t, e, n) {
		return (t[e] = n), !0;
	},
	has(t, e) {
		return t instanceof IDBTransaction && (e === "done" || e === "store")
			? !0
			: e in t;
	},
};
function z1e(t) {
	u2 = t(u2);
}
function L1e(t) {
	return t === IDBDatabase.prototype.transaction &&
		!("objectStoreNames" in IDBTransaction.prototype)
		? function (e, ...n) {
				const r = t.call(Nk(this), e, ...n);
				return VK.set(r, e.sort ? e.sort() : [e]), $u(r);
			}
		: M1e().includes(t)
			? function (...e) {
					return t.apply(Nk(this), e), $u(LK.get(this));
				}
			: function (...e) {
					return $u(t.apply(Nk(this), e));
				};
}
function V1e(t) {
	return typeof t == "function"
		? L1e(t)
		: (t instanceof IDBTransaction && _1e(t),
			R1e(t, O1e()) ? new Proxy(t, u2) : t);
}
function $u(t) {
	if (t instanceof IDBRequest) return j1e(t);
	if (Pk.has(t)) return Pk.get(t);
	const e = V1e(t);
	return e !== t && (Pk.set(t, e), YS.set(e, t)), e;
}
const Nk = (t) => YS.get(t);
function K1e(
	t,
	e,
	{ blocked: n, upgrade: r, blocking: i, terminated: o } = {},
) {
	const s = indexedDB.open(t, e),
		a = $u(s);
	return (
		r &&
			s.addEventListener("upgradeneeded", (l) => {
				r(
					$u(s.result),
					l.oldVersion,
					l.newVersion,
					$u(s.transaction),
					l,
				);
			}),
		n &&
			s.addEventListener("blocked", (l) =>
				n(l.oldVersion, l.newVersion, l),
			),
		a
			.then((l) => {
				o && l.addEventListener("close", () => o()),
					i &&
						l.addEventListener("versionchange", (u) =>
							i(u.oldVersion, u.newVersion, u),
						);
			})
			.catch(() => {}),
		a
	);
}
const U1e = ["get", "getKey", "getAll", "getAllKeys", "count"],
	H1e = ["put", "add", "delete", "clear"],
	Rk = new Map();
function RB(t, e) {
	if (!(t instanceof IDBDatabase && !(e in t) && typeof e == "string"))
		return;
	if (Rk.get(e)) return Rk.get(e);
	const n = e.replace(/FromIndex$/, ""),
		r = e !== n,
		i = H1e.includes(n);
	if (
		!(n in (r ? IDBIndex : IDBObjectStore).prototype) ||
		!(i || U1e.includes(n))
	)
		return;
	const o = async function (s, ...a) {
		const l = this.transaction(s, i ? "readwrite" : "readonly");
		let u = l.store;
		return (
			r && (u = u.index(a.shift())),
			(await Promise.all([u[n](...a), i && l.done]))[0]
		);
	};
	return Rk.set(e, o), o;
}
z1e((t) => ({
	...t,
	get: (e, n, r) => RB(e, n) || t.get(e, n, r),
	has: (e, n) => !!RB(e, n) || t.has(e, n),
}));
function OB(t, e = "val does not exist") {
	if (t == null) throw e instanceof Error ? e : new Error(e);
}
function KK(t, e) {
	if (t.guid === e) return t;
	for (const n of t.subdocs) {
		const r = KK(n, e);
		if (r) return r;
	}
}
const W1e = (t, e, n = {}) => {
		let r = !1;
		const i = new Map(),
			o = new Map(),
			s = new Set();
		let a = null;
		const { origin: l = "lazy-provider" } = n;
		let u = { type: "idle" },
			c = 0;
		const d = new Set(),
			f = (w) => {
				w.type === "syncing"
					? c++
					: (w.type === "synced" || w.type === "error") && c--,
					c < 0 &&
						console.error(
							"syncingStatus < 0, this should not happen",
							n.origin,
						),
					c === 0 && (u = w),
					w.type !== "synced" && (u = w),
					c === 0 &&
						(r ? (u = { type: "synced" }) : (u = { type: "idle" })),
					d.forEach((D) => D());
			};
		async function h(w) {
			const D = w.guid;
			{
				const $ = D.startsWith("space:") ? D.slice(6) : D,
					A = `${t.guid}:space:${$}`,
					T = `space:${$}`,
					I = await e.queryDocState(A),
					F = await e.queryDocState(T);
				let N = !1;
				I &&
					I.missing.length !== 2 &&
					I.missing[0] !== 0 &&
					I.missing[1] !== 0 &&
					(Ec(w, I.missing, l), (N = !0)),
					F &&
						F.missing.length !== 2 &&
						F.missing[0] !== 0 &&
						F.missing[1] !== 0 &&
						(Ec(w, F.missing, l), (N = !0)),
					N &&
						(await e.sendDocUpdate(
							D,
							Yv(w, I ? I.state : F ? F.state : void 0),
						));
			}
			if (!r) return;
			f({ type: "syncing" });
			const S = await e
				.queryDocState(D, { stateVector: cK(w) })
				.then(($) => (f({ type: "synced" }), $))
				.catch(($) => {
					throw (f({ type: "error", error: $ }), $);
				});
			i.set(D, []),
				S && Ec(w, S.missing, l),
				r &&
					(await e.sendDocUpdate(D, Yv(w, S ? S.state : void 0)),
					w.emit("sync", []));
		}
		function p(w) {
			const D = new Set();
			o.set(w.guid, D);
			const S = async (A, T) => {
					l !== T &&
						(f({ type: "syncing" }),
						e
							.sendDocUpdate(w.guid, A)
							.then(() => {
								f({ type: "synced" });
							})
							.catch((I) => {
								f({ type: "error", error: I }),
									console.error(I);
							}));
				},
				$ = (A) => {
					A.loaded.forEach((T) => {
						v(T).catch(console.error);
					}),
						A.removed.forEach((T) => {
							b(T);
						});
				};
			w.on("update", S),
				w.on("subdocs", $),
				D.add(() => {
					w.off("update", S), w.off("subdocs", $);
				});
		}
		function g() {
			var w;
			OB(a, "abortController should be defined");
			const D =
				(w = e.onDocUpdate) == null
					? void 0
					: w.call(e, (S, $) => {
							var A;
							f({ type: "syncing" });
							const T = KK(t, S);
							T
								? (Ec(T, $, l),
									i.has(S) &&
										((A = i.get(S)) == null ||
											A.forEach((I) => Ec(T, I, l)),
										i.delete(S)))
								: (console.warn("doc not found", S),
									i.set(S, (i.get(S) ?? []).concat($))),
								f({ type: "synced" });
						});
			a.signal.addEventListener("abort", () => {
				D == null || D();
			});
		}
		async function v(w) {
			s.has(w.guid) ||
				(s.add(w.guid),
				p(w),
				await h(w),
				await Promise.all(
					[...w.subdocs].filter((D) => D.shouldLoad).map((D) => v(D)),
				));
		}
		function b(w) {
			s.delete(w.guid);
			const D = o.get(w.guid);
			D && (D.forEach((S) => S()), o.delete(w.guid)),
				w.subdocs.forEach(b);
		}
		function y() {
			o.forEach((w) => {
				w.forEach((D) => D());
			}),
				o.clear(),
				s.clear();
		}
		function x() {
			(r = !0),
				(a = new AbortController()),
				f({ type: "syncing" }),
				v(t)
					.then(() => {
						f({ type: "synced" });
					})
					.catch((w) => {
						f({ type: "error", error: w }), console.error(w);
					}),
				g();
		}
		async function C() {
			(r = !1),
				y(),
				OB(a, "abortController should be defined"),
				a.abort(),
				(a = null);
		}
		const k = async (w) => {
			await h(w),
				await Promise.all([...w.subdocs.values()].map((D) => k(D)));
		};
		return {
			sync: async (w) => {
				r = !0;
				try {
					w ? await h(t) : await k(t);
				} finally {
					r = !1;
				}
			},
			get status() {
				return u;
			},
			subscribeStatusChange(w) {
				return (
					d.add(w),
					() => {
						d.delete(w);
					}
				);
			},
			get connected() {
				return r;
			},
			passive: !0,
			connect: x,
			disconnect: C,
			datasource: e,
		};
	},
	MB = (t) => (
		t.preventDefault(),
		(t.returnValue = "Data is not saved. Are you sure you want to leave?")
	),
	q1e = async (t) => {
		window.addEventListener("beforeunload", MB, { capture: !0 }),
			await t,
			window.removeEventListener("beforeunload", MB, { capture: !0 });
	},
	G1e = 1,
	UK = "affine-local";
function Y1e(t) {
	t.createObjectStore("workspace", { keyPath: "id" }),
		t.createObjectStore("milestone", { keyPath: "id" });
}
function jB(t, e = "val does not exist") {
	if (t == null) throw e instanceof Error ? e : new Error(e);
}
function _B(t) {
	const e = new Ki();
	return (
		t.forEach((n) => {
			Ec(e, n);
		}),
		Yv(e)
	);
}
let J1e = 500;
const X1e = ({ dbName: t = UK, mergeCount: e }) => {
		let n = null;
		const r = async () => (
			n === null && (n = K1e(t, G1e, { upgrade: Y1e })), n
		);
		return {
			queryDocState: async (i, o) => {
				var s;
				try {
					const a = await (await r())
						.transaction("workspace", "readonly")
						.objectStore("workspace")
						.get(i);
					if (!a) return !1;
					const { updates: l } = a,
						u = _B(l.map(({ update: c }) => c));
					return {
						missing:
							o != null && o.stateVector
								? K0e(u, o == null ? void 0 : o.stateVector)
								: u,
						state: L0e(u),
					};
				} catch (a) {
					if (
						!(
							(s = a.message) != null &&
							s.includes("The database connection is closing.")
						)
					)
						throw a;
					return !1;
				}
			},
			sendDocUpdate: async (i, o) => {
				var s;
				try {
					const a = (await r())
							.transaction("workspace", "readwrite")
							.objectStore("workspace"),
						{ updates: l } = (await a.get(i)) ?? { updates: [] };
					let u = [...l, { timestamp: Date.now(), update: o }];
					if (e && u.length >= e) {
						const c = _B(u.map(({ update: d }) => d));
						u = [{ timestamp: Date.now(), update: c }];
					}
					await q1e(a.put({ id: i, updates: u }));
				} catch (a) {
					if (
						!(
							(s = a.message) != null &&
							s.includes("The database connection is closing.")
						)
					)
						throw a;
				}
			},
			disconnect: () => {
				r()
					.then((i) => i.close())
					.then(() => {
						n = null;
					})
					.catch(console.error);
			},
			cleanup: async () => {
				await (await r()).clear("workspace");
			},
		};
	},
	Z1e = (t, e = UK) => {
		const n = X1e({ dbName: e, mergeCount: J1e });
		let r = null;
		const i = {
			get status() {
				return jB(r), r.status;
			},
			subscribeStatusChange(o) {
				return jB(r), r.subscribeStatusChange(o);
			},
			connect: () => {
				i.connected && i.disconnect(),
					(r = W1e(t, n, { origin: "idb" })),
					r.connect();
			},
			disconnect: () => {
				n == null || n.disconnect(),
					r == null || r.disconnect(),
					(r = null);
			},
			cleanup: async () => {
				await (n == null ? void 0 : n.cleanup());
			},
			get connected() {
				return (r == null ? void 0 : r.connected) || !1;
			},
			datasource: n,
		};
		return i;
	},
	HK = new Map();
class Q1e {
	constructor(e) {
		(this.room = e),
			(this.onmessage = null),
			(this._onChange = (n) =>
				n.key === e &&
				this.onmessage !== null &&
				this.onmessage({ data: Zge(n.newValue || "") })),
			zge(this._onChange);
	}
	postMessage(e) {
		GV.setItem(this.room, Xge(Wge(e)));
	}
	close() {
		Lge(this._onChange);
	}
}
const ebe = typeof BroadcastChannel > "u" ? Q1e : BroadcastChannel,
	JS = (t) =>
		Ms(HK, t, () => {
			const e = xl(),
				n = new ebe(t);
			return (
				(n.onmessage = (r) =>
					e.forEach((i) => i(r.data, "broadcastchannel"))),
				{ bc: n, subs: e }
			);
		}),
	tbe = (t, e) => (JS(t).subs.add(e), e),
	nbe = (t, e) => {
		const n = JS(t),
			r = n.subs.delete(e);
		return r && n.subs.size === 0 && (n.bc.close(), HK.delete(t)), r;
	},
	Tf = (t, e, n = null) => {
		const r = JS(t);
		r.bc.postMessage(e), r.subs.forEach((i) => i(e, n));
	},
	WK = 0,
	o3 = 1,
	qK = 2,
	M1 = (t, e) => {
		Oe(t, WK);
		const n = cK(e);
		Fn(t, n);
	},
	GK = (t, e, n) => {
		Oe(t, o3), Fn(t, Yv(e, n));
	},
	rbe = (t, e, n) => GK(e, n, ur(t)),
	YK = (t, e, n) => {
		try {
			Ec(e, ur(t), n);
		} catch (r) {
			console.error("Caught error while handling a Yjs update", r);
		}
	},
	zB = (t, e) => {
		Oe(t, qK), Fn(t, e);
	},
	ibe = YK,
	JK = (t, e, n, r) => {
		const i = nt(t);
		switch (i) {
			case WK:
				rbe(t, e, n);
				break;
			case o3:
				YK(t, n, r);
				break;
			case qK:
				ibe(t, n, r);
				break;
			default:
				throw new Error("Unknown message type");
		}
		return i;
	},
	obe = 0,
	sbe = (t, e, n) => {
		switch (nt(t)) {
			case obe:
				n(e, Es(t));
		}
	},
	XK = () => {
		let t = !0;
		return (e, n) => {
			if (t) {
				t = !1;
				try {
					e();
				} finally {
					t = !0;
				}
			} else n !== void 0 && n();
		};
	};
var ZK = function (e) {
	var n = new WeakMap();
	return function (r) {
		if (n.has(r)) return n.get(r);
		var i = e(r);
		return n.set(r, i), i;
	};
};
/*!
 * cookie
 * Copyright(c) 2012-2014 Roman Shtylman
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */ var QK = abe;
function abe(t, e) {
	if (typeof t != "string")
		throw new TypeError("argument str must be a string");
	for (var n = {}, r = e || {}, i = r.decode || lbe, o = 0; o < t.length; ) {
		var s = t.indexOf("=", o);
		if (s === -1) break;
		var a = t.indexOf(";", o);
		if (a === -1) a = t.length;
		else if (a < s) {
			o = t.lastIndexOf(";", s - 1) + 1;
			continue;
		}
		var l = t.slice(o, s).trim();
		if (n[l] === void 0) {
			var u = t.slice(s + 1, a).trim();
			u.charCodeAt(0) === 34 && (u = u.slice(1, -1)), (n[l] = ube(u, i));
		}
		o = a + 1;
	}
	return n;
}
function lbe(t) {
	return t.indexOf("%") !== -1 ? decodeURIComponent(t) : t;
}
function ube(t, e) {
	try {
		return e(t);
	} catch {
		return t;
	}
}
function Ok(t, e) {
	if (!!!t) throw new Error(e);
}
function cbe(t) {
	return typeof t == "object" && t !== null;
}
function dbe(t, e) {
	if (!!!t) throw new Error("Unexpected invariant triggered.");
}
const fbe = /\r\n|[\n\r]/g;
function c2(t, e) {
	let n = 0,
		r = 1;
	for (const i of t.body.matchAll(fbe)) {
		if ((typeof i.index == "number" || dbe(!1), i.index >= e)) break;
		(n = i.index + i[0].length), (r += 1);
	}
	return { line: r, column: e + 1 - n };
}
function hbe(t) {
	return eU(t.source, c2(t.source, t.start));
}
function eU(t, e) {
	const n = t.locationOffset.column - 1,
		r = "".padStart(n) + t.body,
		i = e.line - 1,
		o = t.locationOffset.line - 1,
		s = e.line + o,
		a = e.line === 1 ? n : 0,
		l = e.column + a,
		u = `${t.name}:${s}:${l}
`,
		c = r.split(/\r\n|[\n\r]/g),
		d = c[i];
	if (d.length > 120) {
		const f = Math.floor(l / 80),
			h = l % 80,
			p = [];
		for (let g = 0; g < d.length; g += 80) p.push(d.slice(g, g + 80));
		return (
			u +
			LB([
				[`${s} |`, p[0]],
				...p.slice(1, f + 1).map((g) => ["|", g]),
				["|", "^".padStart(h)],
				["|", p[f + 1]],
			])
		);
	}
	return (
		u +
		LB([
			[`${s - 1} |`, c[i - 1]],
			[`${s} |`, d],
			["|", "^".padStart(l)],
			[`${s + 1} |`, c[i + 1]],
		])
	);
}
function LB(t) {
	const e = t.filter(([r, i]) => i !== void 0),
		n = Math.max(...e.map(([r]) => r.length));
	return e.map(([r, i]) => r.padStart(n) + (i ? " " + i : "")).join(`
`);
}
function pbe(t) {
	const e = t[0];
	return e == null || "kind" in e || "length" in e
		? {
				nodes: e,
				source: t[1],
				positions: t[2],
				path: t[3],
				originalError: t[4],
				extensions: t[5],
			}
		: e;
}
let mbe = class tU extends Error {
	constructor(e, ...n) {
		var r, i, o;
		const {
			nodes: s,
			source: a,
			positions: l,
			path: u,
			originalError: c,
			extensions: d,
		} = pbe(n);
		super(e),
			(this.name = "GraphQLError"),
			(this.path = u ?? void 0),
			(this.originalError = c ?? void 0),
			(this.nodes = VB(Array.isArray(s) ? s : s ? [s] : void 0));
		const f = VB(
			(r = this.nodes) === null || r === void 0
				? void 0
				: r.map((p) => p.loc).filter((p) => p != null),
		);
		(this.source =
			a ??
			(f == null || (i = f[0]) === null || i === void 0
				? void 0
				: i.source)),
			(this.positions =
				l ?? (f == null ? void 0 : f.map((p) => p.start))),
			(this.locations =
				l && a
					? l.map((p) => c2(a, p))
					: f == null
						? void 0
						: f.map((p) => c2(p.source, p.start)));
		const h = cbe(c == null ? void 0 : c.extensions)
			? c == null
				? void 0
				: c.extensions
			: void 0;
		(this.extensions =
			(o = d ?? h) !== null && o !== void 0 ? o : Object.create(null)),
			Object.defineProperties(this, {
				message: { writable: !0, enumerable: !0 },
				name: { enumerable: !1 },
				nodes: { enumerable: !1 },
				source: { enumerable: !1 },
				positions: { enumerable: !1 },
				originalError: { enumerable: !1 },
			}),
			c != null && c.stack
				? Object.defineProperty(this, "stack", {
						value: c.stack,
						writable: !0,
						configurable: !0,
					})
				: Error.captureStackTrace
					? Error.captureStackTrace(this, tU)
					: Object.defineProperty(this, "stack", {
							value: Error().stack,
							writable: !0,
							configurable: !0,
						});
	}
	get [Symbol.toStringTag]() {
		return "GraphQLError";
	}
	toString() {
		let e = this.message;
		if (this.nodes)
			for (const n of this.nodes)
				n.loc &&
					(e +=
						`

` + hbe(n.loc));
		else if (this.source && this.locations)
			for (const n of this.locations)
				e +=
					`

` + eU(this.source, n);
		return e;
	}
	toJSON() {
		const e = { message: this.message };
		return (
			this.locations != null && (e.locations = this.locations),
			this.path != null && (e.path = this.path),
			this.extensions != null &&
				Object.keys(this.extensions).length > 0 &&
				(e.extensions = this.extensions),
			e
		);
	}
};
function VB(t) {
	return t === void 0 || t.length === 0 ? void 0 : t;
}
function fr(t, e, n) {
	return new mbe(`Syntax Error: ${n}`, { source: t, positions: [e] });
}
class gbe {
	constructor(e, n, r) {
		(this.start = e.start),
			(this.end = n.end),
			(this.startToken = e),
			(this.endToken = n),
			(this.source = r);
	}
	get [Symbol.toStringTag]() {
		return "Location";
	}
	toJSON() {
		return { start: this.start, end: this.end };
	}
}
let nU = class {
	constructor(e, n, r, i, o, s) {
		(this.kind = e),
			(this.start = n),
			(this.end = r),
			(this.line = i),
			(this.column = o),
			(this.value = s),
			(this.prev = null),
			(this.next = null);
	}
	get [Symbol.toStringTag]() {
		return "Token";
	}
	toJSON() {
		return {
			kind: this.kind,
			value: this.value,
			line: this.line,
			column: this.column,
		};
	}
};
const bbe = {
	Name: [],
	Document: ["definitions"],
	OperationDefinition: [
		"name",
		"variableDefinitions",
		"directives",
		"selectionSet",
	],
	VariableDefinition: ["variable", "type", "defaultValue", "directives"],
	Variable: ["name"],
	SelectionSet: ["selections"],
	Field: ["alias", "name", "arguments", "directives", "selectionSet"],
	Argument: ["name", "value"],
	FragmentSpread: ["name", "directives"],
	InlineFragment: ["typeCondition", "directives", "selectionSet"],
	FragmentDefinition: [
		"name",
		"variableDefinitions",
		"typeCondition",
		"directives",
		"selectionSet",
	],
	IntValue: [],
	FloatValue: [],
	StringValue: [],
	BooleanValue: [],
	NullValue: [],
	EnumValue: [],
	ListValue: ["values"],
	ObjectValue: ["fields"],
	ObjectField: ["name", "value"],
	Directive: ["name", "arguments"],
	NamedType: ["name"],
	ListType: ["type"],
	NonNullType: ["type"],
	SchemaDefinition: ["description", "directives", "operationTypes"],
	OperationTypeDefinition: ["type"],
	ScalarTypeDefinition: ["description", "name", "directives"],
	ObjectTypeDefinition: [
		"description",
		"name",
		"interfaces",
		"directives",
		"fields",
	],
	FieldDefinition: ["description", "name", "arguments", "type", "directives"],
	InputValueDefinition: [
		"description",
		"name",
		"type",
		"defaultValue",
		"directives",
	],
	InterfaceTypeDefinition: [
		"description",
		"name",
		"interfaces",
		"directives",
		"fields",
	],
	UnionTypeDefinition: ["description", "name", "directives", "types"],
	EnumTypeDefinition: ["description", "name", "directives", "values"],
	EnumValueDefinition: ["description", "name", "directives"],
	InputObjectTypeDefinition: ["description", "name", "directives", "fields"],
	DirectiveDefinition: ["description", "name", "arguments", "locations"],
	SchemaExtension: ["directives", "operationTypes"],
	ScalarTypeExtension: ["name", "directives"],
	ObjectTypeExtension: ["name", "interfaces", "directives", "fields"],
	InterfaceTypeExtension: ["name", "interfaces", "directives", "fields"],
	UnionTypeExtension: ["name", "directives", "types"],
	EnumTypeExtension: ["name", "directives", "values"],
	InputObjectTypeExtension: ["name", "directives", "fields"],
};
new Set(Object.keys(bbe));
var Vf;
(function (t) {
	(t.QUERY = "query"),
		(t.MUTATION = "mutation"),
		(t.SUBSCRIPTION = "subscription");
})(Vf || (Vf = {}));
var d2;
(function (t) {
	(t.QUERY = "QUERY"),
		(t.MUTATION = "MUTATION"),
		(t.SUBSCRIPTION = "SUBSCRIPTION"),
		(t.FIELD = "FIELD"),
		(t.FRAGMENT_DEFINITION = "FRAGMENT_DEFINITION"),
		(t.FRAGMENT_SPREAD = "FRAGMENT_SPREAD"),
		(t.INLINE_FRAGMENT = "INLINE_FRAGMENT"),
		(t.VARIABLE_DEFINITION = "VARIABLE_DEFINITION"),
		(t.SCHEMA = "SCHEMA"),
		(t.SCALAR = "SCALAR"),
		(t.OBJECT = "OBJECT"),
		(t.FIELD_DEFINITION = "FIELD_DEFINITION"),
		(t.ARGUMENT_DEFINITION = "ARGUMENT_DEFINITION"),
		(t.INTERFACE = "INTERFACE"),
		(t.UNION = "UNION"),
		(t.ENUM = "ENUM"),
		(t.ENUM_VALUE = "ENUM_VALUE"),
		(t.INPUT_OBJECT = "INPUT_OBJECT"),
		(t.INPUT_FIELD_DEFINITION = "INPUT_FIELD_DEFINITION");
})(d2 || (d2 = {}));
var ot;
(function (t) {
	(t.NAME = "Name"),
		(t.DOCUMENT = "Document"),
		(t.OPERATION_DEFINITION = "OperationDefinition"),
		(t.VARIABLE_DEFINITION = "VariableDefinition"),
		(t.SELECTION_SET = "SelectionSet"),
		(t.FIELD = "Field"),
		(t.ARGUMENT = "Argument"),
		(t.FRAGMENT_SPREAD = "FragmentSpread"),
		(t.INLINE_FRAGMENT = "InlineFragment"),
		(t.FRAGMENT_DEFINITION = "FragmentDefinition"),
		(t.VARIABLE = "Variable"),
		(t.INT = "IntValue"),
		(t.FLOAT = "FloatValue"),
		(t.STRING = "StringValue"),
		(t.BOOLEAN = "BooleanValue"),
		(t.NULL = "NullValue"),
		(t.ENUM = "EnumValue"),
		(t.LIST = "ListValue"),
		(t.OBJECT = "ObjectValue"),
		(t.OBJECT_FIELD = "ObjectField"),
		(t.DIRECTIVE = "Directive"),
		(t.NAMED_TYPE = "NamedType"),
		(t.LIST_TYPE = "ListType"),
		(t.NON_NULL_TYPE = "NonNullType"),
		(t.SCHEMA_DEFINITION = "SchemaDefinition"),
		(t.OPERATION_TYPE_DEFINITION = "OperationTypeDefinition"),
		(t.SCALAR_TYPE_DEFINITION = "ScalarTypeDefinition"),
		(t.OBJECT_TYPE_DEFINITION = "ObjectTypeDefinition"),
		(t.FIELD_DEFINITION = "FieldDefinition"),
		(t.INPUT_VALUE_DEFINITION = "InputValueDefinition"),
		(t.INTERFACE_TYPE_DEFINITION = "InterfaceTypeDefinition"),
		(t.UNION_TYPE_DEFINITION = "UnionTypeDefinition"),
		(t.ENUM_TYPE_DEFINITION = "EnumTypeDefinition"),
		(t.ENUM_VALUE_DEFINITION = "EnumValueDefinition"),
		(t.INPUT_OBJECT_TYPE_DEFINITION = "InputObjectTypeDefinition"),
		(t.DIRECTIVE_DEFINITION = "DirectiveDefinition"),
		(t.SCHEMA_EXTENSION = "SchemaExtension"),
		(t.SCALAR_TYPE_EXTENSION = "ScalarTypeExtension"),
		(t.OBJECT_TYPE_EXTENSION = "ObjectTypeExtension"),
		(t.INTERFACE_TYPE_EXTENSION = "InterfaceTypeExtension"),
		(t.UNION_TYPE_EXTENSION = "UnionTypeExtension"),
		(t.ENUM_TYPE_EXTENSION = "EnumTypeExtension"),
		(t.INPUT_OBJECT_TYPE_EXTENSION = "InputObjectTypeExtension");
})(ot || (ot = {}));
function vbe(t) {
	return t === 9 || t === 32;
}
function yg(t) {
	return t >= 48 && t <= 57;
}
function rU(t) {
	return (t >= 97 && t <= 122) || (t >= 65 && t <= 90);
}
function iU(t) {
	return rU(t) || t === 95;
}
function ybe(t) {
	return rU(t) || yg(t) || t === 95;
}
function xbe(t) {
	var e;
	let n = Number.MAX_SAFE_INTEGER,
		r = null,
		i = -1;
	for (let s = 0; s < t.length; ++s) {
		var o;
		const a = t[s],
			l = kbe(a);
		l !== a.length &&
			((r = (o = r) !== null && o !== void 0 ? o : s),
			(i = s),
			s !== 0 && l < n && (n = l));
	}
	return t
		.map((s, a) => (a === 0 ? s : s.slice(n)))
		.slice((e = r) !== null && e !== void 0 ? e : 0, i + 1);
}
function kbe(t) {
	let e = 0;
	for (; e < t.length && vbe(t.charCodeAt(e)); ) ++e;
	return e;
}
var ge;
(function (t) {
	(t.SOF = "<SOF>"),
		(t.EOF = "<EOF>"),
		(t.BANG = "!"),
		(t.DOLLAR = "$"),
		(t.AMP = "&"),
		(t.PAREN_L = "("),
		(t.PAREN_R = ")"),
		(t.SPREAD = "..."),
		(t.COLON = ":"),
		(t.EQUALS = "="),
		(t.AT = "@"),
		(t.BRACKET_L = "["),
		(t.BRACKET_R = "]"),
		(t.BRACE_L = "{"),
		(t.PIPE = "|"),
		(t.BRACE_R = "}"),
		(t.NAME = "Name"),
		(t.INT = "Int"),
		(t.FLOAT = "Float"),
		(t.STRING = "String"),
		(t.BLOCK_STRING = "BlockString"),
		(t.COMMENT = "Comment");
})(ge || (ge = {}));
class Cbe {
	constructor(e) {
		const n = new nU(ge.SOF, 0, 0, 0, 0);
		(this.source = e),
			(this.lastToken = n),
			(this.token = n),
			(this.line = 1),
			(this.lineStart = 0);
	}
	get [Symbol.toStringTag]() {
		return "Lexer";
	}
	advance() {
		return (this.lastToken = this.token), (this.token = this.lookahead());
	}
	lookahead() {
		let e = this.token;
		if (e.kind !== ge.EOF)
			do
				if (e.next) e = e.next;
				else {
					const n = Ebe(this, e.end);
					(e.next = n), (n.prev = e), (e = n);
				}
			while (e.kind === ge.COMMENT);
		return e;
	}
}
function wbe(t) {
	return (
		t === ge.BANG ||
		t === ge.DOLLAR ||
		t === ge.AMP ||
		t === ge.PAREN_L ||
		t === ge.PAREN_R ||
		t === ge.SPREAD ||
		t === ge.COLON ||
		t === ge.EQUALS ||
		t === ge.AT ||
		t === ge.BRACKET_L ||
		t === ge.BRACKET_R ||
		t === ge.BRACE_L ||
		t === ge.PIPE ||
		t === ge.BRACE_R
	);
}
function lp(t) {
	return (t >= 0 && t <= 55295) || (t >= 57344 && t <= 1114111);
}
function s3(t, e) {
	return oU(t.charCodeAt(e)) && sU(t.charCodeAt(e + 1));
}
function oU(t) {
	return t >= 55296 && t <= 56319;
}
function sU(t) {
	return t >= 56320 && t <= 57343;
}
function Ad(t, e) {
	const n = t.source.body.codePointAt(e);
	if (n === void 0) return ge.EOF;
	if (n >= 32 && n <= 126) {
		const r = String.fromCodePoint(n);
		return r === '"' ? `'"'` : `"${r}"`;
	}
	return "U+" + n.toString(16).toUpperCase().padStart(4, "0");
}
function zn(t, e, n, r, i) {
	const o = t.line,
		s = 1 + n - t.lineStart;
	return new nU(e, n, r, o, s, i);
}
function Ebe(t, e) {
	const n = t.source.body,
		r = n.length;
	let i = e;
	for (; i < r; ) {
		const o = n.charCodeAt(i);
		switch (o) {
			case 65279:
			case 9:
			case 32:
			case 44:
				++i;
				continue;
			case 10:
				++i, ++t.line, (t.lineStart = i);
				continue;
			case 13:
				n.charCodeAt(i + 1) === 10 ? (i += 2) : ++i,
					++t.line,
					(t.lineStart = i);
				continue;
			case 35:
				return Dbe(t, i);
			case 33:
				return zn(t, ge.BANG, i, i + 1);
			case 36:
				return zn(t, ge.DOLLAR, i, i + 1);
			case 38:
				return zn(t, ge.AMP, i, i + 1);
			case 40:
				return zn(t, ge.PAREN_L, i, i + 1);
			case 41:
				return zn(t, ge.PAREN_R, i, i + 1);
			case 46:
				if (n.charCodeAt(i + 1) === 46 && n.charCodeAt(i + 2) === 46)
					return zn(t, ge.SPREAD, i, i + 3);
				break;
			case 58:
				return zn(t, ge.COLON, i, i + 1);
			case 61:
				return zn(t, ge.EQUALS, i, i + 1);
			case 64:
				return zn(t, ge.AT, i, i + 1);
			case 91:
				return zn(t, ge.BRACKET_L, i, i + 1);
			case 93:
				return zn(t, ge.BRACKET_R, i, i + 1);
			case 123:
				return zn(t, ge.BRACE_L, i, i + 1);
			case 124:
				return zn(t, ge.PIPE, i, i + 1);
			case 125:
				return zn(t, ge.BRACE_R, i, i + 1);
			case 34:
				return n.charCodeAt(i + 1) === 34 && n.charCodeAt(i + 2) === 34
					? Ibe(t, i)
					: Abe(t, i);
		}
		if (yg(o) || o === 45) return Sbe(t, i, o);
		if (iU(o)) return Fbe(t, i);
		throw fr(
			t.source,
			i,
			o === 39
				? `Unexpected single quote character ('), did you mean to use a double quote (")?`
				: lp(o) || s3(n, i)
					? `Unexpected character: ${Ad(t, i)}.`
					: `Invalid character: ${Ad(t, i)}.`,
		);
	}
	return zn(t, ge.EOF, r, r);
}
function Dbe(t, e) {
	const n = t.source.body,
		r = n.length;
	let i = e + 1;
	for (; i < r; ) {
		const o = n.charCodeAt(i);
		if (o === 10 || o === 13) break;
		if (lp(o)) ++i;
		else if (s3(n, i)) i += 2;
		else break;
	}
	return zn(t, ge.COMMENT, e, i, n.slice(e + 1, i));
}
function Sbe(t, e, n) {
	const r = t.source.body;
	let i = e,
		o = n,
		s = !1;
	if ((o === 45 && (o = r.charCodeAt(++i)), o === 48)) {
		if (((o = r.charCodeAt(++i)), yg(o)))
			throw fr(
				t.source,
				i,
				`Invalid number, unexpected digit after 0: ${Ad(t, i)}.`,
			);
	} else (i = Mk(t, i, o)), (o = r.charCodeAt(i));
	if (
		(o === 46 &&
			((s = !0),
			(o = r.charCodeAt(++i)),
			(i = Mk(t, i, o)),
			(o = r.charCodeAt(i))),
		(o === 69 || o === 101) &&
			((s = !0),
			(o = r.charCodeAt(++i)),
			(o === 43 || o === 45) && (o = r.charCodeAt(++i)),
			(i = Mk(t, i, o)),
			(o = r.charCodeAt(i))),
		o === 46 || iU(o))
	)
		throw fr(
			t.source,
			i,
			`Invalid number, expected digit but got: ${Ad(t, i)}.`,
		);
	return zn(t, s ? ge.FLOAT : ge.INT, e, i, r.slice(e, i));
}
function Mk(t, e, n) {
	if (!yg(n))
		throw fr(
			t.source,
			e,
			`Invalid number, expected digit but got: ${Ad(t, e)}.`,
		);
	const r = t.source.body;
	let i = e + 1;
	for (; yg(r.charCodeAt(i)); ) ++i;
	return i;
}
function Abe(t, e) {
	const n = t.source.body,
		r = n.length;
	let i = e + 1,
		o = i,
		s = "";
	for (; i < r; ) {
		const a = n.charCodeAt(i);
		if (a === 34)
			return (s += n.slice(o, i)), zn(t, ge.STRING, e, i + 1, s);
		if (a === 92) {
			s += n.slice(o, i);
			const l =
				n.charCodeAt(i + 1) === 117
					? n.charCodeAt(i + 2) === 123
						? $be(t, i)
						: Tbe(t, i)
					: Bbe(t, i);
			(s += l.value), (i += l.size), (o = i);
			continue;
		}
		if (a === 10 || a === 13) break;
		if (lp(a)) ++i;
		else if (s3(n, i)) i += 2;
		else
			throw fr(
				t.source,
				i,
				`Invalid character within String: ${Ad(t, i)}.`,
			);
	}
	throw fr(t.source, i, "Unterminated string.");
}
function $be(t, e) {
	const n = t.source.body;
	let r = 0,
		i = 3;
	for (; i < 12; ) {
		const o = n.charCodeAt(e + i++);
		if (o === 125) {
			if (i < 5 || !lp(r)) break;
			return { value: String.fromCodePoint(r), size: i };
		}
		if (((r = (r << 4) | rm(o)), r < 0)) break;
	}
	throw fr(
		t.source,
		e,
		`Invalid Unicode escape sequence: "${n.slice(e, e + i)}".`,
	);
}
function Tbe(t, e) {
	const n = t.source.body,
		r = KB(n, e + 2);
	if (lp(r)) return { value: String.fromCodePoint(r), size: 6 };
	if (oU(r) && n.charCodeAt(e + 6) === 92 && n.charCodeAt(e + 7) === 117) {
		const i = KB(n, e + 8);
		if (sU(i)) return { value: String.fromCodePoint(r, i), size: 12 };
	}
	throw fr(
		t.source,
		e,
		`Invalid Unicode escape sequence: "${n.slice(e, e + 6)}".`,
	);
}
function KB(t, e) {
	return (
		(rm(t.charCodeAt(e)) << 12) |
		(rm(t.charCodeAt(e + 1)) << 8) |
		(rm(t.charCodeAt(e + 2)) << 4) |
		rm(t.charCodeAt(e + 3))
	);
}
function rm(t) {
	return t >= 48 && t <= 57
		? t - 48
		: t >= 65 && t <= 70
			? t - 55
			: t >= 97 && t <= 102
				? t - 87
				: -1;
}
function Bbe(t, e) {
	const n = t.source.body;
	switch (n.charCodeAt(e + 1)) {
		case 34:
			return { value: '"', size: 2 };
		case 92:
			return { value: "\\", size: 2 };
		case 47:
			return { value: "/", size: 2 };
		case 98:
			return { value: "\b", size: 2 };
		case 102:
			return { value: "\f", size: 2 };
		case 110:
			return {
				value: `
`,
				size: 2,
			};
		case 114:
			return { value: "\r", size: 2 };
		case 116:
			return { value: "	", size: 2 };
	}
	throw fr(
		t.source,
		e,
		`Invalid character escape sequence: "${n.slice(e, e + 2)}".`,
	);
}
function Ibe(t, e) {
	const n = t.source.body,
		r = n.length;
	let i = t.lineStart,
		o = e + 3,
		s = o,
		a = "";
	const l = [];
	for (; o < r; ) {
		const u = n.charCodeAt(o);
		if (
			u === 34 &&
			n.charCodeAt(o + 1) === 34 &&
			n.charCodeAt(o + 2) === 34
		) {
			(a += n.slice(s, o)), l.push(a);
			const c = zn(
				t,
				ge.BLOCK_STRING,
				e,
				o + 3,
				xbe(l).join(`
`),
			);
			return (t.line += l.length - 1), (t.lineStart = i), c;
		}
		if (
			u === 92 &&
			n.charCodeAt(o + 1) === 34 &&
			n.charCodeAt(o + 2) === 34 &&
			n.charCodeAt(o + 3) === 34
		) {
			(a += n.slice(s, o)), (s = o + 1), (o += 4);
			continue;
		}
		if (u === 10 || u === 13) {
			(a += n.slice(s, o)),
				l.push(a),
				u === 13 && n.charCodeAt(o + 1) === 10 ? (o += 2) : ++o,
				(a = ""),
				(s = o),
				(i = o);
			continue;
		}
		if (lp(u)) ++o;
		else if (s3(n, o)) o += 2;
		else
			throw fr(
				t.source,
				o,
				`Invalid character within String: ${Ad(t, o)}.`,
			);
	}
	throw fr(t.source, o, "Unterminated string.");
}
function Fbe(t, e) {
	const n = t.source.body,
		r = n.length;
	let i = e + 1;
	for (; i < r; ) {
		const o = n.charCodeAt(i);
		if (ybe(o)) ++i;
		else break;
	}
	return zn(t, ge.NAME, e, i, n.slice(e, i));
}
const Pbe = 10,
	aU = 2;
function lU(t) {
	return a3(t, []);
}
function a3(t, e) {
	switch (typeof t) {
		case "string":
			return JSON.stringify(t);
		case "function":
			return t.name ? `[function ${t.name}]` : "[function]";
		case "object":
			return Nbe(t, e);
		default:
			return String(t);
	}
}
function Nbe(t, e) {
	if (t === null) return "null";
	if (e.includes(t)) return "[Circular]";
	const n = [...e, t];
	if (Rbe(t)) {
		const r = t.toJSON();
		if (r !== t) return typeof r == "string" ? r : a3(r, n);
	} else if (Array.isArray(t)) return Mbe(t, n);
	return Obe(t, n);
}
function Rbe(t) {
	return typeof t.toJSON == "function";
}
function Obe(t, e) {
	const n = Object.entries(t);
	return n.length === 0
		? "{}"
		: e.length > aU
			? "[" + jbe(t) + "]"
			: "{ " + n.map(([i, o]) => i + ": " + a3(o, e)).join(", ") + " }";
}
function Mbe(t, e) {
	if (t.length === 0) return "[]";
	if (e.length > aU) return "[Array]";
	const n = Math.min(Pbe, t.length),
		r = t.length - n,
		i = [];
	for (let o = 0; o < n; ++o) i.push(a3(t[o], e));
	return (
		r === 1
			? i.push("... 1 more item")
			: r > 1 && i.push(`... ${r} more items`),
		"[" + i.join(", ") + "]"
	);
}
function jbe(t) {
	const e = Object.prototype.toString
		.call(t)
		.replace(/^\[object /, "")
		.replace(/]$/, "");
	if (e === "Object" && typeof t.constructor == "function") {
		const n = t.constructor.name;
		if (typeof n == "string" && n !== "") return n;
	}
	return e;
}
const _be = globalThis.process && !0,
	zbe = _be
		? function (e, n) {
				return e instanceof n;
			}
		: function (e, n) {
				if (e instanceof n) return !0;
				if (typeof e == "object" && e !== null) {
					var r;
					const i = n.prototype[Symbol.toStringTag],
						o =
							Symbol.toStringTag in e
								? e[Symbol.toStringTag]
								: (r = e.constructor) === null || r === void 0
									? void 0
									: r.name;
					if (i === o) {
						const s = lU(e);
						throw new Error(`Cannot use ${i} "${s}" from another module or realm.

Ensure that there is only one instance of "graphql" in the node_modules
directory. If different versions of "graphql" are the dependencies of other
relied on modules, use "resolutions" to ensure only one version is installed.

https://yarnpkg.com/en/docs/selective-version-resolutions

Duplicate "graphql" modules cannot be used at the same time since different
versions may have different capabilities and behavior. The data from one
version used in the function from another could produce confusing and
spurious results.`);
					}
				}
				return !1;
			};
class uU {
	constructor(e, n = "GraphQL request", r = { line: 1, column: 1 }) {
		typeof e == "string" ||
			Ok(!1, `Body must be a string. Received: ${lU(e)}.`),
			(this.body = e),
			(this.name = n),
			(this.locationOffset = r),
			this.locationOffset.line > 0 ||
				Ok(
					!1,
					"line in locationOffset is 1-indexed and must be positive.",
				),
			this.locationOffset.column > 0 ||
				Ok(
					!1,
					"column in locationOffset is 1-indexed and must be positive.",
				);
	}
	get [Symbol.toStringTag]() {
		return "Source";
	}
}
function Lbe(t) {
	return zbe(t, uU);
}
function Vbe(t, e) {
	return new Kbe(t, e).parseDocument();
}
let Kbe = class {
	constructor(e, n = {}) {
		const r = Lbe(e) ? e : new uU(e);
		(this._lexer = new Cbe(r)),
			(this._options = n),
			(this._tokenCounter = 0);
	}
	parseName() {
		const e = this.expectToken(ge.NAME);
		return this.node(e, { kind: ot.NAME, value: e.value });
	}
	parseDocument() {
		return this.node(this._lexer.token, {
			kind: ot.DOCUMENT,
			definitions: this.many(ge.SOF, this.parseDefinition, ge.EOF),
		});
	}
	parseDefinition() {
		if (this.peek(ge.BRACE_L)) return this.parseOperationDefinition();
		const e = this.peekDescription(),
			n = e ? this._lexer.lookahead() : this._lexer.token;
		if (n.kind === ge.NAME) {
			switch (n.value) {
				case "schema":
					return this.parseSchemaDefinition();
				case "scalar":
					return this.parseScalarTypeDefinition();
				case "type":
					return this.parseObjectTypeDefinition();
				case "interface":
					return this.parseInterfaceTypeDefinition();
				case "union":
					return this.parseUnionTypeDefinition();
				case "enum":
					return this.parseEnumTypeDefinition();
				case "input":
					return this.parseInputObjectTypeDefinition();
				case "directive":
					return this.parseDirectiveDefinition();
			}
			if (e)
				throw fr(
					this._lexer.source,
					this._lexer.token.start,
					"Unexpected description, descriptions are supported only on type definitions.",
				);
			switch (n.value) {
				case "query":
				case "mutation":
				case "subscription":
					return this.parseOperationDefinition();
				case "fragment":
					return this.parseFragmentDefinition();
				case "extend":
					return this.parseTypeSystemExtension();
			}
		}
		throw this.unexpected(n);
	}
	parseOperationDefinition() {
		const e = this._lexer.token;
		if (this.peek(ge.BRACE_L))
			return this.node(e, {
				kind: ot.OPERATION_DEFINITION,
				operation: Vf.QUERY,
				name: void 0,
				variableDefinitions: [],
				directives: [],
				selectionSet: this.parseSelectionSet(),
			});
		const n = this.parseOperationType();
		let r;
		return (
			this.peek(ge.NAME) && (r = this.parseName()),
			this.node(e, {
				kind: ot.OPERATION_DEFINITION,
				operation: n,
				name: r,
				variableDefinitions: this.parseVariableDefinitions(),
				directives: this.parseDirectives(!1),
				selectionSet: this.parseSelectionSet(),
			})
		);
	}
	parseOperationType() {
		const e = this.expectToken(ge.NAME);
		switch (e.value) {
			case "query":
				return Vf.QUERY;
			case "mutation":
				return Vf.MUTATION;
			case "subscription":
				return Vf.SUBSCRIPTION;
		}
		throw this.unexpected(e);
	}
	parseVariableDefinitions() {
		return this.optionalMany(
			ge.PAREN_L,
			this.parseVariableDefinition,
			ge.PAREN_R,
		);
	}
	parseVariableDefinition() {
		return this.node(this._lexer.token, {
			kind: ot.VARIABLE_DEFINITION,
			variable: this.parseVariable(),
			type: (this.expectToken(ge.COLON), this.parseTypeReference()),
			defaultValue: this.expectOptionalToken(ge.EQUALS)
				? this.parseConstValueLiteral()
				: void 0,
			directives: this.parseConstDirectives(),
		});
	}
	parseVariable() {
		const e = this._lexer.token;
		return (
			this.expectToken(ge.DOLLAR),
			this.node(e, { kind: ot.VARIABLE, name: this.parseName() })
		);
	}
	parseSelectionSet() {
		return this.node(this._lexer.token, {
			kind: ot.SELECTION_SET,
			selections: this.many(ge.BRACE_L, this.parseSelection, ge.BRACE_R),
		});
	}
	parseSelection() {
		return this.peek(ge.SPREAD) ? this.parseFragment() : this.parseField();
	}
	parseField() {
		const e = this._lexer.token,
			n = this.parseName();
		let r, i;
		return (
			this.expectOptionalToken(ge.COLON)
				? ((r = n), (i = this.parseName()))
				: (i = n),
			this.node(e, {
				kind: ot.FIELD,
				alias: r,
				name: i,
				arguments: this.parseArguments(!1),
				directives: this.parseDirectives(!1),
				selectionSet: this.peek(ge.BRACE_L)
					? this.parseSelectionSet()
					: void 0,
			})
		);
	}
	parseArguments(e) {
		const n = e ? this.parseConstArgument : this.parseArgument;
		return this.optionalMany(ge.PAREN_L, n, ge.PAREN_R);
	}
	parseArgument(e = !1) {
		const n = this._lexer.token,
			r = this.parseName();
		return (
			this.expectToken(ge.COLON),
			this.node(n, {
				kind: ot.ARGUMENT,
				name: r,
				value: this.parseValueLiteral(e),
			})
		);
	}
	parseConstArgument() {
		return this.parseArgument(!0);
	}
	parseFragment() {
		const e = this._lexer.token;
		this.expectToken(ge.SPREAD);
		const n = this.expectOptionalKeyword("on");
		return !n && this.peek(ge.NAME)
			? this.node(e, {
					kind: ot.FRAGMENT_SPREAD,
					name: this.parseFragmentName(),
					directives: this.parseDirectives(!1),
				})
			: this.node(e, {
					kind: ot.INLINE_FRAGMENT,
					typeCondition: n ? this.parseNamedType() : void 0,
					directives: this.parseDirectives(!1),
					selectionSet: this.parseSelectionSet(),
				});
	}
	parseFragmentDefinition() {
		const e = this._lexer.token;
		return (
			this.expectKeyword("fragment"),
			this._options.allowLegacyFragmentVariables === !0
				? this.node(e, {
						kind: ot.FRAGMENT_DEFINITION,
						name: this.parseFragmentName(),
						variableDefinitions: this.parseVariableDefinitions(),
						typeCondition:
							(this.expectKeyword("on"), this.parseNamedType()),
						directives: this.parseDirectives(!1),
						selectionSet: this.parseSelectionSet(),
					})
				: this.node(e, {
						kind: ot.FRAGMENT_DEFINITION,
						name: this.parseFragmentName(),
						typeCondition:
							(this.expectKeyword("on"), this.parseNamedType()),
						directives: this.parseDirectives(!1),
						selectionSet: this.parseSelectionSet(),
					})
		);
	}
	parseFragmentName() {
		if (this._lexer.token.value === "on") throw this.unexpected();
		return this.parseName();
	}
	parseValueLiteral(e) {
		const n = this._lexer.token;
		switch (n.kind) {
			case ge.BRACKET_L:
				return this.parseList(e);
			case ge.BRACE_L:
				return this.parseObject(e);
			case ge.INT:
				return (
					this.advanceLexer(),
					this.node(n, { kind: ot.INT, value: n.value })
				);
			case ge.FLOAT:
				return (
					this.advanceLexer(),
					this.node(n, { kind: ot.FLOAT, value: n.value })
				);
			case ge.STRING:
			case ge.BLOCK_STRING:
				return this.parseStringLiteral();
			case ge.NAME:
				switch ((this.advanceLexer(), n.value)) {
					case "true":
						return this.node(n, { kind: ot.BOOLEAN, value: !0 });
					case "false":
						return this.node(n, { kind: ot.BOOLEAN, value: !1 });
					case "null":
						return this.node(n, { kind: ot.NULL });
					default:
						return this.node(n, { kind: ot.ENUM, value: n.value });
				}
			case ge.DOLLAR:
				if (e)
					if (
						(this.expectToken(ge.DOLLAR),
						this._lexer.token.kind === ge.NAME)
					) {
						const r = this._lexer.token.value;
						throw fr(
							this._lexer.source,
							n.start,
							`Unexpected variable "$${r}" in constant value.`,
						);
					} else throw this.unexpected(n);
				return this.parseVariable();
			default:
				throw this.unexpected();
		}
	}
	parseConstValueLiteral() {
		return this.parseValueLiteral(!0);
	}
	parseStringLiteral() {
		const e = this._lexer.token;
		return (
			this.advanceLexer(),
			this.node(e, {
				kind: ot.STRING,
				value: e.value,
				block: e.kind === ge.BLOCK_STRING,
			})
		);
	}
	parseList(e) {
		const n = () => this.parseValueLiteral(e);
		return this.node(this._lexer.token, {
			kind: ot.LIST,
			values: this.any(ge.BRACKET_L, n, ge.BRACKET_R),
		});
	}
	parseObject(e) {
		const n = () => this.parseObjectField(e);
		return this.node(this._lexer.token, {
			kind: ot.OBJECT,
			fields: this.any(ge.BRACE_L, n, ge.BRACE_R),
		});
	}
	parseObjectField(e) {
		const n = this._lexer.token,
			r = this.parseName();
		return (
			this.expectToken(ge.COLON),
			this.node(n, {
				kind: ot.OBJECT_FIELD,
				name: r,
				value: this.parseValueLiteral(e),
			})
		);
	}
	parseDirectives(e) {
		const n = [];
		for (; this.peek(ge.AT); ) n.push(this.parseDirective(e));
		return n;
	}
	parseConstDirectives() {
		return this.parseDirectives(!0);
	}
	parseDirective(e) {
		const n = this._lexer.token;
		return (
			this.expectToken(ge.AT),
			this.node(n, {
				kind: ot.DIRECTIVE,
				name: this.parseName(),
				arguments: this.parseArguments(e),
			})
		);
	}
	parseTypeReference() {
		const e = this._lexer.token;
		let n;
		if (this.expectOptionalToken(ge.BRACKET_L)) {
			const r = this.parseTypeReference();
			this.expectToken(ge.BRACKET_R),
				(n = this.node(e, { kind: ot.LIST_TYPE, type: r }));
		} else n = this.parseNamedType();
		return this.expectOptionalToken(ge.BANG)
			? this.node(e, { kind: ot.NON_NULL_TYPE, type: n })
			: n;
	}
	parseNamedType() {
		return this.node(this._lexer.token, {
			kind: ot.NAMED_TYPE,
			name: this.parseName(),
		});
	}
	peekDescription() {
		return this.peek(ge.STRING) || this.peek(ge.BLOCK_STRING);
	}
	parseDescription() {
		if (this.peekDescription()) return this.parseStringLiteral();
	}
	parseSchemaDefinition() {
		const e = this._lexer.token,
			n = this.parseDescription();
		this.expectKeyword("schema");
		const r = this.parseConstDirectives(),
			i = this.many(
				ge.BRACE_L,
				this.parseOperationTypeDefinition,
				ge.BRACE_R,
			);
		return this.node(e, {
			kind: ot.SCHEMA_DEFINITION,
			description: n,
			directives: r,
			operationTypes: i,
		});
	}
	parseOperationTypeDefinition() {
		const e = this._lexer.token,
			n = this.parseOperationType();
		this.expectToken(ge.COLON);
		const r = this.parseNamedType();
		return this.node(e, {
			kind: ot.OPERATION_TYPE_DEFINITION,
			operation: n,
			type: r,
		});
	}
	parseScalarTypeDefinition() {
		const e = this._lexer.token,
			n = this.parseDescription();
		this.expectKeyword("scalar");
		const r = this.parseName(),
			i = this.parseConstDirectives();
		return this.node(e, {
			kind: ot.SCALAR_TYPE_DEFINITION,
			description: n,
			name: r,
			directives: i,
		});
	}
	parseObjectTypeDefinition() {
		const e = this._lexer.token,
			n = this.parseDescription();
		this.expectKeyword("type");
		const r = this.parseName(),
			i = this.parseImplementsInterfaces(),
			o = this.parseConstDirectives(),
			s = this.parseFieldsDefinition();
		return this.node(e, {
			kind: ot.OBJECT_TYPE_DEFINITION,
			description: n,
			name: r,
			interfaces: i,
			directives: o,
			fields: s,
		});
	}
	parseImplementsInterfaces() {
		return this.expectOptionalKeyword("implements")
			? this.delimitedMany(ge.AMP, this.parseNamedType)
			: [];
	}
	parseFieldsDefinition() {
		return this.optionalMany(
			ge.BRACE_L,
			this.parseFieldDefinition,
			ge.BRACE_R,
		);
	}
	parseFieldDefinition() {
		const e = this._lexer.token,
			n = this.parseDescription(),
			r = this.parseName(),
			i = this.parseArgumentDefs();
		this.expectToken(ge.COLON);
		const o = this.parseTypeReference(),
			s = this.parseConstDirectives();
		return this.node(e, {
			kind: ot.FIELD_DEFINITION,
			description: n,
			name: r,
			arguments: i,
			type: o,
			directives: s,
		});
	}
	parseArgumentDefs() {
		return this.optionalMany(
			ge.PAREN_L,
			this.parseInputValueDef,
			ge.PAREN_R,
		);
	}
	parseInputValueDef() {
		const e = this._lexer.token,
			n = this.parseDescription(),
			r = this.parseName();
		this.expectToken(ge.COLON);
		const i = this.parseTypeReference();
		let o;
		this.expectOptionalToken(ge.EQUALS) &&
			(o = this.parseConstValueLiteral());
		const s = this.parseConstDirectives();
		return this.node(e, {
			kind: ot.INPUT_VALUE_DEFINITION,
			description: n,
			name: r,
			type: i,
			defaultValue: o,
			directives: s,
		});
	}
	parseInterfaceTypeDefinition() {
		const e = this._lexer.token,
			n = this.parseDescription();
		this.expectKeyword("interface");
		const r = this.parseName(),
			i = this.parseImplementsInterfaces(),
			o = this.parseConstDirectives(),
			s = this.parseFieldsDefinition();
		return this.node(e, {
			kind: ot.INTERFACE_TYPE_DEFINITION,
			description: n,
			name: r,
			interfaces: i,
			directives: o,
			fields: s,
		});
	}
	parseUnionTypeDefinition() {
		const e = this._lexer.token,
			n = this.parseDescription();
		this.expectKeyword("union");
		const r = this.parseName(),
			i = this.parseConstDirectives(),
			o = this.parseUnionMemberTypes();
		return this.node(e, {
			kind: ot.UNION_TYPE_DEFINITION,
			description: n,
			name: r,
			directives: i,
			types: o,
		});
	}
	parseUnionMemberTypes() {
		return this.expectOptionalToken(ge.EQUALS)
			? this.delimitedMany(ge.PIPE, this.parseNamedType)
			: [];
	}
	parseEnumTypeDefinition() {
		const e = this._lexer.token,
			n = this.parseDescription();
		this.expectKeyword("enum");
		const r = this.parseName(),
			i = this.parseConstDirectives(),
			o = this.parseEnumValuesDefinition();
		return this.node(e, {
			kind: ot.ENUM_TYPE_DEFINITION,
			description: n,
			name: r,
			directives: i,
			values: o,
		});
	}
	parseEnumValuesDefinition() {
		return this.optionalMany(
			ge.BRACE_L,
			this.parseEnumValueDefinition,
			ge.BRACE_R,
		);
	}
	parseEnumValueDefinition() {
		const e = this._lexer.token,
			n = this.parseDescription(),
			r = this.parseEnumValueName(),
			i = this.parseConstDirectives();
		return this.node(e, {
			kind: ot.ENUM_VALUE_DEFINITION,
			description: n,
			name: r,
			directives: i,
		});
	}
	parseEnumValueName() {
		if (
			this._lexer.token.value === "true" ||
			this._lexer.token.value === "false" ||
			this._lexer.token.value === "null"
		)
			throw fr(
				this._lexer.source,
				this._lexer.token.start,
				`${j1(this._lexer.token)} is reserved and cannot be used for an enum value.`,
			);
		return this.parseName();
	}
	parseInputObjectTypeDefinition() {
		const e = this._lexer.token,
			n = this.parseDescription();
		this.expectKeyword("input");
		const r = this.parseName(),
			i = this.parseConstDirectives(),
			o = this.parseInputFieldsDefinition();
		return this.node(e, {
			kind: ot.INPUT_OBJECT_TYPE_DEFINITION,
			description: n,
			name: r,
			directives: i,
			fields: o,
		});
	}
	parseInputFieldsDefinition() {
		return this.optionalMany(
			ge.BRACE_L,
			this.parseInputValueDef,
			ge.BRACE_R,
		);
	}
	parseTypeSystemExtension() {
		const e = this._lexer.lookahead();
		if (e.kind === ge.NAME)
			switch (e.value) {
				case "schema":
					return this.parseSchemaExtension();
				case "scalar":
					return this.parseScalarTypeExtension();
				case "type":
					return this.parseObjectTypeExtension();
				case "interface":
					return this.parseInterfaceTypeExtension();
				case "union":
					return this.parseUnionTypeExtension();
				case "enum":
					return this.parseEnumTypeExtension();
				case "input":
					return this.parseInputObjectTypeExtension();
			}
		throw this.unexpected(e);
	}
	parseSchemaExtension() {
		const e = this._lexer.token;
		this.expectKeyword("extend"), this.expectKeyword("schema");
		const n = this.parseConstDirectives(),
			r = this.optionalMany(
				ge.BRACE_L,
				this.parseOperationTypeDefinition,
				ge.BRACE_R,
			);
		if (n.length === 0 && r.length === 0) throw this.unexpected();
		return this.node(e, {
			kind: ot.SCHEMA_EXTENSION,
			directives: n,
			operationTypes: r,
		});
	}
	parseScalarTypeExtension() {
		const e = this._lexer.token;
		this.expectKeyword("extend"), this.expectKeyword("scalar");
		const n = this.parseName(),
			r = this.parseConstDirectives();
		if (r.length === 0) throw this.unexpected();
		return this.node(e, {
			kind: ot.SCALAR_TYPE_EXTENSION,
			name: n,
			directives: r,
		});
	}
	parseObjectTypeExtension() {
		const e = this._lexer.token;
		this.expectKeyword("extend"), this.expectKeyword("type");
		const n = this.parseName(),
			r = this.parseImplementsInterfaces(),
			i = this.parseConstDirectives(),
			o = this.parseFieldsDefinition();
		if (r.length === 0 && i.length === 0 && o.length === 0)
			throw this.unexpected();
		return this.node(e, {
			kind: ot.OBJECT_TYPE_EXTENSION,
			name: n,
			interfaces: r,
			directives: i,
			fields: o,
		});
	}
	parseInterfaceTypeExtension() {
		const e = this._lexer.token;
		this.expectKeyword("extend"), this.expectKeyword("interface");
		const n = this.parseName(),
			r = this.parseImplementsInterfaces(),
			i = this.parseConstDirectives(),
			o = this.parseFieldsDefinition();
		if (r.length === 0 && i.length === 0 && o.length === 0)
			throw this.unexpected();
		return this.node(e, {
			kind: ot.INTERFACE_TYPE_EXTENSION,
			name: n,
			interfaces: r,
			directives: i,
			fields: o,
		});
	}
	parseUnionTypeExtension() {
		const e = this._lexer.token;
		this.expectKeyword("extend"), this.expectKeyword("union");
		const n = this.parseName(),
			r = this.parseConstDirectives(),
			i = this.parseUnionMemberTypes();
		if (r.length === 0 && i.length === 0) throw this.unexpected();
		return this.node(e, {
			kind: ot.UNION_TYPE_EXTENSION,
			name: n,
			directives: r,
			types: i,
		});
	}
	parseEnumTypeExtension() {
		const e = this._lexer.token;
		this.expectKeyword("extend"), this.expectKeyword("enum");
		const n = this.parseName(),
			r = this.parseConstDirectives(),
			i = this.parseEnumValuesDefinition();
		if (r.length === 0 && i.length === 0) throw this.unexpected();
		return this.node(e, {
			kind: ot.ENUM_TYPE_EXTENSION,
			name: n,
			directives: r,
			values: i,
		});
	}
	parseInputObjectTypeExtension() {
		const e = this._lexer.token;
		this.expectKeyword("extend"), this.expectKeyword("input");
		const n = this.parseName(),
			r = this.parseConstDirectives(),
			i = this.parseInputFieldsDefinition();
		if (r.length === 0 && i.length === 0) throw this.unexpected();
		return this.node(e, {
			kind: ot.INPUT_OBJECT_TYPE_EXTENSION,
			name: n,
			directives: r,
			fields: i,
		});
	}
	parseDirectiveDefinition() {
		const e = this._lexer.token,
			n = this.parseDescription();
		this.expectKeyword("directive"), this.expectToken(ge.AT);
		const r = this.parseName(),
			i = this.parseArgumentDefs(),
			o = this.expectOptionalKeyword("repeatable");
		this.expectKeyword("on");
		const s = this.parseDirectiveLocations();
		return this.node(e, {
			kind: ot.DIRECTIVE_DEFINITION,
			description: n,
			name: r,
			arguments: i,
			repeatable: o,
			locations: s,
		});
	}
	parseDirectiveLocations() {
		return this.delimitedMany(ge.PIPE, this.parseDirectiveLocation);
	}
	parseDirectiveLocation() {
		const e = this._lexer.token,
			n = this.parseName();
		if (Object.prototype.hasOwnProperty.call(d2, n.value)) return n;
		throw this.unexpected(e);
	}
	node(e, n) {
		return (
			this._options.noLocation !== !0 &&
				(n.loc = new gbe(e, this._lexer.lastToken, this._lexer.source)),
			n
		);
	}
	peek(e) {
		return this._lexer.token.kind === e;
	}
	expectToken(e) {
		const n = this._lexer.token;
		if (n.kind === e) return this.advanceLexer(), n;
		throw fr(
			this._lexer.source,
			n.start,
			`Expected ${cU(e)}, found ${j1(n)}.`,
		);
	}
	expectOptionalToken(e) {
		return this._lexer.token.kind === e ? (this.advanceLexer(), !0) : !1;
	}
	expectKeyword(e) {
		const n = this._lexer.token;
		if (n.kind === ge.NAME && n.value === e) this.advanceLexer();
		else
			throw fr(
				this._lexer.source,
				n.start,
				`Expected "${e}", found ${j1(n)}.`,
			);
	}
	expectOptionalKeyword(e) {
		const n = this._lexer.token;
		return n.kind === ge.NAME && n.value === e
			? (this.advanceLexer(), !0)
			: !1;
	}
	unexpected(e) {
		const n = e ?? this._lexer.token;
		return fr(this._lexer.source, n.start, `Unexpected ${j1(n)}.`);
	}
	any(e, n, r) {
		this.expectToken(e);
		const i = [];
		for (; !this.expectOptionalToken(r); ) i.push(n.call(this));
		return i;
	}
	optionalMany(e, n, r) {
		if (this.expectOptionalToken(e)) {
			const i = [];
			do i.push(n.call(this));
			while (!this.expectOptionalToken(r));
			return i;
		}
		return [];
	}
	many(e, n, r) {
		this.expectToken(e);
		const i = [];
		do i.push(n.call(this));
		while (!this.expectOptionalToken(r));
		return i;
	}
	delimitedMany(e, n) {
		this.expectOptionalToken(e);
		const r = [];
		do r.push(n.call(this));
		while (this.expectOptionalToken(e));
		return r;
	}
	advanceLexer() {
		const { maxTokens: e } = this._options,
			n = this._lexer.advance();
		if (
			e !== void 0 &&
			n.kind !== ge.EOF &&
			(++this._tokenCounter, this._tokenCounter > e)
		)
			throw fr(
				this._lexer.source,
				n.start,
				`Document contains more that ${e} tokens. Parsing aborted.`,
			);
	}
};
function j1(t) {
	const e = t.value;
	return cU(t.kind) + (e != null ? ` "${e}"` : "");
}
function cU(t) {
	return wbe(t) ? `"${t}"` : t;
}
var yb = new Map(),
	f2 = new Map(),
	dU = !0,
	ny = !1;
function fU(t) {
	return t.replace(/[\s,]+/g, " ").trim();
}
function Ube(t) {
	return fU(t.source.body.substring(t.start, t.end));
}
function Hbe(t) {
	var e = new Set(),
		n = [];
	return (
		t.definitions.forEach(function (r) {
			if (r.kind === "FragmentDefinition") {
				var i = r.name.value,
					o = Ube(r.loc),
					s = f2.get(i);
				s && !s.has(o)
					? dU &&
						console.warn(
							"Warning: fragment with name " +
								i +
								` already exists.
graphql-tag enforces all fragment names across your application to be unique; read more about
this in the docs: http://dev.apollodata.com/core/fragments.html#unique-names`,
						)
					: s || f2.set(i, (s = new Set())),
					s.add(o),
					e.has(o) || (e.add(o), n.push(r));
			} else n.push(r);
		}),
		nv(nv({}, t), { definitions: n })
	);
}
function Wbe(t) {
	var e = new Set(t.definitions);
	e.forEach(function (r) {
		r.loc && delete r.loc,
			Object.keys(r).forEach(function (i) {
				var o = r[i];
				o && typeof o == "object" && e.add(o);
			});
	});
	var n = t.loc;
	return n && (delete n.startToken, delete n.endToken), t;
}
function qbe(t) {
	var e = fU(t);
	if (!yb.has(e)) {
		var n = Vbe(t, {
			experimentalFragmentVariables: ny,
			allowLegacyFragmentVariables: ny,
		});
		if (!n || n.kind !== "Document")
			throw new Error("Not a valid GraphQL document.");
		yb.set(e, Wbe(Hbe(n)));
	}
	return yb.get(e);
}
function yr(t) {
	for (var e = [], n = 1; n < arguments.length; n++) e[n - 1] = arguments[n];
	typeof t == "string" && (t = [t]);
	var r = t[0];
	return (
		e.forEach(function (i, o) {
			i && i.kind === "Document" ? (r += i.loc.source.body) : (r += i),
				(r += t[o + 1]);
		}),
		qbe(r)
	);
}
function Gbe() {
	yb.clear(), f2.clear();
}
function Ybe() {
	dU = !1;
}
function Jbe() {
	ny = !0;
}
function Xbe() {
	ny = !1;
}
var Np = {
	gql: yr,
	resetCaches: Gbe,
	disableFragmentWarnings: Ybe,
	enableExperimentalFragmentVariables: Jbe,
	disableExperimentalFragmentVariables: Xbe,
};
(function (t) {
	(t.gql = Np.gql),
		(t.resetCaches = Np.resetCaches),
		(t.disableFragmentWarnings = Np.disableFragmentWarnings),
		(t.enableExperimentalFragmentVariables =
			Np.enableExperimentalFragmentVariables),
		(t.disableExperimentalFragmentVariables =
			Np.disableExperimentalFragmentVariables);
})(yr || (yr = {}));
yr.default = yr;
var ea = {
	NAME: "Name",
	DOCUMENT: "Document",
	OPERATION_DEFINITION: "OperationDefinition",
	VARIABLE_DEFINITION: "VariableDefinition",
	SELECTION_SET: "SelectionSet",
	FIELD: "Field",
	ARGUMENT: "Argument",
	FRAGMENT_SPREAD: "FragmentSpread",
	INLINE_FRAGMENT: "InlineFragment",
	FRAGMENT_DEFINITION: "FragmentDefinition",
	VARIABLE: "Variable",
	INT: "IntValue",
	FLOAT: "FloatValue",
	STRING: "StringValue",
	BOOLEAN: "BooleanValue",
	NULL: "NullValue",
	ENUM: "EnumValue",
	LIST: "ListValue",
	OBJECT: "ObjectValue",
	OBJECT_FIELD: "ObjectField",
	DIRECTIVE: "Directive",
	NAMED_TYPE: "NamedType",
	LIST_TYPE: "ListType",
	NON_NULL_TYPE: "NonNullType",
};
class h2 extends Error {
	constructor(e, n, r, i, o, s, a) {
		super(e),
			(this.name = "GraphQLError"),
			(this.message = e),
			o && (this.path = o),
			n && (this.nodes = Array.isArray(n) ? n : [n]),
			r && (this.source = r),
			i && (this.positions = i),
			s && (this.originalError = s);
		var l = a;
		if (!l && s) {
			var u = s.extensions;
			u && typeof u == "object" && (l = u);
		}
		this.extensions = l || {};
	}
	toJSON() {
		return { ...this, message: this.message };
	}
	toString() {
		return this.message;
	}
	get [Symbol.toStringTag]() {
		return "GraphQLError";
	}
}
var Ft, et;
function Rn(t) {
	return new h2(`Syntax Error: Unexpected token at ${et} in ${t}`);
}
function uo(t) {
	if (((t.lastIndex = et), t.test(Ft)))
		return Ft.slice(et, (et = t.lastIndex));
}
var _1 = / +(?=[^\s])/y;
function Zbe(t) {
	for (
		var e = t.split(`
`),
			n = "",
			r = 0,
			i = 0,
			o = e.length - 1,
			s = 0;
		s < e.length;
		s++
	)
		(_1.lastIndex = 0),
			_1.test(e[s]) &&
				(s && (!r || _1.lastIndex < r) && (r = _1.lastIndex),
				(i = i || s),
				(o = s));
	for (var a = i; a <= o; a++)
		a !== i &&
			(n += `
`),
			(n += e[a].slice(r).replace(/\\"""/g, '"""'));
	return n;
}
function yt() {
	for (
		var t = 0 | Ft.charCodeAt(et++);
		t === 9 ||
		t === 10 ||
		t === 13 ||
		t === 32 ||
		t === 35 ||
		t === 44 ||
		t === 65279;
		t = 0 | Ft.charCodeAt(et++)
	)
		if (t === 35) for (; (t = Ft.charCodeAt(et++)) !== 10 && t !== 13; );
	et--;
}
var pi = /[_A-Za-z]\w*/y,
	jk = new RegExp(
		"(?:(null|true|false)|\\$(" +
			pi.source +
			')|(-?\\d+)((?:\\.\\d+)?[eE][+-]?\\d+|\\.\\d+)?|("""(?:"""|(?:[\\s\\S]*?[^\\\\])"""))|("(?:"|[^\\r\\n]*?[^\\\\]"))|(' +
			pi.source +
			"))",
		"y",
	),
	Wl = (function (t) {
		return (
			(t[(t.Const = 1)] = "Const"),
			(t[(t.Var = 2)] = "Var"),
			(t[(t.Int = 3)] = "Int"),
			(t[(t.Float = 4)] = "Float"),
			(t[(t.BlockString = 5)] = "BlockString"),
			(t[(t.String = 6)] = "String"),
			(t[(t.Enum = 7)] = "Enum"),
			t
		);
	})(Wl || {}),
	Qbe = /\\/;
function ry(t) {
	var e, n;
	if (((jk.lastIndex = et), Ft.charCodeAt(et) === 91)) {
		et++, yt();
		for (var r = []; Ft.charCodeAt(et) !== 93; ) r.push(ry(t));
		return et++, yt(), { kind: "ListValue", values: r };
	} else if (Ft.charCodeAt(et) === 123) {
		et++, yt();
		for (var i = []; Ft.charCodeAt(et) !== 125; ) {
			if ((e = uo(pi)) == null || (yt(), Ft.charCodeAt(et++) !== 58))
				throw Rn("ObjectField");
			yt(),
				i.push({
					kind: "ObjectField",
					name: { kind: "Name", value: e },
					value: ry(t),
				});
		}
		return et++, yt(), { kind: "ObjectValue", fields: i };
	} else if ((n = jk.exec(Ft)) != null) {
		if (((et = jk.lastIndex), yt(), (e = n[Wl.Const]) != null))
			return e === "null"
				? { kind: "NullValue" }
				: { kind: "BooleanValue", value: e === "true" };
		if ((e = n[Wl.Var]) != null) {
			if (t) throw Rn("Variable");
			return { kind: "Variable", name: { kind: "Name", value: e } };
		} else if ((e = n[Wl.Int]) != null) {
			var o;
			return (o = n[Wl.Float]) != null
				? { kind: "FloatValue", value: e + o }
				: { kind: "IntValue", value: e };
		} else {
			if ((e = n[Wl.BlockString]) != null)
				return {
					kind: "StringValue",
					value: Zbe(e.slice(3, -3)),
					block: !0,
				};
			if ((e = n[Wl.String]) != null)
				return {
					kind: "StringValue",
					value: Qbe.test(e) ? JSON.parse(e) : e.slice(1, -1),
					block: !1,
				};
			if ((e = n[Wl.Enum]) != null)
				return { kind: "EnumValue", value: e };
		}
	}
	throw Rn("Value");
}
function hU(t) {
	if (Ft.charCodeAt(et) === 40) {
		var e = [];
		et++, yt();
		var n;
		do {
			if ((n = uo(pi)) == null || (yt(), Ft.charCodeAt(et++) !== 58))
				throw Rn("Argument");
			yt(),
				e.push({
					kind: "Argument",
					name: { kind: "Name", value: n },
					value: ry(t),
				});
		} while (Ft.charCodeAt(et) !== 41);
		return et++, yt(), e;
	}
}
function lh(t) {
	if (Ft.charCodeAt(et) === 64) {
		var e = [],
			n;
		do {
			if ((et++, (n = uo(pi)) == null)) throw Rn("Directive");
			yt(),
				e.push({
					kind: "Directive",
					name: { kind: "Name", value: n },
					arguments: hU(t),
				});
		} while (Ft.charCodeAt(et) === 64);
		return e;
	}
}
function eve() {
	for (var t, e = 0; Ft.charCodeAt(et) === 91; ) e++, et++, yt();
	if ((t = uo(pi)) == null) throw Rn("NamedType");
	yt();
	var n = { kind: "NamedType", name: { kind: "Name", value: t } };
	do
		if (
			(Ft.charCodeAt(et) === 33 &&
				(et++, yt(), (n = { kind: "NonNullType", type: n })),
			e)
		) {
			if (Ft.charCodeAt(et++) !== 93) throw Rn("NamedType");
			yt(), (n = { kind: "ListType", type: n });
		}
	while (e--);
	return n;
}
var _k = new RegExp("(?:(\\.{3})|(" + pi.source + "))", "y"),
	p2 = (function (t) {
		return (t[(t.Spread = 1)] = "Spread"), (t[(t.Name = 2)] = "Name"), t;
	})(p2 || {});
function iy() {
	var t = [],
		e,
		n;
	do
		if (((_k.lastIndex = et), (n = _k.exec(Ft)) != null)) {
			if (((et = _k.lastIndex), n[p2.Spread] != null)) {
				yt();
				var r = uo(pi);
				if (r != null && r !== "on")
					yt(),
						t.push({
							kind: "FragmentSpread",
							name: { kind: "Name", value: r },
							directives: lh(!1),
						});
				else {
					if ((yt(), r === "on")) {
						if ((r = uo(pi)) == null) throw Rn("NamedType");
						yt();
					}
					var i = lh(!1);
					if (Ft.charCodeAt(et++) !== 123) throw Rn("InlineFragment");
					yt(),
						t.push({
							kind: "InlineFragment",
							typeCondition: r
								? {
										kind: "NamedType",
										name: { kind: "Name", value: r },
									}
								: void 0,
							directives: i,
							selectionSet: iy(),
						});
				}
			} else if ((e = n[p2.Name]) != null) {
				var o = void 0;
				if ((yt(), Ft.charCodeAt(et) === 58)) {
					if ((et++, yt(), (o = e), (e = uo(pi)) == null))
						throw Rn("Field");
					yt();
				}
				var s = hU(!1);
				yt();
				var a = lh(!1),
					l = void 0;
				Ft.charCodeAt(et) === 123 && (et++, yt(), (l = iy())),
					t.push({
						kind: "Field",
						alias: o ? { kind: "Name", value: o } : void 0,
						name: { kind: "Name", value: e },
						arguments: s,
						directives: a,
						selectionSet: l,
					});
			}
		} else throw Rn("SelectionSet");
	while (Ft.charCodeAt(et) !== 125);
	return et++, yt(), { kind: "SelectionSet", selections: t };
}
function tve() {
	var t, e;
	if (
		(t = uo(pi)) == null ||
		(yt(), uo(pi) !== "on") ||
		(yt(), (e = uo(pi)) == null)
	)
		throw Rn("FragmentDefinition");
	yt();
	var n = lh(!1);
	if (Ft.charCodeAt(et++) !== 123) throw Rn("FragmentDefinition");
	return (
		yt(),
		{
			kind: "FragmentDefinition",
			name: { kind: "Name", value: t },
			typeCondition: {
				kind: "NamedType",
				name: { kind: "Name", value: e },
			},
			directives: n,
			selectionSet: iy(),
		}
	);
}
var nve = /(?:query|mutation|subscription|fragment)/y;
function rve(t) {
	var e, n, r;
	if (
		(t &&
			(yt(),
			(e = uo(pi)),
			(n = (function () {
				if ((yt(), Ft.charCodeAt(et) === 40)) {
					var o = [];
					et++, yt();
					var s;
					do {
						if (Ft.charCodeAt(et++) !== 36 || (s = uo(pi)) == null)
							throw Rn("Variable");
						if ((yt(), Ft.charCodeAt(et++) !== 58))
							throw Rn("VariableDefinition");
						yt();
						var a = eve(),
							l = void 0;
						Ft.charCodeAt(et) === 61 && (et++, yt(), (l = ry(!0))),
							yt(),
							o.push({
								kind: "VariableDefinition",
								variable: {
									kind: "Variable",
									name: { kind: "Name", value: s },
								},
								type: a,
								defaultValue: l,
								directives: lh(!0),
							});
					} while (Ft.charCodeAt(et) !== 41);
					return et++, yt(), o;
				}
			})()),
			(r = lh(!1))),
		Ft.charCodeAt(et) === 123)
	)
		return (
			et++,
			yt(),
			{
				kind: "OperationDefinition",
				operation: t || "query",
				name: e ? { kind: "Name", value: e } : void 0,
				variableDefinitions: n,
				directives: r,
				selectionSet: iy(),
			}
		);
}
function ive(t, e) {
	return (
		(Ft = typeof t.body == "string" ? t.body : t),
		(et = 0),
		(function () {
			var r, i;
			yt();
			var o = [];
			do
				if ((r = uo(nve)) === "fragment") yt(), o.push(tve());
				else if ((i = rve(r)) != null) o.push(i);
				else throw Rn("Document");
			while (et < Ft.length);
			return { kind: "Document", definitions: o };
		})()
	);
}
function wi(t, e, n) {
	for (var r = "", i = 0; i < t.length; i++) i && (r += e), (r += n(t[i]));
	return r;
}
function ove(t) {
	return JSON.stringify(t);
}
function sve(t) {
	return (
		`"""
` +
		t.replace(/"""/g, '\\"""') +
		`
"""`
	);
}
var Hs = `
`,
	Mn = {
		OperationDefinition(t) {
			var e = t.operation;
			return (
				t.name && (e += " " + t.name.value),
				t.variableDefinitions &&
					t.variableDefinitions.length &&
					(t.name || (e += " "),
					(e +=
						"(" +
						wi(t.variableDefinitions, ", ", Mn.VariableDefinition) +
						")")),
				t.directives &&
					t.directives.length &&
					(e += " " + wi(t.directives, " ", Mn.Directive)),
				e !== "query"
					? e + " " + Mn.SelectionSet(t.selectionSet)
					: Mn.SelectionSet(t.selectionSet)
			);
		},
		VariableDefinition(t) {
			var e = Mn.Variable(t.variable) + ": " + Va(t.type);
			return (
				t.defaultValue && (e += " = " + Va(t.defaultValue)),
				t.directives &&
					t.directives.length &&
					(e += " " + wi(t.directives, " ", Mn.Directive)),
				e
			);
		},
		Field(t) {
			var e = t.alias
				? t.alias.value + ": " + t.name.value
				: t.name.value;
			if (t.arguments && t.arguments.length) {
				var n = wi(t.arguments, ", ", Mn.Argument);
				e.length + n.length + 2 > 80
					? (e +=
							"(" +
							(Hs += "  ") +
							wi(t.arguments, Hs, Mn.Argument) +
							(Hs = Hs.slice(0, -2)) +
							")")
					: (e += "(" + n + ")");
			}
			return (
				t.directives &&
					t.directives.length &&
					(e += " " + wi(t.directives, " ", Mn.Directive)),
				t.selectionSet && (e += " " + Mn.SelectionSet(t.selectionSet)),
				e
			);
		},
		StringValue(t) {
			return t.block ? sve(t.value).replace(/\n/g, Hs) : ove(t.value);
		},
		BooleanValue: (t) => "" + t.value,
		NullValue: (t) => "null",
		IntValue: (t) => t.value,
		FloatValue: (t) => t.value,
		EnumValue: (t) => t.value,
		Name: (t) => t.value,
		Variable: (t) => "$" + t.name.value,
		ListValue: (t) => "[" + wi(t.values, ", ", Va) + "]",
		ObjectValue: (t) => "{" + wi(t.fields, ", ", Mn.ObjectField) + "}",
		ObjectField: (t) => t.name.value + ": " + Va(t.value),
		Document(t) {
			return !t.definitions || !t.definitions.length
				? ""
				: wi(
						t.definitions,
						`

`,
						Va,
					);
		},
		SelectionSet: (t) =>
			"{" +
			(Hs += "  ") +
			wi(t.selections, Hs, Va) +
			(Hs = Hs.slice(0, -2)) +
			"}",
		Argument: (t) => t.name.value + ": " + Va(t.value),
		FragmentSpread(t) {
			var e = "..." + t.name.value;
			return (
				t.directives &&
					t.directives.length &&
					(e += " " + wi(t.directives, " ", Mn.Directive)),
				e
			);
		},
		InlineFragment(t) {
			var e = "...";
			return (
				t.typeCondition && (e += " on " + t.typeCondition.name.value),
				t.directives &&
					t.directives.length &&
					(e += " " + wi(t.directives, " ", Mn.Directive)),
				(e += " " + Mn.SelectionSet(t.selectionSet))
			);
		},
		FragmentDefinition(t) {
			var e = "fragment " + t.name.value;
			return (
				(e += " on " + t.typeCondition.name.value),
				t.directives &&
					t.directives.length &&
					(e += " " + wi(t.directives, " ", Mn.Directive)),
				e + " " + Mn.SelectionSet(t.selectionSet)
			);
		},
		Directive(t) {
			var e = "@" + t.name.value;
			return (
				t.arguments &&
					t.arguments.length &&
					(e += "(" + wi(t.arguments, ", ", Mn.Argument) + ")"),
				e
			);
		},
		NamedType: (t) => t.name.value,
		ListType: (t) => "[" + Va(t.type) + "]",
		NonNullType: (t) => Va(t.type) + "!",
	},
	Va = (t) => Mn[t.kind](t);
function ave(t) {
	return (
		(Hs = `
`),
		Mn[t.kind] ? Mn[t.kind](t) : ""
	);
}
function Fh(t, e) {
	switch (t.kind) {
		case "NullValue":
			return null;
		case "IntValue":
			return parseInt(t.value, 10);
		case "FloatValue":
			return parseFloat(t.value);
		case "StringValue":
		case "EnumValue":
		case "BooleanValue":
			return t.value;
		case "ListValue":
			var n = [];
			for (var r of t.values) n.push(Fh(r, e));
			return n;
		case "ObjectValue":
			var i = Object.create(null);
			for (var o of t.fields) i[o.name.value] = Fh(o.value, e);
			return i;
		case "Variable":
			return e && e[t.name.value];
	}
}
var XS = () => {},
	co = XS;
function Zo(t) {
	return { tag: 0, 0: t };
}
function F0(t) {
	return { tag: 1, 0: t };
}
var UB = () =>
		(typeof Symbol == "function" && Symbol.asyncIterator) ||
		"@@asyncIterator",
	lve = (t) => t;
function hn(t) {
	return (e) => (n) => {
		var r = co;
		e((i) => {
			i === 0
				? n(0)
				: i.tag === 0
					? ((r = i[0]), n(i))
					: t(i[0])
						? n(i)
						: r(0);
		});
	};
}
function ou(t) {
	return (e) => (n) =>
		e((r) => {
			r === 0 || r.tag === 0 ? n(r) : n(F0(t(r[0])));
		});
}
function l3(t) {
	return (e) => (n) => {
		var r = [],
			i = co,
			o = !1,
			s = !1;
		e((a) => {
			s ||
				(a === 0
					? ((s = !0), r.length || n(0))
					: a.tag === 0
						? (i = a[0])
						: ((o = !1),
							(function (u) {
								var c = co;
								u((d) => {
									if (d === 0) {
										if (r.length) {
											var f = r.indexOf(c);
											f > -1 &&
												(r = r.slice()).splice(f, 1),
												r.length ||
													(s
														? n(0)
														: o ||
															((o = !0), i(0)));
										}
									} else
										d.tag === 0
											? (r.push((c = d[0])), c(0))
											: r.length && (n(d), c(0));
								});
							})(t(a[0])),
							o || ((o = !0), i(0))));
		}),
			n(
				Zo((a) => {
					if (a === 1) {
						s || ((s = !0), i(1));
						for (var l = 0, u = r, c = r.length; l < c; l++)
							u[l](1);
						r.length = 0;
					} else {
						!s && !o ? ((o = !0), i(0)) : (o = !1);
						for (var d = 0, f = r, h = r.length; d < h; d++)
							f[d](0);
					}
				}),
			);
	};
}
function uve(t) {
	return l3(lve)(t);
}
function Yu(t) {
	return uve(gU(t));
}
function ZS(t) {
	return (e) => (n) => {
		var r = !1;
		e((i) => {
			if (!r)
				if (i === 0) (r = !0), n(0), t();
				else if (i.tag === 0) {
					var o = i[0];
					n(
						Zo((s) => {
							s === 1 ? ((r = !0), o(1), t()) : o(s);
						}),
					);
				} else n(i);
		});
	};
}
function oy(t) {
	return (e) => (n) => {
		var r = !1;
		e((i) => {
			if (!r)
				if (i === 0) (r = !0), n(0);
				else if (i.tag === 0) {
					var o = i[0];
					n(
						Zo((s) => {
							s === 1 && (r = !0), o(s);
						}),
					);
				} else t(i[0]), n(i);
		});
	};
}
function m2(t) {
	return (e) => (n) =>
		e((r) => {
			r === 0 ? n(0) : r.tag === 0 ? (n(r), t()) : n(r);
		});
}
function Ph(t) {
	var e = [],
		n = co,
		r = !1;
	return (i) => {
		e.push(i),
			e.length === 1 &&
				t((o) => {
					if (o === 0) {
						for (var s = 0, a = e, l = e.length; s < l; s++)
							a[s](0);
						e.length = 0;
					} else if (o.tag === 0) n = o[0];
					else {
						r = !1;
						for (var u = 0, c = e, d = e.length; u < d; u++)
							c[u](o);
					}
				}),
			i(
				Zo((o) => {
					if (o === 1) {
						var s = e.indexOf(i);
						s > -1 && (e = e.slice()).splice(s, 1),
							e.length || n(1);
					} else r || ((r = !0), n(0));
				}),
			);
	};
}
function HB(t) {
	return (e) => (n) => {
		var r = co,
			i = co,
			o = !1,
			s = !1,
			a = !1,
			l = !1;
		e((u) => {
			l ||
				(u === 0
					? ((l = !0), a || n(0))
					: u.tag === 0
						? (r = u[0])
						: (a && (i(1), (i = co)),
							o ? (o = !1) : ((o = !0), r(0)),
							(function (d) {
								(a = !0),
									d((f) => {
										a &&
											(f === 0
												? ((a = !1),
													l
														? n(0)
														: o || ((o = !0), r(0)))
												: f.tag === 0
													? ((s = !1), (i = f[0])(0))
													: (n(f),
														s ? (s = !1) : i(0)));
									});
							})(t(u[0]))));
		}),
			n(
				Zo((u) => {
					u === 1
						? (l || ((l = !0), r(1)), a && ((a = !1), i(1)))
						: (!l && !o && ((o = !0), r(0)),
							a && !s && ((s = !0), i(0)));
				}),
			);
	};
}
function u3(t) {
	return (e) => (n) => {
		var r = co,
			i = !1,
			o = 0;
		e((s) => {
			i ||
				(s === 0
					? ((i = !0), n(0))
					: s.tag === 0
						? (r = s[0])
						: o++ < t
							? (n(s), !i && o >= t && ((i = !0), n(0), r(1)))
							: n(s));
		}),
			n(
				Zo((s) => {
					s === 1 && !i
						? ((i = !0), r(1))
						: s === 0 && !i && o < t && r(0);
				}),
			);
	};
}
function QS(t) {
	return (e) => (n) => {
		var r = co,
			i = co,
			o = !1;
		e((s) => {
			o ||
				(s === 0
					? ((o = !0), i(1), n(0))
					: s.tag === 0
						? ((r = s[0]),
							t((a) => {
								a === 0 ||
									(a.tag === 0
										? (i = a[0])(0)
										: ((o = !0), i(1), r(1), n(0)));
							}))
						: n(s));
		}),
			n(
				Zo((s) => {
					s === 1 && !o ? ((o = !0), r(1), i(1)) : o || r(0);
				}),
			);
	};
}
function pU(t, e) {
	return (n) => (r) => {
		var i = co,
			o = !1;
		n((s) => {
			o ||
				(s === 0
					? ((o = !0), r(0))
					: s.tag === 0
						? ((i = s[0]), r(s))
						: t(s[0])
							? r(s)
							: ((o = !0), e && r(s), r(0), i(1)));
		});
	};
}
function cve(t) {
	return (e) => t()(e);
}
function mU(t) {
	return (e) => {
		var n = (t[UB()] && t[UB()]()) || t,
			r = !1,
			i = !1,
			o = !1,
			s;
		e(
			Zo(async (a) => {
				if (a === 1) (r = !0), n.return && n.return();
				else if (i) o = !0;
				else {
					for (o = i = !0; o && !r; )
						if ((s = await n.next()).done)
							(r = !0), n.return && (await n.return()), e(0);
						else
							try {
								(o = !1), e(F0(s.value));
							} catch (l) {
								if (n.throw)
									(r = !!(await n.throw(l)).done) && e(0);
								else throw l;
							}
					i = !1;
				}
			}),
		);
	};
}
function dve(t) {
	return t[Symbol.asyncIterator]
		? mU(t)
		: (e) => {
				var n = t[Symbol.iterator](),
					r = !1,
					i = !1,
					o = !1,
					s;
				e(
					Zo((a) => {
						if (a === 1) (r = !0), n.return && n.return();
						else if (i) o = !0;
						else {
							for (o = i = !0; o && !r; )
								if ((s = n.next()).done)
									(r = !0), n.return && n.return(), e(0);
								else
									try {
										(o = !1), e(F0(s.value));
									} catch (l) {
										if (n.throw)
											(r = !!n.throw(l).done) && e(0);
										else throw l;
									}
							i = !1;
						}
					}),
				);
			};
}
var gU = dve;
function zk(t) {
	return (e) => {
		var n = !1;
		e(
			Zo((r) => {
				r === 1 ? (n = !0) : n || ((n = !0), e(F0(t)), e(0));
			}),
		);
	};
}
function bU(t) {
	return (e) => {
		var n = !1,
			r = t({
				next(i) {
					n || e(F0(i));
				},
				complete() {
					n || ((n = !0), e(0));
				},
			});
		e(
			Zo((i) => {
				i === 1 && !n && ((n = !0), r());
			}),
		);
	};
}
function sy() {
	var t, e;
	return {
		source: Ph(bU((n) => ((t = n.next), (e = n.complete), XS))),
		next(n) {
			t && t(n);
		},
		complete() {
			e && e();
		},
	};
}
var fve = (t) => {
	var e = !1;
	t(
		Zo((n) => {
			n === 1 ? (e = !0) : e || ((e = !0), t(0));
		}),
	);
};
function hve(t) {
	return bU(
		(e) => (
			t.then((n) => {
				Promise.resolve(n).then(() => {
					e.next(n), e.complete();
				});
			}),
			XS
		),
	);
}
function Nh(t) {
	return (e) => {
		var n = co,
			r = !1;
		return (
			e((i) => {
				i === 0
					? (r = !0)
					: i.tag === 0
						? (n = i[0])(0)
						: r || (t(i[0]), n(0));
			}),
			{
				unsubscribe() {
					r || ((r = !0), n(1));
				},
			}
		);
	};
}
function pve(t) {
	Nh((e) => {})(t);
}
function e5(t) {
	return new Promise((e) => {
		var n = co,
			r;
		t((i) => {
			i === 0
				? Promise.resolve(r).then(e)
				: i.tag === 0
					? (n = i[0])(0)
					: ((r = i[0]), n(0));
		});
	});
}
var mve = (t) =>
	t &&
	typeof t.message == "string" &&
	(t.extensions || t.name === "GraphQLError")
		? t
		: typeof t == "object" && typeof t.message == "string"
			? new h2(
					t.message,
					t.nodes,
					t.source,
					t.positions,
					t.path,
					t,
					t.extensions || {},
				)
			: new h2(t);
class t5 extends Error {
	constructor(e) {
		var n = (e.graphQLErrors || []).map(mve),
			r = ((i, o) => {
				var s = "";
				if (i) return `[Network] ${i.message}`;
				if (o)
					for (var a of o)
						s &&
							(s += `
`),
							(s += `[GraphQL] ${a.message}`);
				return s;
			})(e.networkError, n);
		super(r),
			(this.name = "CombinedError"),
			(this.message = r),
			(this.graphQLErrors = n),
			(this.networkError = e.networkError),
			(this.response = e.response);
	}
	toString() {
		return this.message;
	}
}
var xb = (t, e) => {
		for (var n = 0 | (e || 5381), r = 0, i = 0 | t.length; r < i; r++)
			n = (n << 5) + n + t.charCodeAt(r);
		return n;
	},
	td = new Set(),
	WB = new WeakMap(),
	Bf = (t, e) => {
		if (t === null || td.has(t)) return "null";
		if (typeof t != "object") return JSON.stringify(t) || "";
		if (t.toJSON) return Bf(t.toJSON(), e);
		if (Array.isArray(t)) {
			var n = "[";
			for (var r of t)
				n.length > 1 && (n += ","), (n += Bf(r, e) || "null");
			return (n += "]");
		} else if (
			!e &&
			((ay !== Rh && t instanceof ay) || (ly !== Rh && t instanceof ly))
		)
			return "null";
		var i = Object.keys(t).sort();
		if (
			!i.length &&
			t.constructor &&
			Object.getPrototypeOf(t).constructor !==
				Object.prototype.constructor
		) {
			var o = WB.get(t) || Math.random().toString(36).slice(2);
			return WB.set(t, o), Bf({ __key: o }, e);
		}
		td.add(t);
		var s = "{";
		for (var a of i) {
			var l = Bf(t[a], e);
			l && (s.length > 1 && (s += ","), (s += Bf(a, e) + ":" + l));
		}
		return td.delete(t), (s += "}");
	},
	g2 = (t, e, n) => {
		if (!(n == null || typeof n != "object" || n.toJSON || td.has(n)))
			if (Array.isArray(n))
				for (var r = 0, i = n.length; r < i; r++)
					g2(t, `${e}.${r}`, n[r]);
			else if (n instanceof ay || n instanceof ly) t.set(e, n);
			else {
				td.add(n);
				for (var o of Object.keys(n)) g2(t, `${e}.${o}`, n[o]);
			}
	},
	Cl = (t, e) => (td.clear(), Bf(t, e || !1));
class Rh {}
var ay = typeof File < "u" ? File : Rh,
	ly = typeof Blob < "u" ? Blob : Rh,
	gve = /("{3}[\s\S]*"{3}|"(?:\\.|[^"])*")/g,
	bve = /(?:#[^\n\r]+)?(?:[\r\n]+|$)/g,
	vve = (t, e) =>
		e % 2 == 0
			? t.replace(
					bve,
					`
`,
				)
			: t,
	qB = (t) => t.split(gve).map(vve).join("").trim(),
	GB = new Map(),
	kb = new Map(),
	c3 = (t) => {
		var e;
		return (
			typeof t == "string"
				? (e = qB(t))
				: t.loc && kb.get(t.__key) === t
					? (e = t.loc.source.body)
					: ((e = GB.get(t) || qB(ave(t))), GB.set(t, e)),
			typeof t != "string" &&
				!t.loc &&
				(t.loc = {
					start: 0,
					end: e.length,
					source: {
						body: e,
						name: "gql",
						locationOffset: { line: 1, column: 1 },
					},
				}),
			e
		);
	},
	YB = (t) => {
		var e;
		if (t.documentId) e = xb(t.documentId);
		else if (((e = xb(c3(t))), t.definitions)) {
			var n = yU(t);
			n &&
				(e = xb(
					`
# ${n}`,
					e,
				));
		}
		return e;
	},
	vU = (t) => {
		var e, n;
		return (
			typeof t == "string"
				? ((e = YB(t)), (n = kb.get(e) || ive(t)))
				: ((e = t.__key || YB(t)), (n = kb.get(e) || t)),
			n.loc || c3(n),
			(n.__key = e),
			kb.set(e, n),
			n
		);
	},
	Tu = (t, e, n) => {
		var r = e || {},
			i = vU(t),
			o = Cl(r, !0),
			s = i.__key;
		return (
			o !== "{}" && (s = xb(o, s)),
			{ key: s, query: i, variables: r, extensions: n }
		);
	},
	yU = (t) => {
		for (var e of t.definitions)
			if (e.kind === ea.OPERATION_DEFINITION)
				return e.name ? e.name.value : void 0;
	},
	JB = (t, e, n) => {
		if (!("data" in e || ("errors" in e && Array.isArray(e.errors))))
			throw new Error("No Content");
		var r = t.kind === "subscription";
		return {
			operation: t,
			data: e.data,
			error: Array.isArray(e.errors)
				? new t5({ graphQLErrors: e.errors, response: n })
				: void 0,
			extensions: e.extensions ? { ...e.extensions } : void 0,
			hasNext: e.hasNext == null ? r : e.hasNext,
			stale: !1,
		};
	},
	b2 = (t, e) => {
		if (
			typeof t == "object" &&
			t != null &&
			(!t.constructor || t.constructor === Object || Array.isArray(t))
		) {
			t = Array.isArray(t) ? [...t] : { ...t };
			for (var n of Object.keys(e)) t[n] = b2(t[n], e[n]);
			return t;
		}
		return e;
	},
	yve = (t, e, n, r) => {
		var i = t.error ? t.error.graphQLErrors : [],
			o = !!t.extensions || !!(e.payload || e).extensions,
			s = { ...t.extensions, ...(e.payload || e).extensions },
			a = e.incremental;
		"path" in e && (a = [e]);
		var l = { data: t.data };
		if (a) {
			var u = function (d) {
				Array.isArray(d.errors) && i.push(...d.errors),
					d.extensions && (Object.assign(s, d.extensions), (o = !0));
				var f = "data",
					h = l,
					p = [];
				if (d.path) p = d.path;
				else if (r) {
					var g = r.find((k) => k.id === d.id);
					d.subPath ? (p = [...g.path, ...d.subPath]) : (p = g.path);
				}
				for (var v = 0, b = p.length; v < b; f = p[v++])
					h = h[f] = Array.isArray(h[f]) ? [...h[f]] : { ...h[f] };
				if (d.items)
					for (
						var y = +f >= 0 ? f : 0, x = 0, C = d.items.length;
						x < C;
						x++
					)
						h[y + x] = b2(h[y + x], d.items[x]);
				else d.data !== void 0 && (h[f] = b2(h[f], d.data));
			};
			for (var c of a) u(c);
		} else
			(l.data = (e.payload || e).data || t.data),
				(i = e.errors || (e.payload && e.payload.errors) || i);
		return {
			operation: t.operation,
			data: l.data,
			error: i.length
				? new t5({ graphQLErrors: i, response: n })
				: void 0,
			extensions: o ? s : void 0,
			hasNext: e.hasNext != null ? e.hasNext : t.hasNext,
			stale: !1,
		};
	},
	xU = (t, e, n) => ({
		operation: t,
		data: void 0,
		error: new t5({ networkError: e, response: n }),
		extensions: void 0,
		hasNext: !1,
		stale: !1,
	});
function xve(t) {
	var e = {
		query: void 0,
		documentId: void 0,
		operationName: yU(t.query),
		variables: t.variables || void 0,
		extensions: t.extensions,
	};
	return (
		"documentId" in t.query &&
		t.query.documentId &&
		(!t.query.definitions || !t.query.definitions.length)
			? (e.documentId = t.query.documentId)
			: (!t.extensions ||
					!t.extensions.persistedQuery ||
					t.extensions.persistedQuery.miss) &&
				(e.query = c3(t.query)),
		e
	);
}
var kve = (t, e) => {
		var n = t.kind === "query" && t.context.preferGetMethod;
		if (!n || !e) return t.context.url;
		var r = Cve(t.context.url);
		for (var i in e) {
			var o = e[i];
			o && r[1].set(i, typeof o == "object" ? Cl(o) : o);
		}
		var s = r.join("?");
		return s.length > 2047 && n !== "force"
			? ((t.context.preferGetMethod = !1), t.context.url)
			: s;
	},
	Cve = (t) => {
		var e = t.indexOf("?");
		return e > -1
			? [t.slice(0, e), new URLSearchParams(t.slice(e + 1))]
			: [t, new URLSearchParams()];
	},
	wve = (t, e) => {
		if (e && !(t.kind === "query" && t.context.preferGetMethod)) {
			var n = Cl(e),
				r = ((a) => {
					var l = new Map();
					return (
						(ay !== Rh || ly !== Rh) &&
							(td.clear(), g2(l, "variables", a)),
						l
					);
				})(e.variables);
			if (r.size) {
				var i = new FormData();
				i.append("operations", n),
					i.append("map", Cl({ ...[...r.keys()].map((a) => [a]) }));
				var o = 0;
				for (var s of r.values()) i.append("" + o++, s);
				return i;
			}
			return n;
		}
	},
	Eve = (t, e) => {
		var n = {
				accept:
					t.kind === "subscription"
						? "text/event-stream, multipart/mixed"
						: "application/graphql-response+json, application/graphql+json, application/json, text/event-stream, multipart/mixed",
			},
			r =
				(typeof t.context.fetchOptions == "function"
					? t.context.fetchOptions()
					: t.context.fetchOptions) || {};
		if (r.headers)
			if (((s) => "has" in s && !Object.keys(s).length)(r.headers))
				r.headers.forEach((s, a) => {
					n[a] = s;
				});
			else if (Array.isArray(r.headers))
				r.headers.forEach((s, a) => {
					Array.isArray(s)
						? n[s[0]]
							? (n[s[0]] = `${n[s[0]]},${s[1]}`)
							: (n[s[0]] = s[1])
						: (n[a] = s);
				});
			else for (var i in r.headers) n[i.toLowerCase()] = r.headers[i];
		var o = wve(t, e);
		return (
			typeof o == "string" &&
				!n["content-type"] &&
				(n["content-type"] = "application/json"),
			{ ...r, method: o ? "POST" : "GET", body: o, headers: n }
		);
	},
	Dve = typeof TextDecoder < "u" ? new TextDecoder() : null,
	Sve = /boundary="?([^=";]+)"?/i,
	Ave = /data: ?([^\n]+)/,
	XB = (t) =>
		t.constructor.name === "Buffer" ? t.toString() : Dve.decode(t);
async function* ZB(t) {
	if (t.body[Symbol.asyncIterator]) for await (var e of t.body) yield XB(e);
	else {
		var n = t.body.getReader(),
			r;
		try {
			for (; !(r = await n.read()).done; ) yield XB(r.value);
		} finally {
			n.cancel();
		}
	}
}
async function* QB(t, e) {
	var n = "",
		r;
	for await (var i of t)
		for (n += i; (r = n.indexOf(e)) > -1; )
			yield n.slice(0, r), (n = n.slice(r + e.length));
}
async function* $ve(t, e, n) {
	var r = !0,
		i = null,
		o;
	try {
		yield await Promise.resolve();
		var s =
				(o = await (t.context.fetch || fetch)(e, n)).headers.get(
					"Content-Type",
				) || "",
			a;
		/multipart\/mixed/i.test(s)
			? (a = (async function* (d, f) {
					var h = d.match(Sve),
						p = "--" + (h ? h[1] : "-"),
						g = !0,
						v;
					for await (var b of QB(
						ZB(f),
						`\r
` + p,
					)) {
						if (g) {
							g = !1;
							var y = b.indexOf(p);
							if (y > -1) b = b.slice(y + p.length);
							else continue;
						}
						try {
							yield (v = JSON.parse(
								b.slice(
									b.indexOf(`\r
\r
`) + 4,
								),
							));
						} catch (x) {
							if (!v) throw x;
						}
						if (v && v.hasNext === !1) break;
					}
					v && v.hasNext !== !1 && (yield { hasNext: !1 });
				})(s, o))
			: /text\/event-stream/i.test(s)
				? (a = (async function* (d) {
						var f;
						for await (var h of QB(
							ZB(d),
							`

`,
						)) {
							var p = h.match(Ave);
							if (p) {
								var g = p[1];
								try {
									yield (f = JSON.parse(g));
								} catch (v) {
									if (!f) throw v;
								}
								if (f && f.hasNext === !1) break;
							}
						}
						f && f.hasNext !== !1 && (yield { hasNext: !1 });
					})(o))
				: /text\//i.test(s)
					? (a = (async function* (d) {
							var f = await d.text();
							try {
								var h = JSON.parse(f);
								yield h;
							} catch {
								throw new Error(f);
							}
						})(o))
					: (a = (async function* (d) {
							yield JSON.parse(await d.text());
						})(o));
		var l;
		for await (var u of a)
			u.pending && !i
				? (l = u.pending)
				: u.pending && (l = [...l, ...u.pending]),
				(i = i ? yve(i, u, o, l) : JB(t, u, o)),
				(r = !1),
				yield i,
				(r = !0);
		i || (yield (i = JB(t, {}, o)));
	} catch (c) {
		if (!r) throw c;
		yield xU(
			t,
			o && (o.status < 200 || o.status >= 300) && o.statusText
				? new Error(o.statusText)
				: c,
			o,
		);
	}
}
function Tve(t, e, n) {
	var r;
	return (
		typeof AbortController < "u" &&
			(n.signal = (r = new AbortController()).signal),
		ZS(() => {
			r && r.abort();
		})(hn((i) => !!i)(mU($ve(t, e, n))))
	);
}
var v2 = (t) => {
		if ("definitions" in t) {
			var e = [];
			for (var n of t.definitions) {
				var r = v2(n);
				e.push(r);
			}
			return { ...t, definitions: e };
		}
		if ("directives" in t && t.directives && t.directives.length) {
			var i = [],
				o = {};
			for (var s of t.directives) {
				var a = s.name.value;
				a[0] !== "_" ? i.push(s) : (a = a.slice(1)), (o[a] = s);
			}
			t = { ...t, directives: i, _directives: o };
		}
		if ("selectionSet" in t) {
			var l = [],
				u = t.kind === ea.OPERATION_DEFINITION;
			if (t.selectionSet) {
				for (var c of t.selectionSet.selections || []) {
					u =
						u ||
						(c.kind === ea.FIELD &&
							c.name.value === "__typename" &&
							!c.alias);
					var d = v2(c);
					l.push(d);
				}
				return (
					u ||
						l.push({
							kind: ea.FIELD,
							name: { kind: ea.NAME, value: "__typename" },
							_generated: !0,
						}),
					{ ...t, selectionSet: { ...t.selectionSet, selections: l } }
				);
			}
		}
		return t;
	},
	eI = new Map(),
	xg = (t) => {
		var e = vU(t),
			n = eI.get(e.__key);
		return (
			n ||
				(eI.set(e.__key, (n = v2(e))),
				Object.defineProperty(n, "__key", {
					value: e.__key,
					enumerable: !1,
				})),
			n
		);
	};
function tI(t) {
	var e = (n) => t(n);
	return (
		(e.toPromise = () => e5(u3(1)(hn((n) => !n.stale && !n.hasNext)(e)))),
		(e.then = (n, r) => e.toPromise().then(n, r)),
		(e.subscribe = (n) => Nh(n)(e)),
		e
	);
}
function sl(t, e, n) {
	return {
		...e,
		kind: t,
		context: e.context ? { ...e.context, ...n } : n || e.context,
	};
}
var Bve = () => {},
	Ive =
		({ forward: t, dispatchDebug: e }) =>
		(n) => {
			var r = l3((o) => {
					var s = xve(o),
						a = kve(o, s),
						l = Eve(o, s),
						u = QS(
							hn((c) => c.kind === "teardown" && c.key === o.key)(
								n,
							),
						)(Tve(o, a, l));
					return u;
				})(
					hn(
						(o) =>
							o.kind !== "teardown" &&
							(o.kind !== "subscription" ||
								!!o.context.fetchSubscriptions),
					)(n),
				),
				i = t(
					hn(
						(o) =>
							o.kind === "teardown" ||
							(o.kind === "subscription" &&
								!o.context.fetchSubscriptions),
					)(n),
				);
			return Yu([r, i]);
		},
	Fve =
		(t) =>
		({ client: e, forward: n, dispatchDebug: r }) =>
			t.reduceRight(
				(i, o) =>
					o({
						client: e,
						forward(s) {
							return Ph(i(Ph(s)));
						},
						dispatchDebug(s) {},
					}),
				n,
			),
	Pve =
		({ dispatchDebug: t }) =>
		(e) =>
			hn((n) => !1)(e),
	Nve = function t(e) {
		var n = 0,
			r = new Map(),
			i = new Map(),
			o = new Set(),
			s = [],
			a = {
				url: e.url,
				fetchSubscriptions: e.fetchSubscriptions,
				fetchOptions: e.fetchOptions,
				fetch: e.fetch,
				preferGetMethod: e.preferGetMethod,
				requestPolicy: e.requestPolicy || "cache-first",
			},
			l = sy();
		function u(y) {
			(y.kind === "mutation" || y.kind === "teardown" || !o.has(y.key)) &&
				(y.kind === "teardown"
					? o.delete(y.key)
					: y.kind !== "mutation" && o.add(y.key),
				l.next(y));
		}
		var c = !1;
		function d(y) {
			if ((y && u(y), !c)) {
				for (c = !0; c && (y = s.shift()); ) u(y);
				c = !1;
			}
		}
		var f = (y) => {
				var x = QS(
					hn((C) => C.kind === "teardown" && C.key === y.key)(
						l.source,
					),
				)(
					hn(
						(C) =>
							C.operation.kind === y.kind &&
							C.operation.key === y.key &&
							(!C.operation.context._instance ||
								C.operation.context._instance ===
									y.context._instance),
					)(b),
				);
				return (
					y.kind !== "query"
						? (x = pU((C) => !!C.hasNext, !0)(x))
						: (x = HB((C) => {
								var k = zk(C);
								return C.stale || C.hasNext
									? k
									: Yu([
											k,
											ou(() => ((C.stale = !0), C))(
												u3(1)(
													hn((w) => w.key === y.key)(
														l.source,
													),
												),
											),
										]);
							})(x)),
					y.kind !== "mutation"
						? (x = ZS(() => {
								o.delete(y.key),
									r.delete(y.key),
									i.delete(y.key),
									(c = !1);
								for (var C = s.length - 1; C >= 0; C--)
									s[C].key === y.key && s.splice(C, 1);
								u(sl("teardown", y, y.context));
							})(
								oy((C) => {
									if (C.stale) {
										if (!C.hasNext) o.delete(y.key);
										else
											for (var k of s)
												if (k.key === C.operation.key) {
													o.delete(k.key);
													break;
												}
									} else C.hasNext || o.delete(y.key);
									r.set(y.key, C);
								})(x),
							))
						: (x = m2(() => {
								u(y);
							})(x)),
					Ph(x)
				);
			},
			h = this instanceof t ? this : Object.create(t.prototype),
			p = Object.assign(h, {
				suspense: !!e.suspense,
				operations$: l.source,
				reexecuteOperation(y) {
					if (y.kind === "teardown") d(y);
					else if (y.kind === "mutation")
						s.push(y), Promise.resolve().then(d);
					else if (i.has(y.key)) {
						for (var x = !1, C = 0; C < s.length; C++)
							s[C].key === y.key && ((s[C] = y), (x = !0));
						x ||
						(o.has(y.key) &&
							y.context.requestPolicy !== "network-only")
							? (o.delete(y.key), Promise.resolve().then(d))
							: (s.push(y), Promise.resolve().then(d));
					}
				},
				createRequestOperation(y, x, C) {
					return (
						C || (C = {}),
						sl(y, x, {
							_instance:
								y === "mutation" ? (n = (n + 1) | 0) : void 0,
							...a,
							...C,
							requestPolicy: C.requestPolicy || a.requestPolicy,
							suspense:
								C.suspense || (C.suspense !== !1 && p.suspense),
						})
					);
				},
				executeRequestOperation(y) {
					return y.kind === "mutation"
						? tI(f(y))
						: tI(
								cve(() => {
									var x = i.get(y.key);
									x || i.set(y.key, (x = f(y))),
										(x = m2(() => {
											d(y);
										})(x));
									var C = r.get(y.key);
									return y.kind === "query" &&
										C &&
										(C.stale || C.hasNext)
										? HB(zk)(
												Yu([
													x,
													hn(
														(k) =>
															k === r.get(y.key),
													)(zk(C)),
												]),
											)
										: x;
								}),
							);
				},
				executeQuery(y, x) {
					var C = p.createRequestOperation("query", y, x);
					return p.executeRequestOperation(C);
				},
				executeSubscription(y, x) {
					var C = p.createRequestOperation("subscription", y, x);
					return p.executeRequestOperation(C);
				},
				executeMutation(y, x) {
					var C = p.createRequestOperation("mutation", y, x);
					return p.executeRequestOperation(C);
				},
				readQuery(y, x, C) {
					var k = null;
					return (
						Nh((w) => {
							k = w;
						})(p.query(y, x, C)).unsubscribe(),
						k
					);
				},
				query: (y, x, C) => p.executeQuery(Tu(y, x), C),
				subscription: (y, x, C) => p.executeSubscription(Tu(y, x), C),
				mutation: (y, x, C) => p.executeMutation(Tu(y, x), C),
			}),
			g = Bve,
			v = Fve(e.exchanges),
			b = Ph(
				v({
					client: p,
					dispatchDebug: g,
					forward: Pve({ dispatchDebug: g }),
				})(l.source),
			);
		return pve(b), p;
	},
	Rve = Nve,
	kU = {},
	d3 = E.createContext(kU),
	Ove = d3.Provider;
d3.Consumer;
d3.displayName = "UrqlContext";
var n5 = () => {
		var t = E.useContext(d3);
		if (t === kU && !1) var e;
		return t;
	},
	y2 = {
		fetching: !1,
		stale: !1,
		error: void 0,
		data: void 0,
		extensions: void 0,
		operation: void 0,
	},
	Mve = (t, e) => t === e || !(!t || !e || t.key !== e.key),
	Lk = (t, e) => {
		var n = {
			...t,
			...e,
			data: e.data !== void 0 || e.error ? e.data : t.data,
			fetching: !!e.fetching,
			stale: !!e.stale,
		};
		return ((r, i) => {
			for (var o in r) if (!(o in i)) return !0;
			for (var s in i)
				if (s === "operation" ? !Mve(r[s], i[s]) : r[s] !== i[s])
					return !0;
			return !1;
		})(t, n)
			? n
			: t;
	},
	jve = (t, e) => {
		for (var n = 0, r = e.length; n < r; n++) if (t[n] !== e[n]) return !0;
		return !1;
	};
function uy(t, e) {
	t(e);
}
function f3(t) {
	var e = E.useRef(!0),
		n = n5(),
		[r, i] = E.useState(y2),
		o = E.useCallback(
			(s, a) => (
				uy(i, { ...y2, fetching: !0 }),
				e5(
					u3(1)(
						hn((l) => !l.hasNext)(
							oy((l) => {
								e.current &&
									uy(i, {
										fetching: !1,
										stale: l.stale,
										data: l.data,
										error: l.error,
										extensions: l.extensions,
										operation: l.operation,
									});
							})(n.executeMutation(Tu(t, s), a || {})),
						),
					),
				)
			),
			[n, t, i],
		);
	return (
		E.useEffect(
			() => (
				(e.current = !0),
				() => {
					e.current = !1;
				}
			),
			[],
		),
		[r, o]
	);
}
function _ve(t, e) {
	var n = E.useRef(void 0);
	return E.useMemo(() => {
		var r = Tu(t, e);
		return n.current !== void 0 && n.current.key === r.key
			? n.current
			: ((n.current = r), r);
	}, [t, e]);
}
var zve = (t) => {
		if (!t._react) {
			var e = new Set(),
				n = new Map();
			t.operations$ &&
				Nh((r) => {
					r.kind === "teardown" &&
						e.has(r.key) &&
						(e.delete(r.key), n.delete(r.key));
				})(t.operations$),
				(t._react = {
					get: (r) => n.get(r),
					set(r, i) {
						e.delete(r), n.set(r, i);
					},
					dispose(r) {
						e.add(r);
					},
				});
		}
		return t._react;
	},
	Lve = (t, e) => (e && e.suspense !== void 0 ? !!e.suspense : t.suspense);
function x2(t) {
	var e = n5(),
		n = zve(e),
		r = Lve(e, t.context),
		i = _ve(t.query, t.variables),
		o = E.useMemo(() => {
			if (t.pause) return null;
			var f = e.executeQuery(i, {
				requestPolicy: t.requestPolicy,
				...t.context,
			});
			return r
				? oy((h) => {
						n.set(i.key, h);
					})(f)
				: f;
		}, [n, e, i, r, t.pause, t.requestPolicy, t.context]),
		s = E.useCallback(
			(f, h) => {
				if (!f) return { fetching: !1 };
				var p = n.get(i.key);
				if (p) {
					if (h && p != null && "then" in p) throw p;
				} else {
					var g,
						v = Nh((y) => {
							(p = y), g && g(p);
						})(pU(() => (h && !g) || !p)(f));
					if (p == null && h) {
						var b = new Promise((y) => {
							g = y;
						});
						throw (n.set(i.key, b), b);
					} else v.unsubscribe();
				}
				return p || { fetching: !0 };
			},
			[n, i],
		),
		a = [e, i, t.requestPolicy, t.context, t.pause],
		[l, u] = E.useState(() => [o, Lk(y2, s(o, r)), a]),
		c = l[1];
	o !== l[0] && jve(l[2], a) && u([o, (c = Lk(l[1], s(o, r))), a]),
		E.useEffect(() => {
			var f = l[0],
				h = l[2][1],
				p = !1,
				g = (b) => {
					(p = !0),
						uy(u, (y) => {
							var x = Lk(y[1], b);
							return y[1] !== x ? [y[0], x, y[2]] : y;
						});
				};
			if (f) {
				var v = Nh(g)(
					ZS(() => {
						g({ fetching: !1 });
					})(f),
				);
				return (
					p || g({ fetching: !0 }),
					() => {
						n.dispose(h.key), v.unsubscribe();
					}
				);
			} else g({ fetching: !1 });
		}, [n, l[0], l[2][1]]);
	var d = E.useCallback(
		(f) => {
			var h = { requestPolicy: t.requestPolicy, ...t.context, ...f };
			uy(u, (p) => [
				r
					? oy((g) => {
							n.set(i.key, g);
						})(e.executeQuery(i, h))
					: e.executeQuery(i, h),
				p[1],
				a,
			]);
		},
		[e, n, i, r, t.requestPolicy, t.context, t.pause],
	);
	return [c, d];
}
function Vve(t) {
	let e = "";
	for (const n of t) e += n.toString(16).padStart(2, "0");
	return e;
}
function h3(t) {
	const e = atob(t.replace(/-/g, "+").replace(/_/g, "/"));
	return Uint8Array.from(e, (n) => n.codePointAt(0));
}
function nd(t) {
	return k2(t).replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}
function k2(t) {
	const e = Array.from(t, (n) => String.fromCodePoint(n)).join("");
	return btoa(e);
}
function Is(t) {
	return new Promise((e, n) => {
		(t.oncomplete = t.onsuccess = () => e(t.result)),
			(t.onabort = t.onerror = () => n(t.error));
	});
}
function p3(t, e) {
	const n = indexedDB.open(t);
	n.onupgradeneeded = () => n.result.createObjectStore(e);
	const r = Is(n);
	return (i, o) => r.then((s) => o(s.transaction(e, i).objectStore(e)));
}
let Vk;
function rc() {
	return Vk || (Vk = p3("keyval-store", "keyval")), Vk;
}
function CU(t, e = rc()) {
	return e("readonly", (n) => Is(n.get(t)));
}
function wU(t, e, n = rc()) {
	return n("readwrite", (r) => (r.put(e, t), Is(r.transaction)));
}
function Kve(t, e = rc()) {
	return e(
		"readwrite",
		(n) => (t.forEach((r) => n.put(r[1], r[0])), Is(n.transaction)),
	);
}
function Uve(t, e = rc()) {
	return e("readwrite", (n) => (n.delete(t), Is(n.transaction)));
}
function nI(t, e = rc()) {
	return e(
		"readwrite",
		(n) => (t.forEach((r) => n.delete(r)), Is(n.transaction)),
	);
}
function C2(t = rc()) {
	return t("readwrite", (e) => (e.clear(), Is(e.transaction)));
}
function EU(t, e) {
	return (
		(t.openCursor().onsuccess = function () {
			this.result && (e(this.result), this.result.continue());
		}),
		Is(t.transaction)
	);
}
function Hve(t = rc()) {
	return t("readonly", (e) => {
		if (e.getAllKeys) return Is(e.getAllKeys());
		const n = [];
		return EU(e, (r) => n.push(r.key)).then(() => n);
	});
}
function Wve(t = rc()) {
	return t("readonly", (e) => {
		if (e.getAll && e.getAllKeys)
			return Promise.all([Is(e.getAllKeys()), Is(e.getAll())]).then(
				([r, i]) => r.map((o, s) => [o, i[s]]),
			);
		const n = [];
		return t("readonly", (r) =>
			EU(r, (i) => n.push([i.key, i.value])).then(() => n),
		);
	});
}
const gf =
		typeof performance == "object" &&
		performance &&
		typeof performance.now == "function"
			? performance
			: Date,
	DU = new Set(),
	w2 = typeof process == "object" && process ? process : {},
	SU = (t, e, n, r) => {
		typeof w2.emitWarning == "function"
			? w2.emitWarning(t, e, n, r)
			: console.error(`[${n}] ${e}: ${t}`);
	};
let cy = globalThis.AbortController,
	rI = globalThis.AbortSignal;
var W8;
if (typeof cy > "u") {
	(rI = class {
		constructor() {
			Fe(this, "onabort");
			Fe(this, "_onabort", []);
			Fe(this, "reason");
			Fe(this, "aborted", !1);
		}
		addEventListener(r, i) {
			this._onabort.push(i);
		}
	}),
		(cy = class {
			constructor() {
				Fe(this, "signal", new rI());
				e();
			}
			abort(r) {
				var i, o;
				if (!this.signal.aborted) {
					(this.signal.reason = r), (this.signal.aborted = !0);
					for (const s of this.signal._onabort) s(r);
					(o = (i = this.signal).onabort) == null || o.call(i, r);
				}
			}
		});
	let t =
		((W8 = w2.env) == null ? void 0 : W8.LRU_CACHE_IGNORE_AC_WARNING) !==
		"1";
	const e = () => {
		t &&
			((t = !1),
			SU(
				"AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.",
				"NO_ABORT_CONTROLLER",
				"ENOTSUP",
				e,
			));
	};
}
const qve = (t) => !DU.has(t),
	ql = (t) => t && t === Math.floor(t) && t > 0 && isFinite(t),
	AU = (t) =>
		ql(t)
			? t <= Math.pow(2, 8)
				? Uint8Array
				: t <= Math.pow(2, 16)
					? Uint16Array
					: t <= Math.pow(2, 32)
						? Uint32Array
						: t <= Number.MAX_SAFE_INTEGER
							? Cb
							: null
			: null;
class Cb extends Array {
	constructor(e) {
		super(e), this.fill(0);
	}
}
var hh;
const Bc = class Bc {
	constructor(e, n) {
		Fe(this, "heap");
		Fe(this, "length");
		if (!z(Bc, hh))
			throw new TypeError("instantiate Stack using Stack.create(n)");
		(this.heap = new n(e)), (this.length = 0);
	}
	static create(e) {
		const n = AU(e);
		if (!n) return [];
		Te(Bc, hh, !0);
		const r = new Bc(e, n);
		return Te(Bc, hh, !1), r;
	}
	push(e) {
		this.heap[this.length++] = e;
	}
	pop() {
		return this.heap[--this.length];
	}
};
(hh = new WeakMap()), qe(Bc, hh, !1);
let E2 = Bc;
var q8,
	G8,
	is,
	qi,
	ss,
	as,
	ph,
	mh,
	Xn,
	ls,
	jn,
	nn,
	ft,
	ii,
	Gi,
	Or,
	or,
	us,
	sr,
	cs,
	ds,
	Yi,
	fs,
	cu,
	oi,
	Ie,
	D2,
	Lc,
	Ga,
	qg,
	Ji,
	$U,
	Vc,
	gh,
	Gg,
	Gl,
	Yl,
	S2,
	wb,
	Eb,
	tn,
	A2,
	im,
	Jl,
	$2;
const HA = class HA {
	constructor(e) {
		qe(this, Ie);
		qe(this, is);
		qe(this, qi);
		qe(this, ss);
		qe(this, as);
		qe(this, ph);
		qe(this, mh);
		Fe(this, "ttl");
		Fe(this, "ttlResolution");
		Fe(this, "ttlAutopurge");
		Fe(this, "updateAgeOnGet");
		Fe(this, "updateAgeOnHas");
		Fe(this, "allowStale");
		Fe(this, "noDisposeOnSet");
		Fe(this, "noUpdateTTL");
		Fe(this, "maxEntrySize");
		Fe(this, "sizeCalculation");
		Fe(this, "noDeleteOnFetchRejection");
		Fe(this, "noDeleteOnStaleGet");
		Fe(this, "allowStaleOnFetchAbort");
		Fe(this, "allowStaleOnFetchRejection");
		Fe(this, "ignoreFetchAbort");
		qe(this, Xn);
		qe(this, ls);
		qe(this, jn);
		qe(this, nn);
		qe(this, ft);
		qe(this, ii);
		qe(this, Gi);
		qe(this, Or);
		qe(this, or);
		qe(this, us);
		qe(this, sr);
		qe(this, cs);
		qe(this, ds);
		qe(this, Yi);
		qe(this, fs);
		qe(this, cu);
		qe(this, oi);
		qe(this, Lc, () => {});
		qe(this, Ga, () => {});
		qe(this, qg, () => {});
		qe(this, Ji, () => !1);
		qe(this, Vc, (e) => {});
		qe(this, gh, (e, n, r) => {});
		qe(this, Gg, (e, n, r, i) => {
			if (r || i)
				throw new TypeError(
					"cannot set size without setting maxSize or maxEntrySize on cache",
				);
			return 0;
		});
		Fe(this, q8, "LRUCache");
		const {
			max: n = 0,
			ttl: r,
			ttlResolution: i = 1,
			ttlAutopurge: o,
			updateAgeOnGet: s,
			updateAgeOnHas: a,
			allowStale: l,
			dispose: u,
			disposeAfter: c,
			noDisposeOnSet: d,
			noUpdateTTL: f,
			maxSize: h = 0,
			maxEntrySize: p = 0,
			sizeCalculation: g,
			fetchMethod: v,
			memoMethod: b,
			noDeleteOnFetchRejection: y,
			noDeleteOnStaleGet: x,
			allowStaleOnFetchRejection: C,
			allowStaleOnFetchAbort: k,
			ignoreFetchAbort: w,
		} = e;
		if (n !== 0 && !ql(n))
			throw new TypeError("max option must be a nonnegative integer");
		const D = n ? AU(n) : Array;
		if (!D) throw new Error("invalid max value: " + n);
		if (
			(Te(this, is, n),
			Te(this, qi, h),
			(this.maxEntrySize = p || z(this, qi)),
			(this.sizeCalculation = g),
			this.sizeCalculation)
		) {
			if (!z(this, qi) && !this.maxEntrySize)
				throw new TypeError(
					"cannot set sizeCalculation without setting maxSize or maxEntrySize",
				);
			if (typeof this.sizeCalculation != "function")
				throw new TypeError("sizeCalculation set to non-function");
		}
		if (b !== void 0 && typeof b != "function")
			throw new TypeError("memoMethod must be a function if defined");
		if ((Te(this, mh, b), v !== void 0 && typeof v != "function"))
			throw new TypeError("fetchMethod must be a function if specified");
		if (
			(Te(this, ph, v),
			Te(this, cu, !!v),
			Te(this, jn, new Map()),
			Te(this, nn, new Array(n).fill(void 0)),
			Te(this, ft, new Array(n).fill(void 0)),
			Te(this, ii, new D(n)),
			Te(this, Gi, new D(n)),
			Te(this, Or, 0),
			Te(this, or, 0),
			Te(this, us, E2.create(n)),
			Te(this, Xn, 0),
			Te(this, ls, 0),
			typeof u == "function" && Te(this, ss, u),
			typeof c == "function"
				? (Te(this, as, c), Te(this, sr, []))
				: (Te(this, as, void 0), Te(this, sr, void 0)),
			Te(this, fs, !!z(this, ss)),
			Te(this, oi, !!z(this, as)),
			(this.noDisposeOnSet = !!d),
			(this.noUpdateTTL = !!f),
			(this.noDeleteOnFetchRejection = !!y),
			(this.allowStaleOnFetchRejection = !!C),
			(this.allowStaleOnFetchAbort = !!k),
			(this.ignoreFetchAbort = !!w),
			this.maxEntrySize !== 0)
		) {
			if (z(this, qi) !== 0 && !ql(z(this, qi)))
				throw new TypeError(
					"maxSize must be a positive integer if specified",
				);
			if (!ql(this.maxEntrySize))
				throw new TypeError(
					"maxEntrySize must be a positive integer if specified",
				);
			Ne(this, Ie, $U).call(this);
		}
		if (
			((this.allowStale = !!l),
			(this.noDeleteOnStaleGet = !!x),
			(this.updateAgeOnGet = !!s),
			(this.updateAgeOnHas = !!a),
			(this.ttlResolution = ql(i) || i === 0 ? i : 1),
			(this.ttlAutopurge = !!o),
			(this.ttl = r || 0),
			this.ttl)
		) {
			if (!ql(this.ttl))
				throw new TypeError(
					"ttl must be a positive integer if specified",
				);
			Ne(this, Ie, D2).call(this);
		}
		if (z(this, is) === 0 && this.ttl === 0 && z(this, qi) === 0)
			throw new TypeError(
				"At least one of max, maxSize, or ttl is required",
			);
		if (!this.ttlAutopurge && !z(this, is) && !z(this, qi)) {
			const S = "LRU_CACHE_UNBOUNDED";
			qve(S) &&
				(DU.add(S),
				SU(
					"TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.",
					"UnboundedCacheWarning",
					S,
					HA,
				));
		}
	}
	static unsafeExposeInternals(e) {
		return {
			starts: z(e, ds),
			ttls: z(e, Yi),
			sizes: z(e, cs),
			keyMap: z(e, jn),
			keyList: z(e, nn),
			valList: z(e, ft),
			next: z(e, ii),
			prev: z(e, Gi),
			get head() {
				return z(e, Or);
			},
			get tail() {
				return z(e, or);
			},
			free: z(e, us),
			isBackgroundFetch: (n) => {
				var r;
				return Ne((r = e), Ie, tn).call(r, n);
			},
			backgroundFetch: (n, r, i, o) => {
				var s;
				return Ne((s = e), Ie, Eb).call(s, n, r, i, o);
			},
			moveToTail: (n) => {
				var r;
				return Ne((r = e), Ie, im).call(r, n);
			},
			indexes: (n) => {
				var r;
				return Ne((r = e), Ie, Gl).call(r, n);
			},
			rindexes: (n) => {
				var r;
				return Ne((r = e), Ie, Yl).call(r, n);
			},
			isStale: (n) => {
				var r;
				return z((r = e), Ji).call(r, n);
			},
		};
	}
	get max() {
		return z(this, is);
	}
	get maxSize() {
		return z(this, qi);
	}
	get calculatedSize() {
		return z(this, ls);
	}
	get size() {
		return z(this, Xn);
	}
	get fetchMethod() {
		return z(this, ph);
	}
	get memoMethod() {
		return z(this, mh);
	}
	get dispose() {
		return z(this, ss);
	}
	get disposeAfter() {
		return z(this, as);
	}
	getRemainingTTL(e) {
		return z(this, jn).has(e) ? 1 / 0 : 0;
	}
	*entries() {
		for (const e of Ne(this, Ie, Gl).call(this))
			z(this, ft)[e] !== void 0 &&
				z(this, nn)[e] !== void 0 &&
				!Ne(this, Ie, tn).call(this, z(this, ft)[e]) &&
				(yield [z(this, nn)[e], z(this, ft)[e]]);
	}
	*rentries() {
		for (const e of Ne(this, Ie, Yl).call(this))
			z(this, ft)[e] !== void 0 &&
				z(this, nn)[e] !== void 0 &&
				!Ne(this, Ie, tn).call(this, z(this, ft)[e]) &&
				(yield [z(this, nn)[e], z(this, ft)[e]]);
	}
	*keys() {
		for (const e of Ne(this, Ie, Gl).call(this)) {
			const n = z(this, nn)[e];
			n !== void 0 &&
				!Ne(this, Ie, tn).call(this, z(this, ft)[e]) &&
				(yield n);
		}
	}
	*rkeys() {
		for (const e of Ne(this, Ie, Yl).call(this)) {
			const n = z(this, nn)[e];
			n !== void 0 &&
				!Ne(this, Ie, tn).call(this, z(this, ft)[e]) &&
				(yield n);
		}
	}
	*values() {
		for (const e of Ne(this, Ie, Gl).call(this))
			z(this, ft)[e] !== void 0 &&
				!Ne(this, Ie, tn).call(this, z(this, ft)[e]) &&
				(yield z(this, ft)[e]);
	}
	*rvalues() {
		for (const e of Ne(this, Ie, Yl).call(this))
			z(this, ft)[e] !== void 0 &&
				!Ne(this, Ie, tn).call(this, z(this, ft)[e]) &&
				(yield z(this, ft)[e]);
	}
	[((G8 = Symbol.iterator), (q8 = Symbol.toStringTag), G8)]() {
		return this.entries();
	}
	find(e, n = {}) {
		for (const r of Ne(this, Ie, Gl).call(this)) {
			const i = z(this, ft)[r],
				o = Ne(this, Ie, tn).call(this, i) ? i.__staleWhileFetching : i;
			if (o !== void 0 && e(o, z(this, nn)[r], this))
				return this.get(z(this, nn)[r], n);
		}
	}
	forEach(e, n = this) {
		for (const r of Ne(this, Ie, Gl).call(this)) {
			const i = z(this, ft)[r],
				o = Ne(this, Ie, tn).call(this, i) ? i.__staleWhileFetching : i;
			o !== void 0 && e.call(n, o, z(this, nn)[r], this);
		}
	}
	rforEach(e, n = this) {
		for (const r of Ne(this, Ie, Yl).call(this)) {
			const i = z(this, ft)[r],
				o = Ne(this, Ie, tn).call(this, i) ? i.__staleWhileFetching : i;
			o !== void 0 && e.call(n, o, z(this, nn)[r], this);
		}
	}
	purgeStale() {
		let e = !1;
		for (const n of Ne(this, Ie, Yl).call(this, { allowStale: !0 }))
			z(this, Ji).call(this, n) &&
				(Ne(this, Ie, Jl).call(this, z(this, nn)[n], "expire"),
				(e = !0));
		return e;
	}
	info(e) {
		const n = z(this, jn).get(e);
		if (n === void 0) return;
		const r = z(this, ft)[n],
			i = Ne(this, Ie, tn).call(this, r) ? r.__staleWhileFetching : r;
		if (i === void 0) return;
		const o = { value: i };
		if (z(this, Yi) && z(this, ds)) {
			const s = z(this, Yi)[n],
				a = z(this, ds)[n];
			if (s && a) {
				const l = s - (gf.now() - a);
				(o.ttl = l), (o.start = Date.now());
			}
		}
		return z(this, cs) && (o.size = z(this, cs)[n]), o;
	}
	dump() {
		const e = [];
		for (const n of Ne(this, Ie, Gl).call(this, { allowStale: !0 })) {
			const r = z(this, nn)[n],
				i = z(this, ft)[n],
				o = Ne(this, Ie, tn).call(this, i) ? i.__staleWhileFetching : i;
			if (o === void 0 || r === void 0) continue;
			const s = { value: o };
			if (z(this, Yi) && z(this, ds)) {
				s.ttl = z(this, Yi)[n];
				const a = gf.now() - z(this, ds)[n];
				s.start = Math.floor(Date.now() - a);
			}
			z(this, cs) && (s.size = z(this, cs)[n]), e.unshift([r, s]);
		}
		return e;
	}
	load(e) {
		this.clear();
		for (const [n, r] of e) {
			if (r.start) {
				const i = Date.now() - r.start;
				r.start = gf.now() - i;
			}
			this.set(n, r.value, r);
		}
	}
	set(e, n, r = {}) {
		var f, h, p, g, v;
		if (n === void 0) return this.delete(e), this;
		const {
			ttl: i = this.ttl,
			start: o,
			noDisposeOnSet: s = this.noDisposeOnSet,
			sizeCalculation: a = this.sizeCalculation,
			status: l,
		} = r;
		let { noUpdateTTL: u = this.noUpdateTTL } = r;
		const c = z(this, Gg).call(this, e, n, r.size || 0, a);
		if (this.maxEntrySize && c > this.maxEntrySize)
			return (
				l && ((l.set = "miss"), (l.maxEntrySizeExceeded = !0)),
				Ne(this, Ie, Jl).call(this, e, "set"),
				this
			);
		let d = z(this, Xn) === 0 ? void 0 : z(this, jn).get(e);
		if (d === void 0)
			(d =
				z(this, Xn) === 0
					? z(this, or)
					: z(this, us).length !== 0
						? z(this, us).pop()
						: z(this, Xn) === z(this, is)
							? Ne(this, Ie, wb).call(this, !1)
							: z(this, Xn)),
				(z(this, nn)[d] = e),
				(z(this, ft)[d] = n),
				z(this, jn).set(e, d),
				(z(this, ii)[z(this, or)] = d),
				(z(this, Gi)[d] = z(this, or)),
				Te(this, or, d),
				o1(this, Xn)._++,
				z(this, gh).call(this, d, c, l),
				l && (l.set = "add"),
				(u = !1);
		else {
			Ne(this, Ie, im).call(this, d);
			const b = z(this, ft)[d];
			if (n !== b) {
				if (z(this, cu) && Ne(this, Ie, tn).call(this, b)) {
					b.__abortController.abort(new Error("replaced"));
					const { __staleWhileFetching: y } = b;
					y !== void 0 &&
						!s &&
						(z(this, fs) &&
							((f = z(this, ss)) == null ||
								f.call(this, y, e, "set")),
						z(this, oi) &&
							((h = z(this, sr)) == null ||
								h.push([y, e, "set"])));
				} else
					s ||
						(z(this, fs) &&
							((p = z(this, ss)) == null ||
								p.call(this, b, e, "set")),
						z(this, oi) &&
							((g = z(this, sr)) == null ||
								g.push([b, e, "set"])));
				if (
					(z(this, Vc).call(this, d),
					z(this, gh).call(this, d, c, l),
					(z(this, ft)[d] = n),
					l)
				) {
					l.set = "replace";
					const y =
						b && Ne(this, Ie, tn).call(this, b)
							? b.__staleWhileFetching
							: b;
					y !== void 0 && (l.oldValue = y);
				}
			} else l && (l.set = "update");
		}
		if (
			(i !== 0 && !z(this, Yi) && Ne(this, Ie, D2).call(this),
			z(this, Yi) &&
				(u || z(this, qg).call(this, d, i, o),
				l && z(this, Ga).call(this, l, d)),
			!s && z(this, oi) && z(this, sr))
		) {
			const b = z(this, sr);
			let y;
			for (; (y = b == null ? void 0 : b.shift()); )
				(v = z(this, as)) == null || v.call(this, ...y);
		}
		return this;
	}
	pop() {
		var e;
		try {
			for (; z(this, Xn); ) {
				const n = z(this, ft)[z(this, Or)];
				if (
					(Ne(this, Ie, wb).call(this, !0),
					Ne(this, Ie, tn).call(this, n))
				) {
					if (n.__staleWhileFetching) return n.__staleWhileFetching;
				} else if (n !== void 0) return n;
			}
		} finally {
			if (z(this, oi) && z(this, sr)) {
				const n = z(this, sr);
				let r;
				for (; (r = n == null ? void 0 : n.shift()); )
					(e = z(this, as)) == null || e.call(this, ...r);
			}
		}
	}
	has(e, n = {}) {
		const { updateAgeOnHas: r = this.updateAgeOnHas, status: i } = n,
			o = z(this, jn).get(e);
		if (o !== void 0) {
			const s = z(this, ft)[o];
			if (
				Ne(this, Ie, tn).call(this, s) &&
				s.__staleWhileFetching === void 0
			)
				return !1;
			if (z(this, Ji).call(this, o))
				i && ((i.has = "stale"), z(this, Ga).call(this, i, o));
			else
				return (
					r && z(this, Lc).call(this, o),
					i && ((i.has = "hit"), z(this, Ga).call(this, i, o)),
					!0
				);
		} else i && (i.has = "miss");
		return !1;
	}
	peek(e, n = {}) {
		const { allowStale: r = this.allowStale } = n,
			i = z(this, jn).get(e);
		if (i === void 0 || (!r && z(this, Ji).call(this, i))) return;
		const o = z(this, ft)[i];
		return Ne(this, Ie, tn).call(this, o) ? o.__staleWhileFetching : o;
	}
	async fetch(e, n = {}) {
		const {
			allowStale: r = this.allowStale,
			updateAgeOnGet: i = this.updateAgeOnGet,
			noDeleteOnStaleGet: o = this.noDeleteOnStaleGet,
			ttl: s = this.ttl,
			noDisposeOnSet: a = this.noDisposeOnSet,
			size: l = 0,
			sizeCalculation: u = this.sizeCalculation,
			noUpdateTTL: c = this.noUpdateTTL,
			noDeleteOnFetchRejection: d = this.noDeleteOnFetchRejection,
			allowStaleOnFetchRejection: f = this.allowStaleOnFetchRejection,
			ignoreFetchAbort: h = this.ignoreFetchAbort,
			allowStaleOnFetchAbort: p = this.allowStaleOnFetchAbort,
			context: g,
			forceRefresh: v = !1,
			status: b,
			signal: y,
		} = n;
		if (!z(this, cu))
			return (
				b && (b.fetch = "get"),
				this.get(e, {
					allowStale: r,
					updateAgeOnGet: i,
					noDeleteOnStaleGet: o,
					status: b,
				})
			);
		const x = {
			allowStale: r,
			updateAgeOnGet: i,
			noDeleteOnStaleGet: o,
			ttl: s,
			noDisposeOnSet: a,
			size: l,
			sizeCalculation: u,
			noUpdateTTL: c,
			noDeleteOnFetchRejection: d,
			allowStaleOnFetchRejection: f,
			allowStaleOnFetchAbort: p,
			ignoreFetchAbort: h,
			status: b,
			signal: y,
		};
		let C = z(this, jn).get(e);
		if (C === void 0) {
			b && (b.fetch = "miss");
			const k = Ne(this, Ie, Eb).call(this, e, C, x, g);
			return (k.__returned = k);
		} else {
			const k = z(this, ft)[C];
			if (Ne(this, Ie, tn).call(this, k)) {
				const A = r && k.__staleWhileFetching !== void 0;
				return (
					b && ((b.fetch = "inflight"), A && (b.returnedStale = !0)),
					A ? k.__staleWhileFetching : (k.__returned = k)
				);
			}
			const w = z(this, Ji).call(this, C);
			if (!v && !w)
				return (
					b && (b.fetch = "hit"),
					Ne(this, Ie, im).call(this, C),
					i && z(this, Lc).call(this, C),
					b && z(this, Ga).call(this, b, C),
					k
				);
			const D = Ne(this, Ie, Eb).call(this, e, C, x, g),
				$ = D.__staleWhileFetching !== void 0 && r;
			return (
				b &&
					((b.fetch = w ? "stale" : "refresh"),
					$ && w && (b.returnedStale = !0)),
				$ ? D.__staleWhileFetching : (D.__returned = D)
			);
		}
	}
	async forceFetch(e, n = {}) {
		const r = await this.fetch(e, n);
		if (r === void 0) throw new Error("fetch() returned undefined");
		return r;
	}
	memo(e, n = {}) {
		const r = z(this, mh);
		if (!r) throw new Error("no memoMethod provided to constructor");
		const { context: i, forceRefresh: o, ...s } = n,
			a = this.get(e, s);
		if (!o && a !== void 0) return a;
		const l = r(e, a, { options: s, context: i });
		return this.set(e, l, s), l;
	}
	get(e, n = {}) {
		const {
				allowStale: r = this.allowStale,
				updateAgeOnGet: i = this.updateAgeOnGet,
				noDeleteOnStaleGet: o = this.noDeleteOnStaleGet,
				status: s,
			} = n,
			a = z(this, jn).get(e);
		if (a !== void 0) {
			const l = z(this, ft)[a],
				u = Ne(this, Ie, tn).call(this, l);
			return (
				s && z(this, Ga).call(this, s, a),
				z(this, Ji).call(this, a)
					? (s && (s.get = "stale"),
						u
							? (s &&
									r &&
									l.__staleWhileFetching !== void 0 &&
									(s.returnedStale = !0),
								r ? l.__staleWhileFetching : void 0)
							: (o || Ne(this, Ie, Jl).call(this, e, "expire"),
								s && r && (s.returnedStale = !0),
								r ? l : void 0))
					: (s && (s.get = "hit"),
						u
							? l.__staleWhileFetching
							: (Ne(this, Ie, im).call(this, a),
								i && z(this, Lc).call(this, a),
								l))
			);
		} else s && (s.get = "miss");
	}
	delete(e) {
		return Ne(this, Ie, Jl).call(this, e, "delete");
	}
	clear() {
		return Ne(this, Ie, $2).call(this, "delete");
	}
};
(is = new WeakMap()),
	(qi = new WeakMap()),
	(ss = new WeakMap()),
	(as = new WeakMap()),
	(ph = new WeakMap()),
	(mh = new WeakMap()),
	(Xn = new WeakMap()),
	(ls = new WeakMap()),
	(jn = new WeakMap()),
	(nn = new WeakMap()),
	(ft = new WeakMap()),
	(ii = new WeakMap()),
	(Gi = new WeakMap()),
	(Or = new WeakMap()),
	(or = new WeakMap()),
	(us = new WeakMap()),
	(sr = new WeakMap()),
	(cs = new WeakMap()),
	(ds = new WeakMap()),
	(Yi = new WeakMap()),
	(fs = new WeakMap()),
	(cu = new WeakMap()),
	(oi = new WeakMap()),
	(Ie = new WeakSet()),
	(D2 = function () {
		const e = new Cb(z(this, is)),
			n = new Cb(z(this, is));
		Te(this, Yi, e),
			Te(this, ds, n),
			Te(this, qg, (o, s, a = gf.now()) => {
				if (
					((n[o] = s !== 0 ? a : 0),
					(e[o] = s),
					s !== 0 && this.ttlAutopurge)
				) {
					const l = setTimeout(() => {
						z(this, Ji).call(this, o) &&
							Ne(this, Ie, Jl).call(
								this,
								z(this, nn)[o],
								"expire",
							);
					}, s + 1);
					l.unref && l.unref();
				}
			}),
			Te(this, Lc, (o) => {
				n[o] = e[o] !== 0 ? gf.now() : 0;
			}),
			Te(this, Ga, (o, s) => {
				if (e[s]) {
					const a = e[s],
						l = n[s];
					if (!a || !l) return;
					(o.ttl = a), (o.start = l), (o.now = r || i());
					const u = o.now - l;
					o.remainingTTL = a - u;
				}
			});
		let r = 0;
		const i = () => {
			const o = gf.now();
			if (this.ttlResolution > 0) {
				r = o;
				const s = setTimeout(() => (r = 0), this.ttlResolution);
				s.unref && s.unref();
			}
			return o;
		};
		(this.getRemainingTTL = (o) => {
			const s = z(this, jn).get(o);
			if (s === void 0) return 0;
			const a = e[s],
				l = n[s];
			if (!a || !l) return 1 / 0;
			const u = (r || i()) - l;
			return a - u;
		}),
			Te(this, Ji, (o) => {
				const s = n[o],
					a = e[o];
				return !!a && !!s && (r || i()) - s > a;
			});
	}),
	(Lc = new WeakMap()),
	(Ga = new WeakMap()),
	(qg = new WeakMap()),
	(Ji = new WeakMap()),
	($U = function () {
		const e = new Cb(z(this, is));
		Te(this, ls, 0),
			Te(this, cs, e),
			Te(this, Vc, (n) => {
				Te(this, ls, z(this, ls) - e[n]), (e[n] = 0);
			}),
			Te(this, Gg, (n, r, i, o) => {
				if (Ne(this, Ie, tn).call(this, r)) return 0;
				if (!ql(i))
					if (o) {
						if (typeof o != "function")
							throw new TypeError(
								"sizeCalculation must be a function",
							);
						if (((i = o(r, n)), !ql(i)))
							throw new TypeError(
								"sizeCalculation return invalid (expect positive integer)",
							);
					} else
						throw new TypeError(
							"invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.",
						);
				return i;
			}),
			Te(this, gh, (n, r, i) => {
				if (((e[n] = r), z(this, qi))) {
					const o = z(this, qi) - e[n];
					for (; z(this, ls) > o; ) Ne(this, Ie, wb).call(this, !0);
				}
				Te(this, ls, z(this, ls) + e[n]),
					i &&
						((i.entrySize = r),
						(i.totalCalculatedSize = z(this, ls)));
			});
	}),
	(Vc = new WeakMap()),
	(gh = new WeakMap()),
	(Gg = new WeakMap()),
	(Gl = function* ({ allowStale: e = this.allowStale } = {}) {
		if (z(this, Xn))
			for (
				let n = z(this, or);
				!(
					!Ne(this, Ie, S2).call(this, n) ||
					((e || !z(this, Ji).call(this, n)) && (yield n),
					n === z(this, Or))
				);

			)
				n = z(this, Gi)[n];
	}),
	(Yl = function* ({ allowStale: e = this.allowStale } = {}) {
		if (z(this, Xn))
			for (
				let n = z(this, Or);
				!(
					!Ne(this, Ie, S2).call(this, n) ||
					((e || !z(this, Ji).call(this, n)) && (yield n),
					n === z(this, or))
				);

			)
				n = z(this, ii)[n];
	}),
	(S2 = function (e) {
		return e !== void 0 && z(this, jn).get(z(this, nn)[e]) === e;
	}),
	(wb = function (e) {
		var o, s;
		const n = z(this, Or),
			r = z(this, nn)[n],
			i = z(this, ft)[n];
		return (
			z(this, cu) && Ne(this, Ie, tn).call(this, i)
				? i.__abortController.abort(new Error("evicted"))
				: (z(this, fs) || z(this, oi)) &&
					(z(this, fs) &&
						((o = z(this, ss)) == null ||
							o.call(this, i, r, "evict")),
					z(this, oi) &&
						((s = z(this, sr)) == null || s.push([i, r, "evict"]))),
			z(this, Vc).call(this, n),
			e &&
				((z(this, nn)[n] = void 0),
				(z(this, ft)[n] = void 0),
				z(this, us).push(n)),
			z(this, Xn) === 1
				? (Te(this, Or, Te(this, or, 0)), (z(this, us).length = 0))
				: Te(this, Or, z(this, ii)[n]),
			z(this, jn).delete(r),
			o1(this, Xn)._--,
			n
		);
	}),
	(Eb = function (e, n, r, i) {
		const o = n === void 0 ? void 0 : z(this, ft)[n];
		if (Ne(this, Ie, tn).call(this, o)) return o;
		const s = new cy(),
			{ signal: a } = r;
		a == null ||
			a.addEventListener("abort", () => s.abort(a.reason), {
				signal: s.signal,
			});
		const l = { signal: s.signal, options: r, context: i },
			u = (g, v = !1) => {
				const { aborted: b } = s.signal,
					y = r.ignoreFetchAbort && g !== void 0;
				if (
					(r.status &&
						(b && !v
							? ((r.status.fetchAborted = !0),
								(r.status.fetchError = s.signal.reason),
								y && (r.status.fetchAbortIgnored = !0))
							: (r.status.fetchResolved = !0)),
					b && !y && !v)
				)
					return d(s.signal.reason);
				const x = h;
				return (
					z(this, ft)[n] === h &&
						(g === void 0
							? x.__staleWhileFetching
								? (z(this, ft)[n] = x.__staleWhileFetching)
								: Ne(this, Ie, Jl).call(this, e, "fetch")
							: (r.status && (r.status.fetchUpdated = !0),
								this.set(e, g, l.options))),
					g
				);
			},
			c = (g) => (
				r.status &&
					((r.status.fetchRejected = !0), (r.status.fetchError = g)),
				d(g)
			),
			d = (g) => {
				const { aborted: v } = s.signal,
					b = v && r.allowStaleOnFetchAbort,
					y = b || r.allowStaleOnFetchRejection,
					x = y || r.noDeleteOnFetchRejection,
					C = h;
				if (
					(z(this, ft)[n] === h &&
						(!x || C.__staleWhileFetching === void 0
							? Ne(this, Ie, Jl).call(this, e, "fetch")
							: b || (z(this, ft)[n] = C.__staleWhileFetching)),
					y)
				)
					return (
						r.status &&
							C.__staleWhileFetching !== void 0 &&
							(r.status.returnedStale = !0),
						C.__staleWhileFetching
					);
				if (C.__returned === C) throw g;
			},
			f = (g, v) => {
				var y;
				const b =
					(y = z(this, ph)) == null ? void 0 : y.call(this, e, o, l);
				b &&
					b instanceof Promise &&
					b.then((x) => g(x === void 0 ? void 0 : x), v),
					s.signal.addEventListener("abort", () => {
						(!r.ignoreFetchAbort || r.allowStaleOnFetchAbort) &&
							(g(void 0),
							r.allowStaleOnFetchAbort && (g = (x) => u(x, !0)));
					});
			};
		r.status && (r.status.fetchDispatched = !0);
		const h = new Promise(f).then(u, c),
			p = Object.assign(h, {
				__abortController: s,
				__staleWhileFetching: o,
				__returned: void 0,
			});
		return (
			n === void 0
				? (this.set(e, p, { ...l.options, status: void 0 }),
					(n = z(this, jn).get(e)))
				: (z(this, ft)[n] = p),
			p
		);
	}),
	(tn = function (e) {
		if (!z(this, cu)) return !1;
		const n = e;
		return (
			!!n &&
			n instanceof Promise &&
			n.hasOwnProperty("__staleWhileFetching") &&
			n.__abortController instanceof cy
		);
	}),
	(A2 = function (e, n) {
		(z(this, Gi)[n] = e), (z(this, ii)[e] = n);
	}),
	(im = function (e) {
		e !== z(this, or) &&
			(e === z(this, Or)
				? Te(this, Or, z(this, ii)[e])
				: Ne(this, Ie, A2).call(this, z(this, Gi)[e], z(this, ii)[e]),
			Ne(this, Ie, A2).call(this, z(this, or), e),
			Te(this, or, e));
	}),
	(Jl = function (e, n) {
		var i, o, s, a;
		let r = !1;
		if (z(this, Xn) !== 0) {
			const l = z(this, jn).get(e);
			if (l !== void 0)
				if (((r = !0), z(this, Xn) === 1))
					Ne(this, Ie, $2).call(this, n);
				else {
					z(this, Vc).call(this, l);
					const u = z(this, ft)[l];
					if (
						(Ne(this, Ie, tn).call(this, u)
							? u.__abortController.abort(new Error("deleted"))
							: (z(this, fs) || z(this, oi)) &&
								(z(this, fs) &&
									((i = z(this, ss)) == null ||
										i.call(this, u, e, n)),
								z(this, oi) &&
									((o = z(this, sr)) == null ||
										o.push([u, e, n]))),
						z(this, jn).delete(e),
						(z(this, nn)[l] = void 0),
						(z(this, ft)[l] = void 0),
						l === z(this, or))
					)
						Te(this, or, z(this, Gi)[l]);
					else if (l === z(this, Or)) Te(this, Or, z(this, ii)[l]);
					else {
						const c = z(this, Gi)[l];
						z(this, ii)[c] = z(this, ii)[l];
						const d = z(this, ii)[l];
						z(this, Gi)[d] = z(this, Gi)[l];
					}
					o1(this, Xn)._--, z(this, us).push(l);
				}
		}
		if (z(this, oi) && (s = z(this, sr)) != null && s.length) {
			const l = z(this, sr);
			let u;
			for (; (u = l == null ? void 0 : l.shift()); )
				(a = z(this, as)) == null || a.call(this, ...u);
		}
		return r;
	}),
	($2 = function (e) {
		var n, r, i;
		for (const o of Ne(this, Ie, Yl).call(this, { allowStale: !0 })) {
			const s = z(this, ft)[o];
			if (Ne(this, Ie, tn).call(this, s))
				s.__abortController.abort(new Error("deleted"));
			else {
				const a = z(this, nn)[o];
				z(this, fs) &&
					((n = z(this, ss)) == null || n.call(this, s, a, e)),
					z(this, oi) &&
						((r = z(this, sr)) == null || r.push([s, a, e]));
			}
		}
		if (
			(z(this, jn).clear(),
			z(this, ft).fill(void 0),
			z(this, nn).fill(void 0),
			z(this, Yi) &&
				z(this, ds) &&
				(z(this, Yi).fill(0), z(this, ds).fill(0)),
			z(this, cs) && z(this, cs).fill(0),
			Te(this, Or, 0),
			Te(this, or, 0),
			(z(this, us).length = 0),
			Te(this, ls, 0),
			Te(this, Xn, 0),
			z(this, oi) && z(this, sr))
		) {
			const o = z(this, sr);
			let s;
			for (; (s = o == null ? void 0 : o.shift()); )
				(i = z(this, as)) == null || i.call(this, ...s);
		}
	});
let dy = HA;
(!globalThis.EventTarget || !globalThis.Event) &&
	console.error(`
  PartySocket requires a global 'EventTarget' class to be available!
  You can polyfill this global by adding this to your code before any partysocket imports: 
  
  \`\`\`
  import 'partysocket/event-target-polyfill';
  \`\`\`
  Please file an issue at https://github.com/partykit/partykit if you're still having trouble.
`);
var TU = class extends Event {
		constructor(n, r) {
			super("error", r);
			Fe(this, "message");
			Fe(this, "error");
			(this.message = n.message), (this.error = n);
		}
	},
	BU = class extends Event {
		constructor(e = 1e3, n = "", r) {
			super("close", r);
			Fe(this, "code");
			Fe(this, "reason");
			Fe(this, "wasClean", !0);
			(this.code = e), (this.reason = n);
		}
	},
	Kk = { Event, ErrorEvent: TU, CloseEvent: BU };
function Gve(t, e) {
	if (!t) throw new Error(e);
}
function Yve(t) {
	return new t.constructor(t.type, t);
}
function Jve(t) {
	return "data" in t
		? new MessageEvent(t.type, t)
		: "code" in t || "reason" in t
			? new BU(t.code || 1999, t.reason || "unknown reason", t)
			: "error" in t
				? new TU(t.error, t)
				: new Event(t.type, t);
}
var Y8,
	Xve =
		typeof process < "u" &&
		typeof ((Y8 = process.versions) == null ? void 0 : Y8.node) < "u" &&
		typeof document > "u",
	z1 = Xve ? Jve : Yve,
	fc = {
		maxReconnectionDelay: 1e4,
		minReconnectionDelay: 1e3 + Math.random() * 4e3,
		minUptime: 5e3,
		reconnectionDelayGrowFactor: 1.3,
		connectionTimeout: 4e3,
		maxRetries: 1 / 0,
		maxEnqueuedMessages: 1 / 0,
		startClosed: !1,
		debug: !1,
	},
	iI = !1,
	Zve = class bc extends EventTarget {
		constructor(n, r, i = {}) {
			super();
			Fe(this, "_ws");
			Fe(this, "_retryCount", -1);
			Fe(this, "_uptimeTimeout");
			Fe(this, "_connectTimeout");
			Fe(this, "_shouldReconnect", !0);
			Fe(this, "_connectLock", !1);
			Fe(this, "_binaryType", "blob");
			Fe(this, "_closeCalled", !1);
			Fe(this, "_messageQueue", []);
			Fe(this, "_url");
			Fe(this, "_protocols");
			Fe(this, "_options");
			Fe(this, "onclose", null);
			Fe(this, "onerror", null);
			Fe(this, "onmessage", null);
			Fe(this, "onopen", null);
			Fe(this, "_handleOpen", (n) => {
				this._debug("open event");
				const { minUptime: r = fc.minUptime } = this._options;
				clearTimeout(this._connectTimeout),
					(this._uptimeTimeout = setTimeout(
						() => this._acceptOpen(),
						r,
					)),
					Gve(this._ws, "WebSocket is not defined"),
					(this._ws.binaryType = this._binaryType),
					this._messageQueue.forEach((i) => {
						var o;
						return (o = this._ws) == null ? void 0 : o.send(i);
					}),
					(this._messageQueue = []),
					this.onopen && this.onopen(n),
					this.dispatchEvent(z1(n));
			});
			Fe(this, "_handleMessage", (n) => {
				this._debug("message event"),
					this.onmessage && this.onmessage(n),
					this.dispatchEvent(z1(n));
			});
			Fe(this, "_handleError", (n) => {
				this._debug("error event", n.message),
					this._disconnect(
						void 0,
						n.message === "TIMEOUT" ? "timeout" : void 0,
					),
					this.onerror && this.onerror(n),
					this._debug("exec error listeners"),
					this.dispatchEvent(z1(n)),
					this._connect();
			});
			Fe(this, "_handleClose", (n) => {
				this._debug("close event"),
					this._clearTimeouts(),
					this._shouldReconnect && this._connect(),
					this.onclose && this.onclose(n),
					this.dispatchEvent(z1(n));
			});
			(this._url = n),
				(this._protocols = r),
				(this._options = i),
				this._options.startClosed && (this._shouldReconnect = !1),
				this._connect();
		}
		static get CONNECTING() {
			return 0;
		}
		static get OPEN() {
			return 1;
		}
		static get CLOSING() {
			return 2;
		}
		static get CLOSED() {
			return 3;
		}
		get CONNECTING() {
			return bc.CONNECTING;
		}
		get OPEN() {
			return bc.OPEN;
		}
		get CLOSING() {
			return bc.CLOSING;
		}
		get CLOSED() {
			return bc.CLOSED;
		}
		get binaryType() {
			return this._ws ? this._ws.binaryType : this._binaryType;
		}
		set binaryType(n) {
			(this._binaryType = n), this._ws && (this._ws.binaryType = n);
		}
		get retryCount() {
			return Math.max(this._retryCount, 0);
		}
		get bufferedAmount() {
			return (
				this._messageQueue.reduce(
					(r, i) => (
						typeof i == "string"
							? (r += i.length)
							: i instanceof Blob
								? (r += i.size)
								: (r += i.byteLength),
						r
					),
					0,
				) + (this._ws ? this._ws.bufferedAmount : 0)
			);
		}
		get extensions() {
			return this._ws ? this._ws.extensions : "";
		}
		get protocol() {
			return this._ws ? this._ws.protocol : "";
		}
		get readyState() {
			return this._ws
				? this._ws.readyState
				: this._options.startClosed
					? bc.CLOSED
					: bc.CONNECTING;
		}
		get url() {
			return this._ws ? this._ws.url : "";
		}
		get shouldReconnect() {
			return this._shouldReconnect;
		}
		close(n = 1e3, r) {
			if (
				((this._closeCalled = !0),
				(this._shouldReconnect = !1),
				this._clearTimeouts(),
				!this._ws)
			) {
				this._debug("close enqueued: no ws instance");
				return;
			}
			if (this._ws.readyState === this.CLOSED) {
				this._debug("close: already closed");
				return;
			}
			this._ws.close(n, r);
		}
		reconnect(n, r) {
			(this._shouldReconnect = !0),
				(this._closeCalled = !1),
				(this._retryCount = -1),
				!this._ws || this._ws.readyState === this.CLOSED
					? this._connect()
					: (this._disconnect(n, r), this._connect());
		}
		send(n) {
			if (this._ws && this._ws.readyState === this.OPEN)
				this._debug("send", n), this._ws.send(n);
			else {
				const { maxEnqueuedMessages: r = fc.maxEnqueuedMessages } =
					this._options;
				this._messageQueue.length < r &&
					(this._debug("enqueue", n), this._messageQueue.push(n));
			}
		}
		_debug(...n) {
			this._options.debug && console.log.apply(console, ["RWS>", ...n]);
		}
		_getNextDelay() {
			const {
				reconnectionDelayGrowFactor: n = fc.reconnectionDelayGrowFactor,
				minReconnectionDelay: r = fc.minReconnectionDelay,
				maxReconnectionDelay: i = fc.maxReconnectionDelay,
			} = this._options;
			let o = 0;
			return (
				this._retryCount > 0 &&
					((o = r * Math.pow(n, this._retryCount - 1)),
					o > i && (o = i)),
				this._debug("next delay", o),
				o
			);
		}
		_wait() {
			return new Promise((n) => {
				setTimeout(n, this._getNextDelay());
			});
		}
		_getNextProtocols(n) {
			if (!n) return Promise.resolve(null);
			if (typeof n == "string" || Array.isArray(n))
				return Promise.resolve(n);
			if (typeof n == "function") {
				const r = n();
				if (!r) return Promise.resolve(null);
				if (typeof r == "string" || Array.isArray(r))
					return Promise.resolve(r);
				if (r.then) return r;
			}
			throw Error("Invalid protocols");
		}
		_getNextUrl(n) {
			if (typeof n == "string") return Promise.resolve(n);
			if (typeof n == "function") {
				const r = n();
				if (typeof r == "string") return Promise.resolve(r);
				if (r.then) return r;
			}
			throw Error("Invalid URL");
		}
		_connect() {
			if (this._connectLock || !this._shouldReconnect) return;
			this._connectLock = !0;
			const {
				maxRetries: n = fc.maxRetries,
				connectionTimeout: r = fc.connectionTimeout,
			} = this._options;
			if (this._retryCount >= n) {
				this._debug("max retries reached", this._retryCount, ">=", n);
				return;
			}
			this._retryCount++,
				this._debug("connect", this._retryCount),
				this._removeListeners(),
				this._wait()
					.then(() =>
						Promise.all([
							this._getNextUrl(this._url),
							this._getNextProtocols(this._protocols || null),
						]),
					)
					.then(([i, o]) => {
						if (this._closeCalled) {
							this._connectLock = !1;
							return;
						}
						!this._options.WebSocket &&
							typeof WebSocket > "u" &&
							!iI &&
							(console.error(`‼️ No WebSocket implementation available. You should define options.WebSocket. 

For example, if you're using node.js, run \`npm install ws\`, and then in your code:

import PartySocket from 'partysocket';
import WS from 'ws';

const partysocket = new PartySocket({
  host: "127.0.0.1:1999",
  room: "test-room",
  WebSocket: WS
});

`),
							(iI = !0));
						const s = this._options.WebSocket || WebSocket;
						this._debug("connect", { url: i, protocols: o }),
							(this._ws = o ? new s(i, o) : new s(i)),
							(this._ws.binaryType = this._binaryType),
							(this._connectLock = !1),
							this._addListeners(),
							(this._connectTimeout = setTimeout(
								() => this._handleTimeout(),
								r,
							));
					})
					.catch((i) => {
						(this._connectLock = !1),
							this._handleError(
								new Kk.ErrorEvent(Error(i.message), this),
							);
					});
		}
		_handleTimeout() {
			this._debug("timeout event"),
				this._handleError(new Kk.ErrorEvent(Error("TIMEOUT"), this));
		}
		_disconnect(n = 1e3, r) {
			if ((this._clearTimeouts(), !!this._ws)) {
				this._removeListeners();
				try {
					this._ws.close(n, r),
						this._handleClose(new Kk.CloseEvent(n, r, this));
				} catch {}
			}
		}
		_acceptOpen() {
			this._debug("accept open"), (this._retryCount = 0);
		}
		_removeListeners() {
			this._ws &&
				(this._debug("removeListeners"),
				this._ws.removeEventListener("open", this._handleOpen),
				this._ws.removeEventListener("close", this._handleClose),
				this._ws.removeEventListener("message", this._handleMessage),
				this._ws.removeEventListener("error", this._handleError));
		}
		_addListeners() {
			this._ws &&
				(this._debug("addListeners"),
				this._ws.addEventListener("open", this._handleOpen),
				this._ws.addEventListener("close", this._handleClose),
				this._ws.addEventListener("message", this._handleMessage),
				this._ws.addEventListener("error", this._handleError));
		}
		_clearTimeouts() {
			clearTimeout(this._connectTimeout),
				clearTimeout(this._uptimeTimeout);
		}
	};
/*!
 * Reconnecting WebSocket
 * by Pedro Ladaria <pedro.ladaria@gmail.com>
 * https://github.com/pladaria/reconnecting-websocket
 * License MIT
 */ const m3 = E.forwardRef(function (e, n) {
	const r = ce(19);
	e = Yr(e, "avatar");
	let i, o, s;
	r[0] !== e
		? (({ alt: s, size: i, ...o } = e),
			(r[0] = e),
			(r[1] = i),
			(r[2] = o),
			(r[3] = s))
		: ((i = r[1]), (o = r[2]), (s = r[3]));
	const a = i === void 0 ? "regular" : i,
		l = ht(o),
		u = a === "regular" ? void 0 : a;
	let c;
	r[4] !== o ? ((c = Ge(o)), (r[4] = o), (r[5] = c)) : (c = r[5]);
	let d;
	r[6] !== l.className
		? ((d = Se(
				l.className,
				X({
					alignItems: "center",
					backgroundColor: B.color.background.surfaceTertiary,
					borderRadius: "50%",
					display: "inline-flex",
					flexShrink: 0,
					fontSize: "var(--avatar-text-size)",
					height: "var(--avatar-size)",
					justifyContent: "center",
					overflow: "hidden",
					width: "var(--avatar-size)",
					userSelect: "none",
					"--avatar-size": B.size.element.regular,
					"--avatar-text-size": B.typography.text.regular.size,
					"&[data-size=xsmall]": {
						"--avatar-size": B.size.element.xsmall,
						"--avatar-text-size": B.typography.text.small.size,
					},
					"&[data-size=small]": {
						"--avatar-size": B.size.element.small,
						"--avatar-text-size": B.typography.text.small.size,
					},
					"&[data-size=medium]": {
						"--avatar-size": B.size.element.medium,
						"--avatar-text-size": B.typography.text.medium.size,
					},
					"&[data-size=large]": {
						"--avatar-size": B.size.element.large,
						"--avatar-text-size": B.typography.text.large.size,
					},
					"&[data-size=xlarge]": {
						"--avatar-size": B.size.element.xlarge,
						"--avatar-text-size": B.typography.text.large.size,
					},
				}),
			)),
			(r[6] = l.className),
			(r[7] = d))
		: (d = r[7]);
	let f;
	r[8] !== e || r[9] !== a
		? ((f =
				"src" in e
					? m.jsx("div", {
							className: X({ height: "100%", width: "100%" }),
							style: {
								backgroundImage: `url(${e.src})`,
								backgroundPosition: "center",
								backgroundRepeat: "no-repeat",
								backgroundSize: "cover",
							},
						})
					: m.jsx(ue, {
							"aria-hidden": !0,
							color: "neutralSecondary",
							weight: "medium",
							UNSAFE_className: X({ fontSize: "inherit" }),
							children: Qve(e.name, a),
						})),
			(r[8] = e),
			(r[9] = a),
			(r[10] = f))
		: (f = r[10]);
	let h;
	return (
		r[11] !== n ||
		r[12] !== s ||
		r[13] !== u ||
		r[14] !== l ||
		r[15] !== c ||
		r[16] !== d ||
		r[17] !== f
			? ((h = m.jsx("div", {
					ref: n,
					role: "img",
					"aria-label": s,
					"data-size": u,
					...l,
					...c,
					className: d,
					children: f,
				})),
				(r[11] = n),
				(r[12] = s),
				(r[13] = u),
				(r[14] = l),
				(r[15] = c),
				(r[16] = d),
				(r[17] = f),
				(r[18] = h))
			: (h = r[18]),
		h
	);
});
function Qve(t, e) {
	const n = t.split(" "),
		r = n[0].charAt(0),
		i = n[n.length - 1].charAt(0);
	return e === "xsmall" ? `${r}`.toUpperCase() : `${r}${i}`.toUpperCase();
}
const IU = E.createContext(null);
function eye(t) {
	const e = ee(17);
	let n;
	e[0] === Symbol.for("react.memo_cache_sentinel")
		? ((n = () => window.location.href), (e[0] = n))
		: (n = e[0]);
	const [r, i] = E.useState(n);
	let o;
	e[1] === Symbol.for("react.memo_cache_sentinel")
		? ((o = function (k, w) {
				const D = new URL(k, window.location.href);
				if (
					D.origin !== window.location.origin ||
					!D.pathname.startsWith("/keystatic")
				) {
					window.location.assign(D);
					return;
				}
				window.history[w ? "replaceState" : "pushState"](null, "", D),
					E.startTransition(() => {
						i(D.toString());
					});
			}),
			(e[1] = o))
		: (o = e[1]);
	const s = o;
	let a;
	e[2] === Symbol.for("react.memo_cache_sentinel")
		? ((a = function (k) {
				s(k, !0);
			}),
			(e[2] = a))
		: (a = e[2]);
	const l = a;
	let u;
	e[3] === Symbol.for("react.memo_cache_sentinel")
		? ((u = function (k) {
				s(k, !1);
			}),
			(e[3] = u))
		: (u = e[3]);
	const c = u;
	let d, f;
	if (e[4] !== r) {
		f = new URL(r);
		const C = f.pathname.replace(/^\/keystatic\/?/, "");
		(d = C === "" ? [] : C.split("/").map(decodeURIComponent)),
			(e[4] = r),
			(e[5] = d),
			(e[6] = f);
	} else (d = e[5]), (f = e[6]);
	const h = d,
		p = f.pathname + f.search;
	let g;
	e[7] !== p || e[8] !== f.pathname || e[9] !== f.search || e[10] !== h
		? ((g = {
				href: p,
				pathname: f.pathname,
				search: f.search,
				replace: l,
				push: c,
				params: h,
			}),
			(e[7] = p),
			(e[8] = f.pathname),
			(e[9] = f.search),
			(e[10] = h),
			(e[11] = g))
		: (g = e[11]);
	const v = g;
	let b, y;
	e[12] === Symbol.for("react.memo_cache_sentinel")
		? ((b = () => {
				const C = () => {
					E.startTransition(() => {
						i(window.location.href);
					});
				};
				return (
					window.addEventListener("popstate", C),
					() => {
						window.removeEventListener("popstate", C);
					}
				);
			}),
			(y = []),
			(e[12] = b),
			(e[13] = y))
		: ((b = e[12]), (y = e[13])),
		E.useEffect(b, y);
	let x;
	return (
		e[14] !== v || e[15] !== t.children
			? ((x = m.jsx(IU.Provider, { value: v, children: t.children })),
				(e[14] = v),
				(e[15] = t.children),
				(e[16] = x))
			: (x = e[16]),
		x
	);
}
function En() {
	const t = E.useContext(IU);
	if (t == null)
		throw new Error("useRouter must be used within a RouterProvider");
	return t;
}
function xr(t) {
	return t.replace(/^\.?\/+/, "").replace(/\/*$/, "");
}
const tye = /\/\*\*?(?:$|\/)/;
function g3(t, e) {
	var n;
	const i =
		(n = t.collections[e].path) !== null && n !== void 0 ? n : `${e}/*/`;
	if (!tye.test(i))
		throw new Error(
			`Collection path must end with /* or /** or include /*/ or /**/ but ${e} has ${i}`,
		);
	return i;
}
function r5(t, e) {
	const n = g3(t, e);
	return xr(n.replace(/\*\*?.*$/, ""));
}
function qo(t, e) {
	const n = t.collections[e];
	return PU(n)(g3(t, e));
}
function kg(t, e) {
	var n;
	const r = t.singletons[e];
	return PU(r)((n = r.path) !== null && n !== void 0 ? n : `${e}/`);
}
function Ni(t, e, n) {
	const r = r5(t, e),
		i = FU(t, e);
	return `${r}/${n}${i}`;
}
function up(t, e) {
	return `${t}${e.dataLocation === "index" ? "/index" : ""}${N0(e)}`;
}
function i5(t, e) {
	return g3(t, e).includes("**") ? "**" : "*";
}
function FU(t, e) {
	const n = g3(t, e),
		r = xr(n.replace(/^[^*]+\*\*?/, ""));
	return r ? `/${r}` : "";
}
function P0(t, e) {
	var n, r;
	if ((n = t.singletons[e].path) !== null && n !== void 0 && n.includes("*"))
		throw new Error(
			`Singleton paths cannot include * but ${e} has ${t.singletons[e].path}`,
		);
	return xr((r = t.singletons[e].path) !== null && r !== void 0 ? r : e);
}
function N0(t) {
	return t.contentField ? t.contentField.contentExtension : "." + t.data;
}
function nye(t) {
	const e = new WeakMap();
	return (n) => {
		if (e.has(n)) return e.get(n);
		const r = t(n);
		return e.set(n, r), r;
	};
}
function rye(t) {
	const e = new Map();
	return (n) => {
		if (e.has(n)) return e.get(n);
		const r = t(n);
		return e.set(n, r), r;
	};
}
const PU = nye((t) => rye((e) => iye(t, e)));
function iye(t, e) {
	var n;
	const r = e.endsWith("/") ? "index" : "outer",
		{ schema: i, format: o = "yaml" } = t;
	if (typeof o == "string")
		return { dataLocation: r, contentField: void 0, data: o };
	let s;
	if (o.contentField) {
		let a = { kind: "object", fields: i },
			l = Array.isArray(o.contentField)
				? o.contentField
				: [o.contentField];
		s = {
			path: l,
			contentExtension: T2(l, a, () =>
				l.length === 1 ? l[0] : JSON.stringify(l),
			),
		};
	}
	return {
		data: (n = o.data) !== null && n !== void 0 ? n : "yaml",
		contentField: s,
		dataLocation: r,
	};
}
function T2(t, e, n) {
	if (t.length === 0) {
		if (e.kind !== "form" || e.formKind !== "content")
			throw new Error(`Content field for ${n()} is not a content field`);
		return e.contentExtension;
	}
	if (e.kind === "object") return T2(t.slice(1), e.fields[t[0]], n);
	if (e.kind === "conditional") {
		if (t[0] !== "value")
			throw new Error(
				`Conditional fields referenced in a contentField path must only reference the value field (${n()})`,
			);
		let r;
		const i = t.slice(1);
		for (const o of Object.values(e.values)) {
			const s = T2(i, o, n);
			if (!r) {
				r = s;
				continue;
			}
			if (r !== s)
				throw new Error(
					`contentField ${n()} has conflicting content extensions`,
				);
		}
		if (!r)
			throw new Error(
				`contentField ${n()} does not point to a content field`,
			);
		return r;
	}
	throw new Error(
		`Path specified in contentField ${n()} does not point to a content field`,
	);
}
function Ju(t) {
	if (!(t.kind === "local" || !t.pathPrefix)) return xr(t.pathPrefix) + "/";
}
async function NU(t) {
	const e = await crypto.subtle.digest("SHA-1", t);
	return Vve(new Uint8Array(e));
}
const Sm = new TextEncoder(),
	Uk = new WeakMap();
async function o5(t) {
	const e = Uk.get(t);
	if (e !== void 0) return e;
	const n = Sm.encode("blob " + t.length + "\0"),
		r = new Uint8Array(n.byteLength + t.byteLength);
	r.set(n, 0), r.set(t, n.byteLength);
	const i = NU(r);
	return Uk.set(t, i), i.then((o) => Uk.set(t, o)), i;
}
function al(t, e) {
	const n = e.split("/");
	let r = t.get(n[0]);
	for (const i of n.slice(1)) {
		if (!r || !r.children) return;
		r = r.children.get(i);
	}
	return r;
}
function oI(t, e) {
	if (e === "") return t;
	let n = t;
	for (const r of e.split("/")) {
		n.has(r) || n.set(r, new Map());
		const i = n.get(r);
		wt(i instanceof Map, "expected tree"), (n = i);
	}
	return n;
}
function sI(t) {
	return t.replace(/.*\//, "");
}
function aI(t) {
	return t.includes("/") ? t.replace(/\/[^/]+$/, "") : "";
}
function oye(t) {
	const e = new Map();
	for (const n of t.deletions) oI(e, aI(n)).set(sI(n), "delete");
	for (const n of t.additions) oI(e, aI(n.path)).set(sI(n.path), n.contents);
	return e;
}
const sye = 32,
	aye = new Uint8Array([sye]),
	lI = new Uint8Array([0]),
	lye = Sm.encode("tree ");
function R0(t) {
	const e = [...t].map(([r, i]) => ({
		name: r,
		sha: i.entry.sha,
		mode: i.entry.mode,
	}));
	e.sort((r, i) => {
		const o = r.mode === "040000" ? r.name + "/" : r.name,
			s = i.mode === "040000" ? i.name + "/" : i.name;
		return o === s ? 0 : o < s ? -1 : 1;
	});
	const n = e.flatMap((r) => {
		const i = Sm.encode(r.mode.replace(/^0/, "")),
			o = Sm.encode(r.name),
			s = cye(r.sha);
		return [i, aye, o, lI, s];
	});
	return NU(
		uye([
			lye,
			Sm.encode(n.reduce((r, i) => r + i.byteLength, 0).toString()),
			lI,
			...n,
		]),
	);
}
function uye(t) {
	const e = t.reduce((i, o) => i + o.byteLength, 0),
		n = new Uint8Array(e);
	let r = 0;
	for (const i of t) n.set(i, r), (r += i.byteLength);
	return n;
}
function cye(t) {
	const e = new Uint8Array(t.length / 2);
	for (var n = 0; n < e.byteLength; n += 1) {
		const r = n * 2;
		e[n] = parseInt(t.slice(r, r + 2), 16);
	}
	return e;
}
async function dye(t, e) {
	const n = await R0(e);
	return { path: t, mode: "040000", type: "tree", sha: n };
}
async function fye(t, e) {
	const n = "sha" in e ? e.sha : await o5(e);
	return { path: t, mode: "100644", type: "blob", sha: n };
}
async function RU(t, e) {
	var n;
	const r =
		(n = await OU(t, oye(e), [])) !== null && n !== void 0 ? n : new Map();
	return { entries: fy(r), sha: await R0(r ?? new Map()) };
}
function fy(t) {
	return [...t.values()].flatMap((e) =>
		e.children ? [e.entry, ...fy(e.children)] : [e.entry],
	);
}
async function OU(t, e, n) {
	const r = new Map(t);
	for (const [s, a] of e) {
		if ((a === "delete" && r.delete(s), a instanceof Map)) {
			var i, o;
			const l =
					(i =
						(o = r.get(s)) === null || o === void 0
							? void 0
							: o.children) !== null && i !== void 0
						? i
						: new Map(),
				u = await OU(l, a, n.concat(s));
			if (u === void 0) {
				r.delete(s);
				continue;
			}
			const c = await dye(n.concat(s).join("/"), u);
			r.set(s, { entry: c, children: u });
		}
		if (a instanceof Uint8Array || (typeof a == "object" && "sha" in a)) {
			const l = await fye(n.concat(s).join("/"), a);
			r.set(s, { entry: l });
		}
	}
	if (r.size !== 0) return r;
}
function s5(t) {
	const e = new Map(),
		n = (r) => {
			var i;
			if (r.length === 0) return e;
			let o = e.get(r[0]);
			for (const s of r.slice(1)) {
				if (!o || !o.children) return;
				o = o.children.get(s);
			}
			return (i = o) === null || i === void 0 ? void 0 : i.children;
		};
	for (const r of t) {
		const i = r.path.split("/"),
			o = n(i.slice(0, -1));
		o &&
			o.set(i[i.length - 1], {
				entry: r,
				children: r.type === "tree" ? new Map() : void 0,
			});
	}
	return e;
}
function hye(t) {
	const e = { inner: new WeakMap() };
	return function (...n) {
		let r = e;
		for (const i of n) {
			const { inner: o } = r;
			o.has(i) || o.set(i, { inner: new WeakMap() }), (r = o.get(i));
		}
		return r.hasOwnProperty("value") || (r.value = t(...n)), r.value;
	};
}
const zo = { then() {} };
function L1(t) {
	return t && typeof t.then == "function";
}
function Hk(t) {
	if (t.kind === "error") throw t.error;
	if (t.kind === "loaded") return t.data;
	throw t.promise;
}
function bo(t) {
	const e = E.useMemo(() => {
			try {
				const s = t();
				return (
					L1(s) &&
						s.then(
							() => {},
							() => {},
						),
					{ kind: "result", result: s }
				);
			} catch (s) {
				return { kind: "error", error: s };
			}
		}, [t]),
		[n, r] = E.useState(() =>
			e.kind === "result"
				? L1(e.result)
					? { kind: "loading", promise: e.result }
					: { kind: "loaded", data: e.result }
				: e,
		);
	let i = n;
	const o = E.useMemo(() => {
		if (e.kind === "error" && (n.kind !== "error" || n.error !== e.error))
			return { kind: "error", error: e.error };
		if (
			e.kind === "result" &&
			!L1(e.result) &&
			(n.kind !== "loaded" || n.data !== e.result)
		)
			return { kind: "loaded", data: e.result };
	}, [e, n]);
	return (
		o && o !== n && ((i = o), r(o)),
		E.useEffect(() => {
			if (e.kind === "result" && L1(e.result)) {
				r({ kind: "loading", promise: e.result });
				let s = !0;
				return (
					e.result.then(
						(a) => {
							s && r({ kind: "loaded", data: a });
						},
						(a) => {
							s && r({ kind: "error", error: a });
						},
					),
					() => {
						s = !1;
					}
				);
			}
		}, [e]),
		i
	);
}
function uI(t, e) {
	return t.kind === "error" || t.kind === "loading"
		? t
		: { kind: "loaded", data: e(t.data) };
}
function MU(t) {
	const e = Object.entries(t);
	for (const [, r] of e)
		if (r.kind === "error") return { kind: "error", error: r.error };
	let n = [];
	for (const [, r] of e) r.kind === "loading" && n.push(r.promise);
	return n.length
		? { kind: "loading", promise: pye(...n) }
		: {
				kind: "loaded",
				data: Object.fromEntries(e.map(([r, i]) => [r, i.data])),
			};
}
const pye = hye((...t) => Promise.all(t));
function Db(t, e, n) {
	if (!n.has(t)) {
		if ((n.add(t), t.kind === "array")) return Db(t.element, e, n);
		if (t.kind !== "child") {
			if (t.kind === "form") {
				if (
					(t.formKind === "asset" &&
						t.directory !== void 0 &&
						e.add(xr(t.directory)),
					(t.formKind === "content" || t.formKind === "assets") &&
						t.directories !== void 0)
				)
					for (const r of t.directories) e.add(xr(r));
				return;
			}
			if (t.kind === "object") {
				for (const r of Object.values(t.fields)) Db(r, e, n);
				return;
			}
			if (t.kind === "conditional") {
				for (const r of Object.values(t.values)) Db(r, e, n);
				return;
			}
			qn(t);
		}
	}
}
function b3(t) {
	const e = new Set();
	return Db(t, e, new Set()), e;
}
function jU(t, e, n, r) {
	const i = [xr(e)];
	r.dataLocation === "outer" && i.push(xr(e) + N0(r));
	const o = n === void 0 ? "" : `/${n}`;
	for (const s of b3(t)) i.push(s + o);
	return i;
}
function Am(t, e) {
	return t
		.map((n) => {
			var r;
			return (r = al(e, n)) === null || r === void 0
				? void 0
				: r.entry.sha;
		})
		.join("-");
}
var _U = {
	name: "@keystatic/core",
	version: "0.5.35",
	license: "MIT",
	repository: {
		type: "git",
		url: "https://github.com/Thinkmill/keystatic/",
		directory: "packages/keystatic",
	},
	type: "module",
	exports: {
		"./ui": {
			types: "./dist/keystatic-core-ui.js",
			node: {
				"react-server": "./dist/keystatic-core-ui.node.react-server.js",
				default: "./dist/keystatic-core-ui.node.js",
			},
			"react-server": "./dist/keystatic-core-ui.react-server.js",
			worker: "./dist/keystatic-core-ui.worker.js",
			default: "./dist/keystatic-core-ui.js",
		},
		".": {
			types: "./dist/keystatic-core.js",
			node: {
				"react-server": "./dist/keystatic-core.node.react-server.js",
				default: "./dist/keystatic-core.node.js",
			},
			"react-server": "./dist/keystatic-core.react-server.js",
			worker: "./dist/keystatic-core.worker.js",
			default: "./dist/keystatic-core.js",
		},
		"./api/utils": {
			types: "./dist/keystatic-core-api-utils.js",
			node: {
				"react-server":
					"./dist/keystatic-core-api-utils.node.react-server.js",
				default: "./dist/keystatic-core-api-utils.node.js",
			},
			"react-server": "./dist/keystatic-core-api-utils.react-server.js",
			worker: "./dist/keystatic-core-api-utils.worker.js",
			default: "./dist/keystatic-core-api-utils.js",
		},
		"./renderer": {
			types: "./dist/keystatic-core-renderer.js",
			node: {
				"react-server":
					"./dist/keystatic-core-renderer.node.react-server.js",
				default: "./dist/keystatic-core-renderer.node.js",
			},
			"react-server": "./dist/keystatic-core-renderer.react-server.js",
			worker: "./dist/keystatic-core-renderer.worker.js",
			default: "./dist/keystatic-core-renderer.js",
		},
		"./api/generic": {
			types: "./dist/keystatic-core-api-generic.js",
			node: {
				"react-server":
					"./dist/keystatic-core-api-generic.node.react-server.js",
				default: "./dist/keystatic-core-api-generic.node.js",
			},
			"react-server": "./dist/keystatic-core-api-generic.react-server.js",
			worker: "./dist/keystatic-core-api-generic.worker.js",
			default: "./dist/keystatic-core-api-generic.js",
		},
		"./reader": {
			types: "./dist/keystatic-core-reader.js",
			node: {
				"react-server":
					"./dist/keystatic-core-reader.node.react-server.js",
				default: "./dist/keystatic-core-reader.node.js",
			},
			"react-server": "./dist/keystatic-core-reader.react-server.js",
			worker: "./dist/keystatic-core-reader.worker.js",
			default: "./dist/keystatic-core-reader.js",
		},
		"./reader/github": {
			types: "./dist/keystatic-core-reader-github.js",
			node: {
				"react-server":
					"./dist/keystatic-core-reader-github.node.react-server.js",
				default: "./dist/keystatic-core-reader-github.node.js",
			},
			"react-server":
				"./dist/keystatic-core-reader-github.react-server.js",
			worker: "./dist/keystatic-core-reader-github.worker.js",
			default: "./dist/keystatic-core-reader-github.js",
		},
		"./content-components": {
			types: "./dist/keystatic-core-content-components.js",
			node: {
				"react-server":
					"./dist/keystatic-core-content-components.node.react-server.js",
				default: "./dist/keystatic-core-content-components.node.js",
			},
			"react-server":
				"./dist/keystatic-core-content-components.react-server.js",
			worker: "./dist/keystatic-core-content-components.worker.js",
			default: "./dist/keystatic-core-content-components.js",
		},
		"./component-blocks": {
			types: "./dist/keystatic-core-component-blocks.js",
			node: {
				"react-server":
					"./dist/keystatic-core-component-blocks.node.react-server.js",
				default: "./dist/keystatic-core-component-blocks.node.js",
			},
			"react-server":
				"./dist/keystatic-core-component-blocks.react-server.js",
			worker: "./dist/keystatic-core-component-blocks.worker.js",
			default: "./dist/keystatic-core-component-blocks.js",
		},
		"./package.json": "./package.json",
	},
	files: ["dist"],
	scripts: {
		setup: "ts-gql build && tsx scripts/l10n.cts && tsx scripts/build-prism.cts",
		build: "pnpm run setup && next build",
		dev: "next dev",
		start: "next start",
	},
	dependencies: {
		"@babel/runtime": "^7.18.3",
		"@braintree/sanitize-url": "^6.0.2",
		"@emotion/css": "^11.9.0",
		"@emotion/weak-memoize": "^0.3.0",
		"@floating-ui/react": "^0.24.0",
		"@internationalized/string": "^3.2.3",
		"@keystar/ui": "workspace:^",
		"@markdoc/markdoc": "^0.4.0",
		"@react-aria/focus": "^3.18.1",
		"@react-aria/i18n": "^3.12.1",
		"@react-aria/interactions": "^3.22.1",
		"@react-aria/label": "^3.7.11",
		"@react-aria/overlays": "^3.23.2",
		"@react-aria/selection": "^3.19.3",
		"@react-aria/utils": "^3.25.1",
		"@react-aria/visually-hidden": "^3.8.15",
		"@react-stately/collections": "^3.10.9",
		"@react-stately/list": "^3.10.8",
		"@react-stately/overlays": "^3.6.10",
		"@react-stately/utils": "^3.10.3",
		"@react-types/shared": "^3.24.1",
		"@sindresorhus/slugify": "^1.1.2",
		"@toeverything/y-indexeddb": "^0.10.0-canary.9",
		"@ts-gql/tag": "^0.7.3",
		"@types/react": "^18.2.8",
		"@urql/core": "^5.0.4",
		"@urql/exchange-auth": "^2.2.0",
		"@urql/exchange-graphcache": "^7.1.2",
		"@urql/exchange-persisted": "^4.3.0",
		cookie: "^0.5.0",
		"decimal.js-light": "^2.5.1",
		emery: "^1.4.1",
		"escape-string-regexp": "^4.0.0",
		"fast-deep-equal": "^3.1.3",
		graphql: "^16.6.0",
		"idb-keyval": "^6.2.1",
		ignore: "^5.2.4",
		"is-hotkey": "^0.2.0",
		"js-yaml": "^4.1.0",
		lib0: "^0.2.88",
		"lru-cache": "^10.2.0",
		"match-sorter": "^6.3.1",
		"mdast-util-from-markdown": "^2.0.0",
		"mdast-util-gfm": "^3.0.0",
		"mdast-util-gfm-autolink-literal": "^2.0.0",
		"mdast-util-gfm-strikethrough": "^2.0.0",
		"mdast-util-mdx": "^3.0.0",
		"mdast-util-to-markdown": "^2.1.0",
		"micromark-extension-gfm": "^3.0.0",
		"micromark-extension-gfm-autolink-literal": "^2.0.0",
		"micromark-extension-gfm-strikethrough": "^2.0.0",
		"micromark-extension-mdxjs": "^3.0.0",
		minimatch: "^9.0.3",
		partysocket: "^0.0.22",
		"prosemirror-commands": "^1.5.1",
		"prosemirror-history": "^1.3.0",
		"prosemirror-keymap": "^1.2.1",
		"prosemirror-model": "^1.19.0",
		"prosemirror-state": "^1.4.2",
		"prosemirror-tables": "^1.3.4",
		"prosemirror-transform": "^1.7.1",
		"prosemirror-view": "^1.30.2",
		"scroll-into-view-if-needed": "^3.0.3",
		slate: "^0.91.4",
		"slate-history": "^0.86.0",
		"slate-react": "^0.91.9",
		superstruct: "^1.0.4",
		"unist-util-visit": "^5.0.0",
		urql: "^4.1.0",
		"y-prosemirror": "^1.2.2",
		"y-protocols": "^1.0.6",
		yjs: "^13.6.11",
	},
	devDependencies: {
		"@internationalized/string-compiler": "^3.2.4",
		"@jest/expect": "^29.7.0",
		"@jest/globals": "^29.7.0",
		"@testing-library/user-event": "^14.4.3",
		"@ts-gql/compiler": "^0.16.7",
		"@ts-gql/eslint-plugin": "^0.9.1",
		"@ts-gql/next": "^17.0.1",
		"@types/cookie": "^0.5.1",
		"@types/is-hotkey": "^0.1.7",
		"@types/js-yaml": "^4.0.5",
		"@types/mdast": "^4.0.3",
		"@types/node": "16.11.13",
		"@types/prismjs": "^1.26.0",
		"@types/react-dom": "^18.0.11",
		"@types/signal-exit": "^3.0.1",
		eslint: "^8.18.0",
		"fast-glob": "^3.2.12",
		"jest-diff": "^29.0.1",
		outdent: "^0.8.0",
		"pretty-format": "^29.0.1",
		prismjs: "^1.29.0",
		react: "^18.2.0",
		"react-dom": "^18.2.0",
		"react-element-to-jsx-string": "^15.0.0",
		"resize-observer-polyfill": "^1.5.1",
		"signal-exit": "^3.0.7",
		"slate-hyperscript": "^0.77.0",
		tsx: "^4.8.2",
		typescript: "^5.5.3",
	},
	peerDependencies: { react: "^18.2.0", "react-dom": "^18.2.0" },
	preconstruct: {
		entrypoints: [
			"index.ts",
			"api/generic.ts",
			"api/utils.ts",
			"reader/index.ts",
			"reader/github.ts",
			"renderer.tsx",
			"ui.tsx",
			"component-blocks/index.tsx",
			"content-components.ts",
		],
	},
	"ts-gql": {
		schema: "./github.graphql",
		mode: "no-transform",
		addTypename: !1,
		scalars: { GitObjectID: "string" },
	},
	imports: {
		"#react-cache-in-react-server": {
			"react-server": "./src/reader/react-server-cache.ts",
			default: "./src/reader/noop-cache.ts",
		},
		"#sha1": {
			node: "./src/sha1/node.ts",
			default: "./src/sha1/webcrypto.ts",
		},
		"#webcrypto": {
			node: "./src/api/webcrypto/node.ts",
			default: "./src/api/webcrypto/default.ts",
		},
		"#api-handler": {
			node: "./src/api/api-node.ts",
			default: "./src/api/api-noop.ts",
		},
		"#ui": {
			node: "./src/app/ui-empty.tsx",
			worker: "./src/app/ui-empty.tsx",
			"react-server": "./src/app/ui-empty.tsx",
			default: "./src/app/ui.tsx",
		},
		"#field-ui/*": {
			node: "./src/form/fields/empty-field-ui.tsx",
			worker: "./src/form/fields/empty-field-ui.tsx",
			"react-server": "./src/form/fields/empty-field-ui.tsx",
			default: "./src/form/fields/*/ui.tsx",
		},
		"#component-block-primitives": {
			node: "./src/form/fields/document/DocumentEditor/primitives/blank-for-react-server.tsx",
			worker: "./src/form/fields/document/DocumentEditor/primitives/blank-for-react-server.tsx",
			"react-server":
				"./src/form/fields/document/DocumentEditor/primitives/blank-for-react-server.tsx",
			default:
				"./src/form/fields/document/DocumentEditor/primitives/index.tsx",
		},
		"#cloud-image-preview": {
			node: "./src/component-blocks/blank-for-react-server.tsx",
			worker: "./src/component-blocks/blank-for-react-server.tsx",
			"react-server": "./src/component-blocks/blank-for-react-server.tsx",
			default: "./src/component-blocks/cloud-image-preview.tsx",
		},
		"#markdoc": "./src/markdoc.js",
		"#base64": "./src/base64.ts",
		"#react-compiler-runtime": "./src/react-compiler-runtime.ts",
	},
};
function Ir(t, e) {
	return { ...e, kind: "object", fields: t };
}
const mye = {
	seconds: 60,
	minutes: 60,
	hours: 24,
	days: 7,
	weeks: 4,
	months: 12,
	years: 1 / 0,
};
function gye(t, e, n) {
	let r = (t.getTime() - e.getTime()) / 1e3;
	for (const [i, o] of Object.entries(mye)) {
		if (Math.abs(r) < o) return n.format(Math.round(r), i);
		r /= o;
	}
	return "unknown";
}
function bye(t) {
	const e = ee(10),
		{ locale: n } = Vt();
	let r;
	e[0] === Symbol.for("react.memo_cache_sentinel")
		? ((r = () => new Date()), (e[0] = r))
		: (r = e[0]);
	const [i] = E.useState(r);
	let o, s;
	if (e[1] !== n || e[2] !== t.date || e[3] !== i) {
		const c = new Intl.RelativeTimeFormat(n);
		c.format(t.date.getTime() - i.getTime(), "second"),
			(s = gye(t.date, i, c)),
			(e[1] = n),
			(e[2] = t.date),
			(e[3] = i),
			(e[4] = s);
	} else s = e[4];
	o = s;
	const a = o;
	let l;
	e[5] !== t.date
		? ((l = t.date.toISOString()), (e[5] = t.date), (e[6] = l))
		: (l = e[6]);
	let u;
	return (
		e[7] !== l || e[8] !== a
			? ((u = m.jsx("time", { dateTime: l, children: a })),
				(e[7] = l),
				(e[8] = a),
				(e[9] = u))
			: (u = e[9]),
		u
	);
}
function vye(t, e) {
	il.info(
		m.jsxs(ue, {
			children: [
				"Restored draft from ",
				m.jsx(bye, { date: t }),
				".",
				" ",
				e &&
					m.jsx(ue, {
						color: "accent",
						children:
							"Other changes have been made to this entry since the draft. You may want to discard the draft changes.",
					}),
			],
		}),
		{ timeout: 8e3 },
	);
}
let Wk;
function v3() {
	return Wk || (Wk = p3("keystatic", "items")), Wk;
}
function a5(t, e) {
	return wU(t, e, v3());
}
function l5(t) {
	return Uve(t, v3());
}
function u5(t) {
	return CU(t, v3());
}
async function yye() {
	await C2(v3());
}
function zU(t, e) {
	return t.collections[e];
}
function c5(t) {
	return t.storage.kind !== "local" ? t.storage.branchPrefix : void 0;
}
function va(t) {
	return t.storage.kind === "github";
}
function cp(t) {
	return t.storage.kind === "local";
}
function B2(t) {
	var e;
	if (t.storage.kind !== "cloud") return !1;
	if (
		!((e = t.cloud) !== null && e !== void 0 && e.project) ||
		!t.cloud.project.includes("/")
	)
		throw new Error(
			"Keystatic is set to `storage: { kind: 'cloud' }` but `cloud.project` isn't set.\nconfig({\n  storage: { kind: 'cloud' },\n  cloud: { project: 'team/project' },\n})",
		);
	return !0;
}
function xye(t) {
	var e;
	if (!((e = t.cloud) !== null && e !== void 0 && e.project)) return;
	const [n, r] = t.cloud.project.split("/");
	return { team: n, project: r };
}
function kye(t) {
	return `${t.owner}/${t.name}`;
}
function Cg(t) {
	return `https://github.com/${kye(t)}`;
}
function tr(t, e) {
	const n = e[t.slugField],
		r = t.schema[t.slugField];
	if (r.kind !== "form" || r.formKind !== "slug")
		throw new Error("slugField is not a slug field");
	return r.serializeWithSlug(n).slug;
}
function wg(t, e, n) {
	var r, i;
	const o = t.collections[e],
		s = Ir(o.schema),
		a = qo(t, e),
		l = N0(a),
		u = i5(t, e),
		c = r5(t, e),
		d =
			(r =
				(i = al(n, c)) === null || i === void 0
					? void 0
					: i.children) !== null && r !== void 0
				? r
				: new Map(),
		f = [],
		h = [...b3(s)],
		p = FU(t, e),
		g = new Map(d);
	if (u === "**") {
		const b = (y, x) => {
			for (const [C, k] of y)
				k.children
					? (g.set(`${x}${C}`, k), b(k.children, `${x}${C}/`))
					: g.set(`${x}${C}`, k);
		};
		b(d, "");
	}
	for (const [b, y] of g)
		if (a.dataLocation === "index") {
			var v;
			const x = al(n, Ni(t, e, b));
			if (
				!(
					x != null &&
					(v = x.children) !== null &&
					v !== void 0 &&
					v.has("index" + l)
				)
			)
				continue;
			f.push({
				key: Am([x.entry.path, ...h.map((C) => `${C}/${b}`)], n),
				slug: b,
				sha: x.children.get("index" + l).entry.sha,
			});
		} else {
			if (p) {
				const C = al(n, Ni(t, e, b) + l);
				if (!C || C.children) continue;
				f.push({
					key: Am(
						[
							y.entry.path,
							Ni(t, e, b),
							...h.map((k) => `${k}/${b}`),
						],
						n,
					),
					slug: b,
					sha: C.entry.sha,
				});
			}
			if (y.children || !b.endsWith(l)) continue;
			const x = b.slice(0, -l.length);
			f.push({
				key: Am(
					[y.entry.path, Ni(t, e, x), ...h.map((C) => `${C}/${x}`)],
					n,
				),
				slug: x,
				sha: y.entry.sha,
			});
		}
	return f;
}
const Rl = "https://api.keystatic.cloud",
	LU = _U.version,
	ic = { "x-keystatic-version": LU },
	Cye = new TextEncoder();
async function O0(t, e) {
	var n;
	if (!((n = e.cloud) !== null && n !== void 0 && n.project))
		throw new Error("Not a cloud config");
	const r = nd(crypto.getRandomValues(new Uint8Array(32))),
		i = nd(
			new Uint8Array(
				await crypto.subtle.digest("SHA-256", Cye.encode(r)),
			),
		),
		o = nd(crypto.getRandomValues(new Uint8Array(32)));
	localStorage.setItem(
		"keystatic-cloud-state",
		JSON.stringify({ state: o, from: t, code_verifier: r }),
	);
	const s = new URL(`${Rl}/oauth/authorize`);
	s.searchParams.set("state", o),
		s.searchParams.set("client_id", e.cloud.project),
		s.searchParams.set(
			"redirect_uri",
			`${window.location.origin}/keystatic/cloud/oauth/callback`,
		),
		s.searchParams.set("response_type", "code"),
		s.searchParams.set("code_challenge_method", "S256"),
		s.searchParams.set("code_challenge", i),
		s.searchParams.set("keystatic_version", _U.version),
		(window.location.href = s.toString());
}
function d5(t, e, n) {
	const r = ee(8);
	let i;
	r[0] !== t || r[1] !== e || r[2] !== n
		? ((i = () => {
				t && e === t.state && vye(t.savedAt, n !== t.treeKey);
			}),
			(r[0] = t),
			(r[1] = e),
			(r[2] = n),
			(r[3] = i))
		: (i = r[3]);
	const o = Pt(i);
	let s, a;
	r[4] !== t || r[5] !== o
		? ((s = () => {
				t && o();
			}),
			(a = [t, o]),
			(r[4] = t),
			(r[5] = o),
			(r[6] = s),
			(r[7] = a))
		: ((s = r[6]), (a = r[7])),
		E.useEffect(s, a);
}
const wye = Xx({
	token: jt(),
	project: jt(),
	validUntil: Mz(Yx(), $h(), (t) => new Date(t)),
});
function I2(t) {
	if (typeof document > "u") return null;
	if (t.storage.kind === "github") {
		const n = QK(document.cookie)["keystatic-gh-access-token"];
		return n ? { accessToken: n } : null;
	}
	return t.storage.kind === "cloud" ? M0(t) : null;
}
function M0(t) {
	var e;
	if (!((e = t.cloud) !== null && e !== void 0 && e.project)) return null;
	const n = localStorage.getItem("keystatic-cloud-access-token");
	let r;
	try {
		r = wye.create(JSON.parse(n));
	} catch {
		return null;
	}
	return !r || r.validUntil < new Date() || r.project !== t.cloud.project
		? null
		: { accessToken: r.token };
}
let V1;
async function $d(t) {
	const e = I2(t);
	return t.storage.kind === "github" && !e
		? (V1 ||
				(V1 = (async () => {
					try {
						if (
							(
								await fetch(
									"/api/keystatic/github/refresh-token",
									{ method: "POST" },
								)
							).status === 200
						) {
							const i = QK(document.cookie)[
								"keystatic-gh-access-token"
							];
							if (i) return { accessToken: i };
						}
					} catch {
					} finally {
						V1 = void 0;
					}
					return null;
				})()),
			V1)
		: e;
}
const Eye = yr`
  fragment SidebarFooter_viewer on User {
    id
    name
    login
    avatarUrl
    databaseId
  }
`,
	VU = E.createContext(void 0);
function KU() {
	return E.useContext(VU);
}
function j0(t) {
	if (typeof t == "string") {
		const [e, n] = t.split("/");
		return { owner: e, name: n };
	}
	return t;
}
function Td(t) {
	return typeof t == "string" ? t : `${t.owner}/${t.name}`;
}
function Dye(t) {
	if (typeof t == "string" && !t.includes("/"))
		throw new Error(
			`Invalid repo config: ${t}. It must be in the form owner/name`,
		);
	if (typeof t == "object") {
		if (!t.owner && !t.name)
			throw new Error("Invalid repo config: owner and name are missing");
		if (!t.owner) throw new Error("Invalid repo config: owner is missing");
		if (!t.name) throw new Error("Invalid repo config: name is missing");
	}
}
function F2(t, e) {
	const n = Ju(e.storage);
	if (!n) return t;
	const r = [];
	for (const i of t.entries.values())
		i.path.startsWith(n) && r.push({ ...i, path: i.path.slice(n.length) });
	return { entries: new Map(r.map((i) => [i.path, i])), tree: s5(r) };
}
let qk;
function y3() {
	return qk || (qk = p3("keystatic-trees", "trees")), qk;
}
let Gk;
function Eg() {
	return Gk || (Gk = p3("keystatic-blobs", "blobs")), Gk;
}
function UU(t, e) {
	return wU(t, e, Eg());
}
async function Sye(t) {
	const e = await CU(t, Eg());
	if (e instanceof Uint8Array) return e;
}
let Sb;
const HU = eme(Xx({ path: jt(), mode: jt(), sha: jt() }));
function WU() {
	if (Sb) return Sb;
	const t = new Map();
	return Wve(y3()).then((e) => {
		for (const [n, r] of e) {
			if (typeof n != "string") continue;
			let i;
			try {
				i = HU.create(r);
			} catch {
				continue;
			}
			t.set(n, i);
		}
		return (Sb = t), t;
	});
}
function P2(t, e, n = "") {
	const r = new Map(),
		i = e.get(t);
	if (i) {
		for (const o of i) {
			const s = (n === "" ? "" : n + "/") + o.path;
			if (o.mode === "040000") {
				const a = P2(o.sha, e, s);
				if (a) {
					r.set(o.path, a);
					continue;
				}
				return;
			}
			r.set(o.path, {
				entry: {
					mode: o.mode,
					path: s,
					sha: o.sha,
					type: o.mode === "120000" ? "symlink" : "blob",
				},
			});
		}
		return {
			entry: { mode: "040000", path: n, sha: t, type: "tree" },
			children: r,
		};
	}
}
function Aye(t) {
	const e = WU();
	return e instanceof Map ? P2(t, e) : e.then((n) => P2(t, n));
}
async function $ye(t) {
	const e = new Map(),
		n = [];
	for (const [l, u] of await WU()) {
		if (typeof l != "string") {
			n.push(l);
			continue;
		}
		let c;
		try {
			c = HU.create(u);
		} catch {
			n.push(l);
			continue;
		}
		e.set(l, c);
	}
	const r = await Hve(Eg()),
		i = new Set(r),
		o = new Set(t);
	for (const l of o) {
		if (i.has(l)) {
			i.delete(l);
			continue;
		}
		const u = e.get(l);
		if (u) {
			for (const c of u) o.add(c.sha);
			e.delete(l);
			continue;
		}
	}
	const s = [...e.keys(), ...n];
	await Promise.all([nI([...i], Eg()), nI([...e.keys(), ...n], y3())]);
	for (const l of s) {
		var a;
		(a = Sb) === null || a === void 0 || a.delete(l);
	}
}
function Tye(t, e) {
	const n = [];
	return qU(t, e, n), Kve(n, y3());
}
function qU(t, e, n) {
	const r = [];
	for (const [i, o] of e)
		r.push({
			path: i.replace(/.*\//, ""),
			mode: o.entry.mode,
			sha: o.entry.sha,
		}),
			o.children && qU(o.entry.sha, o.children, n);
	n.push([t, r]);
}
async function Bye() {
	await Promise.all([C2(Eg()), C2(y3())]);
}
const su = 0,
	GU = 3,
	Kf = 1,
	N2 = 2,
	R2 = 4,
	dp = [];
dp[su] = (t, e, n, r) => {
	Oe(t, su);
	const i = JK(e, t, n.doc, n);
	r && i === o3 && !n.synced && (n.synced = !0);
};
dp[GU] = (t, e, n) => {
	Oe(t, Kf),
		Fn(t, nm(n.awareness, Array.from(n.awareness.getStates().keys())));
};
dp[Kf] = (t, e, n) => {
	N1e(n.awareness, ur(e), n);
};
dp[N2] = (t, e, n) => {
	sbe(e, n.doc, Pye);
};
dp[R2] = (t, e, n, r) => {
	const i = Es(e);
	Oe(t, su);
	const o = n.getSubDoc(i);
	if (o) {
		const s = JK(e, t, o, n);
		r && s === o3 && o.emit("sync", [!0]);
	}
};
const Iye = 1200,
	Fye = 2500,
	cI = 3e4,
	Pye = (t, e) =>
		console.warn(`Permission denied to access ${t.url}.
${e}`),
	O2 = (t, e, n) => {
		const r = Vi(e),
			i = In(),
			o = nt(r),
			s = dp[o];
		return (
			s ? s(i, r, t, n, o) : console.error("Unable to compute message"), i
		);
	},
	YU = (t, e) => {
		if (t.shouldConnect && t.ws === null) {
			const n = new e(t.url);
			(n.binaryType = "arraybuffer"),
				(t.ws = n),
				(t.wsconnecting = !0),
				(t.wsconnected = !1),
				(t.synced = !1);
			let r = { kind: "authenticating", queue: [] };
			(n.onmessage = (i) => {
				t.wsLastMessageReceived = Hu();
				const o = new Uint8Array(i.data);
				if (r.kind === "authenticating") {
					const s = Vi(o);
					if (cg(s) === N2 && cg(s) === 2) {
						const u = r.queue;
						(r = { kind: "authed" }), t.onConnect(n);
						for (const c of u) {
							const d = O2(t, c, !0);
							qv(d) > 1 && n.send(Kt(d));
						}
						return;
					}
					r.queue.push(o);
				} else {
					const s = O2(t, o, !0);
					qv(s) > 1 && n.send(Kt(s));
				}
			}),
				(n.onclose = () => {
					(t.ws = null),
						(t.wsconnecting = !1),
						t.wsconnected
							? ((t.wsconnected = !1),
								(t.synced = !1),
								GS(
									t.awareness,
									Array.from(
										t.awareness.getStates().keys(),
									).filter((i) => i !== t.doc.clientID),
									t,
								),
								t.onStatus({ status: "disconnected" }))
							: t.wsUnsuccessfulReconnects++,
						setTimeout(
							YU,
							Su(Hme(t.wsUnsuccessfulReconnects + 1) * Iye, Fye),
							t,
						);
				}),
				(n.onopen = async () => {
					t.wsLastMessageReceived = Hu();
					const i = In();
					Oe(i, N2),
						Oe(i, 0),
						aa(i, await t.authToken()),
						n.send(Kt(i));
				}),
				t.onStatus({ status: "connecting" });
		}
	},
	K1 = (t, e) => {
		if (t.ws && t.wsconnected) {
			var n;
			(n = t.ws) === null || n === void 0 || n.send(e);
		}
		t.bcconnected &&
			t.mux(() => {
				Tf(t.bcChannel, e);
			});
	};
var Yg, Kc, Uc, Jg, Xg, Zg, Qg, e0, t0;
class Nye {
	constructor(e) {
		qe(this, Yg);
		qe(this, Kc);
		qe(this, Uc);
		qe(this, Jg);
		qe(this, Xg, (e) => {
			this.mux(() => {
				const n = O2(this, new Uint8Array(e), !1);
				qv(n) > 1 && Tf(this.bcChannel, Kt(n));
			});
		});
		qe(this, Zg, () => {
			GS(this.awareness, [this.doc.clientID], "window unload");
		});
		Fe(this, "waitForConnection", (e, n) => {
			const r = this.ws;
			(r == null ? void 0 : r.readyState) === 1
				? e(r)
				: setTimeout(() => {
						this.waitForConnection(e, n);
					}, n);
		});
		qe(this, Qg, ({ added: e, updated: n, removed: r }) => {
			const i = e.concat(n).concat(r),
				o = In();
			Oe(o, Kf), Fn(o, nm(this.awareness, i)), K1(this, Kt(o));
		});
		Fe(this, "send", (e, n) => {
			this.waitForConnection((r) => {
				r.send(e), typeof n < "u" && n();
			}, 1e3);
		});
		qe(
			this,
			e0,
			ZK((e) => (n) => {
				const r = In();
				Oe(r, R2), aa(r, e.guid), zB(r, n), K1(this, Kt(r));
			}),
		);
		qe(this, t0, (e, n) => {
			if (n !== this) {
				const r = In();
				Oe(r, su), zB(r, e), K1(this, Kt(r));
			}
		});
		var n, r, i;
		(this.bcChannel = e.url),
			(this.url = e.url),
			(this.doc = e.doc),
			Te(
				this,
				Yg,
				(n = e.WebSocketPolyfill) !== null && n !== void 0
					? n
					: WebSocket,
			),
			(this.awareness = e.awareness),
			(this.wsconnected = !1),
			(this.wsconnecting = !1),
			(this.bcconnected = !1),
			(this.wsUnsuccessfulReconnects = 0),
			(this.mux = XK()),
			Te(this, Kc, !1),
			(this.authToken = e.authToken),
			(this.ws = null),
			(this.wsLastMessageReceived = 0),
			(this.onStatus =
				(r = e.onStatus) !== null && r !== void 0 ? r : () => {}),
			(this.onSynced =
				(i = e.onSynced) !== null && i !== void 0 ? i : () => {}),
			(this.shouldConnect = !1),
			(this.subdocs = new Map()),
			Te(this, Uc, null),
			e.resyncInterval !== void 0 &&
				e.resyncInterval > 0 &&
				Te(
					this,
					Uc,
					setInterval(() => {
						if (this.ws) {
							const o = In();
							Oe(o, su), M1(o, e.doc), this.ws.send(Kt(o));
						}
					}, e.resyncInterval),
				),
			this.doc.on("subdocs", ({ added: o, removed: s, loaded: a }) => {
				o.forEach((l) => {
					this.subdocs.set(l.guid, l);
				}),
					s.forEach((l) => {
						l.off("update", z(this, e0).call(this, l)),
							this.subdocs.delete(l.guid);
					}),
					a.forEach((l) => {
						this.waitForConnection(() => {
							const u = In();
							Oe(u, R2),
								aa(u, l.guid),
								M1(u, l),
								this.send(Kt(u), () => {
									l.on("update", z(this, e0).call(this, l));
								});
						}, 1e3);
					});
			}),
			this.doc.on("update", z(this, t0)),
			typeof window < "u" &&
				window.addEventListener("beforeunload", z(this, Zg)),
			e.awareness.on("update", z(this, Qg)),
			Te(
				this,
				Jg,
				setInterval(() => {
					if (
						this.wsconnected &&
						cI < Hu() - this.wsLastMessageReceived
					) {
						var o;
						(o = this.ws) === null || o === void 0 || o.close();
					}
				}, cI / 10),
			);
	}
	onConnect(e) {
		(this.wsconnecting = !1),
			(this.wsconnected = !0),
			(this.wsUnsuccessfulReconnects = 0),
			this.onStatus({ status: "connected" });
		const n = In();
		if (
			(Oe(n, su),
			M1(n, this.doc),
			e.send(Kt(n)),
			this.awareness.getLocalState() !== null)
		) {
			const r = In();
			Oe(r, Kf),
				Fn(r, nm(this.awareness, [this.doc.clientID])),
				e.send(Kt(r));
		}
	}
	get synced() {
		return z(this, Kc);
	}
	getSubDoc(e) {
		return this.subdocs.get(e);
	}
	set synced(e) {
		z(this, Kc) !== e &&
			(Te(this, Kc, e), this.onSynced(e), this.doc.emit("sync", [e]));
	}
	destroy() {
		z(this, Uc) !== null && clearInterval(z(this, Uc)),
			clearInterval(z(this, Jg)),
			this.disconnect(),
			typeof window < "u" &&
				window.removeEventListener("beforeunload", z(this, Zg)),
			this.awareness.off("update", z(this, Qg)),
			this.doc.off("update", z(this, t0));
	}
	connectBc() {
		this.bcconnected ||
			(tbe(this.bcChannel, z(this, Xg)), (this.bcconnected = !0)),
			this.mux(() => {
				const e = In();
				Oe(e, su), M1(e, this.doc), Tf(this.bcChannel, Kt(e));
				const n = In();
				Oe(n, su), GK(n, this.doc), Tf(this.bcChannel, Kt(n));
				const r = In();
				Oe(r, GU), Tf(this.bcChannel, Kt(r));
				const i = In();
				Oe(i, Kf),
					Fn(i, nm(this.awareness, [this.doc.clientID])),
					Tf(this.bcChannel, Kt(i));
			});
	}
	disconnectBc() {
		const e = In();
		Oe(e, Kf),
			Fn(e, nm(this.awareness, [this.doc.clientID], new Map())),
			K1(this, Kt(e)),
			this.bcconnected &&
				(nbe(this.bcChannel, z(this, Xg)), (this.bcconnected = !1));
	}
	disconnect() {
		(this.shouldConnect = !1),
			this.disconnectBc(),
			this.ws !== null && this.ws.close();
	}
	connect() {
		(this.shouldConnect = !0),
			!this.wsconnected &&
				this.ws === null &&
				(YU(this, z(this, Yg)), this.connectBc());
	}
}
(Yg = new WeakMap()),
	(Kc = new WeakMap()),
	(Uc = new WeakMap()),
	(Jg = new WeakMap()),
	(Xg = new WeakMap()),
	(Zg = new WeakMap()),
	(Qg = new WeakMap()),
	(e0 = new WeakMap()),
	(t0 = new WeakMap());
const f5 = E.createContext(null),
	JU = 0,
	XU = 1,
	ZU = 2,
	QU = 4,
	Rye = 5;
function Oye(t) {
	const e = Vi(t);
	switch (nt(e)) {
		case JU:
			return { kind: "sync" };
		case QU:
			return { kind: "sync-subdoc" };
		case XU: {
			const r = ur(e),
				i = [];
			{
				const o = Vi(r),
					s = nt(o);
				for (let a = 0; a < s; a++) {
					const l = nt(o);
					let u = nt(o);
					const c = JSON.parse(Es(o));
					i.push({ clientID: l, clock: u, state: c });
				}
			}
			return { kind: "awareness", states: i };
		}
		case ZU:
			return { kind: "auth" };
	}
}
function Mye(t) {
	const e = Vi(t);
	switch (nt(e)) {
		case JU:
			return { kind: "sync" };
		case QU:
			return { kind: "sync-subdoc" };
		case XU: {
			const r = ur(e),
				i = [];
			{
				const o = Vi(r),
					s = nt(o);
				for (let a = 0; a < s; a++) {
					const l = nt(o);
					let u = nt(o);
					const c = JSON.parse(Es(o));
					i.push({ clientID: l, clock: u, state: c });
				}
			}
			return { kind: "awareness", states: i };
		}
		case ZU:
			return { kind: "auth" };
	}
}
function eH() {
	const t = E.useContext(f5);
	if (!t) throw new Error("CollabProvider not found");
	if (t === "loading") throw new Error("CollabProvider is loading");
	return t;
}
function x3() {
	return E.useContext(f5);
}
const dI = !1,
	Ab = new Map(),
	tH = E.createContext(Ab);
function nH() {
	return E.useContext(tH);
}
const Yk = new WeakMap();
function jye(t) {
	var e;
	const n = En(),
		r = _0(),
		i = (e = t.config.cloud) === null || e === void 0 ? void 0 : e.project,
		o = `ks-multiplayer-${i}`,
		s =
			r === null
				? localStorage.getItem(o) === "true"
				: r.team.multiplayer,
		a = E.useMemo(() => {
			if (!s) return;
			const d = new Ki(),
				f = d.getMap("data"),
				h = new P1e(d),
				p = Z1e(d, `keystatic-2-${i}`),
				g = new Nye({
					doc: d,
					url: `wss://live.keystatic.cloud/${i}?v=${LU}`,
					WebSocketPolyfill: class extends Zve {
						constructor(v) {
							super(v),
								this.addEventListener("message", (b) => {
									b.data instanceof ArrayBuffer &&
										dI &&
										console.log(
											"recv",
											Mye(new Uint8Array(b.data)),
										);
								});
						}
						send(v) {
							v instanceof Uint8Array &&
								dI &&
								console.log("send", Oye(v));
							const b = 1e6;
							if (v instanceof Uint8Array && v.byteLength > b) {
								const y = Math.ceil(v.byteLength / b),
									x = In();
								Oe(x, Rye), Oe(x, y), super.send(Kt(x));
								for (let C = 0; C < y; C++) {
									const k = C * b,
										w = Math.min((C + 1) * b, v.byteLength);
									super.send(v.slice(k, w));
								}
								return;
							}
							super.send(v);
						}
					},
					awareness: h,
					authToken: async () =>
						$d(t.config).then((v) => {
							var b;
							return (b = v == null ? void 0 : v.accessToken) !==
								null && b !== void 0
								? b
								: "";
						}),
				});
			return { doc: d, awareness: h, provider: g, data: f, idb: p };
		}, [s, i, t.config]),
		l = Xr();
	E.useEffect(() => {
		a == null || a.awareness.setLocalStateField("branch", l),
			a == null ||
				a.awareness.setLocalStateField(
					"location",
					n.params.slice(2).join("/"),
				);
	}, [l, n.params, a == null ? void 0 : a.awareness]);
	const u = !!l;
	E.useEffect(() => {
		if (u && a) {
			a.idb.connect();
			let d = !1;
			const f = a.idb.subscribeStatusChange(() => {
				(a.idb.status.type === "synced" ||
					a.idb.status.type === "error") &&
					(f(), a.provider.connect(), (d = !0));
			});
			return () => {
				a.idb.disconnect(), d ? a.provider.disconnect() : f();
			};
		}
	}, [a, u]),
		E.useEffect(() => {
			if (r === null) return;
			const d = `ks-multiplayer-${i}`;
			r.team.multiplayer
				? localStorage.setItem(d, "true")
				: localStorage.removeItem(d);
		}, [r, i]);
	const c = E.useSyncExternalStore(
		E.useCallback(
			(d) => {
				const f = a == null ? void 0 : a.awareness;
				if (!f) return () => {};
				const h = () => {
					Yk.set(f, new Map(f.getStates())), d();
				};
				return (
					f.on("change", h),
					() => {
						Yk.set(f, new Map(f.getStates())), f.off("change", h);
					}
				);
			},
			[a],
		),
		() => {
			var d;
			return a != null &&
				a.awareness &&
				(d = Yk.get(a.awareness)) !== null &&
				d !== void 0
				? d
				: Ab;
		},
	);
	return m.jsx(tH.Provider, {
		value: c ?? Ab,
		children: m.jsx(f5.Provider, {
			value: a === void 0 ? (r === void 0 ? "loading" : null) : a,
			children: t.children,
		}),
	});
}
function _ye(t) {
	const e = ee(4);
	let n;
	e[0] === Symbol.for("react.memo_cache_sentinel")
		? ((n = m.jsx(ke, {
				justifyContent: "center",
				children: m.jsx(Ut, { children: "Git repo not initialised" }),
			})),
			(e[0] = n))
		: (n = e[0]);
	const r = `https://github.com/${t.repo}`;
	let i;
	return (
		e[1] !== r || e[2] !== t.repo
			? ((i = m.jsx(ke, {
					alignItems: "center",
					justifyContent: "center",
					margin: "xxlarge",
					children: m.jsxs(ke, {
						backgroundColor: "surface",
						padding: "large",
						border: "color.alias.borderIdle",
						borderRadius: "medium",
						direction: "column",
						justifyContent: "center",
						gap: "xlarge",
						maxWidth: "scale.4600",
						children: [
							n,
							m.jsxs(ue, {
								children: [
									"The Keystatic GitHub App is installed in the GitHub repository",
									" ",
									m.jsx(xh, { href: r, children: t.repo }),
									" ",
									"but the Git repo is not initialised. Please initialise the Git repo before using Keystatic.",
								],
							}),
						],
					}),
				})),
				(e[1] = r),
				(e[2] = t.repo),
				(e[3] = i))
			: (i = e[3]),
		i
	);
}
function zye(t) {
	if (yu.has(t)) return yu.get(t);
	const e = fetch("/api/keystatic/tree", { headers: { "no-cors": "1" } })
		.then((n) => n.json())
		.then(async (n) => Oh(n));
	return yu.set(t, e), e;
}
function rH() {
	return E.useContext(iH);
}
const iH = E.createContext(() => {
	throw new Error("SetTreeShaContext not set");
});
function Lye(t) {
	const [e, n] = E.useState("initial"),
		r = bo(E.useCallback(() => zye(e), [e])),
		i = E.useMemo(
			() => ({
				unscopedDefault: r,
				scoped: {
					default: r,
					current: r,
					merged: MU({ default: r, current: r }),
				},
			}),
			[r],
		),
		o = E.useMemo(
			() =>
				i.scoped.merged.kind !== "loaded"
					? { collections: new Map(), singletons: new Set() }
					: fH(t.config, i.scoped.merged.data),
			[i, t.config],
		);
	return m.jsx(iH.Provider, {
		value: n,
		children: m.jsx(p5.Provider, {
			value: o,
			children: m.jsx(C3.Provider, { value: i, children: t.children }),
		}),
	});
}
const Vye = sa({
		user: sa({ id: jt(), name: jt(), email: jt(), avatarUrl: CS(jt()) }),
		project: sa({ name: jt() }),
		team: Xx({ name: jt(), slug: jt(), images: nB(), multiplayer: nB() }),
	}),
	h5 = E.createContext(null);
function _0() {
	const t = E.useContext(h5);
	return t === "unauthorized" ? null : t;
}
function Kye() {
	return E.useContext(h5);
}
function Uye(t) {
	const e = bo(
		E.useCallback(async () => {
			var n, r;
			if (!((n = t.config.cloud) !== null && n !== void 0 && n.project))
				throw new Error("no cloud project set");
			const i =
				(r = M0(t.config)) === null || r === void 0
					? void 0
					: r.accessToken;
			if (!i) return "unauthorized";
			const o = await fetch(`${Rl}/v1/info`, {
				headers: { ...ic, Authorization: `Bearer ${i}` },
			});
			return o.status === 401
				? "unauthorized"
				: Vye.create(await o.json());
		}, [t.config]),
	);
	return m.jsx(h5.Provider, {
		value: e.kind === "loaded" ? e.data : null,
		children: t.children,
	});
}
const k3 = E.createContext(null);
function Hye(t) {
	var e, n, r, i;
	const o =
			t.config.storage.kind === "github"
				? j0(t.config.storage.repo)
				: { name: "repo-name", owner: "repo-owner" },
		[s] = x2({
			query: t.config.storage.kind === "github" ? hy : M2,
			variables: o,
		}),
		[a, l] = E.useState(null),
		[u] = x2({
			query: yr`
      query FetchMoreRefs($owner: String!, $name: String!, $after: String) {
        repository(owner: $owner, name: $name) {
          __typename
          id
          refs(refPrefix: "refs/heads/", first: 100, after: $after) {
            __typename
            nodes {
              ...Ref_base
            }
            pageInfo {
              hasNextPage
              endCursor
            }
          }
        }
      }
      ${m5}
    `,
			pause: !(
				(e = s.data) !== null &&
				e !== void 0 &&
				(e = e.repository) !== null &&
				e !== void 0 &&
				(e = e.refs) !== null &&
				e !== void 0 &&
				e.pageInfo.hasNextPage
			),
			variables: {
				...o,
				after:
					a ??
					((n = s.data) === null ||
					n === void 0 ||
					(n = n.repository) === null ||
					n === void 0 ||
					(n = n.refs) === null ||
					n === void 0
						? void 0
						: n.pageInfo.endCursor),
			},
		}),
		c =
			(r = u.data) === null ||
			r === void 0 ||
			(r = r.repository) === null ||
			r === void 0 ||
			(r = r.refs) === null ||
			r === void 0
				? void 0
				: r.pageInfo;
	return (
		c != null &&
			c.hasNextPage &&
			c.endCursor !== a &&
			c.endCursor &&
			l(c.endCursor),
		(i = s.data) !== null &&
		i !== void 0 &&
		(i = i.repository) !== null &&
		i !== void 0 &&
		i.owner &&
		!s.data.repository.defaultBranchRef &&
		!s.fetching &&
		!s.error
			? m.jsx(_ye, {
					repo: `${s.data.repository.owner.login}/${s.data.repository.name}`,
				})
			: m.jsx(k3.Provider, {
					value: s,
					children: m.jsx(VU.Provider, {
						value:
							s.data && "viewer" in s.data
								? s.data.viewer
								: void 0,
						children: t.children,
					}),
				})
	);
}
const fI = new Set(["WRITE", "ADMIN", "MAINTAIN"]);
function Wye(t) {
	var e, n, r, i, o, s, a, l, u, c, d, f, h;
	const p = En(),
		{ data: g, error: v } = E.useContext(k3);
	let b = g == null ? void 0 : g.repository;
	if (
		b &&
		"viewerPermission" in b &&
		b.viewerPermission &&
		!fI.has(b.viewerPermission) &&
		"forks" in b
	) {
		var y, x;
		b =
			(y =
				(x = b.forks) === null ||
				x === void 0 ||
				(x = x.nodes) === null ||
				x === void 0
					? void 0
					: x[0]) !== null && y !== void 0
				? y
				: b;
	}
	const C =
			(e = b) === null ||
			e === void 0 ||
			(e = e.refs) === null ||
			e === void 0 ||
			(e = e.nodes) === null ||
			e === void 0
				? void 0
				: e.find((O) => {
						var _;
						return (
							(O == null ? void 0 : O.name) ===
							((_ = b) === null ||
							_ === void 0 ||
							(_ = _.defaultBranchRef) === null ||
							_ === void 0
								? void 0
								: _.name)
						);
					}),
		k =
			(n = b) === null ||
			n === void 0 ||
			(n = n.refs) === null ||
			n === void 0 ||
			(n = n.nodes) === null ||
			n === void 0
				? void 0
				: n.find(
						(O) =>
							(O == null ? void 0 : O.name) === t.currentBranch,
					);
	E.useEffect(() => {
		var O;
		(O = b) !== null &&
			O !== void 0 &&
			(O = O.refs) !== null &&
			O !== void 0 &&
			O.nodes &&
			$ye(
				b.refs.nodes
					.map((_) => {
						var j;
						return (_ == null ||
						(j = _.target) === null ||
						j === void 0
							? void 0
							: j.__typename) === "Commit"
							? _.target.tree.oid
							: void 0;
					})
					.filter(ine),
			);
	}, [(r = b) === null || r === void 0 ? void 0 : r.id]);
	const w =
			(i = C == null ? void 0 : C.target.tree.oid) !== null &&
			i !== void 0
				? i
				: null,
		D =
			(o = k == null ? void 0 : k.target.tree.oid) !== null &&
			o !== void 0
				? o
				: null,
		S = hI(w, t.config),
		$ = hI(D, t.config),
		A = E.useMemo(() => {
			const O = uI(S, (j) => F2(j, t.config)),
				_ = uI($, (j) => F2(j, t.config));
			return {
				unscopedDefault: $,
				scoped: {
					default: O,
					current: _,
					merged: MU({ default: O, current: _ }),
				},
			};
		}, [$, S, t.config]),
		T = E.useMemo(
			() =>
				A.scoped.merged.kind !== "loaded"
					? { collections: new Map(), singletons: new Set() }
					: fH(t.config, A.scoped.merged.data),
			[A, t.config],
		);
	E.useEffect(() => {
		var O, _;
		(v == null || (O = v.response) === null || O === void 0
			? void 0
			: O.status) === 401 &&
			(va(t.config)
				? (window.location.href = `/api/keystatic/github/login?from=${p.params.map(encodeURIComponent).join("/")}`)
				: O0(p.params.map(encodeURIComponent).join("/"), t.config)),
			!((_ = b) !== null && _ !== void 0 && _.id) &&
				v !== null &&
				v !== void 0 &&
				v.graphQLErrors.some((j) => {
					var V, K;
					return (
						(j == null ||
						(V = j.originalError) === null ||
						V === void 0
							? void 0
							: V.type) === "NOT_FOUND" ||
						(j == null ||
						(K = j.originalError) === null ||
						K === void 0
							? void 0
							: K.type) === "FORBIDDEN"
					);
				}) &&
				(window.location.href = `/api/keystatic/github/repo-not-found?from=${p.params.map(encodeURIComponent).join("/")}`);
	}, [v, p, (s = b) === null || s === void 0 ? void 0 : s.id, t.config]);
	const I = E.useMemo(() => {
			var O;
			return new Map(
				(O = b) === null ||
				O === void 0 ||
				(O = O.refs) === null ||
				O === void 0 ||
				(O = O.nodes) === null ||
				O === void 0
					? void 0
					: O.flatMap((_) => {
							var j;
							return (_ == null ||
							(j = _.target) === null ||
							j === void 0
								? void 0
								: j.__typename) !== "Commit"
								? []
								: [
										[
											_.name,
											{
												id: _.id,
												commitSha: _.target.oid,
												treeSha: _.target.tree.oid,
											},
										],
									];
						}),
			);
		}, [
			(a = b) === null ||
			a === void 0 ||
			(a = a.refs) === null ||
			a === void 0
				? void 0
				: a.nodes,
		]),
		F =
			!!b &&
			(t.config.storage.kind === "cloud" ||
				("viewerPermission" in b &&
					!!(
						(l = b) !== null &&
						l !== void 0 &&
						l.viewerPermission
					) &&
					fI.has(b.viewerPermission))),
		N = E.useMemo(() => {
			var O;
			return !(g != null && g.repository) ||
				!(
					(O = b) !== null &&
					O !== void 0 &&
					(O = O.defaultBranchRef) !== null &&
					O !== void 0 &&
					O.name
				)
				? null
				: {
						id: b.id,
						defaultBranch: b.defaultBranchRef.name,
						hasWritePermission: F,
						isPrivate: b.isPrivate,
						name: b.name,
						owner: b.owner.login,
						upstream: { name: b.name, owner: b.owner.login },
					};
		}, [
			g == null ? void 0 : g.repository,
			F,
			(u = b) === null ||
			u === void 0 ||
			(u = u.defaultBranchRef) === null ||
			u === void 0
				? void 0
				: u.name,
			(c = b) === null || c === void 0 ? void 0 : c.id,
			(d = b) === null || d === void 0 ? void 0 : d.isPrivate,
			(f = b) === null || f === void 0 ? void 0 : f.name,
			(h = b) === null || h === void 0 ? void 0 : h.owner.login,
		]);
	return m.jsx(oH.Provider, {
		value: v,
		children: m.jsx(sH.Provider, {
			value: t.currentBranch,
			children: m.jsx(aH.Provider, {
				value: I,
				children: m.jsx(lH.Provider, {
					value: N,
					children: m.jsx(p5.Provider, {
						value: T,
						children: m.jsx(C3.Provider, {
							value: A,
							children:
								t.config.storage.kind === "cloud"
									? m.jsx(jye, {
											config: t.config,
											children: t.children,
										})
									: t.children,
						}),
					}),
				}),
			}),
		}),
	});
}
const oH = E.createContext(void 0),
	sH = E.createContext("");
function Xr() {
	return E.useContext(sH);
}
const aH = E.createContext(new Map());
function fp() {
	return E.useContext(aH);
}
const lH = E.createContext(null);
function Qo() {
	return E.useContext(lH);
}
const p5 = E.createContext({ collections: new Map(), singletons: new Set() }),
	C3 = E.createContext({
		unscopedDefault: { kind: "loading", promise: zo },
		scoped: {
			current: { kind: "loading", promise: zo },
			default: { kind: "loading", promise: zo },
			merged: { kind: "loading", promise: zo },
		},
	});
function w3() {
	return E.useContext(C3).scoped;
}
function uH() {
	return E.useContext(C3).unscopedDefault;
}
function qye() {
	return E.useContext(p5);
}
function Qd() {
	var t, e;
	const n = fp(),
		r = Xr();
	return (t =
		(e = n.get(r)) === null || e === void 0 ? void 0 : e.commitSha) !==
		null && t !== void 0
		? t
		: "";
}
const m5 = yr`
  fragment Ref_base on Ref {
    id
    name
    target {
      __typename
      id
      oid
      ... on Commit {
        tree {
          id
          oid
        }
      }
    }
  }
`,
	cH = yr`
  fragment Repo_base on Repository {
    id
    isPrivate
    owner {
      id
      login
    }
    name
    defaultBranchRef {
      id
      name
    }
    refs(refPrefix: "refs/heads/", first: 100) {
      nodes {
        ...Ref_base
      }
      pageInfo {
        hasNextPage
        endCursor
      }
    }
  }
  ${m5}
`,
	M2 = yr`
  query CloudAppShell($name: String!, $owner: String!) {
    repository(owner: $owner, name: $name) {
      id
      ...Repo_base
    }
  }
  ${cH}
`,
	Gye = yr`
  fragment Repo_ghDirect on Repository {
    id
    ...Repo_base
    viewerPermission
  }
  ${cH}
`,
	Yye = yr`
  fragment Repo_primary on Repository {
    id
    ...Repo_ghDirect
    forks(affiliations: [OWNER], first: 1) {
      nodes {
        ...Repo_ghDirect
      }
    }
  }
  ${Gye}
`,
	hy = yr`
  query GitHubAppShell($name: String!, $owner: String!) {
    repository(owner: $owner, name: $name) {
      id
      ...Repo_primary
    }
    viewer {
      ...SidebarFooter_viewer
    }
  }
  ${Yye}
  ${Eye}
`,
	yu = new dy({ max: 40 });
async function Oh(t) {
	const e = { entries: new Map(t.map((r) => [r.path, r])), tree: s5(t) },
		n = await R0(e.tree);
	return yu.set(n, e), e;
}
function dH(t, e) {
	const n = yu.get(t);
	if (n) return n;
	const r = Aye(t);
	if (r && !(r instanceof Promise)) {
		const o = fy(r.children),
			s = {
				entries: new Map(o.map((a) => [a.path, a])),
				tree: r.children,
			};
		return yu.set(t, s), s;
	}
	const i = (async () => {
		const o = await r;
		if (o) {
			const u = fy(o.children),
				c = {
					entries: new Map(u.map((d) => [d.path, d])),
					tree: o.children,
				};
			return yu.set(t, c), c;
		}
		const s = await $d(e);
		if (!s) throw new Error("Not authorized");
		const { tree: a } = await fetch(
				e.storage.kind === "github"
					? `https://api.github.com/repos/${Td(e.storage.repo)}/git/trees/${t}?recursive=1`
					: `${Rl}/v1/github/trees/${t}`,
				{
					headers: {
						Authorization: `Bearer ${s.accessToken}`,
						...(e.storage.kind === "cloud" ? ic : {}),
					},
				},
			).then((u) => u.json()),
			l = a.map(({ url: u, size: c, ...d }) => d);
		return await Tye(t, s5(l)), Oh(l);
	})();
	return yu.set(t, i), i;
}
function hI(t, e) {
	return bo(E.useCallback(() => (t ? dH(t, e) : zo), [t, e]));
}
function fH(t, e) {
	var n, r;
	return {
		collections: new Map(
			Object.keys(
				(n = t.collections) !== null && n !== void 0 ? n : {},
			).map((i) => {
				const o = new Map(
						wg(t, i, e.current.tree).map((c) => [c.slug, c.key]),
					),
					s = new Map(
						wg(t, i, e.default.tree).map((c) => [c.slug, c.key]),
					),
					a = new Set(),
					l = new Set();
				for (const [c, d] of o) {
					const f = s.get(c);
					if (f === void 0) {
						l.add(c);
						continue;
					}
					d !== f && a.add(c);
				}
				const u = new Set([...s.keys()].filter((c) => !o.has(c)));
				return [
					i,
					{ removed: u, added: l, changed: a, totalCount: o.size },
				];
			}),
		),
		singletons: new Set(
			Object.keys(
				(r = t.singletons) !== null && r !== void 0 ? r : {},
			).filter((i) => {
				var o, s;
				const a = P0(t, i);
				return (
					((o = al(e.current.tree, a)) === null || o === void 0
						? void 0
						: o.entry.sha) !==
					((s = al(e.default.tree, a)) === null || s === void 0
						? void 0
						: s.entry.sha)
				);
			}),
		),
	};
}
const hH = E.createContext(null);
function Jn() {
	const t = E.useContext(hH);
	if (!t) throw new Error("ConfigContext.Provider not found");
	return t;
}
const pH = E.createContext({ basePath: "/keystatic" });
function mH() {
	const t = E.useContext(pH);
	if (!t) throw new Error("AppStateContext.Provider not found");
	return t;
}
const gH = E.createContext("mobile"),
	Jye = gH.Provider;
function g5() {
	return E.useContext(gH);
}
function Xye(t) {
	const e = ["mobile", "tablet", "desktop", "wide"],
		n = g5(),
		r = "above" in t ? e.indexOf(t.above) + 1 : 0,
		i = "below" in t ? e.indexOf(t.below) - 1 : e.length - 1;
	return e.slice(r, i + 1).includes(n);
}
function Zye(t) {
	const e = ee(5),
		[n, r] = E.useState("mobile");
	let i;
	e[0] !== t.current
		? ((i = () => {
				r((a) => {
					const l = t.current;
					return l
						? l.offsetWidth >= Pn.wide
							? "wide"
							: l.offsetWidth >= Pn.desktop
								? "desktop"
								: l.offsetWidth >= Pn.tablet
									? "tablet"
									: "mobile"
						: a;
				});
			}),
			(e[0] = t.current),
			(e[1] = i))
		: (i = e[1]);
	const o = i;
	let s;
	return (
		e[2] !== t || e[3] !== o
			? ((s = { ref: t, onResize: o }),
				(e[2] = t),
				(e[3] = o),
				(e[4] = s))
			: (s = e[4]),
		fa(s),
		n
	);
}
function b5(t) {
	const e = window.getSelection();
	e && (e.removeAllRanges(), e.addRange(te.toDOMRange(t, t.selection))),
		te.focus(t);
}
const E3 = X({
		marginBlock: "0.75em",
		"&:first-child": { marginBlockStart: 0 },
		"&:last-child": { marginBlockEnd: 0 },
	}),
	Qye = le.createContext(!1);
Qye.Provider;
function v5(t, e) {
	const n = ee(9);
	let r;
	n[0] !== e
		? ((r = { element: e, elementWithChanges: e }), (n[0] = e), (n[1] = r))
		: (r = n[1]);
	const [i, o] = E.useState(r);
	i.element !== e && o({ element: e, elementWithChanges: e });
	const s = E.useRef(e);
	let a;
	n[2] !== e
		? ((a = () => {
				s.current = e;
			}),
			(n[2] = e),
			(n[3] = a))
		: (a = n[3]),
		E.useEffect(a);
	let l;
	n[4] !== t
		? ((l = (d) => {
				const f = s.current,
					h = typeof d == "function" ? d(f) : d;
				W.setNodes(t, h, { at: te.findPath(t, f) }),
					o({ element: f, elementWithChanges: { ...f, ...h } });
			}),
			(n[4] = t),
			(n[5] = l))
		: (l = n[5]);
	const u = l;
	let c;
	return (
		n[6] !== i.elementWithChanges || n[7] !== u
			? ((c = [i.elementWithChanges, u]),
				(n[6] = i.elementWithChanges),
				(n[7] = u),
				(n[8] = c))
			: (c = n[8]),
		c
	);
}
function Ri(t) {
	const e = E.useRef(t),
		n = E.useCallback((...r) => e.current(...r), []);
	return (
		E.useEffect(() => {
			e.current = t;
		}),
		n
	);
}
function To(t, e) {
	var n;
	let r;
	const i = R.above(t, {
		match: (s) => s.type === "heading" || s.type === "paragraph",
	});
	i && pe.string(i[0]) === "" && (r = R.pathRef(t, i[1])),
		W.insertNodes(t, e);
	let o = (n = r) === null || n === void 0 ? void 0 : n.unref();
	o && (W.removeNodes(t, { at: o }), te.focus(t));
}
const bH = [
		"paragraph",
		"code",
		"heading",
		"ordered-list",
		"unordered-list",
		"divider",
		"image",
	],
	vH = [...bH, "table"],
	exe = [...vH, "blockquote"],
	Jk = [...exe, "component-block"];
function Ei(t) {
	return {
		kind: "blocks",
		allowedChildren: new Set(t.allowedChildren),
		blockToWrapInlinesIn: t.allowedChildren[0],
		invalidPositionHandleMode: t.invalidPositionHandleMode,
	};
}
function hc(t) {
	return {
		kind: "inlines",
		invalidPositionHandleMode: t.invalidPositionHandleMode,
	};
}
const rd = {
		editor: Ei({
			allowedChildren: [...Jk, "layout"],
			invalidPositionHandleMode: "move",
		}),
		layout: Ei({
			allowedChildren: ["layout-area"],
			invalidPositionHandleMode: "move",
		}),
		"layout-area": Ei({
			allowedChildren: Jk,
			invalidPositionHandleMode: "unwrap",
		}),
		blockquote: Ei({
			allowedChildren: vH,
			invalidPositionHandleMode: "move",
		}),
		paragraph: hc({ invalidPositionHandleMode: "unwrap" }),
		code: hc({ invalidPositionHandleMode: "move" }),
		divider: hc({ invalidPositionHandleMode: "move" }),
		heading: hc({ invalidPositionHandleMode: "unwrap" }),
		"component-block": Ei({
			allowedChildren: ["component-block-prop", "component-inline-prop"],
			invalidPositionHandleMode: "move",
		}),
		"component-inline-prop": hc({ invalidPositionHandleMode: "unwrap" }),
		"component-block-prop": Ei({
			allowedChildren: Jk,
			invalidPositionHandleMode: "unwrap",
		}),
		"ordered-list": Ei({
			allowedChildren: ["list-item"],
			invalidPositionHandleMode: "move",
		}),
		"unordered-list": Ei({
			allowedChildren: ["list-item"],
			invalidPositionHandleMode: "move",
		}),
		"list-item": Ei({
			allowedChildren: [
				"list-item-content",
				"ordered-list",
				"unordered-list",
			],
			invalidPositionHandleMode: "unwrap",
		}),
		"list-item-content": hc({ invalidPositionHandleMode: "unwrap" }),
		image: hc({ invalidPositionHandleMode: "move" }),
		table: Ei({
			invalidPositionHandleMode: "move",
			allowedChildren: ["table-head", "table-body"],
		}),
		"table-body": Ei({
			invalidPositionHandleMode: "move",
			allowedChildren: ["table-row"],
		}),
		"table-row": Ei({
			invalidPositionHandleMode: "move",
			allowedChildren: ["table-cell"],
		}),
		"table-cell": Ei({
			invalidPositionHandleMode: "move",
			allowedChildren: bH,
		}),
		"table-head": Ei({
			invalidPositionHandleMode: "move",
			allowedChildren: ["table-row"],
		}),
	},
	txe = new Set(
		Object.entries(rd)
			.filter(([, t]) => t.kind === "inlines")
			.map(([t]) => t),
	);
function nxe(t) {
	return t.type !== void 0 && txe.has(t.type);
}
const rxe = new Set(Object.keys(rd).filter((t) => t !== "editor"));
function Lt(t) {
	return rxe.has(t.type);
}
function ixe(t, e) {
	var n, r, i, o, s, a, l;
	const u =
			(n = e.formatting) === null || n === void 0
				? void 0
				: n.inlineMarks,
		c = Object.fromEntries(
			Object.keys(t.formatting.inlineMarks).map((f) => {
				const h = f;
				return [
					h,
					u === "inherit" || (u == null ? void 0 : u[h]) === "inherit"
						? t.formatting.inlineMarks[h]
						: !1,
				];
			}),
		),
		d =
			(r = e.formatting) === null || r === void 0
				? void 0
				: r.headingLevels;
	return {
		formatting: {
			inlineMarks: c,
			softBreaks:
				((i = e.formatting) === null || i === void 0
					? void 0
					: i.softBreaks) === "inherit" && t.formatting.softBreaks,
			alignment: {
				center:
					t.formatting.alignment.center &&
					((o = e.formatting) === null || o === void 0
						? void 0
						: o.alignment) === "inherit",
				end:
					t.formatting.alignment.end &&
					((s = e.formatting) === null || s === void 0
						? void 0
						: s.alignment) === "inherit",
			},
			blockTypes:
				((a = e.formatting) === null || a === void 0
					? void 0
					: a.blockTypes) === "inherit"
					? t.formatting.blockTypes
					: { blockquote: !1, code: !1 },
			headings:
				d === "inherit"
					? t.formatting.headings
					: {
							levels: d
								? t.formatting.headings.levels.filter((f) =>
										d.includes(f),
									)
								: [],
							schema: t.formatting.headings.schema,
						},
			listTypes:
				((l = e.formatting) === null || l === void 0
					? void 0
					: l.listTypes) === "inherit"
					? t.formatting.listTypes
					: { ordered: !1, unordered: !1 },
		},
		dividers: e.dividers === "inherit" ? t.dividers : !1,
		images: e.images === "inherit" && t.images,
		layouts: [],
		links: e.links === "inherit" && t.links,
		tables: e.tables === "inherit" && t.tables,
	};
}
function yH(t, e) {
	var n, r, i, o, s, a;
	const l =
			(n = e.formatting) === null || n === void 0
				? void 0
				: n.inlineMarks,
		u =
			l === "inherit"
				? "inherit"
				: Object.fromEntries(
						Object.keys(t.formatting.inlineMarks).map((f) => [
							f,
							!!(l || {})[f],
						]),
					);
	if (e.kind === "inline") {
		var c;
		return {
			kind: "inline",
			inlineMarks: u,
			documentFeatures: { links: e.links === "inherit" },
			softBreaks:
				((c = e.formatting) === null || c === void 0
					? void 0
					: c.softBreaks) === "inherit",
		};
	}
	const d =
		(r = e.formatting) === null || r === void 0 ? void 0 : r.headingLevels;
	return {
		kind: "block",
		inlineMarks: u,
		softBreaks:
			((i = e.formatting) === null || i === void 0
				? void 0
				: i.softBreaks) === "inherit",
		documentFeatures: {
			layouts: [],
			dividers: e.dividers === "inherit" ? t.dividers : !1,
			formatting: {
				alignment:
					((o = e.formatting) === null || o === void 0
						? void 0
						: o.alignment) === "inherit"
						? t.formatting.alignment
						: { center: !1, end: !1 },
				blockTypes:
					((s = e.formatting) === null || s === void 0
						? void 0
						: s.blockTypes) === "inherit"
						? t.formatting.blockTypes
						: { blockquote: !1, code: !1 },
				headings:
					d === "inherit"
						? t.formatting.headings
						: {
								levels: d
									? t.formatting.headings.levels.filter((f) =>
											d.includes(f),
										)
									: [],
								schema: t.formatting.headings.schema,
							},
				listTypes:
					((a = e.formatting) === null || a === void 0
						? void 0
						: a.listTypes) === "inherit"
						? t.formatting.listTypes
						: { ordered: !1, unordered: !1 },
			},
			links: e.links === "inherit",
			images: e.images === "inherit" ? t.images : !1,
			tables: e.tables === "inherit",
		},
		componentBlocks: e.componentBlocks === "inherit",
	};
}
function om(t, e, n) {
	if (t.length === 0) return n;
	if (!(n.kind === "child" || n.kind === "form")) {
		if (n.kind === "conditional") {
			const r = t.shift();
			if (r === "discriminant")
				return om(t, e.discriminant, n.discriminant);
			if (r === "value") {
				const i = n.values[e.discriminant];
				return om(t, e.value, i);
			}
			return;
		}
		if (n.kind === "object") {
			const r = t.shift();
			return om(t, e[r], n.fields[r]);
		}
		if (n.kind === "array") {
			const r = t.shift();
			return om(t, e[r], n.element);
		}
		qn(n);
	}
}
function y5(t, e, n) {
	return om([...t], e, { kind: "object", fields: n });
}
function oxe(t, e, n) {
	const r = [],
		i = [...e];
	let o = t,
		s = n;
	for (; i.length; ) {
		r.push(o);
		const a = i.shift();
		if (o.kind === "array") (o = o.element), (s = s[a]);
		else if (o.kind === "conditional")
			(o = o.values[n.discriminant]), (s = s.value);
		else if (o.kind === "object") (s = s[a]), (o = o.fields[a]);
		else {
			if (o.kind === "child" || o.kind === "form")
				throw new Error(`unexpected prop "${a}"`);
			qn(o);
		}
	}
	return r;
}
function sxe(t, e, n) {
	const r = y5(t, n, e);
	return (r == null ? void 0 : r.kind) === "child" &&
		((r.options.kind === "block" && r.options.editIn !== "modal") ||
			r.options.kind === "inline")
		? r.options.placeholder
		: "";
}
function x5(t) {
	return $e.isElement(t) ? { ...t, children: t.children.map(x5) } : { ...t };
}
const xH = [
		"bold",
		"italic",
		"underline",
		"strikethrough",
		"code",
		"superscript",
		"subscript",
		"keyboard",
	],
	Xs = (t, e) => {
		const [n] = R.nodes(t, { match: (r) => r.type === e });
		return !!n;
	};
function kH(t) {
	W.unwrapNodes(t, {
		match: (e) =>
			e.type === "heading" ||
			e.type === "blockquote" ||
			e.type === "code",
	}),
		W.unsetNodes(t, xH, { match: Be.isText });
}
function Dg(t, e, n, r = () => !0) {
	const i = Y.isPath(e) ? e : e[1],
		o = Y.isPath(e) ? pe.get(t, i) : e[0];
	if (Lt(o)) {
		for (let s = o.children.length - 1; s >= 0; s--)
			if (r(o.children[s], s)) {
				const a = [...i, s];
				W.moveNodes(t, { at: a, to: n });
			}
	}
}
function $m(t, e, { distance: n = 1 } = {}) {
	const r = R.point(t, e, { edge: "end" }),
		i = R.end(t, []),
		o = { anchor: r, focus: i };
	let s = 0,
		a;
	for (const l of R.positions(t, { at: o })) {
		if (s > n) break;
		pe.get(t, l.path).text.length !== l.offset && (s !== 0 && (a = l), s++);
	}
	return a;
}
function mr(...t) {
	if (t.length === 1) {
		const n = t[0];
		return (r) => r.type === n;
	}
	const e = new Set(t);
	return (n) => typeof n.type == "string" && e.has(n.type);
}
function z0(t, e, n) {
	const r = R.above(t, {
		match: mr("component-block-prop", "component-inline-prop"),
	});
	if (r) {
		const i = r[0].propPath,
			o = R.parent(t, r[1]);
		if (o[0].type === "component-block") {
			const s = o[0].component,
				a = n[s];
			if (a && i) {
				const l = y5(i, o[0].props, a.schema);
				if ((l == null ? void 0 : l.kind) === "child")
					return yH(e, l.options);
			}
		}
	}
}
const CH = E.createContext(null);
function wH() {
	const t = E.useContext(CH);
	if (!t)
		throw new Error(
			"useBlockPopoverContext must be used within a BlockPopoverTrigger",
		);
	return t;
}
const axe = mr(
		"code",
		"component-block",
		"image",
		"layout",
		"link",
		"table",
		"heading",
	),
	EH = E.createContext(void 0);
function k5() {
	return E.useContext(EH);
}
function lxe(t) {
	const e = ee(5);
	let n;
	e[0] !== t.editor
		? ((n = R.above(t.editor, { match: axe })),
			(e[0] = t.editor),
			(e[1] = n))
		: (n = e[1]);
	const r = n,
		i = r == null ? void 0 : r[0];
	let o;
	return (
		e[2] !== i || e[3] !== t.children
			? ((o = m.jsx(EH.Provider, { value: i, children: t.children })),
				(e[2] = i),
				(e[3] = t.children),
				(e[4] = o))
			: (o = e[4]),
		o
	);
}
const ef = ({ children: t, element: e }) => {
	const [n, r] = t,
		i = k5(),
		o = E.useRef(null),
		s = Bl({ isOpen: i === e }),
		a = E.useMemo(() => ({ state: s, triggerRef: o }), [s, o]);
	return m.jsxs(CH.Provider, {
		value: a,
		children: [E.cloneElement(n, { ref: o }), r],
	});
};
function tf(t) {
	const e = ee(7),
		{ state: n } = wH(),
		r = E.useRef(null);
	let i;
	e[0] !== r || e[1] !== t
		? ((i = m.jsx(uxe, { wrapperRef: r, ...t })),
			(e[0] = r),
			(e[1] = t),
			(e[2] = i))
		: (i = e[2]);
	let o;
	return (
		e[3] !== n.isOpen || e[4] !== r || e[5] !== i
			? ((o = m.jsx(m0, { isOpen: n.isOpen, nodeRef: r, children: i })),
				(e[3] = n.isOpen),
				(e[4] = r),
				(e[5] = i),
				(e[6] = o))
			: (o = e[6]),
		o
	);
}
const uxe = (t) => {
	const e = ee(14),
		{ children: n, placement: r } = t,
		i = r === void 0 ? "bottom" : r,
		o = E.useRef(null),
		{ state: s, triggerRef: a } = wH();
	let l;
	e[0] !== i || e[1] !== a || e[2] !== o
		? ((l = {
				isNonModal: !0,
				isKeyboardDismissDisabled: !1,
				placement: i,
				triggerRef: a,
				popoverRef: o,
			}),
			(e[0] = i),
			(e[1] = a),
			(e[2] = o),
			(e[3] = l))
		: (l = e[3]);
	const { placement: u, popoverProps: c } = cxe(l, s);
	let d;
	e[4] === Symbol.for("react.memo_cache_sentinel")
		? ((d = X({
				backgroundColor: B.color.background.surface,
				borderRadius: B.size.radius.medium,
				border: `${B.size.border.regular} solid ${B.color.border.emphasis}`,
				boxSizing: "content-box",
				minHeight: B.size.element.regular,
				minWidth: B.size.element.regular,
				opacity: 0,
				outline: 0,
				pointerEvents: "auto",
				position: "absolute",
				filter: `drop-shadow(0 1px 4px ${B.color.shadow.regular})`,
				willChange: "filter",
				userSelect: "none",
				'&[data-placement="top"]': {
					marginBottom: B.size.space.regular,
					transform: `translateY(${B.size.space.regular})`,
				},
				'&[data-placement="bottom"]': {
					marginTop: B.size.space.regular,
					transform: `translateY(calc(${B.size.space.regular} * -1))`,
				},
				'&[data-open="true"]': {
					opacity: 1,
					transform: "translateX(0) translateY(0)",
					transition: bt(["opacity", "transform"], {
						easing: "easeOut",
					}),
				},
			})),
			(e[4] = d))
		: (d = e[4]);
	let f;
	e[5] !== n || e[6] !== s
		? ((f = typeof n == "function" ? n(s.close) : n),
			(e[5] = n),
			(e[6] = s),
			(e[7] = f))
		: (f = e[7]);
	let h;
	return (
		e[8] !== o ||
		e[9] !== c ||
		e[10] !== s.isOpen ||
		e[11] !== u ||
		e[12] !== f
			? ((h = m.jsx("div", {
					ref: o,
					...c,
					"data-open": s.isOpen,
					"data-placement": u,
					contentEditable: !1,
					className: d,
					children: f,
				})),
				(e[8] = o),
				(e[9] = c),
				(e[10] = s.isOpen),
				(e[11] = u),
				(e[12] = f),
				(e[13] = h))
			: (h = e[13]),
		h
	);
};
function cxe(t, e) {
	var n;
	let {
			triggerRef: r,
			popoverRef: i,
			isNonModal: o,
			isKeyboardDismissDisabled: s,
			...a
		} = t,
		[l, u] = E.useState(!1),
		{ overlayProps: c, underlayProps: d } = nD(
			{
				isOpen: e.isOpen,
				onClose: e.close,
				shouldCloseOnBlur: !0,
				isDismissable: !o,
				isKeyboardDismissDisabled: !1,
			},
			i,
		);
	const f = 8;
	E.useEffect(() => {
		if (e.isOpen) {
			const y = () => {
				var x, C;
				const k = Math.max(
					document.documentElement.clientHeight || 0,
					window.innerHeight || 0,
				);
				let w =
						(x = i.current) === null || x === void 0
							? void 0
							: x.getBoundingClientRect(),
					D =
						(C = r.current) === null || C === void 0
							? void 0
							: C.getBoundingClientRect();
				w && D && u(D.bottom + w.height + f * 2 > k && D.top < k);
			};
			return (
				y(),
				window.addEventListener("scroll", y),
				() => {
					y(), window.removeEventListener("scroll", y);
				}
			);
		}
	}, [i, r, e.isOpen]);
	let {
			overlayProps: h,
			arrowProps: p,
			placement: g,
			updatePosition: v,
		} = ZE({
			...a,
			containerPadding: f,
			shouldFlip: !1,
			targetRef: r,
			overlayRef: i,
			isOpen: e.isOpen,
			onClose: void 0,
		}),
		b = dxe(
			(n = r.current) === null || n === void 0
				? void 0
				: n.getBoundingClientRect(),
		);
	return (
		at(() => {
			if (b) {
				var y;
				const x =
					(y = r.current) === null || y === void 0
						? void 0
						: y.getBoundingClientRect();
				x &&
					(b.height !== x.height ||
						b.width !== x.width ||
						b.x !== x.x ||
						b.y !== x.y) &&
					v();
			}
		}, [b, r, v]),
		h.style && (h.style.zIndex = 1),
		l &&
			(h.style = {
				...h.style,
				maxHeight: null,
				position: "fixed",
				top: null,
				bottom: f,
			}),
		{
			arrowProps: p,
			placement: g,
			popoverProps: xe(c, h),
			underlayProps: d,
			updatePosition: v,
		}
	);
}
function dxe(t) {
	const e = E.useRef();
	return (
		E.useEffect(() => {
			e.current = t;
		}),
		e.current
	);
}
const C5 = E.forwardRef(function (e, n) {
	const r = ee(10);
	let i, o;
	r[0] !== e
		? (({ className: i, ...o } = e), (r[0] = e), (r[1] = i), (r[2] = o))
		: ((i = r[1]), (o = r[2]));
	let s;
	r[3] === Symbol.for("react.memo_cache_sentinel")
		? ((s = X({ userSelect: "none", whiteSpace: "initial" })), (r[3] = s))
		: (s = r[3]);
	let a;
	r[4] !== i ? ((a = [s, i]), (r[4] = i), (r[5] = a)) : (a = r[5]);
	const l = a.join(" ");
	let u;
	return (
		r[6] !== o || r[7] !== n || r[8] !== l
			? ((u = m.jsx("div", {
					...o,
					ref: n,
					className: l,
					contentEditable: !1,
				})),
				(r[6] = o),
				(r[7] = n),
				(r[8] = l),
				(r[9] = u))
			: (u = r[9]),
		u
	);
});
function fxe(t) {
	let e = t.toLowerCase().trim();
	return (
		(e = e.normalize("NFD").replace(/[\u0300-\u036f]/g, "")),
		(e = e.replace(/[^a-z0-9\s-]/g, " ").trim()),
		(e = e.replace(/[\s-]+/g, "-")),
		e
	);
}
const hxe = sa({ src: jt(), width: $h(), height: $h() });
function pxe(t, e) {
	if (t.size > 1e7) throw new Error("Images must be smaller than 10MB");
	const n = M0(e);
	if (!n) throw new Error("You must be signed in to upload images");
	const r = /(.+)\.(png|jpe?g|gif|webp)$/.exec(t.name);
	if (!r)
		throw new Error(
			"Invalid image type, only PNG, JPEG, GIF, and WebP are supported",
		);
	const i = fxe(r[1]),
		o = r[2],
		s = `${i}.${o}`,
		a = new File([t], s, { type: `image/${s === "jpg" ? "jpeg" : s}` }),
		l = new FormData();
	return (
		l.set("image", a, s),
		(async () => {
			const u = await fetch(`${Rl}/v1/image`, {
				method: "PUT",
				headers: { Authorization: `Bearer ${n.accessToken}`, ...ic },
				body: l,
			});
			if (!u.ok)
				throw new Error(`Failed to upload image: ${await u.text()}`);
			const c = await u.json();
			let d;
			try {
				d = hxe.create(c);
			} catch {
				throw new Error("Unexpected response from cloud");
			}
			return d;
		})()
	);
}
function mxe(t) {
	try {
		const r = JSON.parse(t);
		if (
			typeof r == "object" &&
			r !== null &&
			"src" in r &&
			typeof r.src == "string"
		)
			return {
				src: r.src,
				alt: "alt" in r && typeof r.alt == "string" ? r.alt : "",
				height:
					"height" in r &&
					typeof r.height == "number" &&
					Number.isInteger(r.height)
						? r.height
						: void 0,
				width:
					"width" in r &&
					typeof r.width == "number" &&
					Number.isInteger(r.width)
						? r.width
						: void 0,
			};
	} catch {}
	const e = /^\s*!\[(.*)\]\(([a-z0-9_\-/:.]+)\)\s*$/,
		n = t.match(e);
	return n ? { src: n[2], alt: n[1] } : { src: t, alt: "" };
}
function gxe(t) {
	const e = ee(4);
	let n;
	e[0] === Symbol.for("react.memo_cache_sentinel")
		? ((n = {}), (e[0] = n))
		: (n = e[0]);
	const [r, i] = E.useState(n);
	let o, s;
	return (
		e[1] !== t
			? ((o = () => {
					if (!t || !wxe(t)) {
						i({});
						return;
					}
					let a;
					return (
						(a = !0),
						DH(t).then((l) => {
							a && i(l);
						}),
						() => {
							a = !1;
						}
					);
				}),
				(s = [t]),
				(e[1] = t),
				(e[2] = o),
				(e[3] = s))
			: ((o = e[2]), (s = e[3])),
		E.useEffect(o, s),
		r
	);
}
function DH(t) {
	return new Promise((e, n) => {
		const r = new Image();
		(r.onload = () => {
			e({ width: r.width, height: r.height });
		}),
			(r.onerror = () => {
				n();
			}),
			(r.src = t);
	});
}
const bxe = sa({ src: jt(), alt: jt(), width: $h(), height: $h() });
async function vxe(t, e) {
	const n = M0(e);
	if (n) {
		const r = await fetch(
			`${Rl}/v1/image?${new URLSearchParams({ url: t })}`,
			{ headers: { Authorization: `Bearer ${n.accessToken}`, ...ic } },
		);
		if (r.ok) {
			const i = await r.json();
			try {
				return bxe.create(i);
			} catch {}
		}
	}
	return DH(t).then((r) => ({ src: t, alt: "", ...r }));
}
function yxe(t) {
	const e = ee(42),
		n = gxe(t.src),
		[r, i] = E.useState(!0),
		o = `Revert to original (${n.width} × ${n.height})`,
		s = n.width === t.image.width && n.height === t.image.height;
	let a;
	e[0] === Symbol.for("react.memo_cache_sentinel")
		? ((a = { maximumFractionDigits: 0 }), (e[0] = a))
		: (a = e[0]);
	let l;
	e[1] !== r || e[2] !== t
		? ((l = (A) => {
				r
					? t.onChange({
							width: A,
							height: Math.round(A / mI(t.image)),
						})
					: t.onChange({ width: A });
			}),
			(e[1] = r),
			(e[2] = t),
			(e[3] = l))
		: (l = e[3]);
	let u;
	e[4] !== t.image.width || e[5] !== l
		? ((u = m.jsx(Wv, {
				label: "Width",
				width: "scale.1600",
				formatOptions: a,
				value: t.image.width,
				onChange: l,
			})),
			(e[4] = t.image.width),
			(e[5] = l),
			(e[6] = u))
		: (u = e[6]);
	let c;
	e[7] === Symbol.for("react.memo_cache_sentinel")
		? ((c = () => {
				i((A) => !A);
			}),
			(e[7] = c))
		: (c = e[7]);
	const d = r ? rme : ime;
	let f;
	e[8] !== d
		? ((f = m.jsx(ve, { src: d })), (e[8] = d), (e[9] = f))
		: (f = e[9]);
	let h;
	e[10] !== r || e[11] !== f
		? ((h = m.jsx(WP, {
				isSelected: r,
				"aria-label": "Constrain proportions",
				prominence: "low",
				onPress: c,
				children: f,
			})),
			(e[10] = r),
			(e[11] = f),
			(e[12] = h))
		: (h = e[12]);
	let p;
	e[13] === Symbol.for("react.memo_cache_sentinel")
		? ((p = m.jsx(Xe, { children: "Constrain proportions" })), (e[13] = p))
		: (p = e[13]);
	let g;
	e[14] !== h
		? ((g = m.jsxs(Ze, { children: [h, p] })), (e[14] = h), (e[15] = g))
		: (g = e[15]);
	let v;
	e[16] === Symbol.for("react.memo_cache_sentinel")
		? ((v = { maximumFractionDigits: 0 }), (e[16] = v))
		: (v = e[16]);
	let b;
	e[17] !== r || e[18] !== t
		? ((b = (A) => {
				r
					? t.onChange({
							height: A,
							width: Math.round(A * mI(t.image)),
						})
					: t.onChange({ height: A });
			}),
			(e[17] = r),
			(e[18] = t),
			(e[19] = b))
		: (b = e[19]);
	let y;
	e[20] !== t.image.height || e[21] !== b
		? ((y = m.jsx(Wv, {
				label: "Height",
				width: "scale.1600",
				formatOptions: v,
				value: t.image.height,
				onChange: b,
			})),
			(e[20] = t.image.height),
			(e[21] = b),
			(e[22] = y))
		: (y = e[22]);
	const x = s || !n.width || !n.height;
	let C;
	e[23] !== t || e[24] !== n.height || e[25] !== n.width
		? ((C = () => {
				t.onChange({ height: n.height, width: n.width });
			}),
			(e[23] = t),
			(e[24] = n.height),
			(e[25] = n.width),
			(e[26] = C))
		: (C = e[26]);
	let k;
	e[27] === Symbol.for("react.memo_cache_sentinel")
		? ((k = m.jsx(ve, { src: ome })), (e[27] = k))
		: (k = e[27]);
	let w;
	e[28] !== o || e[29] !== x || e[30] !== C
		? ((w = m.jsx(Re, {
				"aria-label": o,
				isDisabled: x,
				onPress: C,
				children: k,
			})),
			(e[28] = o),
			(e[29] = x),
			(e[30] = C),
			(e[31] = w))
		: (w = e[31]);
	let D;
	e[32] !== o
		? ((D = m.jsx(Xe, { maxWidth: "100%", children: o })),
			(e[32] = o),
			(e[33] = D))
		: (D = e[33]);
	let S;
	e[34] !== w || e[35] !== D
		? ((S = m.jsxs(Ze, { children: [w, D] })),
			(e[34] = w),
			(e[35] = D),
			(e[36] = S))
		: (S = e[36]);
	let $;
	return (
		e[37] !== u || e[38] !== g || e[39] !== y || e[40] !== S
			? (($ = m.jsxs(As, {
					gap: "regular",
					alignItems: "end",
					children: [u, g, y, S],
				})),
				(e[37] = u),
				(e[38] = g),
				(e[39] = y),
				(e[40] = S),
				(e[41] = $))
			: ($ = e[41]),
		$
	);
}
const pI = { src: "", alt: "" },
	xxe = ["jpeg", "jpg", "png", "gif", "webp"],
	kxe = xxe.map((t) => `image/${t}`);
function Cxe(t) {
	var e;
	const n = ee(12);
	let r;
	if (n[0] !== t) {
		const { onUploaded: d, ...f } = t;
		(r = f), (n[0] = t), (n[1] = r);
	} else r = n[1];
	const i = Jn(),
		[o, s] = E.useState(!1);
	if (!((e = i.cloud) !== null && e !== void 0 && e.project)) return null;
	let a;
	n[2] !== i || n[3] !== t
		? ((a = async (d) => {
				const f = Array.from(d || []);
				if (f[0]) {
					s(!0);
					try {
						const h = await pxe(f[0], i);
						t.onUploaded({ ...h, alt: "" }), s(!1);
					} catch (h) {
						const p = h;
						s(!1), il.critical(p.message);
					}
				}
			}),
			(n[2] = i),
			(n[3] = t),
			(n[4] = a))
		: (a = n[4]);
	const l = o ? "Uploading…" : "Upload";
	let u;
	n[5] !== o || n[6] !== r || n[7] !== l
		? ((u = m.jsx(Re, { isDisabled: o, ...r, children: l })),
			(n[5] = o),
			(n[6] = r),
			(n[7] = l),
			(n[8] = u))
		: (u = n[8]);
	let c;
	return (
		n[9] !== a || n[10] !== u
			? ((c = m.jsx(sse, {
					acceptedFileTypes: kxe,
					onSelect: a,
					children: u,
				})),
				(n[9] = a),
				(n[10] = u),
				(n[11] = c))
			: (c = n[11]),
		c
	);
}
function wxe(t) {
	try {
		return new URL(t), !0;
	} catch {
		return !1;
	}
}
function SH() {
	const t = Jn(),
		e = xye(t);
	return e
		? `https://keystatic.cloud/teams/${e.team}/project/${e.project}/images`
		: "https://keystatic.cloud/";
}
function mI(t) {
	return !t.width || !t.height ? 1 : t.width / t.height;
}
class st extends Error {
	constructor(e) {
		super(e), (this.name = "FieldDataError");
	}
}
function Fs(t, e, n) {
	if (t === null && e !== null && e !== void 0 && e.isRequired)
		throw new st(`${n} is required`);
}
function Hi(t) {
	return {
		kind: "form",
		Input: t.Input,
		defaultValue: t.defaultValue,
		parse: t.parse,
		serialize: t.serialize,
		validate: t.validate,
		reader: {
			parse(e) {
				return t.validate(t.parse(e));
			},
		},
		label: t.label,
	};
}
function Bd(t, e) {
	return t.length === e.length && t.every((n, r) => n === e[r]);
}
function AH([t, e], n, r, i) {
	const o = Object.keys(t).filter(
		(s) => s !== "text" && s !== "insertMenu" && r[s] !== !0,
	);
	if (o.length) return W.unsetNodes(n, o, { at: e }), !0;
	if (
		!i &&
		t.text.includes(`
`)
	) {
		const [a] = R.parent(n, e);
		if (a.type !== "code") {
			for (const l of R.positions(n, { at: e }))
				if (
					pe.get(n, l.path).text[l.offset] ===
					`
`
				)
					return W.delete(n, { at: l }), !0;
		}
	}
	return !1;
}
function $H([t, e], n, r) {
	return t.type === "link" && !r
		? (W.insertText(n, ` (${t.href})`, { at: R.end(n, e) }),
			W.unwrapNodes(n, { at: e }),
			!0)
		: !1;
}
function TH(
	[t, e],
	n,
	{ formatting: r, dividers: i, layouts: o, links: s, images: a, tables: l },
) {
	return (t.type === "heading" &&
		(!r.headings.levels.length || !r.headings.levels.includes(t.level))) ||
		(t.type === "ordered-list" && !r.listTypes.ordered) ||
		(t.type === "unordered-list" && !r.listTypes.unordered) ||
		(t.type === "code" && !r.blockTypes.code) ||
		(t.type === "blockquote" && !r.blockTypes.blockquote) ||
		(t.type === "image" && !a) ||
		(t.type === "table" && !l) ||
		(t.type === "layout" &&
			(o.length === 0 || !o.some((u) => Bd(u, t.layout))))
		? (W.unwrapNodes(n, { at: e }), !0)
		: (t.type === "paragraph" || t.type === "heading") &&
			  ((!r.alignment.center && t.textAlign === "center") ||
					(!r.alignment.end && t.textAlign === "end") ||
					("textAlign" in t &&
						t.textAlign !== "center" &&
						t.textAlign !== "end"))
			? (W.unsetNodes(n, "textAlign", { at: e }), !0)
			: t.type === "divider" && !i
				? (W.removeNodes(n, { at: e }), !0)
				: $H([t, e], n, s);
}
function Exe(t, e) {
	const { normalizeNode: n } = e;
	return (
		(e.normalizeNode = ([r, i]) => {
			Be.isText(r)
				? AH(
						[r, i],
						e,
						t.formatting.inlineMarks,
						t.formatting.softBreaks,
					)
				: $e.isElement(r) && TH([r, i], e, t),
				n([r, i]);
		}),
		e
	);
}
function Dxe(t) {
	const e = x3(),
		n = _0(),
		r = En(),
		i = nH(),
		o = E.useMemo(() => {
			if (!e || e === "loading" || !n) return [];
			const s = [];
			for (const [a, l] of i)
				a === e.awareness.clientID ||
					!l.user ||
					r.href !== `/keystatic/branch/${l.branch}/${l.location}` ||
					!Array.isArray(l.path) ||
					!Bd(l.path, t.path) ||
					s.push(l.user);
			return s;
		}, [e, n, i, r.href, t.path]);
	return m.jsxs("div", {
		"data-ks-path": JSON.stringify(t.path),
		onFocus: (s) => {
			s.target.closest("[data-ks-path]") === s.currentTarget &&
				e &&
				e !== "loading" &&
				e.awareness.setLocalStateField("path", t.path);
		},
		children: [
			!!o.length &&
				m.jsx("div", {
					className: X({
						position: "relative",
						width: "100%",
						height: 0,
					}),
					children: m.jsx("div", {
						className: X({
							position: "absolute",
							top: 0,
							right: 0,
							display: "flex",
							gap: "0.5em",
						}),
						children: o.map((s, a) =>
							m.jsx(
								m3,
								{
									size: "xsmall",
									src: s.avatarUrl,
									name: s.name,
								},
								a,
							),
						),
					}),
				}),
			t.children,
		],
	});
}
function py(t) {
	const e = ee(9),
		n = E.useContext(Sg),
		r = Jn();
	let i, o;
	e[0] !== n || e[1] !== t.part
		? ((o = n.concat(t.part)), (e[0] = n), (e[1] = t.part), (e[2] = o))
		: (o = e[2]),
		(i = o);
	const s = i;
	let a;
	e[3] !== s || e[4] !== t.children
		? ((a = m.jsx(Sg.Provider, { value: s, children: t.children })),
			(e[3] = s),
			(e[4] = t.children),
			(e[5] = a))
		: (a = e[5]);
	const l = a;
	if (r.storage.kind === "cloud") {
		let u;
		return (
			e[6] !== s || e[7] !== l
				? ((u = m.jsx(Dxe, { path: s, children: l })),
					(e[6] = s),
					(e[7] = l),
					(e[8] = u))
				: (u = e[8]),
			u
		);
	}
	return l;
}
const w5 = E.createContext(void 0),
	BH = w5.Provider,
	Sg = E.createContext([]),
	IH = Sg.Provider;
function Mh(t, e, n, r, i, o) {
	if (t.length < e)
		return e === 1
			? `${r} must not be empty`
			: `${r} must be at least ${e} characters long`;
	if (t.length > n) return `${r} must be no longer than ${n} characters`;
	if (o && !o.regex.test(t))
		return o.message || `${r} must match the pattern ${o.regex}`;
	if (i) {
		if (t === "") return `${r} must not be empty`;
		if (t === "..") return `${r} must not be ..`;
		if (t === ".") return `${r} must not be .`;
		if (i.glob === "**") {
			const s = t.split("/");
			if (s.some((a) => a === "..")) return `${r} must not contain ..`;
			if (s.some((a) => a === ".")) return `${r} must not be .`;
		}
		if ((i.glob === "*" ? /[\\/]/ : /[\\]/).test(t))
			return `${r} must not contain slashes`;
		if (/^\s|\s$/.test(t)) return `${r} must not start or end with spaces`;
		if (i.slugs.has(t)) return `${r} must be unique`;
	}
}
function Sxe(t) {
	const e = ee(15),
		n = t.multiline ? VN : An,
		[r, i] = E.useState(!1),
		o = E.useContext(w5),
		s = E.useContext(Sg);
	let a;
	e[0] === Symbol.for("react.memo_cache_sentinel")
		? ((a = () => i(!0)), (e[0] = a))
		: (a = e[0]);
	const l = t.min > 0;
	let u;
	e[1] !== t || e[2] !== r || e[3] !== s || e[4] !== o
		? ((u =
				t.forceValidation || r
					? Mh(
							t.value,
							t.min,
							t.max,
							t.label,
							s.length === 1 &&
								(o == null ? void 0 : o.field) === s[0]
								? o
								: void 0,
							t.pattern,
						)
					: void 0),
			(e[1] = t),
			(e[2] = r),
			(e[3] = s),
			(e[4] = o),
			(e[5] = u))
		: (u = e[5]);
	let c;
	return (
		e[6] !== n ||
		e[7] !== t.label ||
		e[8] !== t.description ||
		e[9] !== t.autoFocus ||
		e[10] !== t.value ||
		e[11] !== t.onChange ||
		e[12] !== l ||
		e[13] !== u
			? ((c = m.jsx(n, {
					label: t.label,
					description: t.description,
					autoFocus: t.autoFocus,
					value: t.value,
					onChange: t.onChange,
					onBlur: a,
					isRequired: l,
					errorMessage: u,
				})),
				(e[6] = n),
				(e[7] = t.label),
				(e[8] = t.description),
				(e[9] = t.autoFocus),
				(e[10] = t.value),
				(e[11] = t.onChange),
				(e[12] = l),
				(e[13] = u),
				(e[14] = c))
			: (c = e[14]),
		c
	);
}
function Xk(t) {
	if (t === void 0) return "";
	if (typeof t != "string") throw new st("Must be a string");
	return t;
}
const Axe = new Set();
function Ag({
	label: t,
	defaultValue: e = "",
	validation: {
		length: { max: n = 1 / 0, min: r = 0 } = {},
		pattern: i,
		isRequired: o,
	} = {},
	description: s,
	multiline: a = !1,
}) {
	r = Math.max(o ? 1 : 0, r);
	function l(u, c) {
		const d = Mh(u, r, n, t, c, i);
		if (d !== void 0) throw new st(d);
		return u;
	}
	return {
		kind: "form",
		formKind: "slug",
		label: t,
		Input(u) {
			return m.jsx(Sxe, {
				label: t,
				description: s,
				min: r,
				max: n,
				multiline: a,
				pattern: i,
				...u,
			});
		},
		defaultValue() {
			return typeof e == "string" ? e : e();
		},
		parse(u, c) {
			return (c == null ? void 0 : c.slug) !== void 0 ? c.slug : Xk(u);
		},
		serialize(u) {
			return { value: u === "" ? void 0 : u };
		},
		serializeWithSlug(u) {
			return { slug: u, value: void 0 };
		},
		reader: {
			parse(u) {
				const c = Xk(u);
				return l(c, void 0);
			},
			parseWithSlug(u, c) {
				return l(Xk(c.slug), { glob: c.glob, slugs: Axe }), null;
			},
		},
		validate(u, c) {
			return l(u, c == null ? void 0 : c.slugField);
		},
	};
}
const E5 = new WeakMap();
function j2(t, e) {
	let { id: n } = E5.get(t);
	if (!n) throw new Error("Unknown list");
	return `${n}-${$xe(e)}`;
}
function $xe(t) {
	return typeof t == "string" ? t.replace(/\s*/g, "") : "" + t;
}
function Txe(t, e, n) {
	let {
		isVirtualized: r,
		keyboardDelegate: i,
		layoutDelegate: o,
		onAction: s,
		linkBehavior: a = "action",
		keyboardNavigationBehavior: l = "arrow",
	} = t;
	!t["aria-label"] &&
		!t["aria-labelledby"] &&
		console.warn(
			"An aria-label or aria-labelledby prop is required for accessibility.",
		);
	let { listProps: u } = ED({
			selectionManager: e.selectionManager,
			collection: e.collection,
			disabledKeys: e.disabledKeys,
			ref: n,
			keyboardDelegate: i,
			layoutDelegate: o,
			isVirtualized: r,
			selectOnFocus: e.selectionManager.selectionBehavior === "replace",
			shouldFocusWrap: t.shouldFocusWrap,
			linkBehavior: a,
		}),
		c = Ot(t.id);
	E5.set(e, {
		id: c,
		onAction: s,
		linkBehavior: a,
		keyboardNavigationBehavior: l,
	});
	let d = xO({ selectionManager: e.selectionManager, hasItemActions: !!s }),
		f = B9(n, { isDisabled: e.collection.size !== 0 }),
		h = Ge(t, { labelable: !0 }),
		p = xe(
			h,
			{
				role: "grid",
				id: c,
				"aria-multiselectable":
					e.selectionManager.selectionMode === "multiple"
						? "true"
						: void 0,
			},
			e.collection.size === 0 ? { tabIndex: f ? -1 : 0 } : u,
			d,
		);
	return (
		r &&
			((p["aria-rowcount"] = e.collection.size),
			(p["aria-colcount"] = 1)),
		yO({}, e),
		{ gridProps: p }
	);
}
const gI = {
	expand: { ltr: "ArrowRight", rtl: "ArrowLeft" },
	collapse: { ltr: "ArrowLeft", rtl: "ArrowRight" },
};
function Bxe(t, e, n) {
	var r, i;
	let { node: o, isVirtualized: s, shouldSelectOnPressUp: a } = t,
		{ direction: l } = Vt(),
		{
			onAction: u,
			linkBehavior: c,
			keyboardNavigationBehavior: d,
		} = E5.get(e),
		f = Lo(),
		h = E.useRef(null),
		p = () => {
			var A;
			((h.current != null && o.key !== h.current) ||
				!(
					!((A = n.current) === null || A === void 0) &&
					A.contains(document.activeElement)
				)) &&
				on(n.current);
		},
		g = {},
		v,
		b = e.selectionManager.isLink(o.key);
	o != null &&
		"expandedKeys" in e &&
		((v = [...e.collection.getChildren(o.key)].length > 1),
		u == null &&
			!b &&
			e.selectionManager.selectionMode === "none" &&
			v &&
			(u = () => e.toggleKey(o.key)),
		(g = {
			"aria-expanded": v ? e.expandedKeys.has(o.key) : void 0,
			"aria-level": o.level + 1,
			"aria-posinset": (o == null ? void 0 : o.index) + 1,
			"aria-setsize":
				o.level > 0
					? Xa(
							e.collection.getChildren(
								o == null ? void 0 : o.parentKey,
							),
						).index + 1
					: [...e.collection].filter((T) => T.level === 0).at(-1)
							.index + 1,
		}));
	let { itemProps: y, ...x } = f0({
			selectionManager: e.selectionManager,
			key: o.key,
			ref: n,
			isVirtualized: s,
			shouldSelectOnPressUp: a,
			onAction:
				u || (!((r = o.props) === null || r === void 0) && r.onAction)
					? hr(
							(i = o.props) === null || i === void 0
								? void 0
								: i.onAction,
							u ? () => u(o.key) : void 0,
						)
					: void 0,
			focus: p,
			linkBehavior: c,
		}),
		C = (A) => {
			if (!A.currentTarget.contains(A.target)) return;
			let T = rr(n.current);
			if (
				((T.currentNode = document.activeElement),
				"expandedKeys" in e && document.activeElement === n.current)
			) {
				if (
					A.key === gI.expand[l] &&
					e.selectionManager.focusedKey === o.key &&
					v &&
					!e.expandedKeys.has(o.key)
				) {
					e.toggleKey(o.key), A.stopPropagation();
					return;
				} else if (
					A.key === gI.collapse[l] &&
					e.selectionManager.focusedKey === o.key &&
					v &&
					e.expandedKeys.has(o.key)
				) {
					e.toggleKey(o.key), A.stopPropagation();
					return;
				}
			}
			switch (A.key) {
				case "ArrowLeft":
					if (d === "arrow") {
						let I = l === "rtl" ? T.nextNode() : T.previousNode();
						if (I)
							A.preventDefault(),
								A.stopPropagation(),
								on(I),
								ui(I, { containingElement: li(n.current) });
						else if (
							(A.preventDefault(),
							A.stopPropagation(),
							l === "rtl")
						)
							on(n.current),
								ui(n.current, {
									containingElement: li(n.current),
								});
						else {
							T.currentNode = n.current;
							let F = bI(T);
							F &&
								(on(F),
								ui(F, { containingElement: li(n.current) }));
						}
					}
					break;
				case "ArrowRight":
					if (d === "arrow") {
						let I = l === "rtl" ? T.previousNode() : T.nextNode();
						if (I)
							A.preventDefault(),
								A.stopPropagation(),
								on(I),
								ui(I, { containingElement: li(n.current) });
						else if (
							(A.preventDefault(),
							A.stopPropagation(),
							l === "ltr")
						)
							on(n.current),
								ui(n.current, {
									containingElement: li(n.current),
								});
						else {
							T.currentNode = n.current;
							let F = bI(T);
							F &&
								(on(F),
								ui(F, { containingElement: li(n.current) }));
						}
					}
					break;
				case "ArrowUp":
				case "ArrowDown":
					!A.altKey &&
						n.current.contains(A.target) &&
						(A.stopPropagation(),
						A.preventDefault(),
						n.current.parentElement.dispatchEvent(
							new KeyboardEvent(
								A.nativeEvent.type,
								A.nativeEvent,
							),
						));
					break;
				case "Tab":
					if (d === "tab") {
						let I = rr(n.current, { tabbable: !0 });
						(I.currentNode = document.activeElement),
							(A.shiftKey ? I.previousNode() : I.nextNode()) &&
								A.stopPropagation();
					}
			}
		},
		k = (A) => {
			if (((h.current = o.key), A.target !== n.current)) {
				ml() || e.selectionManager.setFocusedKey(o.key);
				return;
			}
		},
		w = i9(o.props),
		D = x.hasAction ? w : {},
		S = xe(y, D, {
			role: "row",
			onKeyDownCapture: C,
			onFocus: k,
			"aria-label": o.textValue || void 0,
			"aria-selected": e.selectionManager.canSelectItem(o.key)
				? e.selectionManager.isSelected(o.key)
				: void 0,
			"aria-disabled": e.selectionManager.isDisabled(o.key) || void 0,
			"aria-labelledby":
				f && o.textValue ? `${j2(e, o.key)} ${f}` : void 0,
			id: j2(e, o.key),
		});
	s && (S["aria-rowindex"] = o.index + 1);
	let $ = { role: "gridcell", "aria-colindex": 1 };
	return {
		rowProps: { ...xe(S, g) },
		gridCellProps: $,
		descriptionProps: { id: f },
		...x,
	};
}
function bI(t) {
	let e, n;
	do (n = t.lastChild()), n && (e = n);
	while (n);
	return e;
}
function Ixe(t, e) {
	let { key: n } = t;
	const { checkboxProps: r } = CO(t, e);
	return {
		checkboxProps: { ...r, "aria-labelledby": `${r.id} ${j2(e, n)}` },
	};
}
const FH = m.jsx("path", { d: "m15 18-6-6 6-6" }),
	PH = m.jsx("path", { d: "m9 18 6-6-6-6" }),
	my = new Gr("ListView", ["centered-wrapper"]),
	Dn = new Gr("ListViewItem", [
		"actionmenu",
		"actions",
		"badge",
		"checkbox",
		"content",
		"description",
		"draghandle",
		"grid",
		"parent-indicator",
		"row",
		"thumbnail",
	]),
	NH = E.createContext(null),
	Fxe = NH.Provider;
function D3() {
	const t = E.useContext(NH);
	if (!t)
		throw new Error(
			"Attempt to access `ListViewContext` outside of its provided.",
		);
	return t;
}
const Pxe = {
	"ar-AE": {
		loading: "جارٍ التحميل...",
		loadingMore: "جارٍ تحميل المزيد...",
	},
	"bg-BG": { loading: "Зареждане...", loadingMore: "Зареждане на още..." },
	"cs-CZ": { loading: "Načítání...", loadingMore: "Načítání dalších..." },
	"da-DK": { loading: "Indlæser...", loadingMore: "Indlæser flere..." },
	"de-DE": { loading: "Laden...", loadingMore: "Mehr laden ..." },
	"el-GR": { loading: "Φόρτωση...", loadingMore: "Φόρτωση περισσότερων..." },
	"en-US": { loading: "Loading…", loadingMore: "Loading more…" },
	"es-ES": { loading: "Cargando…", loadingMore: "Cargando más…" },
	"et-EE": { loading: "Laadimine...", loadingMore: "Laadi rohkem..." },
	"fi-FI": { loading: "Ladataan…", loadingMore: "Ladataan lisää…" },
	"fr-FR": {
		loading: "Chargement...",
		loadingMore: "Chargement supplémentaire...",
	},
	"he-IL": { loading: "טוען...", loadingMore: "טוען עוד..." },
	"hr-HR": { loading: "Učitavam...", loadingMore: "Učitavam još..." },
	"hu-HU": {
		loading: "Betöltés folyamatban…",
		loadingMore: "Továbbiak betöltése folyamatban…",
	},
	"it-IT": { loading: "Caricamento...", loadingMore: "Caricamento altri..." },
	"ja-JP": { loading: "読み込み中...", loadingMore: "さらに読み込み中..." },
	"ko-KR": { loading: "로드 중…", loadingMore: "추가 로드 중…" },
	"lt-LT": { loading: "Įkeliama...", loadingMore: "Įkeliama daugiau..." },
	"lv-LV": {
		loading: "Notiek ielāde...",
		loadingMore: "Tiek ielādēts vēl...",
	},
	"nb-NO": { loading: "Laster inn ...", loadingMore: "Laster inn flere ..." },
	"nl-NL": { loading: "Laden...", loadingMore: "Meer laden..." },
	"pl-PL": {
		loading: "Ładowanie...",
		loadingMore: "Wczytywanie większej liczby...",
	},
	"pt-BR": { loading: "Carregando...", loadingMore: "Carregando mais..." },
	"pt-PT": { loading: "A carregar...", loadingMore: "A carregar mais..." },
	"ro-RO": {
		loading: "Se încarcă...",
		loadingMore: "Se încarcă mai multe...",
	},
	"ru-RU": {
		loading: "Загрузка...",
		loadingMore: "Дополнительная загрузка...",
	},
	"sk-SK": { loading: "Načítava sa...", loadingMore: "Načítava sa viac..." },
	"sl-SI": {
		loading: "Nalaganje ...",
		loadingMore: "Nalaganje več vsebine ...",
	},
	"sr-SP": { loading: "Učitavam...", loadingMore: "Učitavam još..." },
	"sv-SE": { loading: "Läser in...", loadingMore: "Läser in mer..." },
	"tr-TR": {
		loading: "Yükleniyor...",
		loadingMore: "Daha fazla yükleniyor...",
	},
	"uk-UA": {
		loading: "Завантаження…",
		loadingMore: "Завантаження інших об’єктів...",
	},
	"zh-CN": { loading: "正在加载...", loadingMore: "正在加载更多..." },
	"zh-T": { loading: "載入中…", loadingMore: "正在載入更多…" },
};
function Nxe(t) {
	const e = ce(31),
		{ item: n, itemCount: r, itemHeight: i, density: o } = t,
		s = r > 1;
	let a;
	e[0] !== o || e[1] !== s
		? ((a = lt({ density: o, multi: s })),
			(e[0] = o),
			(e[1] = s),
			(e[2] = a))
		: (a = e[2]);
	let l;
	e[3] !== i ? ((l = { height: i }), (e[3] = i), (e[4] = l)) : (l = e[4]);
	let u;
	e[5] === Symbol.for("react.memo_cache_sentinel")
		? ((u = Se(
				X({
					display: "grid",
					backgroundColor: B.color.background.canvas,
					border: `${B.size.border.regular} solid ${B.color.alias.borderSelected}`,
					borderRadius: B.size.radius.small,
					paddingInline: B.size.space.medium,
					position: "relative",
					outline: 0,
					width: B.size.alias.singleLineWidth,
					minHeight: B.size.element.medium,
					paddingBlock: B.size.space.medium,
					'&[data-density="compact"]': {
						minHeight: B.size.element.regular,
						paddingBlock: B.size.space.regular,
					},
					'&[data-density="spacious"]': {
						minHeight: B.size.element.large,
						paddingBlock: B.size.space.large,
					},
					"&[data-multi=true]::after": {
						backgroundColor: "inherit",
						border: "inherit",
						borderRadius: "inherit",
						content: '" "',
						display: "block",
						height: "100%",
						insetInlineStart: 4,
						position: "absolute",
						top: 4,
						width: "100%",
						zIndex: -1,
					},
				}),
			)),
			(e[5] = u))
		: (u = e[5]);
	let c;
	e[6] === Symbol.for("react.memo_cache_sentinel")
		? ((c = Dn.element("grid")), (e[6] = c))
		: (c = e[6]);
	let d;
	e[7] === Symbol.for("react.memo_cache_sentinel")
		? ((d = [
				"thumbnail content     . badge",
				"thumbnail description . badge",
			]),
			(e[7] = d))
		: (d = e[7]);
	let f;
	e[8] === Symbol.for("react.memo_cache_sentinel")
		? ((f = {
				gridArea: "content",
				flexGrow: 1,
				truncate: !0,
				weight: "medium",
				UNSAFE_className: Dn.element("content"),
			}),
			(e[8] = f))
		: (f = e[8]);
	let h;
	e[9] === Symbol.for("react.memo_cache_sentinel")
		? ((h = {
				color: "neutralSecondary",
				size: "small",
				gridArea: "description",
				flexGrow: 1,
				marginTop: "small",
				truncate: !0,
				UNSAFE_className: Dn.element("description"),
			}),
			(e[9] = h))
		: (h = e[9]);
	const p = o === "compact" ? "element.small" : "element.regular";
	let g;
	e[10] === Symbol.for("react.memo_cache_sentinel")
		? ((g = Dn.element("thumbnail")), (e[10] = g))
		: (g = e[10]);
	let v;
	e[11] !== p
		? ((v = {
				borderRadius: "xsmall",
				gridArea: "thumbnail",
				marginEnd: "regular",
				overflow: "hidden",
				height: p,
				UNSAFE_className: g,
			}),
			(e[11] = p),
			(e[12] = v))
		: (v = e[12]);
	let b;
	e[13] === Symbol.for("react.memo_cache_sentinel")
		? ((b = { isHidden: !0, UNSAFE_className: Dn.element("actions") }),
			(e[13] = b))
		: (b = e[13]);
	let y;
	e[14] === Symbol.for("react.memo_cache_sentinel")
		? ((y = { isHidden: !0, UNSAFE_className: Dn.element("actions") }),
			(e[14] = y))
		: (y = e[14]);
	let x;
	e[15] === Symbol.for("react.memo_cache_sentinel")
		? ((x = { isHidden: !0, UNSAFE_className: Dn.element("actionmenu") }),
			(e[15] = x))
		: (x = e[15]);
	let C;
	e[16] !== v
		? ((C = {
				text: f,
				description: h,
				image: v,
				button: b,
				actionGroup: y,
				actionMenu: x,
			}),
			(e[16] = v),
			(e[17] = C))
		: (C = e[17]);
	let k;
	e[18] !== n.rendered
		? ((k = $n(n.rendered)
				? m.jsx(ue, { children: n.rendered })
				: n.rendered),
			(e[18] = n.rendered),
			(e[19] = k))
		: (k = e[19]);
	let w;
	e[20] !== s || e[21] !== r
		? ((w =
				s &&
				m.jsx(ke, {
					alignItems: "center",
					backgroundColor: "accentEmphasis",
					borderRadius: "small",
					gridArea: "badge",
					minWidth: "element.small",
					padding: "small",
					UNSAFE_className: Dn.element("badge"),
					children: m.jsx(ue, {
						align: "center",
						color: "inverse",
						size: "small",
						weight: "medium",
						children: r,
					}),
				})),
			(e[20] = s),
			(e[21] = r),
			(e[22] = w))
		: (w = e[22]);
	let D;
	e[23] !== C || e[24] !== k || e[25] !== w
		? ((D = m.jsx(gd, {
				UNSAFE_className: c,
				columns: "auto auto 1fr auto",
				rows: "1fr auto",
				areas: d,
				alignItems: "center",
				children: m.jsxs(Cn, { slots: C, children: [k, w] }),
			})),
			(e[23] = C),
			(e[24] = k),
			(e[25] = w),
			(e[26] = D))
		: (D = e[26]);
	let S;
	return (
		e[27] !== a || e[28] !== l || e[29] !== D
			? ((S = m.jsx("div", {
					...a,
					style: l,
					className: u,
					children: D,
				})),
				(e[27] = a),
				(e[28] = l),
				(e[29] = D),
				(e[30] = S))
			: (S = e[30]),
		S
	);
}
function vI(t) {
	let { dropState: e, dragAndDropHooks: n } = D3();
	const { target: r, isPresentationOnly: i } = t;
	wt(
		!!n.useDropIndicator,
		"dragAndDropHooks.useDropIndicator is not defined.",
	);
	let o = E.useRef(null),
		{ dropIndicatorProps: s } = n.useDropIndicator(t, e, o),
		{ visuallyHiddenProps: a } = Ea(),
		l = e.isDropTarget(r);
	return !l && s["aria-hidden"]
		? null
		: m.jsx("div", {
				role: "row",
				"aria-hidden": s["aria-hidden"],
				children: m.jsx($M, {
					role: "gridcell",
					"aria-selected": "false",
					isDropTarget: l,
					children:
						!i &&
						m.jsx("div", { ...a, role: "button", ...s, ref: o }),
				}),
			});
}
function Rxe(t) {
	var e, n, r, i;
	let { item: o } = t,
		{
			density: s,
			dragAndDropHooks: a,
			dragState: l,
			dropState: u,
			isListDraggable: c,
			isListDroppable: d,
			layout: f,
			loadingState: h,
			overflowMode: p,
			state: g,
		} = D3(),
		{ direction: v } = Vt(),
		b = E.useRef(null),
		{ isFocusVisible: y, focusProps: x } = ha({ within: !0 }),
		{ isFocusVisible: C, focusProps: k } = ha(),
		{
			rowProps: w,
			gridCellProps: D,
			isPressed: S,
			descriptionProps: $,
			isDisabled: A,
			allowsSelection: T,
			hasAction: I,
		} = Bxe({ node: o, isVirtualized: !0, shouldSelectOnPressUp: c }, g, b),
		F = d && !A,
		{ hoverProps: N, isHovered: O } = gn({ isDisabled: !T && !I }),
		{ checkboxProps: _ } = Ixe({ key: o.key }, g),
		j;
	c &&
		(wt(
			!!(a && a.useDraggableItem),
			"useDraggableItem is missing from dragAndDropHooks",
		),
		(j = a.useDraggableItem({ key: o.key, hasDragButton: !0 }, l)),
		A && (j = null));
	let V,
		K,
		M = E.useRef(null);
	if (d) {
		let Ae = { type: "item", key: o.key, dropPosition: "on" };
		(V = u.isDropTarget(Ae)),
			wt(
				!!(a && a.useDropIndicator),
				"useDropIndicator is missing from dragAndDropHooks",
			),
			(K = a.useDropIndicator({ target: Ae }, u, M));
	}
	let G = E.useRef(null),
		{ buttonProps: H } = Yo(
			{
				...((e = j) === null || e === void 0
					? void 0
					: e.dragButtonProps),
				elementType: "div",
			},
			G,
		),
		P = m.jsx(ve, {
			...lt({ disabled: !I, visible: o.props.hasChildItems }),
			color: "neutral",
			src: v === "ltr" ? PH : FH,
			"aria-hidden": "true",
			UNSAFE_className: Se(
				Dn.element("parent-indicator"),
				X({
					display: "none",
					gridArea: "chevron",
					marginInlineStart: B.size.space.regular,
					[`${Dn.selector("root")}[data-child-nodes=true] &`]: {
						display: "inline-block",
						visibility: "hidden",
					},
					"&[data-visible=true]": { visibility: "visible" },
					"&[data-disabled=true]": {
						stroke: B.color.alias.foregroundDisabled,
					},
				}),
			),
		}),
		q =
			g.selectionManager.selectionMode !== "none" &&
			g.selectionManager.selectionBehavior === "toggle",
		{ visuallyHiddenProps: J } = Ea(),
		Z = F ? void 0 : { "aria-hidden": void 0 };
	const oe = xe(
		w,
		(n = j) === null || n === void 0 ? void 0 : n.dragProps,
		Z,
		N,
		x,
		k,
		(a == null ? void 0 : a.isVirtualDragging()) && { tabIndex: null },
	);
	let ne = o.prevKey == null,
		de = o.nextKey == null,
		se = !1;
	if (de && h !== "loadingMore") {
		var re, he;
		((re = f.getContentSize()) === null || re === void 0
			? void 0
			: re.height) >=
			((he = f.virtualizer) === null || he === void 0
				? void 0
				: he.visibleRect.height) && (se = !0);
	}
	let ye = $n(o.rendered) ? m.jsx(ue, { children: o.rendered }) : o.rendered;
	return (
		A && (ye = m.jsx(Hh, { isDisabled: !0, children: ye })),
		m.jsx("div", {
			...oe,
			...lt({ "flush-last": se }),
			className: Se(
				Dn.element("row"),
				X({
					cursor: "default",
					outline: 0,
					position: "relative",
					"&:not([data-flush-last=true])::after": {
						boxShadow: `inset 0 -1px 0 0 ${B.color.border.neutral}`,
						content: '" "',
						display: "block",
						insetBlockEnd: 0,
						insetBlockStart: 0,
						insetInlineEnd: 0,
						insetInlineStart: 0,
						pointerEvents: "none",
						position: "absolute",
						zIndex: 3,
					},
				}),
			),
			ref: b,
			children: m.jsx("div", {
				...lt({
					first: ne || void 0,
					last: de || void 0,
					droppable: V || void 0,
					draggable: c || void 0,
					focus: C ? "visible" : y ? "within" : void 0,
					interaction: S ? "press" : O ? "hover" : void 0,
				}),
				className: Se(
					Dn.element("root"),
					X({
						display: "grid",
						paddingInline: B.size.space.medium,
						position: "relative",
						outline: 0,
						minHeight: B.size.element.medium,
						paddingBlock: B.size.space.medium,
						[`${my.selector("root")}[data-density="compact"] &`]: {
							minHeight: B.size.element.regular,
							paddingBlock: B.size.space.regular,
						},
						[`${my.selector("root")}[data-density="spacious"] &`]: {
							minHeight: B.size.element.large,
							paddingBlock: B.size.space.large,
						},
						"&[data-draggable=true]": {
							paddingInlineStart: B.size.space.small,
						},
						'&[data-interaction="hover"]': {
							backgroundColor: B.color.alias.backgroundHovered,
						},
						'&[data-interaction="press"]': {
							backgroundColor: B.color.alias.backgroundPressed,
						},
						'&[data-focus="visible"]': {
							"&::before": {
								backgroundColor:
									B.color.background.accentEmphasis,
								borderRadius: B.size.space.small,
								content: '""',
								insetBlock: 0,
								insetInlineStart: B.size.space.xsmall,
								marginBlock: B.size.space.xsmall,
								marginInlineEnd: `calc(${B.size.space.small} * -1)`,
								position: "absolute",
								width: B.size.space.small,
							},
						},
						[`${Dn.selector("row")}[aria-selected="true"] &`]: {
							backgroundColor: B.color.alias.backgroundSelected,
							'&[data-interaction="hover"], &[data-focus="visible"]':
								{
									backgroundColor:
										B.color.alias.backgroundSelectedHovered,
								},
						},
					}),
				),
				...D,
				children: m.jsxs(gd, {
					UNSAFE_className: Dn.element("grid"),
					columns: "auto auto auto 1fr minmax(0px, auto) auto auto",
					rows: "1fr auto",
					areas: [
						"draghandle checkbox thumbnail content actions actionmenu chevron",
						"draghandle checkbox thumbnail description actions actionmenu chevron",
					],
					alignItems: "center",
					children: [
						c &&
							m.jsx("div", {
								className: Se(
									X({
										gridArea: "draghandle",
										display: "flex",
										justifyContent: "center",
										width: B.size.element.small,
									}),
								),
								children:
									!A &&
									m.jsx(xn, {
										children: m.jsx("div", {
											...H,
											className: Se(
												Dn.element("draghandle"),
												X({
													outline: 0,
													position: "relative",
													"::after": {
														borderRadius:
															B.size.radius.small,
														content: '""',
														inset: 0,
														margin: 0,
														position: "absolute",
														transition: bt(
															[
																"box-shadow",
																"margin",
															],
															{
																easing: "easeOut",
															},
														),
													},
													"&[data-focus=visible]::after":
														{
															boxShadow: `0 0 0 ${B.size.alias.focusRing} ${B.color.alias.focusRing}`,
															margin: `calc(${B.size.alias.focusRingGap} * -1)`,
														},
												}),
											),
											ref: G,
											draggable: "true",
											children: m.jsx(ve, {
												src: PO,
												color: "neutral",
											}),
										}),
									}),
							}),
						d &&
							!((r = K) !== null && r !== void 0 && r.isHidden) &&
							m.jsx("div", {
								role: "button",
								...J,
								...((i = K) === null || i === void 0
									? void 0
									: i.dropIndicatorProps),
								ref: M,
							}),
						q &&
							m.jsx(ke, {
								gridArea: "checkbox",
								alignItems: "center",
								justifyContent: "center",
								children: m.jsx(p0, {
									..._,
									UNSAFE_className: Se(
										Dn.element("checkbox"),
										X({
											paddingInlineEnd:
												B.size.space.regular,
										}),
									),
								}),
							}),
						m.jsxs(Cn, {
							slots: {
								text: {
									color: A
										? "color.alias.foregroundDisabled"
										: void 0,
									gridArea: "content",
									flexGrow: 1,
									truncate: p === "truncate",
									weight: "medium",
									UNSAFE_className: Dn.element("content"),
								},
								description: {
									color: A
										? "color.alias.foregroundDisabled"
										: "neutralSecondary",
									size: "small",
									gridArea: "description",
									flexGrow: 1,
									marginTop: "regular",
									truncate: p === "truncate",
									UNSAFE_className: Dn.element("description"),
									...$,
								},
								image: {
									borderRadius: "xsmall",
									gridArea: "thumbnail",
									marginEnd: "regular",
									overflow: "hidden",
									height:
										s === "compact"
											? "element.small"
											: "element.regular",
									UNSAFE_className: Dn.element("thumbnail"),
								},
								button: {
									UNSAFE_className: Dn.element("actions"),
									prominence: "low",
									gridArea: "actions",
								},
								actionGroup: {
									UNSAFE_className: Dn.element("actions"),
									prominence: "low",
									gridArea: "actions",
									density: "compact",
								},
								actionMenu: {
									UNSAFE_className: Dn.element("actionmenu"),
									prominence: "low",
									gridArea: "actionmenu",
								},
							},
							children: [ye, m.jsx(c0, { children: P })],
						}),
					],
				}),
			}),
		})
	);
}
class Oxe extends ND {
	constructor() {
		super(...arguments);
		Fe(this, "isLoading", !1);
	}
	update(n) {
		var r;
		(this.isLoading =
			((r = n.layoutOptions) === null || r === void 0
				? void 0
				: r.isLoading) || !1),
			super.update(n);
	}
	buildCollection() {
		let n = super.buildCollection(),
			r = this.contentSize.height;
		if (this.isLoading) {
			let i = new St(
					0,
					r,
					this.virtualizer.visibleRect.width,
					n.length === 0
						? this.virtualizer.visibleRect.height
						: this.estimatedRowHeight,
				),
				o = new er("loader", "loader", i),
				s = { layoutInfo: o, validRect: o.rect };
			n.push(s), this.layoutNodes.set(o.key, s), (r = o.rect.maxY);
		}
		if (n.length === 0) {
			let i = new St(
					0,
					r,
					this.virtualizer.visibleRect.width,
					this.virtualizer.visibleRect.height,
				),
				o = new er("placeholder", "placeholder", i),
				s = { layoutInfo: o, validRect: o.rect };
			n.push(s), this.layoutNodes.set(o.key, s), (r = o.rect.maxY);
		}
		return (this.contentSize.height = r), n;
	}
	buildItem(n, r, i) {
		let o = super.buildItem(n, r, i);
		return (o.layoutInfo.allowOverflow = !0), o;
	}
}
function Mxe() {
	let { dropState: t, dragAndDropHooks: e } = D3(),
		n = E.useRef(null);
	wt(
		!!e.useDropIndicator,
		"dragAndDropHooks.useDropIndicator is not defined.",
	);
	let { dropIndicatorProps: r } = e.useDropIndicator(
			{ target: { type: "root" } },
			t,
			n,
		),
		i = t.isDropTarget({ type: "root" }),
		{ visuallyHiddenProps: o } = Ea();
	return !i && r["aria-hidden"]
		? null
		: m.jsx("div", {
				role: "row",
				"aria-hidden": r["aria-hidden"],
				children: m.jsx("div", {
					role: "gridcell",
					"aria-selected": "false",
					children: m.jsx("div", {
						role: "button",
						...o,
						...r,
						ref: n,
					}),
				}),
			});
}
const jxe = {
	compact: { medium: 32, large: 40 },
	regular: { medium: 40, large: 50 },
	spacious: { medium: 48, large: 60 },
};
function _xe(t, e, n) {
	const r = ce(2),
		{ scale: i } = Rs();
	let o;
	const s = n === "wrap" ? void 0 : jxe[e][i];
	let a;
	return (
		r[0] !== s
			? ((a = new Oxe({ estimatedRowHeight: s })), (r[0] = s), (r[1] = a))
			: (a = r[1]),
		(o = a),
		o
	);
}
function zxe(t, e) {
	var n, r;
	let {
			density: i = "regular",
			loadingState: o,
			onLoadMore: s,
			isQuiet: a,
			overflowMode: l = "truncate",
			onAction: u,
			dragAndDropHooks: c,
			renderEmptyState: d,
			...f
		} = t,
		h = !!(c != null && c.useDraggableCollectionState),
		p = !!(c != null && c.useDroppableCollectionState),
		g = E.useRef(h),
		v = E.useRef(p);
	E.useEffect(() => {
		g.current !== h &&
			console.warn(
				"Drag hooks were provided during one render, but not another. This should be avoided as it may produce unexpected behavior.",
			),
			v.current !== p &&
				console.warn(
					"Drop hooks were provided during one render, but not another. This should be avoided as it may produce unexpected behavior.",
				);
	}, [h, p]);
	let b = Ct(e),
		y = y0({
			...t,
			selectionBehavior:
				t.selectionStyle === "highlight" ? "replace" : "toggle",
		}),
		{ collection: x, selectionManager: C } = y,
		k = Le(Pxe),
		w = o === "loading" || o === "loadingMore",
		D = ht(t),
		S = E.useRef(null),
		$;
	h &&
		c !== null &&
		c !== void 0 &&
		c.useDraggableCollectionState &&
		c !== null &&
		c !== void 0 &&
		c.useDraggableCollection &&
		(($ = c.useDraggableCollectionState({
			collection: x,
			selectionManager: C,
			preview: S,
		})),
		c.useDraggableCollection({}, $, b));
	let A = _xe(y, t.density || "regular", l),
		T = c == null ? void 0 : c.DragPreview,
		I,
		F,
		N;
	if (
		p &&
		c !== null &&
		c !== void 0 &&
		c.useDroppableCollectionState &&
		c !== null &&
		c !== void 0 &&
		c.useDroppableCollection
	) {
		var O;
		(I = c.useDroppableCollectionState({
			collection: x,
			selectionManager: C,
		})),
			(F = c.useDroppableCollection(
				{
					keyboardDelegate: new Xh({
						collection: x,
						disabledKeys:
							(O = $) !== null &&
							O !== void 0 &&
							O.draggingKeys.size
								? void 0
								: C.disabledKeys,
						ref: b,
						layoutDelegate: A,
					}),
					dropTargetDelegate: A,
				},
				I,
				b,
			)),
			(N = I.isDropTarget({ type: "root" }));
	}
	let { gridProps: _ } = Txe(
			{ ...t, isVirtualized: !0, layoutDelegate: A, onAction: u },
			y,
			b,
		),
		j = C.focusedKey,
		V = null;
	if (
		((n = I) === null ||
		n === void 0 ||
		(n = n.target) === null ||
		n === void 0
			? void 0
			: n.type) === "item" &&
		((V = I.target.key), I.target.dropPosition === "after")
	) {
		var K;
		V = (K = y.collection.getKeyAfter(V)) !== null && K !== void 0 ? K : V;
	}
	let M = E.useMemo(() => new Set([j, V].filter((H) => H !== null)), [j, V]),
		G = E.useMemo(() => [...x].some((H) => H.hasChildNodes), [x]);
	return m.jsxs(Fxe, {
		value: {
			density: i,
			dragAndDropHooks: c,
			dragState: $,
			dropState: I,
			isListDraggable: h,
			isListDroppable: p,
			layout: A,
			loadingState: o,
			onAction: u,
			overflowMode: l,
			renderEmptyState: d,
			state: y,
		},
		children: [
			m.jsx(nc, {
				children: m.jsx(xn, {
					children: m.jsx($O, {
						...xe(
							p
								? (r = F) === null || r === void 0
									? void 0
									: r.collectionProps
								: {},
							_,
						),
						...Ge(f),
						..._,
						...D,
						...lt({
							childNodes: G,
							density: i,
							draggable: h,
							dropTarget: N,
							overflowMode: l,
						}),
						isLoading: w,
						onLoadMore: s,
						ref: b,
						persistedKeys: M,
						scrollDirection: "vertical",
						layout: A,
						layoutOptions: E.useMemo(() => ({ isLoading: w }), [w]),
						collection: x,
						className: Se(
							my.element("root"),
							X({
								backgroundColor: B.color.background.canvas,
								border: `${B.size.border.regular} solid ${B.color.border.neutral}`,
								borderRadius: B.size.radius.medium,
								boxSizing: "content-box",
								outline: 0,
								overflow: "auto",
								position: "relative",
								transform: "translate3d(0, 0, 0)",
								userSelect: "none",
								"&[data-drop-target=true]": {
									borderColor: B.color.alias.focusRing,
									backgroundColor:
										B.color.alias.backgroundSelected,
									boxShadow: `inset 0 0 0 1px ${B.color.alias.focusRing}`,
								},
								"&[data-focus=visible]": {
									borderColor: B.color.alias.focusRing,
									boxShadow: `inset 0 0 0 1px ${B.color.alias.focusRing}`,
								},
							}),
							D.className,
						),
						children: (H, P) => {
							if (H === "item")
								return m.jsxs(m.Fragment, {
									children: [
										p &&
											x.getKeyBefore(P.key) == null &&
											m.jsx(Mxe, {}, "root"),
										p &&
											m.jsx(
												vI,
												{
													target: {
														key: P.key,
														type: "item",
														dropPosition: "before",
													},
												},
												`${P.key}-before`,
											),
										m.jsx(Rxe, {
											item: P,
											isEmphasized: !0,
											hasActions: !!u,
										}),
										p &&
											m.jsx(
												vI,
												{
													target: {
														key: P.key,
														type: "item",
														dropPosition: "after",
													},
													isPresentationOnly:
														x.getKeyAfter(P.key) !=
														null,
												},
												`${P.key}-after`,
											),
									],
								});
							if (H === "loader")
								return m.jsx(yI, {
									children: m.jsx(Cr, {
										isIndeterminate: !0,
										size:
											i === "compact" ? "small" : void 0,
										"aria-label":
											x.size > 0
												? k.format("loadingMore")
												: k.format("loading"),
									}),
								});
							if (H === "placeholder") {
								let q = t.renderEmptyState
									? t.renderEmptyState()
									: null;
								return q == null
									? null
									: m.jsx(yI, { children: q });
							}
						},
					}),
				}),
			}),
			T &&
				h &&
				m.jsx(T, {
					ref: S,
					children: () => {
						let H = y.collection.getItem($.draggedKey);
						wt(H != null, "Dragged item must exist in collection.");
						let P = $.draggingKeys.size,
							q = A.getLayoutInfo($.draggedKey).rect.height;
						return m.jsx(Nxe, {
							item: H,
							itemCount: P,
							itemHeight: q,
							density: i,
						});
					},
				}),
		],
	});
}
function yI({ children: t }) {
	let { state: e } = D3();
	return m.jsx("div", {
		role: "row",
		"aria-rowindex": e.collection.size + 1,
		"data-has-items": e.collection.size > 0,
		className: Se(
			my.element("centered-wrapper"),
			X({
				display: "flex",
				justifyContent: "center",
				alignItems: "center",
				height: "100%",
				width: "100%",
				"&[data-has-items=true]": { paddingTop: B.size.space.regular },
			}),
		),
		children: m.jsx("div", { role: "gridcell", children: t }),
	});
}
const RH = le.forwardRef(zxe),
	OH = E.createContext({ activity: void 0, id: "", isCollapsed: void 0 }),
	Lxe = OH.Provider;
function D5() {
	return E.useContext(OH);
}
let _2 = null,
	Rc = null;
function Vxe(t, e) {
	switch (t) {
		case "horizontal":
			return "ew-resize";
		case "horizontal-max":
			return e ? "e-resize" : "w-resize";
		case "horizontal-min":
			return e ? "w-resize" : "e-resize";
	}
}
function Kxe() {
	Rc !== null && (document.head.removeChild(Rc), (_2 = null), (Rc = null));
}
function Uxe(t, e) {
	if (_2 === t) return;
	_2 = t;
	const n = Vxe(t, e);
	Rc === null &&
		((Rc = document.createElement("style")), document.head.appendChild(Rc)),
		(Rc.innerHTML = `*{cursor: ${n}!important;}`);
}
function xI(t) {
	try {
		if (typeof localStorage < "u")
			(t.getItem = (e) => localStorage.getItem(e)),
				(t.setItem = (e, n) => {
					localStorage.setItem(e, n);
				});
		else throw new Error("localStorage not supported in this environment");
	} catch (e) {
		console.error(e), (t.getItem = () => null), (t.setItem = () => {});
	}
}
const sm = {
	getItem: (t) => (xI(sm), sm.getItem(t)),
	setItem: (t, e) => {
		xI(sm), sm.setItem(t, e);
	},
};
function kI(t) {
	return qxe(t) ? t.clientX : Gxe(t) ? t.touches[0].clientX : 0;
}
function Hxe(t, e, n) {
	return Math.round(((t - e) / (n - e)) * 100);
}
function S5(t) {
	return `primary-pane-${t}`;
}
function MH(t) {
	return `secondary-pane-${t}`;
}
function jH(t) {
	return `resize-handle-${t}`;
}
function CI(t) {
	return document.getElementById(S5(t));
}
function Wxe(t) {
	return document.getElementById(MH(t));
}
function wI(t) {
	return document.getElementById(jH(t));
}
function bf(t) {
	return `${t}px`;
}
function qxe(t) {
	return t.type.startsWith("mouse");
}
function Gxe(t) {
	return t.type.startsWith("touch");
}
const _H = "--primary-pane-max-width",
	Yxe = `var(${_H})`,
	zH = "--primary-pane-min-width",
	Jxe = `var(${zH})`,
	$b = "--primary-pane-width",
	Xxe = `var(${$b})`,
	Zxe = 32,
	Qxe = 10;
function LH(t) {
	const e = ce(62),
		{
			autoSaveId: n,
			children: r,
			defaultSize: i,
			isCollapsed: o,
			minSize: s,
			maxSize: a,
			onCollapseChange: l,
			onResize: u,
			storage: c,
		} = t,
		d = c === void 0 ? sm : c,
		[f, h] = r,
		p = zne(),
		g = _ne(t.id),
		{ direction: v } = Vt(),
		b = ht(t),
		[y, x] = E.useState(!1),
		[C, k] = E.useState(!1),
		[w, D] = E.useState(!1);
	let S;
	e[0] !== i || e[1] !== n || e[2] !== d
		? ((S = () => {
				let he = i;
				if (n) {
					const ye = d.getItem(n);
					ye && (he = Number.parseInt(ye));
				}
				return he;
			}),
			(e[0] = i),
			(e[1] = n),
			(e[2] = d),
			(e[3] = S))
		: (S = e[3]);
	const [$, A] = E.useState(S),
		T = E.useRef(null),
		I = E.useRef(0),
		F = E.useRef(0);
	let N, O;
	e[4] !== g || e[5] !== v
		? ((N = () => {
				const he = wI(g),
					ye = CI(g),
					Ae = Wxe(g);
				x(
					v === "rtl"
						? (he == null ? void 0 : he.previousElementSibling) ===
								ye
						: (he == null ? void 0 : he.previousElementSibling) ===
								Ae,
				);
			}),
			(O = [v, g]),
			(e[4] = g),
			(e[5] = v),
			(e[6] = N),
			(e[7] = O))
		: ((N = e[6]), (O = e[7])),
		E.useEffect(N, O);
	let _;
	e[8] !== u || e[9] !== $
		? ((_ = () => (u == null ? void 0 : u($))),
			(e[8] = u),
			(e[9] = $),
			(e[10] = _))
		: (_ = e[10]);
	let j;
	e[11] !== $ ? ((j = [$]), (e[11] = $), (e[12] = j)) : (j = e[12]), o0(_, j);
	let V;
	e[13] !== $ || e[14] !== n || e[15] !== d
		? ((V = () => {
				var he;
				(he = T.current) === null ||
					he === void 0 ||
					he.style.setProperty($b, bf($)),
					(F.current = $),
					n && d.setItem(n, bf($));
			}),
			(e[13] = $),
			(e[14] = n),
			(e[15] = d),
			(e[16] = V))
		: (V = e[16]);
	let K;
	e[17] !== n || e[18] !== u || e[19] !== $ || e[20] !== d
		? ((K = [n, u, $, d]),
			(e[17] = n),
			(e[18] = u),
			(e[19] = $),
			(e[20] = d),
			(e[21] = K))
		: (K = e[21]),
		E.useEffect(V, K);
	let M, G;
	e[22] !== g ||
	e[23] !== o ||
	e[24] !== y ||
	e[25] !== $ ||
	e[26] !== i ||
	e[27] !== s ||
	e[28] !== a ||
	e[29] !== l
		? ((M = () => {
				const he = T.current,
					ye = wI(g),
					Ae = CI(g);
				if (!he || !ye || !Ae) return;
				let Pe;
				Pe = !1;
				const we = typeof o == "boolean",
					Ke = (_e) => {
						_e.preventDefault();
						let We = kI(_e) - I.current;
						y && (We = We * -1);
						let Et = $ + We;
						Math.abs(Et - i) < Zxe / 2 && (Et = i),
							we && (Pe = Et <= s / 2),
							Pe
								? (Ae.style.setProperty("width", "0px"),
									(F.current = $))
								: ((F.current = Et),
									Ae.style.removeProperty("width")),
							he.style.setProperty($b, bf(F.current));
						let ae = "horizontal";
						F.current < s && (ae = "horizontal-min"),
							F.current > a && (ae = "horizontal-max"),
							Uxe(ae, y);
					},
					rt = () => {
						ye.blur(),
							k(!1),
							Kxe(),
							Pe
								? (l == null || l(!o),
									Ae.style.removeProperty("width"))
								: A(rl(F.current, s, a)),
							(Pe = !1),
							document.body.removeEventListener("mousemove", Ke),
							document.body.removeEventListener("touchmove", Ke),
							window.removeEventListener("mouseup", rt),
							window.removeEventListener("touchend", rt);
					},
					Ce = (_e) => {
						("button" in _e && _e.button !== 0) ||
							("touches" in _e && _e.touches.length !== 1) ||
							(k(!0),
							(I.current = kI(_e)),
							document.body.addEventListener("mousemove", Ke),
							document.body.addEventListener("touchmove", Ke),
							window.addEventListener("mouseup", rt),
							window.addEventListener("touchend", rt));
					},
					Me = (_e) => {
						if (_e.defaultPrevented) return;
						const We = Math.round((a - s) / Qxe),
							Et = () => A((fe) => Math.min(fe + We, a)),
							ae = () => A((fe) => Math.max(fe - We, s));
						e: switch (_e.key) {
							case "Enter": {
								we && (_e.preventDefault(), l == null || l(!o));
								break e;
							}
							case "Home": {
								_e.preventDefault(), A(s);
								break e;
							}
							case "End": {
								_e.preventDefault(), A(a);
								break e;
							}
							case "ArrowLeft": {
								_e.preventDefault(), y ? Et() : ae();
								break e;
							}
							case "ArrowRight":
								_e.preventDefault(), y ? ae() : Et();
						}
					},
					me = { passive: !0 },
					De = (_e) => {
						_e.clientX === I.current && A(i);
					};
				return (
					ye.addEventListener("contextmenu", rt),
					ye.addEventListener("dblclick", De),
					ye.addEventListener("keydown", Me),
					ye.addEventListener("mousedown", Ce, me),
					ye.addEventListener("touchstart", Ce, me),
					() => {
						ye.removeEventListener("contextmenu", rt),
							ye.removeEventListener("dblclick", De),
							ye.removeEventListener("keydown", Me),
							ye.removeEventListener("mousedown", Ce),
							ye.removeEventListener("touchstart", Ce);
					}
				);
			}),
			(G = [a, s, i, g, y, $, l, o]),
			(e[22] = g),
			(e[23] = o),
			(e[24] = y),
			(e[25] = $),
			(e[26] = i),
			(e[27] = s),
			(e[28] = a),
			(e[29] = l),
			(e[30] = M),
			(e[31] = G))
		: ((M = e[30]), (G = e[31])),
		E.useEffect(M, G);
	const H = p() ? (C ? "pointer" : w ? "keyboard" : void 0) : "initializing";
	let P;
	e[32] !== g || e[33] !== o || e[34] !== H
		? ((P = { id: g, isCollapsed: o, activity: H }),
			(e[32] = g),
			(e[33] = o),
			(e[34] = H),
			(e[35] = P))
		: (P = e[35]);
	let q;
	e[36] !== t ? ((q = Ge(t)), (e[36] = t), (e[37] = q)) : (q = e[37]);
	let J;
	e[38] !== s || e[39] !== a || e[40] !== i || e[41] !== b.className
		? ((J = Se(
				X({
					display: "flex",
					height: "100%",
					width: "100%",
					overflow: "hidden",
					[zH]: bf(s),
					[_H]: bf(a),
					[$b]: bf(i),
				}),
				b.className,
			)),
			(e[38] = s),
			(e[39] = a),
			(e[40] = i),
			(e[41] = b.className),
			(e[42] = J))
		: (J = e[42]);
	let Z;
	e[43] !== $ || e[44] !== s || e[45] !== a
		? ((Z = Hxe($, s, a)),
			(e[43] = $),
			(e[44] = s),
			(e[45] = a),
			(e[46] = Z))
		: (Z = e[46]);
	let oe, ne;
	e[47] === Symbol.for("react.memo_cache_sentinel")
		? ((oe = () => D(!1)), (ne = () => D(!0)), (e[47] = oe), (e[48] = ne))
		: ((oe = e[47]), (ne = e[48]));
	let de;
	e[49] !== Z
		? ((de = m.jsx(e3e, {
				"aria-valuemin": 0,
				"aria-valuemax": 100,
				"aria-valuenow": Z,
				onBlur: oe,
				onFocus: ne,
			})),
			(e[49] = Z),
			(e[50] = de))
		: (de = e[50]);
	let se;
	e[51] !== b ||
	e[52] !== q ||
	e[53] !== T ||
	e[54] !== J ||
	e[55] !== f ||
	e[56] !== de ||
	e[57] !== h
		? ((se = m.jsxs("div", {
				...b,
				...q,
				ref: T,
				className: J,
				children: [f, de, h],
			})),
			(e[51] = b),
			(e[52] = q),
			(e[53] = T),
			(e[54] = J),
			(e[55] = f),
			(e[56] = de),
			(e[57] = h),
			(e[58] = se))
		: (se = e[58]);
	let re;
	return (
		e[59] !== P || e[60] !== se
			? ((re = m.jsx(Lxe, { value: P, children: se })),
				(e[59] = P),
				(e[60] = se),
				(e[61] = re))
			: (re = e[61]),
		re
	);
}
const VH = E.forwardRef(function (e, n) {
		const r = ce(15),
			{ activity: i, id: o, isCollapsed: s } = D5(),
			a = ht(e);
		let l;
		r[0] !== e ? ((l = Ge(e)), (r[0] = e), (r[1] = l)) : (l = r[1]);
		let u;
		r[2] !== o ? ((u = S5(o)), (r[2] = o), (r[3] = u)) : (u = r[3]);
		const c = s || void 0;
		let d;
		r[4] !== a.className
			? ((d = Se(
					X({
						containerType: "inline-size",
						overflow: "hidden",
						width: `clamp(${Jxe},${Xxe},${Yxe})`,
						maxWidth: "calc(100% - 100px)",
						"&[data-split-view-collapsed]": {
							visibility: "hidden",
							width: 0,
						},
						"&:not([data-split-view-activity])": {
							transition: bt("width"),
						},
						"&[data-split-view-activity=pointer]": {
							pointerEvents: "none",
						},
					}),
					a.className,
				)),
				(r[4] = a.className),
				(r[5] = d))
			: (d = r[5]);
		let f;
		return (
			r[6] !== a ||
			r[7] !== l ||
			r[8] !== n ||
			r[9] !== u ||
			r[10] !== i ||
			r[11] !== c ||
			r[12] !== d ||
			r[13] !== e.children
				? ((f = m.jsx("div", {
						...a,
						...l,
						ref: n,
						id: u,
						"data-split-pane": "primary",
						"data-split-view-activity": i,
						"data-split-view-collapsed": c,
						className: d,
						children: e.children,
					})),
					(r[6] = a),
					(r[7] = l),
					(r[8] = n),
					(r[9] = u),
					(r[10] = i),
					(r[11] = c),
					(r[12] = d),
					(r[13] = e.children),
					(r[14] = f))
				: (f = r[14]),
			f
		);
	}),
	KH = E.forwardRef(function (e, n) {
		const r = ce(14),
			{ id: i, activity: o } = D5(),
			s = ht(e);
		let a;
		r[0] !== e ? ((a = Ge(e)), (r[0] = e), (r[1] = a)) : (a = r[1]);
		let l;
		r[2] !== i ? ((l = MH(i)), (r[2] = i), (r[3] = l)) : (l = r[3]);
		let u;
		r[4] !== s.className
			? ((u = Se(
					X({
						containerType: "inline-size",
						flex: "1 1 0",
						minWidth: "100px",
						overflow: "hidden",
						"&[data-split-view-activity=pointer]": {
							pointerEvents: "none",
						},
					}),
					s.className,
				)),
				(r[4] = s.className),
				(r[5] = u))
			: (u = r[5]);
		let c;
		return (
			r[6] !== s ||
			r[7] !== a ||
			r[8] !== n ||
			r[9] !== l ||
			r[10] !== o ||
			r[11] !== u ||
			r[12] !== e.children
				? ((c = m.jsx("div", {
						...s,
						...a,
						ref: n,
						id: l,
						"data-split-pane": "secondary",
						"data-split-view-activity": o,
						className: u,
						children: e.children,
					})),
					(r[6] = s),
					(r[7] = a),
					(r[8] = n),
					(r[9] = l),
					(r[10] = o),
					(r[11] = u),
					(r[12] = e.children),
					(r[13] = c))
				: (c = r[13]),
			c
		);
	}),
	e3e = E.forwardRef(function (e, n) {
		const r = ce(12),
			{ activity: i, id: o, isCollapsed: s } = D5();
		let a;
		r[0] !== o ? ((a = S5(o)), (r[0] = o), (r[1] = a)) : (a = r[1]);
		let l;
		r[2] !== o ? ((l = jH(o)), (r[2] = o), (r[3] = l)) : (l = r[3]);
		const u = s || void 0;
		let c;
		r[4] === Symbol.for("react.memo_cache_sentinel")
			? ((c = X({
					backgroundColor: B.color.border.muted,
					boxSizing: "border-box",
					cursor: "ew-resize",
					flexShrink: 0,
					outline: 0,
					position: "relative",
					touchAction: "none",
					transition: bt("background-color"),
					userSelect: "none",
					width: B.size.border.regular,
					zIndex: 1,
					"&[data-split-view-collapsed]:not([data-split-view-activity])":
						t3e,
					"&::before": {
						content: '""',
						position: "absolute",
						inset: `calc(${B.size.space.small} * -1)`,
					},
					"&::after": {
						backgroundColor: B.color.alias.backgroundHovered,
						content: '""',
						insetBlock: 0,
						insetInline: `calc(${B.size.border.medium} * -1)`,
						opacity: 0,
						position: "absolute",
						transition: bt("opacity"),
					},
					"&:hover": {
						backgroundColor: B.color.border.neutral,
						transitionDelay: B.animation.duration.regular,
						"&::after": {
							opacity: 1,
							transitionDelay: B.animation.duration.regular,
						},
					},
					"&[data-split-view-activity=pointer]::after, &[data-split-view-activity=keyboard]::after":
						{
							backgroundColor: B.color.background.accentEmphasis,
							insetInline: `calc(${B.size.border.regular} * -1)`,
							opacity: 1,
						},
				})),
				(r[4] = c))
			: (c = r[4]);
		let d;
		return (
			r[5] !== e ||
			r[6] !== n ||
			r[7] !== a ||
			r[8] !== l ||
			r[9] !== i ||
			r[10] !== u
				? ((d = m.jsx("div", {
						...e,
						ref: n,
						"aria-controls": a,
						"aria-label": "Resize",
						"aria-orientation": "vertical",
						id: l,
						role: "separator",
						tabIndex: 0,
						"data-split-view-resize-handle": !0,
						"data-split-view-activity": i,
						"data-split-view-collapsed": u,
						className: c,
					})),
					(r[5] = e),
					(r[6] = n),
					(r[7] = a),
					(r[8] = l),
					(r[9] = i),
					(r[10] = u),
					(r[11] = d))
				: (d = r[11]),
			d
		);
	}),
	t3e = {
		border: 0,
		clip: "rect(0 0 0 0)",
		clipPath: "inset(50%)",
		height: "1px",
		margin: "-1px",
		overflow: "hidden",
		padding: 0,
		position: "absolute",
		width: "1px",
		whiteSpace: "nowrap",
	},
	n3e = m.jsxs(m.Fragment, {
		children: [
			m.jsx("rect", { width: 18, height: 18, x: 3, y: 3, rx: 2 }),
			m.jsx("path", { d: "M9 3v18M14 9l3 3-3 3" }),
		],
	}),
	r3e = m.jsxs(m.Fragment, {
		children: [
			m.jsx("rect", { width: 18, height: 18, x: 3, y: 3, rx: 2 }),
			m.jsx("path", { d: "M9 3v18M16 15l-3-3 3-3" }),
		],
	}),
	i3e = m.jsxs(m.Fragment, {
		children: [
			m.jsx("rect", { width: 18, height: 18, x: 3, y: 3, rx: 2 }),
			m.jsx("path", { d: "M15 3v18M10 15l-3-3 3-3" }),
		],
	}),
	o3e = m.jsxs(m.Fragment, {
		children: [
			m.jsx("rect", { width: 18, height: 18, x: 3, y: 3, rx: 2 }),
			m.jsx("path", { d: "M15 3v18M8 9l3 3-3 3" }),
		],
	}),
	$g = E.forwardRef(function (e, n) {
		const r = ce(20);
		let i, o, s;
		r[0] !== e
			? (({ children: s, tone: i, ...o } = e),
				(r[0] = e),
				(r[1] = i),
				(r[2] = o),
				(r[3] = s))
			: ((i = r[1]), (o = r[2]), (s = r[3]));
		const a = i === void 0 ? "neutral" : i,
			l = ht(o),
			u = a === "neutral" ? "surfaceSecondary" : a,
			c = a === "neutral" ? void 0 : a;
		let d, f;
		r[4] !== c
			? ((f = {
					icon: { color: c },
					text: { trim: !1, color: c, weight: "medium" },
				}),
				(r[4] = c),
				(r[5] = f))
			: (f = r[5]),
			(d = f);
		const h = d;
		let p;
		r[6] !== o
			? ((p = Ge(o, { labelable: !0 })), (r[6] = o), (r[7] = p))
			: (p = r[7]);
		let g;
		r[8] !== s
			? ((g = $n(s) ? m.jsx(ue, { children: s }) : s),
				(r[8] = s),
				(r[9] = g))
			: (g = r[9]);
		let v;
		r[10] !== h || r[11] !== g
			? ((v = m.jsx(Cn, { slots: h, children: g })),
				(r[10] = h),
				(r[11] = g),
				(r[12] = v))
			: (v = r[12]);
		let b;
		return (
			r[13] !== l.className ||
			r[14] !== l.style ||
			r[15] !== n ||
			r[16] !== p ||
			r[17] !== u ||
			r[18] !== v
				? ((b = m.jsx(ke, {
						UNSAFE_className: l.className,
						UNSAFE_style: l.style,
						ref: n,
						...p,
						backgroundColor: u,
						borderRadius: "full",
						height: "element.small",
						minWidth: 0,
						paddingX: "regular",
						alignItems: "center",
						flexShrink: 0,
						gap: "small",
						inline: !0,
						children: v,
					})),
					(r[13] = l.className),
					(r[14] = l.style),
					(r[15] = n),
					(r[16] = p),
					(r[17] = u),
					(r[18] = v),
					(r[19] = b))
				: (b = r[19]),
			b
		);
	}),
	z2 = B.size.space.large,
	UH = B.size.space.regular,
	L2 = B.size.space.small,
	A5 = B.size.space.medium,
	V2 = `calc(${L2} + ${UH} + ${A5})`,
	s3e = E.forwardRef(function (e, n) {
		const r = ce(19);
		let i, o;
		r[0] !== e
			? (({ children: o, ...i } = e), (r[0] = e), (r[1] = i), (r[2] = o))
			: ((i = r[1]), (o = r[2]));
		const s = Ct(n),
			a = ht(i),
			l = a3e(),
			u = l3e(s);
		let c, d;
		r[3] !== u
			? ((c = () => {
					u && u.scrollIntoView({ block: "center" });
				}),
				(d = [u]),
				(r[3] = u),
				(r[4] = c),
				(r[5] = d))
			: ((c = r[4]), (d = r[5])),
			E.useEffect(c, d);
		let f, h;
		r[6] !== l
			? ((h = {
					divider: {
						"aria-hidden": !0,
						elementType: "li",
						size: "medium",
						UNSAFE_className: l,
					},
				}),
				(r[6] = l),
				(r[7] = h))
			: (h = r[7]),
			(f = h);
		const p = f;
		let g;
		r[8] !== i
			? ((g = Ge(i, { labelable: !0 })), (r[8] = i), (r[9] = g))
			: (g = r[9]);
		let v;
		r[10] !== p || r[11] !== o
			? ((v = m.jsx(ke, {
					direction: "column",
					elementType: "ul",
					flex: "1 0 0",
					children: m.jsx(Cn, { slots: p, children: o }),
				})),
				(r[10] = p),
				(r[11] = o),
				(r[12] = v))
			: (v = r[12]);
		let b;
		return (
			r[13] !== s ||
			r[14] !== a.className ||
			r[15] !== a.style ||
			r[16] !== g ||
			r[17] !== v
				? ((b = m.jsx(ke, {
						elementType: "nav",
						ref: s,
						direction: "column",
						UNSAFE_className: a.className,
						UNSAFE_style: a.style,
						...g,
						children: v,
					})),
					(r[13] = s),
					(r[14] = a.className),
					(r[15] = a.style),
					(r[16] = g),
					(r[17] = v),
					(r[18] = b))
				: (b = r[18]),
			b
		);
	});
function a3e() {
	return X({
		marginBlock: z2,
		marginInlineStart: V2,
		width: `calc(40% - ${V2} - ${A5})`,
		minWidth: 80,
		maxWidth: 240,
	});
}
function l3e(t) {
	const e = ce(4),
		[n, r] = E.useState(null);
	let i;
	e[0] !== t.current
		? ((i = () => {
				const s =
					t.current && t.current.querySelector("[aria-current]");
				s && r(s);
			}),
			(e[0] = t.current),
			(e[1] = i))
		: (i = e[1]);
	let o;
	return (
		e[2] !== t ? ((o = [t]), (e[2] = t), (e[3] = o)) : (o = e[3]),
		at(i, o),
		n
	);
}
const HH = E.forwardRef(function (e, n) {
	const r = ce(31);
	let i, o, s, a;
	r[0] !== e
		? (({ "aria-current": s, children: o, href: a, ...i } = e),
			(r[0] = e),
			(r[1] = i),
			(r[2] = o),
			(r[3] = s),
			(r[4] = a))
		: ((i = r[1]), (o = r[2]), (s = r[3]), (a = r[4]));
	const l = u3e(),
		u = Ct(n),
		{ linkProps: c } = Wh(e, u);
	let d, f;
	r[5] !== l.text
		? ((f = { color: "inherit", UNSAFE_className: l.text }),
			(r[5] = l.text),
			(r[6] = f))
		: (f = r[6]);
	const h = f;
	let p;
	r[7] !== h ? ((p = { text: h }), (r[7] = h), (r[8] = p)) : (p = r[8]),
		(d = p);
	const g = d;
	let v;
	r[9] !== l.anchor
		? ((v = Se(l.anchor)), (r[9] = l.anchor), (r[10] = v))
		: (v = r[10]);
	let b;
	r[11] !== i ? ((b = Ge(i)), (r[11] = i), (r[12] = b)) : (b = r[12]);
	let y;
	r[13] !== l.content
		? ((y = Se(l.content)), (r[13] = l.content), (r[14] = y))
		: (y = r[14]);
	let x;
	r[15] !== o
		? ((x = $n(o) ? m.jsx(ue, { children: o }) : o),
			(r[15] = o),
			(r[16] = x))
		: (x = r[16]);
	let C;
	r[17] !== g || r[18] !== x
		? ((C = m.jsx(Cn, { slots: g, children: x })),
			(r[17] = g),
			(r[18] = x),
			(r[19] = C))
		: (C = r[19]);
	let k;
	r[20] !== y || r[21] !== C
		? ((k = m.jsx("div", { className: y, children: C })),
			(r[20] = y),
			(r[21] = C),
			(r[22] = k))
		: (k = r[22]);
	let w;
	return (
		r[23] !== u ||
		r[24] !== s ||
		r[25] !== a ||
		r[26] !== v ||
		r[27] !== c ||
		r[28] !== b ||
		r[29] !== k
			? ((w = m.jsx("li", {
					children: m.jsx(xn, {
						children: m.jsx("a", {
							ref: u,
							"aria-current": s,
							href: a,
							className: v,
							...c,
							...b,
							children: k,
						}),
					}),
				})),
				(r[23] = u),
				(r[24] = s),
				(r[25] = a),
				(r[26] = v),
				(r[27] = c),
				(r[28] = b),
				(r[29] = k),
				(r[30] = w))
			: (w = r[30]),
		w
	);
});
function u3e() {
	const t = B.color.alias.focusRing,
		e = B.size.alias.focusRing,
		n = X({
			color: B.color.foreground.neutral,
			display: "flex",
			gap: UH,
			paddingBlock: B.size.space.xsmall,
			outline: 0,
			"&::before": {
				borderRadius: L2,
				content: '""',
				insetInlineStart: B.size.space.xsmall,
				marginBlock: B.size.space.xsmall,
				position: "relative",
				width: L2,
			},
			"&:hover": { color: B.color.foreground.neutralEmphasis },
			"&[aria-current]:not([aria-current=false])": {
				color: B.color.foreground.neutralEmphasis,
				"&::before": {
					backgroundColor: B.color.background.accentEmphasis,
				},
			},
		}),
		r = X({
			alignItems: "center",
			borderRadius: B.size.radius.regular,
			display: "flex",
			flex: 1,
			flexShrink: 0,
			gap: B.size.space.regular,
			minHeight: B.size.element.regular,
			minWidth: 0,
			paddingInline: B.size.space.medium,
			paddingBlock: B.size.space.small,
			position: "relative",
			"&::after": {
				borderRadius: B.size.radius.regular,
				content: '""',
				insetBlock: 1,
				insetInline: -1,
				margin: 1,
				position: "absolute",
				transition: bt(["box-shadow", "margin"], { easing: "easeOut" }),
			},
			[`.${n}[data-focus=visible] &::after`]: {
				boxShadow: `0 0 0 ${e} ${t}`,
				margin: 0,
			},
			[`.${n}[aria-current]:not([aria-current=false]) &`]: {
				backgroundColor: B.color.alias.backgroundHovered,
			},
			[`.${n}:hover &`]: {
				backgroundColor: B.color.alias.backgroundHovered,
			},
			[`.${n}:active &`]: {
				backgroundColor: B.color.alias.backgroundPressed,
			},
		}),
		i = X({
			fontWeight: B.typography.fontWeight.regular,
			[`.${n}[aria-current]:not([aria-current=false]) &`]: {
				fontWeight: B.typography.fontWeight.medium,
			},
		});
	return { anchor: n, content: r, text: i };
}
function c3e(t) {
	const e = ce(21);
	let n, r, i, o;
	e[0] !== t
		? (({ children: o, id: n, title: i, ...r } = t),
			(e[0] = t),
			(e[1] = n),
			(e[2] = r),
			(e[3] = i),
			(e[4] = o))
		: ((n = e[1]), (r = e[2]), (i = e[3]), (o = e[4]));
	const s = Ot(n),
		a = d3e(),
		l = f3e();
	let u;
	e[5] !== a ? ((u = Se(a)), (e[5] = a), (e[6] = u)) : (u = e[6]);
	let c;
	e[7] !== r ? ((c = Ge(r)), (e[7] = r), (e[8] = c)) : (c = e[8]);
	let d;
	e[9] !== s || e[10] !== l || e[11] !== i
		? ((d = m.jsx(ue, {
				elementType: "h3",
				id: s,
				UNSAFE_className: l,
				children: i,
			})),
			(e[9] = s),
			(e[10] = l),
			(e[11] = i),
			(e[12] = d))
		: (d = e[12]);
	let f;
	e[13] !== s || e[14] !== o
		? ((f = m.jsx(pr, {
				elementType: "ul",
				flexShrink: 0,
				"aria-labelledby": s,
				children: o,
			})),
			(e[13] = s),
			(e[14] = o),
			(e[15] = f))
		: (f = e[15]);
	let h;
	return (
		e[16] !== u || e[17] !== c || e[18] !== d || e[19] !== f
			? ((h = m.jsxs("li", { className: u, ...c, children: [d, f] })),
				(e[16] = u),
				(e[17] = c),
				(e[18] = d),
				(e[19] = f),
				(e[20] = h))
			: (h = e[20]),
		h
	);
}
function d3e() {
	return X({
		"&:not(:first-child)": { marginBlockStart: z2 },
		"&:not(:last-child)": { marginBlockEnd: z2 },
	});
}
function f3e() {
	return X({
		color: B.color.foreground.neutralSecondary,
		fontSize: B.typography.text.small.size,
		fontWeight: B.typography.fontWeight.medium,
		paddingBlock: B.size.space.regular,
		paddingInlineEnd: A5,
		paddingInlineStart: V2,
		textTransform: "uppercase",
	});
}
const h3e = E.forwardRef(function (e, n) {
		const r = ce(13),
			{ children: i, role: o, tone: s } = e,
			a = s === void 0 ? "neutral" : s,
			l = ht(e);
		!i &&
			!e["aria-label"] &&
			console.warn(
				"If no children are provided, an aria-label must be specified",
			),
			!o &&
				(e["aria-label"] || e["aria-labelledby"]) &&
				console.warn("A labelled StatusLight must have a role.");
		let u;
		r[0] !== e
			? ((u = Ge(e, { labelable: !0 })), (r[0] = e), (r[1] = u))
			: (u = r[1]);
		let c;
		r[2] !== l.className
			? ((c = Se(
					X({
						alignItems: "center",
						color: B.color.foreground.neutral,
						display: "flex",
						gap: B.size.space.regular,
						height: B.size.element.small,
						"&::before": {
							content: '""',
							backgroundColor: B.color.foreground.neutralTertiary,
							borderRadius: B.size.radius.full,
							height: B.size.scale[100],
							width: B.size.scale[100],
						},
						"&[data-tone=neutral]": {
							color: B.color.foreground.neutralSecondary,
						},
						"&[data-tone=accent]::before": {
							backgroundColor: B.color.background.accentEmphasis,
						},
						"&[data-tone=caution]::before": {
							backgroundColor: B.color.background.cautionEmphasis,
						},
						"&[data-tone=critical]::before": {
							backgroundColor:
								B.color.background.criticalEmphasis,
						},
						"&[data-tone=pending]::before": {
							backgroundColor: B.color.background.pendingEmphasis,
						},
						"&[data-tone=positive]::before": {
							backgroundColor:
								B.color.background.positiveEmphasis,
						},
					}),
					l.className,
				)),
				(r[2] = l.className),
				(r[3] = c))
			: (c = r[3]);
		let d;
		r[4] !== i
			? ((d = $n(i) ? m.jsx(ue, { color: "inherit", children: i }) : i),
				(r[4] = i),
				(r[5] = d))
			: (d = r[5]);
		let f;
		return (
			r[6] !== u ||
			r[7] !== l ||
			r[8] !== n ||
			r[9] !== a ||
			r[10] !== c ||
			r[11] !== d
				? ((f = m.jsx("div", {
						...u,
						...l,
						ref: n,
						"data-tone": a,
						className: c,
						children: d,
					})),
					(r[6] = u),
					(r[7] = l),
					(r[8] = n),
					(r[9] = a),
					(r[10] = c),
					(r[11] = d),
					(r[12] = f))
				: (f = r[12]),
			f
		);
	}),
	p3e = m.jsx("path", {
		d: "M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4M16 17l5-5-5-5M21 12H9",
	}),
	gy = m.jsxs(m.Fragment, {
		children: [
			m.jsx("circle", { cx: 18, cy: 18, r: 3 }),
			m.jsx("circle", { cx: 6, cy: 6, r: 3 }),
			m.jsx("path", { d: "M13 6h3a2 2 0 0 1 2 2v7M6 9v12" }),
		],
	}),
	WH = m.jsxs(m.Fragment, {
		children: [
			m.jsx("path", {
				d: "M6 3v12M18 9a3 3 0 1 0 0-6 3 3 0 0 0 0 6zM6 21a3 3 0 1 0 0-6 3 3 0 0 0 0 6z",
			}),
			m.jsx("path", { d: "M15 6a9 9 0 0 0-9 9M18 15v6M21 18h-6" }),
		],
	}),
	m3e = m.jsxs(m.Fragment, {
		children: [
			m.jsx("circle", { cx: 12, cy: 18, r: 3 }),
			m.jsx("circle", { cx: 6, cy: 6, r: 3 }),
			m.jsx("circle", { cx: 18, cy: 6, r: 3 }),
			m.jsx("path", {
				d: "M18 9v2c0 .6-.4 1-1 1H7c-.6 0-1-.4-1-1V9M12 12v3",
			}),
		],
	}),
	g3e = m.jsxs(m.Fragment, {
		children: [
			m.jsx("rect", { width: 20, height: 14, x: 2, y: 3, rx: 2 }),
			m.jsx("path", { d: "M8 21h8M12 17v4" }),
		],
	}),
	qH = m.jsx("path", { d: "M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z" }),
	GH = m.jsxs(m.Fragment, {
		children: [
			m.jsx("circle", { cx: 12, cy: 12, r: 4 }),
			m.jsx("path", {
				d: "M12 2v2M12 20v2M4.93 4.93l1.41 1.41M17.66 17.66l1.41 1.41M2 12h2M20 12h2M6.34 17.66l-1.41 1.41M19.07 4.93l-1.41 1.41",
			}),
		],
	}),
	b3e = m.jsxs(m.Fragment, {
		children: [
			m.jsx("path", { d: "M19 21v-2a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v2" }),
			m.jsx("circle", { cx: 12, cy: 7, r: 4 }),
		],
	});
var YH = {};
YH = {
	buttonLabel: "عرض المقترحات",
	countAnnouncement: (t, e) =>
		`${e.plural(t.optionCount, { one: () => `${e.number(t.optionCount)} خيار`, other: () => `${e.number(t.optionCount)} خيارات` })} متاحة.`,
	focusAnnouncement: (t, e) =>
		`${e.select({ true: () => `المجموعة المدخلة ${t.groupTitle}, مع ${e.plural(t.groupCount, { one: () => `${e.number(t.groupCount)} خيار`, other: () => `${e.number(t.groupCount)} خيارات` })}. `, other: "" }, t.isGroupChange)}${t.optionText}${e.select({ true: ", محدد", other: "" }, t.isSelected)}`,
	listboxLabel: "مقترحات",
	selectedAnnouncement: (t) => `${t.optionText}، محدد`,
};
var JH = {};
JH = {
	buttonLabel: "Покажи предложения",
	countAnnouncement: (t, e) =>
		`${e.plural(t.optionCount, { one: () => `${e.number(t.optionCount)} опция`, other: () => `${e.number(t.optionCount)} опции` })} на разположение.`,
	focusAnnouncement: (t, e) =>
		`${e.select({ true: () => `Въведена група ${t.groupTitle}, с ${e.plural(t.groupCount, { one: () => `${e.number(t.groupCount)} опция`, other: () => `${e.number(t.groupCount)} опции` })}. `, other: "" }, t.isGroupChange)}${t.optionText}${e.select({ true: ", избрани", other: "" }, t.isSelected)}`,
	listboxLabel: "Предложения",
	selectedAnnouncement: (t) => `${t.optionText}, избрани`,
};
var XH = {};
XH = {
	buttonLabel: "Zobrazit doporučení",
	countAnnouncement: (t, e) =>
		`K dispozici ${e.plural(t.optionCount, { one: () => `je ${e.number(t.optionCount)} možnost`, other: () => `jsou/je ${e.number(t.optionCount)} možnosti/-í` })}.`,
	focusAnnouncement: (t, e) =>
		`${e.select({ true: () => `Zadaná skupina „${t.groupTitle}“ ${e.plural(t.groupCount, { one: () => `s ${e.number(t.groupCount)} možností`, other: () => `se ${e.number(t.groupCount)} možnostmi` })}. `, other: "" }, t.isGroupChange)}${t.optionText}${e.select({ true: " (vybráno)", other: "" }, t.isSelected)}`,
	listboxLabel: "Návrhy",
	selectedAnnouncement: (t) => `${t.optionText}, vybráno`,
};
var ZH = {};
ZH = {
	buttonLabel: "Vis forslag",
	countAnnouncement: (t, e) =>
		`${e.plural(t.optionCount, { one: () => `${e.number(t.optionCount)} mulighed tilgængelig`, other: () => `${e.number(t.optionCount)} muligheder tilgængelige` })}.`,
	focusAnnouncement: (t, e) =>
		`${e.select({ true: () => `Angivet gruppe ${t.groupTitle}, med ${e.plural(t.groupCount, { one: () => `${e.number(t.groupCount)} mulighed`, other: () => `${e.number(t.groupCount)} muligheder` })}. `, other: "" }, t.isGroupChange)}${t.optionText}${e.select({ true: ", valgt", other: "" }, t.isSelected)}`,
	listboxLabel: "Forslag",
	selectedAnnouncement: (t) => `${t.optionText}, valgt`,
};
var QH = {};
QH = {
	buttonLabel: "Empfehlungen anzeigen",
	countAnnouncement: (t, e) =>
		`${e.plural(t.optionCount, { one: () => `${e.number(t.optionCount)} Option`, other: () => `${e.number(t.optionCount)} Optionen` })} verfügbar.`,
	focusAnnouncement: (t, e) =>
		`${e.select({ true: () => `Eingetretene Gruppe ${t.groupTitle}, mit ${e.plural(t.groupCount, { one: () => `${e.number(t.groupCount)} Option`, other: () => `${e.number(t.groupCount)} Optionen` })}. `, other: "" }, t.isGroupChange)}${t.optionText}${e.select({ true: ", ausgewählt", other: "" }, t.isSelected)}`,
	listboxLabel: "Empfehlungen",
	selectedAnnouncement: (t) => `${t.optionText}, ausgewählt`,
};
var eW = {};
eW = {
	buttonLabel: "Προβολή προτάσεων",
	countAnnouncement: (t, e) =>
		`${e.plural(t.optionCount, { one: () => `${e.number(t.optionCount)} επιλογή`, other: () => `${e.number(t.optionCount)} επιλογές ` })} διαθέσιμες.`,
	focusAnnouncement: (t, e) =>
		`${e.select({ true: () => `Εισαγμένη ομάδα ${t.groupTitle}, με ${e.plural(t.groupCount, { one: () => `${e.number(t.groupCount)} επιλογή`, other: () => `${e.number(t.groupCount)} επιλογές` })}. `, other: "" }, t.isGroupChange)}${t.optionText}${e.select({ true: ", επιλεγμένο", other: "" }, t.isSelected)}`,
	listboxLabel: "Προτάσεις",
	selectedAnnouncement: (t) => `${t.optionText}, επιλέχθηκε`,
};
var tW = {};
tW = {
	focusAnnouncement: (t, e) =>
		`${e.select({ true: () => `Entered group ${t.groupTitle}, with ${e.plural(t.groupCount, { one: () => `${e.number(t.groupCount)} option`, other: () => `${e.number(t.groupCount)} options` })}. `, other: "" }, t.isGroupChange)}${t.optionText}${e.select({ true: ", selected", other: "" }, t.isSelected)}`,
	countAnnouncement: (t, e) =>
		`${e.plural(t.optionCount, { one: () => `${e.number(t.optionCount)} option`, other: () => `${e.number(t.optionCount)} options` })} available.`,
	selectedAnnouncement: (t) => `${t.optionText}, selected`,
	buttonLabel: "Show suggestions",
	listboxLabel: "Suggestions",
};
var nW = {};
nW = {
	buttonLabel: "Mostrar sugerencias",
	countAnnouncement: (t, e) =>
		`${e.plural(t.optionCount, { one: () => `${e.number(t.optionCount)} opción`, other: () => `${e.number(t.optionCount)} opciones` })} disponible(s).`,
	focusAnnouncement: (t, e) =>
		`${e.select({ true: () => `Se ha unido al grupo ${t.groupTitle}, con ${e.plural(t.groupCount, { one: () => `${e.number(t.groupCount)} opción`, other: () => `${e.number(t.groupCount)} opciones` })}. `, other: "" }, t.isGroupChange)}${t.optionText}${e.select({ true: ", seleccionado", other: "" }, t.isSelected)}`,
	listboxLabel: "Sugerencias",
	selectedAnnouncement: (t) => `${t.optionText}, seleccionado`,
};
var rW = {};
rW = {
	buttonLabel: "Kuva soovitused",
	countAnnouncement: (t, e) =>
		`${e.plural(t.optionCount, { one: () => `${e.number(t.optionCount)} valik`, other: () => `${e.number(t.optionCount)} valikud` })} saadaval.`,
	focusAnnouncement: (t, e) =>
		`${e.select({ true: () => `Sisestatud rühm ${t.groupTitle}, valikuga ${e.plural(t.groupCount, { one: () => `${e.number(t.groupCount)} valik`, other: () => `${e.number(t.groupCount)} valikud` })}. `, other: "" }, t.isGroupChange)}${t.optionText}${e.select({ true: ", valitud", other: "" }, t.isSelected)}`,
	listboxLabel: "Soovitused",
	selectedAnnouncement: (t) => `${t.optionText}, valitud`,
};
var iW = {};
iW = {
	buttonLabel: "Näytä ehdotukset",
	countAnnouncement: (t, e) =>
		`${e.plural(t.optionCount, { one: () => `${e.number(t.optionCount)} vaihtoehto`, other: () => `${e.number(t.optionCount)} vaihtoehdot` })} saatavilla.`,
	focusAnnouncement: (t, e) =>
		`${e.select({ true: () => `Mentiin ryhmään ${t.groupTitle}, ${e.plural(t.groupCount, { one: () => `${e.number(t.groupCount)} vaihtoehdon`, other: () => `${e.number(t.groupCount)} vaihtoehdon` })} kanssa.`, other: "" }, t.isGroupChange)}${t.optionText}${e.select({ true: ", valittu", other: "" }, t.isSelected)}`,
	listboxLabel: "Ehdotukset",
	selectedAnnouncement: (t) => `${t.optionText}, valittu`,
};
var oW = {};
oW = {
	buttonLabel: "Afficher les suggestions",
	countAnnouncement: (t, e) =>
		`${e.plural(t.optionCount, { one: () => `${e.number(t.optionCount)} option`, other: () => `${e.number(t.optionCount)} options` })} disponible(s).`,
	focusAnnouncement: (t, e) =>
		`${e.select({ true: () => `Groupe ${t.groupTitle} rejoint, avec ${e.plural(t.groupCount, { one: () => `${e.number(t.groupCount)} option`, other: () => `${e.number(t.groupCount)} options` })}. `, other: "" }, t.isGroupChange)}${t.optionText}${e.select({ true: ", sélectionné(s)", other: "" }, t.isSelected)}`,
	listboxLabel: "Suggestions",
	selectedAnnouncement: (t) => `${t.optionText}, sélectionné`,
};
var sW = {};
sW = {
	buttonLabel: "הצג הצעות",
	countAnnouncement: (t, e) =>
		`${e.plural(t.optionCount, { one: () => `אפשרות ${e.number(t.optionCount)}`, other: () => `${e.number(t.optionCount)} אפשרויות` })} במצב זמין.`,
	focusAnnouncement: (t, e) =>
		`${e.select({ true: () => `נכנס לקבוצה ${t.groupTitle}, עם ${e.plural(t.groupCount, { one: () => `אפשרות ${e.number(t.groupCount)}`, other: () => `${e.number(t.groupCount)} אפשרויות` })}. `, other: "" }, t.isGroupChange)}${t.optionText}${e.select({ true: ", נבחר", other: "" }, t.isSelected)}`,
	listboxLabel: "הצעות",
	selectedAnnouncement: (t) => `${t.optionText}, נבחר`,
};
var aW = {};
aW = {
	buttonLabel: "Prikaži prijedloge",
	countAnnouncement: (t, e) =>
		`Dostupno još: ${e.plural(t.optionCount, { one: () => `${e.number(t.optionCount)} opcija`, other: () => `${e.number(t.optionCount)} opcije/a` })}.`,
	focusAnnouncement: (t, e) =>
		`${e.select({ true: () => `Unesena skupina ${t.groupTitle}, s ${e.plural(t.groupCount, { one: () => `${e.number(t.groupCount)} opcijom`, other: () => `${e.number(t.groupCount)} opcije/a` })}. `, other: "" }, t.isGroupChange)}${t.optionText}${e.select({ true: ", odabranih", other: "" }, t.isSelected)}`,
	listboxLabel: "Prijedlozi",
	selectedAnnouncement: (t) => `${t.optionText}, odabrano`,
};
var lW = {};
lW = {
	buttonLabel: "Javaslatok megjelenítése",
	countAnnouncement: (t, e) =>
		`${e.plural(t.optionCount, { one: () => `${e.number(t.optionCount)} lehetőség`, other: () => `${e.number(t.optionCount)} lehetőség` })} áll rendelkezésre.`,
	focusAnnouncement: (t, e) =>
		`${e.select({ true: () => `Belépett a(z) ${t.groupTitle} csoportba, amely ${e.plural(t.groupCount, { one: () => `${e.number(t.groupCount)} lehetőséget`, other: () => `${e.number(t.groupCount)} lehetőséget` })} tartalmaz. `, other: "" }, t.isGroupChange)}${t.optionText}${e.select({ true: ", kijelölve", other: "" }, t.isSelected)}`,
	listboxLabel: "Javaslatok",
	selectedAnnouncement: (t) => `${t.optionText}, kijelölve`,
};
var uW = {};
uW = {
	buttonLabel: "Mostra suggerimenti",
	countAnnouncement: (t, e) =>
		`${e.plural(t.optionCount, { one: () => `${e.number(t.optionCount)} opzione disponibile`, other: () => `${e.number(t.optionCount)} opzioni disponibili` })}.`,
	focusAnnouncement: (t, e) =>
		`${e.select({ true: () => `Ingresso nel gruppo ${t.groupTitle}, con ${e.plural(t.groupCount, { one: () => `${e.number(t.groupCount)} opzione`, other: () => `${e.number(t.groupCount)} opzioni` })}. `, other: "" }, t.isGroupChange)}${t.optionText}${e.select({ true: ", selezionato", other: "" }, t.isSelected)}`,
	listboxLabel: "Suggerimenti",
	selectedAnnouncement: (t) => `${t.optionText}, selezionato`,
};
var cW = {};
cW = {
	buttonLabel: "候補を表示",
	countAnnouncement: (t, e) =>
		`${e.plural(t.optionCount, { one: () => `${e.number(t.optionCount)} 個のオプション`, other: () => `${e.number(t.optionCount)} 個のオプション` })}を利用できます。`,
	focusAnnouncement: (t, e) =>
		`${e.select({ true: () => `入力されたグループ ${t.groupTitle}、${e.plural(t.groupCount, { one: () => `${e.number(t.groupCount)} 個のオプション`, other: () => `${e.number(t.groupCount)} 個のオプション` })}を含む。`, other: "" }, t.isGroupChange)}${t.optionText}${e.select({ true: "、選択済み", other: "" }, t.isSelected)}`,
	listboxLabel: "候補",
	selectedAnnouncement: (t) => `${t.optionText}、選択済み`,
};
var dW = {};
dW = {
	buttonLabel: "제안 사항 표시",
	countAnnouncement: (t, e) =>
		`${e.plural(t.optionCount, { one: () => `${e.number(t.optionCount)}개 옵션`, other: () => `${e.number(t.optionCount)}개 옵션` })}을 사용할 수 있습니다.`,
	focusAnnouncement: (t, e) =>
		`${e.select({ true: () => `입력한 그룹 ${t.groupTitle}, ${e.plural(t.groupCount, { one: () => `${e.number(t.groupCount)}개 옵션`, other: () => `${e.number(t.groupCount)}개 옵션` })}. `, other: "" }, t.isGroupChange)}${t.optionText}${e.select({ true: ", 선택됨", other: "" }, t.isSelected)}`,
	listboxLabel: "제안",
	selectedAnnouncement: (t) => `${t.optionText}, 선택됨`,
};
var fW = {};
fW = {
	buttonLabel: "Rodyti pasiūlymus",
	countAnnouncement: (t, e) =>
		`Yra ${e.plural(t.optionCount, { one: () => `${e.number(t.optionCount)} parinktis`, other: () => `${e.number(t.optionCount)} parinktys (-ių)` })}.`,
	focusAnnouncement: (t, e) =>
		`${e.select({ true: () => `Įvesta grupė ${t.groupTitle}, su ${e.plural(t.groupCount, { one: () => `${e.number(t.groupCount)} parinktimi`, other: () => `${e.number(t.groupCount)} parinktimis (-ių)` })}. `, other: "" }, t.isGroupChange)}${t.optionText}${e.select({ true: ", pasirinkta", other: "" }, t.isSelected)}`,
	listboxLabel: "Pasiūlymai",
	selectedAnnouncement: (t) => `${t.optionText}, pasirinkta`,
};
var hW = {};
hW = {
	buttonLabel: "Rādīt ieteikumus",
	countAnnouncement: (t, e) =>
		`Pieejamo opciju skaits: ${e.plural(t.optionCount, { one: () => `${e.number(t.optionCount)} opcija`, other: () => `${e.number(t.optionCount)} opcijas` })}.`,
	focusAnnouncement: (t, e) =>
		`${e.select({ true: () => `Ievadīta grupa ${t.groupTitle}, ar ${e.plural(t.groupCount, { one: () => `${e.number(t.groupCount)} opciju`, other: () => `${e.number(t.groupCount)} opcijām` })}. `, other: "" }, t.isGroupChange)}${t.optionText}${e.select({ true: ", atlasīta", other: "" }, t.isSelected)}`,
	listboxLabel: "Ieteikumi",
	selectedAnnouncement: (t) => `${t.optionText}, atlasīta`,
};
var pW = {};
pW = {
	buttonLabel: "Vis forslag",
	countAnnouncement: (t, e) =>
		`${e.plural(t.optionCount, { one: () => `${e.number(t.optionCount)} alternativ`, other: () => `${e.number(t.optionCount)} alternativer` })} finnes.`,
	focusAnnouncement: (t, e) =>
		`${e.select({ true: () => `Angitt gruppe ${t.groupTitle}, med ${e.plural(t.groupCount, { one: () => `${e.number(t.groupCount)} alternativ`, other: () => `${e.number(t.groupCount)} alternativer` })}. `, other: "" }, t.isGroupChange)}${t.optionText}${e.select({ true: ", valgt", other: "" }, t.isSelected)}`,
	listboxLabel: "Forslag",
	selectedAnnouncement: (t) => `${t.optionText}, valgt`,
};
var mW = {};
mW = {
	buttonLabel: "Suggesties weergeven",
	countAnnouncement: (t, e) =>
		`${e.plural(t.optionCount, { one: () => `${e.number(t.optionCount)} optie`, other: () => `${e.number(t.optionCount)} opties` })} beschikbaar.`,
	focusAnnouncement: (t, e) =>
		`${e.select({ true: () => `Groep ${t.groupTitle} ingevoerd met ${e.plural(t.groupCount, { one: () => `${e.number(t.groupCount)} optie`, other: () => `${e.number(t.groupCount)} opties` })}. `, other: "" }, t.isGroupChange)}${t.optionText}${e.select({ true: ", geselecteerd", other: "" }, t.isSelected)}`,
	listboxLabel: "Suggesties",
	selectedAnnouncement: (t) => `${t.optionText}, geselecteerd`,
};
var gW = {};
gW = {
	buttonLabel: "Wyświetlaj sugestie",
	countAnnouncement: (t, e) =>
		`dostępna/dostępne(-nych) ${e.plural(t.optionCount, { one: () => `${e.number(t.optionCount)} opcja`, other: () => `${e.number(t.optionCount)} opcje(-i)` })}.`,
	focusAnnouncement: (t, e) =>
		`${e.select({ true: () => `Dołączono do grupy ${t.groupTitle}, z ${e.plural(t.groupCount, { one: () => `${e.number(t.groupCount)} opcją`, other: () => `${e.number(t.groupCount)} opcjami` })}. `, other: "" }, t.isGroupChange)}${t.optionText}${e.select({ true: ", wybrano", other: "" }, t.isSelected)}`,
	listboxLabel: "Sugestie",
	selectedAnnouncement: (t) => `${t.optionText}, wybrano`,
};
var bW = {};
bW = {
	buttonLabel: "Mostrar sugestões",
	countAnnouncement: (t, e) =>
		`${e.plural(t.optionCount, { one: () => `${e.number(t.optionCount)} opção`, other: () => `${e.number(t.optionCount)} opções` })} disponível.`,
	focusAnnouncement: (t, e) =>
		`${e.select({ true: () => `Grupo inserido ${t.groupTitle}, com ${e.plural(t.groupCount, { one: () => `${e.number(t.groupCount)} opção`, other: () => `${e.number(t.groupCount)} opções` })}. `, other: "" }, t.isGroupChange)}${t.optionText}${e.select({ true: ", selecionado", other: "" }, t.isSelected)}`,
	listboxLabel: "Sugestões",
	selectedAnnouncement: (t) => `${t.optionText}, selecionado`,
};
var vW = {};
vW = {
	buttonLabel: "Apresentar sugestões",
	countAnnouncement: (t, e) =>
		`${e.plural(t.optionCount, { one: () => `${e.number(t.optionCount)} opção`, other: () => `${e.number(t.optionCount)} opções` })} disponível.`,
	focusAnnouncement: (t, e) =>
		`${e.select({ true: () => `Grupo introduzido ${t.groupTitle}, com ${e.plural(t.groupCount, { one: () => `${e.number(t.groupCount)} opção`, other: () => `${e.number(t.groupCount)} opções` })}. `, other: "" }, t.isGroupChange)}${t.optionText}${e.select({ true: ", selecionado", other: "" }, t.isSelected)}`,
	listboxLabel: "Sugestões",
	selectedAnnouncement: (t) => `${t.optionText}, selecionado`,
};
var yW = {};
yW = {
	buttonLabel: "Afișare sugestii",
	countAnnouncement: (t, e) =>
		`${e.plural(t.optionCount, { one: () => `${e.number(t.optionCount)} opțiune`, other: () => `${e.number(t.optionCount)} opțiuni` })} disponibile.`,
	focusAnnouncement: (t, e) =>
		`${e.select({ true: () => `Grup ${t.groupTitle} introdus, cu ${e.plural(t.groupCount, { one: () => `${e.number(t.groupCount)} opțiune`, other: () => `${e.number(t.groupCount)} opțiuni` })}. `, other: "" }, t.isGroupChange)}${t.optionText}${e.select({ true: ", selectat", other: "" }, t.isSelected)}`,
	listboxLabel: "Sugestii",
	selectedAnnouncement: (t) => `${t.optionText}, selectat`,
};
var xW = {};
xW = {
	buttonLabel: "Показать предложения",
	countAnnouncement: (t, e) =>
		`${e.plural(t.optionCount, { one: () => `${e.number(t.optionCount)} параметр`, other: () => `${e.number(t.optionCount)} параметров` })} доступно.`,
	focusAnnouncement: (t, e) =>
		`${e.select({ true: () => `Введенная группа ${t.groupTitle}, с ${e.plural(t.groupCount, { one: () => `${e.number(t.groupCount)} параметром`, other: () => `${e.number(t.groupCount)} параметрами` })}. `, other: "" }, t.isGroupChange)}${t.optionText}${e.select({ true: ", выбранными", other: "" }, t.isSelected)}`,
	listboxLabel: "Предложения",
	selectedAnnouncement: (t) => `${t.optionText}, выбрано`,
};
var kW = {};
kW = {
	buttonLabel: "Zobraziť návrhy",
	countAnnouncement: (t, e) =>
		`${e.plural(t.optionCount, { one: () => `${e.number(t.optionCount)} možnosť`, other: () => `${e.number(t.optionCount)} možnosti/-í` })} k dispozícii.`,
	focusAnnouncement: (t, e) =>
		`${e.select({ true: () => `Zadaná skupina ${t.groupTitle}, s ${e.plural(t.groupCount, { one: () => `${e.number(t.groupCount)} možnosťou`, other: () => `${e.number(t.groupCount)} možnosťami` })}. `, other: "" }, t.isGroupChange)}${t.optionText}${e.select({ true: ", vybraté", other: "" }, t.isSelected)}`,
	listboxLabel: "Návrhy",
	selectedAnnouncement: (t) => `${t.optionText}, vybraté`,
};
var CW = {};
CW = {
	buttonLabel: "Prikaži predloge",
	countAnnouncement: (t, e) =>
		`Na voljo je ${e.plural(t.optionCount, { one: () => `${e.number(t.optionCount)} opcija`, other: () => `${e.number(t.optionCount)} opcije` })}.`,
	focusAnnouncement: (t, e) =>
		`${e.select({ true: () => `Vnesena skupina ${t.groupTitle}, z ${e.plural(t.groupCount, { one: () => `${e.number(t.groupCount)} opcija`, other: () => `${e.number(t.groupCount)} opcije` })}. `, other: "" }, t.isGroupChange)}${t.optionText}${e.select({ true: ", izbrano", other: "" }, t.isSelected)}`,
	listboxLabel: "Predlogi",
	selectedAnnouncement: (t) => `${t.optionText}, izbrano`,
};
var wW = {};
wW = {
	buttonLabel: "Prikaži predloge",
	countAnnouncement: (t, e) =>
		`Dostupno još: ${e.plural(t.optionCount, { one: () => `${e.number(t.optionCount)} opcija`, other: () => `${e.number(t.optionCount)} opcije/a` })}.`,
	focusAnnouncement: (t, e) =>
		`${e.select({ true: () => `Unesena grupa ${t.groupTitle}, s ${e.plural(t.groupCount, { one: () => `${e.number(t.groupCount)} opcijom`, other: () => `${e.number(t.groupCount)} optione/a` })}. `, other: "" }, t.isGroupChange)}${t.optionText}${e.select({ true: ", izabranih", other: "" }, t.isSelected)}`,
	listboxLabel: "Predlozi",
	selectedAnnouncement: (t) => `${t.optionText}, izabrano`,
};
var EW = {};
EW = {
	buttonLabel: "Visa förslag",
	countAnnouncement: (t, e) =>
		`${e.plural(t.optionCount, { one: () => `${e.number(t.optionCount)} alternativ`, other: () => `${e.number(t.optionCount)} alternativ` })} tillgängliga.`,
	focusAnnouncement: (t, e) =>
		`${e.select({ true: () => `Ingick i gruppen ${t.groupTitle} med ${e.plural(t.groupCount, { one: () => `${e.number(t.groupCount)} alternativ`, other: () => `${e.number(t.groupCount)} alternativ` })}. `, other: "" }, t.isGroupChange)}${t.optionText}${e.select({ true: ", valda", other: "" }, t.isSelected)}`,
	listboxLabel: "Förslag",
	selectedAnnouncement: (t) => `${t.optionText}, valda`,
};
var DW = {};
DW = {
	buttonLabel: "Önerileri göster",
	countAnnouncement: (t, e) =>
		`${e.plural(t.optionCount, { one: () => `${e.number(t.optionCount)} seçenek`, other: () => `${e.number(t.optionCount)} seçenekler` })} kullanılabilir.`,
	focusAnnouncement: (t, e) =>
		`${e.select({ true: () => `Girilen grup ${t.groupTitle}, ile ${e.plural(t.groupCount, { one: () => `${e.number(t.groupCount)} seçenek`, other: () => `${e.number(t.groupCount)} seçenekler` })}. `, other: "" }, t.isGroupChange)}${t.optionText}${e.select({ true: ", seçildi", other: "" }, t.isSelected)}`,
	listboxLabel: "Öneriler",
	selectedAnnouncement: (t) => `${t.optionText}, seçildi`,
};
var SW = {};
SW = {
	buttonLabel: "Показати пропозиції",
	countAnnouncement: (t, e) =>
		`${e.plural(t.optionCount, { one: () => `${e.number(t.optionCount)} параметр`, other: () => `${e.number(t.optionCount)} параметри(-ів)` })} доступно.`,
	focusAnnouncement: (t, e) =>
		`${e.select({ true: () => `Введена група ${t.groupTitle}, з ${e.plural(t.groupCount, { one: () => `${e.number(t.groupCount)} параметр`, other: () => `${e.number(t.groupCount)} параметри(-ів)` })}. `, other: "" }, t.isGroupChange)}${t.optionText}${e.select({ true: ", вибрано", other: "" }, t.isSelected)}`,
	listboxLabel: "Пропозиції",
	selectedAnnouncement: (t) => `${t.optionText}, вибрано`,
};
var AW = {};
AW = {
	buttonLabel: "显示建议",
	countAnnouncement: (t, e) =>
		`有 ${e.plural(t.optionCount, { one: () => `${e.number(t.optionCount)} 个选项`, other: () => `${e.number(t.optionCount)} 个选项` })}可用。`,
	focusAnnouncement: (t, e) =>
		`${e.select({ true: () => `进入了 ${t.groupTitle} 组，其中有 ${e.plural(t.groupCount, { one: () => `${e.number(t.groupCount)} 个选项`, other: () => `${e.number(t.groupCount)} 个选项` })}. `, other: "" }, t.isGroupChange)}${t.optionText}${e.select({ true: ", 已选择", other: "" }, t.isSelected)}`,
	listboxLabel: "建议",
	selectedAnnouncement: (t) => `${t.optionText}, 已选择`,
};
var $W = {};
$W = {
	buttonLabel: "顯示建議",
	countAnnouncement: (t, e) =>
		`${e.plural(t.optionCount, { one: () => `${e.number(t.optionCount)} 選項`, other: () => `${e.number(t.optionCount)} 選項` })} 可用。`,
	focusAnnouncement: (t, e) =>
		`${e.select({ true: () => `輸入的群組 ${t.groupTitle}, 有 ${e.plural(t.groupCount, { one: () => `${e.number(t.groupCount)} 選項`, other: () => `${e.number(t.groupCount)} 選項` })}. `, other: "" }, t.isGroupChange)}${t.optionText}${e.select({ true: ", 已選取", other: "" }, t.isSelected)}`,
	listboxLabel: "建議",
	selectedAnnouncement: (t) => `${t.optionText}, 已選取`,
};
var TW = {};
TW = {
	"ar-AE": YH,
	"bg-BG": JH,
	"cs-CZ": XH,
	"da-DK": ZH,
	"de-DE": QH,
	"el-GR": eW,
	"en-US": tW,
	"es-ES": nW,
	"et-EE": rW,
	"fi-FI": iW,
	"fr-FR": oW,
	"he-IL": sW,
	"hr-HR": aW,
	"hu-HU": lW,
	"it-IT": uW,
	"ja-JP": cW,
	"ko-KR": dW,
	"lt-LT": fW,
	"lv-LV": hW,
	"nb-NO": pW,
	"nl-NL": mW,
	"pl-PL": gW,
	"pt-BR": bW,
	"pt-PT": vW,
	"ro-RO": yW,
	"ru-RU": xW,
	"sk-SK": kW,
	"sl-SI": CW,
	"sr-SP": wW,
	"sv-SE": EW,
	"tr-TR": DW,
	"uk-UA": SW,
	"zh-CN": AW,
	"zh-TW": $W,
};
function v3e(t) {
	return t && t.__esModule ? t.default : t;
}
function BW(t, e) {
	let {
			buttonRef: n,
			popoverRef: r,
			inputRef: i,
			listBoxRef: o,
			keyboardDelegate: s,
			layoutDelegate: a,
			shouldFocusWrap: l,
			isReadOnly: u,
			isDisabled: c,
		} = t,
		d = Le(v3e(TW), "@react-aria/combobox"),
		{ menuTriggerProps: f, menuProps: h } = ZD(
			{ type: "listbox", isDisabled: c || u },
			e,
			n,
		);
	Mx.set(e, { id: h.id });
	let { collection: p } = e,
		{ disabledKeys: g } = e.selectionManager,
		v = E.useMemo(
			() =>
				s ||
				new Xh({
					collection: p,
					disabledKeys: g,
					ref: o,
					layoutDelegate: a,
				}),
			[s, a, p, g, o],
		),
		{ collectionProps: b } = $x({
			selectionManager: e.selectionManager,
			keyboardDelegate: v,
			disallowTypeAhead: !0,
			disallowEmptySelection: !0,
			shouldFocusWrap: l,
			ref: i,
			isVirtualized: !0,
		}),
		y = Kd(),
		x = (se) => {
			if (!se.nativeEvent.isComposing)
				switch (se.key) {
					case "Enter":
					case "Tab":
						if (
							(e.isOpen &&
								se.key === "Enter" &&
								se.preventDefault(),
							e.isOpen &&
								e.selectionManager.focusedKey != null &&
								e.selectionManager.isLink(
									e.selectionManager.focusedKey,
								))
						) {
							if (se.key === "Enter") {
								let re = o.current.querySelector(
									`[data-key="${CSS.escape(e.selectionManager.focusedKey.toString())}"]`,
								);
								if (re instanceof HTMLAnchorElement) {
									let he = e.collection.getItem(
										e.selectionManager.focusedKey,
									);
									y.open(
										re,
										se,
										he.props.href,
										he.props.routerOptions,
									);
								}
							}
							e.close();
						} else e.commit();
						break;
					case "Escape":
						(e.selectedKey !== null ||
							e.inputValue === "" ||
							t.allowsCustomValue) &&
							se.continuePropagation(),
							e.revert();
						break;
					case "ArrowDown":
						e.open("first", "manual");
						break;
					case "ArrowUp":
						e.open("last", "manual");
						break;
					case "ArrowLeft":
					case "ArrowRight":
						e.selectionManager.setFocusedKey(null);
						break;
				}
		},
		C = (se) => {
			var re;
			let he =
					(n == null ? void 0 : n.current) &&
					n.current === se.relatedTarget,
				ye =
					(re = r.current) === null || re === void 0
						? void 0
						: re.contains(se.relatedTarget);
			he || ye || (t.onBlur && t.onBlur(se), e.setFocused(!1));
		},
		k = (se) => {
			e.isFocused || (t.onFocus && t.onFocus(se), e.setFocused(!0));
		},
		{
			isInvalid: w,
			validationErrors: D,
			validationDetails: S,
		} = e.displayValidation,
		{
			labelProps: $,
			inputProps: A,
			descriptionProps: T,
			errorMessageProps: I,
		} = d0(
			{
				...t,
				onChange: e.setInputValue,
				onKeyDown: u
					? t.onKeyDown
					: hr(e.isOpen && b.onKeyDown, x, t.onKeyDown),
				onBlur: C,
				value: e.inputValue,
				onFocus: k,
				autoComplete: "off",
				validate: void 0,
				[Ym]: e,
			},
			i,
		),
		F = (se) => {
			se.pointerType === "touch" &&
				(i.current.focus(), e.toggle(null, "manual"));
		},
		N = (se) => {
			se.pointerType !== "touch" &&
				(i.current.focus(),
				e.toggle(
					se.pointerType === "keyboard" ||
						se.pointerType === "virtual"
						? "first"
						: null,
					"manual",
				));
		},
		O = tv({
			id: f.id,
			"aria-label": d.format("buttonLabel"),
			"aria-labelledby": t["aria-labelledby"] || $.id,
		}),
		_ = tv({
			id: h.id,
			"aria-label": d.format("listboxLabel"),
			"aria-labelledby": t["aria-labelledby"] || $.id,
		}),
		j = E.useRef(0),
		V = (se) => {
			if (c || u) return;
			if (se.timeStamp - j.current < 500) {
				se.preventDefault(), i.current.focus();
				return;
			}
			let re = se.target.getBoundingClientRect(),
				he = se.changedTouches[0],
				ye = Math.ceil(re.left + 0.5 * re.width),
				Ae = Math.ceil(re.top + 0.5 * re.height);
			he.clientX === ye &&
				he.clientY === Ae &&
				(se.preventDefault(),
				i.current.focus(),
				e.toggle(null, "manual"),
				(j.current = se.timeStamp));
		},
		K =
			e.selectionManager.focusedKey != null && e.isOpen
				? e.collection.getItem(e.selectionManager.focusedKey)
				: void 0;
	var M;
	let G =
		(M = K == null ? void 0 : K.parentKey) !== null && M !== void 0
			? M
			: null;
	var H;
	let P =
			(H = e.selectionManager.focusedKey) !== null && H !== void 0
				? H
				: null,
		q = E.useRef(G),
		J = E.useRef(P);
	E.useEffect(() => {
		if (tb() && K != null && P !== J.current) {
			let se = e.selectionManager.isSelected(P),
				re = G != null ? e.collection.getItem(G) : null,
				he =
					(re == null ? void 0 : re["aria-label"]) ||
					(typeof (re == null ? void 0 : re.rendered) == "string"
						? re.rendered
						: "") ||
					"",
				ye = d.format("focusAnnouncement", {
					isGroupChange: re && G !== q.current,
					groupTitle: he,
					groupCount: re ? [...Wt(re, e.collection)].length : 0,
					optionText: K["aria-label"] || K.textValue || "",
					isSelected: se,
				});
			xs(ye);
		}
		(q.current = G), (J.current = P);
	});
	let Z = kD(e.collection),
		oe = E.useRef(Z),
		ne = E.useRef(e.isOpen);
	E.useEffect(() => {
		let se =
			e.isOpen !== ne.current &&
			(e.selectionManager.focusedKey == null || tb());
		if (e.isOpen && (se || Z !== oe.current)) {
			let re = d.format("countAnnouncement", { optionCount: Z });
			xs(re);
		}
		(oe.current = Z), (ne.current = e.isOpen);
	});
	let de = E.useRef(e.selectedKey);
	return (
		E.useEffect(() => {
			if (
				tb() &&
				e.isFocused &&
				e.selectedItem &&
				e.selectedKey !== de.current
			) {
				let se =
						e.selectedItem["aria-label"] ||
						e.selectedItem.textValue ||
						"",
					re = d.format("selectedAnnouncement", { optionText: se });
				xs(re);
			}
			de.current = e.selectedKey;
		}),
		E.useEffect(() => {
			if (e.isOpen) return mx([i.current, r.current]);
		}, [e.isOpen, i, r]),
		{
			labelProps: $,
			buttonProps: {
				...f,
				...O,
				excludeFromTabOrder: !0,
				preventFocusOnPress: !0,
				onPress: F,
				onPressStart: N,
				isDisabled: c || u,
			},
			inputProps: xe(A, {
				role: "combobox",
				"aria-expanded": f["aria-expanded"],
				"aria-controls": e.isOpen ? h.id : void 0,
				"aria-autocomplete": "list",
				"aria-activedescendant": K ? $j(e, K.key) : void 0,
				onTouchEnd: V,
				autoCorrect: "off",
				spellCheck: "false",
			}),
			listBoxProps: xe(h, _, {
				autoFocus: e.focusStrategy,
				shouldUseVirtualFocus: !0,
				shouldSelectOnPressUp: !0,
				shouldFocusOnHover: !0,
				linkBehavior: "selection",
			}),
			descriptionProps: T,
			errorMessageProps: I,
			isInvalid: w,
			validationErrors: D,
			validationDetails: S,
		}
	);
}
function IW(t) {
	var e, n;
	let {
			defaultFilter: r,
			menuTrigger: i = "input",
			allowsEmptyCollection: o = !1,
			allowsCustomValue: s,
			shouldCloseOnBlur: a = !0,
		} = t,
		[l, u] = E.useState(!1),
		[c, d] = E.useState(!1),
		[f, h] = E.useState(null),
		p = (Ce) => {
			t.onSelectionChange && t.onSelectionChange(Ce),
				Ce === y && (q(), G());
		};
	var g;
	let {
		collection: v,
		selectionManager: b,
		selectedKey: y,
		setSelectedKey: x,
		selectedItem: C,
		disabledKeys: k,
	} = Aj({
		...t,
		onSelectionChange: p,
		items: (g = t.items) !== null && g !== void 0 ? g : t.defaultItems,
	});
	var w, D;
	let [S, $] = Ns(
			t.inputValue,
			(D =
				(w = t.defaultInputValue) !== null && w !== void 0
					? w
					: (e = v.getItem(y)) === null || e === void 0
						? void 0
						: e.textValue) !== null && D !== void 0
				? D
				: "",
			t.onInputChange,
		),
		A = v,
		T = E.useMemo(
			() => (t.items != null || !r ? v : y3e(v, S, r)),
			[v, S, r, t.items],
		),
		[I, F] = E.useState(T),
		N = E.useRef("focus"),
		_ = Bl({
			...t,
			onOpenChange: (Ce) => {
				t.onOpenChange && t.onOpenChange(Ce, Ce ? N.current : void 0),
					b.setFocused(Ce),
					Ce || b.setFocusedKey(null);
			},
			isOpen: void 0,
			defaultOpen: void 0,
		}),
		j = (Ce = null, Me) => {
			let me = Me === "manual" || (Me === "focus" && i === "focus");
			(o || T.size > 0 || (me && A.size > 0) || t.items) &&
				(me && !_.isOpen && t.items === void 0 && u(!0),
				(N.current = Me),
				h(Ce),
				_.open());
		},
		V = (Ce = null, Me) => {
			let me = Me === "manual" || (Me === "focus" && i === "focus");
			(!(o || T.size > 0 || (me && A.size > 0) || t.items) &&
				!_.isOpen) ||
				(me && !_.isOpen && t.items === void 0 && u(!0),
				_.isOpen || (N.current = Me),
				M(Ce));
		},
		K = E.useCallback(() => {
			F(l ? A : T);
		}, [l, A, T]),
		M = E.useCallback(
			(Ce = null) => {
				_.isOpen && K(), h(Ce), _.toggle();
			},
			[_, K],
		),
		G = E.useCallback(() => {
			_.isOpen && (K(), _.close());
		}, [_, K]),
		[H, P] = E.useState(S),
		q = () => {
			var Ce, Me;
			let me =
				(Me =
					(Ce = v.getItem(y)) === null || Ce === void 0
						? void 0
						: Ce.textValue) !== null && Me !== void 0
					? Me
					: "";
			P(me), $(me);
		};
	var J, Z;
	let oe = E.useRef(
		(Z =
			(J = t.selectedKey) !== null && J !== void 0
				? J
				: t.defaultSelectedKey) !== null && Z !== void 0
			? Z
			: null,
	);
	var ne;
	let de = E.useRef(
		(ne =
			(n = v.getItem(y)) === null || n === void 0
				? void 0
				: n.textValue) !== null && ne !== void 0
			? ne
			: "",
	);
	E.useEffect(() => {
		var Ce;
		c &&
			(T.size > 0 || o) &&
			!_.isOpen &&
			S !== H &&
			i !== "manual" &&
			j(null, "input"),
			!l && !o && _.isOpen && T.size === 0 && G(),
			y != null && y !== oe.current && G(),
			S !== H &&
				(b.setFocusedKey(null),
				u(!1),
				S === "" &&
					(t.inputValue === void 0 || t.selectedKey === void 0) &&
					x(null)),
			y !== oe.current &&
			(t.inputValue === void 0 || t.selectedKey === void 0)
				? q()
				: H !== S && P(S);
		var Me;
		let me =
			(Me =
				(Ce = v.getItem(y)) === null || Ce === void 0
					? void 0
					: Ce.textValue) !== null && Me !== void 0
				? Me
				: "";
		!c &&
			y != null &&
			t.inputValue === void 0 &&
			y === oe.current &&
			de.current !== me &&
			(P(me), $(me)),
			(oe.current = y),
			(de.current = me);
	});
	let se = Yd({
			...t,
			value: E.useMemo(() => ({ inputValue: S, selectedKey: y }), [S, y]),
		}),
		re = () => {
			s && y == null ? he() : ye();
		},
		he = () => {
			(oe.current = null), x(null), G();
		},
		ye = () => {
			if (t.selectedKey !== void 0 && t.inputValue !== void 0) {
				var Ce;
				t.onSelectionChange(y);
				var Me;
				let me =
					(Me =
						(Ce = v.getItem(y)) === null || Ce === void 0
							? void 0
							: Ce.textValue) !== null && Me !== void 0
						? Me
						: "";
				P(me), G();
			} else q(), G();
		};
	const Ae = () => {
		if (s) {
			var Ce, Me;
			const me =
				(Me =
					(Ce = v.getItem(y)) === null || Ce === void 0
						? void 0
						: Ce.textValue) !== null && Me !== void 0
					? Me
					: "";
			S === me ? ye() : he();
		} else ye();
	};
	let Pe = () => {
			_.isOpen && b.focusedKey != null
				? y === b.focusedKey
					? ye()
					: x(b.focusedKey)
				: Ae();
		},
		we = E.useRef(S),
		Ke = (Ce) => {
			Ce
				? ((we.current = S),
					i === "focus" && !t.isReadOnly && j(null, "focus"))
				: (a && Ae(), S !== we.current && se.commitValidation()),
				d(Ce);
		},
		rt = E.useMemo(
			() => (_.isOpen ? (l ? A : T) : I),
			[_.isOpen, A, T, l, I],
		);
	return {
		...se,
		..._,
		focusStrategy: f,
		toggle: V,
		open: j,
		close: Ae,
		selectionManager: b,
		selectedKey: y,
		setSelectedKey: x,
		disabledKeys: k,
		isFocused: c,
		setFocused: Ke,
		selectedItem: C,
		collection: rt,
		inputValue: S,
		setInputValue: $,
		commit: Pe,
		revert: re,
	};
}
function y3e(t, e, n) {
	return new Sw(FW(t, t, e, n));
}
function FW(t, e, n, r) {
	let i = [];
	for (let o of e)
		if (o.type === "section" && o.hasChildNodes) {
			let s = FW(t, Wt(o, t), n, r);
			[...s].some((a) => a.type === "item") &&
				i.push({ ...o, childNodes: s });
		} else
			o.type === "item" && r(o.textValue, n)
				? i.push({ ...o })
				: o.type !== "item" && i.push({ ...o });
	return i;
}
const xu = new Gr("Combobox", ["input", "mobile-trigger"]),
	$5 = {
		"ar-AE": {
			clear: "مسح",
			invalid: "(غير صالح)",
			loading: "جارٍ التحميل...",
			noResults: "لا توجد نتائج",
		},
		"bg-BG": {
			clear: "Изчисти",
			invalid: "(невалиден)",
			loading: "Зареждане...",
			noResults: "Няма резултати",
		},
		"cs-CZ": {
			clear: "Vymazat",
			invalid: "(neplatné)",
			loading: "Načítání...",
			noResults: "Žádné výsledky",
		},
		"da-DK": {
			clear: "Ryd",
			invalid: "(ugyldig)",
			loading: "Indlæser ...",
			noResults: "Ingen resultater",
		},
		"de-DE": {
			clear: "Löschen",
			invalid: "(ungültig)",
			loading: "Wird geladen...",
			noResults: "Keine Ergebnisse",
		},
		"el-GR": {
			clear: "Καθαρισμός",
			invalid: "(δεν ισχύει)",
			loading: "Φόρτωση...",
			noResults: "Χωρίς αποτέλεσμα",
		},
		"en-US": {
			loading: "Loading...",
			noResults: "No results",
			clear: "Clear",
			invalid: "(invalid)",
		},
		"es-ES": {
			clear: "Borrar",
			invalid: "(no válido)",
			loading: "Cargando...",
			noResults: "Sin resultados",
		},
		"et-EE": {
			clear: "Puhasta",
			invalid: "(kehtetu)",
			loading: "Laadimine...",
			noResults: "Tulemusi pole",
		},
		"fi-FI": {
			clear: "Kirkas",
			invalid: "(epäkelpo)",
			loading: "Ladataan...",
			noResults: "Ei tuloksia",
		},
		"fr-FR": {
			clear: "Effacer",
			invalid: "(non valide)",
			loading: "Chargement en cours...",
			noResults: "Aucun résultat",
		},
		"he-IL": {
			clear: "נקי",
			invalid: "(לא חוקי)",
			loading: "טוען...",
			noResults: "אין תוצאות",
		},
		"hr-HR": {
			clear: "Izbriši",
			invalid: "(nevažeće)",
			loading: "Učitavam...",
			noResults: "Nema rezultata",
		},
		"hu-HU": {
			clear: "Törlés",
			invalid: "(érvénytelen)",
			loading: "Betöltés folyamatban…",
			noResults: "Nincsenek találatok",
		},
		"it-IT": {
			clear: "Cancella",
			invalid: "(non valido)",
			loading: "Caricamento in corso...",
			noResults: "Nessun risultato",
		},
		"ja-JP": {
			clear: "クリア",
			invalid: "(無効)",
			loading: "読み込み中...",
			noResults: "結果なし",
		},
		"ko-KR": {
			clear: "지우기",
			invalid: "(유효하지 않음)",
			loading: "로드 중...",
			noResults: "결과 없음",
		},
		"lt-LT": {
			clear: "Skaidrus",
			invalid: "(netinkama)",
			loading: "Įkeliama...",
			noResults: "Be rezultatų",
		},
		"lv-LV": {
			clear: "Notīrīt",
			invalid: "(nederīgs)",
			loading: "Notiek ielāde...",
			noResults: "Nav rezultātu",
		},
		"nb-NO": {
			clear: "Tøm",
			invalid: "(ugyldig)",
			loading: "Laster inn ...",
			noResults: "Ingen resultater",
		},
		"nl-NL": {
			clear: "Helder",
			invalid: "(ongeldig)",
			loading: "Laden...",
			noResults: "Geen resultaten",
		},
		"pl-PL": {
			clear: "Wyczyść",
			invalid: "(nieprawidłowy)",
			loading: "Trwa ładowanie...",
			noResults: "Brak wyników",
		},
		"pt-BR": {
			clear: "Limpar",
			invalid: "(inválido)",
			loading: "Carregando...",
			noResults: "Nenhum resultado",
		},
		"pt-PT": {
			clear: "Limpar",
			invalid: "(inválido)",
			loading: "A carregar...",
			noResults: "Sem resultados",
		},
		"ro-RO": {
			clear: "Golire",
			invalid: "(nevalid)",
			loading: "Se încarcă...",
			noResults: "Niciun rezultat",
		},
		"ru-RU": {
			clear: "Очистить",
			invalid: "(недействительно)",
			loading: "Загрузка...",
			noResults: "Результаты отсутствуют",
		},
		"sk-SK": {
			clear: "Vymazať",
			invalid: "(neplatné)",
			loading: "Načítava sa...",
			noResults: "Žiadne výsledky",
		},
		"sl-SI": {
			clear: "Jasen",
			invalid: "(neveljavno)",
			loading: "Nalaganje...",
			noResults: "Ni rezultatov",
		},
		"sr-SP": {
			clear: "Izbriši",
			invalid: "(nevažeće)",
			loading: "Učitavam...",
			noResults: "Nema rezultata",
		},
		"sv-SE": {
			clear: "Rensa",
			invalid: "(ogiltigt)",
			loading: "Läser in...",
			noResults: "Inga resultat",
		},
		"tr-TR": {
			clear: "Temizle",
			invalid: "(geçersiz)",
			loading: "Yükleniyor...",
			noResults: "Sonuç yok",
		},
		"uk-UA": {
			clear: "Очистити",
			invalid: "(недійсне)",
			loading: "Завантаження...",
			noResults: "Результатів немає",
		},
		"zh-CN": {
			clear: "透明",
			invalid: "（无效）",
			loading: "正在加载...",
			noResults: "无结果",
		},
		"zh-TW": {
			clear: "清除",
			invalid: "(無效)",
			loading: "正在載入...",
			noResults: "無任何結果",
		},
	};
function x3e(t, e) {
	const n = vo(t);
	let { isDisabled: r, validationState: i, isReadOnly: o } = n,
		{ contains: s } = p9({ sensitivity: "base" }),
		a = IW({
			...n,
			defaultFilter: s,
			allowsEmptyCollection: !0,
			shouldCloseOnBlur: !1,
		}),
		l = E.useRef(null),
		u = Ct(e),
		{ triggerProps: c, overlayProps: d } = px({ type: "listbox" }, a, l),
		{ labelProps: f, fieldProps: h } = Gd({
			...n,
			labelElementType: "span",
		});
	return (
		(f = {
			...f,
			onClick: () => {
				let p = l.current;
				p && !n.isDisabled && (p.focus(), Ic("keyboard"));
			},
		}),
		m.jsxs(m.Fragment, {
			children: [
				m.jsx(Yh, {
					...n,
					labelProps: f,
					ref: u,
					supplementRequiredState: !0,
					children: m.jsx(k3e, {
						...xe(c, h, { autoFocus: n.autoFocus }),
						ref: l,
						isDisabled: r,
						isReadOnly: o,
						isPlaceholder: !a.inputValue,
						validationState: i,
						onPress: () => !o && a.open(null, "manual"),
						children: a.inputValue || n.placeholder || "",
					}),
				}),
				m.jsx(Px, {
					state: a,
					isFixedHeight: !0,
					...d,
					children: m.jsx(E3e, {
						...n,
						onClose: a.close,
						overlayProps: d,
						state: a,
					}),
				}),
			],
		})
	);
}
const k3e = le.forwardRef(function (e, n) {
		let {
				isDisabled: r,
				isPlaceholder: i,
				validationState: o,
				children: s,
				style: a,
			} = e,
			l = Ot(),
			u = Ot(),
			c = Ct(n),
			{ hoverProps: d, isHovered: f } = gn({}),
			{ buttonProps: h, isPressed: p } = Yo(
				{
					...e,
					"aria-labelledby": [
						e["aria-labelledby"],
						e["aria-label"] && !e["aria-labelledby"] ? e.id : null,
						l,
						o === "invalid" ? u : null,
					]
						.filter(Boolean)
						.join(" "),
					elementType: "div",
				},
				c,
			);
		return m.jsx(xn, {
			children: m.jsxs(ke, {
				position: "relative",
				width: "alias.singleLineWidth",
				zIndex: 0,
				...lt({ readonly: e.isReadOnly }),
				...xe(d, h),
				"aria-haspopup": "dialog",
				ref: c,
				UNSAFE_className: xu.element("mobile-trigger"),
				UNSAFE_style: { ...a, outline: "none" },
				children: [
					m.jsx(ke, {
						alignItems: "center",
						paddingX: "medium",
						flex: !0,
						children: m.jsx(ue, {
							id: l,
							color: i ? "neutralSecondary" : void 0,
							trim: !1,
							truncate: !0,
							children: s,
						}),
					}),
					m.jsx(w3e, {
						isHovered: f,
						isPressed: p,
						isDisabled: r,
						validationState: o,
					}),
					m.jsx(C3e, {
						isHovered: f,
						isPressed: p,
						isDisabled: r,
						validationState: o,
						UNSAFE_className: X({
							borderEndStartRadius: 0,
							borderStartStartRadius: 0,
							[`${xu.selector("mobile-trigger")}[data-focus] &`]:
								{ borderColor: B.color.alias.borderFocused },
						}),
						children: m.jsx(ve, { src: Il }),
					}),
				],
			}),
		});
	}),
	C3e = (t) => {
		let { isHovered: e, isPressed: n, ...r } = t,
			{ children: i, styleProps: o } = HP(r, {
				isHovered: e,
				isPressed: n,
			});
		return m.jsx("div", {
			"data-disabled": t.isDisabled,
			...o,
			children: i,
		});
	},
	w3e = (t) => {
		let { isDisabled: e, isHovered: n, isPressed: r } = t;
		return m.jsx("div", {
			role: "presentation",
			...lt({
				disabled: e,
				interaction: r ? "press" : n ? "hover" : void 0,
				validation: t.validationState,
			}),
			className: X({
				backgroundColor: B.color.background.canvas,
				border: `${B.size.border.regular} solid ${B.color.alias.borderIdle}`,
				borderRadius: B.size.radius.regular,
				inset: 0,
				position: "absolute",
				transition: bt(["border-color", "box-shadow"]),
				zIndex: -1,
				"&[data-interaction=hover]": {
					borderColor: B.color.alias.borderHovered,
				},
				"&[data-validation=invalid]": {
					borderColor: B.color.alias.borderInvalid,
				},
				[`${xu.selector("mobile-trigger")}[data-focus] &`]: {
					borderColor: B.color.alias.borderFocused,
				},
				[`${xu.selector("mobile-trigger")}[data-focus]:not([data-readonly]) &`]:
					{ boxShadow: `0 0 0 1px ${B.color.alias.borderFocused}` },
				"&[data-disabled=true]": {
					backgroundColor: B.color.background.surfaceSecondary,
					borderColor: "transparent",
				},
			}),
		});
	};
function E3e(t) {
	let {
			state: e,
			isDisabled: n,
			validationState: r,
			label: i,
			overlayProps: o,
			loadingState: s,
			onLoadMore: a,
			onClose: l,
		} = t,
		u = E.useRef(),
		[c, d] = E.useState(!1),
		f = E.useRef(null),
		h = E.useRef(null),
		p = E.useRef(null),
		g = E.useRef(null),
		v = x0(),
		b = Le($5),
		{
			inputProps: y,
			listBoxProps: x,
			labelProps: C,
		} = BW(
			{
				...t,
				layoutDelegate: v,
				buttonRef: h,
				popoverRef: p,
				listBoxRef: g,
				inputRef: f,
			},
			e,
		);
	le.useEffect(() => {
		let O = f.current;
		return (
			O && on(O),
			() => {
				e.setFocused(!1);
			}
		);
	}, []);
	let { dialogProps: k } = q_({ "aria-labelledby": Ot(C.id) }, p);
	(y.role = "searchbox"),
		(y["aria-haspopup"] = "listbox"),
		delete y.onTouchEnd;
	let w = m.jsx(wx, {
			preventFocus: !0,
			"aria-label": b.format("clear"),
			excludeFromTabOrder: !0,
			onPress: () => {
				e.setInputValue("");
				let O = f.current;
				O && O.focus();
			},
			isDisabled: n,
		}),
		D = m.jsx(ke, {
			alignItems: "center",
			flexShrink: 0,
			justifyContent: "center",
			pointerEvents: "none",
			width: "element.regular",
			children: m.jsx(Cr, {
				"aria-label": b.format("loading"),
				size: "small",
				isIndeterminate: !0,
			}),
		}),
		S = E.useRef(!1),
		$ = () => {
			S.current = !0;
		},
		A = () => {
			S.current = !1;
		},
		T = E.useCallback(() => {
			let O = f.current,
				_ = p.current;
			!O ||
				document.activeElement !== O ||
				!S.current ||
				(_ && _.focus());
		}, [f, p, S]),
		I = y.value,
		F = E.useRef(I);
	E.useEffect(() => {
		s === "filtering" && !c
			? (u.current ||
					(u.current = setTimeout(() => {
						d(!0);
					}, 500)),
				I !== F.current &&
					(clearTimeout(u.current),
					(u.current = setTimeout(() => {
						d(!0);
					}, 500))))
			: s !== "filtering" &&
				(d(!1), clearTimeout(u.current), (u.current = void 0)),
			(F.current = I);
	}, [s, I, c]);
	let N = (O) => {
		let _ = p.current;
		if (_ && O.key === "Enter" && e.selectionManager.focusedKey == null)
			_.focus();
		else {
			var j;
			(j = y.onKeyDown) === null || j === void 0 || j.call(y, O);
		}
	};
	return m.jsx(nc, {
		restoreFocus: !0,
		contain: !0,
		children: m.jsxs(ke, {
			direction: "column",
			height: "100%",
			ref: p,
			...xe(o, k),
			children: [
				m.jsx(Hm, { onDismiss: l }),
				m.jsx(Jh, {
					label: i,
					labelProps: C,
					inputProps: { ...y, onKeyDown: N },
					ref: f,
					isDisabled: n,
					marginX: "small",
					marginTop: "regular",
					endElement: m.jsxs(ke, {
						children: [
							c && s === "filtering" && D,
							(e.inputValue !== "" ||
								s === "filtering" ||
								r != null) &&
								!t.isReadOnly &&
								w,
						],
					}),
				}),
				m.jsx(k0, {
					...x,
					domProps: { onTouchStart: $, onTouchEnd: A },
					disallowEmptySelection: !0,
					shouldSelectOnPressUp: !0,
					focusOnPointerEnter: !0,
					layout: v,
					state: e,
					shouldUseVirtualFocus: !0,
					renderEmptyState: () =>
						s !== "loading" &&
						m.jsx(ke, {
							height: "element.regular",
							alignItems: "center",
							paddingX: "medium",
							children: m.jsx(ue, {
								color: "neutralSecondary",
								children: b.format("noResults"),
							}),
						}),
					ref: g,
					onScroll: T,
					onLoadMore: a,
					isLoading: s === "loading" || s === "loadingMore",
				}),
				m.jsx(Hm, { onDismiss: l }),
			],
		}),
	});
}
const D3e = le.forwardRef(x3e);
function S3e(t, e) {
	const n = ce(8);
	t = vo(t);
	const r = t;
	let i;
	if (
		(n[0] !== r ? ((i = vD(r)), (n[0] = r), (n[1] = i)) : (i = n[1]),
		(t = i),
		kx())
	) {
		let s;
		return (
			n[2] !== t || n[3] !== e
				? ((s = m.jsx(D3e, { ...t, menuTrigger: "input", ref: e })),
					(n[2] = t),
					(n[3] = e),
					(n[4] = s))
				: (s = n[4]),
			s
		);
	} else {
		let s;
		return (
			n[5] !== t || n[6] !== e
				? ((s = m.jsx(A3e, { ...t, ref: e })),
					(n[5] = t),
					(n[6] = e),
					(n[7] = s))
				: (s = n[7]),
			s
		);
	}
}
const A3e = le.forwardRef(function (e, n) {
	const r = ce(62),
		{
			align: i,
			menuTrigger: o,
			shouldFlip: s,
			direction: a,
			loadingState: l,
			menuWidth: u,
			onLoadMore: c,
		} = e,
		d = i === void 0 ? "start" : i,
		f = o === void 0 ? "input" : o,
		h = s === void 0 ? !0 : s,
		p = a === void 0 ? "bottom" : a,
		g = l != null,
		v = Le($5),
		b = E.useRef(null),
		y = E.useRef(null),
		x = E.useRef(null),
		[C, k] = $3e(),
		w = Ct(n);
	let D;
	r[0] === Symbol.for("react.memo_cache_sentinel")
		? ((D = { sensitivity: "base" }), (r[0] = D))
		: (D = r[0]);
	const { contains: S } = p9(D);
	let $;
	r[1] !== e || r[2] !== S || r[3] !== g
		? (($ = { ...e, defaultFilter: S, allowsEmptyCollection: g }),
			(r[1] = e),
			(r[2] = S),
			(r[3] = g),
			(r[4] = $))
		: ($ = r[4]);
	const A = IW($),
		T = x0();
	let I;
	r[5] !== e ||
	r[6] !== T ||
	r[7] !== b ||
	r[8] !== C ||
	r[9] !== x ||
	r[10] !== y ||
	r[11] !== f
		? ((I = {
				...e,
				layoutDelegate: T,
				buttonRef: b,
				popoverRef: C,
				listBoxRef: x,
				inputRef: y,
				menuTrigger: f,
			}),
			(r[5] = e),
			(r[6] = T),
			(r[7] = b),
			(r[8] = C),
			(r[9] = x),
			(r[10] = y),
			(r[11] = f),
			(r[12] = I))
		: (I = r[12]);
	const {
			buttonProps: F,
			inputProps: N,
			listBoxProps: O,
			labelProps: _,
			descriptionProps: j,
			errorMessageProps: V,
		} = BW(I, A),
		[K, M] = E.useState(),
		{ scale: G } = Rs();
	let H;
	r[13] === Symbol.for("react.memo_cache_sentinel")
		? ((H = () => {
				if (b.current && y.current) {
					const rt = b.current.offsetWidth,
						Ce = y.current.offsetWidth;
					M(Ce + rt);
				}
			}),
			(r[13] = H))
		: (H = r[13]);
	const P = H;
	let q;
	r[14] !== w || r[15] !== P
		? ((q = { ref: w, onResize: P }), (r[14] = w), (r[15] = P), (r[16] = q))
		: (q = r[16]),
		fa(q);
	let J;
	r[17] !== G || r[18] !== P
		? ((J = [G, P]), (r[17] = G), (r[18] = P), (r[19] = J))
		: (J = r[19]),
		at(P, J);
	const Z = u ?? K;
	let oe;
	r[20] !== K || r[21] !== Z
		? ((oe = { width: K, minWidth: Z }),
			(r[20] = K),
			(r[21] = Z),
			(r[22] = oe))
		: (oe = r[22]);
	const ne = oe;
	let de;
	r[23] !== e ||
	r[24] !== A.isOpen ||
	r[25] !== l ||
	r[26] !== N ||
	r[27] !== y ||
	r[28] !== F ||
	r[29] !== b
		? ((de = m.jsx(T3e, {
				...e,
				isOpen: A.isOpen,
				loadingState: l,
				inputProps: N,
				inputRef: y,
				triggerProps: F,
				triggerRef: b,
			})),
			(r[23] = e),
			(r[24] = A.isOpen),
			(r[25] = l),
			(r[26] = N),
			(r[27] = y),
			(r[28] = F),
			(r[29] = b),
			(r[30] = de))
		: (de = r[30]);
	let se;
	r[31] !== e ||
	r[32] !== j ||
	r[33] !== V ||
	r[34] !== _ ||
	r[35] !== w ||
	r[36] !== de
		? ((se = m.jsx(Yh, {
				width: "alias.singleLineWidth",
				...e,
				descriptionProps: j,
				errorMessageProps: V,
				labelProps: _,
				ref: w,
				children: de,
			})),
			(r[31] = e),
			(r[32] = j),
			(r[33] = V),
			(r[34] = _),
			(r[35] = w),
			(r[36] = de),
			(r[37] = se))
		: (se = r[37]);
	const re = d === "end" ? b : y,
		he = `${p} ${d}`,
		ye = l === "loadingMore";
	let Ae;
	r[38] !== g || r[39] !== l || r[40] !== v
		? ((Ae = () =>
				g &&
				m.jsx(ke, {
					height: "element.regular",
					alignItems: "center",
					paddingX: "medium",
					children: m.jsx(ue, {
						color: "neutralSecondary",
						children:
							l === "loading"
								? v.format("loading")
								: v.format("noResults"),
					}),
				})),
			(r[38] = g),
			(r[39] = l),
			(r[40] = v),
			(r[41] = Ae))
		: (Ae = r[41]);
	let Pe;
	r[42] !== O ||
	r[43] !== x ||
	r[44] !== A ||
	r[45] !== T ||
	r[46] !== ye ||
	r[47] !== c ||
	r[48] !== Ae
		? ((Pe = m.jsx(k0, {
				...O,
				ref: x,
				disallowEmptySelection: !0,
				autoFocus: A.focusStrategy,
				shouldSelectOnPressUp: !0,
				focusOnPointerEnter: !0,
				layout: T,
				state: A,
				shouldUseVirtualFocus: !0,
				isLoading: ye,
				onLoadMore: c,
				UNSAFE_className: jx,
				renderEmptyState: Ae,
			})),
			(r[42] = O),
			(r[43] = x),
			(r[44] = A),
			(r[45] = T),
			(r[46] = ye),
			(r[47] = c),
			(r[48] = Ae),
			(r[49] = Pe))
		: (Pe = r[49]);
	let we;
	r[50] !== A ||
	r[51] !== ne ||
	r[52] !== k ||
	r[53] !== re ||
	r[54] !== x ||
	r[55] !== he ||
	r[56] !== h ||
	r[57] !== Pe
		? ((we = m.jsx(g0, {
				state: A,
				UNSAFE_style: ne,
				ref: k,
				triggerRef: re,
				scrollRef: x,
				placement: he,
				hideArrow: !0,
				isNonModal: !0,
				shouldFlip: h,
				children: Pe,
			})),
			(r[50] = A),
			(r[51] = ne),
			(r[52] = k),
			(r[53] = re),
			(r[54] = x),
			(r[55] = he),
			(r[56] = h),
			(r[57] = Pe),
			(r[58] = we))
		: (we = r[58]);
	let Ke;
	return (
		r[59] !== se || r[60] !== we
			? ((Ke = m.jsxs(m.Fragment, { children: [se, we] })),
				(r[59] = se),
				(r[60] = we),
				(r[61] = Ke))
			: (Ke = r[61]),
		Ke
	);
});
function $3e() {
	const t = ce(2),
		[e, n] = E.useState(null);
	let r, i;
	return (
		t[0] !== e
			? ((i = [{ current: e }, n]), (t[0] = e), (t[1] = i))
			: (i = t[1]),
		(r = i),
		r
	);
}
const T3e = le.forwardRef(function (e, n) {
		let {
				isDisabled: r,
				inputProps: i,
				inputRef: o,
				triggerProps: s,
				triggerRef: a,
				autoFocus: l,
				style: u,
				loadingState: c,
				isOpen: d,
				menuTrigger: f,
			} = e,
			h = Le($5),
			p = E.useRef(),
			[g, v] = E.useState(!1),
			b = m.jsx(ke, {
				alignItems: "center",
				flexShrink: 0,
				justifyContent: "center",
				pointerEvents: "none",
				width: "element.regular",
				children: m.jsx(Cr, {
					"aria-label": h.format("loading"),
					size: "small",
					isIndeterminate: !0,
				}),
			}),
			y = c === "loading" || c === "filtering",
			x = i.value,
			C = E.useRef(x);
		return (
			E.useEffect(() => {
				y && !g
					? (p.current ||
							(p.current = setTimeout(() => {
								v(!0);
							}, 500)),
						x !== C.current &&
							(clearTimeout(p.current),
							(p.current = setTimeout(() => {
								v(!0);
							}, 500))))
					: y ||
						(v(!1), clearTimeout(p.current), (p.current = void 0)),
					(C.current = x);
			}, [y, g, x]),
			m.jsx(xn, {
				autoFocus: l,
				isTextInput: !0,
				within: !0,
				children: m.jsx("div", {
					ref: n,
					style: u,
					children: m.jsx(Jh, {
						inputProps: { ...i, className: xu.element("input") },
						ref: o,
						isDisabled: r,
						endElement: m.jsxs(m.Fragment, {
							children: [
								g && (d || f === "manual" || c === "loading")
									? b
									: null,
								m.jsx(Al, {
									preventFocusOnPress: !0,
									isPressed: d,
									children: m.jsx(UP, {
										...s,
										ref: a,
										UNSAFE_className: X({
											borderEndStartRadius: 0,
											borderStartStartRadius: 0,
											[`${xu.selector("input")}[aria-invalid] ~ &`]:
												{
													borderColor:
														B.color.alias
															.borderInvalid,
												},
											[`${xu.selector("input")}[readonly] ~ &`]:
												{
													borderColor:
														B.color.alias
															.borderIdle,
												},
											[`${xu.selector("input")}:focus ~ &`]:
												{
													borderColor:
														B.color.alias
															.borderFocused,
												},
										}),
										children: m.jsx(ve, { src: Il }),
									}),
								}),
							],
						}),
					}),
				}),
			})
		);
	}),
	L0 = le.forwardRef(S3e),
	PW = m.jsxs(m.Fragment, {
		children: [
			m.jsx("path", { d: "M6 3v12" }),
			m.jsx("circle", { cx: 18, cy: 6, r: 3 }),
			m.jsx("circle", { cx: 6, cy: 18, r: 3 }),
			m.jsx("path", { d: "M18 9a9 9 0 0 1-9 9" }),
		],
	}),
	NW = new WeakMap();
function B3e(t, e, n) {
	let { value: r, children: i, "aria-label": o, "aria-labelledby": s } = t;
	const a = t.isDisabled || e.isDisabled;
	let l = i != null,
		u = o != null || s != null;
	!l &&
		!u &&
		console.warn(
			"If you do not provide children, you must specify an aria-label for accessibility",
		);
	let c = e.selectedValue === r,
		d = (S) => {
			S.stopPropagation(), e.setSelectedValue(r);
		},
		{ pressProps: f, isPressed: h } = zi({ isDisabled: a }),
		{ pressProps: p, isPressed: g } = zi({
			isDisabled: a,
			onPress() {
				e.setSelectedValue(r);
			},
		}),
		{ focusableProps: v } = Hd(
			xe(t, { onFocus: () => e.setLastFocusedValue(r) }),
			n,
		),
		b = xe(f, v),
		y = Ge(t, { labelable: !0 }),
		x = -1;
	e.selectedValue != null
		? e.selectedValue === r && (x = 0)
		: (e.lastFocusedValue === r || e.lastFocusedValue == null) && (x = 0),
		a && (x = void 0);
	let {
		name: C,
		descriptionId: k,
		errorMessageId: w,
		validationBehavior: D,
	} = NW.get(e);
	return (
		s0(n, e.selectedValue, e.setSelectedValue),
		Ax({ validationBehavior: D }, e, n),
		{
			labelProps: xe(p, { onClick: (S) => S.preventDefault() }),
			inputProps: xe(y, {
				...b,
				type: "radio",
				name: C,
				tabIndex: x,
				disabled: a,
				required: e.isRequired && D === "native",
				checked: c,
				value: r,
				onChange: d,
				"aria-describedby":
					[t["aria-describedby"], e.isInvalid ? w : null, k]
						.filter(Boolean)
						.join(" ") || void 0,
			}),
			isDisabled: a,
			isSelected: c,
			isPressed: h || g,
		}
	);
}
function I3e(t, e) {
	let {
			name: n,
			isReadOnly: r,
			isRequired: i,
			isDisabled: o,
			orientation: s = "vertical",
			validationBehavior: a = "aria",
		} = t,
		{ direction: l } = Vt(),
		{
			isInvalid: u,
			validationErrors: c,
			validationDetails: d,
		} = e.displayValidation,
		{
			labelProps: f,
			fieldProps: h,
			descriptionProps: p,
			errorMessageProps: g,
		} = Gd({
			...t,
			labelElementType: "span",
			isInvalid: e.isInvalid,
			errorMessage: t.errorMessage || c,
		}),
		v = Ge(t, { labelable: !0 }),
		{ focusWithinProps: b } = Ud({
			onBlurWithin(C) {
				var k;
				(k = t.onBlur) === null || k === void 0 || k.call(t, C),
					e.selectedValue || e.setLastFocusedValue(null);
			},
			onFocusWithin: t.onFocus,
			onFocusWithinChange: t.onFocusChange,
		}),
		y = (C) => {
			let k;
			switch (C.key) {
				case "ArrowRight":
					l === "rtl" && s !== "vertical"
						? (k = "prev")
						: (k = "next");
					break;
				case "ArrowLeft":
					l === "rtl" && s !== "vertical"
						? (k = "next")
						: (k = "prev");
					break;
				case "ArrowDown":
					k = "next";
					break;
				case "ArrowUp":
					k = "prev";
					break;
				default:
					return;
			}
			C.preventDefault();
			let w = rr(C.currentTarget, { from: C.target }),
				D;
			k === "next"
				? ((D = w.nextNode()),
					D ||
						((w.currentNode = C.currentTarget),
						(D = w.firstChild())))
				: ((D = w.previousNode()),
					D ||
						((w.currentNode = C.currentTarget),
						(D = w.lastChild()))),
				D && (D.focus(), e.setSelectedValue(D.value));
		},
		x = Ot(n);
	return (
		NW.set(e, {
			name: x,
			descriptionId: p.id,
			errorMessageId: g.id,
			validationBehavior: a,
		}),
		{
			radioGroupProps: xe(v, {
				role: "radiogroup",
				onKeyDown: y,
				"aria-invalid": e.isInvalid || void 0,
				"aria-errormessage": t["aria-errormessage"],
				"aria-readonly": r || void 0,
				"aria-required": i || void 0,
				"aria-disabled": o || void 0,
				"aria-orientation": s,
				...h,
				...b,
			}),
			labelProps: f,
			descriptionProps: p,
			errorMessageProps: g,
			isInvalid: u,
			validationErrors: c,
			validationDetails: d,
		}
	);
}
let F3e = Math.round(Math.random() * 1e10),
	P3e = 0;
function N3e(t) {
	let e = E.useMemo(() => t.name || `radio-group-${F3e}-${++P3e}`, [t.name]);
	var n;
	let [r, i] = Ns(
			t.value,
			(n = t.defaultValue) !== null && n !== void 0 ? n : null,
			t.onChange,
		),
		[o, s] = E.useState(null),
		a = Yd({ ...t, value: r }),
		l = (c) => {
			!t.isReadOnly && !t.isDisabled && (i(c), a.commitValidation());
		},
		u = a.displayValidation.isInvalid;
	return {
		...a,
		name: e,
		selectedValue: r,
		setSelectedValue: l,
		lastFocusedValue: o,
		setLastFocusedValue: s,
		isDisabled: t.isDisabled || !1,
		isReadOnly: t.isReadOnly || !1,
		isRequired: t.isRequired || !1,
		validationState: t.validationState || (u ? "invalid" : null),
		isInvalid: u,
	};
}
const RW = le.createContext(null);
function R3e() {
	const t = le.useContext(RW);
	if (!t)
		throw new Error(
			"useRadioProvider must be used within a RadioGroupProvider",
		);
	return t;
}
const Zk = new Gr("Radio", ["indicator"]);
function EI(t) {
	const e = ce(46);
	let n, r, i;
	e[0] !== t
		? (({ children: i, autoFocus: r, ...n } = t),
			(e[0] = t),
			(e[1] = n),
			(e[2] = r),
			(e[3] = i))
		: ((n = e[1]), (r = e[2]), (i = e[3]));
	const o = ht(n),
		s = E.useRef(null),
		a = R3e(),
		{ state: l } = a;
	let u;
	e[4] !== t || e[5] !== a
		? ((u = { ...t, ...a }), (e[4] = t), (e[5] = a), (e[6] = u))
		: (u = e[6]);
	const { inputProps: c } = B3e(u, l, s);
	let d, f, h, p, g, v, b, y, x;
	if (
		e[7] !== o.className ||
		e[8] !== o.style ||
		e[9] !== r ||
		e[10] !== c ||
		e[11] !== s
	) {
		if (
			((v = X({
				position: "absolute",
				zIndex: 1,
				inset: 0,
				opacity: 1e-4,
			})),
			e[21] !== o.className)
		) {
			const A = X({
				alignItems: "flex-start",
				display: "inline-flex",
				gap: B.size.space.regular,
				position: "relative",
				userSelect: "none",
			});
			let T, I;
			e[24] === Symbol.for("react.memo_cache_sentinel")
				? ((I = {
						text: { color: "inherit" },
						description: { color: "neutralTertiary" },
					}),
					(e[24] = I))
				: (I = e[24]),
				(T = I),
				(b = T),
				(y = Se(o.className, A)),
				(e[21] = o.className),
				(e[22] = b),
				(e[23] = y);
		} else (b = e[22]), (y = e[23]);
		(x = o.style),
			(p = xn),
			(g = r),
			(d = c),
			(f = s),
			(h = Se(v)),
			(e[7] = o.className),
			(e[8] = o.style),
			(e[9] = r),
			(e[10] = c),
			(e[11] = s),
			(e[12] = d),
			(e[13] = f),
			(e[14] = h),
			(e[15] = p),
			(e[16] = g),
			(e[17] = v),
			(e[18] = b),
			(e[19] = y),
			(e[20] = x);
	} else
		(d = e[12]),
			(f = e[13]),
			(h = e[14]),
			(p = e[15]),
			(g = e[16]),
			(v = e[17]),
			(b = e[18]),
			(y = e[19]),
			(x = e[20]);
	let C;
	e[25] !== d || e[26] !== f || e[27] !== h
		? ((C = m.jsx("input", { ...d, ref: f, className: h })),
			(e[25] = d),
			(e[26] = f),
			(e[27] = h),
			(e[28] = C))
		: (C = e[28]);
	let k;
	e[29] !== p || e[30] !== g || e[31] !== C
		? ((k = m.jsx(p, { autoFocus: g, children: C })),
			(e[29] = p),
			(e[30] = g),
			(e[31] = C),
			(e[32] = k))
		: (k = e[32]);
	let w;
	e[33] !== v
		? ((w = m.jsx(O3e, { inputClassName: v })), (e[33] = v), (e[34] = w))
		: (w = e[34]);
	let D;
	e[35] !== i
		? ((D =
				i &&
				m.jsx(M3e, {
					children: $n(i) ? m.jsx(ue, { children: i }) : i,
				})),
			(e[35] = i),
			(e[36] = D))
		: (D = e[36]);
	let S;
	e[37] !== b || e[38] !== D
		? ((S = m.jsx(Cn, { slots: b, children: D })),
			(e[37] = b),
			(e[38] = D),
			(e[39] = S))
		: (S = e[39]);
	let $;
	return (
		e[40] !== y || e[41] !== x || e[42] !== k || e[43] !== w || e[44] !== S
			? (($ = m.jsxs("label", {
					className: y,
					style: x,
					children: [k, w, S],
				})),
				(e[40] = y),
				(e[41] = x),
				(e[42] = k),
				(e[43] = w),
				(e[44] = S),
				(e[45] = $))
			: ($ = e[45]),
		$
	);
}
let Tb = B.size.element.xsmall;
const O3e = (t) => {
		let { inputClassName: e } = t;
		return m.jsx("span", {
			className: Se(
				X({
					backgroundColor: B.color.background.canvas,
					borderRadius: B.size.radius.full,
					color: B.color.foreground.onEmphasis,
					display: "flex",
					flexShrink: 0,
					justifyContent: "center",
					alignItems: "center",
					position: "relative",
					height: Tb,
					width: Tb,
					[Zk.selector("indicator")]: {
						opacity: 0,
						transform: "scale(0) translate3d(0, 0, 0)",
						transition: bt(["opacity", "transform"]),
						willChange: "opacity, transform",
					},
					"::after": {
						borderRadius: B.size.radius.full,
						content: '""',
						inset: 0,
						margin: 0,
						position: "absolute",
						transition: bt(["box-shadow", "margin"], {
							easing: "easeOut",
						}),
					},
					[`.${e}[data-focus=visible] + &::after`]: {
						boxShadow: `0 0 0 ${B.size.alias.focusRing} ${B.color.alias.focusRing}`,
						margin: `calc(${B.size.alias.focusRingGap} * -1)`,
					},
					"&::before": {
						border: `${B.size.border.medium} solid ${B.color.scale.slate8}`,
						borderRadius: "inherit",
						content: '""',
						inset: 0,
						margin: 0,
						position: "absolute",
						transition: bt(["border-color", "border-width"], {
							duration: "regular",
						}),
					},
					[`.${e}:disabled + &`]: {
						color: B.color.alias.foregroundDisabled,
						"&::before": {
							backgroundColor: B.color.alias.borderDisabled,
							borderColor: B.color.alias.borderDisabled,
						},
					},
					[`.${e}:enabled:hover + &::before`]: {
						borderColor: B.color.scale.slate9,
					},
					[`.${e}:enabled:active + &::before`]: {
						borderColor: B.color.scale.slate10,
					},
					[`.${e}:checked + &`]: {
						"&::before": { borderWidth: `calc(${Tb} / 2)` },
						[Zk.selector("indicator")]: {
							opacity: 1,
							transform: "scale(1)",
						},
					},
					[`.${e}:enabled:checked + &::before`]: {
						borderColor: B.color.scale.indigo9,
					},
					[`.${e}:enabled:checked:hover + &::before`]: {
						borderColor: B.color.scale.indigo10,
					},
					[`.${e}:enabled:checked:active + &::before`]: {
						borderColor: B.color.scale.indigo11,
					},
				}),
			),
			children: m.jsx("span", {
				className: Zk.element("indicator"),
				children: m.jsx("svg", {
					className: hv,
					fill: "currentColor",
					height: 12,
					viewBox: "0 0 24 24",
					width: 12,
					children: m.jsx("circle", { cx: "12", cy: "12", r: "6" }),
				}),
			}),
		});
	},
	M3e = (t) => {
		const e = ce(3);
		let n;
		e[0] === Symbol.for("react.memo_cache_sentinel")
			? ((n = Se(
					X({
						color: B.color.alias.foregroundIdle,
						display: "grid",
						paddingTop: `calc((${Tb} - ${B.typography.text.regular.capheight}) / 2)`,
						gap: B.size.space.large,
						'input[type="radio"]:hover ~ &': {
							color: B.color.alias.foregroundHovered,
						},
						'input[type="radio"]:disabled ~ &': {
							color: B.color.alias.foregroundDisabled,
						},
					}),
				)),
				(e[0] = n))
			: (n = e[0]);
		let r;
		return (
			e[1] !== t
				? ((r = m.jsx("div", { className: n, ...t })),
					(e[1] = t),
					(e[2] = r))
				: (r = e[2]),
			r
		);
	},
	j3e = E.forwardRef(function (e, n) {
		const r = ce(22);
		e = vo(e);
		let i;
		r[0] !== e ? ((i = LN(e)), (r[0] = e), (r[1] = i)) : (i = r[1]),
			(e = i);
		const { validationState: o, children: s, orientation: a } = e,
			l = a === void 0 ? "vertical" : a,
			u = N3e(e),
			{
				radioGroupProps: c,
				labelProps: d,
				descriptionProps: f,
				errorMessageProps: h,
			} = I3e(e, u);
		let p;
		r[2] !== l
			? ((p = lt({ orientation: l })), (r[2] = l), (r[3] = p))
			: (p = r[3]);
		let g;
		r[4] === Symbol.for("react.memo_cache_sentinel")
			? ((g = Se(
					X({
						display: "flex",
						gap: B.size.space.large,
						'&[data-orientation="vertical"]': {
							flexDirection: "column",
						},
					}),
				)),
				(r[4] = g))
			: (g = r[4]);
		let v;
		r[5] !== o || r[6] !== u
			? ((v = { validationState: o, state: u }),
				(r[5] = o),
				(r[6] = u),
				(r[7] = v))
			: (v = r[7]);
		let b;
		r[8] !== v || r[9] !== s
			? ((b = m.jsx(RW.Provider, { value: v, children: s })),
				(r[8] = v),
				(r[9] = s),
				(r[10] = b))
			: (b = r[10]);
		let y;
		r[11] !== c || r[12] !== p || r[13] !== b
			? ((y = m.jsx("div", { ...c, ...p, className: g, children: b })),
				(r[11] = c),
				(r[12] = p),
				(r[13] = b),
				(r[14] = y))
			: (y = r[14]);
		let x;
		return (
			r[15] !== e ||
			r[16] !== n ||
			r[17] !== d ||
			r[18] !== f ||
			r[19] !== h ||
			r[20] !== y
				? ((x = m.jsx(Yh, {
						...e,
						ref: n,
						labelProps: d,
						labelElementType: "span",
						descriptionProps: f,
						errorMessageProps: h,
						children: y,
					})),
					(r[15] = e),
					(r[16] = n),
					(r[17] = d),
					(r[18] = f),
					(r[19] = h),
					(r[20] = y),
					(r[21] = x))
				: (x = r[21]),
			x
		);
	}),
	V0 = m.jsxs(m.Fragment, {
		children: [
			m.jsx("path", {
				d: "M12 3H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7",
			}),
			m.jsx("path", {
				d: "M18.375 2.625a2.121 2.121 0 1 1 3 3L12 15l-4 1 1-4Z",
			}),
		],
	}),
	S3 = m.jsx("path", {
		d: "M15 3h6v6M10 14 21 3M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6",
	}),
	OW = m.jsxs(m.Fragment, {
		children: [
			m.jsx("path", {
				d: "M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71",
			}),
			m.jsx("path", {
				d: "M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71",
			}),
		],
	}),
	MW = m.jsx("path", {
		d: "m18.84 12.25 1.72-1.71h-.02a5.004 5.004 0 0 0-.12-7.07 5.006 5.006 0 0 0-6.95 0l-1.72 1.71M5.17 11.75l-1.71 1.71a5.004 5.004 0 0 0 .12 7.07 5.006 5.006 0 0 0 6.95 0l1.71-1.71M8 2v3M2 8h3M16 19v3M19 16h3",
	});
var T5 = {};
(function (t) {
	Object.defineProperty(t, "__esModule", { value: !0 }),
		(t.sanitizeUrl = t.BLANK_URL = void 0);
	var e = /^([^\w]*)(javascript|data|vbscript)/im,
		n = /&#(\w+)(^\w|;)?/g,
		r = /&(newline|tab);/gi,
		i = /[\u0000-\u001F\u007F-\u009F\u2000-\u200D\uFEFF]/gim,
		o = /^.+(:|&colon;)/gim,
		s = [".", "/"];
	t.BLANK_URL = "about:blank";
	function a(c) {
		return s.indexOf(c[0]) > -1;
	}
	function l(c) {
		var d = c.replace(i, "");
		return d.replace(n, function (f, h) {
			return String.fromCharCode(h);
		});
	}
	function u(c) {
		if (!c) return t.BLANK_URL;
		var d = l(c).replace(r, "").replace(i, "").trim();
		if (!d) return t.BLANK_URL;
		if (a(d)) return d;
		var f = d.match(o);
		if (!f) return d;
		var h = f[0];
		return e.test(h) ? t.BLANK_URL : d;
	}
	t.sanitizeUrl = u;
})(T5);
const _3e = { none: "toolbar", single: "radiogroup", multiple: "toolbar" };
function z3e(t, e, n) {
	let { isDisabled: r, orientation: i = "horizontal" } = t,
		[o, s] = E.useState(!1);
	at(() => {
		var h;
		s(
			!!(
				n.current &&
				!((h = n.current.parentElement) === null || h === void 0) &&
				h.closest('[role="toolbar"]')
			),
		);
	}, [n]),
		[...e.collection.getKeys()].some((h) => !e.disabledKeys.has(h)) ||
			(r = !0);
	let { direction: l } = Vt(),
		u = $9(n),
		c = l === "rtl" && i === "horizontal",
		d = (h) => {
			if (h.currentTarget.contains(h.target))
				switch (h.key) {
					case "ArrowRight":
					case "ArrowDown":
						h.preventDefault(),
							h.stopPropagation(),
							h.key === "ArrowRight" && c
								? u.focusPrevious({ wrap: !0 })
								: u.focusNext({ wrap: !0 });
						break;
					case "ArrowLeft":
					case "ArrowUp":
						h.preventDefault(),
							h.stopPropagation(),
							h.key === "ArrowLeft" && c
								? u.focusNext({ wrap: !0 })
								: u.focusPrevious({ wrap: !0 });
						break;
				}
		},
		f = _3e[e.selectionManager.selectionMode];
	return (
		o && f === "toolbar" && (f = "group"),
		{
			actionGroupProps: {
				...Ge(t, { labelable: !0 }),
				role: f,
				"aria-orientation": f === "toolbar" ? i : void 0,
				"aria-disabled": r,
				onKeyDown: d,
			},
		}
	);
}
const L3e = { none: void 0, single: "radio", multiple: "checkbox" };
function jW(t, e, n) {
	let r = e.selectionManager.selectionMode,
		i = { role: L3e[r] };
	if (r !== "none") {
		let a = e.selectionManager.isSelected(t.key);
		i["aria-checked"] = a;
	}
	let o = t.key === e.selectionManager.focusedKey,
		s = Pt(() => {
			o && e.selectionManager.setFocusedKey(null);
		});
	return (
		E.useEffect(
			() => () => {
				s();
			},
			[s],
		),
		{
			buttonProps: xe(i, {
				tabIndex: o || e.selectionManager.focusedKey == null ? 0 : -1,
				onFocus() {
					e.selectionManager.setFocusedKey(t.key);
				},
				onPress() {
					e.selectionManager.select(t.key);
				},
			}),
		}
	);
}
function V3e(t, e) {
	(t = vo(t)), (t = Yr(t, "actionGroup"));
	let {
		density: n,
		prominence: r,
		isJustified: i,
		isDisabled: o,
		orientation: s = "horizontal",
		overflowMode: a = "wrap",
		onAction: l,
		buttonLabelBehavior: u,
		summaryIcon: c,
		...d
	} = t;
	r = r === "low" ? "low" : "default";
	let f = Ct(e),
		h = E.useRef(null),
		p = y0({ ...t, suppressTextValueWarning: !0 }),
		{ actionGroupProps: g } = z3e(t, p, f),
		v = { isDisabled: o },
		b = ht(t),
		y = E.useMemo(
			() => [...p.collection].every((N) => typeof N.rendered != "string"),
			[p.collection],
		),
		[{ visibleItems: x, hideButtonText: C, isMeasuring: k }, w] = ox({
			visibleItems: p.collection.size,
			hideButtonText: u === "hide" && y,
			isMeasuring: !1,
		}),
		D = p.selectionManager.selectionMode,
		S = E.useCallback(() => {
			if (a === "wrap" || (s === "vertical" && D !== "none")) return;
			let N = (O) => {
				if (f.current && h.current) {
					let _ = Array.from(f.current.children),
						j =
							s === "horizontal"
								? h.current.getBoundingClientRect().width
								: h.current.getBoundingClientRect().height,
						V = O < p.collection.size,
						K = 0,
						M = 0;
					if (V) {
						let G = _.pop();
						G &&
							(K +=
								s === "horizontal"
									? DI(G, !1, !0)
									: SI(G, !1, !0));
					}
					for (let [G, H] of _.entries())
						if (
							((K +=
								s === "horizontal"
									? DI(H, G === 0, G === _.length - 1)
									: SI(H, G === 0, G === _.length - 1)),
							Math.round(K) <= Math.round(j))
						)
							M++;
						else break;
					return D !== "none" && M < p.collection.size ? 0 : M;
				}
				return O;
			};
			w(function* () {
				let O = u === "hide" && y;
				yield {
					visibleItems: p.collection.size,
					hideButtonText: O,
					isMeasuring: !0,
				};
				let _ = N(p.collection.size),
					j = _ < p.collection.size && _ > 0;
				_ < p.collection.size &&
					u === "collapse" &&
					y &&
					(yield {
						visibleItems: p.collection.size,
						hideButtonText: !0,
						isMeasuring: !0,
					},
					(_ = N(p.collection.size)),
					(j = _ < p.collection.size && _ > 0),
					(O = !0)),
					yield {
						visibleItems: _,
						hideButtonText: O,
						isMeasuring: j,
					},
					j &&
						(yield {
							visibleItems: N(_),
							hideButtonText: O,
							isMeasuring: !1,
						});
			});
		}, [f, p.collection, w, a, D, u, y, s]),
		$ = E.useMemo(
			() => ({
				get current() {
					var N;
					return (N = h.current) === null || N === void 0
						? void 0
						: N.parentElement;
				},
			}),
			[h],
		);
	fa({ ref: a !== "wrap" ? $ : void 0, onResize: S }),
		at(S, [S, p.collection]);
	let A = [...p.collection],
		T = null,
		I = {};
	if (
		(a === "collapse" &&
			x === 0 &&
			((I = Ge(t, { labelable: !0 })), (g = {})),
		a === "collapse" && x < p.collection.size)
	) {
		let N = A.slice(x);
		(A = A.slice(0, x)),
			(T = m.jsx(U3e, {
				...I,
				items: N,
				prominence: r,
				onAction: l,
				isDisabled: o,
				state: p,
				summaryIcon: c,
				hideButtonText: C,
				isOnlyItem: x === 0,
				orientation: s,
			}));
	}
	let F = { ...b.style, flexBasis: k ? "100%" : void 0 };
	return m.jsx(nc, {
		children: m.jsx("div", {
			...b,
			style: F,
			className: Se(X({ display: "flex", minWidth: 0 }), b.className),
			ref: h,
			children: m.jsx("div", {
				...g,
				...lt({
					overflow: a,
					prominence: r,
					justified: (i && !k) || void 0,
					compact: n === "compact" || void 0,
					vertical: s === "vertical" || void 0,
				}),
				ref: f,
				className: Se(
					X({
						display: "flex",
						margin: "calc(var(--action-item-gap) / -2)",
						minWidth: 0,
						width: "calc(100% + var(--action-item-gap) + 1px)",
						"--action-item-gap": B.size.space.regular,
						[qc.selector("root", "child")]: {
							margin: "calc(var(--action-item-gap) / 2)",
						},
						"&[data-overflow=wrap]": { flexWrap: "wrap" },
						"&[data-justified]": {
							[qc.selector("root", "child")]: { flexGrow: 1 },
						},
						"&[data-compact]:not([data-prominence=low])": {
							"--action-item-gap": 0,
							[qc.selector("root", "child")]: {
								borderRadius: 0,
								"&:first-of-type": {
									borderTopLeftRadius: B.size.radius.regular,
									borderBottomLeftRadius:
										B.size.radius.regular,
								},
								"&:last-of-type": {
									borderTopRightRadius: B.size.radius.regular,
									borderBottomRightRadius:
										B.size.radius.regular,
								},
								"&:not(:last-of-type)": {
									marginRight: `calc(${B.size.border.regular} * -1)`,
								},
								"&[data-interaction=hover], &[data-focus=visible], &[data-interaction=press]":
									{ zIndex: 1 },
								"&[data-selected]": { zIndex: 2 },
							},
						},
						"&[data-compact][data-prominence=low]": {
							"--action-item-gap": B.size.space.small,
						},
					}),
					d.UNSAFE_className,
				),
				children: m.jsxs(Hh, {
					...v,
					children: [
						A.map((N) =>
							m.jsx(
								K3e,
								{
									onAction: l,
									prominence: r,
									isDisabled: o,
									item: N,
									state: p,
									hideButtonText: C,
									orientation: s,
								},
								N.key,
							),
						),
						T,
					],
				}),
			}),
		}),
	});
}
const nf = E.forwardRef(V3e);
function K3e(t) {
	const e = ce(58);
	let {
		item: n,
		state: r,
		isDisabled: i,
		onAction: o,
		hideButtonText: s,
		orientation: a,
		prominence: l,
	} = t;
	const u = E.useRef(null);
	let c;
	e[0] !== n.key
		? ((c = { key: n.key }), (e[0] = n.key), (e[1] = c))
		: (c = e[1]);
	let { buttonProps: d } = jW(c, r),
		f;
	e[2] !== i || e[3] !== r || e[4] !== n
		? ((f = i || r.disabledKeys.has(n.key)),
			(e[2] = i),
			(e[3] = r),
			(e[4] = n),
			(e[5] = f))
		: (f = e[5]),
		(i = f);
	let h;
	e[6] !== r.selectionManager || e[7] !== n.key
		? ((h = r.selectionManager.isSelected(n.key)),
			(e[6] = r.selectionManager),
			(e[7] = n.key),
			(e[8] = h))
		: (h = e[8]);
	const p = h,
		g = Ge(n.props);
	if (o && !i) {
		let G;
		e[9] !== o || e[10] !== n.key
			? ((G = () => o(n.key)), (e[9] = o), (e[10] = n.key), (e[11] = G))
			: (G = e[11]);
		let H;
		e[12] !== G || e[13] !== d
			? ((H = xe(d, { onPress: G })),
				(e[12] = G),
				(e[13] = d),
				(e[14] = H))
			: (H = e[14]),
			(d = H);
	}
	const v = Ot(),
		b = Ot(),
		[y, x] = E.useState(""),
		[C, k] = E.useState("");
	let w;
	e[15] !== s || e[16] !== v || e[17] !== b
		? ((w = () => {
				if (s) {
					var G, H;
					x(
						(G = document.getElementById(v)) === null ||
							G === void 0
							? void 0
							: G.textContent,
					),
						k(
							(H = document.getElementById(b)) === null ||
								H === void 0
								? void 0
								: H.textContent,
						);
				}
			}),
			(e[15] = s),
			(e[16] = v),
			(e[17] = b),
			(e[18] = w))
		: (w = e[18]);
	let D;
	e[19] !== s || e[20] !== n.rendered || e[21] !== v || e[22] !== b
		? ((D = [s, n.rendered, v, b]),
			(e[19] = s),
			(e[20] = n.rendered),
			(e[21] = v),
			(e[22] = b),
			(e[23] = D))
		: (D = e[23]),
		at(w, D);
	const S = xe(d, g),
		$ = s ? b : void 0;
	let A;
	e[24] !== $
		? ((A = { id: $, isHidden: !0 }), (e[24] = $), (e[25] = A))
		: (A = e[25]);
	const T = s ? v : void 0;
	let I;
	e[26] !== T || e[27] !== s
		? ((I = { id: T, isHidden: s }), (e[26] = T), (e[27] = s), (e[28] = I))
		: (I = e[28]);
	let F;
	e[29] !== A || e[30] !== I
		? ((F = { kbd: A, text: I }), (e[29] = A), (e[30] = I), (e[31] = F))
		: (F = e[31]);
	let N;
	e[32] === Symbol.for("react.memo_cache_sentinel")
		? ((N = Se(X({ flexShrink: 0 }))), (e[32] = N))
		: (N = e[32]);
	const O = n["aria-label"],
		_ = n["aria-label"] == null && s ? v : void 0;
	let j;
	e[33] !== n.props ||
	e[34] !== n.rendered ||
	e[35] !== l ||
	e[36] !== u ||
	e[37] !== p ||
	e[38] !== i ||
	e[39] !== O ||
	e[40] !== _
		? ((j = m.jsx(Re, {
				...n.props,
				prominence: l,
				ref: u,
				UNSAFE_className: N,
				isSelected: p,
				isDisabled: i,
				"aria-label": O,
				"aria-labelledby": _,
				children: n.rendered,
			})),
			(e[33] = n.props),
			(e[34] = n.rendered),
			(e[35] = l),
			(e[36] = u),
			(e[37] = p),
			(e[38] = i),
			(e[39] = O),
			(e[40] = _),
			(e[41] = j))
		: (j = e[41]);
	let V;
	e[42] !== F || e[43] !== j
		? ((V = m.jsx(c0, { children: m.jsx(Cn, { slots: F, children: j }) })),
			(e[42] = F),
			(e[43] = j),
			(e[44] = V))
		: (V = e[44]);
	let K;
	e[45] !== S || e[46] !== V
		? ((K = m.jsx(Al, { ...S, children: V })),
			(e[45] = S),
			(e[46] = V),
			(e[47] = K))
		: (K = e[47]);
	let M = K;
	if (s && y) {
		const G = a === "vertical" ? "end" : "top";
		let H;
		e[48] !== C || e[49] !== y
			? ((H = m.jsx(Xe, {
					children: C
						? m.jsxs(m.Fragment, {
								children: [
									m.jsx(ue, { children: y }),
									m.jsx(fi, { children: C }),
								],
							})
						: y,
				})),
				(e[48] = C),
				(e[49] = y),
				(e[50] = H))
			: (H = e[50]);
		let P;
		e[51] !== G || e[52] !== M || e[53] !== H
			? ((P = m.jsxs(Ze, { placement: G, children: [M, H] })),
				(e[51] = G),
				(e[52] = M),
				(e[53] = H),
				(e[54] = P))
			: (P = e[54]),
			(M = P);
	}
	if (n.wrapper) {
		let G;
		e[55] !== n || e[56] !== M
			? ((G = n.wrapper(M)), (e[55] = n), (e[56] = M), (e[57] = G))
			: (G = e[57]),
			(M = G);
	}
	return M;
}
function U3e({
	hideButtonText: t,
	isDisabled: e,
	isOnlyItem: n,
	items: r,
	onAction: i,
	orientation: o,
	prominence: s,
	state: a,
	summaryIcon: l,
	...u
}) {
	let c = r[0].key,
		{ buttonProps: d } = jW({ key: c }, a);
	delete d.onPress, delete d.role, delete d["aria-checked"];
	let f = u["aria-label"] || (u["aria-labelledby"] ? void 0 : "…"),
		h = u["aria-labelledby"],
		p = Ot(),
		g = Ot();
	a.selectionManager.selectionMode === "none" && (l = null);
	let v =
		a.selectionManager.selectionMode !== "none" &&
		r.some((y) => a.selectionManager.isSelected(y.key));
	if (
		!l &&
		a.selectionManager.selectionMode === "single" &&
		a.selectionManager.disallowEmptySelection &&
		a.selectionManager.firstSelectedKey != null
	) {
		let y = a.collection.getItem(a.selectionManager.firstSelectedKey);
		if (y) {
			var b;
			(l = y.rendered),
				$n(l) && (l = m.jsx(ue, { children: l })),
				(h = `${(b = h) !== null && b !== void 0 ? b : g} ${p}`);
		}
	}
	return (
		l &&
			(l = m.jsxs(m.Fragment, { children: [l, m.jsx(ve, { src: Il })] })),
		m.jsxs(Xo, {
			align: n ? "start" : "end",
			direction: o === "vertical" ? "end" : "bottom",
			children: [
				m.jsx(Cn, {
					slots: { text: { id: t ? p : void 0, isHidden: t } },
					children: m.jsx(Al, {
						...d,
						children: m.jsx(Re, {
							...u,
							id: g,
							prominence: s,
							"aria-label": f,
							"aria-labelledby": h,
							isDisabled: e,
							isSelected: v,
							children: l || m.jsx(ve, { src: U_ }),
						}),
					}),
				}),
				m.jsx(Jo, {
					items: r,
					disabledKeys: a.disabledKeys,
					selectionMode: a.selectionManager.selectionMode,
					selectedKeys: a.selectionManager.selectedKeys,
					disallowEmptySelection:
						a.selectionManager.disallowEmptySelection,
					onSelectionChange: (y) =>
						a.selectionManager.setSelectedKeys(y),
					onAction: i,
					children: (y) =>
						m.jsx(Mt, {
							...y.props,
							textValue: y.textValue,
							children: y.rendered,
						}),
				}),
			],
		})
	);
}
function DI(t, e, n) {
	let r = window.getComputedStyle(t);
	return (
		t.offsetWidth + (e ? 0 : by(r.marginLeft)) + (n ? 0 : by(r.marginRight))
	);
}
function SI(t, e, n) {
	let r = window.getComputedStyle(t);
	return (
		t.offsetHeight +
		(e ? 0 : by(r.marginTop)) +
		(n ? 0 : by(r.marginBottom))
	);
}
function by(t) {
	let e = parseInt(t, 10);
	return isNaN(e) ? 0 : e;
}
const H3e = m.jsx("path", {
		d: "M8 3H5a2 2 0 0 0-2 2v3M21 8V5a2 2 0 0 0-2-2h-3M3 16v3a2 2 0 0 0 2 2h3M16 21h3a2 2 0 0 0 2-2v-3",
	}),
	W3e = m.jsx("path", {
		d: "M8 3v3a2 2 0 0 1-2 2H3M21 8h-3a2 2 0 0 1-2-2V3M3 16h3a2 2 0 0 1 2 2v3M16 21v-3a2 2 0 0 1 2-2h3",
	}),
	q3e = m.jsx("path", {
		d: "m4 5 8 8M12 5l-8 8M20 19h-4c0-1.5.44-2 1.5-2.5S20 15.33 20 14c0-.47-.17-.93-.48-1.29a2.11 2.11 0 0 0-2.62-.44c-.42.24-.74.62-.9 1.07",
	}),
	G3e = m.jsx("path", {
		d: "m4 19 8-8M12 19l-8-8M20 12h-4c0-1.5.442-2 1.5-2.5S20 8.334 20 7.002c0-.472-.17-.93-.484-1.29a2.105 2.105 0 0 0-2.617-.436c-.42.239-.738.614-.899 1.06",
	}),
	Y3e = m.jsx("path", { d: "M4 7V4h16v3M9 20h6M12 4v16" }),
	J3e = m.jsx("path", { d: "M6 4v6a6 6 0 0 0 12 0V4M4 20h16" }),
	X3e = m.jsx("path", { d: "M21 6H3M15 12H3M17 18H3" }),
	Z3e = m.jsx("path", { d: "M21 6H3M21 12H9M21 18H7" }),
	Q3e = m.jsx("path", { d: "M21 6H3M17 12H7M19 18H5" });
var A3 = { exports: {} },
	_W = {
		À: "A",
		Á: "A",
		Â: "A",
		Ã: "A",
		Ä: "A",
		Å: "A",
		Ấ: "A",
		Ắ: "A",
		Ẳ: "A",
		Ẵ: "A",
		Ặ: "A",
		Æ: "AE",
		Ầ: "A",
		Ằ: "A",
		Ȃ: "A",
		Ả: "A",
		Ạ: "A",
		Ẩ: "A",
		Ẫ: "A",
		Ậ: "A",
		Ç: "C",
		Ḉ: "C",
		È: "E",
		É: "E",
		Ê: "E",
		Ë: "E",
		Ế: "E",
		Ḗ: "E",
		Ề: "E",
		Ḕ: "E",
		Ḝ: "E",
		Ȇ: "E",
		Ẻ: "E",
		Ẽ: "E",
		Ẹ: "E",
		Ể: "E",
		Ễ: "E",
		Ệ: "E",
		Ì: "I",
		Í: "I",
		Î: "I",
		Ï: "I",
		Ḯ: "I",
		Ȋ: "I",
		Ỉ: "I",
		Ị: "I",
		Ð: "D",
		Ñ: "N",
		Ò: "O",
		Ó: "O",
		Ô: "O",
		Õ: "O",
		Ö: "O",
		Ø: "O",
		Ố: "O",
		Ṍ: "O",
		Ṓ: "O",
		Ȏ: "O",
		Ỏ: "O",
		Ọ: "O",
		Ổ: "O",
		Ỗ: "O",
		Ộ: "O",
		Ờ: "O",
		Ở: "O",
		Ỡ: "O",
		Ớ: "O",
		Ợ: "O",
		Ù: "U",
		Ú: "U",
		Û: "U",
		Ü: "U",
		Ủ: "U",
		Ụ: "U",
		Ử: "U",
		Ữ: "U",
		Ự: "U",
		Ý: "Y",
		à: "a",
		á: "a",
		â: "a",
		ã: "a",
		ä: "a",
		å: "a",
		ấ: "a",
		ắ: "a",
		ẳ: "a",
		ẵ: "a",
		ặ: "a",
		æ: "ae",
		ầ: "a",
		ằ: "a",
		ȃ: "a",
		ả: "a",
		ạ: "a",
		ẩ: "a",
		ẫ: "a",
		ậ: "a",
		ç: "c",
		ḉ: "c",
		è: "e",
		é: "e",
		ê: "e",
		ë: "e",
		ế: "e",
		ḗ: "e",
		ề: "e",
		ḕ: "e",
		ḝ: "e",
		ȇ: "e",
		ẻ: "e",
		ẽ: "e",
		ẹ: "e",
		ể: "e",
		ễ: "e",
		ệ: "e",
		ì: "i",
		í: "i",
		î: "i",
		ï: "i",
		ḯ: "i",
		ȋ: "i",
		ỉ: "i",
		ị: "i",
		ð: "d",
		ñ: "n",
		ò: "o",
		ó: "o",
		ô: "o",
		õ: "o",
		ö: "o",
		ø: "o",
		ố: "o",
		ṍ: "o",
		ṓ: "o",
		ȏ: "o",
		ỏ: "o",
		ọ: "o",
		ổ: "o",
		ỗ: "o",
		ộ: "o",
		ờ: "o",
		ở: "o",
		ỡ: "o",
		ớ: "o",
		ợ: "o",
		ù: "u",
		ú: "u",
		û: "u",
		ü: "u",
		ủ: "u",
		ụ: "u",
		ử: "u",
		ữ: "u",
		ự: "u",
		ý: "y",
		ÿ: "y",
		Ā: "A",
		ā: "a",
		Ă: "A",
		ă: "a",
		Ą: "A",
		ą: "a",
		Ć: "C",
		ć: "c",
		Ĉ: "C",
		ĉ: "c",
		Ċ: "C",
		ċ: "c",
		Č: "C",
		č: "c",
		C̆: "C",
		c̆: "c",
		Ď: "D",
		ď: "d",
		Đ: "D",
		đ: "d",
		Ē: "E",
		ē: "e",
		Ĕ: "E",
		ĕ: "e",
		Ė: "E",
		ė: "e",
		Ę: "E",
		ę: "e",
		Ě: "E",
		ě: "e",
		Ĝ: "G",
		Ǵ: "G",
		ĝ: "g",
		ǵ: "g",
		Ğ: "G",
		ğ: "g",
		Ġ: "G",
		ġ: "g",
		Ģ: "G",
		ģ: "g",
		Ĥ: "H",
		ĥ: "h",
		Ħ: "H",
		ħ: "h",
		Ḫ: "H",
		ḫ: "h",
		Ĩ: "I",
		ĩ: "i",
		Ī: "I",
		ī: "i",
		Ĭ: "I",
		ĭ: "i",
		Į: "I",
		į: "i",
		İ: "I",
		ı: "i",
		Ĳ: "IJ",
		ĳ: "ij",
		Ĵ: "J",
		ĵ: "j",
		Ķ: "K",
		ķ: "k",
		Ḱ: "K",
		ḱ: "k",
		K̆: "K",
		k̆: "k",
		Ĺ: "L",
		ĺ: "l",
		Ļ: "L",
		ļ: "l",
		Ľ: "L",
		ľ: "l",
		Ŀ: "L",
		ŀ: "l",
		Ł: "l",
		ł: "l",
		Ḿ: "M",
		ḿ: "m",
		M̆: "M",
		m̆: "m",
		Ń: "N",
		ń: "n",
		Ņ: "N",
		ņ: "n",
		Ň: "N",
		ň: "n",
		ŉ: "n",
		N̆: "N",
		n̆: "n",
		Ō: "O",
		ō: "o",
		Ŏ: "O",
		ŏ: "o",
		Ő: "O",
		ő: "o",
		Œ: "OE",
		œ: "oe",
		P̆: "P",
		p̆: "p",
		Ŕ: "R",
		ŕ: "r",
		Ŗ: "R",
		ŗ: "r",
		Ř: "R",
		ř: "r",
		R̆: "R",
		r̆: "r",
		Ȓ: "R",
		ȓ: "r",
		Ś: "S",
		ś: "s",
		Ŝ: "S",
		ŝ: "s",
		Ş: "S",
		Ș: "S",
		ș: "s",
		ş: "s",
		Š: "S",
		š: "s",
		Ţ: "T",
		ţ: "t",
		ț: "t",
		Ț: "T",
		Ť: "T",
		ť: "t",
		Ŧ: "T",
		ŧ: "t",
		T̆: "T",
		t̆: "t",
		Ũ: "U",
		ũ: "u",
		Ū: "U",
		ū: "u",
		Ŭ: "U",
		ŭ: "u",
		Ů: "U",
		ů: "u",
		Ű: "U",
		ű: "u",
		Ų: "U",
		ų: "u",
		Ȗ: "U",
		ȗ: "u",
		V̆: "V",
		v̆: "v",
		Ŵ: "W",
		ŵ: "w",
		Ẃ: "W",
		ẃ: "w",
		X̆: "X",
		x̆: "x",
		Ŷ: "Y",
		ŷ: "y",
		Ÿ: "Y",
		Y̆: "Y",
		y̆: "y",
		Ź: "Z",
		ź: "z",
		Ż: "Z",
		ż: "z",
		Ž: "Z",
		ž: "z",
		ſ: "s",
		ƒ: "f",
		Ơ: "O",
		ơ: "o",
		Ư: "U",
		ư: "u",
		Ǎ: "A",
		ǎ: "a",
		Ǐ: "I",
		ǐ: "i",
		Ǒ: "O",
		ǒ: "o",
		Ǔ: "U",
		ǔ: "u",
		Ǖ: "U",
		ǖ: "u",
		Ǘ: "U",
		ǘ: "u",
		Ǚ: "U",
		ǚ: "u",
		Ǜ: "U",
		ǜ: "u",
		Ứ: "U",
		ứ: "u",
		Ṹ: "U",
		ṹ: "u",
		Ǻ: "A",
		ǻ: "a",
		Ǽ: "AE",
		ǽ: "ae",
		Ǿ: "O",
		ǿ: "o",
		Þ: "TH",
		þ: "th",
		Ṕ: "P",
		ṕ: "p",
		Ṥ: "S",
		ṥ: "s",
		X́: "X",
		x́: "x",
		Ѓ: "Г",
		ѓ: "г",
		Ќ: "К",
		ќ: "к",
		A̋: "A",
		a̋: "a",
		E̋: "E",
		e̋: "e",
		I̋: "I",
		i̋: "i",
		Ǹ: "N",
		ǹ: "n",
		Ồ: "O",
		ồ: "o",
		Ṑ: "O",
		ṑ: "o",
		Ừ: "U",
		ừ: "u",
		Ẁ: "W",
		ẁ: "w",
		Ỳ: "Y",
		ỳ: "y",
		Ȁ: "A",
		ȁ: "a",
		Ȅ: "E",
		ȅ: "e",
		Ȉ: "I",
		ȉ: "i",
		Ȍ: "O",
		ȍ: "o",
		Ȑ: "R",
		ȑ: "r",
		Ȕ: "U",
		ȕ: "u",
		B̌: "B",
		b̌: "b",
		Č̣: "C",
		č̣: "c",
		Ê̌: "E",
		ê̌: "e",
		F̌: "F",
		f̌: "f",
		Ǧ: "G",
		ǧ: "g",
		Ȟ: "H",
		ȟ: "h",
		J̌: "J",
		ǰ: "j",
		Ǩ: "K",
		ǩ: "k",
		M̌: "M",
		m̌: "m",
		P̌: "P",
		p̌: "p",
		Q̌: "Q",
		q̌: "q",
		Ř̩: "R",
		ř̩: "r",
		Ṧ: "S",
		ṧ: "s",
		V̌: "V",
		v̌: "v",
		W̌: "W",
		w̌: "w",
		X̌: "X",
		x̌: "x",
		Y̌: "Y",
		y̌: "y",
		A̧: "A",
		a̧: "a",
		B̧: "B",
		b̧: "b",
		Ḑ: "D",
		ḑ: "d",
		Ȩ: "E",
		ȩ: "e",
		Ɛ̧: "E",
		ɛ̧: "e",
		Ḩ: "H",
		ḩ: "h",
		I̧: "I",
		i̧: "i",
		Ɨ̧: "I",
		ɨ̧: "i",
		M̧: "M",
		m̧: "m",
		O̧: "O",
		o̧: "o",
		Q̧: "Q",
		q̧: "q",
		U̧: "U",
		u̧: "u",
		X̧: "X",
		x̧: "x",
		Z̧: "Z",
		z̧: "z",
		й: "и",
		Й: "И",
		ё: "е",
		Ё: "Е",
	},
	zW = Object.keys(_W).join("|"),
	e4e = new RegExp(zW, "g"),
	t4e = new RegExp(zW, "");
function n4e(t) {
	return _W[t];
}
var LW = function (t) {
		return t.replace(e4e, n4e);
	},
	r4e = function (t) {
		return !!t.match(t4e);
	};
A3.exports = LW;
A3.exports.has = r4e;
A3.exports.remove = LW;
var i4e = A3.exports;
const o4e = Dl(i4e);
/**
 * @name match-sorter
 * @license MIT license.
 * @copyright (c) 2020 Kent C. Dodds
 * @author Kent C. Dodds <me@kentcdodds.com> (https://kentcdodds.com)
 */ const si = {
		CASE_SENSITIVE_EQUAL: 7,
		EQUAL: 6,
		STARTS_WITH: 5,
		WORD_STARTS_WITH: 4,
		CONTAINS: 3,
		ACRONYM: 2,
		MATCHES: 1,
		NO_MATCH: 0,
	},
	s4e = (t, e) => String(t.rankedValue).localeCompare(String(e.rankedValue));
function $3(t, e, n) {
	n === void 0 && (n = {});
	const {
			keys: r,
			threshold: i = si.MATCHES,
			baseSort: o = s4e,
			sorter: s = (u) => u.sort((c, d) => c4e(c, d, o)),
		} = n,
		a = t.reduce(l, []);
	return s(a).map((u) => {
		let { item: c } = u;
		return c;
	});
	function l(u, c, d) {
		const f = a4e(c, r, e, n),
			{ rank: h, keyThreshold: p = i } = f;
		return h >= p && u.push({ ...f, item: c, index: d }), u;
	}
}
$3.rankings = si;
function a4e(t, e, n, r) {
	if (!e) {
		const o = t;
		return {
			rankedValue: o,
			rank: AI(o, n, r),
			keyIndex: -1,
			keyThreshold: r.threshold,
		};
	}
	return h4e(t, e).reduce(
		(o, s, a) => {
			let { rank: l, rankedValue: u, keyIndex: c, keyThreshold: d } = o,
				{ itemValue: f, attributes: h } = s,
				p = AI(f, n, r),
				g = u;
			const { minRanking: v, maxRanking: b, threshold: y } = h;
			return (
				p < v && p >= si.MATCHES ? (p = v) : p > b && (p = b),
				p > l && ((l = p), (c = a), (d = y), (g = f)),
				{ rankedValue: g, rank: l, keyIndex: c, keyThreshold: d }
			);
		},
		{
			rankedValue: t,
			rank: si.NO_MATCH,
			keyIndex: -1,
			keyThreshold: r.threshold,
		},
	);
}
function AI(t, e, n) {
	return (
		(t = $I(t, n)),
		(e = $I(e, n)),
		e.length > t.length
			? si.NO_MATCH
			: t === e
				? si.CASE_SENSITIVE_EQUAL
				: ((t = t.toLowerCase()),
					(e = e.toLowerCase()),
					t === e
						? si.EQUAL
						: t.startsWith(e)
							? si.STARTS_WITH
							: t.includes(` ${e}`)
								? si.WORD_STARTS_WITH
								: t.includes(e)
									? si.CONTAINS
									: e.length === 1
										? si.NO_MATCH
										: l4e(t).includes(e)
											? si.ACRONYM
											: u4e(t, e))
	);
}
function l4e(t) {
	let e = "";
	return (
		t.split(" ").forEach((r) => {
			r.split("-").forEach((o) => {
				e += o.substr(0, 1);
			});
		}),
		e
	);
}
function u4e(t, e) {
	let n = 0,
		r = 0;
	function i(l, u, c) {
		for (let d = c, f = u.length; d < f; d++)
			if (u[d] === l) return (n += 1), d + 1;
		return -1;
	}
	function o(l) {
		const u = 1 / l,
			c = n / e.length;
		return si.MATCHES + c * u;
	}
	const s = i(e[0], t, 0);
	if (s < 0) return si.NO_MATCH;
	r = s;
	for (let l = 1, u = e.length; l < u; l++) {
		const c = e[l];
		if (((r = i(c, t, r)), !(r > -1))) return si.NO_MATCH;
	}
	const a = r - s;
	return o(a);
}
function c4e(t, e, n) {
	const { rank: o, keyIndex: s } = t,
		{ rank: a, keyIndex: l } = e;
	return o === a ? (s === l ? n(t, e) : s < l ? -1 : 1) : o > a ? -1 : 1;
}
function $I(t, e) {
	let { keepDiacritics: n } = e;
	return (t = `${t}`), n || (t = o4e(t)), t;
}
function d4e(t, e) {
	typeof e == "object" && (e = e.key);
	let n;
	if (typeof e == "function") n = e(t);
	else if (t == null) n = null;
	else if (Object.hasOwnProperty.call(t, e)) n = t[e];
	else {
		if (e.includes(".")) return f4e(e, t);
		n = null;
	}
	return n == null ? [] : Array.isArray(n) ? n : [String(n)];
}
function f4e(t, e) {
	const n = t.split(".");
	let r = [e];
	for (let i = 0, o = n.length; i < o; i++) {
		const s = n[i];
		let a = [];
		for (let l = 0, u = r.length; l < u; l++) {
			const c = r[l];
			if (c != null)
				if (Object.hasOwnProperty.call(c, s)) {
					const d = c[s];
					d != null && a.push(d);
				} else s === "*" && (a = a.concat(c));
		}
		r = a;
	}
	return Array.isArray(r[0]) ? [].concat(...r) : r;
}
function h4e(t, e) {
	const n = [];
	for (let r = 0, i = e.length; r < i; r++) {
		const o = e[r],
			s = p4e(o),
			a = d4e(t, o);
		for (let l = 0, u = a.length; l < u; l++)
			n.push({ itemValue: a[l], attributes: s });
	}
	return n;
}
const TI = { maxRanking: 1 / 0, minRanking: -1 / 0 };
function p4e(t) {
	return typeof t == "string" ? TI : { ...TI, ...t };
}
const m4e = m.jsx("path", {
		d: "M3 6h18M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2",
	}),
	g4e = m.jsxs(m.Fragment, {
		children: [
			m.jsx("rect", { width: 18, height: 18, x: 3, y: 3, rx: 2 }),
			m.jsx("path", { d: "M12 3v18" }),
		],
	}),
	VW = m.jsxs(m.Fragment, {
		children: [
			m.jsx("path", {
				d: "M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z",
			}),
			m.jsx("path", {
				d: "M14 2v4a2 2 0 0 0 2 2h4M12 12v6M15 15l-3-3-3 3",
			}),
		],
	}),
	b4e = {
		"ar-AE": {
			actions: "الإجراءات",
			actionsAvailable: "الإجراءات المتاحة.",
			clearSelection: "إزالة التحديد",
			selected: (t, e) =>
				`${e.plural(t.count, { "=0": "غير محدد", other: () => `${e.number(t.count)} محدد` })}`,
			selectedAll: "تم تحديد الكل",
		},
		"bg-BG": {
			actions: "Действия",
			actionsAvailable: "Налични действия.",
			clearSelection: "Изчистване на избора",
			selected: (t, e) =>
				`${e.plural(t.count, { "=0": "Няма избрани", one: () => `${e.number(t.count)} избран`, other: () => `${e.number(t.count)} избрани` })}`,
			selectedAll: "Всички избрани",
		},
		"cs-CZ": {
			actions: "Akce",
			actionsAvailable: "Dostupné akce.",
			clearSelection: "Vymazat výběr",
			selected: (t) => `Vybráno: ${t.count}`,
			selectedAll: "Vybráno vše",
		},
		"da-DK": {
			actions: "Handlinger",
			actionsAvailable: "Tilgængelige handlinger.",
			clearSelection: "Ryd markering",
			selected: (t, e) =>
				`${e.plural(t.count, { "=0": "Ingen valgt", other: () => `${e.number(t.count)} valgt` })}`,
			selectedAll: "Alle valgt",
		},
		"de-DE": {
			actions: "Aktionen",
			actionsAvailable: "Aktionen verfügbar.",
			clearSelection: "Auswahl löschen",
			selected: (t, e) =>
				`${e.plural(t.count, { "=0": "Nichts ausgewählt", one: () => `${e.number(t.count)} ausgewählt`, other: () => `${e.number(t.count)} ausgewählt` })}`,
			selectedAll: "Alles ausgewählt",
		},
		"el-GR": {
			actions: "Ενέργειες",
			actionsAvailable: "Υπάρχουν διαθέσιμες ενέργειες.",
			clearSelection: "Εκκαθάριση επιλογής",
			selected: (t, e) =>
				`${e.plural(t.count, { "=0": "Δεν επιλέχθηκε κανένα", one: () => `${e.number(t.count)} επιλεγμένο`, other: () => `${e.number(t.count)} επιλεγμένα` })}`,
			selectedAll: "Επιλέχθηκαν όλα",
		},
		"en-US": {
			clearSelection: "Clear selection",
			selected: (t, e) =>
				`${e.plural(t.count, { "=0": "None selected", other: () => `${e.number(t.count)} selected` })}`,
			selectedAll: "All selected",
			actions: "Actions",
			actionsAvailable: "Actions available.",
		},
		"es-ES": {
			actions: "Acciones",
			actionsAvailable: "Acciones disponibles.",
			clearSelection: "Borrar selección",
			selected: (t, e) =>
				`${e.plural(t.count, { "=0": "Nada seleccionado", one: () => `${e.number(t.count)} seleccionado`, other: () => `${e.number(t.count)} seleccionados` })}`,
			selectedAll: "Todo seleccionado",
		},
		"et-EE": {
			actions: "Toimingud",
			actionsAvailable: "Toimingud saadaval.",
			clearSelection: "Puhasta valik",
			selected: (t, e) =>
				`${e.plural(t.count, { "=0": "Pole valitud", other: () => `${e.number(t.count)} valitud` })}`,
			selectedAll: "Kõik valitud",
		},
		"fi-FI": {
			actions: "Toiminnot",
			actionsAvailable: "Toiminnot käytettävissä.",
			clearSelection: "Poista valinta",
			selected: (t, e) =>
				`${e.plural(t.count, { "=0": "Ei mitään valittu", other: () => `${e.number(t.count)} valittu` })}`,
			selectedAll: "Kaikki valittu",
		},
		"fr-FR": {
			actions: "Actions",
			actionsAvailable: "Actions disponibles.",
			clearSelection: "Supprimer la sélection",
			selected: (t, e) =>
				`${e.plural(t.count, { "=0": "Aucun élément sélectionné", one: () => `${e.number(t.count)} sélectionné`, other: () => `${e.number(t.count)} sélectionnés` })}`,
			selectedAll: "Toute la sélection",
		},
		"he-IL": {
			actions: "פעולות",
			actionsAvailable: "פעולות זמינות.",
			clearSelection: "נקה בחירה",
			selected: (t, e) =>
				`${e.plural(t.count, { "=0": "לא בוצעה בחירה", one: () => ` ${e.number(t.count)} בחר`, other: () => `${e.number(t.count)} נבחרו` })}",`,
			selectedAll: "כל הפריטים שנבחרו",
		},
		"hr-HR": {
			actions: "Radnje",
			actionsAvailable: "Dostupne radnje.",
			clearSelection: "Poništi odabir",
			selected: (t) => `Odabrano: ${t.count}`,
			selectedAll: "Sve je odabrano",
		},
		"hu-HU": {
			actions: "Műveletek",
			actionsAvailable: "Műveletek állnak rendelkezésre.",
			clearSelection: "Kijelölés törlése",
			selected: (t, e) =>
				`${e.plural(t.count, { "=0": "Egy sincs kijelölve", other: () => `${e.number(t.count)} kijelölve` })}`,
			selectedAll: "Mind kijelölve",
		},
		"it-IT": {
			actions: "Azioni",
			actionsAvailable: "Azioni disponibili.",
			clearSelection: "Annulla selezione",
			selected: (t, e) =>
				`${e.plural(t.count, { "=0": "Nessuno selezionato", one: () => `${e.number(t.count)} selezionato`, other: () => `${e.number(t.count)} selezionati` })}`,
			selectedAll: "Tutti selezionati",
		},
		"ja-JP": {
			actions: "アクション",
			actionsAvailable: "アクションを利用できます。",
			clearSelection: "選択をクリア",
			selected: (t, e) =>
				`${e.plural(t.count, { "=0": "選択されていません", other: () => `${e.number(t.count)} 個を選択しました` })}`,
			selectedAll: "すべてを選択",
		},
		"ko-KR": {
			actions: "액션",
			actionsAvailable: "사용 가능한 액션",
			clearSelection: "선택 항목 지우기",
			selected: (t, e) =>
				`${e.plural(t.count, { "=0": "선택된 항목 없음", other: () => `${e.number(t.count)}개 선택됨` })}`,
			selectedAll: "모두 선택됨",
		},
		"lt-LT": {
			actions: "Veiksmai",
			actionsAvailable: "Galimi veiksmai.",
			clearSelection: "Išvalyti pasirinkimą",
			selected: (t) => `Pasirinkta: ${t.count}`,
			selectedAll: "Pasirinkta viskas",
		},
		"lv-LV": {
			actions: "Darbības",
			actionsAvailable: "Pieejamas darbības.",
			clearSelection: "Notīrīt atlasi",
			selected: (t, e) =>
				`${e.plural(t.count, { "=0": "Nav atlasīts nekas", other: () => `Atlasīts(-i): ${e.number(t.count)}` })}`,
			selectedAll: "Atlasīts viss",
		},
		"nb-NO": {
			actions: "Handlinger",
			actionsAvailable: "Tilgjengelige handlinger.",
			clearSelection: "Tøm utvalg",
			selected: (t) => `Valde element: ${t.count}`,
			selectedAll: "Alle er valgt",
		},
		"nl-NL": {
			actions: "Acties",
			actionsAvailable: "Acties beschikbaar.",
			clearSelection: "Selectie wissen",
			selected: (t, e) =>
				`${e.plural(t.count, { "=0": "Niets geselecteerd", other: () => `${e.number(t.count)} geselecteerd` })}`,
			selectedAll: "Alles geselecteerd",
		},
		"pl-PL": {
			actions: "Działania",
			actionsAvailable: "Dostępne działania.",
			clearSelection: "Wyczyść zaznaczenie",
			selected: (t) => `Zaznaczono: ${t.count}`,
			selectedAll: "Wszystkie zaznaczone",
		},
		"pt-BR": {
			actions: "Ações",
			actionsAvailable: "Ações disponíveis.",
			clearSelection: "Limpar seleção",
			selected: (t, e) =>
				`${e.plural(t.count, { "=0": "Nenhum selecionado", one: () => `${e.number(t.count)} selecionado`, other: () => `${e.number(t.count)} selecionados` })}`,
			selectedAll: "Todos selecionados",
		},
		"pt-PT": {
			actions: "Ações",
			actionsAvailable: "Ações disponíveis.",
			clearSelection: "Limpar seleção",
			selected: (t, e) =>
				`${e.plural(t.count, { "=0": "Nenhum selecionado", one: () => `${e.number(t.count)} selecionado`, other: () => `${e.number(t.count)} selecionados` })}`,
			selectedAll: "Tudo selecionado",
		},
		"ro-RO": {
			actions: "Acțiuni",
			actionsAvailable: "Acțiuni disponibile.",
			clearSelection: "Goliți selecția",
			selected: (t, e) =>
				`${e.plural(t.count, { "=0": "Niciunul selectat", one: () => ` ${e.number(t.count)} selectat`, other: () => `${e.number(t.count)} selectate` })}`,
			selectedAll: "Toate selectate",
		},
		"ru-RU": {
			actions: "Действия",
			actionsAvailable: "Возможно выполнение действий.",
			clearSelection: "Очистить выбор",
			selected: (t) => `Выбрано: ${t.count}`,
			selectedAll: "Выбрано все",
		},
		"sk-SK": {
			actions: "Akcie",
			actionsAvailable: "Dostupné akcie.",
			clearSelection: "Vymazať výber",
			selected: (t) => `Vybrané položky: ${t.count}`,
			selectedAll: "Všetky vybraté položky",
		},
		"sl-SI": {
			actions: "Dejanja",
			actionsAvailable: "Na voljo so dejanja.",
			clearSelection: "Počisti izbor",
			selected: (t) => `Izbrano: ${t.count}`,
			selectedAll: "Vsi izbrani",
		},
		"sr-SP": {
			actions: "Radnje",
			actionsAvailable: "Dostupne su radnje.",
			clearSelection: "Poništi izbor",
			selected: (t) => `Izabrano: ${t.count}`,
			selectedAll: "Sve je izabrano",
		},
		"sv-SE": {
			actions: "Åtgärder",
			actionsAvailable: "Åtgärder finns.",
			clearSelection: "Rensa markering",
			selected: (t, e) =>
				`${e.plural(t.count, { "=0": "Inga valda", one: () => `${e.number(t.count)} vald`, other: () => `${e.number(t.count)} valda` })}`,
			selectedAll: "Alla markerade",
		},
		"tr-TR": {
			actions: "Eylemler",
			actionsAvailable: "Eylemler mevcut.",
			clearSelection: "Seçimi temizle",
			selected: (t, e) =>
				`${e.plural(t.count, { "=0": "Hiçbiri seçilmedi", other: () => `${e.number(t.count)} seçildi` })}`,
			selectedAll: "Tümü seçildi",
		},
		"uk-UA": {
			actions: "Дії",
			actionsAvailable: "Доступні дії.",
			clearSelection: "Очистити вибір",
			selected: (t) => `Вибрано: ${t.count}`,
			selectedAll: "Усе вибрано",
		},
		"zh-CN": {
			actions: "操作",
			actionsAvailable: "有可用操作。",
			clearSelection: "清除选择",
			selected: (t, e) =>
				`${e.plural(t.count, { "=0": "无选择", other: () => `已选择 ${e.number(t.count)} 个` })}`,
			selectedAll: "全选",
		},
		"zh-TW": {
			actions: "動作",
			actionsAvailable: "可執行的動作。",
			clearSelection: "清除選取項目",
			selected: (t, e) =>
				`${e.plural(t.count, { "=0": "未選取任何項目", other: () => `已選取 ${e.number(t.count)} 個` })}`,
			selectedAll: "已選取所有項目",
		},
	},
	vy = new Gr("ActionBar", ["bar", "container"]);
function v4e(t, e) {
	const n = ce(7),
		r = t.selectedItemCount !== 0,
		i = Ct(e);
	let o;
	n[0] !== t || n[1] !== i
		? ((o = m.jsx(x4e, { ...t, ref: i })),
			(n[0] = t),
			(n[1] = i),
			(n[2] = o))
		: (o = n[2]);
	let s;
	return (
		n[3] !== i || n[4] !== r || n[5] !== o
			? ((s = m.jsx(doe, { nodeRef: i, isOpen: r, children: o })),
				(n[3] = i),
				(n[4] = r),
				(n[5] = o),
				(n[6] = s))
			: (s = n[6]),
		s
	);
}
function y4e(t, e) {
	const n = ce(43);
	t = vo(t);
	const {
			children: r,
			onAction: i,
			onClearSelection: o,
			selectedItemCount: s,
			isOpen: a,
			items: l,
		} = t,
		u = ht(t),
		c = Le(b4e),
		[d, f] = E.useState(s);
	(s === "all" || s > 0) && s !== d && f(s);
	let h;
	n[0] !== o
		? ((h = {
				onKeyDown(O) {
					O.key === "Escape" && (O.preventDefault(), o());
				},
			}),
			(n[0] = o),
			(n[1] = h))
		: (h = n[1]);
	const { keyboardProps: p } = hx(h),
		g = E.useRef(!0);
	let v, b;
	n[2] !== c
		? ((v = () => {
				g.current &&
					((g.current = !1), xs(c.format("actionsAvailable")));
			}),
			(b = [c]),
			(n[2] = c),
			(n[3] = v),
			(n[4] = b))
		: ((v = n[3]), (b = n[4])),
		E.useEffect(v, b);
	let y;
	n[5] !== t ? ((y = Ge(t)), (n[5] = t), (n[6] = y)) : (y = n[6]);
	let x;
	n[7] !== u.className
		? ((x = Se(
				X({
					flex: "none",
					height: 0,
					opacity: 0,
					overflow: "hidden",
					transition: bt(["height", "opacity"], {
						duration: "short",
					}),
					'&[data-open="true"]': {
						height: `calc(${B.size.element.large} + (2 * ${B.size.space.regular}))`,
						opacity: 1,
					},
				}),
				vy.element("root"),
				u.className,
			)),
			(n[7] = u.className),
			(n[8] = x))
		: (x = n[8]);
	let C;
	n[9] === Symbol.for("react.memo_cache_sentinel")
		? ((C = Se(
				X({
					alignItems: "center",
					backgroundColor: B.color.background.canvas,
					border: `${B.size.border.regular} solid ${B.color.border.emphasis}`,
					borderRadius: B.size.radius.regular,
					boxShadow: `0 1px 4px ${B.color.shadow.regular}`,
					display: "grid",
					gap: B.size.space.small,
					gridTemplateAreas: '"clear selected . actiongroup"',
					gridTemplateColumns: `auto max-content minmax(${B.size.element.small}, 1fr) auto`,
					bottom: B.size.space.regular,
					insetInline: B.size.space.regular,
					isolation: "isolate",
					justifyContent: "space-between",
					margin: "0 auto",
					padding: B.size.space.regular,
					position: "absolute",
					transform: `translateY(${B.size.space.large})`,
					transition: bt("transform", { duration: "short" }),
					'&[data-open="true"]': { transform: "translateY(0)" },
				}),
				vy.element("bar"),
			)),
			(n[9] = C))
		: (C = n[9]);
	let k;
	n[10] !== c
		? ((k = c.format("actions")), (n[10] = c), (n[11] = k))
		: (k = n[11]);
	let w;
	n[12] !== l || n[13] !== k || n[14] !== i || n[15] !== r
		? ((w = m.jsx(nf, {
				items: l,
				"aria-label": k,
				prominence: "low",
				overflowMode: "collapse",
				buttonLabelBehavior: "collapse",
				onAction: i,
				gridArea: "actiongroup",
				children: r,
			})),
			(n[12] = l),
			(n[13] = k),
			(n[14] = i),
			(n[15] = r),
			(n[16] = w))
		: (w = n[16]);
	let D;
	n[17] !== c
		? ((D = c.format("clearSelection")), (n[17] = c), (n[18] = D))
		: (D = n[18]);
	let S;
	n[19] !== o ? ((S = () => o()), (n[19] = o), (n[20] = S)) : (S = n[20]);
	let $;
	n[21] === Symbol.for("react.memo_cache_sentinel")
		? (($ = m.jsx(ve, { src: cD })), (n[21] = $))
		: ($ = n[21]);
	let A;
	n[22] !== D || n[23] !== S
		? ((A = m.jsx(Re, {
				gridArea: "clear",
				"aria-label": D,
				onPress: S,
				prominence: "low",
				children: $,
			})),
			(n[22] = D),
			(n[23] = S),
			(n[24] = A))
		: (A = n[24]);
	let T;
	n[25] !== d || n[26] !== c
		? ((T = d === "all" ? c.format("selectedAll") : `${d} selected`),
			(n[25] = d),
			(n[26] = c),
			(n[27] = T))
		: (T = n[27]);
	let I;
	n[28] !== T
		? ((I = m.jsx(ue, { gridArea: "selected", children: T })),
			(n[28] = T),
			(n[29] = I))
		: (I = n[29]);
	let F;
	n[30] !== a || n[31] !== w || n[32] !== A || n[33] !== I
		? ((F = m.jsxs("div", {
				"data-open": a,
				className: C,
				children: [w, A, I],
			})),
			(n[30] = a),
			(n[31] = w),
			(n[32] = A),
			(n[33] = I),
			(n[34] = F))
		: (F = n[34]);
	let N;
	return (
		n[35] !== y ||
		n[36] !== u ||
		n[37] !== p ||
		n[38] !== a ||
		n[39] !== e ||
		n[40] !== x ||
		n[41] !== F
			? ((N = m.jsx(nc, {
					restoreFocus: !0,
					children: m.jsx("div", {
						...y,
						...u,
						...p,
						"data-open": a,
						ref: e,
						className: x,
						children: F,
					}),
				})),
				(n[35] = y),
				(n[36] = u),
				(n[37] = p),
				(n[38] = a),
				(n[39] = e),
				(n[40] = x),
				(n[41] = F),
				(n[42] = N))
			: (N = n[42]),
		N
	);
}
const x4e = le.forwardRef(y4e),
	k4e = le.forwardRef(v4e);
function C4e(t, e) {
	let n = ht(t),
		r = Ct(e);
	return m.jsx("div", {
		...Ge(t),
		...n,
		ref: r,
		className: Se(
			X({
				display: "flex",
				flexDirection: "column",
				position: "relative",
				[`& > :not(${vy.selector("root")})`]: { flex: 1, minHeight: 0 },
			}),
			vy.element("container"),
			n.className,
		),
		children: t.children,
	});
}
const w4e = le.forwardRef(C4e);
var hp = 1e9,
	E4e = {
		precision: 20,
		rounding: 4,
		toExpNeg: -7,
		toExpPos: 21,
		LN10: "2.302585092994045684017991454684364207601101488628772976033327900967572609677352480235997205089598298341967784042286",
	},
	I5,
	pn = !0,
	Go = "[DecimalError] ",
	id = Go + "Invalid argument: ",
	B5 = Go + "Exponent out of range: ",
	pp = Math.floor,
	vc = Math.pow,
	D4e = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i,
	ro,
	cr = 1e7,
	rn = 7,
	KW = 9007199254740991,
	yy = pp(KW / rn),
	je = {};
je.absoluteValue = je.abs = function () {
	var t = new this.constructor(this);
	return t.s && (t.s = 1), t;
};
je.comparedTo = je.cmp = function (t) {
	var e,
		n,
		r,
		i,
		o = this;
	if (((t = new o.constructor(t)), o.s !== t.s)) return o.s || -t.s;
	if (o.e !== t.e) return (o.e > t.e) ^ (o.s < 0) ? 1 : -1;
	for (r = o.d.length, i = t.d.length, e = 0, n = r < i ? r : i; e < n; ++e)
		if (o.d[e] !== t.d[e]) return (o.d[e] > t.d[e]) ^ (o.s < 0) ? 1 : -1;
	return r === i ? 0 : (r > i) ^ (o.s < 0) ? 1 : -1;
};
je.decimalPlaces = je.dp = function () {
	var t = this,
		e = t.d.length - 1,
		n = (e - t.e) * rn;
	if (((e = t.d[e]), e)) for (; e % 10 == 0; e /= 10) n--;
	return n < 0 ? 0 : n;
};
je.dividedBy = je.div = function (t) {
	return ll(this, new this.constructor(t));
};
je.dividedToIntegerBy = je.idiv = function (t) {
	var e = this,
		n = e.constructor;
	return Jt(ll(e, new n(t), 0, 1), n.precision);
};
je.equals = je.eq = function (t) {
	return !this.cmp(t);
};
je.exponent = function () {
	return Wn(this);
};
je.greaterThan = je.gt = function (t) {
	return this.cmp(t) > 0;
};
je.greaterThanOrEqualTo = je.gte = function (t) {
	return this.cmp(t) >= 0;
};
je.isInteger = je.isint = function () {
	return this.e > this.d.length - 2;
};
je.isNegative = je.isneg = function () {
	return this.s < 0;
};
je.isPositive = je.ispos = function () {
	return this.s > 0;
};
je.isZero = function () {
	return this.s === 0;
};
je.lessThan = je.lt = function (t) {
	return this.cmp(t) < 0;
};
je.lessThanOrEqualTo = je.lte = function (t) {
	return this.cmp(t) < 1;
};
je.logarithm = je.log = function (t) {
	var e,
		n = this,
		r = n.constructor,
		i = r.precision,
		o = i + 5;
	if (t === void 0) t = new r(10);
	else if (((t = new r(t)), t.s < 1 || t.eq(ro))) throw Error(Go + "NaN");
	if (n.s < 1) throw Error(Go + (n.s ? "NaN" : "-Infinity"));
	return n.eq(ro)
		? new r(0)
		: ((pn = !1), (e = ll(Tg(n, o), Tg(t, o), o)), (pn = !0), Jt(e, i));
};
je.minus = je.sub = function (t) {
	var e = this;
	return (
		(t = new e.constructor(t)),
		e.s == t.s ? WW(e, t) : UW(e, ((t.s = -t.s), t))
	);
};
je.modulo = je.mod = function (t) {
	var e,
		n = this,
		r = n.constructor,
		i = r.precision;
	if (((t = new r(t)), !t.s)) throw Error(Go + "NaN");
	return n.s
		? ((pn = !1), (e = ll(n, t, 0, 1).times(t)), (pn = !0), n.minus(e))
		: Jt(new r(n), i);
};
je.naturalExponential = je.exp = function () {
	return HW(this);
};
je.naturalLogarithm = je.ln = function () {
	return Tg(this);
};
je.negated = je.neg = function () {
	var t = new this.constructor(this);
	return (t.s = -t.s || 0), t;
};
je.plus = je.add = function (t) {
	var e = this;
	return (
		(t = new e.constructor(t)),
		e.s == t.s ? UW(e, t) : WW(e, ((t.s = -t.s), t))
	);
};
je.precision = je.sd = function (t) {
	var e,
		n,
		r,
		i = this;
	if (t !== void 0 && t !== !!t && t !== 1 && t !== 0) throw Error(id + t);
	if (
		((e = Wn(i) + 1),
		(r = i.d.length - 1),
		(n = r * rn + 1),
		(r = i.d[r]),
		r)
	) {
		for (; r % 10 == 0; r /= 10) n--;
		for (r = i.d[0]; r >= 10; r /= 10) n++;
	}
	return t && e > n ? e : n;
};
je.squareRoot = je.sqrt = function () {
	var t,
		e,
		n,
		r,
		i,
		o,
		s,
		a = this,
		l = a.constructor;
	if (a.s < 1) {
		if (!a.s) return new l(0);
		throw Error(Go + "NaN");
	}
	for (
		t = Wn(a),
			pn = !1,
			i = Math.sqrt(+a),
			i == 0 || i == 1 / 0
				? ((e = ta(a.d)),
					(e.length + t) % 2 == 0 && (e += "0"),
					(i = Math.sqrt(e)),
					(t = pp((t + 1) / 2) - (t < 0 || t % 2)),
					i == 1 / 0
						? (e = "5e" + t)
						: ((e = i.toExponential()),
							(e = e.slice(0, e.indexOf("e") + 1) + t)),
					(r = new l(e)))
				: (r = new l(i.toString())),
			n = l.precision,
			i = s = n + 3;
		;

	)
		if (
			((o = r),
			(r = o.plus(ll(a, o, s + 2)).times(0.5)),
			ta(o.d).slice(0, s) === (e = ta(r.d)).slice(0, s))
		) {
			if (((e = e.slice(s - 3, s + 1)), i == s && e == "4999")) {
				if ((Jt(o, n + 1, 0), o.times(o).eq(a))) {
					r = o;
					break;
				}
			} else if (e != "9999") break;
			s += 4;
		}
	return (pn = !0), Jt(r, n);
};
je.times = je.mul = function (t) {
	var e,
		n,
		r,
		i,
		o,
		s,
		a,
		l,
		u,
		c = this,
		d = c.constructor,
		f = c.d,
		h = (t = new d(t)).d;
	if (!c.s || !t.s) return new d(0);
	for (
		t.s *= c.s,
			n = c.e + t.e,
			l = f.length,
			u = h.length,
			l < u && ((o = f), (f = h), (h = o), (s = l), (l = u), (u = s)),
			o = [],
			s = l + u,
			r = s;
		r--;

	)
		o.push(0);
	for (r = u; --r >= 0; ) {
		for (e = 0, i = l + r; i > r; )
			(a = o[i] + h[r] * f[i - r - 1] + e),
				(o[i--] = a % cr | 0),
				(e = (a / cr) | 0);
		o[i] = (o[i] + e) % cr | 0;
	}
	for (; !o[--s]; ) o.pop();
	return (
		e ? ++n : o.shift(), (t.d = o), (t.e = n), pn ? Jt(t, d.precision) : t
	);
};
je.toDecimalPlaces = je.todp = function (t, e) {
	var n = this,
		r = n.constructor;
	return (
		(n = new r(n)),
		t === void 0
			? n
			: (ya(t, 0, hp),
				e === void 0 ? (e = r.rounding) : ya(e, 0, 8),
				Jt(n, t + Wn(n) + 1, e))
	);
};
je.toExponential = function (t, e) {
	var n,
		r = this,
		i = r.constructor;
	return (
		t === void 0
			? (n = Id(r, !0))
			: (ya(t, 0, hp),
				e === void 0 ? (e = i.rounding) : ya(e, 0, 8),
				(r = Jt(new i(r), t + 1, e)),
				(n = Id(r, !0, t + 1))),
		n
	);
};
je.toFixed = function (t, e) {
	var n,
		r,
		i = this,
		o = i.constructor;
	return t === void 0
		? Id(i)
		: (ya(t, 0, hp),
			e === void 0 ? (e = o.rounding) : ya(e, 0, 8),
			(r = Jt(new o(i), t + Wn(i) + 1, e)),
			(n = Id(r.abs(), !1, t + Wn(r) + 1)),
			i.isneg() && !i.isZero() ? "-" + n : n);
};
je.toInteger = je.toint = function () {
	var t = this,
		e = t.constructor;
	return Jt(new e(t), Wn(t) + 1, e.rounding);
};
je.toNumber = function () {
	return +this;
};
je.toPower = je.pow = function (t) {
	var e,
		n,
		r,
		i,
		o,
		s,
		a = this,
		l = a.constructor,
		u = 12,
		c = +(t = new l(t));
	if (!t.s) return new l(ro);
	if (((a = new l(a)), !a.s)) {
		if (t.s < 1) throw Error(Go + "Infinity");
		return a;
	}
	if (a.eq(ro)) return a;
	if (((r = l.precision), t.eq(ro))) return Jt(a, r);
	if (((e = t.e), (n = t.d.length - 1), (s = e >= n), (o = a.s), s)) {
		if ((n = c < 0 ? -c : c) <= KW) {
			for (
				i = new l(ro), e = Math.ceil(r / rn + 4), pn = !1;
				n % 2 && ((i = i.times(a)), II(i.d, e)),
					(n = pp(n / 2)),
					n !== 0;

			)
				(a = a.times(a)), II(a.d, e);
			return (pn = !0), t.s < 0 ? new l(ro).div(i) : Jt(i, r);
		}
	} else if (o < 0) throw Error(Go + "NaN");
	return (
		(o = o < 0 && t.d[Math.max(e, n)] & 1 ? -1 : 1),
		(a.s = 1),
		(pn = !1),
		(i = t.times(Tg(a, r + u))),
		(pn = !0),
		(i = HW(i)),
		(i.s = o),
		i
	);
};
je.toPrecision = function (t, e) {
	var n,
		r,
		i = this,
		o = i.constructor;
	return (
		t === void 0
			? ((n = Wn(i)), (r = Id(i, n <= o.toExpNeg || n >= o.toExpPos)))
			: (ya(t, 1, hp),
				e === void 0 ? (e = o.rounding) : ya(e, 0, 8),
				(i = Jt(new o(i), t, e)),
				(n = Wn(i)),
				(r = Id(i, t <= n || n <= o.toExpNeg, t))),
		r
	);
};
je.toSignificantDigits = je.tosd = function (t, e) {
	var n = this,
		r = n.constructor;
	return (
		t === void 0
			? ((t = r.precision), (e = r.rounding))
			: (ya(t, 1, hp), e === void 0 ? (e = r.rounding) : ya(e, 0, 8)),
		Jt(new r(n), t, e)
	);
};
je.toString =
	je.valueOf =
	je.val =
	je.toJSON =
	je[Symbol.for("nodejs.util.inspect.custom")] =
		function () {
			var t = this,
				e = Wn(t),
				n = t.constructor;
			return Id(t, e <= n.toExpNeg || e >= n.toExpPos);
		};
function UW(t, e) {
	var n,
		r,
		i,
		o,
		s,
		a,
		l,
		u,
		c = t.constructor,
		d = c.precision;
	if (!t.s || !e.s) return e.s || (e = new c(t)), pn ? Jt(e, d) : e;
	if (
		((l = t.d),
		(u = e.d),
		(s = t.e),
		(i = e.e),
		(l = l.slice()),
		(o = s - i),
		o)
	) {
		for (
			o < 0
				? ((r = l), (o = -o), (a = u.length))
				: ((r = u), (i = s), (a = l.length)),
				s = Math.ceil(d / rn),
				a = s > a ? s + 1 : a + 1,
				o > a && ((o = a), (r.length = 1)),
				r.reverse();
			o--;

		)
			r.push(0);
		r.reverse();
	}
	for (
		a = l.length,
			o = u.length,
			a - o < 0 && ((o = a), (r = u), (u = l), (l = r)),
			n = 0;
		o;

	)
		(n = ((l[--o] = l[o] + u[o] + n) / cr) | 0), (l[o] %= cr);
	for (n && (l.unshift(n), ++i), a = l.length; l[--a] == 0; ) l.pop();
	return (e.d = l), (e.e = i), pn ? Jt(e, d) : e;
}
function ya(t, e, n) {
	if (t !== ~~t || t < e || t > n) throw Error(id + t);
}
function ta(t) {
	var e,
		n,
		r,
		i = t.length - 1,
		o = "",
		s = t[0];
	if (i > 0) {
		for (o += s, e = 1; e < i; e++)
			(r = t[e] + ""), (n = rn - r.length), n && (o += tu(n)), (o += r);
		(s = t[e]), (r = s + ""), (n = rn - r.length), n && (o += tu(n));
	} else if (s === 0) return "0";
	for (; s % 10 === 0; ) s /= 10;
	return o + s;
}
var ll = (function () {
	function t(r, i) {
		var o,
			s = 0,
			a = r.length;
		for (r = r.slice(); a--; )
			(o = r[a] * i + s), (r[a] = o % cr | 0), (s = (o / cr) | 0);
		return s && r.unshift(s), r;
	}
	function e(r, i, o, s) {
		var a, l;
		if (o != s) l = o > s ? 1 : -1;
		else
			for (a = l = 0; a < o; a++)
				if (r[a] != i[a]) {
					l = r[a] > i[a] ? 1 : -1;
					break;
				}
		return l;
	}
	function n(r, i, o) {
		for (var s = 0; o--; )
			(r[o] -= s),
				(s = r[o] < i[o] ? 1 : 0),
				(r[o] = s * cr + r[o] - i[o]);
		for (; !r[0] && r.length > 1; ) r.shift();
	}
	return function (r, i, o, s) {
		var a,
			l,
			u,
			c,
			d,
			f,
			h,
			p,
			g,
			v,
			b,
			y,
			x,
			C,
			k,
			w,
			D,
			S,
			$ = r.constructor,
			A = r.s == i.s ? 1 : -1,
			T = r.d,
			I = i.d;
		if (!r.s) return new $(r);
		if (!i.s) throw Error(Go + "Division by zero");
		for (
			l = r.e - i.e,
				D = I.length,
				k = T.length,
				h = new $(A),
				p = h.d = [],
				u = 0;
			I[u] == (T[u] || 0);

		)
			++u;
		if (
			(I[u] > (T[u] || 0) && --l,
			o == null
				? (y = o = $.precision)
				: s
					? (y = o + (Wn(r) - Wn(i)) + 1)
					: (y = o),
			y < 0)
		)
			return new $(0);
		if (((y = (y / rn + 2) | 0), (u = 0), D == 1))
			for (c = 0, I = I[0], y++; (u < k || c) && y--; u++)
				(x = c * cr + (T[u] || 0)),
					(p[u] = (x / I) | 0),
					(c = x % I | 0);
		else {
			for (
				c = (cr / (I[0] + 1)) | 0,
					c > 1 &&
						((I = t(I, c)),
						(T = t(T, c)),
						(D = I.length),
						(k = T.length)),
					C = D,
					g = T.slice(0, D),
					v = g.length;
				v < D;

			)
				g[v++] = 0;
			(S = I.slice()), S.unshift(0), (w = I[0]), I[1] >= cr / 2 && ++w;
			do
				(c = 0),
					(a = e(I, g, D, v)),
					a < 0
						? ((b = g[0]),
							D != v && (b = b * cr + (g[1] || 0)),
							(c = (b / w) | 0),
							c > 1
								? (c >= cr && (c = cr - 1),
									(d = t(I, c)),
									(f = d.length),
									(v = g.length),
									(a = e(d, g, f, v)),
									a == 1 && (c--, n(d, D < f ? S : I, f)))
								: (c == 0 && (a = c = 1), (d = I.slice())),
							(f = d.length),
							f < v && d.unshift(0),
							n(g, d, v),
							a == -1 &&
								((v = g.length),
								(a = e(I, g, D, v)),
								a < 1 && (c++, n(g, D < v ? S : I, v))),
							(v = g.length))
						: a === 0 && (c++, (g = [0])),
					(p[u++] = c),
					a && g[0] ? (g[v++] = T[C] || 0) : ((g = [T[C]]), (v = 1));
			while ((C++ < k || g[0] !== void 0) && y--);
		}
		return p[0] || p.shift(), (h.e = l), Jt(h, s ? o + Wn(h) + 1 : o);
	};
})();
function HW(t, e) {
	var n,
		r,
		i,
		o,
		s,
		a,
		l = 0,
		u = 0,
		c = t.constructor,
		d = c.precision;
	if (Wn(t) > 16) throw Error(B5 + Wn(t));
	if (!t.s) return new c(ro);
	for (
		e == null ? ((pn = !1), (a = d)) : (a = e), s = new c(0.03125);
		t.abs().gte(0.1);

	)
		(t = t.times(s)), (u += 5);
	for (
		r = ((Math.log(vc(2, u)) / Math.LN10) * 2 + 5) | 0,
			a += r,
			n = i = o = new c(ro),
			c.precision = a;
		;

	) {
		if (
			((i = Jt(i.times(t), a)),
			(n = n.times(++l)),
			(s = o.plus(ll(i, n, a))),
			ta(s.d).slice(0, a) === ta(o.d).slice(0, a))
		) {
			for (; u--; ) o = Jt(o.times(o), a);
			return (c.precision = d), e == null ? ((pn = !0), Jt(o, d)) : o;
		}
		o = s;
	}
}
function Wn(t) {
	for (var e = t.e * rn, n = t.d[0]; n >= 10; n /= 10) e++;
	return e;
}
function Qk(t, e, n) {
	if (e > t.LN10.sd())
		throw (
			((pn = !0),
			n && (t.precision = n),
			Error(Go + "LN10 precision limit exceeded"))
		);
	return Jt(new t(t.LN10), e);
}
function tu(t) {
	for (var e = ""; t--; ) e += "0";
	return e;
}
function Tg(t, e) {
	var n,
		r,
		i,
		o,
		s,
		a,
		l,
		u,
		c,
		d = 1,
		f = 10,
		h = t,
		p = h.d,
		g = h.constructor,
		v = g.precision;
	if (h.s < 1) throw Error(Go + (h.s ? "NaN" : "-Infinity"));
	if (h.eq(ro)) return new g(0);
	if ((e == null ? ((pn = !1), (u = v)) : (u = e), h.eq(10)))
		return e == null && (pn = !0), Qk(g, u);
	if (
		((u += f),
		(g.precision = u),
		(n = ta(p)),
		(r = n.charAt(0)),
		(o = Wn(h)),
		Math.abs(o) < 15e14)
	) {
		for (; (r < 7 && r != 1) || (r == 1 && n.charAt(1) > 3); )
			(h = h.times(t)), (n = ta(h.d)), (r = n.charAt(0)), d++;
		(o = Wn(h)),
			r > 1
				? ((h = new g("0." + n)), o++)
				: (h = new g(r + "." + n.slice(1)));
	} else
		return (
			(l = Qk(g, u + 2, v).times(o + "")),
			(h = Tg(new g(r + "." + n.slice(1)), u - f).plus(l)),
			(g.precision = v),
			e == null ? ((pn = !0), Jt(h, v)) : h
		);
	for (
		a = s = h = ll(h.minus(ro), h.plus(ro), u),
			c = Jt(h.times(h), u),
			i = 3;
		;

	) {
		if (
			((s = Jt(s.times(c), u)),
			(l = a.plus(ll(s, new g(i), u))),
			ta(l.d).slice(0, u) === ta(a.d).slice(0, u))
		)
			return (
				(a = a.times(2)),
				o !== 0 && (a = a.plus(Qk(g, u + 2, v).times(o + ""))),
				(a = ll(a, new g(d), u)),
				(g.precision = v),
				e == null ? ((pn = !0), Jt(a, v)) : a
			);
		(a = l), (i += 2);
	}
}
function BI(t, e) {
	var n, r, i;
	for (
		(n = e.indexOf(".")) > -1 && (e = e.replace(".", "")),
			(r = e.search(/e/i)) > 0
				? (n < 0 && (n = r),
					(n += +e.slice(r + 1)),
					(e = e.substring(0, r)))
				: n < 0 && (n = e.length),
			r = 0;
		e.charCodeAt(r) === 48;

	)
		++r;
	for (i = e.length; e.charCodeAt(i - 1) === 48; ) --i;
	if (((e = e.slice(r, i)), e)) {
		if (
			((i -= r),
			(n = n - r - 1),
			(t.e = pp(n / rn)),
			(t.d = []),
			(r = (n + 1) % rn),
			n < 0 && (r += rn),
			r < i)
		) {
			for (r && t.d.push(+e.slice(0, r)), i -= rn; r < i; )
				t.d.push(+e.slice(r, (r += rn)));
			(e = e.slice(r)), (r = rn - e.length);
		} else r -= i;
		for (; r--; ) e += "0";
		if ((t.d.push(+e), pn && (t.e > yy || t.e < -yy))) throw Error(B5 + n);
	} else (t.s = 0), (t.e = 0), (t.d = [0]);
	return t;
}
function Jt(t, e, n) {
	var r,
		i,
		o,
		s,
		a,
		l,
		u,
		c,
		d = t.d;
	for (s = 1, o = d[0]; o >= 10; o /= 10) s++;
	if (((r = e - s), r < 0)) (r += rn), (i = e), (u = d[(c = 0)]);
	else {
		if (((c = Math.ceil((r + 1) / rn)), (o = d.length), c >= o)) return t;
		for (u = o = d[c], s = 1; o >= 10; o /= 10) s++;
		(r %= rn), (i = r - rn + s);
	}
	if (
		(n !== void 0 &&
			((o = vc(10, s - i - 1)),
			(a = (u / o) % 10 | 0),
			(l = e < 0 || d[c + 1] !== void 0 || u % o),
			(l =
				n < 4
					? (a || l) && (n == 0 || n == (t.s < 0 ? 3 : 2))
					: a > 5 ||
						(a == 5 &&
							(n == 4 ||
								l ||
								(n == 6 &&
									(r > 0
										? i > 0
											? u / vc(10, s - i)
											: 0
										: d[c - 1]) %
										10 &
										1) ||
								n == (t.s < 0 ? 8 : 7))))),
		e < 1 || !d[0])
	)
		return (
			l
				? ((o = Wn(t)),
					(d.length = 1),
					(e = e - o - 1),
					(d[0] = vc(10, (rn - (e % rn)) % rn)),
					(t.e = pp(-e / rn) || 0))
				: ((d.length = 1), (d[0] = t.e = t.s = 0)),
			t
		);
	if (
		(r == 0
			? ((d.length = c), (o = 1), c--)
			: ((d.length = c + 1),
				(o = vc(10, rn - r)),
				(d[c] = i > 0 ? ((u / vc(10, s - i)) % vc(10, i) | 0) * o : 0)),
		l)
	)
		for (;;)
			if (c == 0) {
				(d[0] += o) == cr && ((d[0] = 1), ++t.e);
				break;
			} else {
				if (((d[c] += o), d[c] != cr)) break;
				(d[c--] = 0), (o = 1);
			}
	for (r = d.length; d[--r] === 0; ) d.pop();
	if (pn && (t.e > yy || t.e < -yy)) throw Error(B5 + Wn(t));
	return t;
}
function WW(t, e) {
	var n,
		r,
		i,
		o,
		s,
		a,
		l,
		u,
		c,
		d,
		f = t.constructor,
		h = f.precision;
	if (!t.s || !e.s)
		return e.s ? (e.s = -e.s) : (e = new f(t)), pn ? Jt(e, h) : e;
	if (
		((l = t.d),
		(d = e.d),
		(r = e.e),
		(u = t.e),
		(l = l.slice()),
		(s = u - r),
		s)
	) {
		for (
			c = s < 0,
				c
					? ((n = l), (s = -s), (a = d.length))
					: ((n = d), (r = u), (a = l.length)),
				i = Math.max(Math.ceil(h / rn), a) + 2,
				s > i && ((s = i), (n.length = 1)),
				n.reverse(),
				i = s;
			i--;

		)
			n.push(0);
		n.reverse();
	} else {
		for (
			i = l.length, a = d.length, c = i < a, c && (a = i), i = 0;
			i < a;
			i++
		)
			if (l[i] != d[i]) {
				c = l[i] < d[i];
				break;
			}
		s = 0;
	}
	for (
		c && ((n = l), (l = d), (d = n), (e.s = -e.s)),
			a = l.length,
			i = d.length - a;
		i > 0;
		--i
	)
		l[a++] = 0;
	for (i = d.length; i > s; ) {
		if (l[--i] < d[i]) {
			for (o = i; o && l[--o] === 0; ) l[o] = cr - 1;
			--l[o], (l[i] += cr);
		}
		l[i] -= d[i];
	}
	for (; l[--a] === 0; ) l.pop();
	for (; l[0] === 0; l.shift()) --r;
	return l[0] ? ((e.d = l), (e.e = r), pn ? Jt(e, h) : e) : new f(0);
}
function Id(t, e, n) {
	var r,
		i = Wn(t),
		o = ta(t.d),
		s = o.length;
	return (
		e
			? (n && (r = n - s) > 0
					? (o = o.charAt(0) + "." + o.slice(1) + tu(r))
					: s > 1 && (o = o.charAt(0) + "." + o.slice(1)),
				(o = o + (i < 0 ? "e" : "e+") + i))
			: i < 0
				? ((o = "0." + tu(-i - 1) + o),
					n && (r = n - s) > 0 && (o += tu(r)))
				: i >= s
					? ((o += tu(i + 1 - s)),
						n && (r = n - i - 1) > 0 && (o = o + "." + tu(r)))
					: ((r = i + 1) < s &&
							(o = o.slice(0, r) + "." + o.slice(r)),
						n &&
							(r = n - s) > 0 &&
							(i + 1 === s && (o += "."), (o += tu(r)))),
		t.s < 0 ? "-" + o : o
	);
}
function II(t, e) {
	if (t.length > e) return (t.length = e), !0;
}
function qW(t) {
	var e, n, r;
	function i(o) {
		var s = this;
		if (!(s instanceof i)) return new i(o);
		if (((s.constructor = i), o instanceof i)) {
			(s.s = o.s), (s.e = o.e), (s.d = (o = o.d) ? o.slice() : o);
			return;
		}
		if (typeof o == "number") {
			if (o * 0 !== 0) throw Error(id + o);
			if (o > 0) s.s = 1;
			else if (o < 0) (o = -o), (s.s = -1);
			else {
				(s.s = 0), (s.e = 0), (s.d = [0]);
				return;
			}
			if (o === ~~o && o < 1e7) {
				(s.e = 0), (s.d = [o]);
				return;
			}
			return BI(s, o.toString());
		} else if (typeof o != "string") throw Error(id + o);
		if (
			(o.charCodeAt(0) === 45
				? ((o = o.slice(1)), (s.s = -1))
				: (s.s = 1),
			D4e.test(o))
		)
			BI(s, o);
		else throw Error(id + o);
	}
	if (
		((i.prototype = je),
		(i.ROUND_UP = 0),
		(i.ROUND_DOWN = 1),
		(i.ROUND_CEIL = 2),
		(i.ROUND_FLOOR = 3),
		(i.ROUND_HALF_UP = 4),
		(i.ROUND_HALF_DOWN = 5),
		(i.ROUND_HALF_EVEN = 6),
		(i.ROUND_HALF_CEIL = 7),
		(i.ROUND_HALF_FLOOR = 8),
		(i.clone = qW),
		(i.config = i.set = S4e),
		t === void 0 && (t = {}),
		t)
	)
		for (
			r = ["precision", "rounding", "toExpNeg", "toExpPos", "LN10"],
				e = 0;
			e < r.length;

		)
			t.hasOwnProperty((n = r[e++])) || (t[n] = this[n]);
	return i.config(t), i;
}
function S4e(t) {
	if (!t || typeof t != "object") throw Error(Go + "Object expected");
	var e,
		n,
		r,
		i = [
			"precision",
			1,
			hp,
			"rounding",
			0,
			8,
			"toExpNeg",
			-1 / 0,
			0,
			"toExpPos",
			0,
			1 / 0,
		];
	for (e = 0; e < i.length; e += 3)
		if ((r = t[(n = i[e])]) !== void 0)
			if (pp(r) === r && r >= i[e + 1] && r <= i[e + 2]) this[n] = r;
			else throw Error(id + n + ": " + r);
	if ((r = t[(n = "LN10")]) !== void 0)
		if (r == Math.LN10) this[n] = new this(r);
		else throw Error(id + n + ": " + r);
	return this;
}
var I5 = qW(E4e);
ro = new I5(1);
const FI = I5;
var A4e = GW;
function GW(t, e, n) {
	t instanceof RegExp && (t = PI(t, n)),
		e instanceof RegExp && (e = PI(e, n));
	var r = YW(t, e, n);
	return (
		r && {
			start: r[0],
			end: r[1],
			pre: n.slice(0, r[0]),
			body: n.slice(r[0] + t.length, r[1]),
			post: n.slice(r[1] + e.length),
		}
	);
}
function PI(t, e) {
	var n = e.match(t);
	return n ? n[0] : null;
}
GW.range = YW;
function YW(t, e, n) {
	var r,
		i,
		o,
		s,
		a,
		l = n.indexOf(t),
		u = n.indexOf(e, l + 1),
		c = l;
	if (l >= 0 && u > 0) {
		if (t === e) return [l, u];
		for (r = [], o = n.length; c >= 0 && !a; )
			c == l
				? (r.push(c), (l = n.indexOf(t, c + 1)))
				: r.length == 1
					? (a = [r.pop(), u])
					: ((i = r.pop()),
						i < o && ((o = i), (s = u)),
						(u = n.indexOf(e, c + 1))),
				(c = l < u && l >= 0 ? l : u);
		r.length && (a = [o, s]);
	}
	return a;
}
var JW = A4e,
	$4e = I4e,
	XW = "\0SLASH" + Math.random() + "\0",
	ZW = "\0OPEN" + Math.random() + "\0",
	F5 = "\0CLOSE" + Math.random() + "\0",
	QW = "\0COMMA" + Math.random() + "\0",
	eq = "\0PERIOD" + Math.random() + "\0";
function eC(t) {
	return parseInt(t, 10) == t ? parseInt(t, 10) : t.charCodeAt(0);
}
function T4e(t) {
	return t
		.split("\\\\")
		.join(XW)
		.split("\\{")
		.join(ZW)
		.split("\\}")
		.join(F5)
		.split("\\,")
		.join(QW)
		.split("\\.")
		.join(eq);
}
function B4e(t) {
	return t
		.split(XW)
		.join("\\")
		.split(ZW)
		.join("{")
		.split(F5)
		.join("}")
		.split(QW)
		.join(",")
		.split(eq)
		.join(".");
}
function tq(t) {
	if (!t) return [""];
	var e = [],
		n = JW("{", "}", t);
	if (!n) return t.split(",");
	var r = n.pre,
		i = n.body,
		o = n.post,
		s = r.split(",");
	s[s.length - 1] += "{" + i + "}";
	var a = tq(o);
	return (
		o.length && ((s[s.length - 1] += a.shift()), s.push.apply(s, a)),
		e.push.apply(e, s),
		e
	);
}
function I4e(t) {
	return t
		? (t.substr(0, 2) === "{}" && (t = "\\{\\}" + t.substr(2)),
			am(T4e(t), !0).map(B4e))
		: [];
}
function F4e(t) {
	return "{" + t + "}";
}
function P4e(t) {
	return /^-?0\d/.test(t);
}
function N4e(t, e) {
	return t <= e;
}
function R4e(t, e) {
	return t >= e;
}
function am(t, e) {
	var n = [],
		r = JW("{", "}", t);
	if (!r) return [t];
	var i = r.pre,
		o = r.post.length ? am(r.post, !1) : [""];
	if (/\$$/.test(r.pre))
		for (var s = 0; s < o.length; s++) {
			var a = i + "{" + r.body + "}" + o[s];
			n.push(a);
		}
	else {
		var l = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(r.body),
			u = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(r.body),
			c = l || u,
			d = r.body.indexOf(",") >= 0;
		if (!c && !d)
			return r.post.match(/,.*\}/)
				? ((t = r.pre + "{" + r.body + F5 + r.post), am(t))
				: [t];
		var f;
		if (c) f = r.body.split(/\.\./);
		else if (
			((f = tq(r.body)),
			f.length === 1 && ((f = am(f[0], !1).map(F4e)), f.length === 1))
		)
			return o.map(function (A) {
				return r.pre + f[0] + A;
			});
		var h;
		if (c) {
			var p = eC(f[0]),
				g = eC(f[1]),
				v = Math.max(f[0].length, f[1].length),
				b = f.length == 3 ? Math.abs(eC(f[2])) : 1,
				y = N4e,
				x = g < p;
			x && ((b *= -1), (y = R4e));
			var C = f.some(P4e);
			h = [];
			for (var k = p; y(k, g); k += b) {
				var w;
				if (u) (w = String.fromCharCode(k)), w === "\\" && (w = "");
				else if (((w = String(k)), C)) {
					var D = v - w.length;
					if (D > 0) {
						var S = new Array(D + 1).join("0");
						k < 0 ? (w = "-" + S + w.slice(1)) : (w = S + w);
					}
				}
				h.push(w);
			}
		} else {
			h = [];
			for (var $ = 0; $ < f.length; $++) h.push.apply(h, am(f[$], !1));
		}
		for (var $ = 0; $ < h.length; $++)
			for (var s = 0; s < o.length; s++) {
				var a = i + h[$] + o[s];
				(!e || c || a) && n.push(a);
			}
	}
	return n;
}
const O4e = Dl($4e),
	M4e = 1024 * 64,
	xy = (t) => {
		if (typeof t != "string") throw new TypeError("invalid pattern");
		if (t.length > M4e) throw new TypeError("pattern is too long");
	},
	j4e = {
		"[:alnum:]": ["\\p{L}\\p{Nl}\\p{Nd}", !0],
		"[:alpha:]": ["\\p{L}\\p{Nl}", !0],
		"[:ascii:]": ["\\x00-\\x7f", !1],
		"[:blank:]": ["\\p{Zs}\\t", !0],
		"[:cntrl:]": ["\\p{Cc}", !0],
		"[:digit:]": ["\\p{Nd}", !0],
		"[:graph:]": ["\\p{Z}\\p{C}", !0, !0],
		"[:lower:]": ["\\p{Ll}", !0],
		"[:print:]": ["\\p{C}", !0],
		"[:punct:]": ["\\p{P}", !0],
		"[:space:]": ["\\p{Z}\\t\\r\\n\\v\\f", !0],
		"[:upper:]": ["\\p{Lu}", !0],
		"[:word:]": ["\\p{L}\\p{Nl}\\p{Nd}\\p{Pc}", !0],
		"[:xdigit:]": ["A-Fa-f0-9", !1],
	},
	Rp = (t) => t.replace(/[[\]\\-]/g, "\\$&"),
	_4e = (t) => t.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&"),
	NI = (t) => t.join(""),
	z4e = (t, e) => {
		const n = e;
		if (t.charAt(n) !== "[") throw new Error("not in a brace expression");
		const r = [],
			i = [];
		let o = n + 1,
			s = !1,
			a = !1,
			l = !1,
			u = !1,
			c = n,
			d = "";
		e: for (; o < t.length; ) {
			const g = t.charAt(o);
			if ((g === "!" || g === "^") && o === n + 1) {
				(u = !0), o++;
				continue;
			}
			if (g === "]" && s && !l) {
				c = o + 1;
				break;
			}
			if (((s = !0), g === "\\" && !l)) {
				(l = !0), o++;
				continue;
			}
			if (g === "[" && !l) {
				for (const [v, [b, y, x]] of Object.entries(j4e))
					if (t.startsWith(v, o)) {
						if (d) return ["$.", !1, t.length - n, !0];
						(o += v.length),
							x ? i.push(b) : r.push(b),
							(a = a || y);
						continue e;
					}
			}
			if (((l = !1), d)) {
				g > d ? r.push(Rp(d) + "-" + Rp(g)) : g === d && r.push(Rp(g)),
					(d = ""),
					o++;
				continue;
			}
			if (t.startsWith("-]", o + 1)) {
				r.push(Rp(g + "-")), (o += 2);
				continue;
			}
			if (t.startsWith("-", o + 1)) {
				(d = g), (o += 2);
				continue;
			}
			r.push(Rp(g)), o++;
		}
		if (c < o) return ["", !1, 0, !1];
		if (!r.length && !i.length) return ["$.", !1, t.length - n, !0];
		if (i.length === 0 && r.length === 1 && /^\\?.$/.test(r[0]) && !u) {
			const g = r[0].length === 2 ? r[0].slice(-1) : r[0];
			return [_4e(g), !1, c - n, !1];
		}
		const f = "[" + (u ? "^" : "") + NI(r) + "]",
			h = "[" + (u ? "" : "^") + NI(i) + "]";
		return [
			r.length && i.length ? "(" + f + "|" + h + ")" : r.length ? f : h,
			a,
			c - n,
			!0,
		];
	},
	lm = (t, { windowsPathsNoEscape: e = !1 } = {}) =>
		e
			? t.replace(/\[([^\/\\])\]/g, "$1")
			: t
					.replace(/((?!\\).|^)\[([^\/\\])\]/g, "$1$2")
					.replace(/\\([^\/])/g, "$1"),
	L4e = new Set(["!", "?", "+", "*", "@"]),
	RI = (t) => L4e.has(t),
	V4e = "(?!(?:^|/)\\.\\.?(?:$|/))",
	U1 = "(?!\\.)",
	K4e = new Set(["[", "."]),
	U4e = new Set(["..", "."]),
	H4e = new Set("().*{}+?[]^$\\!"),
	W4e = (t) => t.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&"),
	P5 = "[^/]",
	OI = P5 + "*?",
	MI = P5 + "+?";
var Zn, ar, Ya, cn, _n, du, Hc, fu, Ys, Wc, n0, Ld, nq, Mu, Bb, K2, rq;
const ri = class ri {
	constructor(e, n, r = {}) {
		qe(this, Ld);
		Fe(this, "type");
		qe(this, Zn);
		qe(this, ar);
		qe(this, Ya, !1);
		qe(this, cn, []);
		qe(this, _n);
		qe(this, du);
		qe(this, Hc);
		qe(this, fu, !1);
		qe(this, Ys);
		qe(this, Wc);
		qe(this, n0, !1);
		(this.type = e),
			e && Te(this, ar, !0),
			Te(this, _n, n),
			Te(this, Zn, z(this, _n) ? z(z(this, _n), Zn) : this),
			Te(this, Ys, z(this, Zn) === this ? r : z(z(this, Zn), Ys)),
			Te(this, Hc, z(this, Zn) === this ? [] : z(z(this, Zn), Hc)),
			e === "!" && !z(z(this, Zn), fu) && z(this, Hc).push(this),
			Te(this, du, z(this, _n) ? z(z(this, _n), cn).length : 0);
	}
	get hasMagic() {
		if (z(this, ar) !== void 0) return z(this, ar);
		for (const e of z(this, cn))
			if (typeof e != "string" && (e.type || e.hasMagic))
				return Te(this, ar, !0);
		return z(this, ar);
	}
	toString() {
		return z(this, Wc) !== void 0
			? z(this, Wc)
			: this.type
				? Te(
						this,
						Wc,
						this.type +
							"(" +
							z(this, cn)
								.map((e) => String(e))
								.join("|") +
							")",
					)
				: Te(
						this,
						Wc,
						z(this, cn)
							.map((e) => String(e))
							.join(""),
					);
	}
	push(...e) {
		for (const n of e)
			if (n !== "") {
				if (
					typeof n != "string" &&
					!(n instanceof ri && z(n, _n) === this)
				)
					throw new Error("invalid part: " + n);
				z(this, cn).push(n);
			}
	}
	toJSON() {
		var n;
		const e =
			this.type === null
				? z(this, cn)
						.slice()
						.map((r) => (typeof r == "string" ? r : r.toJSON()))
				: [this.type, ...z(this, cn).map((r) => r.toJSON())];
		return (
			this.isStart() && !this.type && e.unshift([]),
			this.isEnd() &&
				(this === z(this, Zn) ||
					(z(z(this, Zn), fu) &&
						((n = z(this, _n)) == null ? void 0 : n.type) ===
							"!")) &&
				e.push({}),
			e
		);
	}
	isStart() {
		var n;
		if (z(this, Zn) === this) return !0;
		if (!((n = z(this, _n)) != null && n.isStart())) return !1;
		if (z(this, du) === 0) return !0;
		const e = z(this, _n);
		for (let r = 0; r < z(this, du); r++) {
			const i = z(e, cn)[r];
			if (!(i instanceof ri && i.type === "!")) return !1;
		}
		return !0;
	}
	isEnd() {
		var n, r, i;
		if (
			z(this, Zn) === this ||
			((n = z(this, _n)) == null ? void 0 : n.type) === "!"
		)
			return !0;
		if (!((r = z(this, _n)) != null && r.isEnd())) return !1;
		if (!this.type) return (i = z(this, _n)) == null ? void 0 : i.isEnd();
		const e = z(this, _n) ? z(z(this, _n), cn).length : 0;
		return z(this, du) === e - 1;
	}
	copyIn(e) {
		typeof e == "string" ? this.push(e) : this.push(e.clone(this));
	}
	clone(e) {
		const n = new ri(this.type, e);
		for (const r of z(this, cn)) n.copyIn(r);
		return n;
	}
	static fromGlob(e, n = {}) {
		var i;
		const r = new ri(null, void 0, n);
		return Ne((i = ri), Mu, Bb).call(i, e, r, 0, n), r;
	}
	toMMPattern() {
		if (this !== z(this, Zn)) return z(this, Zn).toMMPattern();
		const e = this.toString(),
			[n, r, i, o] = this.toRegExpSource();
		if (
			!(
				i ||
				z(this, ar) ||
				(z(this, Ys).nocase &&
					!z(this, Ys).nocaseMagicOnly &&
					e.toUpperCase() !== e.toLowerCase())
			)
		)
			return r;
		const a = (z(this, Ys).nocase ? "i" : "") + (o ? "u" : "");
		return Object.assign(new RegExp(`^${n}$`, a), { _src: n, _glob: e });
	}
	get options() {
		return z(this, Ys);
	}
	toRegExpSource(e) {
		var l;
		const n = e ?? !!z(this, Ys).dot;
		if ((z(this, Zn) === this && Ne(this, Ld, nq).call(this), !this.type)) {
			const u = this.isStart() && this.isEnd(),
				c = z(this, cn)
					.map((p) => {
						var x;
						const [g, v, b, y] =
							typeof p == "string"
								? Ne((x = ri), Mu, rq).call(
										x,
										p,
										z(this, ar),
										u,
									)
								: p.toRegExpSource(e);
						return (
							Te(this, ar, z(this, ar) || b),
							Te(this, Ya, z(this, Ya) || y),
							g
						);
					})
					.join("");
			let d = "";
			if (
				this.isStart() &&
				typeof z(this, cn)[0] == "string" &&
				!(z(this, cn).length === 1 && U4e.has(z(this, cn)[0]))
			) {
				const g = K4e,
					v =
						(n && g.has(c.charAt(0))) ||
						(c.startsWith("\\.") && g.has(c.charAt(2))) ||
						(c.startsWith("\\.\\.") && g.has(c.charAt(4))),
					b = !n && !e && g.has(c.charAt(0));
				d = v ? V4e : b ? U1 : "";
			}
			let f = "";
			return (
				this.isEnd() &&
					z(z(this, Zn), fu) &&
					((l = z(this, _n)) == null ? void 0 : l.type) === "!" &&
					(f = "(?:$|\\/)"),
				[d + c + f, lm(c), Te(this, ar, !!z(this, ar)), z(this, Ya)]
			);
		}
		const r = this.type === "*" || this.type === "+",
			i = this.type === "!" ? "(?:(?!(?:" : "(?:";
		let o = Ne(this, Ld, K2).call(this, n);
		if (this.isStart() && this.isEnd() && !o && this.type !== "!") {
			const u = this.toString();
			return (
				Te(this, cn, [u]),
				(this.type = null),
				Te(this, ar, void 0),
				[u, lm(this.toString()), !1, !1]
			);
		}
		let s = !r || e || n || !U1 ? "" : Ne(this, Ld, K2).call(this, !0);
		s === o && (s = ""), s && (o = `(?:${o})(?:${s})*?`);
		let a = "";
		if (this.type === "!" && z(this, n0))
			a = (this.isStart() && !n ? U1 : "") + MI;
		else {
			const u =
				this.type === "!"
					? "))" + (this.isStart() && !n && !e ? U1 : "") + OI + ")"
					: this.type === "@"
						? ")"
						: this.type === "?"
							? ")?"
							: this.type === "+" && s
								? ")"
								: this.type === "*" && s
									? ")?"
									: `)${this.type}`;
			a = i + o + u;
		}
		return [a, lm(o), Te(this, ar, !!z(this, ar)), z(this, Ya)];
	}
};
(Zn = new WeakMap()),
	(ar = new WeakMap()),
	(Ya = new WeakMap()),
	(cn = new WeakMap()),
	(_n = new WeakMap()),
	(du = new WeakMap()),
	(Hc = new WeakMap()),
	(fu = new WeakMap()),
	(Ys = new WeakMap()),
	(Wc = new WeakMap()),
	(n0 = new WeakMap()),
	(Ld = new WeakSet()),
	(nq = function () {
		if (this !== z(this, Zn)) throw new Error("should only call on root");
		if (z(this, fu)) return this;
		this.toString(), Te(this, fu, !0);
		let e;
		for (; (e = z(this, Hc).pop()); ) {
			if (e.type !== "!") continue;
			let n = e,
				r = z(n, _n);
			for (; r; ) {
				for (let i = z(n, du) + 1; !r.type && i < z(r, cn).length; i++)
					for (const o of z(e, cn)) {
						if (typeof o == "string")
							throw new Error("string part in extglob AST??");
						o.copyIn(z(r, cn)[i]);
					}
				(n = r), (r = z(n, _n));
			}
		}
		return this;
	}),
	(Mu = new WeakSet()),
	(Bb = function (e, n, r, i) {
		var h, p;
		let o = !1,
			s = !1,
			a = -1,
			l = !1;
		if (n.type === null) {
			let g = r,
				v = "";
			for (; g < e.length; ) {
				const b = e.charAt(g++);
				if (o || b === "\\") {
					(o = !o), (v += b);
					continue;
				}
				if (s) {
					g === a + 1
						? (b === "^" || b === "!") && (l = !0)
						: b === "]" && !(g === a + 2 && l) && (s = !1),
						(v += b);
					continue;
				} else if (b === "[") {
					(s = !0), (a = g), (l = !1), (v += b);
					continue;
				}
				if (!i.noext && RI(b) && e.charAt(g) === "(") {
					n.push(v), (v = "");
					const y = new ri(b, n);
					(g = Ne((h = ri), Mu, Bb).call(h, e, y, g, i)), n.push(y);
					continue;
				}
				v += b;
			}
			return n.push(v), g;
		}
		let u = r + 1,
			c = new ri(null, n);
		const d = [];
		let f = "";
		for (; u < e.length; ) {
			const g = e.charAt(u++);
			if (o || g === "\\") {
				(o = !o), (f += g);
				continue;
			}
			if (s) {
				u === a + 1
					? (g === "^" || g === "!") && (l = !0)
					: g === "]" && !(u === a + 2 && l) && (s = !1),
					(f += g);
				continue;
			} else if (g === "[") {
				(s = !0), (a = u), (l = !1), (f += g);
				continue;
			}
			if (RI(g) && e.charAt(u) === "(") {
				c.push(f), (f = "");
				const v = new ri(g, c);
				c.push(v), (u = Ne((p = ri), Mu, Bb).call(p, e, v, u, i));
				continue;
			}
			if (g === "|") {
				c.push(f), (f = ""), d.push(c), (c = new ri(null, n));
				continue;
			}
			if (g === ")")
				return (
					f === "" && z(n, cn).length === 0 && Te(n, n0, !0),
					c.push(f),
					(f = ""),
					n.push(...d, c),
					u
				);
			f += g;
		}
		return (
			(n.type = null),
			Te(n, ar, void 0),
			Te(n, cn, [e.substring(r - 1)]),
			u
		);
	}),
	(K2 = function (e) {
		return z(this, cn)
			.map((n) => {
				if (typeof n == "string")
					throw new Error("string type in extglob ast??");
				const [r, i, o, s] = n.toRegExpSource(e);
				return Te(this, Ya, z(this, Ya) || s), r;
			})
			.filter((n) => !(this.isStart() && this.isEnd()) || !!n)
			.join("|");
	}),
	(rq = function (e, n, r = !1) {
		let i = !1,
			o = "",
			s = !1;
		for (let a = 0; a < e.length; a++) {
			const l = e.charAt(a);
			if (i) {
				(i = !1), (o += (H4e.has(l) ? "\\" : "") + l);
				continue;
			}
			if (l === "\\") {
				a === e.length - 1 ? (o += "\\\\") : (i = !0);
				continue;
			}
			if (l === "[") {
				const [u, c, d, f] = z4e(e, a);
				if (d) {
					(o += u), (s = s || c), (a += d - 1), (n = n || f);
					continue;
				}
			}
			if (l === "*") {
				r && e === "*" ? (o += MI) : (o += OI), (n = !0);
				continue;
			}
			if (l === "?") {
				(o += P5), (n = !0);
				continue;
			}
			o += W4e(l);
		}
		return [o, lm(e), !!n, s];
	}),
	qe(ri, Mu);
let ky = ri;
const q4e = (t, { windowsPathsNoEscape: e = !1 } = {}) =>
	e ? t.replace(/[?*()[\]]/g, "[$&]") : t.replace(/[?*()[\]\\]/g, "\\$&");
var tC = {};
const mi = (t, e, n = {}) => (
		xy(e), !n.nocomment && e.charAt(0) === "#" ? !1 : new T3(e, n).match(t)
	),
	G4e = /^\*+([^+@!?\*\[\(]*)$/,
	Y4e = (t) => (e) => !e.startsWith(".") && e.endsWith(t),
	J4e = (t) => (e) => e.endsWith(t),
	X4e = (t) => (
		(t = t.toLowerCase()),
		(e) => !e.startsWith(".") && e.toLowerCase().endsWith(t)
	),
	Z4e = (t) => ((t = t.toLowerCase()), (e) => e.toLowerCase().endsWith(t)),
	Q4e = /^\*+\.\*+$/,
	eke = (t) => !t.startsWith(".") && t.includes("."),
	tke = (t) => t !== "." && t !== ".." && t.includes("."),
	nke = /^\.\*+$/,
	rke = (t) => t !== "." && t !== ".." && t.startsWith("."),
	ike = /^\*+$/,
	oke = (t) => t.length !== 0 && !t.startsWith("."),
	ske = (t) => t.length !== 0 && t !== "." && t !== "..",
	ake = /^\?+([^+@!?\*\[\(]*)?$/,
	lke = ([t, e = ""]) => {
		const n = iq([t]);
		return e
			? ((e = e.toLowerCase()),
				(r) => n(r) && r.toLowerCase().endsWith(e))
			: n;
	},
	uke = ([t, e = ""]) => {
		const n = oq([t]);
		return e
			? ((e = e.toLowerCase()),
				(r) => n(r) && r.toLowerCase().endsWith(e))
			: n;
	},
	cke = ([t, e = ""]) => {
		const n = oq([t]);
		return e ? (r) => n(r) && r.endsWith(e) : n;
	},
	dke = ([t, e = ""]) => {
		const n = iq([t]);
		return e ? (r) => n(r) && r.endsWith(e) : n;
	},
	iq = ([t]) => {
		const e = t.length;
		return (n) => n.length === e && !n.startsWith(".");
	},
	oq = ([t]) => {
		const e = t.length;
		return (n) => n.length === e && n !== "." && n !== "..";
	},
	sq =
		typeof process == "object" && process
			? (typeof tC == "object" &&
					tC &&
					tC.__MINIMATCH_TESTING_PLATFORM__) ||
				process.platform
			: "posix",
	jI = { win32: { sep: "\\" }, posix: { sep: "/" } },
	fke = sq === "win32" ? jI.win32.sep : jI.posix.sep;
mi.sep = fke;
const Do = Symbol("globstar **");
mi.GLOBSTAR = Do;
const hke = "[^/]",
	pke = hke + "*?",
	mke = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?",
	gke = "(?:(?!(?:\\/|^)\\.).)*?",
	aq =
		(t, e = {}) =>
		(n) =>
			mi(n, t, e);
mi.filter = aq;
const Co = (t, e = {}) => Object.assign({}, t, e),
	bke = (t) => {
		if (!t || typeof t != "object" || !Object.keys(t).length) return mi;
		const e = mi;
		return Object.assign((r, i, o = {}) => e(r, i, Co(t, o)), {
			Minimatch: class extends e.Minimatch {
				constructor(i, o = {}) {
					super(i, Co(t, o));
				}
				static defaults(i) {
					return e.defaults(Co(t, i)).Minimatch;
				}
			},
			AST: class extends e.AST {
				constructor(i, o, s = {}) {
					super(i, o, Co(t, s));
				}
				static fromGlob(i, o = {}) {
					return e.AST.fromGlob(i, Co(t, o));
				}
			},
			unescape: (r, i = {}) => e.unescape(r, Co(t, i)),
			escape: (r, i = {}) => e.escape(r, Co(t, i)),
			filter: (r, i = {}) => e.filter(r, Co(t, i)),
			defaults: (r) => e.defaults(Co(t, r)),
			makeRe: (r, i = {}) => e.makeRe(r, Co(t, i)),
			braceExpand: (r, i = {}) => e.braceExpand(r, Co(t, i)),
			match: (r, i, o = {}) => e.match(r, i, Co(t, o)),
			sep: e.sep,
			GLOBSTAR: Do,
		});
	};
mi.defaults = bke;
const lq = (t, e = {}) => (
	xy(t), e.nobrace || !/\{(?:(?!\{).)*\}/.test(t) ? [t] : O4e(t)
);
mi.braceExpand = lq;
const vke = (t, e = {}) => new T3(t, e).makeRe();
mi.makeRe = vke;
const yke = (t, e, n = {}) => {
	const r = new T3(e, n);
	return (
		(t = t.filter((i) => r.match(i))),
		r.options.nonull && !t.length && t.push(e),
		t
	);
};
mi.match = yke;
const _I = /[?*]|[+@!]\(.*?\)|\[|\]/,
	xke = (t) => t.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
class T3 {
	constructor(e, n = {}) {
		Fe(this, "options");
		Fe(this, "set");
		Fe(this, "pattern");
		Fe(this, "windowsPathsNoEscape");
		Fe(this, "nonegate");
		Fe(this, "negate");
		Fe(this, "comment");
		Fe(this, "empty");
		Fe(this, "preserveMultipleSlashes");
		Fe(this, "partial");
		Fe(this, "globSet");
		Fe(this, "globParts");
		Fe(this, "nocase");
		Fe(this, "isWindows");
		Fe(this, "platform");
		Fe(this, "windowsNoMagicRoot");
		Fe(this, "regexp");
		xy(e),
			(n = n || {}),
			(this.options = n),
			(this.pattern = e),
			(this.platform = n.platform || sq),
			(this.isWindows = this.platform === "win32"),
			(this.windowsPathsNoEscape =
				!!n.windowsPathsNoEscape || n.allowWindowsEscape === !1),
			this.windowsPathsNoEscape &&
				(this.pattern = this.pattern.replace(/\\/g, "/")),
			(this.preserveMultipleSlashes = !!n.preserveMultipleSlashes),
			(this.regexp = null),
			(this.negate = !1),
			(this.nonegate = !!n.nonegate),
			(this.comment = !1),
			(this.empty = !1),
			(this.partial = !!n.partial),
			(this.nocase = !!this.options.nocase),
			(this.windowsNoMagicRoot =
				n.windowsNoMagicRoot !== void 0
					? n.windowsNoMagicRoot
					: !!(this.isWindows && this.nocase)),
			(this.globSet = []),
			(this.globParts = []),
			(this.set = []),
			this.make();
	}
	hasMagic() {
		if (this.options.magicalBraces && this.set.length > 1) return !0;
		for (const e of this.set)
			for (const n of e) if (typeof n != "string") return !0;
		return !1;
	}
	debug(...e) {}
	make() {
		const e = this.pattern,
			n = this.options;
		if (!n.nocomment && e.charAt(0) === "#") {
			this.comment = !0;
			return;
		}
		if (!e) {
			this.empty = !0;
			return;
		}
		this.parseNegate(),
			(this.globSet = [...new Set(this.braceExpand())]),
			n.debug && (this.debug = (...o) => console.error(...o)),
			this.debug(this.pattern, this.globSet);
		const r = this.globSet.map((o) => this.slashSplit(o));
		(this.globParts = this.preprocess(r)),
			this.debug(this.pattern, this.globParts);
		let i = this.globParts.map((o, s, a) => {
			if (this.isWindows && this.windowsNoMagicRoot) {
				const l =
						o[0] === "" &&
						o[1] === "" &&
						(o[2] === "?" || !_I.test(o[2])) &&
						!_I.test(o[3]),
					u = /^[a-z]:/i.test(o[0]);
				if (l)
					return [
						...o.slice(0, 4),
						...o.slice(4).map((c) => this.parse(c)),
					];
				if (u) return [o[0], ...o.slice(1).map((c) => this.parse(c))];
			}
			return o.map((l) => this.parse(l));
		});
		if (
			(this.debug(this.pattern, i),
			(this.set = i.filter((o) => o.indexOf(!1) === -1)),
			this.isWindows)
		)
			for (let o = 0; o < this.set.length; o++) {
				const s = this.set[o];
				s[0] === "" &&
					s[1] === "" &&
					this.globParts[o][2] === "?" &&
					typeof s[3] == "string" &&
					/^[a-z]:$/i.test(s[3]) &&
					(s[2] = "?");
			}
		this.debug(this.pattern, this.set);
	}
	preprocess(e) {
		if (this.options.noglobstar)
			for (let r = 0; r < e.length; r++)
				for (let i = 0; i < e[r].length; i++)
					e[r][i] === "**" && (e[r][i] = "*");
		const { optimizationLevel: n = 1 } = this.options;
		return (
			n >= 2
				? ((e = this.firstPhasePreProcess(e)),
					(e = this.secondPhasePreProcess(e)))
				: n >= 1
					? (e = this.levelOneOptimize(e))
					: (e = this.adjascentGlobstarOptimize(e)),
			e
		);
	}
	adjascentGlobstarOptimize(e) {
		return e.map((n) => {
			let r = -1;
			for (; (r = n.indexOf("**", r + 1)) !== -1; ) {
				let i = r;
				for (; n[i + 1] === "**"; ) i++;
				i !== r && n.splice(r, i - r);
			}
			return n;
		});
	}
	levelOneOptimize(e) {
		return e.map(
			(n) => (
				(n = n.reduce((r, i) => {
					const o = r[r.length - 1];
					return i === "**" && o === "**"
						? r
						: i === ".." &&
							  o &&
							  o !== ".." &&
							  o !== "." &&
							  o !== "**"
							? (r.pop(), r)
							: (r.push(i), r);
				}, [])),
				n.length === 0 ? [""] : n
			),
		);
	}
	levelTwoFileOptimize(e) {
		Array.isArray(e) || (e = this.slashSplit(e));
		let n = !1;
		do {
			if (((n = !1), !this.preserveMultipleSlashes)) {
				for (let i = 1; i < e.length - 1; i++) {
					const o = e[i];
					(i === 1 && o === "" && e[0] === "") ||
						((o === "." || o === "") &&
							((n = !0), e.splice(i, 1), i--));
				}
				e[0] === "." &&
					e.length === 2 &&
					(e[1] === "." || e[1] === "") &&
					((n = !0), e.pop());
			}
			let r = 0;
			for (; (r = e.indexOf("..", r + 1)) !== -1; ) {
				const i = e[r - 1];
				i &&
					i !== "." &&
					i !== ".." &&
					i !== "**" &&
					((n = !0), e.splice(r - 1, 2), (r -= 2));
			}
		} while (n);
		return e.length === 0 ? [""] : e;
	}
	firstPhasePreProcess(e) {
		let n = !1;
		do {
			n = !1;
			for (let r of e) {
				let i = -1;
				for (; (i = r.indexOf("**", i + 1)) !== -1; ) {
					let s = i;
					for (; r[s + 1] === "**"; ) s++;
					s > i && r.splice(i + 1, s - i);
					let a = r[i + 1];
					const l = r[i + 2],
						u = r[i + 3];
					if (
						a !== ".." ||
						!l ||
						l === "." ||
						l === ".." ||
						!u ||
						u === "." ||
						u === ".."
					)
						continue;
					(n = !0), r.splice(i, 1);
					const c = r.slice(0);
					(c[i] = "**"), e.push(c), i--;
				}
				if (!this.preserveMultipleSlashes) {
					for (let s = 1; s < r.length - 1; s++) {
						const a = r[s];
						(s === 1 && a === "" && r[0] === "") ||
							((a === "." || a === "") &&
								((n = !0), r.splice(s, 1), s--));
					}
					r[0] === "." &&
						r.length === 2 &&
						(r[1] === "." || r[1] === "") &&
						((n = !0), r.pop());
				}
				let o = 0;
				for (; (o = r.indexOf("..", o + 1)) !== -1; ) {
					const s = r[o - 1];
					if (s && s !== "." && s !== ".." && s !== "**") {
						n = !0;
						const l = o === 1 && r[o + 1] === "**" ? ["."] : [];
						r.splice(o - 1, 2, ...l),
							r.length === 0 && r.push(""),
							(o -= 2);
					}
				}
			}
		} while (n);
		return e;
	}
	secondPhasePreProcess(e) {
		for (let n = 0; n < e.length - 1; n++)
			for (let r = n + 1; r < e.length; r++) {
				const i = this.partsMatch(
					e[n],
					e[r],
					!this.preserveMultipleSlashes,
				);
				if (i) {
					(e[n] = []), (e[r] = i);
					break;
				}
			}
		return e.filter((n) => n.length);
	}
	partsMatch(e, n, r = !1) {
		let i = 0,
			o = 0,
			s = [],
			a = "";
		for (; i < e.length && o < n.length; )
			if (e[i] === n[o]) s.push(a === "b" ? n[o] : e[i]), i++, o++;
			else if (r && e[i] === "**" && n[o] === e[i + 1]) s.push(e[i]), i++;
			else if (r && n[o] === "**" && e[i] === n[o + 1]) s.push(n[o]), o++;
			else if (
				e[i] === "*" &&
				n[o] &&
				(this.options.dot || !n[o].startsWith(".")) &&
				n[o] !== "**"
			) {
				if (a === "b") return !1;
				(a = "a"), s.push(e[i]), i++, o++;
			} else if (
				n[o] === "*" &&
				e[i] &&
				(this.options.dot || !e[i].startsWith(".")) &&
				e[i] !== "**"
			) {
				if (a === "a") return !1;
				(a = "b"), s.push(n[o]), i++, o++;
			} else return !1;
		return e.length === n.length && s;
	}
	parseNegate() {
		if (this.nonegate) return;
		const e = this.pattern;
		let n = !1,
			r = 0;
		for (let i = 0; i < e.length && e.charAt(i) === "!"; i++) (n = !n), r++;
		r && (this.pattern = e.slice(r)), (this.negate = n);
	}
	matchOne(e, n, r = !1) {
		const i = this.options;
		if (this.isWindows) {
			const g = typeof e[0] == "string" && /^[a-z]:$/i.test(e[0]),
				v =
					!g &&
					e[0] === "" &&
					e[1] === "" &&
					e[2] === "?" &&
					/^[a-z]:$/i.test(e[3]),
				b = typeof n[0] == "string" && /^[a-z]:$/i.test(n[0]),
				y =
					!b &&
					n[0] === "" &&
					n[1] === "" &&
					n[2] === "?" &&
					typeof n[3] == "string" &&
					/^[a-z]:$/i.test(n[3]),
				x = v ? 3 : g ? 0 : void 0,
				C = y ? 3 : b ? 0 : void 0;
			if (typeof x == "number" && typeof C == "number") {
				const [k, w] = [e[x], n[C]];
				k.toLowerCase() === w.toLowerCase() &&
					((n[C] = k),
					C > x ? (n = n.slice(C)) : x > C && (e = e.slice(x)));
			}
		}
		const { optimizationLevel: o = 1 } = this.options;
		o >= 2 && (e = this.levelTwoFileOptimize(e)),
			this.debug("matchOne", this, { file: e, pattern: n }),
			this.debug("matchOne", e.length, n.length);
		for (
			var s = 0, a = 0, l = e.length, u = n.length;
			s < l && a < u;
			s++, a++
		) {
			this.debug("matchOne loop");
			var c = n[a],
				d = e[s];
			if ((this.debug(n, c, d), c === !1)) return !1;
			if (c === Do) {
				this.debug("GLOBSTAR", [n, c, d]);
				var f = s,
					h = a + 1;
				if (h === u) {
					for (this.debug("** at the end"); s < l; s++)
						if (
							e[s] === "." ||
							e[s] === ".." ||
							(!i.dot && e[s].charAt(0) === ".")
						)
							return !1;
					return !0;
				}
				for (; f < l; ) {
					var p = e[f];
					if (
						(this.debug(
							`
globstar while`,
							e,
							f,
							n,
							h,
							p,
						),
						this.matchOne(e.slice(f), n.slice(h), r))
					)
						return this.debug("globstar found match!", f, l, p), !0;
					if (
						p === "." ||
						p === ".." ||
						(!i.dot && p.charAt(0) === ".")
					) {
						this.debug("dot detected!", e, f, n, h);
						break;
					}
					this.debug("globstar swallow a segment, and continue"), f++;
				}
				return !!(
					r &&
					(this.debug(
						`
>>> no match, partial?`,
						e,
						f,
						n,
						h,
					),
					f === l)
				);
			}
			let g;
			if (
				(typeof c == "string"
					? ((g = d === c), this.debug("string match", c, d, g))
					: ((g = c.test(d)), this.debug("pattern match", c, d, g)),
				!g)
			)
				return !1;
		}
		if (s === l && a === u) return !0;
		if (s === l) return r;
		if (a === u) return s === l - 1 && e[s] === "";
		throw new Error("wtf?");
	}
	braceExpand() {
		return lq(this.pattern, this.options);
	}
	parse(e) {
		xy(e);
		const n = this.options;
		if (e === "**") return Do;
		if (e === "") return "";
		let r,
			i = null;
		(r = e.match(ike))
			? (i = n.dot ? ske : oke)
			: (r = e.match(G4e))
				? (i = (n.nocase ? (n.dot ? Z4e : X4e) : n.dot ? J4e : Y4e)(
						r[1],
					))
				: (r = e.match(ake))
					? (i = (n.nocase ? (n.dot ? uke : lke) : n.dot ? cke : dke)(
							r,
						))
					: (r = e.match(Q4e))
						? (i = n.dot ? tke : eke)
						: (r = e.match(nke)) && (i = rke);
		const o = ky.fromGlob(e, this.options).toMMPattern();
		return (
			i &&
				typeof o == "object" &&
				Reflect.defineProperty(o, "test", { value: i }),
			o
		);
	}
	makeRe() {
		if (this.regexp || this.regexp === !1) return this.regexp;
		const e = this.set;
		if (!e.length) return (this.regexp = !1), this.regexp;
		const n = this.options,
			r = n.noglobstar ? pke : n.dot ? mke : gke,
			i = new Set(n.nocase ? ["i"] : []);
		let o = e
			.map((l) => {
				const u = l.map((c) => {
					if (c instanceof RegExp)
						for (const d of c.flags.split("")) i.add(d);
					return typeof c == "string"
						? xke(c)
						: c === Do
							? Do
							: c._src;
				});
				return (
					u.forEach((c, d) => {
						const f = u[d + 1],
							h = u[d - 1];
						c !== Do ||
							h === Do ||
							(h === void 0
								? f !== void 0 && f !== Do
									? (u[d + 1] = "(?:\\/|" + r + "\\/)?" + f)
									: (u[d] = r)
								: f === void 0
									? (u[d - 1] = h + "(?:\\/|" + r + ")?")
									: f !== Do &&
										((u[d - 1] =
											h + "(?:\\/|\\/" + r + "\\/)" + f),
										(u[d + 1] = Do)));
					}),
					u.filter((c) => c !== Do).join("/")
				);
			})
			.join("|");
		const [s, a] = e.length > 1 ? ["(?:", ")"] : ["", ""];
		(o = "^" + s + o + a + "$"), this.negate && (o = "^(?!" + o + ").+$");
		try {
			this.regexp = new RegExp(o, [...i].join(""));
		} catch {
			this.regexp = !1;
		}
		return this.regexp;
	}
	slashSplit(e) {
		return this.preserveMultipleSlashes
			? e.split("/")
			: this.isWindows && /^\/\/[^\/]+/.test(e)
				? ["", ...e.split(/\/+/)]
				: e.split(/\/+/);
	}
	match(e, n = this.partial) {
		if ((this.debug("match", e, this.pattern), this.comment)) return !1;
		if (this.empty) return e === "";
		if (e === "/" && n) return !0;
		const r = this.options;
		this.isWindows && (e = e.split("\\").join("/"));
		const i = this.slashSplit(e);
		this.debug(this.pattern, "split", i);
		const o = this.set;
		this.debug(this.pattern, "set", o);
		let s = i[i.length - 1];
		if (!s) for (let a = i.length - 2; !s && a >= 0; a--) s = i[a];
		for (let a = 0; a < o.length; a++) {
			const l = o[a];
			let u = i;
			if (
				(r.matchBase && l.length === 1 && (u = [s]),
				this.matchOne(u, l, n))
			)
				return r.flipNegate ? !0 : !this.negate;
		}
		return r.flipNegate ? !1 : this.negate;
	}
	static defaults(e) {
		return mi.defaults(e).Minimatch;
	}
}
mi.AST = ky;
mi.Minimatch = T3;
mi.escape = q4e;
mi.unescape = lm;
const kke = m.jsxs(m.Fragment, {
	children: [
		m.jsx("path", {
			d: "M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8",
		}),
		m.jsx("path", {
			d: "M21 3v5h-5M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16",
		}),
		m.jsx("path", { d: "M8 16H3v5" }),
	],
});
var N5 = { exports: {} },
	uq = (t) => {
		if (typeof t != "string") throw new TypeError("Expected a string");
		return t.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
	};
const um = Dl(uq);
var Cke = 1 / 0,
	wke = "[object Symbol]",
	Eke = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g,
	Dke = "\\u0300-\\u036f\\ufe20-\\ufe23",
	Ske = "\\u20d0-\\u20f0",
	Ake = "[" + Dke + Ske + "]",
	$ke = RegExp(Ake, "g"),
	Tke = {
		À: "A",
		Á: "A",
		Â: "A",
		Ã: "A",
		Ä: "A",
		Å: "A",
		à: "a",
		á: "a",
		â: "a",
		ã: "a",
		ä: "a",
		å: "a",
		Ç: "C",
		ç: "c",
		Ð: "D",
		ð: "d",
		È: "E",
		É: "E",
		Ê: "E",
		Ë: "E",
		è: "e",
		é: "e",
		ê: "e",
		ë: "e",
		Ì: "I",
		Í: "I",
		Î: "I",
		Ï: "I",
		ì: "i",
		í: "i",
		î: "i",
		ï: "i",
		Ñ: "N",
		ñ: "n",
		Ò: "O",
		Ó: "O",
		Ô: "O",
		Õ: "O",
		Ö: "O",
		Ø: "O",
		ò: "o",
		ó: "o",
		ô: "o",
		õ: "o",
		ö: "o",
		ø: "o",
		Ù: "U",
		Ú: "U",
		Û: "U",
		Ü: "U",
		ù: "u",
		ú: "u",
		û: "u",
		ü: "u",
		Ý: "Y",
		ý: "y",
		ÿ: "y",
		Æ: "Ae",
		æ: "ae",
		Þ: "Th",
		þ: "th",
		ß: "ss",
		Ā: "A",
		Ă: "A",
		Ą: "A",
		ā: "a",
		ă: "a",
		ą: "a",
		Ć: "C",
		Ĉ: "C",
		Ċ: "C",
		Č: "C",
		ć: "c",
		ĉ: "c",
		ċ: "c",
		č: "c",
		Ď: "D",
		Đ: "D",
		ď: "d",
		đ: "d",
		Ē: "E",
		Ĕ: "E",
		Ė: "E",
		Ę: "E",
		Ě: "E",
		ē: "e",
		ĕ: "e",
		ė: "e",
		ę: "e",
		ě: "e",
		Ĝ: "G",
		Ğ: "G",
		Ġ: "G",
		Ģ: "G",
		ĝ: "g",
		ğ: "g",
		ġ: "g",
		ģ: "g",
		Ĥ: "H",
		Ħ: "H",
		ĥ: "h",
		ħ: "h",
		Ĩ: "I",
		Ī: "I",
		Ĭ: "I",
		Į: "I",
		İ: "I",
		ĩ: "i",
		ī: "i",
		ĭ: "i",
		į: "i",
		ı: "i",
		Ĵ: "J",
		ĵ: "j",
		Ķ: "K",
		ķ: "k",
		ĸ: "k",
		Ĺ: "L",
		Ļ: "L",
		Ľ: "L",
		Ŀ: "L",
		Ł: "L",
		ĺ: "l",
		ļ: "l",
		ľ: "l",
		ŀ: "l",
		ł: "l",
		Ń: "N",
		Ņ: "N",
		Ň: "N",
		Ŋ: "N",
		ń: "n",
		ņ: "n",
		ň: "n",
		ŋ: "n",
		Ō: "O",
		Ŏ: "O",
		Ő: "O",
		ō: "o",
		ŏ: "o",
		ő: "o",
		Ŕ: "R",
		Ŗ: "R",
		Ř: "R",
		ŕ: "r",
		ŗ: "r",
		ř: "r",
		Ś: "S",
		Ŝ: "S",
		Ş: "S",
		Š: "S",
		ś: "s",
		ŝ: "s",
		ş: "s",
		š: "s",
		Ţ: "T",
		Ť: "T",
		Ŧ: "T",
		ţ: "t",
		ť: "t",
		ŧ: "t",
		Ũ: "U",
		Ū: "U",
		Ŭ: "U",
		Ů: "U",
		Ű: "U",
		Ų: "U",
		ũ: "u",
		ū: "u",
		ŭ: "u",
		ů: "u",
		ű: "u",
		ų: "u",
		Ŵ: "W",
		ŵ: "w",
		Ŷ: "Y",
		ŷ: "y",
		Ÿ: "Y",
		Ź: "Z",
		Ż: "Z",
		Ž: "Z",
		ź: "z",
		ż: "z",
		ž: "z",
		Ĳ: "IJ",
		ĳ: "ij",
		Œ: "Oe",
		œ: "oe",
		ŉ: "'n",
		ſ: "ss",
	},
	Bke = typeof hu == "object" && hu && hu.Object === Object && hu,
	Ike = typeof self == "object" && self && self.Object === Object && self,
	Fke = Bke || Ike || Function("return this")();
function Pke(t) {
	return function (e) {
		return t == null ? void 0 : t[e];
	};
}
var Nke = Pke(Tke),
	Rke = Object.prototype,
	Oke = Rke.toString,
	zI = Fke.Symbol,
	LI = zI ? zI.prototype : void 0,
	VI = LI ? LI.toString : void 0;
function Mke(t) {
	if (typeof t == "string") return t;
	if (_ke(t)) return VI ? VI.call(t) : "";
	var e = t + "";
	return e == "0" && 1 / t == -Cke ? "-0" : e;
}
function jke(t) {
	return !!t && typeof t == "object";
}
function _ke(t) {
	return typeof t == "symbol" || (jke(t) && Oke.call(t) == wke);
}
function zke(t) {
	return t == null ? "" : Mke(t);
}
function Lke(t) {
	return (t = zke(t)), t && t.replace(Eke, Nke).replace($ke, "");
}
var Vke = Lke;
const Kke = /[|\\{}()[\]^$+*?.-]/g;
var Uke = (t) => {
		if (typeof t != "string") throw new TypeError("Expected a string");
		return t.replace(Kke, "\\$&");
	},
	Hke = [
		["ß", "ss"],
		["ä", "ae"],
		["Ä", "Ae"],
		["ö", "oe"],
		["Ö", "Oe"],
		["ü", "ue"],
		["Ü", "Ue"],
		["À", "A"],
		["Á", "A"],
		["Â", "A"],
		["Ã", "A"],
		["Ä", "Ae"],
		["Å", "A"],
		["Æ", "AE"],
		["Ç", "C"],
		["È", "E"],
		["É", "E"],
		["Ê", "E"],
		["Ë", "E"],
		["Ì", "I"],
		["Í", "I"],
		["Î", "I"],
		["Ï", "I"],
		["Ð", "D"],
		["Ñ", "N"],
		["Ò", "O"],
		["Ó", "O"],
		["Ô", "O"],
		["Õ", "O"],
		["Ö", "Oe"],
		["Ő", "O"],
		["Ø", "O"],
		["Ù", "U"],
		["Ú", "U"],
		["Û", "U"],
		["Ü", "Ue"],
		["Ű", "U"],
		["Ý", "Y"],
		["Þ", "TH"],
		["ß", "ss"],
		["à", "a"],
		["á", "a"],
		["â", "a"],
		["ã", "a"],
		["ä", "ae"],
		["å", "a"],
		["æ", "ae"],
		["ç", "c"],
		["è", "e"],
		["é", "e"],
		["ê", "e"],
		["ë", "e"],
		["ì", "i"],
		["í", "i"],
		["î", "i"],
		["ï", "i"],
		["ð", "d"],
		["ñ", "n"],
		["ò", "o"],
		["ó", "o"],
		["ô", "o"],
		["õ", "o"],
		["ö", "oe"],
		["ő", "o"],
		["ø", "o"],
		["ù", "u"],
		["ú", "u"],
		["û", "u"],
		["ü", "ue"],
		["ű", "u"],
		["ý", "y"],
		["þ", "th"],
		["ÿ", "y"],
		["ẞ", "SS"],
		["à", "a"],
		["À", "A"],
		["á", "a"],
		["Á", "A"],
		["â", "a"],
		["Â", "A"],
		["ã", "a"],
		["Ã", "A"],
		["è", "e"],
		["È", "E"],
		["é", "e"],
		["É", "E"],
		["ê", "e"],
		["Ê", "E"],
		["ì", "i"],
		["Ì", "I"],
		["í", "i"],
		["Í", "I"],
		["ò", "o"],
		["Ò", "O"],
		["ó", "o"],
		["Ó", "O"],
		["ô", "o"],
		["Ô", "O"],
		["õ", "o"],
		["Õ", "O"],
		["ù", "u"],
		["Ù", "U"],
		["ú", "u"],
		["Ú", "U"],
		["ý", "y"],
		["Ý", "Y"],
		["ă", "a"],
		["Ă", "A"],
		["Đ", "D"],
		["đ", "d"],
		["ĩ", "i"],
		["Ĩ", "I"],
		["ũ", "u"],
		["Ũ", "U"],
		["ơ", "o"],
		["Ơ", "O"],
		["ư", "u"],
		["Ư", "U"],
		["ạ", "a"],
		["Ạ", "A"],
		["ả", "a"],
		["Ả", "A"],
		["ấ", "a"],
		["Ấ", "A"],
		["ầ", "a"],
		["Ầ", "A"],
		["ẩ", "a"],
		["Ẩ", "A"],
		["ẫ", "a"],
		["Ẫ", "A"],
		["ậ", "a"],
		["Ậ", "A"],
		["ắ", "a"],
		["Ắ", "A"],
		["ằ", "a"],
		["Ằ", "A"],
		["ẳ", "a"],
		["Ẳ", "A"],
		["ẵ", "a"],
		["Ẵ", "A"],
		["ặ", "a"],
		["Ặ", "A"],
		["ẹ", "e"],
		["Ẹ", "E"],
		["ẻ", "e"],
		["Ẻ", "E"],
		["ẽ", "e"],
		["Ẽ", "E"],
		["ế", "e"],
		["Ế", "E"],
		["ề", "e"],
		["Ề", "E"],
		["ể", "e"],
		["Ể", "E"],
		["ễ", "e"],
		["Ễ", "E"],
		["ệ", "e"],
		["Ệ", "E"],
		["ỉ", "i"],
		["Ỉ", "I"],
		["ị", "i"],
		["Ị", "I"],
		["ọ", "o"],
		["Ọ", "O"],
		["ỏ", "o"],
		["Ỏ", "O"],
		["ố", "o"],
		["Ố", "O"],
		["ồ", "o"],
		["Ồ", "O"],
		["ổ", "o"],
		["Ổ", "O"],
		["ỗ", "o"],
		["Ỗ", "O"],
		["ộ", "o"],
		["Ộ", "O"],
		["ớ", "o"],
		["Ớ", "O"],
		["ờ", "o"],
		["Ờ", "O"],
		["ở", "o"],
		["Ở", "O"],
		["ỡ", "o"],
		["Ỡ", "O"],
		["ợ", "o"],
		["Ợ", "O"],
		["ụ", "u"],
		["Ụ", "U"],
		["ủ", "u"],
		["Ủ", "U"],
		["ứ", "u"],
		["Ứ", "U"],
		["ừ", "u"],
		["Ừ", "U"],
		["ử", "u"],
		["Ử", "U"],
		["ữ", "u"],
		["Ữ", "U"],
		["ự", "u"],
		["Ự", "U"],
		["ỳ", "y"],
		["Ỳ", "Y"],
		["ỵ", "y"],
		["Ỵ", "Y"],
		["ỷ", "y"],
		["Ỷ", "Y"],
		["ỹ", "y"],
		["Ỹ", "Y"],
		["ء", "e"],
		["آ", "a"],
		["أ", "a"],
		["ؤ", "w"],
		["إ", "i"],
		["ئ", "y"],
		["ا", "a"],
		["ب", "b"],
		["ة", "t"],
		["ت", "t"],
		["ث", "th"],
		["ج", "j"],
		["ح", "h"],
		["خ", "kh"],
		["د", "d"],
		["ذ", "dh"],
		["ر", "r"],
		["ز", "z"],
		["س", "s"],
		["ش", "sh"],
		["ص", "s"],
		["ض", "d"],
		["ط", "t"],
		["ظ", "z"],
		["ع", "e"],
		["غ", "gh"],
		["ـ", "_"],
		["ف", "f"],
		["ق", "q"],
		["ك", "k"],
		["ل", "l"],
		["م", "m"],
		["ن", "n"],
		["ه", "h"],
		["و", "w"],
		["ى", "a"],
		["ي", "y"],
		["َ‎", "a"],
		["ُ", "u"],
		["ِ‎", "i"],
		["٠", "0"],
		["١", "1"],
		["٢", "2"],
		["٣", "3"],
		["٤", "4"],
		["٥", "5"],
		["٦", "6"],
		["٧", "7"],
		["٨", "8"],
		["٩", "9"],
		["چ", "ch"],
		["ک", "k"],
		["گ", "g"],
		["پ", "p"],
		["ژ", "zh"],
		["ی", "y"],
		["۰", "0"],
		["۱", "1"],
		["۲", "2"],
		["۳", "3"],
		["۴", "4"],
		["۵", "5"],
		["۶", "6"],
		["۷", "7"],
		["۸", "8"],
		["۹", "9"],
		["ټ", "p"],
		["ځ", "z"],
		["څ", "c"],
		["ډ", "d"],
		["ﺫ", "d"],
		["ﺭ", "r"],
		["ړ", "r"],
		["ﺯ", "z"],
		["ږ", "g"],
		["ښ", "x"],
		["ګ", "g"],
		["ڼ", "n"],
		["ۀ", "e"],
		["ې", "e"],
		["ۍ", "ai"],
		["ٹ", "t"],
		["ڈ", "d"],
		["ڑ", "r"],
		["ں", "n"],
		["ہ", "h"],
		["ھ", "h"],
		["ے", "e"],
		["А", "A"],
		["а", "a"],
		["Б", "B"],
		["б", "b"],
		["В", "V"],
		["в", "v"],
		["Г", "G"],
		["г", "g"],
		["Д", "D"],
		["д", "d"],
		["Е", "E"],
		["е", "e"],
		["Ж", "Zh"],
		["ж", "zh"],
		["З", "Z"],
		["з", "z"],
		["И", "I"],
		["и", "i"],
		["Й", "J"],
		["й", "j"],
		["К", "K"],
		["к", "k"],
		["Л", "L"],
		["л", "l"],
		["М", "M"],
		["м", "m"],
		["Н", "N"],
		["н", "n"],
		["О", "O"],
		["о", "o"],
		["П", "P"],
		["п", "p"],
		["Р", "R"],
		["р", "r"],
		["С", "S"],
		["с", "s"],
		["Т", "T"],
		["т", "t"],
		["У", "U"],
		["у", "u"],
		["Ф", "F"],
		["ф", "f"],
		["Х", "H"],
		["х", "h"],
		["Ц", "Cz"],
		["ц", "cz"],
		["Ч", "Ch"],
		["ч", "ch"],
		["Ш", "Sh"],
		["ш", "sh"],
		["Щ", "Shh"],
		["щ", "shh"],
		["Ъ", ""],
		["ъ", ""],
		["Ы", "Y"],
		["ы", "y"],
		["Ь", ""],
		["ь", ""],
		["Э", "E"],
		["э", "e"],
		["Ю", "Yu"],
		["ю", "yu"],
		["Я", "Ya"],
		["я", "ya"],
		["Ё", "Yo"],
		["ё", "yo"],
		["ă", "a"],
		["Ă", "A"],
		["ș", "s"],
		["Ș", "S"],
		["ț", "t"],
		["Ț", "T"],
		["ţ", "t"],
		["Ţ", "T"],
		["ş", "s"],
		["Ş", "S"],
		["ç", "c"],
		["Ç", "C"],
		["ğ", "g"],
		["Ğ", "G"],
		["ı", "i"],
		["İ", "I"],
		["ա", "a"],
		["Ա", "A"],
		["բ", "b"],
		["Բ", "B"],
		["գ", "g"],
		["Գ", "G"],
		["դ", "d"],
		["Դ", "D"],
		["ե", "ye"],
		["Ե", "Ye"],
		["զ", "z"],
		["Զ", "Z"],
		["է", "e"],
		["Է", "E"],
		["ը", "y"],
		["Ը", "Y"],
		["թ", "t"],
		["Թ", "T"],
		["ժ", "zh"],
		["Ժ", "Zh"],
		["ի", "i"],
		["Ի", "I"],
		["լ", "l"],
		["Լ", "L"],
		["խ", "kh"],
		["Խ", "Kh"],
		["ծ", "ts"],
		["Ծ", "Ts"],
		["կ", "k"],
		["Կ", "K"],
		["հ", "h"],
		["Հ", "H"],
		["ձ", "dz"],
		["Ձ", "Dz"],
		["ղ", "gh"],
		["Ղ", "Gh"],
		["ճ", "tch"],
		["Ճ", "Tch"],
		["մ", "m"],
		["Մ", "M"],
		["յ", "y"],
		["Յ", "Y"],
		["ն", "n"],
		["Ն", "N"],
		["շ", "sh"],
		["Շ", "Sh"],
		["ո", "vo"],
		["Ո", "Vo"],
		["չ", "ch"],
		["Չ", "Ch"],
		["պ", "p"],
		["Պ", "P"],
		["ջ", "j"],
		["Ջ", "J"],
		["ռ", "r"],
		["Ռ", "R"],
		["ս", "s"],
		["Ս", "S"],
		["վ", "v"],
		["Վ", "V"],
		["տ", "t"],
		["Տ", "T"],
		["ր", "r"],
		["Ր", "R"],
		["ց", "c"],
		["Ց", "C"],
		["ու", "u"],
		["ՈՒ", "U"],
		["Ու", "U"],
		["փ", "p"],
		["Փ", "P"],
		["ք", "q"],
		["Ք", "Q"],
		["օ", "o"],
		["Օ", "O"],
		["ֆ", "f"],
		["Ֆ", "F"],
		["և", "yev"],
		["ა", "a"],
		["ბ", "b"],
		["გ", "g"],
		["დ", "d"],
		["ე", "e"],
		["ვ", "v"],
		["ზ", "z"],
		["თ", "t"],
		["ი", "i"],
		["კ", "k"],
		["ლ", "l"],
		["მ", "m"],
		["ნ", "n"],
		["ო", "o"],
		["პ", "p"],
		["ჟ", "zh"],
		["რ", "r"],
		["ს", "s"],
		["ტ", "t"],
		["უ", "u"],
		["ფ", "ph"],
		["ქ", "q"],
		["ღ", "gh"],
		["ყ", "k"],
		["შ", "sh"],
		["ჩ", "ch"],
		["ც", "ts"],
		["ძ", "dz"],
		["წ", "ts"],
		["ჭ", "tch"],
		["ხ", "kh"],
		["ჯ", "j"],
		["ჰ", "h"],
		["č", "c"],
		["ď", "d"],
		["ě", "e"],
		["ň", "n"],
		["ř", "r"],
		["š", "s"],
		["ť", "t"],
		["ů", "u"],
		["ž", "z"],
		["Č", "C"],
		["Ď", "D"],
		["Ě", "E"],
		["Ň", "N"],
		["Ř", "R"],
		["Š", "S"],
		["Ť", "T"],
		["Ů", "U"],
		["Ž", "Z"],
		["ހ", "h"],
		["ށ", "sh"],
		["ނ", "n"],
		["ރ", "r"],
		["ބ", "b"],
		["ޅ", "lh"],
		["ކ", "k"],
		["އ", "a"],
		["ވ", "v"],
		["މ", "m"],
		["ފ", "f"],
		["ދ", "dh"],
		["ތ", "th"],
		["ލ", "l"],
		["ގ", "g"],
		["ޏ", "gn"],
		["ސ", "s"],
		["ޑ", "d"],
		["ޒ", "z"],
		["ޓ", "t"],
		["ޔ", "y"],
		["ޕ", "p"],
		["ޖ", "j"],
		["ޗ", "ch"],
		["ޘ", "tt"],
		["ޙ", "hh"],
		["ޚ", "kh"],
		["ޛ", "th"],
		["ޜ", "z"],
		["ޝ", "sh"],
		["ޞ", "s"],
		["ޟ", "d"],
		["ޠ", "t"],
		["ޡ", "z"],
		["ޢ", "a"],
		["ޣ", "gh"],
		["ޤ", "q"],
		["ޥ", "w"],
		["ަ", "a"],
		["ާ", "aa"],
		["ި", "i"],
		["ީ", "ee"],
		["ު", "u"],
		["ޫ", "oo"],
		["ެ", "e"],
		["ޭ", "ey"],
		["ޮ", "o"],
		["ޯ", "oa"],
		["ް", ""],
		["α", "a"],
		["β", "v"],
		["γ", "g"],
		["δ", "d"],
		["ε", "e"],
		["ζ", "z"],
		["η", "i"],
		["θ", "th"],
		["ι", "i"],
		["κ", "k"],
		["λ", "l"],
		["μ", "m"],
		["ν", "n"],
		["ξ", "ks"],
		["ο", "o"],
		["π", "p"],
		["ρ", "r"],
		["σ", "s"],
		["τ", "t"],
		["υ", "y"],
		["φ", "f"],
		["χ", "x"],
		["ψ", "ps"],
		["ω", "o"],
		["ά", "a"],
		["έ", "e"],
		["ί", "i"],
		["ό", "o"],
		["ύ", "y"],
		["ή", "i"],
		["ώ", "o"],
		["ς", "s"],
		["ϊ", "i"],
		["ΰ", "y"],
		["ϋ", "y"],
		["ΐ", "i"],
		["Α", "A"],
		["Β", "B"],
		["Γ", "G"],
		["Δ", "D"],
		["Ε", "E"],
		["Ζ", "Z"],
		["Η", "I"],
		["Θ", "TH"],
		["Ι", "I"],
		["Κ", "K"],
		["Λ", "L"],
		["Μ", "M"],
		["Ν", "N"],
		["Ξ", "KS"],
		["Ο", "O"],
		["Π", "P"],
		["Ρ", "R"],
		["Σ", "S"],
		["Τ", "T"],
		["Υ", "Y"],
		["Φ", "F"],
		["Χ", "X"],
		["Ψ", "PS"],
		["Ω", "O"],
		["Ά", "A"],
		["Έ", "E"],
		["Ί", "I"],
		["Ό", "O"],
		["Ύ", "Y"],
		["Ή", "I"],
		["Ώ", "O"],
		["Ϊ", "I"],
		["Ϋ", "Y"],
		["ā", "a"],
		["ē", "e"],
		["ģ", "g"],
		["ī", "i"],
		["ķ", "k"],
		["ļ", "l"],
		["ņ", "n"],
		["ū", "u"],
		["Ā", "A"],
		["Ē", "E"],
		["Ģ", "G"],
		["Ī", "I"],
		["Ķ", "K"],
		["Ļ", "L"],
		["Ņ", "N"],
		["Ū", "U"],
		["č", "c"],
		["š", "s"],
		["ž", "z"],
		["Č", "C"],
		["Š", "S"],
		["Ž", "Z"],
		["ą", "a"],
		["č", "c"],
		["ę", "e"],
		["ė", "e"],
		["į", "i"],
		["š", "s"],
		["ų", "u"],
		["ū", "u"],
		["ž", "z"],
		["Ą", "A"],
		["Č", "C"],
		["Ę", "E"],
		["Ė", "E"],
		["Į", "I"],
		["Š", "S"],
		["Ų", "U"],
		["Ū", "U"],
		["Ќ", "Kj"],
		["ќ", "kj"],
		["Љ", "Lj"],
		["љ", "lj"],
		["Њ", "Nj"],
		["њ", "nj"],
		["Тс", "Ts"],
		["тс", "ts"],
		["ą", "a"],
		["ć", "c"],
		["ę", "e"],
		["ł", "l"],
		["ń", "n"],
		["ś", "s"],
		["ź", "z"],
		["ż", "z"],
		["Ą", "A"],
		["Ć", "C"],
		["Ę", "E"],
		["Ł", "L"],
		["Ń", "N"],
		["Ś", "S"],
		["Ź", "Z"],
		["Ż", "Z"],
		["Є", "Ye"],
		["І", "I"],
		["Ї", "Yi"],
		["Ґ", "G"],
		["є", "ye"],
		["і", "i"],
		["ї", "yi"],
		["ґ", "g"],
	];
const Wke = Vke,
	qke = Uke,
	Gke = Hke,
	Yke = (t, e) => {
		for (const [n, r] of e) t = t.replace(new RegExp(qke(n), "g"), r);
		return t;
	};
var Jke = (t, e) => {
		if (typeof t != "string")
			throw new TypeError(`Expected a string, got \`${typeof t}\``);
		e = { customReplacements: [], ...e };
		const n = new Map([...Gke, ...e.customReplacements]);
		return (t = t.normalize()), (t = Yke(t, n)), (t = Wke(t)), t;
	},
	Xke = [
		["&", " and "],
		["🦄", " unicorn "],
		["♥", " love "],
	];
const Zke = uq,
	Qke = Jke,
	eCe = Xke,
	tCe = (t) =>
		t
			.replace(/([A-Z]{2,})(\d+)/g, "$1 $2")
			.replace(/([a-z\d]+)([A-Z]{2,})/g, "$1 $2")
			.replace(/([a-z\d])([A-Z])/g, "$1 $2")
			.replace(/([A-Z]+)([A-Z][a-z\d]+)/g, "$1 $2"),
	nCe = (t, e) => {
		const n = Zke(e);
		return t
			.replace(new RegExp(`${n}{2,}`, "g"), e)
			.replace(new RegExp(`^${n}|${n}$`, "g"), "");
	},
	cq = (t, e) => {
		if (typeof t != "string")
			throw new TypeError(`Expected a string, got \`${typeof t}\``);
		e = {
			separator: "-",
			lowercase: !0,
			decamelize: !0,
			customReplacements: [],
			preserveLeadingUnderscore: !1,
			...e,
		};
		const n = e.preserveLeadingUnderscore && t.startsWith("_"),
			r = new Map([...eCe, ...e.customReplacements]);
		(t = Qke(t, { customReplacements: r })), e.decamelize && (t = tCe(t));
		let i = /[^a-zA-Z\d]+/g;
		return (
			e.lowercase && ((t = t.toLowerCase()), (i = /[^a-z\d]+/g)),
			(t = t.replace(i, e.separator)),
			(t = t.replace(/\\/g, "")),
			e.separator && (t = nCe(t, e.separator)),
			n && (t = `_${t}`),
			t
		);
	},
	rCe = () => {
		const t = new Map(),
			e = (n, r) => {
				if (((n = cq(n, r)), !n)) return "";
				const i = n.toLowerCase(),
					o = t.get(i.replace(/(?:-\d+?)+?$/, "")) || 0,
					s = t.get(i);
				t.set(i, typeof s == "number" ? s + 1 : 1);
				const a = t.get(i) || 2;
				return (a >= 2 || o > 2) && (n = `${n}-${a}`), n;
			};
		return (
			(e.reset = () => {
				t.clear();
			}),
			e
		);
	};
N5.exports = cq;
N5.exports.counter = rCe;
var iCe = N5.exports;
const oCe = Dl(iCe),
	$r = function (t) {
		for (var e = 0; ; e++) if (((t = t.previousSibling), !t)) return e;
	},
	Bg = function (t) {
		let e = t.assignedSlot || t.parentNode;
		return e && e.nodeType == 11 ? e.host : e;
	};
let U2 = null;
const Wa = function (t, e, n) {
		let r = U2 || (U2 = document.createRange());
		return r.setEnd(t, n ?? t.nodeValue.length), r.setStart(t, e || 0), r;
	},
	sCe = function () {
		U2 = null;
	},
	Fd = function (t, e, n, r) {
		return n && (KI(t, e, n, r, -1) || KI(t, e, n, r, 1));
	},
	aCe = /^(img|br|input|textarea|hr)$/i;
function KI(t, e, n, r, i) {
	for (;;) {
		if (t == n && e == r) return !0;
		if (e == (i < 0 ? 0 : Oo(t))) {
			let o = t.parentNode;
			if (
				!o ||
				o.nodeType != 1 ||
				K0(t) ||
				aCe.test(t.nodeName) ||
				t.contentEditable == "false"
			)
				return !1;
			(e = $r(t) + (i < 0 ? 0 : 1)), (t = o);
		} else if (t.nodeType == 1) {
			if (
				((t = t.childNodes[e + (i < 0 ? -1 : 0)]),
				t.contentEditable == "false")
			)
				return !1;
			e = i < 0 ? Oo(t) : 0;
		} else return !1;
	}
}
function Oo(t) {
	return t.nodeType == 3 ? t.nodeValue.length : t.childNodes.length;
}
function lCe(t, e) {
	for (;;) {
		if (t.nodeType == 3 && e) return t;
		if (t.nodeType == 1 && e > 0) {
			if (t.contentEditable == "false") return null;
			(t = t.childNodes[e - 1]), (e = Oo(t));
		} else if (t.parentNode && !K0(t)) (e = $r(t)), (t = t.parentNode);
		else return null;
	}
}
function uCe(t, e) {
	for (;;) {
		if (t.nodeType == 3 && e < t.nodeValue.length) return t;
		if (t.nodeType == 1 && e < t.childNodes.length) {
			if (t.contentEditable == "false") return null;
			(t = t.childNodes[e]), (e = 0);
		} else if (t.parentNode && !K0(t)) (e = $r(t) + 1), (t = t.parentNode);
		else return null;
	}
}
function cCe(t, e, n) {
	for (let r = e == 0, i = e == Oo(t); r || i; ) {
		if (t == n) return !0;
		let o = $r(t);
		if (((t = t.parentNode), !t)) return !1;
		(r = r && o == 0), (i = i && o == Oo(t));
	}
}
function K0(t) {
	let e;
	for (let n = t; n && !(e = n.pmViewDesc); n = n.parentNode);
	return e && e.node && e.node.isBlock && (e.dom == t || e.contentDOM == t);
}
const B3 = function (t) {
	return (
		t.focusNode &&
		Fd(t.focusNode, t.focusOffset, t.anchorNode, t.anchorOffset)
	);
};
function Sc(t, e) {
	let n = document.createEvent("Event");
	return (
		n.initEvent("keydown", !0, !0), (n.keyCode = t), (n.key = n.code = e), n
	);
}
function dCe(t) {
	let e = t.activeElement;
	for (; e && e.shadowRoot; ) e = e.shadowRoot.activeElement;
	return e;
}
function fCe(t, e, n) {
	if (t.caretPositionFromPoint)
		try {
			let r = t.caretPositionFromPoint(e, n);
			if (r)
				return {
					node: r.offsetNode,
					offset: Math.min(Oo(r.offsetNode), r.offset),
				};
		} catch {}
	if (t.caretRangeFromPoint) {
		let r = t.caretRangeFromPoint(e, n);
		if (r)
			return {
				node: r.startContainer,
				offset: Math.min(Oo(r.startContainer), r.startOffset),
			};
	}
}
const xa = typeof navigator < "u" ? navigator : null,
	UI = typeof document < "u" ? document : null,
	oc = (xa && xa.userAgent) || "",
	H2 = /Edge\/(\d+)/.exec(oc),
	dq = /MSIE \d/.exec(oc),
	W2 = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(oc),
	_i = !!(dq || W2 || H2),
	Bu = dq ? document.documentMode : W2 ? +W2[1] : H2 ? +H2[1] : 0,
	Ps = !_i && /gecko\/(\d+)/i.test(oc);
Ps && +(/Firefox\/(\d+)/.exec(oc) || [0, 0])[1];
const q2 = !_i && /Chrome\/(\d+)/.exec(oc),
	Ur = !!q2,
	fq = q2 ? +q2[1] : 0,
	gi = !_i && !!xa && /Apple Computer/.test(xa.vendor),
	jh = gi && (/Mobile\/\w+/.test(oc) || (!!xa && xa.maxTouchPoints > 2)),
	Bo = jh || (xa ? /Mac/.test(xa.platform) : !1),
	hCe = xa ? /Win/.test(xa.platform) : !1,
	ms = /Android \d/.test(oc),
	U0 = !!UI && "webkitFontSmoothing" in UI.documentElement.style,
	pCe = U0
		? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1]
		: 0;
function mCe(t) {
	let e = t.defaultView && t.defaultView.visualViewport;
	return e
		? { left: 0, right: e.width, top: 0, bottom: e.height }
		: {
				left: 0,
				right: t.documentElement.clientWidth,
				top: 0,
				bottom: t.documentElement.clientHeight,
			};
}
function Ka(t, e) {
	return typeof t == "number" ? t : t[e];
}
function gCe(t) {
	let e = t.getBoundingClientRect(),
		n = e.width / t.offsetWidth || 1,
		r = e.height / t.offsetHeight || 1;
	return {
		left: e.left,
		right: e.left + t.clientWidth * n,
		top: e.top,
		bottom: e.top + t.clientHeight * r,
	};
}
function HI(t, e, n) {
	let r = t.someProp("scrollThreshold") || 0,
		i = t.someProp("scrollMargin") || 5,
		o = t.dom.ownerDocument;
	for (let s = n || t.dom; s; s = Bg(s)) {
		if (s.nodeType != 1) continue;
		let a = s,
			l = a == o.body,
			u = l ? mCe(o) : gCe(a),
			c = 0,
			d = 0;
		if (
			(e.top < u.top + Ka(r, "top")
				? (d = -(u.top - e.top + Ka(i, "top")))
				: e.bottom > u.bottom - Ka(r, "bottom") &&
					(d =
						e.bottom - e.top > u.bottom - u.top
							? e.top + Ka(i, "top") - u.top
							: e.bottom - u.bottom + Ka(i, "bottom")),
			e.left < u.left + Ka(r, "left")
				? (c = -(u.left - e.left + Ka(i, "left")))
				: e.right > u.right - Ka(r, "right") &&
					(c = e.right - u.right + Ka(i, "right")),
			c || d)
		)
			if (l) o.defaultView.scrollBy(c, d);
			else {
				let f = a.scrollLeft,
					h = a.scrollTop;
				d && (a.scrollTop += d), c && (a.scrollLeft += c);
				let p = a.scrollLeft - f,
					g = a.scrollTop - h;
				e = {
					left: e.left - p,
					top: e.top - g,
					right: e.right - p,
					bottom: e.bottom - g,
				};
			}
		if (l || /^(fixed|sticky)$/.test(getComputedStyle(s).position)) break;
	}
}
function bCe(t) {
	let e = t.dom.getBoundingClientRect(),
		n = Math.max(0, e.top),
		r,
		i;
	for (
		let o = (e.left + e.right) / 2, s = n + 1;
		s < Math.min(innerHeight, e.bottom);
		s += 5
	) {
		let a = t.root.elementFromPoint(o, s);
		if (!a || a == t.dom || !t.dom.contains(a)) continue;
		let l = a.getBoundingClientRect();
		if (l.top >= n - 20) {
			(r = a), (i = l.top);
			break;
		}
	}
	return { refDOM: r, refTop: i, stack: hq(t.dom) };
}
function hq(t) {
	let e = [],
		n = t.ownerDocument;
	for (
		let r = t;
		r && (e.push({ dom: r, top: r.scrollTop, left: r.scrollLeft }), t != n);
		r = Bg(r)
	);
	return e;
}
function vCe({ refDOM: t, refTop: e, stack: n }) {
	let r = t ? t.getBoundingClientRect().top : 0;
	pq(n, r == 0 ? 0 : r - e);
}
function pq(t, e) {
	for (let n = 0; n < t.length; n++) {
		let { dom: r, top: i, left: o } = t[n];
		r.scrollTop != i + e && (r.scrollTop = i + e),
			r.scrollLeft != o && (r.scrollLeft = o);
	}
}
let vf = null;
function yCe(t) {
	if (t.setActive) return t.setActive();
	if (vf) return t.focus(vf);
	let e = hq(t);
	t.focus(
		vf == null
			? {
					get preventScroll() {
						return (vf = { preventScroll: !0 }), !0;
					},
				}
			: void 0,
	),
		vf || ((vf = !1), pq(e, 0));
}
function mq(t, e) {
	let n,
		r = 2e8,
		i,
		o = 0,
		s = e.top,
		a = e.top,
		l,
		u;
	for (let c = t.firstChild, d = 0; c; c = c.nextSibling, d++) {
		let f;
		if (c.nodeType == 1) f = c.getClientRects();
		else if (c.nodeType == 3) f = Wa(c).getClientRects();
		else continue;
		for (let h = 0; h < f.length; h++) {
			let p = f[h];
			if (p.top <= s && p.bottom >= a) {
				(s = Math.max(p.bottom, s)), (a = Math.min(p.top, a));
				let g =
					p.left > e.left
						? p.left - e.left
						: p.right < e.left
							? e.left - p.right
							: 0;
				if (g < r) {
					(n = c),
						(r = g),
						(i =
							g && n.nodeType == 3
								? {
										left:
											p.right < e.left ? p.right : p.left,
										top: e.top,
									}
								: e),
						c.nodeType == 1 &&
							g &&
							(o =
								d + (e.left >= (p.left + p.right) / 2 ? 1 : 0));
					continue;
				}
			} else
				p.top > e.top &&
					!l &&
					p.left <= e.left &&
					p.right >= e.left &&
					((l = c),
					(u = {
						left: Math.max(p.left, Math.min(p.right, e.left)),
						top: p.top,
					}));
			!n &&
				((e.left >= p.right && e.top >= p.top) ||
					(e.left >= p.left && e.top >= p.bottom)) &&
				(o = d + 1);
		}
	}
	return (
		!n && l && ((n = l), (i = u), (r = 0)),
		n && n.nodeType == 3
			? xCe(n, i)
			: !n || (r && n.nodeType == 1)
				? { node: t, offset: o }
				: mq(n, i)
	);
}
function xCe(t, e) {
	let n = t.nodeValue.length,
		r = document.createRange();
	for (let i = 0; i < n; i++) {
		r.setEnd(t, i + 1), r.setStart(t, i);
		let o = Xl(r, 1);
		if (o.top != o.bottom && R5(e, o))
			return {
				node: t,
				offset: i + (e.left >= (o.left + o.right) / 2 ? 1 : 0),
			};
	}
	return { node: t, offset: 0 };
}
function R5(t, e) {
	return (
		t.left >= e.left - 1 &&
		t.left <= e.right + 1 &&
		t.top >= e.top - 1 &&
		t.top <= e.bottom + 1
	);
}
function kCe(t, e) {
	let n = t.parentNode;
	return n &&
		/^li$/i.test(n.nodeName) &&
		e.left < t.getBoundingClientRect().left
		? n
		: t;
}
function CCe(t, e, n) {
	let { node: r, offset: i } = mq(e, n),
		o = -1;
	if (r.nodeType == 1 && !r.firstChild) {
		let s = r.getBoundingClientRect();
		o = s.left != s.right && n.left > (s.left + s.right) / 2 ? 1 : -1;
	}
	return t.docView.posFromDOM(r, i, o);
}
function wCe(t, e, n, r) {
	let i = -1;
	for (let o = e, s = !1; o != t.dom; ) {
		let a = t.docView.nearestDesc(o, !0);
		if (!a) return null;
		if (
			a.dom.nodeType == 1 &&
			((a.node.isBlock && a.parent) || !a.contentDOM)
		) {
			let l = a.dom.getBoundingClientRect();
			if (
				(a.node.isBlock &&
					a.parent &&
					((!s && l.left > r.left) || l.top > r.top
						? (i = a.posBefore)
						: ((!s && l.right < r.left) || l.bottom < r.top) &&
							(i = a.posAfter),
					(s = !0)),
				!a.contentDOM && i < 0 && !a.node.isText)
			)
				return (
					a.node.isBlock
						? r.top < (l.top + l.bottom) / 2
						: r.left < (l.left + l.right) / 2
				)
					? a.posBefore
					: a.posAfter;
		}
		o = a.dom.parentNode;
	}
	return i > -1 ? i : t.docView.posFromDOM(e, n, -1);
}
function gq(t, e, n) {
	let r = t.childNodes.length;
	if (r && n.top < n.bottom)
		for (
			let i = Math.max(
					0,
					Math.min(
						r - 1,
						Math.floor((r * (e.top - n.top)) / (n.bottom - n.top)) -
							2,
					),
				),
				o = i;
			;

		) {
			let s = t.childNodes[o];
			if (s.nodeType == 1) {
				let a = s.getClientRects();
				for (let l = 0; l < a.length; l++) {
					let u = a[l];
					if (R5(e, u)) return gq(s, e, u);
				}
			}
			if ((o = (o + 1) % r) == i) break;
		}
	return t;
}
function ECe(t, e) {
	let n = t.dom.ownerDocument,
		r,
		i = 0,
		o = fCe(n, e.left, e.top);
	o && ({ node: r, offset: i } = o);
	let s = (t.root.elementFromPoint ? t.root : n).elementFromPoint(
			e.left,
			e.top,
		),
		a;
	if (!s || !t.dom.contains(s.nodeType != 1 ? s.parentNode : s)) {
		let u = t.dom.getBoundingClientRect();
		if (!R5(e, u) || ((s = gq(t.dom, e, u)), !s)) return null;
	}
	if (gi) for (let u = s; r && u; u = Bg(u)) u.draggable && (r = void 0);
	if (((s = kCe(s, e)), r)) {
		if (
			Ps &&
			r.nodeType == 1 &&
			((i = Math.min(i, r.childNodes.length)), i < r.childNodes.length)
		) {
			let c = r.childNodes[i],
				d;
			c.nodeName == "IMG" &&
				(d = c.getBoundingClientRect()).right <= e.left &&
				d.bottom > e.top &&
				i++;
		}
		let u;
		U0 &&
			i &&
			r.nodeType == 1 &&
			(u = r.childNodes[i - 1]).nodeType == 1 &&
			u.contentEditable == "false" &&
			u.getBoundingClientRect().top >= e.top &&
			i--,
			r == t.dom &&
			i == r.childNodes.length - 1 &&
			r.lastChild.nodeType == 1 &&
			e.top > r.lastChild.getBoundingClientRect().bottom
				? (a = t.state.doc.content.size)
				: (i == 0 ||
						r.nodeType != 1 ||
						r.childNodes[i - 1].nodeName != "BR") &&
					(a = wCe(t, r, i, e));
	}
	a == null && (a = CCe(t, s, e));
	let l = t.docView.nearestDesc(s, !0);
	return { pos: a, inside: l ? l.posAtStart - l.border : -1 };
}
function WI(t) {
	return t.top < t.bottom || t.left < t.right;
}
function Xl(t, e) {
	let n = t.getClientRects();
	if (n.length) {
		let r = n[e < 0 ? 0 : n.length - 1];
		if (WI(r)) return r;
	}
	return Array.prototype.find.call(n, WI) || t.getBoundingClientRect();
}
const DCe = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
function bq(t, e, n) {
	let {
			node: r,
			offset: i,
			atom: o,
		} = t.docView.domFromPos(e, n < 0 ? -1 : 1),
		s = U0 || Ps;
	if (r.nodeType == 3)
		if (
			s &&
			(DCe.test(r.nodeValue) || (n < 0 ? !i : i == r.nodeValue.length))
		) {
			let l = Xl(Wa(r, i, i), n);
			if (
				Ps &&
				i &&
				/\s/.test(r.nodeValue[i - 1]) &&
				i < r.nodeValue.length
			) {
				let u = Xl(Wa(r, i - 1, i - 1), -1);
				if (u.top == l.top) {
					let c = Xl(Wa(r, i, i + 1), -1);
					if (c.top != l.top) return Op(c, c.left < u.left);
				}
			}
			return l;
		} else {
			let l = i,
				u = i,
				c = n < 0 ? 1 : -1;
			return (
				n < 0 && !i
					? (u++, (c = -1))
					: n >= 0 && i == r.nodeValue.length
						? (l--, (c = 1))
						: n < 0
							? l--
							: u++,
				Op(Xl(Wa(r, l, u), c), c < 0)
			);
		}
	if (!t.state.doc.resolve(e - (o || 0)).parent.inlineContent) {
		if (o == null && i && (n < 0 || i == Oo(r))) {
			let l = r.childNodes[i - 1];
			if (l.nodeType == 1) return nC(l.getBoundingClientRect(), !1);
		}
		if (o == null && i < Oo(r)) {
			let l = r.childNodes[i];
			if (l.nodeType == 1) return nC(l.getBoundingClientRect(), !0);
		}
		return nC(r.getBoundingClientRect(), n >= 0);
	}
	if (o == null && i && (n < 0 || i == Oo(r))) {
		let l = r.childNodes[i - 1],
			u =
				l.nodeType == 3
					? Wa(l, Oo(l) - (s ? 0 : 1))
					: l.nodeType == 1 && (l.nodeName != "BR" || !l.nextSibling)
						? l
						: null;
		if (u) return Op(Xl(u, 1), !1);
	}
	if (o == null && i < Oo(r)) {
		let l = r.childNodes[i];
		for (; l.pmViewDesc && l.pmViewDesc.ignoreForCoords; )
			l = l.nextSibling;
		let u = l
			? l.nodeType == 3
				? Wa(l, 0, s ? 0 : 1)
				: l.nodeType == 1
					? l
					: null
			: null;
		if (u) return Op(Xl(u, -1), !0);
	}
	return Op(Xl(r.nodeType == 3 ? Wa(r) : r, -n), n >= 0);
}
function Op(t, e) {
	if (t.width == 0) return t;
	let n = e ? t.left : t.right;
	return { top: t.top, bottom: t.bottom, left: n, right: n };
}
function nC(t, e) {
	if (t.height == 0) return t;
	let n = e ? t.top : t.bottom;
	return { top: n, bottom: n, left: t.left, right: t.right };
}
function vq(t, e, n) {
	let r = t.state,
		i = t.root.activeElement;
	r != e && t.updateState(e), i != t.dom && t.focus();
	try {
		return n();
	} finally {
		r != e && t.updateState(r), i != t.dom && i && i.focus();
	}
}
function SCe(t, e, n) {
	let r = e.selection,
		i = n == "up" ? r.$from : r.$to;
	return vq(t, e, () => {
		let { node: o } = t.docView.domFromPos(i.pos, n == "up" ? -1 : 1);
		for (;;) {
			let a = t.docView.nearestDesc(o, !0);
			if (!a) break;
			if (a.node.isBlock) {
				o = a.contentDOM || a.dom;
				break;
			}
			o = a.dom.parentNode;
		}
		let s = bq(t, i.pos, 1);
		for (let a = o.firstChild; a; a = a.nextSibling) {
			let l;
			if (a.nodeType == 1) l = a.getClientRects();
			else if (a.nodeType == 3)
				l = Wa(a, 0, a.nodeValue.length).getClientRects();
			else continue;
			for (let u = 0; u < l.length; u++) {
				let c = l[u];
				if (
					c.bottom > c.top + 1 &&
					(n == "up"
						? s.top - c.top > (c.bottom - s.top) * 2
						: c.bottom - s.bottom > (s.bottom - c.top) * 2)
				)
					return !1;
			}
		}
		return !0;
	});
}
const ACe = /[\u0590-\u08ac]/;
function $Ce(t, e, n) {
	let { $head: r } = e.selection;
	if (!r.parent.isTextblock) return !1;
	let i = r.parentOffset,
		o = !i,
		s = i == r.parent.content.size,
		a = t.domSelection();
	return a
		? !ACe.test(r.parent.textContent) || !a.modify
			? n == "left" || n == "backward"
				? o
				: s
			: vq(t, e, () => {
					let {
							focusNode: l,
							focusOffset: u,
							anchorNode: c,
							anchorOffset: d,
						} = t.domSelectionRange(),
						f = a.caretBidiLevel;
					a.modify("move", n, "character");
					let h = r.depth ? t.docView.domAfterPos(r.before()) : t.dom,
						{ focusNode: p, focusOffset: g } =
							t.domSelectionRange(),
						v =
							(p &&
								!h.contains(
									p.nodeType == 1 ? p : p.parentNode,
								)) ||
							(l == p && u == g);
					try {
						a.collapse(c, d),
							l &&
								(l != c || u != d) &&
								a.extend &&
								a.extend(l, u);
					} catch {}
					return f != null && (a.caretBidiLevel = f), v;
				})
		: r.pos == r.start() || r.pos == r.end();
}
let qI = null,
	GI = null,
	YI = !1;
function TCe(t, e, n) {
	return qI == e && GI == n
		? YI
		: ((qI = e),
			(GI = n),
			(YI = n == "up" || n == "down" ? SCe(t, e, n) : $Ce(t, e, n)));
}
const Ko = 0,
	JI = 1,
	Oc = 2,
	ka = 3;
class H0 {
	constructor(e, n, r, i) {
		(this.parent = e),
			(this.children = n),
			(this.dom = r),
			(this.contentDOM = i),
			(this.dirty = Ko),
			(r.pmViewDesc = this);
	}
	matchesWidget(e) {
		return !1;
	}
	matchesMark(e) {
		return !1;
	}
	matchesNode(e, n, r) {
		return !1;
	}
	matchesHack(e) {
		return !1;
	}
	parseRule() {
		return null;
	}
	stopEvent(e) {
		return !1;
	}
	get size() {
		let e = 0;
		for (let n = 0; n < this.children.length; n++)
			e += this.children[n].size;
		return e;
	}
	get border() {
		return 0;
	}
	destroy() {
		(this.parent = void 0),
			this.dom.pmViewDesc == this && (this.dom.pmViewDesc = void 0);
		for (let e = 0; e < this.children.length; e++)
			this.children[e].destroy();
	}
	posBeforeChild(e) {
		for (let n = 0, r = this.posAtStart; ; n++) {
			let i = this.children[n];
			if (i == e) return r;
			r += i.size;
		}
	}
	get posBefore() {
		return this.parent.posBeforeChild(this);
	}
	get posAtStart() {
		return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;
	}
	get posAfter() {
		return this.posBefore + this.size;
	}
	get posAtEnd() {
		return this.posAtStart + this.size - 2 * this.border;
	}
	localPosFromDOM(e, n, r) {
		if (
			this.contentDOM &&
			this.contentDOM.contains(e.nodeType == 1 ? e : e.parentNode)
		)
			if (r < 0) {
				let o, s;
				if (e == this.contentDOM) o = e.childNodes[n - 1];
				else {
					for (; e.parentNode != this.contentDOM; ) e = e.parentNode;
					o = e.previousSibling;
				}
				for (; o && !((s = o.pmViewDesc) && s.parent == this); )
					o = o.previousSibling;
				return o ? this.posBeforeChild(s) + s.size : this.posAtStart;
			} else {
				let o, s;
				if (e == this.contentDOM) o = e.childNodes[n];
				else {
					for (; e.parentNode != this.contentDOM; ) e = e.parentNode;
					o = e.nextSibling;
				}
				for (; o && !((s = o.pmViewDesc) && s.parent == this); )
					o = o.nextSibling;
				return o ? this.posBeforeChild(s) : this.posAtEnd;
			}
		let i;
		if (e == this.dom && this.contentDOM) i = n > $r(this.contentDOM);
		else if (
			this.contentDOM &&
			this.contentDOM != this.dom &&
			this.dom.contains(this.contentDOM)
		)
			i = e.compareDocumentPosition(this.contentDOM) & 2;
		else if (this.dom.firstChild) {
			if (n == 0)
				for (let o = e; ; o = o.parentNode) {
					if (o == this.dom) {
						i = !1;
						break;
					}
					if (o.previousSibling) break;
				}
			if (i == null && n == e.childNodes.length)
				for (let o = e; ; o = o.parentNode) {
					if (o == this.dom) {
						i = !0;
						break;
					}
					if (o.nextSibling) break;
				}
		}
		return (i ?? r > 0) ? this.posAtEnd : this.posAtStart;
	}
	nearestDesc(e, n = !1) {
		for (let r = !0, i = e; i; i = i.parentNode) {
			let o = this.getDesc(i),
				s;
			if (o && (!n || o.node))
				if (
					r &&
					(s = o.nodeDOM) &&
					!(s.nodeType == 1
						? s.contains(e.nodeType == 1 ? e : e.parentNode)
						: s == e)
				)
					r = !1;
				else return o;
		}
	}
	getDesc(e) {
		let n = e.pmViewDesc;
		for (let r = n; r; r = r.parent) if (r == this) return n;
	}
	posFromDOM(e, n, r) {
		for (let i = e; i; i = i.parentNode) {
			let o = this.getDesc(i);
			if (o) return o.localPosFromDOM(e, n, r);
		}
		return -1;
	}
	descAt(e) {
		for (let n = 0, r = 0; n < this.children.length; n++) {
			let i = this.children[n],
				o = r + i.size;
			if (r == e && o != r) {
				for (; !i.border && i.children.length; ) i = i.children[0];
				return i;
			}
			if (e < o) return i.descAt(e - r - i.border);
			r = o;
		}
	}
	domFromPos(e, n) {
		if (!this.contentDOM) return { node: this.dom, offset: 0, atom: e + 1 };
		let r = 0,
			i = 0;
		for (let o = 0; r < this.children.length; r++) {
			let s = this.children[r],
				a = o + s.size;
			if (a > e || s instanceof xq) {
				i = e - o;
				break;
			}
			o = a;
		}
		if (i)
			return this.children[r].domFromPos(i - this.children[r].border, n);
		for (
			let o;
			r &&
			!(o = this.children[r - 1]).size &&
			o instanceof yq &&
			o.side >= 0;
			r--
		);
		if (n <= 0) {
			let o,
				s = !0;
			for (
				;
				(o = r ? this.children[r - 1] : null),
					!(!o || o.dom.parentNode == this.contentDOM);
				r--, s = !1
			);
			return o && n && s && !o.border && !o.domAtom
				? o.domFromPos(o.size, n)
				: { node: this.contentDOM, offset: o ? $r(o.dom) + 1 : 0 };
		} else {
			let o,
				s = !0;
			for (
				;
				(o = r < this.children.length ? this.children[r] : null),
					!(!o || o.dom.parentNode == this.contentDOM);
				r++, s = !1
			);
			return o && s && !o.border && !o.domAtom
				? o.domFromPos(0, n)
				: {
						node: this.contentDOM,
						offset: o
							? $r(o.dom)
							: this.contentDOM.childNodes.length,
					};
		}
	}
	parseRange(e, n, r = 0) {
		if (this.children.length == 0)
			return {
				node: this.contentDOM,
				from: e,
				to: n,
				fromOffset: 0,
				toOffset: this.contentDOM.childNodes.length,
			};
		let i = -1,
			o = -1;
		for (let s = r, a = 0; ; a++) {
			let l = this.children[a],
				u = s + l.size;
			if (i == -1 && e <= u) {
				let c = s + l.border;
				if (
					e >= c &&
					n <= u - l.border &&
					l.node &&
					l.contentDOM &&
					this.contentDOM.contains(l.contentDOM)
				)
					return l.parseRange(e, n, c);
				e = s;
				for (let d = a; d > 0; d--) {
					let f = this.children[d - 1];
					if (
						f.size &&
						f.dom.parentNode == this.contentDOM &&
						!f.emptyChildAt(1)
					) {
						i = $r(f.dom) + 1;
						break;
					}
					e -= f.size;
				}
				i == -1 && (i = 0);
			}
			if (i > -1 && (u > n || a == this.children.length - 1)) {
				n = u;
				for (let c = a + 1; c < this.children.length; c++) {
					let d = this.children[c];
					if (
						d.size &&
						d.dom.parentNode == this.contentDOM &&
						!d.emptyChildAt(-1)
					) {
						o = $r(d.dom);
						break;
					}
					n += d.size;
				}
				o == -1 && (o = this.contentDOM.childNodes.length);
				break;
			}
			s = u;
		}
		return {
			node: this.contentDOM,
			from: e,
			to: n,
			fromOffset: i,
			toOffset: o,
		};
	}
	emptyChildAt(e) {
		if (this.border || !this.contentDOM || !this.children.length) return !1;
		let n = this.children[e < 0 ? 0 : this.children.length - 1];
		return n.size == 0 || n.emptyChildAt(e);
	}
	domAfterPos(e) {
		let { node: n, offset: r } = this.domFromPos(e, 0);
		if (n.nodeType != 1 || r == n.childNodes.length)
			throw new RangeError("No node after pos " + e);
		return n.childNodes[r];
	}
	setSelection(e, n, r, i = !1) {
		let o = Math.min(e, n),
			s = Math.max(e, n);
		for (let f = 0, h = 0; f < this.children.length; f++) {
			let p = this.children[f],
				g = h + p.size;
			if (o > h && s < g)
				return p.setSelection(e - h - p.border, n - h - p.border, r, i);
			h = g;
		}
		let a = this.domFromPos(e, e ? -1 : 1),
			l = n == e ? a : this.domFromPos(n, n ? -1 : 1),
			u = r.getSelection(),
			c = !1;
		if ((Ps || gi) && e == n) {
			let { node: f, offset: h } = a;
			if (f.nodeType == 3) {
				if (
					((c = !!(
						h &&
						f.nodeValue[h - 1] ==
							`
`
					)),
					c && h == f.nodeValue.length)
				)
					for (let p = f, g; p; p = p.parentNode) {
						if ((g = p.nextSibling)) {
							g.nodeName == "BR" &&
								(a = l =
									{ node: g.parentNode, offset: $r(g) + 1 });
							break;
						}
						let v = p.pmViewDesc;
						if (v && v.node && v.node.isBlock) break;
					}
			} else {
				let p = f.childNodes[h - 1];
				c = p && (p.nodeName == "BR" || p.contentEditable == "false");
			}
		}
		if (
			Ps &&
			u.focusNode &&
			u.focusNode != l.node &&
			u.focusNode.nodeType == 1
		) {
			let f = u.focusNode.childNodes[u.focusOffset];
			f && f.contentEditable == "false" && (i = !0);
		}
		if (
			!(i || (c && gi)) &&
			Fd(a.node, a.offset, u.anchorNode, u.anchorOffset) &&
			Fd(l.node, l.offset, u.focusNode, u.focusOffset)
		)
			return;
		let d = !1;
		if ((u.extend || e == n) && !c) {
			u.collapse(a.node, a.offset);
			try {
				e != n && u.extend(l.node, l.offset), (d = !0);
			} catch {}
		}
		if (!d) {
			if (e > n) {
				let h = a;
				(a = l), (l = h);
			}
			let f = document.createRange();
			f.setEnd(l.node, l.offset),
				f.setStart(a.node, a.offset),
				u.removeAllRanges(),
				u.addRange(f);
		}
	}
	ignoreMutation(e) {
		return !this.contentDOM && e.type != "selection";
	}
	get contentLost() {
		return (
			this.contentDOM &&
			this.contentDOM != this.dom &&
			!this.dom.contains(this.contentDOM)
		);
	}
	markDirty(e, n) {
		for (let r = 0, i = 0; i < this.children.length; i++) {
			let o = this.children[i],
				s = r + o.size;
			if (r == s ? e <= s && n >= r : e < s && n > r) {
				let a = r + o.border,
					l = s - o.border;
				if (e >= a && n <= l) {
					(this.dirty = e == r || n == s ? Oc : JI),
						e == a &&
						n == l &&
						(o.contentLost || o.dom.parentNode != this.contentDOM)
							? (o.dirty = ka)
							: o.markDirty(e - a, n - a);
					return;
				} else
					o.dirty =
						o.dom == o.contentDOM &&
						o.dom.parentNode == this.contentDOM &&
						!o.children.length
							? Oc
							: ka;
			}
			r = s;
		}
		this.dirty = Oc;
	}
	markParentsDirty() {
		let e = 1;
		for (let n = this.parent; n; n = n.parent, e++) {
			let r = e == 1 ? Oc : JI;
			n.dirty < r && (n.dirty = r);
		}
	}
	get domAtom() {
		return !1;
	}
	get ignoreForCoords() {
		return !1;
	}
	isText(e) {
		return !1;
	}
}
class yq extends H0 {
	constructor(e, n, r, i) {
		let o,
			s = n.type.toDOM;
		if (
			(typeof s == "function" &&
				(s = s(r, () => {
					if (!o) return i;
					if (o.parent) return o.parent.posBeforeChild(o);
				})),
			!n.type.spec.raw)
		) {
			if (s.nodeType != 1) {
				let a = document.createElement("span");
				a.appendChild(s), (s = a);
			}
			(s.contentEditable = "false"),
				s.classList.add("ProseMirror-widget");
		}
		super(e, [], s, null), (this.widget = n), (this.widget = n), (o = this);
	}
	matchesWidget(e) {
		return this.dirty == Ko && e.type.eq(this.widget.type);
	}
	parseRule() {
		return { ignore: !0 };
	}
	stopEvent(e) {
		let n = this.widget.spec.stopEvent;
		return n ? n(e) : !1;
	}
	ignoreMutation(e) {
		return e.type != "selection" || this.widget.spec.ignoreSelection;
	}
	destroy() {
		this.widget.type.destroy(this.dom), super.destroy();
	}
	get domAtom() {
		return !0;
	}
	get side() {
		return this.widget.type.side;
	}
}
class BCe extends H0 {
	constructor(e, n, r, i) {
		super(e, [], n, null), (this.textDOM = r), (this.text = i);
	}
	get size() {
		return this.text.length;
	}
	localPosFromDOM(e, n) {
		return e != this.textDOM
			? this.posAtStart + (n ? this.size : 0)
			: this.posAtStart + n;
	}
	domFromPos(e) {
		return { node: this.textDOM, offset: e };
	}
	ignoreMutation(e) {
		return e.type === "characterData" && e.target.nodeValue == e.oldValue;
	}
}
class Pd extends H0 {
	constructor(e, n, r, i) {
		super(e, [], r, i), (this.mark = n);
	}
	static create(e, n, r, i) {
		let o = i.nodeViews[n.type.name],
			s = o && o(n, i, r);
		return (
			(!s || !s.dom) &&
				(s = Jd.renderSpec(
					document,
					n.type.spec.toDOM(n, r),
					null,
					n.attrs,
				)),
			new Pd(e, n, s.dom, s.contentDOM || s.dom)
		);
	}
	parseRule() {
		return this.dirty & ka || this.mark.type.spec.reparseInView
			? null
			: {
					mark: this.mark.type.name,
					attrs: this.mark.attrs,
					contentElement: this.contentDOM,
				};
	}
	matchesMark(e) {
		return this.dirty != ka && this.mark.eq(e);
	}
	markDirty(e, n) {
		if ((super.markDirty(e, n), this.dirty != Ko)) {
			let r = this.parent;
			for (; !r.node; ) r = r.parent;
			r.dirty < this.dirty && (r.dirty = this.dirty), (this.dirty = Ko);
		}
	}
	slice(e, n, r) {
		let i = Pd.create(this.parent, this.mark, !0, r),
			o = this.children,
			s = this.size;
		n < s && (o = J2(o, n, s, r)), e > 0 && (o = J2(o, 0, e, r));
		for (let a = 0; a < o.length; a++) o[a].parent = i;
		return (i.children = o), i;
	}
}
class Iu extends H0 {
	constructor(e, n, r, i, o, s, a, l, u) {
		super(e, [], o, s),
			(this.node = n),
			(this.outerDeco = r),
			(this.innerDeco = i),
			(this.nodeDOM = a);
	}
	static create(e, n, r, i, o, s) {
		let a = o.nodeViews[n.type.name],
			l,
			u =
				a &&
				a(
					n,
					o,
					() => {
						if (!l) return s;
						if (l.parent) return l.parent.posBeforeChild(l);
					},
					r,
					i,
				),
			c = u && u.dom,
			d = u && u.contentDOM;
		if (n.isText) {
			if (!c) c = document.createTextNode(n.text);
			else if (c.nodeType != 3)
				throw new RangeError(
					"Text must be rendered as a DOM text node",
				);
		} else
			c ||
				({ dom: c, contentDOM: d } = Jd.renderSpec(
					document,
					n.type.spec.toDOM(n),
					null,
					n.attrs,
				));
		!d &&
			!n.isText &&
			c.nodeName != "BR" &&
			(c.hasAttribute("contenteditable") || (c.contentEditable = "false"),
			n.type.spec.draggable && (c.draggable = !0));
		let f = c;
		return (
			(c = wq(c, r, n)),
			u
				? (l = new ICe(e, n, r, i, c, d || null, f, u, o, s + 1))
				: n.isText
					? new I3(e, n, r, i, c, f, o)
					: new Iu(e, n, r, i, c, d || null, f, o, s + 1)
		);
	}
	parseRule() {
		if (this.node.type.spec.reparseInView) return null;
		let e = { node: this.node.type.name, attrs: this.node.attrs };
		if (
			(this.node.type.whitespace == "pre" &&
				(e.preserveWhitespace = "full"),
			!this.contentDOM)
		)
			e.getContent = () => this.node.content;
		else if (!this.contentLost) e.contentElement = this.contentDOM;
		else {
			for (let n = this.children.length - 1; n >= 0; n--) {
				let r = this.children[n];
				if (this.dom.contains(r.dom.parentNode)) {
					e.contentElement = r.dom.parentNode;
					break;
				}
			}
			e.contentElement || (e.getContent = () => be.empty);
		}
		return e;
	}
	matchesNode(e, n, r) {
		return (
			this.dirty == Ko &&
			e.eq(this.node) &&
			Y2(n, this.outerDeco) &&
			r.eq(this.innerDeco)
		);
	}
	get size() {
		return this.node.nodeSize;
	}
	get border() {
		return this.node.isLeaf ? 0 : 1;
	}
	updateChildren(e, n) {
		let r = this.node.inlineContent,
			i = n,
			o = e.composing ? this.localCompositionInfo(e, n) : null,
			s = o && o.pos > -1 ? o : null,
			a = o && o.pos < 0,
			l = new PCe(this, s && s.node, e);
		OCe(
			this.node,
			this.innerDeco,
			(u, c, d) => {
				u.spec.marks
					? l.syncToMarks(u.spec.marks, r, e)
					: u.type.side >= 0 &&
						!d &&
						l.syncToMarks(
							c == this.node.childCount
								? zt.none
								: this.node.child(c).marks,
							r,
							e,
						),
					l.placeWidget(u, e, i);
			},
			(u, c, d, f) => {
				l.syncToMarks(u.marks, r, e);
				let h;
				l.findNodeMatch(u, c, d, f) ||
					(a &&
						e.state.selection.from > i &&
						e.state.selection.to < i + u.nodeSize &&
						(h = l.findIndexWithChild(o.node)) > -1 &&
						l.updateNodeAt(u, c, d, h, e)) ||
					l.updateNextNode(u, c, d, e, f, i) ||
					l.addNode(u, c, d, e, i),
					(i += u.nodeSize);
			},
		),
			l.syncToMarks([], r, e),
			this.node.isTextblock && l.addTextblockHacks(),
			l.destroyRest(),
			(l.changed || this.dirty == Oc) &&
				(s && this.protectLocalComposition(e, s),
				kq(this.contentDOM, this.children, e),
				jh && MCe(this.dom));
	}
	localCompositionInfo(e, n) {
		let { from: r, to: i } = e.state.selection;
		if (
			!(e.state.selection instanceof kt) ||
			r < n ||
			i > n + this.node.content.size
		)
			return null;
		let o = e.input.compositionNode;
		if (!o || !this.dom.contains(o.parentNode)) return null;
		if (this.node.inlineContent) {
			let s = o.nodeValue,
				a = jCe(this.node.content, s, r - n, i - n);
			return a < 0 ? null : { node: o, pos: a, text: s };
		} else return { node: o, pos: -1, text: "" };
	}
	protectLocalComposition(e, { node: n, pos: r, text: i }) {
		if (this.getDesc(n)) return;
		let o = n;
		for (; o.parentNode != this.contentDOM; o = o.parentNode) {
			for (; o.previousSibling; )
				o.parentNode.removeChild(o.previousSibling);
			for (; o.nextSibling; ) o.parentNode.removeChild(o.nextSibling);
			o.pmViewDesc && (o.pmViewDesc = void 0);
		}
		let s = new BCe(this, o, n, i);
		e.input.compositionNodes.push(s),
			(this.children = J2(this.children, r, r + i.length, e, s));
	}
	update(e, n, r, i) {
		return this.dirty == ka || !e.sameMarkup(this.node)
			? !1
			: (this.updateInner(e, n, r, i), !0);
	}
	updateInner(e, n, r, i) {
		this.updateOuterDeco(n),
			(this.node = e),
			(this.innerDeco = r),
			this.contentDOM && this.updateChildren(i, this.posAtStart),
			(this.dirty = Ko);
	}
	updateOuterDeco(e) {
		if (Y2(e, this.outerDeco)) return;
		let n = this.nodeDOM.nodeType != 1,
			r = this.dom;
		(this.dom = Cq(
			this.dom,
			this.nodeDOM,
			G2(this.outerDeco, this.node, n),
			G2(e, this.node, n),
		)),
			this.dom != r &&
				((r.pmViewDesc = void 0), (this.dom.pmViewDesc = this)),
			(this.outerDeco = e);
	}
	selectNode() {
		this.nodeDOM.nodeType == 1 &&
			this.nodeDOM.classList.add("ProseMirror-selectednode"),
			(this.contentDOM || !this.node.type.spec.draggable) &&
				(this.dom.draggable = !0);
	}
	deselectNode() {
		this.nodeDOM.nodeType == 1 &&
			(this.nodeDOM.classList.remove("ProseMirror-selectednode"),
			(this.contentDOM || !this.node.type.spec.draggable) &&
				this.dom.removeAttribute("draggable"));
	}
	get domAtom() {
		return this.node.isAtom;
	}
}
function XI(t, e, n, r, i) {
	wq(r, e, t);
	let o = new Iu(void 0, t, e, n, r, r, r, i, 0);
	return o.contentDOM && o.updateChildren(i, 0), o;
}
class I3 extends Iu {
	constructor(e, n, r, i, o, s, a) {
		super(e, n, r, i, o, null, s, a, 0);
	}
	parseRule() {
		let e = this.nodeDOM.parentNode;
		for (; e && e != this.dom && !e.pmIsDeco; ) e = e.parentNode;
		return { skip: e || !0 };
	}
	update(e, n, r, i) {
		return this.dirty == ka ||
			(this.dirty != Ko && !this.inParent()) ||
			!e.sameMarkup(this.node)
			? !1
			: (this.updateOuterDeco(n),
				(this.dirty != Ko || e.text != this.node.text) &&
					e.text != this.nodeDOM.nodeValue &&
					((this.nodeDOM.nodeValue = e.text),
					i.trackWrites == this.nodeDOM && (i.trackWrites = null)),
				(this.node = e),
				(this.dirty = Ko),
				!0);
	}
	inParent() {
		let e = this.parent.contentDOM;
		for (let n = this.nodeDOM; n; n = n.parentNode) if (n == e) return !0;
		return !1;
	}
	domFromPos(e) {
		return { node: this.nodeDOM, offset: e };
	}
	localPosFromDOM(e, n, r) {
		return e == this.nodeDOM
			? this.posAtStart + Math.min(n, this.node.text.length)
			: super.localPosFromDOM(e, n, r);
	}
	ignoreMutation(e) {
		return e.type != "characterData" && e.type != "selection";
	}
	slice(e, n, r) {
		let i = this.node.cut(e, n),
			o = document.createTextNode(i.text);
		return new I3(this.parent, i, this.outerDeco, this.innerDeco, o, o, r);
	}
	markDirty(e, n) {
		super.markDirty(e, n),
			this.dom != this.nodeDOM &&
				(e == 0 || n == this.nodeDOM.nodeValue.length) &&
				(this.dirty = ka);
	}
	get domAtom() {
		return !1;
	}
	isText(e) {
		return this.node.text == e;
	}
}
class xq extends H0 {
	parseRule() {
		return { ignore: !0 };
	}
	matchesHack(e) {
		return this.dirty == Ko && this.dom.nodeName == e;
	}
	get domAtom() {
		return !0;
	}
	get ignoreForCoords() {
		return this.dom.nodeName == "IMG";
	}
}
class ICe extends Iu {
	constructor(e, n, r, i, o, s, a, l, u, c) {
		super(e, n, r, i, o, s, a, u, c), (this.spec = l);
	}
	update(e, n, r, i) {
		if (this.dirty == ka) return !1;
		if (this.spec.update) {
			let o = this.spec.update(e, n, r);
			return o && this.updateInner(e, n, r, i), o;
		} else
			return !this.contentDOM && !e.isLeaf
				? !1
				: super.update(e, n, r, i);
	}
	selectNode() {
		this.spec.selectNode ? this.spec.selectNode() : super.selectNode();
	}
	deselectNode() {
		this.spec.deselectNode
			? this.spec.deselectNode()
			: super.deselectNode();
	}
	setSelection(e, n, r, i) {
		this.spec.setSelection
			? this.spec.setSelection(e, n, r)
			: super.setSelection(e, n, r, i);
	}
	destroy() {
		this.spec.destroy && this.spec.destroy(), super.destroy();
	}
	stopEvent(e) {
		return this.spec.stopEvent ? this.spec.stopEvent(e) : !1;
	}
	ignoreMutation(e) {
		return this.spec.ignoreMutation
			? this.spec.ignoreMutation(e)
			: super.ignoreMutation(e);
	}
}
function kq(t, e, n) {
	let r = t.firstChild,
		i = !1;
	for (let o = 0; o < e.length; o++) {
		let s = e[o],
			a = s.dom;
		if (a.parentNode == t) {
			for (; a != r; ) (r = ZI(r)), (i = !0);
			r = r.nextSibling;
		} else (i = !0), t.insertBefore(a, r);
		if (s instanceof Pd) {
			let l = r ? r.previousSibling : t.lastChild;
			kq(s.contentDOM, s.children, n),
				(r = l ? l.nextSibling : t.firstChild);
		}
	}
	for (; r; ) (r = ZI(r)), (i = !0);
	i && n.trackWrites == t && (n.trackWrites = null);
}
const Tm = function (t) {
	t && (this.nodeName = t);
};
Tm.prototype = Object.create(null);
const Mc = [new Tm()];
function G2(t, e, n) {
	if (t.length == 0) return Mc;
	let r = n ? Mc[0] : new Tm(),
		i = [r];
	for (let o = 0; o < t.length; o++) {
		let s = t[o].type.attrs;
		if (s) {
			s.nodeName && i.push((r = new Tm(s.nodeName)));
			for (let a in s) {
				let l = s[a];
				l != null &&
					(n &&
						i.length == 1 &&
						i.push((r = new Tm(e.isInline ? "span" : "div"))),
					a == "class"
						? (r.class = (r.class ? r.class + " " : "") + l)
						: a == "style"
							? (r.style = (r.style ? r.style + ";" : "") + l)
							: a != "nodeName" && (r[a] = l));
			}
		}
	}
	return i;
}
function Cq(t, e, n, r) {
	if (n == Mc && r == Mc) return e;
	let i = e;
	for (let o = 0; o < r.length; o++) {
		let s = r[o],
			a = n[o];
		if (o) {
			let l;
			(a &&
				a.nodeName == s.nodeName &&
				i != t &&
				(l = i.parentNode) &&
				l.nodeName.toLowerCase() == s.nodeName) ||
				((l = document.createElement(s.nodeName)),
				(l.pmIsDeco = !0),
				l.appendChild(i),
				(a = Mc[0])),
				(i = l);
		}
		FCe(i, a || Mc[0], s);
	}
	return i;
}
function FCe(t, e, n) {
	for (let r in e)
		r != "class" &&
			r != "style" &&
			r != "nodeName" &&
			!(r in n) &&
			t.removeAttribute(r);
	for (let r in n)
		r != "class" &&
			r != "style" &&
			r != "nodeName" &&
			n[r] != e[r] &&
			t.setAttribute(r, n[r]);
	if (e.class != n.class) {
		let r = e.class ? e.class.split(" ").filter(Boolean) : [],
			i = n.class ? n.class.split(" ").filter(Boolean) : [];
		for (let o = 0; o < r.length; o++)
			i.indexOf(r[o]) == -1 && t.classList.remove(r[o]);
		for (let o = 0; o < i.length; o++)
			r.indexOf(i[o]) == -1 && t.classList.add(i[o]);
		t.classList.length == 0 && t.removeAttribute("class");
	}
	if (e.style != n.style) {
		if (e.style) {
			let r =
					/\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g,
				i;
			for (; (i = r.exec(e.style)); ) t.style.removeProperty(i[1]);
		}
		n.style && (t.style.cssText += n.style);
	}
}
function wq(t, e, n) {
	return Cq(t, t, Mc, G2(e, n, t.nodeType != 1));
}
function Y2(t, e) {
	if (t.length != e.length) return !1;
	for (let n = 0; n < t.length; n++) if (!t[n].type.eq(e[n].type)) return !1;
	return !0;
}
function ZI(t) {
	let e = t.nextSibling;
	return t.parentNode.removeChild(t), e;
}
class PCe {
	constructor(e, n, r) {
		(this.lock = n),
			(this.view = r),
			(this.index = 0),
			(this.stack = []),
			(this.changed = !1),
			(this.top = e),
			(this.preMatch = NCe(e.node.content, e));
	}
	destroyBetween(e, n) {
		if (e != n) {
			for (let r = e; r < n; r++) this.top.children[r].destroy();
			this.top.children.splice(e, n - e), (this.changed = !0);
		}
	}
	destroyRest() {
		this.destroyBetween(this.index, this.top.children.length);
	}
	syncToMarks(e, n, r) {
		let i = 0,
			o = this.stack.length >> 1,
			s = Math.min(o, e.length);
		for (
			;
			i < s &&
			(i == o - 1 ? this.top : this.stack[(i + 1) << 1]).matchesMark(
				e[i],
			) &&
			e[i].type.spec.spanning !== !1;

		)
			i++;
		for (; i < o; )
			this.destroyRest(),
				(this.top.dirty = Ko),
				(this.index = this.stack.pop()),
				(this.top = this.stack.pop()),
				o--;
		for (; o < e.length; ) {
			this.stack.push(this.top, this.index + 1);
			let a = -1;
			for (
				let l = this.index;
				l < Math.min(this.index + 3, this.top.children.length);
				l++
			) {
				let u = this.top.children[l];
				if (u.matchesMark(e[o]) && !this.isLocked(u.dom)) {
					a = l;
					break;
				}
			}
			if (a > -1)
				a > this.index &&
					((this.changed = !0), this.destroyBetween(this.index, a)),
					(this.top = this.top.children[this.index]);
			else {
				let l = Pd.create(this.top, e[o], n, r);
				this.top.children.splice(this.index, 0, l),
					(this.top = l),
					(this.changed = !0);
			}
			(this.index = 0), o++;
		}
	}
	findNodeMatch(e, n, r, i) {
		let o = -1,
			s;
		if (
			i >= this.preMatch.index &&
			(s = this.preMatch.matches[i - this.preMatch.index]).parent ==
				this.top &&
			s.matchesNode(e, n, r)
		)
			o = this.top.children.indexOf(s, this.index);
		else
			for (
				let a = this.index,
					l = Math.min(this.top.children.length, a + 5);
				a < l;
				a++
			) {
				let u = this.top.children[a];
				if (u.matchesNode(e, n, r) && !this.preMatch.matched.has(u)) {
					o = a;
					break;
				}
			}
		return o < 0
			? !1
			: (this.destroyBetween(this.index, o), this.index++, !0);
	}
	updateNodeAt(e, n, r, i, o) {
		let s = this.top.children[i];
		return (
			s.dirty == ka && s.dom == s.contentDOM && (s.dirty = Oc),
			s.update(e, n, r, o)
				? (this.destroyBetween(this.index, i), this.index++, !0)
				: !1
		);
	}
	findIndexWithChild(e) {
		for (;;) {
			let n = e.parentNode;
			if (!n) return -1;
			if (n == this.top.contentDOM) {
				let r = e.pmViewDesc;
				if (r) {
					for (let i = this.index; i < this.top.children.length; i++)
						if (this.top.children[i] == r) return i;
				}
				return -1;
			}
			e = n;
		}
	}
	updateNextNode(e, n, r, i, o, s) {
		for (let a = this.index; a < this.top.children.length; a++) {
			let l = this.top.children[a];
			if (l instanceof Iu) {
				let u = this.preMatch.matched.get(l);
				if (u != null && u != o) return !1;
				let c = l.dom,
					d,
					f =
						this.isLocked(c) &&
						!(
							e.isText &&
							l.node &&
							l.node.isText &&
							l.nodeDOM.nodeValue == e.text &&
							l.dirty != ka &&
							Y2(n, l.outerDeco)
						);
				if (!f && l.update(e, n, r, i))
					return (
						this.destroyBetween(this.index, a),
						l.dom != c && (this.changed = !0),
						this.index++,
						!0
					);
				if (!f && (d = this.recreateWrapper(l, e, n, r, i, s)))
					return (
						(this.top.children[this.index] = d),
						d.contentDOM &&
							((d.dirty = Oc),
							d.updateChildren(i, s + 1),
							(d.dirty = Ko)),
						(this.changed = !0),
						this.index++,
						!0
					);
				break;
			}
		}
		return !1;
	}
	recreateWrapper(e, n, r, i, o, s) {
		if (
			e.dirty ||
			n.isAtom ||
			!e.children.length ||
			!e.node.content.eq(n.content)
		)
			return null;
		let a = Iu.create(this.top, n, r, i, o, s);
		if (a.contentDOM) {
			(a.children = e.children), (e.children = []);
			for (let l of a.children) l.parent = a;
		}
		return e.destroy(), a;
	}
	addNode(e, n, r, i, o) {
		let s = Iu.create(this.top, e, n, r, i, o);
		s.contentDOM && s.updateChildren(i, o + 1),
			this.top.children.splice(this.index++, 0, s),
			(this.changed = !0);
	}
	placeWidget(e, n, r) {
		let i =
			this.index < this.top.children.length
				? this.top.children[this.index]
				: null;
		if (
			i &&
			i.matchesWidget(e) &&
			(e == i.widget || !i.widget.type.toDOM.parentNode)
		)
			this.index++;
		else {
			let o = new yq(this.top, e, n, r);
			this.top.children.splice(this.index++, 0, o), (this.changed = !0);
		}
	}
	addTextblockHacks() {
		let e = this.top.children[this.index - 1],
			n = this.top;
		for (; e instanceof Pd; )
			(n = e), (e = n.children[n.children.length - 1]);
		(!e ||
			!(e instanceof I3) ||
			/\n$/.test(e.node.text) ||
			(this.view.requiresGeckoHackNode && /\s$/.test(e.node.text))) &&
			((gi || Ur) &&
				e &&
				e.dom.contentEditable == "false" &&
				this.addHackNode("IMG", n),
			this.addHackNode("BR", this.top));
	}
	addHackNode(e, n) {
		if (
			n == this.top &&
			this.index < n.children.length &&
			n.children[this.index].matchesHack(e)
		)
			this.index++;
		else {
			let r = document.createElement(e);
			e == "IMG" &&
				((r.className = "ProseMirror-separator"), (r.alt = "")),
				e == "BR" && (r.className = "ProseMirror-trailingBreak");
			let i = new xq(this.top, [], r, null);
			n != this.top
				? n.children.push(i)
				: n.children.splice(this.index++, 0, i),
				(this.changed = !0);
		}
	}
	isLocked(e) {
		return (
			this.lock &&
			(e == this.lock ||
				(e.nodeType == 1 && e.contains(this.lock.parentNode)))
		);
	}
}
function NCe(t, e) {
	let n = e,
		r = n.children.length,
		i = t.childCount,
		o = new Map(),
		s = [];
	e: for (; i > 0; ) {
		let a;
		for (;;)
			if (r) {
				let u = n.children[r - 1];
				if (u instanceof Pd) (n = u), (r = u.children.length);
				else {
					(a = u), r--;
					break;
				}
			} else {
				if (n == e) break e;
				(r = n.parent.children.indexOf(n)), (n = n.parent);
			}
		let l = a.node;
		if (l) {
			if (l != t.child(i - 1)) break;
			--i, o.set(a, i), s.push(a);
		}
	}
	return { index: i, matched: o, matches: s.reverse() };
}
function RCe(t, e) {
	return t.type.side - e.type.side;
}
function OCe(t, e, n, r) {
	let i = e.locals(t),
		o = 0;
	if (i.length == 0) {
		for (let u = 0; u < t.childCount; u++) {
			let c = t.child(u);
			r(c, i, e.forChild(o, c), u), (o += c.nodeSize);
		}
		return;
	}
	let s = 0,
		a = [],
		l = null;
	for (let u = 0; ; ) {
		let c, d;
		for (; s < i.length && i[s].to == o; ) {
			let v = i[s++];
			v.widget && (c ? (d || (d = [c])).push(v) : (c = v));
		}
		if (c)
			if (d) {
				d.sort(RCe);
				for (let v = 0; v < d.length; v++) n(d[v], u, !!l);
			} else n(c, u, !!l);
		let f, h;
		if (l) (h = -1), (f = l), (l = null);
		else if (u < t.childCount) (h = u), (f = t.child(u++));
		else break;
		for (let v = 0; v < a.length; v++) a[v].to <= o && a.splice(v--, 1);
		for (; s < i.length && i[s].from <= o && i[s].to > o; ) a.push(i[s++]);
		let p = o + f.nodeSize;
		if (f.isText) {
			let v = p;
			s < i.length && i[s].from < v && (v = i[s].from);
			for (let b = 0; b < a.length; b++) a[b].to < v && (v = a[b].to);
			v < p &&
				((l = f.cut(v - o)), (f = f.cut(0, v - o)), (p = v), (h = -1));
		} else for (; s < i.length && i[s].to < p; ) s++;
		let g =
			f.isInline && !f.isLeaf ? a.filter((v) => !v.inline) : a.slice();
		r(f, g, e.forChild(o, f), h), (o = p);
	}
}
function MCe(t) {
	if (t.nodeName == "UL" || t.nodeName == "OL") {
		let e = t.style.cssText;
		(t.style.cssText = e + "; list-style: square !important"),
			window.getComputedStyle(t).listStyle,
			(t.style.cssText = e);
	}
}
function jCe(t, e, n, r) {
	for (let i = 0, o = 0; i < t.childCount && o <= r; ) {
		let s = t.child(i++),
			a = o;
		if (((o += s.nodeSize), !s.isText)) continue;
		let l = s.text;
		for (; i < t.childCount; ) {
			let u = t.child(i++);
			if (((o += u.nodeSize), !u.isText)) break;
			l += u.text;
		}
		if (o >= n) {
			if (o >= r && l.slice(r - e.length - a, r - a) == e)
				return r - e.length;
			let u = a < r ? l.lastIndexOf(e, r - a - 1) : -1;
			if (u >= 0 && u + e.length + a >= n) return a + u;
			if (
				n == r &&
				l.length >= r + e.length - a &&
				l.slice(r - a, r - a + e.length) == e
			)
				return r;
		}
	}
	return -1;
}
function J2(t, e, n, r, i) {
	let o = [];
	for (let s = 0, a = 0; s < t.length; s++) {
		let l = t[s],
			u = a,
			c = (a += l.size);
		u >= n || c <= e
			? o.push(l)
			: (u < e && o.push(l.slice(0, e - u, r)),
				i && (o.push(i), (i = void 0)),
				c > n && o.push(l.slice(n - u, l.size, r)));
	}
	return o;
}
function O5(t, e = null) {
	let n = t.domSelectionRange(),
		r = t.state.doc;
	if (!n.focusNode) return null;
	let i = t.docView.nearestDesc(n.focusNode),
		o = i && i.size == 0,
		s = t.docView.posFromDOM(n.focusNode, n.focusOffset, 1);
	if (s < 0) return null;
	let a = r.resolve(s),
		l,
		u;
	if (B3(n)) {
		for (l = a; i && !i.node; ) i = i.parent;
		let c = i.node;
		if (
			i &&
			c.isAtom &&
			Qe.isSelectable(c) &&
			i.parent &&
			!(c.isInline && cCe(n.focusNode, n.focusOffset, i.dom))
		) {
			let d = i.posBefore;
			u = new Qe(s == d ? a : r.resolve(d));
		}
	} else {
		let c = t.docView.posFromDOM(n.anchorNode, n.anchorOffset, 1);
		if (c < 0) return null;
		l = r.resolve(c);
	}
	if (!u) {
		let c =
			e == "pointer" || (t.state.selection.head < a.pos && !o) ? 1 : -1;
		u = M5(t, l, a, c);
	}
	return u;
}
function Eq(t) {
	return t.editable
		? t.hasFocus()
		: Sq(t) &&
				document.activeElement &&
				document.activeElement.contains(t.dom);
}
function ul(t, e = !1) {
	let n = t.state.selection;
	if ((Dq(t, n), !!Eq(t))) {
		if (!e && t.input.mouseDown && t.input.mouseDown.allowDefault && Ur) {
			let r = t.domSelectionRange(),
				i = t.domObserver.currentSelection;
			if (
				r.anchorNode &&
				i.anchorNode &&
				Fd(r.anchorNode, r.anchorOffset, i.anchorNode, i.anchorOffset)
			) {
				(t.input.mouseDown.delayedSelectionSync = !0),
					t.domObserver.setCurSelection();
				return;
			}
		}
		if ((t.domObserver.disconnectSelection(), t.cursorWrapper)) zCe(t);
		else {
			let { anchor: r, head: i } = n,
				o,
				s;
			QI &&
				!(n instanceof kt) &&
				(n.$from.parent.inlineContent || (o = e7(t, n.from)),
				!n.empty && !n.$from.parent.inlineContent && (s = e7(t, n.to))),
				t.docView.setSelection(r, i, t.root, e),
				QI && (o && t7(o), s && t7(s)),
				n.visible
					? t.dom.classList.remove("ProseMirror-hideselection")
					: (t.dom.classList.add("ProseMirror-hideselection"),
						"onselectionchange" in document && _Ce(t));
		}
		t.domObserver.setCurSelection(), t.domObserver.connectSelection();
	}
}
const QI = gi || (Ur && fq < 63);
function e7(t, e) {
	let { node: n, offset: r } = t.docView.domFromPos(e, 0),
		i = r < n.childNodes.length ? n.childNodes[r] : null,
		o = r ? n.childNodes[r - 1] : null;
	if (gi && i && i.contentEditable == "false") return rC(i);
	if (
		(!i || i.contentEditable == "false") &&
		(!o || o.contentEditable == "false")
	) {
		if (i) return rC(i);
		if (o) return rC(o);
	}
}
function rC(t) {
	return (
		(t.contentEditable = "true"),
		gi && t.draggable && ((t.draggable = !1), (t.wasDraggable = !0)),
		t
	);
}
function t7(t) {
	(t.contentEditable = "false"),
		t.wasDraggable && ((t.draggable = !0), (t.wasDraggable = null));
}
function _Ce(t) {
	let e = t.dom.ownerDocument;
	e.removeEventListener("selectionchange", t.input.hideSelectionGuard);
	let n = t.domSelectionRange(),
		r = n.anchorNode,
		i = n.anchorOffset;
	e.addEventListener(
		"selectionchange",
		(t.input.hideSelectionGuard = () => {
			(n.anchorNode != r || n.anchorOffset != i) &&
				(e.removeEventListener(
					"selectionchange",
					t.input.hideSelectionGuard,
				),
				setTimeout(() => {
					(!Eq(t) || t.state.selection.visible) &&
						t.dom.classList.remove("ProseMirror-hideselection");
				}, 20));
		}),
	);
}
function zCe(t) {
	let e = t.domSelection(),
		n = document.createRange();
	if (!e) return;
	let r = t.cursorWrapper.dom,
		i = r.nodeName == "IMG";
	i ? n.setStart(r.parentNode, $r(r) + 1) : n.setStart(r, 0),
		n.collapse(!0),
		e.removeAllRanges(),
		e.addRange(n),
		!i &&
			!t.state.selection.visible &&
			_i &&
			Bu <= 11 &&
			((r.disabled = !0), (r.disabled = !1));
}
function Dq(t, e) {
	if (e instanceof Qe) {
		let n = t.docView.descAt(e.from);
		n != t.lastSelectedViewDesc &&
			(n7(t), n && n.selectNode(), (t.lastSelectedViewDesc = n));
	} else n7(t);
}
function n7(t) {
	t.lastSelectedViewDesc &&
		(t.lastSelectedViewDesc.parent && t.lastSelectedViewDesc.deselectNode(),
		(t.lastSelectedViewDesc = void 0));
}
function M5(t, e, n, r) {
	return (
		t.someProp("createSelectionBetween", (i) => i(t, e, n)) ||
		kt.between(e, n, r)
	);
}
function r7(t) {
	return t.editable && !t.hasFocus() ? !1 : Sq(t);
}
function Sq(t) {
	let e = t.domSelectionRange();
	if (!e.anchorNode) return !1;
	try {
		return (
			t.dom.contains(
				e.anchorNode.nodeType == 3
					? e.anchorNode.parentNode
					: e.anchorNode,
			) &&
			(t.editable ||
				t.dom.contains(
					e.focusNode.nodeType == 3
						? e.focusNode.parentNode
						: e.focusNode,
				))
		);
	} catch {
		return !1;
	}
}
function LCe(t) {
	let e = t.docView.domFromPos(t.state.selection.anchor, 0),
		n = t.domSelectionRange();
	return Fd(e.node, e.offset, n.anchorNode, n.anchorOffset);
}
function X2(t, e) {
	let { $anchor: n, $head: r } = t.selection,
		i = e > 0 ? n.max(r) : n.min(r),
		o = i.parent.inlineContent
			? i.depth
				? t.doc.resolve(e > 0 ? i.after() : i.before())
				: null
			: i;
	return o && mt.findFrom(o, e);
}
function nu(t, e) {
	return t.dispatch(t.state.tr.setSelection(e).scrollIntoView()), !0;
}
function i7(t, e, n) {
	let r = t.state.selection;
	if (r instanceof kt)
		if (n.indexOf("s") > -1) {
			let { $head: i } = r,
				o = i.textOffset ? null : e < 0 ? i.nodeBefore : i.nodeAfter;
			if (!o || o.isText || !o.isLeaf) return !1;
			let s = t.state.doc.resolve(i.pos + o.nodeSize * (e < 0 ? -1 : 1));
			return nu(t, new kt(r.$anchor, s));
		} else if (r.empty) {
			if (t.endOfTextblock(e > 0 ? "forward" : "backward")) {
				let i = X2(t.state, e);
				return i && i instanceof Qe ? nu(t, i) : !1;
			} else if (!(Bo && n.indexOf("m") > -1)) {
				let i = r.$head,
					o = i.textOffset
						? null
						: e < 0
							? i.nodeBefore
							: i.nodeAfter,
					s;
				if (!o || o.isText) return !1;
				let a = e < 0 ? i.pos - o.nodeSize : i.pos;
				return o.isAtom || ((s = t.docView.descAt(a)) && !s.contentDOM)
					? Qe.isSelectable(o)
						? nu(
								t,
								new Qe(
									e < 0
										? t.state.doc.resolve(
												i.pos - o.nodeSize,
											)
										: i,
								),
							)
						: U0
							? nu(
									t,
									new kt(
										t.state.doc.resolve(
											e < 0 ? a : a + o.nodeSize,
										),
									),
								)
							: !1
					: !1;
			}
		} else return !1;
	else {
		if (r instanceof Qe && r.node.isInline)
			return nu(t, new kt(e > 0 ? r.$to : r.$from));
		{
			let i = X2(t.state, e);
			return i ? nu(t, i) : !1;
		}
	}
}
function Cy(t) {
	return t.nodeType == 3 ? t.nodeValue.length : t.childNodes.length;
}
function Bm(t, e) {
	let n = t.pmViewDesc;
	return n && n.size == 0 && (e < 0 || t.nextSibling || t.nodeName != "BR");
}
function yf(t, e) {
	return e < 0 ? VCe(t) : KCe(t);
}
function VCe(t) {
	let e = t.domSelectionRange(),
		n = e.focusNode,
		r = e.focusOffset;
	if (!n) return;
	let i,
		o,
		s = !1;
	for (
		Ps &&
		n.nodeType == 1 &&
		r < Cy(n) &&
		Bm(n.childNodes[r], -1) &&
		(s = !0);
		;

	)
		if (r > 0) {
			if (n.nodeType != 1) break;
			{
				let a = n.childNodes[r - 1];
				if (Bm(a, -1)) (i = n), (o = --r);
				else if (a.nodeType == 3) (n = a), (r = n.nodeValue.length);
				else break;
			}
		} else {
			if (Aq(n)) break;
			{
				let a = n.previousSibling;
				for (; a && Bm(a, -1); )
					(i = n.parentNode), (o = $r(a)), (a = a.previousSibling);
				if (a) (n = a), (r = Cy(n));
				else {
					if (((n = n.parentNode), n == t.dom)) break;
					r = 0;
				}
			}
		}
	s ? Z2(t, n, r) : i && Z2(t, i, o);
}
function KCe(t) {
	let e = t.domSelectionRange(),
		n = e.focusNode,
		r = e.focusOffset;
	if (!n) return;
	let i = Cy(n),
		o,
		s;
	for (;;)
		if (r < i) {
			if (n.nodeType != 1) break;
			let a = n.childNodes[r];
			if (Bm(a, 1)) (o = n), (s = ++r);
			else break;
		} else {
			if (Aq(n)) break;
			{
				let a = n.nextSibling;
				for (; a && Bm(a, 1); )
					(o = a.parentNode), (s = $r(a) + 1), (a = a.nextSibling);
				if (a) (n = a), (r = 0), (i = Cy(n));
				else {
					if (((n = n.parentNode), n == t.dom)) break;
					r = i = 0;
				}
			}
		}
	o && Z2(t, o, s);
}
function Aq(t) {
	let e = t.pmViewDesc;
	return e && e.node && e.node.isBlock;
}
function UCe(t, e) {
	for (; t && e == t.childNodes.length && !K0(t); )
		(e = $r(t) + 1), (t = t.parentNode);
	for (; t && e < t.childNodes.length; ) {
		let n = t.childNodes[e];
		if (n.nodeType == 3) return n;
		if (n.nodeType == 1 && n.contentEditable == "false") break;
		(t = n), (e = 0);
	}
}
function HCe(t, e) {
	for (; t && !e && !K0(t); ) (e = $r(t)), (t = t.parentNode);
	for (; t && e; ) {
		let n = t.childNodes[e - 1];
		if (n.nodeType == 3) return n;
		if (n.nodeType == 1 && n.contentEditable == "false") break;
		(t = n), (e = t.childNodes.length);
	}
}
function Z2(t, e, n) {
	if (e.nodeType != 3) {
		let o, s;
		(s = UCe(e, n))
			? ((e = s), (n = 0))
			: (o = HCe(e, n)) && ((e = o), (n = o.nodeValue.length));
	}
	let r = t.domSelection();
	if (!r) return;
	if (B3(r)) {
		let o = document.createRange();
		o.setEnd(e, n), o.setStart(e, n), r.removeAllRanges(), r.addRange(o);
	} else r.extend && r.extend(e, n);
	t.domObserver.setCurSelection();
	let { state: i } = t;
	setTimeout(() => {
		t.state == i && ul(t);
	}, 50);
}
function o7(t, e) {
	let n = t.state.doc.resolve(e);
	if (!(Ur || hCe) && n.parent.inlineContent) {
		let i = t.coordsAtPos(e);
		if (e > n.start()) {
			let o = t.coordsAtPos(e - 1),
				s = (o.top + o.bottom) / 2;
			if (s > i.top && s < i.bottom && Math.abs(o.left - i.left) > 1)
				return o.left < i.left ? "ltr" : "rtl";
		}
		if (e < n.end()) {
			let o = t.coordsAtPos(e + 1),
				s = (o.top + o.bottom) / 2;
			if (s > i.top && s < i.bottom && Math.abs(o.left - i.left) > 1)
				return o.left > i.left ? "ltr" : "rtl";
		}
	}
	return getComputedStyle(t.dom).direction == "rtl" ? "rtl" : "ltr";
}
function s7(t, e, n) {
	let r = t.state.selection;
	if (
		(r instanceof kt && !r.empty) ||
		n.indexOf("s") > -1 ||
		(Bo && n.indexOf("m") > -1)
	)
		return !1;
	let { $from: i, $to: o } = r;
	if (!i.parent.inlineContent || t.endOfTextblock(e < 0 ? "up" : "down")) {
		let s = X2(t.state, e);
		if (s && s instanceof Qe) return nu(t, s);
	}
	if (!i.parent.inlineContent) {
		let s = e < 0 ? i : o,
			a = r instanceof ji ? mt.near(s, e) : mt.findFrom(s, e);
		return a ? nu(t, a) : !1;
	}
	return !1;
}
function a7(t, e) {
	if (!(t.state.selection instanceof kt)) return !0;
	let { $head: n, $anchor: r, empty: i } = t.state.selection;
	if (!n.sameParent(r)) return !0;
	if (!i) return !1;
	if (t.endOfTextblock(e > 0 ? "forward" : "backward")) return !0;
	let o = !n.textOffset && (e < 0 ? n.nodeBefore : n.nodeAfter);
	if (o && !o.isText) {
		let s = t.state.tr;
		return (
			e < 0
				? s.delete(n.pos - o.nodeSize, n.pos)
				: s.delete(n.pos, n.pos + o.nodeSize),
			t.dispatch(s),
			!0
		);
	}
	return !1;
}
function l7(t, e, n) {
	t.domObserver.stop(), (e.contentEditable = n), t.domObserver.start();
}
function WCe(t) {
	if (!gi || t.state.selection.$head.parentOffset > 0) return !1;
	let { focusNode: e, focusOffset: n } = t.domSelectionRange();
	if (
		e &&
		e.nodeType == 1 &&
		n == 0 &&
		e.firstChild &&
		e.firstChild.contentEditable == "false"
	) {
		let r = e.firstChild;
		l7(t, r, "true"), setTimeout(() => l7(t, r, "false"), 20);
	}
	return !1;
}
function qCe(t) {
	let e = "";
	return (
		t.ctrlKey && (e += "c"),
		t.metaKey && (e += "m"),
		t.altKey && (e += "a"),
		t.shiftKey && (e += "s"),
		e
	);
}
function GCe(t, e) {
	let n = e.keyCode,
		r = qCe(e);
	if (n == 8 || (Bo && n == 72 && r == "c")) return a7(t, -1) || yf(t, -1);
	if ((n == 46 && !e.shiftKey) || (Bo && n == 68 && r == "c"))
		return a7(t, 1) || yf(t, 1);
	if (n == 13 || n == 27) return !0;
	if (n == 37 || (Bo && n == 66 && r == "c")) {
		let i =
			n == 37 ? (o7(t, t.state.selection.from) == "ltr" ? -1 : 1) : -1;
		return i7(t, i, r) || yf(t, i);
	} else if (n == 39 || (Bo && n == 70 && r == "c")) {
		let i = n == 39 ? (o7(t, t.state.selection.from) == "ltr" ? 1 : -1) : 1;
		return i7(t, i, r) || yf(t, i);
	} else {
		if (n == 38 || (Bo && n == 80 && r == "c"))
			return s7(t, -1, r) || yf(t, -1);
		if (n == 40 || (Bo && n == 78 && r == "c"))
			return WCe(t) || s7(t, 1, r) || yf(t, 1);
		if (r == (Bo ? "m" : "c") && (n == 66 || n == 73 || n == 89 || n == 90))
			return !0;
	}
	return !1;
}
function $q(t, e) {
	t.someProp("transformCopied", (h) => {
		e = h(e, t);
	});
	let n = [],
		{ content: r, openStart: i, openEnd: o } = e;
	for (
		;
		i > 1 && o > 1 && r.childCount == 1 && r.firstChild.childCount == 1;

	) {
		i--, o--;
		let h = r.firstChild;
		n.push(h.type.name, h.attrs != h.type.defaultAttrs ? h.attrs : null),
			(r = h.content);
	}
	let s = t.someProp("clipboardSerializer") || Jd.fromSchema(t.state.schema),
		a = Nq(),
		l = a.createElement("div");
	l.appendChild(s.serializeFragment(r, { document: a }));
	let u = l.firstChild,
		c,
		d = 0;
	for (; u && u.nodeType == 1 && (c = Pq[u.nodeName.toLowerCase()]); ) {
		for (let h = c.length - 1; h >= 0; h--) {
			let p = a.createElement(c[h]);
			for (; l.firstChild; ) p.appendChild(l.firstChild);
			l.appendChild(p), d++;
		}
		u = l.firstChild;
	}
	u &&
		u.nodeType == 1 &&
		u.setAttribute(
			"data-pm-slice",
			`${i} ${o}${d ? ` -${d}` : ""} ${JSON.stringify(n)}`,
		);
	let f =
		t.someProp("clipboardTextSerializer", (h) => h(e, t)) ||
		e.content.textBetween(
			0,
			e.content.size,
			`

`,
		);
	return { dom: l, text: f, slice: e };
}
function Tq(t, e, n, r, i) {
	let o = i.parent.type.spec.code,
		s,
		a;
	if (!n && !e) return null;
	let l = e && (r || o || !n);
	if (l) {
		if (
			(t.someProp("transformPastedText", (f) => {
				e = f(e, o || r, t);
			}),
			o)
		)
			return e
				? new Ee(
						be.from(
							t.state.schema.text(
								e.replace(
									/\r\n?/g,
									`
`,
								),
							),
						),
						0,
						0,
					)
				: Ee.empty;
		let d = t.someProp("clipboardTextParser", (f) => f(e, i, r, t));
		if (d) a = d;
		else {
			let f = i.marks(),
				{ schema: h } = t.state,
				p = Jd.fromSchema(h);
			(s = document.createElement("div")),
				e.split(/(?:\r\n?|\n)+/).forEach((g) => {
					let v = s.appendChild(document.createElement("p"));
					g && v.appendChild(p.serializeNode(h.text(g, f)));
				});
		}
	} else
		t.someProp("transformPastedHTML", (d) => {
			n = d(n, t);
		}),
			(s = ZCe(n)),
			U0 && QCe(s);
	let u = s && s.querySelector("[data-pm-slice]"),
		c =
			u &&
			/^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(
				u.getAttribute("data-pm-slice") || "",
			);
	if (c && c[3])
		for (let d = +c[3]; d > 0; d--) {
			let f = s.firstChild;
			for (; f && f.nodeType != 1; ) f = f.nextSibling;
			if (!f) break;
			s = f;
		}
	if (
		(a ||
			(a = (
				t.someProp("clipboardParser") ||
				t.someProp("domParser") ||
				jD.fromSchema(t.state.schema)
			).parseSlice(s, {
				preserveWhitespace: !!(l || c),
				context: i,
				ruleFromNode(f) {
					return f.nodeName == "BR" &&
						!f.nextSibling &&
						f.parentNode &&
						!YCe.test(f.parentNode.nodeName)
						? { ignore: !0 }
						: null;
				},
			})),
		c)
	)
		a = ewe(u7(a, +c[1], +c[2]), c[4]);
	else if (
		((a = Ee.maxOpen(JCe(a.content, i), !0)), a.openStart || a.openEnd)
	) {
		let d = 0,
			f = 0;
		for (
			let h = a.content.firstChild;
			d < a.openStart && !h.type.spec.isolating;
			d++, h = h.firstChild
		);
		for (
			let h = a.content.lastChild;
			f < a.openEnd && !h.type.spec.isolating;
			f++, h = h.lastChild
		);
		a = u7(a, d, f);
	}
	return (
		t.someProp("transformPasted", (d) => {
			a = d(a, t);
		}),
		a
	);
}
const YCe =
	/^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
function JCe(t, e) {
	if (t.childCount < 2) return t;
	for (let n = e.depth; n >= 0; n--) {
		let i = e.node(n).contentMatchAt(e.index(n)),
			o,
			s = [];
		if (
			(t.forEach((a) => {
				if (!s) return;
				let l = i.findWrapping(a.type),
					u;
				if (!l) return (s = null);
				if (
					(u =
						s.length && o.length && Iq(l, o, a, s[s.length - 1], 0))
				)
					s[s.length - 1] = u;
				else {
					s.length &&
						(s[s.length - 1] = Fq(s[s.length - 1], o.length));
					let c = Bq(a, l);
					s.push(c), (i = i.matchType(c.type)), (o = l);
				}
			}),
			s)
		)
			return be.from(s);
	}
	return t;
}
function Bq(t, e, n = 0) {
	for (let r = e.length - 1; r >= n; r--) t = e[r].create(null, be.from(t));
	return t;
}
function Iq(t, e, n, r, i) {
	if (i < t.length && i < e.length && t[i] == e[i]) {
		let o = Iq(t, e, n, r.lastChild, i + 1);
		if (o) return r.copy(r.content.replaceChild(r.childCount - 1, o));
		if (
			r
				.contentMatchAt(r.childCount)
				.matchType(i == t.length - 1 ? n.type : t[i + 1])
		)
			return r.copy(r.content.append(be.from(Bq(n, t, i + 1))));
	}
}
function Fq(t, e) {
	if (e == 0) return t;
	let n = t.content.replaceChild(t.childCount - 1, Fq(t.lastChild, e - 1)),
		r = t.contentMatchAt(t.childCount).fillBefore(be.empty, !0);
	return t.copy(n.append(r));
}
function Q2(t, e, n, r, i, o) {
	let s = e < 0 ? t.firstChild : t.lastChild,
		a = s.content;
	return (
		t.childCount > 1 && (o = 0),
		i < r - 1 && (a = Q2(a, e, n, r, i + 1, o)),
		i >= n &&
			(a =
				e < 0
					? s
							.contentMatchAt(0)
							.fillBefore(a, o <= i)
							.append(a)
					: a.append(
							s
								.contentMatchAt(s.childCount)
								.fillBefore(be.empty, !0),
						)),
		t.replaceChild(e < 0 ? 0 : t.childCount - 1, s.copy(a))
	);
}
function u7(t, e, n) {
	return (
		e < t.openStart &&
			(t = new Ee(
				Q2(t.content, -1, e, t.openStart, 0, t.openEnd),
				e,
				t.openEnd,
			)),
		n < t.openEnd &&
			(t = new Ee(Q2(t.content, 1, n, t.openEnd, 0, 0), t.openStart, n)),
		t
	);
}
const Pq = {
	thead: ["table"],
	tbody: ["table"],
	tfoot: ["table"],
	caption: ["table"],
	colgroup: ["table"],
	col: ["table", "colgroup"],
	tr: ["table", "tbody"],
	td: ["table", "tbody", "tr"],
	th: ["table", "tbody", "tr"],
};
let c7 = null;
function Nq() {
	return c7 || (c7 = document.implementation.createHTMLDocument("title"));
}
function XCe(t) {
	let e = window.trustedTypes;
	return e
		? e
				.createPolicy("detachedDocument", { createHTML: (n) => n })
				.createHTML(t)
		: t;
}
function ZCe(t) {
	let e = /^(\s*<meta [^>]*>)*/.exec(t);
	e && (t = t.slice(e[0].length));
	let n = Nq().createElement("div"),
		r = /<([a-z][^>\s]+)/i.exec(t),
		i;
	if (
		((i = r && Pq[r[1].toLowerCase()]) &&
			(t =
				i.map((o) => "<" + o + ">").join("") +
				t +
				i
					.map((o) => "</" + o + ">")
					.reverse()
					.join("")),
		(n.innerHTML = XCe(t)),
		i)
	)
		for (let o = 0; o < i.length; o++) n = n.querySelector(i[o]) || n;
	return n;
}
function QCe(t) {
	let e = t.querySelectorAll(
		Ur ? "span:not([class]):not([style])" : "span.Apple-converted-space",
	);
	for (let n = 0; n < e.length; n++) {
		let r = e[n];
		r.childNodes.length == 1 &&
			r.textContent == " " &&
			r.parentNode &&
			r.parentNode.replaceChild(t.ownerDocument.createTextNode(" "), r);
	}
}
function ewe(t, e) {
	if (!t.size) return t;
	let n = t.content.firstChild.type.schema,
		r;
	try {
		r = JSON.parse(e);
	} catch {
		return t;
	}
	let { content: i, openStart: o, openEnd: s } = t;
	for (let a = r.length - 2; a >= 0; a -= 2) {
		let l = n.nodes[r[a]];
		if (!l || l.hasRequiredAttrs()) break;
		(i = be.from(l.create(r[a + 1], i))), o++, s++;
	}
	return new Ee(i, o, s);
}
const bi = {},
	vi = {},
	twe = { touchstart: !0, touchmove: !0 };
class nwe {
	constructor() {
		(this.shiftKey = !1),
			(this.mouseDown = null),
			(this.lastKeyCode = null),
			(this.lastKeyCodeTime = 0),
			(this.lastClick = { time: 0, x: 0, y: 0, type: "" }),
			(this.lastSelectionOrigin = null),
			(this.lastSelectionTime = 0),
			(this.lastIOSEnter = 0),
			(this.lastIOSEnterFallbackTimeout = -1),
			(this.lastFocus = 0),
			(this.lastTouch = 0),
			(this.lastAndroidDelete = 0),
			(this.composing = !1),
			(this.compositionNode = null),
			(this.composingTimeout = -1),
			(this.compositionNodes = []),
			(this.compositionEndedAt = -2e8),
			(this.compositionID = 1),
			(this.compositionPendingChanges = 0),
			(this.domChangeCount = 0),
			(this.eventHandlers = Object.create(null)),
			(this.hideSelectionGuard = null);
	}
}
function rwe(t) {
	for (let e in bi) {
		let n = bi[e];
		t.dom.addEventListener(
			e,
			(t.input.eventHandlers[e] = (r) => {
				owe(t, r) &&
					!j5(t, r) &&
					(t.editable || !(r.type in vi)) &&
					n(t, r);
			}),
			twe[e] ? { passive: !0 } : void 0,
		);
	}
	gi && t.dom.addEventListener("input", () => null), eE(t);
}
function ku(t, e) {
	(t.input.lastSelectionOrigin = e), (t.input.lastSelectionTime = Date.now());
}
function iwe(t) {
	t.domObserver.stop();
	for (let e in t.input.eventHandlers)
		t.dom.removeEventListener(e, t.input.eventHandlers[e]);
	clearTimeout(t.input.composingTimeout),
		clearTimeout(t.input.lastIOSEnterFallbackTimeout);
}
function eE(t) {
	t.someProp("handleDOMEvents", (e) => {
		for (let n in e)
			t.input.eventHandlers[n] ||
				t.dom.addEventListener(
					n,
					(t.input.eventHandlers[n] = (r) => j5(t, r)),
				);
	});
}
function j5(t, e) {
	return t.someProp("handleDOMEvents", (n) => {
		let r = n[e.type];
		return r ? r(t, e) || e.defaultPrevented : !1;
	});
}
function owe(t, e) {
	if (!e.bubbles) return !0;
	if (e.defaultPrevented) return !1;
	for (let n = e.target; n != t.dom; n = n.parentNode)
		if (
			!n ||
			n.nodeType == 11 ||
			(n.pmViewDesc && n.pmViewDesc.stopEvent(e))
		)
			return !1;
	return !0;
}
function swe(t, e) {
	!j5(t, e) &&
		bi[e.type] &&
		(t.editable || !(e.type in vi)) &&
		bi[e.type](t, e);
}
vi.keydown = (t, e) => {
	let n = e;
	if (
		((t.input.shiftKey = n.keyCode == 16 || n.shiftKey),
		!Oq(t, n) &&
			((t.input.lastKeyCode = n.keyCode),
			(t.input.lastKeyCodeTime = Date.now()),
			!(ms && Ur && n.keyCode == 13)))
	)
		if (
			(t.domObserver.selectionChanged(t.domSelectionRange())
				? t.domObserver.flush()
				: n.keyCode != 229 && t.domObserver.forceFlush(),
			jh && n.keyCode == 13 && !n.ctrlKey && !n.altKey && !n.metaKey)
		) {
			let r = Date.now();
			(t.input.lastIOSEnter = r),
				(t.input.lastIOSEnterFallbackTimeout = setTimeout(() => {
					t.input.lastIOSEnter == r &&
						(t.someProp("handleKeyDown", (i) =>
							i(t, Sc(13, "Enter")),
						),
						(t.input.lastIOSEnter = 0));
				}, 200));
		} else
			t.someProp("handleKeyDown", (r) => r(t, n)) || GCe(t, n)
				? n.preventDefault()
				: ku(t, "key");
};
vi.keyup = (t, e) => {
	e.keyCode == 16 && (t.input.shiftKey = !1);
};
vi.keypress = (t, e) => {
	let n = e;
	if (
		Oq(t, n) ||
		!n.charCode ||
		(n.ctrlKey && !n.altKey) ||
		(Bo && n.metaKey)
	)
		return;
	if (t.someProp("handleKeyPress", (i) => i(t, n))) {
		n.preventDefault();
		return;
	}
	let r = t.state.selection;
	if (!(r instanceof kt) || !r.$from.sameParent(r.$to)) {
		let i = String.fromCharCode(n.charCode);
		!/[\r\n]/.test(i) &&
			!t.someProp("handleTextInput", (o) =>
				o(t, r.$from.pos, r.$to.pos, i),
			) &&
			t.dispatch(t.state.tr.insertText(i).scrollIntoView()),
			n.preventDefault();
	}
};
function F3(t) {
	return { left: t.clientX, top: t.clientY };
}
function awe(t, e) {
	let n = e.x - t.clientX,
		r = e.y - t.clientY;
	return n * n + r * r < 100;
}
function _5(t, e, n, r, i) {
	if (r == -1) return !1;
	let o = t.state.doc.resolve(r);
	for (let s = o.depth + 1; s > 0; s--)
		if (
			t.someProp(e, (a) =>
				s > o.depth
					? a(t, n, o.nodeAfter, o.before(s), i, !0)
					: a(t, n, o.node(s), o.before(s), i, !1),
			)
		)
			return !0;
	return !1;
}
function uh(t, e, n) {
	if ((t.focused || t.focus(), t.state.selection.eq(e))) return;
	let r = t.state.tr.setSelection(e);
	r.setMeta("pointer", !0), t.dispatch(r);
}
function lwe(t, e) {
	if (e == -1) return !1;
	let n = t.state.doc.resolve(e),
		r = n.nodeAfter;
	return r && r.isAtom && Qe.isSelectable(r) ? (uh(t, new Qe(n)), !0) : !1;
}
function uwe(t, e) {
	if (e == -1) return !1;
	let n = t.state.selection,
		r,
		i;
	n instanceof Qe && (r = n.node);
	let o = t.state.doc.resolve(e);
	for (let s = o.depth + 1; s > 0; s--) {
		let a = s > o.depth ? o.nodeAfter : o.node(s);
		if (Qe.isSelectable(a)) {
			r &&
			n.$from.depth > 0 &&
			s >= n.$from.depth &&
			o.before(n.$from.depth + 1) == n.$from.pos
				? (i = o.before(n.$from.depth))
				: (i = o.before(s));
			break;
		}
	}
	return i != null ? (uh(t, Qe.create(t.state.doc, i)), !0) : !1;
}
function cwe(t, e, n, r, i) {
	return (
		_5(t, "handleClickOn", e, n, r) ||
		t.someProp("handleClick", (o) => o(t, e, r)) ||
		(i ? uwe(t, n) : lwe(t, n))
	);
}
function dwe(t, e, n, r) {
	return (
		_5(t, "handleDoubleClickOn", e, n, r) ||
		t.someProp("handleDoubleClick", (i) => i(t, e, r))
	);
}
function fwe(t, e, n, r) {
	return (
		_5(t, "handleTripleClickOn", e, n, r) ||
		t.someProp("handleTripleClick", (i) => i(t, e, r)) ||
		hwe(t, n, r)
	);
}
function hwe(t, e, n) {
	if (n.button != 0) return !1;
	let r = t.state.doc;
	if (e == -1)
		return r.inlineContent
			? (uh(t, kt.create(r, 0, r.content.size)), !0)
			: !1;
	let i = r.resolve(e);
	for (let o = i.depth + 1; o > 0; o--) {
		let s = o > i.depth ? i.nodeAfter : i.node(o),
			a = i.before(o);
		if (s.inlineContent) uh(t, kt.create(r, a + 1, a + 1 + s.content.size));
		else if (Qe.isSelectable(s)) uh(t, Qe.create(r, a));
		else continue;
		return !0;
	}
}
function z5(t) {
	return wy(t);
}
const Rq = Bo ? "metaKey" : "ctrlKey";
bi.mousedown = (t, e) => {
	let n = e;
	t.input.shiftKey = n.shiftKey;
	let r = z5(t),
		i = Date.now(),
		o = "singleClick";
	i - t.input.lastClick.time < 500 &&
		awe(n, t.input.lastClick) &&
		!n[Rq] &&
		(t.input.lastClick.type == "singleClick"
			? (o = "doubleClick")
			: t.input.lastClick.type == "doubleClick" && (o = "tripleClick")),
		(t.input.lastClick = { time: i, x: n.clientX, y: n.clientY, type: o });
	let s = t.posAtCoords(F3(n));
	s &&
		(o == "singleClick"
			? (t.input.mouseDown && t.input.mouseDown.done(),
				(t.input.mouseDown = new pwe(t, s, n, !!r)))
			: (o == "doubleClick" ? dwe : fwe)(t, s.pos, s.inside, n)
				? n.preventDefault()
				: ku(t, "pointer"));
};
class pwe {
	constructor(e, n, r, i) {
		(this.view = e),
			(this.pos = n),
			(this.event = r),
			(this.flushed = i),
			(this.delayedSelectionSync = !1),
			(this.mightDrag = null),
			(this.startDoc = e.state.doc),
			(this.selectNode = !!r[Rq]),
			(this.allowDefault = r.shiftKey);
		let o, s;
		if (n.inside > -1) (o = e.state.doc.nodeAt(n.inside)), (s = n.inside);
		else {
			let c = e.state.doc.resolve(n.pos);
			(o = c.parent), (s = c.depth ? c.before() : 0);
		}
		const a = i ? null : r.target,
			l = a ? e.docView.nearestDesc(a, !0) : null;
		this.target = l && l.dom.nodeType == 1 ? l.dom : null;
		let { selection: u } = e.state;
		((r.button == 0 &&
			o.type.spec.draggable &&
			o.type.spec.selectable !== !1) ||
			(u instanceof Qe && u.from <= s && u.to > s)) &&
			(this.mightDrag = {
				node: o,
				pos: s,
				addAttr: !!(this.target && !this.target.draggable),
				setUneditable: !!(
					this.target &&
					Ps &&
					!this.target.hasAttribute("contentEditable")
				),
			}),
			this.target &&
				this.mightDrag &&
				(this.mightDrag.addAttr || this.mightDrag.setUneditable) &&
				(this.view.domObserver.stop(),
				this.mightDrag.addAttr && (this.target.draggable = !0),
				this.mightDrag.setUneditable &&
					setTimeout(() => {
						this.view.input.mouseDown == this &&
							this.target.setAttribute(
								"contentEditable",
								"false",
							);
					}, 20),
				this.view.domObserver.start()),
			e.root.addEventListener("mouseup", (this.up = this.up.bind(this))),
			e.root.addEventListener(
				"mousemove",
				(this.move = this.move.bind(this)),
			),
			ku(e, "pointer");
	}
	done() {
		this.view.root.removeEventListener("mouseup", this.up),
			this.view.root.removeEventListener("mousemove", this.move),
			this.mightDrag &&
				this.target &&
				(this.view.domObserver.stop(),
				this.mightDrag.addAttr &&
					this.target.removeAttribute("draggable"),
				this.mightDrag.setUneditable &&
					this.target.removeAttribute("contentEditable"),
				this.view.domObserver.start()),
			this.delayedSelectionSync && setTimeout(() => ul(this.view)),
			(this.view.input.mouseDown = null);
	}
	up(e) {
		if ((this.done(), !this.view.dom.contains(e.target))) return;
		let n = this.pos;
		this.view.state.doc != this.startDoc &&
			(n = this.view.posAtCoords(F3(e))),
			this.updateAllowDefault(e),
			this.allowDefault || !n
				? ku(this.view, "pointer")
				: cwe(this.view, n.pos, n.inside, e, this.selectNode)
					? e.preventDefault()
					: e.button == 0 &&
						  (this.flushed ||
								(gi &&
									this.mightDrag &&
									!this.mightDrag.node.isAtom) ||
								(Ur &&
									!this.view.state.selection.visible &&
									Math.min(
										Math.abs(
											n.pos -
												this.view.state.selection.from,
										),
										Math.abs(
											n.pos -
												this.view.state.selection.to,
										),
									) <= 2))
						? (uh(
								this.view,
								mt.near(this.view.state.doc.resolve(n.pos)),
							),
							e.preventDefault())
						: ku(this.view, "pointer");
	}
	move(e) {
		this.updateAllowDefault(e),
			ku(this.view, "pointer"),
			e.buttons == 0 && this.done();
	}
	updateAllowDefault(e) {
		!this.allowDefault &&
			(Math.abs(this.event.x - e.clientX) > 4 ||
				Math.abs(this.event.y - e.clientY) > 4) &&
			(this.allowDefault = !0);
	}
}
bi.touchstart = (t) => {
	(t.input.lastTouch = Date.now()), z5(t), ku(t, "pointer");
};
bi.touchmove = (t) => {
	(t.input.lastTouch = Date.now()), ku(t, "pointer");
};
bi.contextmenu = (t) => z5(t);
function Oq(t, e) {
	return t.composing
		? !0
		: gi && Math.abs(e.timeStamp - t.input.compositionEndedAt) < 500
			? ((t.input.compositionEndedAt = -2e8), !0)
			: !1;
}
const mwe = ms ? 5e3 : -1;
vi.compositionstart = vi.compositionupdate = (t) => {
	if (!t.composing) {
		t.domObserver.flush();
		let { state: e } = t,
			n = e.selection.$to;
		if (
			e.selection instanceof kt &&
			(e.storedMarks ||
				(!n.textOffset &&
					n.parentOffset &&
					n.nodeBefore.marks.some(
						(r) => r.type.spec.inclusive === !1,
					)))
		)
			(t.markCursor = t.state.storedMarks || n.marks()),
				wy(t, !0),
				(t.markCursor = null);
		else if (
			(wy(t, !e.selection.empty),
			Ps &&
				e.selection.empty &&
				n.parentOffset &&
				!n.textOffset &&
				n.nodeBefore.marks.length)
		) {
			let r = t.domSelectionRange();
			for (
				let i = r.focusNode, o = r.focusOffset;
				i && i.nodeType == 1 && o != 0;

			) {
				let s = o < 0 ? i.lastChild : i.childNodes[o - 1];
				if (!s) break;
				if (s.nodeType == 3) {
					let a = t.domSelection();
					a && a.collapse(s, s.nodeValue.length);
					break;
				} else (i = s), (o = -1);
			}
		}
		t.input.composing = !0;
	}
	Mq(t, mwe);
};
vi.compositionend = (t, e) => {
	t.composing &&
		((t.input.composing = !1),
		(t.input.compositionEndedAt = e.timeStamp),
		(t.input.compositionPendingChanges = t.domObserver.pendingRecords()
			.length
			? t.input.compositionID
			: 0),
		(t.input.compositionNode = null),
		t.input.compositionPendingChanges &&
			Promise.resolve().then(() => t.domObserver.flush()),
		t.input.compositionID++,
		Mq(t, 20));
};
function Mq(t, e) {
	clearTimeout(t.input.composingTimeout),
		e > -1 && (t.input.composingTimeout = setTimeout(() => wy(t), e));
}
function jq(t) {
	for (
		t.composing &&
		((t.input.composing = !1), (t.input.compositionEndedAt = bwe()));
		t.input.compositionNodes.length > 0;

	)
		t.input.compositionNodes.pop().markParentsDirty();
}
function gwe(t) {
	let e = t.domSelectionRange();
	if (!e.focusNode) return null;
	let n = lCe(e.focusNode, e.focusOffset),
		r = uCe(e.focusNode, e.focusOffset);
	if (n && r && n != r) {
		let i = r.pmViewDesc,
			o = t.domObserver.lastChangedTextNode;
		if (n == o || r == o) return o;
		if (!i || !i.isText(r.nodeValue)) return r;
		if (t.input.compositionNode == r) {
			let s = n.pmViewDesc;
			if (!(!s || !s.isText(n.nodeValue))) return r;
		}
	}
	return n || r;
}
function bwe() {
	let t = document.createEvent("Event");
	return t.initEvent("event", !0, !0), t.timeStamp;
}
function wy(t, e = !1) {
	if (!(ms && t.domObserver.flushingSoon >= 0)) {
		if (
			(t.domObserver.forceFlush(),
			jq(t),
			e || (t.docView && t.docView.dirty))
		) {
			let n = O5(t);
			return (
				n && !n.eq(t.state.selection)
					? t.dispatch(t.state.tr.setSelection(n))
					: (t.markCursor || e) && !t.state.selection.empty
						? t.dispatch(t.state.tr.deleteSelection())
						: t.updateState(t.state),
				!0
			);
		}
		return !1;
	}
}
function vwe(t, e) {
	if (!t.dom.parentNode) return;
	let n = t.dom.parentNode.appendChild(document.createElement("div"));
	n.appendChild(e),
		(n.style.cssText = "position: fixed; left: -10000px; top: 10px");
	let r = getSelection(),
		i = document.createRange();
	i.selectNodeContents(e),
		t.dom.blur(),
		r.removeAllRanges(),
		r.addRange(i),
		setTimeout(() => {
			n.parentNode && n.parentNode.removeChild(n), t.focus();
		}, 50);
}
const Ig = (_i && Bu < 15) || (jh && pCe < 604);
bi.copy = vi.cut = (t, e) => {
	let n = e,
		r = t.state.selection,
		i = n.type == "cut";
	if (r.empty) return;
	let o = Ig ? null : n.clipboardData,
		s = r.content(),
		{ dom: a, text: l } = $q(t, s);
	o
		? (n.preventDefault(),
			o.clearData(),
			o.setData("text/html", a.innerHTML),
			o.setData("text/plain", l))
		: vwe(t, a),
		i &&
			t.dispatch(
				t.state.tr
					.deleteSelection()
					.scrollIntoView()
					.setMeta("uiEvent", "cut"),
			);
};
function ywe(t) {
	return t.openStart == 0 && t.openEnd == 0 && t.content.childCount == 1
		? t.content.firstChild
		: null;
}
function xwe(t, e) {
	if (!t.dom.parentNode) return;
	let n = t.input.shiftKey || t.state.selection.$from.parent.type.spec.code,
		r = t.dom.parentNode.appendChild(
			document.createElement(n ? "textarea" : "div"),
		);
	n || (r.contentEditable = "true"),
		(r.style.cssText = "position: fixed; left: -10000px; top: 10px"),
		r.focus();
	let i = t.input.shiftKey && t.input.lastKeyCode != 45;
	setTimeout(() => {
		t.focus(),
			r.parentNode && r.parentNode.removeChild(r),
			n
				? Fg(t, r.value, null, i, e)
				: Fg(t, r.textContent, r.innerHTML, i, e);
	}, 50);
}
function Fg(t, e, n, r, i) {
	let o = Tq(t, e, n, r, t.state.selection.$from);
	if (t.someProp("handlePaste", (l) => l(t, i, o || Ee.empty))) return !0;
	if (!o) return !1;
	let s = ywe(o),
		a = s
			? t.state.tr.replaceSelectionWith(s, r)
			: t.state.tr.replaceSelection(o);
	return (
		t.dispatch(
			a.scrollIntoView().setMeta("paste", !0).setMeta("uiEvent", "paste"),
		),
		!0
	);
}
function _q(t) {
	let e = t.getData("text/plain") || t.getData("Text");
	if (e) return e;
	let n = t.getData("text/uri-list");
	return n ? n.replace(/\r?\n/g, " ") : "";
}
vi.paste = (t, e) => {
	let n = e;
	if (t.composing && !ms) return;
	let r = Ig ? null : n.clipboardData,
		i = t.input.shiftKey && t.input.lastKeyCode != 45;
	r && Fg(t, _q(r), r.getData("text/html"), i, n)
		? n.preventDefault()
		: xwe(t, n);
};
class zq {
	constructor(e, n, r) {
		(this.slice = e), (this.move = n), (this.node = r);
	}
}
const Lq = Bo ? "altKey" : "ctrlKey";
bi.dragstart = (t, e) => {
	let n = e,
		r = t.input.mouseDown;
	if ((r && r.done(), !n.dataTransfer)) return;
	let i = t.state.selection,
		o = i.empty ? null : t.posAtCoords(F3(n)),
		s;
	if (
		!(o && o.pos >= i.from && o.pos <= (i instanceof Qe ? i.to - 1 : i.to))
	) {
		if (r && r.mightDrag) s = Qe.create(t.state.doc, r.mightDrag.pos);
		else if (n.target && n.target.nodeType == 1) {
			let d = t.docView.nearestDesc(n.target, !0);
			d &&
				d.node.type.spec.draggable &&
				d != t.docView &&
				(s = Qe.create(t.state.doc, d.posBefore));
		}
	}
	let a = (s || t.state.selection).content(),
		{ dom: l, text: u, slice: c } = $q(t, a);
	(!n.dataTransfer.files.length || !Ur || fq > 120) &&
		n.dataTransfer.clearData(),
		n.dataTransfer.setData(Ig ? "Text" : "text/html", l.innerHTML),
		(n.dataTransfer.effectAllowed = "copyMove"),
		Ig || n.dataTransfer.setData("text/plain", u),
		(t.dragging = new zq(c, !n[Lq], s));
};
bi.dragend = (t) => {
	let e = t.dragging;
	window.setTimeout(() => {
		t.dragging == e && (t.dragging = null);
	}, 50);
};
vi.dragover = vi.dragenter = (t, e) => e.preventDefault();
vi.drop = (t, e) => {
	let n = e,
		r = t.dragging;
	if (((t.dragging = null), !n.dataTransfer)) return;
	let i = t.posAtCoords(F3(n));
	if (!i) return;
	let o = t.state.doc.resolve(i.pos),
		s = r && r.slice;
	s
		? t.someProp("transformPasted", (p) => {
				s = p(s, t);
			})
		: (s = Tq(
				t,
				_q(n.dataTransfer),
				Ig ? null : n.dataTransfer.getData("text/html"),
				!1,
				o,
			));
	let a = !!(r && !n[Lq]);
	if (t.someProp("handleDrop", (p) => p(t, n, s || Ee.empty, a))) {
		n.preventDefault();
		return;
	}
	if (!s) return;
	n.preventDefault();
	let l = s ? Iv(t.state.doc, o.pos, s) : o.pos;
	l == null && (l = o.pos);
	let u = t.state.tr;
	if (a) {
		let { node: p } = r;
		p ? p.replace(u) : u.deleteSelection();
	}
	let c = u.mapping.map(l),
		d = s.openStart == 0 && s.openEnd == 0 && s.content.childCount == 1,
		f = u.doc;
	if (
		(d
			? u.replaceRangeWith(c, c, s.content.firstChild)
			: u.replaceRange(c, c, s),
		u.doc.eq(f))
	)
		return;
	let h = u.doc.resolve(c);
	if (
		d &&
		Qe.isSelectable(s.content.firstChild) &&
		h.nodeAfter &&
		h.nodeAfter.sameMarkup(s.content.firstChild)
	)
		u.setSelection(new Qe(h));
	else {
		let p = u.mapping.map(l);
		u.mapping.maps[u.mapping.maps.length - 1].forEach(
			(g, v, b, y) => (p = y),
		),
			u.setSelection(M5(t, h, u.doc.resolve(p)));
	}
	t.focus(), t.dispatch(u.setMeta("uiEvent", "drop"));
};
bi.focus = (t) => {
	(t.input.lastFocus = Date.now()),
		t.focused ||
			(t.domObserver.stop(),
			t.dom.classList.add("ProseMirror-focused"),
			t.domObserver.start(),
			(t.focused = !0),
			setTimeout(() => {
				t.docView &&
					t.hasFocus() &&
					!t.domObserver.currentSelection.eq(t.domSelectionRange()) &&
					ul(t);
			}, 20));
};
bi.blur = (t, e) => {
	let n = e;
	t.focused &&
		(t.domObserver.stop(),
		t.dom.classList.remove("ProseMirror-focused"),
		t.domObserver.start(),
		n.relatedTarget &&
			t.dom.contains(n.relatedTarget) &&
			t.domObserver.currentSelection.clear(),
		(t.focused = !1));
};
bi.beforeinput = (t, e) => {
	if (Ur && ms && e.inputType == "deleteContentBackward") {
		t.domObserver.flushSoon();
		let { domChangeCount: r } = t.input;
		setTimeout(() => {
			if (
				t.input.domChangeCount != r ||
				(t.dom.blur(),
				t.focus(),
				t.someProp("handleKeyDown", (o) => o(t, Sc(8, "Backspace"))))
			)
				return;
			let { $cursor: i } = t.state.selection;
			i &&
				i.pos > 0 &&
				t.dispatch(
					t.state.tr.delete(i.pos - 1, i.pos).scrollIntoView(),
				);
		}, 50);
	}
};
for (let t in vi) bi[t] = vi[t];
function Pg(t, e) {
	if (t == e) return !0;
	for (let n in t) if (t[n] !== e[n]) return !1;
	for (let n in e) if (!(n in t)) return !1;
	return !0;
}
class Ey {
	constructor(e, n) {
		(this.toDOM = e),
			(this.spec = n || od),
			(this.side = this.spec.side || 0);
	}
	map(e, n, r, i) {
		let { pos: o, deleted: s } = e.mapResult(
			n.from + i,
			this.side < 0 ? -1 : 1,
		);
		return s ? null : new Hn(o - r, o - r, this);
	}
	valid() {
		return !0;
	}
	eq(e) {
		return (
			this == e ||
			(e instanceof Ey &&
				((this.spec.key && this.spec.key == e.spec.key) ||
					(this.toDOM == e.toDOM && Pg(this.spec, e.spec))))
		);
	}
	destroy(e) {
		this.spec.destroy && this.spec.destroy(e);
	}
}
class Fu {
	constructor(e, n) {
		(this.attrs = e), (this.spec = n || od);
	}
	map(e, n, r, i) {
		let o = e.map(n.from + i, this.spec.inclusiveStart ? -1 : 1) - r,
			s = e.map(n.to + i, this.spec.inclusiveEnd ? 1 : -1) - r;
		return o >= s ? null : new Hn(o, s, this);
	}
	valid(e, n) {
		return n.from < n.to;
	}
	eq(e) {
		return (
			this == e ||
			(e instanceof Fu &&
				Pg(this.attrs, e.attrs) &&
				Pg(this.spec, e.spec))
		);
	}
	static is(e) {
		return e.type instanceof Fu;
	}
	destroy() {}
}
class L5 {
	constructor(e, n) {
		(this.attrs = e), (this.spec = n || od);
	}
	map(e, n, r, i) {
		let o = e.mapResult(n.from + i, 1);
		if (o.deleted) return null;
		let s = e.mapResult(n.to + i, -1);
		return s.deleted || s.pos <= o.pos
			? null
			: new Hn(o.pos - r, s.pos - r, this);
	}
	valid(e, n) {
		let { index: r, offset: i } = e.content.findIndex(n.from),
			o;
		return (
			i == n.from && !(o = e.child(r)).isText && i + o.nodeSize == n.to
		);
	}
	eq(e) {
		return (
			this == e ||
			(e instanceof L5 &&
				Pg(this.attrs, e.attrs) &&
				Pg(this.spec, e.spec))
		);
	}
	destroy() {}
}
class Hn {
	constructor(e, n, r) {
		(this.from = e), (this.to = n), (this.type = r);
	}
	copy(e, n) {
		return new Hn(e, n, this.type);
	}
	eq(e, n = 0) {
		return (
			this.type.eq(e.type) &&
			this.from + n == e.from &&
			this.to + n == e.to
		);
	}
	map(e, n, r) {
		return this.type.map(e, this, n, r);
	}
	static widget(e, n, r) {
		return new Hn(e, e, new Ey(n, r));
	}
	static inline(e, n, r, i) {
		return new Hn(e, n, new Fu(r, i));
	}
	static node(e, n, r, i) {
		return new Hn(e, n, new L5(r, i));
	}
	get spec() {
		return this.type.spec;
	}
	get inline() {
		return this.type instanceof Fu;
	}
	get widget() {
		return this.type instanceof Ey;
	}
}
const If = [],
	od = {};
class qt {
	constructor(e, n) {
		(this.local = e.length ? e : If), (this.children = n.length ? n : If);
	}
	static create(e, n) {
		return n.length ? Dy(n, e, 0, od) : jr;
	}
	find(e, n, r) {
		let i = [];
		return this.findInner(e ?? 0, n ?? 1e9, i, 0, r), i;
	}
	findInner(e, n, r, i, o) {
		for (let s = 0; s < this.local.length; s++) {
			let a = this.local[s];
			a.from <= n &&
				a.to >= e &&
				(!o || o(a.spec)) &&
				r.push(a.copy(a.from + i, a.to + i));
		}
		for (let s = 0; s < this.children.length; s += 3)
			if (this.children[s] < n && this.children[s + 1] > e) {
				let a = this.children[s] + 1;
				this.children[s + 2].findInner(e - a, n - a, r, i + a, o);
			}
	}
	map(e, n, r) {
		return this == jr || e.maps.length == 0
			? this
			: this.mapInner(e, n, 0, 0, r || od);
	}
	mapInner(e, n, r, i, o) {
		let s;
		for (let a = 0; a < this.local.length; a++) {
			let l = this.local[a].map(e, r, i);
			l && l.type.valid(n, l)
				? (s || (s = [])).push(l)
				: o.onRemove && o.onRemove(this.local[a].spec);
		}
		return this.children.length
			? kwe(this.children, s || [], e, n, r, i, o)
			: s
				? new qt(s.sort(sd), If)
				: jr;
	}
	add(e, n) {
		return n.length
			? this == jr
				? qt.create(e, n)
				: this.addInner(e, n, 0)
			: this;
	}
	addInner(e, n, r) {
		let i,
			o = 0;
		e.forEach((a, l) => {
			let u = l + r,
				c;
			if ((c = Kq(n, a, u))) {
				for (
					i || (i = this.children.slice());
					o < i.length && i[o] < l;

				)
					o += 3;
				i[o] == l
					? (i[o + 2] = i[o + 2].addInner(a, c, u + 1))
					: i.splice(o, 0, l, l + a.nodeSize, Dy(c, a, u + 1, od)),
					(o += 3);
			}
		});
		let s = Vq(o ? Uq(n) : n, -r);
		for (let a = 0; a < s.length; a++)
			s[a].type.valid(e, s[a]) || s.splice(a--, 1);
		return new qt(
			s.length ? this.local.concat(s).sort(sd) : this.local,
			i || this.children,
		);
	}
	remove(e) {
		return e.length == 0 || this == jr ? this : this.removeInner(e, 0);
	}
	removeInner(e, n) {
		let r = this.children,
			i = this.local;
		for (let o = 0; o < r.length; o += 3) {
			let s,
				a = r[o] + n,
				l = r[o + 1] + n;
			for (let c = 0, d; c < e.length; c++)
				(d = e[c]) &&
					d.from > a &&
					d.to < l &&
					((e[c] = null), (s || (s = [])).push(d));
			if (!s) continue;
			r == this.children && (r = this.children.slice());
			let u = r[o + 2].removeInner(s, a + 1);
			u != jr ? (r[o + 2] = u) : (r.splice(o, 3), (o -= 3));
		}
		if (i.length) {
			for (let o = 0, s; o < e.length; o++)
				if ((s = e[o]))
					for (let a = 0; a < i.length; a++)
						i[a].eq(s, n) &&
							(i == this.local && (i = this.local.slice()),
							i.splice(a--, 1));
		}
		return r == this.children && i == this.local
			? this
			: i.length || r.length
				? new qt(i, r)
				: jr;
	}
	forChild(e, n) {
		if (this == jr) return this;
		if (n.isLeaf) return qt.empty;
		let r, i;
		for (let a = 0; a < this.children.length; a += 3)
			if (this.children[a] >= e) {
				this.children[a] == e && (r = this.children[a + 2]);
				break;
			}
		let o = e + 1,
			s = o + n.content.size;
		for (let a = 0; a < this.local.length; a++) {
			let l = this.local[a];
			if (l.from < s && l.to > o && l.type instanceof Fu) {
				let u = Math.max(o, l.from) - o,
					c = Math.min(s, l.to) - o;
				u < c && (i || (i = [])).push(l.copy(u, c));
			}
		}
		if (i) {
			let a = new qt(i.sort(sd), If);
			return r ? new au([a, r]) : a;
		}
		return r || jr;
	}
	eq(e) {
		if (this == e) return !0;
		if (
			!(e instanceof qt) ||
			this.local.length != e.local.length ||
			this.children.length != e.children.length
		)
			return !1;
		for (let n = 0; n < this.local.length; n++)
			if (!this.local[n].eq(e.local[n])) return !1;
		for (let n = 0; n < this.children.length; n += 3)
			if (
				this.children[n] != e.children[n] ||
				this.children[n + 1] != e.children[n + 1] ||
				!this.children[n + 2].eq(e.children[n + 2])
			)
				return !1;
		return !0;
	}
	locals(e) {
		return V5(this.localsInner(e));
	}
	localsInner(e) {
		if (this == jr) return If;
		if (e.inlineContent || !this.local.some(Fu.is)) return this.local;
		let n = [];
		for (let r = 0; r < this.local.length; r++)
			this.local[r].type instanceof Fu || n.push(this.local[r]);
		return n;
	}
	forEachSet(e) {
		e(this);
	}
}
qt.empty = new qt([], []);
qt.removeOverlap = V5;
const jr = qt.empty;
class au {
	constructor(e) {
		this.members = e;
	}
	map(e, n) {
		const r = this.members.map((i) => i.map(e, n, od));
		return au.from(r);
	}
	forChild(e, n) {
		if (n.isLeaf) return qt.empty;
		let r = [];
		for (let i = 0; i < this.members.length; i++) {
			let o = this.members[i].forChild(e, n);
			o != jr &&
				(o instanceof au ? (r = r.concat(o.members)) : r.push(o));
		}
		return au.from(r);
	}
	eq(e) {
		if (!(e instanceof au) || e.members.length != this.members.length)
			return !1;
		for (let n = 0; n < this.members.length; n++)
			if (!this.members[n].eq(e.members[n])) return !1;
		return !0;
	}
	locals(e) {
		let n,
			r = !0;
		for (let i = 0; i < this.members.length; i++) {
			let o = this.members[i].localsInner(e);
			if (o.length)
				if (!n) n = o;
				else {
					r && ((n = n.slice()), (r = !1));
					for (let s = 0; s < o.length; s++) n.push(o[s]);
				}
		}
		return n ? V5(r ? n : n.sort(sd)) : If;
	}
	static from(e) {
		switch (e.length) {
			case 0:
				return jr;
			case 1:
				return e[0];
			default:
				return new au(
					e.every((n) => n instanceof qt)
						? e
						: e.reduce(
								(n, r) =>
									n.concat(r instanceof qt ? r : r.members),
								[],
							),
				);
		}
	}
	forEachSet(e) {
		for (let n = 0; n < this.members.length; n++)
			this.members[n].forEachSet(e);
	}
}
function kwe(t, e, n, r, i, o, s) {
	let a = t.slice();
	for (let u = 0, c = o; u < n.maps.length; u++) {
		let d = 0;
		n.maps[u].forEach((f, h, p, g) => {
			let v = g - p - (h - f);
			for (let b = 0; b < a.length; b += 3) {
				let y = a[b + 1];
				if (y < 0 || f > y + c - d) continue;
				let x = a[b] + c - d;
				h >= x
					? (a[b + 1] = f <= x ? -2 : -1)
					: f >= c && v && ((a[b] += v), (a[b + 1] += v));
			}
			d += v;
		}),
			(c = n.maps[u].map(c, -1));
	}
	let l = !1;
	for (let u = 0; u < a.length; u += 3)
		if (a[u + 1] < 0) {
			if (a[u + 1] == -2) {
				(l = !0), (a[u + 1] = -1);
				continue;
			}
			let c = n.map(t[u] + o),
				d = c - i;
			if (d < 0 || d >= r.content.size) {
				l = !0;
				continue;
			}
			let f = n.map(t[u + 1] + o, -1),
				h = f - i,
				{ index: p, offset: g } = r.content.findIndex(d),
				v = r.maybeChild(p);
			if (v && g == d && g + v.nodeSize == h) {
				let b = a[u + 2].mapInner(n, v, c + 1, t[u] + o + 1, s);
				b != jr
					? ((a[u] = d), (a[u + 1] = h), (a[u + 2] = b))
					: ((a[u + 1] = -2), (l = !0));
			} else l = !0;
		}
	if (l) {
		let u = Cwe(a, t, e, n, i, o, s),
			c = Dy(u, r, 0, s);
		e = c.local;
		for (let d = 0; d < a.length; d += 3)
			a[d + 1] < 0 && (a.splice(d, 3), (d -= 3));
		for (let d = 0, f = 0; d < c.children.length; d += 3) {
			let h = c.children[d];
			for (; f < a.length && a[f] < h; ) f += 3;
			a.splice(f, 0, c.children[d], c.children[d + 1], c.children[d + 2]);
		}
	}
	return new qt(e.sort(sd), a);
}
function Vq(t, e) {
	if (!e || !t.length) return t;
	let n = [];
	for (let r = 0; r < t.length; r++) {
		let i = t[r];
		n.push(new Hn(i.from + e, i.to + e, i.type));
	}
	return n;
}
function Cwe(t, e, n, r, i, o, s) {
	function a(l, u) {
		for (let c = 0; c < l.local.length; c++) {
			let d = l.local[c].map(r, i, u);
			d ? n.push(d) : s.onRemove && s.onRemove(l.local[c].spec);
		}
		for (let c = 0; c < l.children.length; c += 3)
			a(l.children[c + 2], l.children[c] + u + 1);
	}
	for (let l = 0; l < t.length; l += 3)
		t[l + 1] == -1 && a(t[l + 2], e[l] + o + 1);
	return n;
}
function Kq(t, e, n) {
	if (e.isLeaf) return null;
	let r = n + e.nodeSize,
		i = null;
	for (let o = 0, s; o < t.length; o++)
		(s = t[o]) &&
			s.from > n &&
			s.to < r &&
			((i || (i = [])).push(s), (t[o] = null));
	return i;
}
function Uq(t) {
	let e = [];
	for (let n = 0; n < t.length; n++) t[n] != null && e.push(t[n]);
	return e;
}
function Dy(t, e, n, r) {
	let i = [],
		o = !1;
	e.forEach((a, l) => {
		let u = Kq(t, a, l + n);
		if (u) {
			o = !0;
			let c = Dy(u, a, n + l + 1, r);
			c != jr && i.push(l, l + a.nodeSize, c);
		}
	});
	let s = Vq(o ? Uq(t) : t, -n).sort(sd);
	for (let a = 0; a < s.length; a++)
		s[a].type.valid(e, s[a]) ||
			(r.onRemove && r.onRemove(s[a].spec), s.splice(a--, 1));
	return s.length || i.length ? new qt(s, i) : jr;
}
function sd(t, e) {
	return t.from - e.from || t.to - e.to;
}
function V5(t) {
	let e = t;
	for (let n = 0; n < e.length - 1; n++) {
		let r = e[n];
		if (r.from != r.to)
			for (let i = n + 1; i < e.length; i++) {
				let o = e[i];
				if (o.from == r.from) {
					o.to != r.to &&
						(e == t && (e = t.slice()),
						(e[i] = o.copy(o.from, r.to)),
						d7(e, i + 1, o.copy(r.to, o.to)));
					continue;
				} else {
					o.from < r.to &&
						(e == t && (e = t.slice()),
						(e[n] = r.copy(r.from, o.from)),
						d7(e, i, r.copy(o.from, r.to)));
					break;
				}
			}
	}
	return e;
}
function d7(t, e, n) {
	for (; e < t.length && sd(n, t[e]) > 0; ) e++;
	t.splice(e, 0, n);
}
function iC(t) {
	let e = [];
	return (
		t.someProp("decorations", (n) => {
			let r = n(t.state);
			r && r != jr && e.push(r);
		}),
		t.cursorWrapper &&
			e.push(qt.create(t.state.doc, [t.cursorWrapper.deco])),
		au.from(e)
	);
}
const wwe = {
		childList: !0,
		characterData: !0,
		characterDataOldValue: !0,
		attributes: !0,
		attributeOldValue: !0,
		subtree: !0,
	},
	Ewe = _i && Bu <= 11;
class Dwe {
	constructor() {
		(this.anchorNode = null),
			(this.anchorOffset = 0),
			(this.focusNode = null),
			(this.focusOffset = 0);
	}
	set(e) {
		(this.anchorNode = e.anchorNode),
			(this.anchorOffset = e.anchorOffset),
			(this.focusNode = e.focusNode),
			(this.focusOffset = e.focusOffset);
	}
	clear() {
		this.anchorNode = this.focusNode = null;
	}
	eq(e) {
		return (
			e.anchorNode == this.anchorNode &&
			e.anchorOffset == this.anchorOffset &&
			e.focusNode == this.focusNode &&
			e.focusOffset == this.focusOffset
		);
	}
}
class Swe {
	constructor(e, n) {
		(this.view = e),
			(this.handleDOMChange = n),
			(this.queue = []),
			(this.flushingSoon = -1),
			(this.observer = null),
			(this.currentSelection = new Dwe()),
			(this.onCharData = null),
			(this.suppressingSelectionUpdates = !1),
			(this.lastChangedTextNode = null),
			(this.observer =
				window.MutationObserver &&
				new window.MutationObserver((r) => {
					for (let i = 0; i < r.length; i++) this.queue.push(r[i]);
					_i &&
					Bu <= 11 &&
					r.some(
						(i) =>
							(i.type == "childList" && i.removedNodes.length) ||
							(i.type == "characterData" &&
								i.oldValue.length > i.target.nodeValue.length),
					)
						? this.flushSoon()
						: this.flush();
				})),
			Ewe &&
				(this.onCharData = (r) => {
					this.queue.push({
						target: r.target,
						type: "characterData",
						oldValue: r.prevValue,
					}),
						this.flushSoon();
				}),
			(this.onSelectionChange = this.onSelectionChange.bind(this));
	}
	flushSoon() {
		this.flushingSoon < 0 &&
			(this.flushingSoon = window.setTimeout(() => {
				(this.flushingSoon = -1), this.flush();
			}, 20));
	}
	forceFlush() {
		this.flushingSoon > -1 &&
			(window.clearTimeout(this.flushingSoon),
			(this.flushingSoon = -1),
			this.flush());
	}
	start() {
		this.observer &&
			(this.observer.takeRecords(),
			this.observer.observe(this.view.dom, wwe)),
			this.onCharData &&
				this.view.dom.addEventListener(
					"DOMCharacterDataModified",
					this.onCharData,
				),
			this.connectSelection();
	}
	stop() {
		if (this.observer) {
			let e = this.observer.takeRecords();
			if (e.length) {
				for (let n = 0; n < e.length; n++) this.queue.push(e[n]);
				window.setTimeout(() => this.flush(), 20);
			}
			this.observer.disconnect();
		}
		this.onCharData &&
			this.view.dom.removeEventListener(
				"DOMCharacterDataModified",
				this.onCharData,
			),
			this.disconnectSelection();
	}
	connectSelection() {
		this.view.dom.ownerDocument.addEventListener(
			"selectionchange",
			this.onSelectionChange,
		);
	}
	disconnectSelection() {
		this.view.dom.ownerDocument.removeEventListener(
			"selectionchange",
			this.onSelectionChange,
		);
	}
	suppressSelectionUpdates() {
		(this.suppressingSelectionUpdates = !0),
			setTimeout(() => (this.suppressingSelectionUpdates = !1), 50);
	}
	onSelectionChange() {
		if (r7(this.view)) {
			if (this.suppressingSelectionUpdates) return ul(this.view);
			if (_i && Bu <= 11 && !this.view.state.selection.empty) {
				let e = this.view.domSelectionRange();
				if (
					e.focusNode &&
					Fd(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset)
				)
					return this.flushSoon();
			}
			this.flush();
		}
	}
	setCurSelection() {
		this.currentSelection.set(this.view.domSelectionRange());
	}
	ignoreSelectionChange(e) {
		if (!e.focusNode) return !0;
		let n = new Set(),
			r;
		for (let o = e.focusNode; o; o = Bg(o)) n.add(o);
		for (let o = e.anchorNode; o; o = Bg(o))
			if (n.has(o)) {
				r = o;
				break;
			}
		let i = r && this.view.docView.nearestDesc(r);
		if (
			i &&
			i.ignoreMutation({
				type: "selection",
				target: r.nodeType == 3 ? r.parentNode : r,
			})
		)
			return this.setCurSelection(), !0;
	}
	pendingRecords() {
		if (this.observer)
			for (let e of this.observer.takeRecords()) this.queue.push(e);
		return this.queue;
	}
	selectionChanged(e) {
		return (
			!this.suppressingSelectionUpdates &&
			!this.currentSelection.eq(e) &&
			r7(this.view) &&
			!this.ignoreSelectionChange(e)
		);
	}
	flush() {
		let { view: e } = this;
		if (!e.docView || this.flushingSoon > -1) return;
		let n = this.pendingRecords();
		n.length && (this.queue = []);
		let r = e.domSelectionRange(),
			i = this.selectionChanged(r),
			o = -1,
			s = -1,
			a = !1,
			l = [];
		if (e.editable)
			for (let c = 0; c < n.length; c++) {
				let d = this.registerMutation(n[c], l);
				d &&
					((o = o < 0 ? d.from : Math.min(d.from, o)),
					(s = s < 0 ? d.to : Math.max(d.to, s)),
					d.typeOver && (a = !0));
			}
		if (Ps && l.length) {
			let c = l.filter((d) => d.nodeName == "BR");
			if (c.length == 2) {
				let [d, f] = c;
				d.parentNode && d.parentNode.parentNode == f.parentNode
					? f.remove()
					: d.remove();
			} else {
				let { focusNode: d } = this.currentSelection;
				for (let f of c) {
					let h = f.parentNode;
					h &&
						h.nodeName == "LI" &&
						(!d || Twe(e, d) != h) &&
						f.remove();
				}
			}
		}
		let u = null;
		o < 0 &&
		i &&
		e.input.lastFocus > Date.now() - 200 &&
		Math.max(e.input.lastTouch, e.input.lastClick.time) <
			Date.now() - 300 &&
		B3(r) &&
		(u = O5(e)) &&
		u.eq(mt.near(e.state.doc.resolve(0), 1))
			? ((e.input.lastFocus = 0),
				ul(e),
				this.currentSelection.set(r),
				e.scrollToSelection())
			: (o > -1 || i) &&
				(o > -1 && (e.docView.markDirty(o, s), Awe(e)),
				this.handleDOMChange(o, s, a, l),
				e.docView && e.docView.dirty
					? e.updateState(e.state)
					: this.currentSelection.eq(r) || ul(e),
				this.currentSelection.set(r));
	}
	registerMutation(e, n) {
		if (n.indexOf(e.target) > -1) return null;
		let r = this.view.docView.nearestDesc(e.target);
		if (
			(e.type == "attributes" &&
				(r == this.view.docView ||
					e.attributeName == "contenteditable" ||
					(e.attributeName == "style" &&
						!e.oldValue &&
						!e.target.getAttribute("style")))) ||
			!r ||
			r.ignoreMutation(e)
		)
			return null;
		if (e.type == "childList") {
			for (let c = 0; c < e.addedNodes.length; c++) {
				let d = e.addedNodes[c];
				n.push(d), d.nodeType == 3 && (this.lastChangedTextNode = d);
			}
			if (
				r.contentDOM &&
				r.contentDOM != r.dom &&
				!r.contentDOM.contains(e.target)
			)
				return { from: r.posBefore, to: r.posAfter };
			let i = e.previousSibling,
				o = e.nextSibling;
			if (_i && Bu <= 11 && e.addedNodes.length)
				for (let c = 0; c < e.addedNodes.length; c++) {
					let { previousSibling: d, nextSibling: f } =
						e.addedNodes[c];
					(!d || Array.prototype.indexOf.call(e.addedNodes, d) < 0) &&
						(i = d),
						(!f ||
							Array.prototype.indexOf.call(e.addedNodes, f) <
								0) &&
							(o = f);
				}
			let s = i && i.parentNode == e.target ? $r(i) + 1 : 0,
				a = r.localPosFromDOM(e.target, s, -1),
				l =
					o && o.parentNode == e.target
						? $r(o)
						: e.target.childNodes.length,
				u = r.localPosFromDOM(e.target, l, 1);
			return { from: a, to: u };
		} else
			return e.type == "attributes"
				? { from: r.posAtStart - r.border, to: r.posAtEnd + r.border }
				: ((this.lastChangedTextNode = e.target),
					{
						from: r.posAtStart,
						to: r.posAtEnd,
						typeOver: e.target.nodeValue == e.oldValue,
					});
	}
}
let f7 = new WeakMap(),
	h7 = !1;
function Awe(t) {
	if (
		!f7.has(t) &&
		(f7.set(t, null),
		["normal", "nowrap", "pre-line"].indexOf(
			getComputedStyle(t.dom).whiteSpace,
		) !== -1)
	) {
		if (((t.requiresGeckoHackNode = Ps), h7)) return;
		console.warn(
			"ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package.",
		),
			(h7 = !0);
	}
}
function p7(t, e) {
	let n = e.startContainer,
		r = e.startOffset,
		i = e.endContainer,
		o = e.endOffset,
		s = t.domAtPos(t.state.selection.anchor);
	return (
		Fd(s.node, s.offset, i, o) && ([n, r, i, o] = [i, o, n, r]),
		{ anchorNode: n, anchorOffset: r, focusNode: i, focusOffset: o }
	);
}
function $we(t, e) {
	if (e.getComposedRanges) {
		let i = e.getComposedRanges(t.root)[0];
		if (i) return p7(t, i);
	}
	let n;
	function r(i) {
		i.preventDefault(),
			i.stopImmediatePropagation(),
			(n = i.getTargetRanges()[0]);
	}
	return (
		t.dom.addEventListener("beforeinput", r, !0),
		document.execCommand("indent"),
		t.dom.removeEventListener("beforeinput", r, !0),
		n ? p7(t, n) : null
	);
}
function Twe(t, e) {
	for (let n = e.parentNode; n && n != t.dom; n = n.parentNode) {
		let r = t.docView.nearestDesc(n, !0);
		if (r && r.node.isBlock) return n;
	}
	return null;
}
function Bwe(t, e, n) {
	let {
			node: r,
			fromOffset: i,
			toOffset: o,
			from: s,
			to: a,
		} = t.docView.parseRange(e, n),
		l = t.domSelectionRange(),
		u,
		c = l.anchorNode;
	if (
		(c &&
			t.dom.contains(c.nodeType == 1 ? c : c.parentNode) &&
			((u = [{ node: c, offset: l.anchorOffset }]),
			B3(l) || u.push({ node: l.focusNode, offset: l.focusOffset })),
		Ur && t.input.lastKeyCode === 8)
	)
		for (let v = o; v > i; v--) {
			let b = r.childNodes[v - 1],
				y = b.pmViewDesc;
			if (b.nodeName == "BR" && !y) {
				o = v;
				break;
			}
			if (!y || y.size) break;
		}
	let d = t.state.doc,
		f = t.someProp("domParser") || jD.fromSchema(t.state.schema),
		h = d.resolve(s),
		p = null,
		g = f.parse(r, {
			topNode: h.parent,
			topMatch: h.parent.contentMatchAt(h.index()),
			topOpen: !0,
			from: i,
			to: o,
			preserveWhitespace: h.parent.type.whitespace == "pre" ? "full" : !0,
			findPositions: u,
			ruleFromNode: Iwe,
			context: h,
		});
	if (u && u[0].pos != null) {
		let v = u[0].pos,
			b = u[1] && u[1].pos;
		b == null && (b = v), (p = { anchor: v + s, head: b + s });
	}
	return { doc: g, sel: p, from: s, to: a };
}
function Iwe(t) {
	let e = t.pmViewDesc;
	if (e) return e.parseRule();
	if (t.nodeName == "BR" && t.parentNode) {
		if (gi && /^(ul|ol)$/i.test(t.parentNode.nodeName)) {
			let n = document.createElement("div");
			return n.appendChild(document.createElement("li")), { skip: n };
		} else if (
			t.parentNode.lastChild == t ||
			(gi && /^(tr|table)$/i.test(t.parentNode.nodeName))
		)
			return { ignore: !0 };
	} else if (t.nodeName == "IMG" && t.getAttribute("mark-placeholder"))
		return { ignore: !0 };
	return null;
}
const Fwe =
	/^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i;
function Pwe(t, e, n, r, i) {
	let o =
		t.input.compositionPendingChanges ||
		(t.composing ? t.input.compositionID : 0);
	if (((t.input.compositionPendingChanges = 0), e < 0)) {
		let $ =
				t.input.lastSelectionTime > Date.now() - 50
					? t.input.lastSelectionOrigin
					: null,
			A = O5(t, $);
		if (A && !t.state.selection.eq(A)) {
			if (
				Ur &&
				ms &&
				t.input.lastKeyCode === 13 &&
				Date.now() - 100 < t.input.lastKeyCodeTime &&
				t.someProp("handleKeyDown", (I) => I(t, Sc(13, "Enter")))
			)
				return;
			let T = t.state.tr.setSelection(A);
			$ == "pointer"
				? T.setMeta("pointer", !0)
				: $ == "key" && T.scrollIntoView(),
				o && T.setMeta("composition", o),
				t.dispatch(T);
		}
		return;
	}
	let s = t.state.doc.resolve(e),
		a = s.sharedDepth(n);
	(e = s.before(a + 1)), (n = t.state.doc.resolve(n).after(a + 1));
	let l = t.state.selection,
		u = Bwe(t, e, n),
		c = t.state.doc,
		d = c.slice(u.from, u.to),
		f,
		h;
	t.input.lastKeyCode === 8 && Date.now() - 100 < t.input.lastKeyCodeTime
		? ((f = t.state.selection.to), (h = "end"))
		: ((f = t.state.selection.from), (h = "start")),
		(t.input.lastKeyCode = null);
	let p = Owe(d.content, u.doc.content, u.from, f, h);
	if (
		(p && t.input.domChangeCount++,
		((jh && t.input.lastIOSEnter > Date.now() - 225) || ms) &&
			i.some(($) => $.nodeType == 1 && !Fwe.test($.nodeName)) &&
			(!p || p.endA >= p.endB) &&
			t.someProp("handleKeyDown", ($) => $(t, Sc(13, "Enter"))))
	) {
		t.input.lastIOSEnter = 0;
		return;
	}
	if (!p)
		if (
			r &&
			l instanceof kt &&
			!l.empty &&
			l.$head.sameParent(l.$anchor) &&
			!t.composing &&
			!(u.sel && u.sel.anchor != u.sel.head)
		)
			p = { start: l.from, endA: l.to, endB: l.to };
		else {
			if (u.sel) {
				let $ = m7(t, t.state.doc, u.sel);
				if ($ && !$.eq(t.state.selection)) {
					let A = t.state.tr.setSelection($);
					o && A.setMeta("composition", o), t.dispatch(A);
				}
			}
			return;
		}
	t.state.selection.from < t.state.selection.to &&
		p.start == p.endB &&
		t.state.selection instanceof kt &&
		(p.start > t.state.selection.from &&
		p.start <= t.state.selection.from + 2 &&
		t.state.selection.from >= u.from
			? (p.start = t.state.selection.from)
			: p.endA < t.state.selection.to &&
				p.endA >= t.state.selection.to - 2 &&
				t.state.selection.to <= u.to &&
				((p.endB += t.state.selection.to - p.endA),
				(p.endA = t.state.selection.to))),
		_i &&
			Bu <= 11 &&
			p.endB == p.start + 1 &&
			p.endA == p.start &&
			p.start > u.from &&
			u.doc.textBetween(p.start - u.from - 1, p.start - u.from + 1) ==
				"  " &&
			(p.start--, p.endA--, p.endB--);
	let g = u.doc.resolveNoCache(p.start - u.from),
		v = u.doc.resolveNoCache(p.endB - u.from),
		b = c.resolve(p.start),
		y = g.sameParent(v) && g.parent.inlineContent && b.end() >= p.endA,
		x;
	if (
		((jh &&
			t.input.lastIOSEnter > Date.now() - 225 &&
			(!y || i.some(($) => $.nodeName == "DIV" || $.nodeName == "P"))) ||
			(!y &&
				g.pos < u.doc.content.size &&
				!g.sameParent(v) &&
				(x = mt.findFrom(u.doc.resolve(g.pos + 1), 1, !0)) &&
				x.head == v.pos)) &&
		t.someProp("handleKeyDown", ($) => $(t, Sc(13, "Enter")))
	) {
		t.input.lastIOSEnter = 0;
		return;
	}
	if (
		t.state.selection.anchor > p.start &&
		Rwe(c, p.start, p.endA, g, v) &&
		t.someProp("handleKeyDown", ($) => $(t, Sc(8, "Backspace")))
	) {
		ms && Ur && t.domObserver.suppressSelectionUpdates();
		return;
	}
	Ur && ms && p.endB == p.start && (t.input.lastAndroidDelete = Date.now()),
		ms &&
			!y &&
			g.start() != v.start() &&
			v.parentOffset == 0 &&
			g.depth == v.depth &&
			u.sel &&
			u.sel.anchor == u.sel.head &&
			u.sel.head == p.endA &&
			((p.endB -= 2),
			(v = u.doc.resolveNoCache(p.endB - u.from)),
			setTimeout(() => {
				t.someProp("handleKeyDown", function ($) {
					return $(t, Sc(13, "Enter"));
				});
			}, 20));
	let C = p.start,
		k = p.endA,
		w,
		D,
		S;
	if (y) {
		if (g.pos == v.pos)
			_i &&
				Bu <= 11 &&
				g.parentOffset == 0 &&
				(t.domObserver.suppressSelectionUpdates(),
				setTimeout(() => ul(t), 20)),
				(w = t.state.tr.delete(C, k)),
				(D = c.resolve(p.start).marksAcross(c.resolve(p.endA)));
		else if (
			p.endA == p.endB &&
			(S = Nwe(
				g.parent.content.cut(g.parentOffset, v.parentOffset),
				b.parent.content.cut(b.parentOffset, p.endA - b.start()),
			))
		)
			(w = t.state.tr),
				S.type == "add"
					? w.addMark(C, k, S.mark)
					: w.removeMark(C, k, S.mark);
		else if (
			g.parent.child(g.index()).isText &&
			g.index() == v.index() - (v.textOffset ? 0 : 1)
		) {
			let $ = g.parent.textBetween(g.parentOffset, v.parentOffset);
			if (t.someProp("handleTextInput", (A) => A(t, C, k, $))) return;
			w = t.state.tr.insertText($, C, k);
		}
	}
	if (
		(w ||
			(w = t.state.tr.replace(
				C,
				k,
				u.doc.slice(p.start - u.from, p.endB - u.from),
			)),
		u.sel)
	) {
		let $ = m7(t, w.doc, u.sel);
		$ &&
			!(
				(Ur &&
					ms &&
					t.composing &&
					$.empty &&
					(p.start != p.endB ||
						t.input.lastAndroidDelete < Date.now() - 100) &&
					($.head == C || $.head == w.mapping.map(k) - 1)) ||
				(_i && $.empty && $.head == C)
			) &&
			w.setSelection($);
	}
	D && w.ensureMarks(D),
		o && w.setMeta("composition", o),
		t.dispatch(w.scrollIntoView());
}
function m7(t, e, n) {
	return Math.max(n.anchor, n.head) > e.content.size
		? null
		: M5(t, e.resolve(n.anchor), e.resolve(n.head));
}
function Nwe(t, e) {
	let n = t.firstChild.marks,
		r = e.firstChild.marks,
		i = n,
		o = r,
		s,
		a,
		l;
	for (let c = 0; c < r.length; c++) i = r[c].removeFromSet(i);
	for (let c = 0; c < n.length; c++) o = n[c].removeFromSet(o);
	if (i.length == 1 && o.length == 0)
		(a = i[0]), (s = "add"), (l = (c) => c.mark(a.addToSet(c.marks)));
	else if (i.length == 0 && o.length == 1)
		(a = o[0]),
			(s = "remove"),
			(l = (c) => c.mark(a.removeFromSet(c.marks)));
	else return null;
	let u = [];
	for (let c = 0; c < e.childCount; c++) u.push(l(e.child(c)));
	if (be.from(u).eq(t)) return { mark: a, type: s };
}
function Rwe(t, e, n, r, i) {
	if (n - e <= i.pos - r.pos || oC(r, !0, !1) < i.pos) return !1;
	let o = t.resolve(e);
	if (!r.parent.isTextblock) {
		let a = o.nodeAfter;
		return a != null && n == e + a.nodeSize;
	}
	if (o.parentOffset < o.parent.content.size || !o.parent.isTextblock)
		return !1;
	let s = t.resolve(oC(o, !0, !0));
	return !s.parent.isTextblock || s.pos > n || oC(s, !0, !1) < n
		? !1
		: r.parent.content.cut(r.parentOffset).eq(s.parent.content);
}
function oC(t, e, n) {
	let r = t.depth,
		i = e ? t.end() : t.pos;
	for (; r > 0 && (e || t.indexAfter(r) == t.node(r).childCount); )
		r--, i++, (e = !1);
	if (n) {
		let o = t.node(r).maybeChild(t.indexAfter(r));
		for (; o && !o.isLeaf; ) (o = o.firstChild), i++;
	}
	return i;
}
function Owe(t, e, n, r, i) {
	let o = t.findDiffStart(e, n);
	if (o == null) return null;
	let { a: s, b: a } = t.findDiffEnd(e, n + t.size, n + e.size);
	if (i == "end") {
		let l = Math.max(0, o - Math.min(s, a));
		r -= s + l - o;
	}
	if (s < o && t.size < e.size) {
		let l = r <= o && r >= s ? o - r : 0;
		(o -= l),
			o &&
				o < e.size &&
				g7(e.textBetween(o - 1, o + 1)) &&
				(o += l ? 1 : -1),
			(a = o + (a - s)),
			(s = o);
	} else if (a < o) {
		let l = r <= o && r >= a ? o - r : 0;
		(o -= l),
			o &&
				o < t.size &&
				g7(t.textBetween(o - 1, o + 1)) &&
				(o += l ? 1 : -1),
			(s = o + (s - a)),
			(a = o);
	}
	return { start: o, endA: s, endB: a };
}
function g7(t) {
	if (t.length != 2) return !1;
	let e = t.charCodeAt(0),
		n = t.charCodeAt(1);
	return e >= 56320 && e <= 57343 && n >= 55296 && n <= 56319;
}
class Mwe {
	constructor(e, n) {
		(this._root = null),
			(this.focused = !1),
			(this.trackWrites = null),
			(this.mounted = !1),
			(this.markCursor = null),
			(this.cursorWrapper = null),
			(this.lastSelectedViewDesc = void 0),
			(this.input = new nwe()),
			(this.prevDirectPlugins = []),
			(this.pluginViews = []),
			(this.requiresGeckoHackNode = !1),
			(this.dragging = null),
			(this._props = n),
			(this.state = n.state),
			(this.directPlugins = n.plugins || []),
			this.directPlugins.forEach(k7),
			(this.dispatch = this.dispatch.bind(this)),
			(this.dom = (e && e.mount) || document.createElement("div")),
			e &&
				(e.appendChild
					? e.appendChild(this.dom)
					: typeof e == "function"
						? e(this.dom)
						: e.mount && (this.mounted = !0)),
			(this.editable = y7(this)),
			v7(this),
			(this.nodeViews = x7(this)),
			(this.docView = XI(
				this.state.doc,
				b7(this),
				iC(this),
				this.dom,
				this,
			)),
			(this.domObserver = new Swe(this, (r, i, o, s) =>
				Pwe(this, r, i, o, s),
			)),
			this.domObserver.start(),
			rwe(this),
			this.updatePluginViews();
	}
	get composing() {
		return this.input.composing;
	}
	get props() {
		if (this._props.state != this.state) {
			let e = this._props;
			this._props = {};
			for (let n in e) this._props[n] = e[n];
			this._props.state = this.state;
		}
		return this._props;
	}
	update(e) {
		e.handleDOMEvents != this._props.handleDOMEvents && eE(this);
		let n = this._props;
		(this._props = e),
			e.plugins &&
				(e.plugins.forEach(k7), (this.directPlugins = e.plugins)),
			this.updateStateInner(e.state, n);
	}
	setProps(e) {
		let n = {};
		for (let r in this._props) n[r] = this._props[r];
		n.state = this.state;
		for (let r in e) n[r] = e[r];
		this.update(n);
	}
	updateState(e) {
		this.updateStateInner(e, this._props);
	}
	updateStateInner(e, n) {
		var r;
		let i = this.state,
			o = !1,
			s = !1;
		e.storedMarks && this.composing && (jq(this), (s = !0)),
			(this.state = e);
		let a = i.plugins != e.plugins || this._props.plugins != n.plugins;
		if (
			a ||
			this._props.plugins != n.plugins ||
			this._props.nodeViews != n.nodeViews
		) {
			let h = x7(this);
			_we(h, this.nodeViews) && ((this.nodeViews = h), (o = !0));
		}
		(a || n.handleDOMEvents != this._props.handleDOMEvents) && eE(this),
			(this.editable = y7(this)),
			v7(this);
		let l = iC(this),
			u = b7(this),
			c =
				i.plugins != e.plugins && !i.doc.eq(e.doc)
					? "reset"
					: e.scrollToSelection > i.scrollToSelection
						? "to selection"
						: "preserve",
			d = o || !this.docView.matchesNode(e.doc, u, l);
		(d || !e.selection.eq(i.selection)) && (s = !0);
		let f =
			c == "preserve" &&
			s &&
			this.dom.style.overflowAnchor == null &&
			bCe(this);
		if (s) {
			this.domObserver.stop();
			let h =
				d &&
				(_i || Ur) &&
				!this.composing &&
				!i.selection.empty &&
				!e.selection.empty &&
				jwe(i.selection, e.selection);
			if (d) {
				let p = Ur
					? (this.trackWrites = this.domSelectionRange().focusNode)
					: null;
				this.composing && (this.input.compositionNode = gwe(this)),
					(o || !this.docView.update(e.doc, u, l, this)) &&
						(this.docView.updateOuterDeco(u),
						this.docView.destroy(),
						(this.docView = XI(e.doc, u, l, this.dom, this))),
					p && !this.trackWrites && (h = !0);
			}
			h ||
			!(
				this.input.mouseDown &&
				this.domObserver.currentSelection.eq(
					this.domSelectionRange(),
				) &&
				LCe(this)
			)
				? ul(this, h)
				: (Dq(this, e.selection), this.domObserver.setCurSelection()),
				this.domObserver.start();
		}
		this.updatePluginViews(i),
			!((r = this.dragging) === null || r === void 0) &&
				r.node &&
				!i.doc.eq(e.doc) &&
				this.updateDraggedNode(this.dragging, i),
			c == "reset"
				? (this.dom.scrollTop = 0)
				: c == "to selection"
					? this.scrollToSelection()
					: f && vCe(f);
	}
	scrollToSelection() {
		let e = this.domSelectionRange().focusNode;
		if (!this.someProp("handleScrollToSelection", (n) => n(this)))
			if (this.state.selection instanceof Qe) {
				let n = this.docView.domAfterPos(this.state.selection.from);
				n.nodeType == 1 && HI(this, n.getBoundingClientRect(), e);
			} else HI(this, this.coordsAtPos(this.state.selection.head, 1), e);
	}
	destroyPluginViews() {
		let e;
		for (; (e = this.pluginViews.pop()); ) e.destroy && e.destroy();
	}
	updatePluginViews(e) {
		if (
			!e ||
			e.plugins != this.state.plugins ||
			this.directPlugins != this.prevDirectPlugins
		) {
			(this.prevDirectPlugins = this.directPlugins),
				this.destroyPluginViews();
			for (let n = 0; n < this.directPlugins.length; n++) {
				let r = this.directPlugins[n];
				r.spec.view && this.pluginViews.push(r.spec.view(this));
			}
			for (let n = 0; n < this.state.plugins.length; n++) {
				let r = this.state.plugins[n];
				r.spec.view && this.pluginViews.push(r.spec.view(this));
			}
		} else
			for (let n = 0; n < this.pluginViews.length; n++) {
				let r = this.pluginViews[n];
				r.update && r.update(this, e);
			}
	}
	updateDraggedNode(e, n) {
		let r = e.node,
			i = -1;
		if (this.state.doc.nodeAt(r.from) == r.node) i = r.from;
		else {
			let o = r.from + (this.state.doc.content.size - n.doc.content.size);
			(o > 0 && this.state.doc.nodeAt(o)) == r.node && (i = o);
		}
		this.dragging = new zq(
			e.slice,
			e.move,
			i < 0 ? void 0 : Qe.create(this.state.doc, i),
		);
	}
	someProp(e, n) {
		let r = this._props && this._props[e],
			i;
		if (r != null && (i = n ? n(r) : r)) return i;
		for (let s = 0; s < this.directPlugins.length; s++) {
			let a = this.directPlugins[s].props[e];
			if (a != null && (i = n ? n(a) : a)) return i;
		}
		let o = this.state.plugins;
		if (o)
			for (let s = 0; s < o.length; s++) {
				let a = o[s].props[e];
				if (a != null && (i = n ? n(a) : a)) return i;
			}
	}
	hasFocus() {
		if (_i) {
			let e = this.root.activeElement;
			if (e == this.dom) return !0;
			if (!e || !this.dom.contains(e)) return !1;
			for (; e && this.dom != e && this.dom.contains(e); ) {
				if (e.contentEditable == "false") return !1;
				e = e.parentElement;
			}
			return !0;
		}
		return this.root.activeElement == this.dom;
	}
	focus() {
		this.domObserver.stop(),
			this.editable && yCe(this.dom),
			ul(this),
			this.domObserver.start();
	}
	get root() {
		let e = this._root;
		if (e == null) {
			for (let n = this.dom.parentNode; n; n = n.parentNode)
				if (n.nodeType == 9 || (n.nodeType == 11 && n.host))
					return (
						n.getSelection ||
							(Object.getPrototypeOf(n).getSelection = () =>
								n.ownerDocument.getSelection()),
						(this._root = n)
					);
		}
		return e || document;
	}
	updateRoot() {
		this._root = null;
	}
	posAtCoords(e) {
		return ECe(this, e);
	}
	coordsAtPos(e, n = 1) {
		return bq(this, e, n);
	}
	domAtPos(e, n = 0) {
		return this.docView.domFromPos(e, n);
	}
	nodeDOM(e) {
		let n = this.docView.descAt(e);
		return n ? n.nodeDOM : null;
	}
	posAtDOM(e, n, r = -1) {
		let i = this.docView.posFromDOM(e, n, r);
		if (i == null)
			throw new RangeError("DOM position not inside the editor");
		return i;
	}
	endOfTextblock(e, n) {
		return TCe(this, n || this.state, e);
	}
	pasteHTML(e, n) {
		return Fg(this, "", e, !1, n || new ClipboardEvent("paste"));
	}
	pasteText(e, n) {
		return Fg(this, e, null, !0, n || new ClipboardEvent("paste"));
	}
	destroy() {
		this.docView &&
			(iwe(this),
			this.destroyPluginViews(),
			this.mounted
				? (this.docView.update(this.state.doc, [], iC(this), this),
					(this.dom.textContent = ""))
				: this.dom.parentNode &&
					this.dom.parentNode.removeChild(this.dom),
			this.docView.destroy(),
			(this.docView = null),
			sCe());
	}
	get isDestroyed() {
		return this.docView == null;
	}
	dispatchEvent(e) {
		return swe(this, e);
	}
	dispatch(e) {
		let n = this._props.dispatchTransaction;
		n ? n.call(this, e) : this.updateState(this.state.apply(e));
	}
	domSelectionRange() {
		let e = this.domSelection();
		return e
			? (gi &&
					this.root.nodeType === 11 &&
					dCe(this.dom.ownerDocument) == this.dom &&
					$we(this, e)) ||
					e
			: {
					focusNode: null,
					focusOffset: 0,
					anchorNode: null,
					anchorOffset: 0,
				};
	}
	domSelection() {
		return this.root.getSelection();
	}
}
function b7(t) {
	let e = Object.create(null);
	return (
		(e.class = "ProseMirror"),
		(e.contenteditable = String(t.editable)),
		t.someProp("attributes", (n) => {
			if ((typeof n == "function" && (n = n(t.state)), n))
				for (let r in n)
					r == "class"
						? (e.class += " " + n[r])
						: r == "style"
							? (e.style = (e.style ? e.style + ";" : "") + n[r])
							: !e[r] &&
								r != "contenteditable" &&
								r != "nodeName" &&
								(e[r] = String(n[r]));
		}),
		e.translate || (e.translate = "no"),
		[Hn.node(0, t.state.doc.content.size, e)]
	);
}
function v7(t) {
	if (t.markCursor) {
		let e = document.createElement("img");
		(e.className = "ProseMirror-separator"),
			e.setAttribute("mark-placeholder", "true"),
			e.setAttribute("alt", ""),
			(t.cursorWrapper = {
				dom: e,
				deco: Hn.widget(t.state.selection.from, e, {
					raw: !0,
					marks: t.markCursor,
				}),
			});
	} else t.cursorWrapper = null;
}
function y7(t) {
	return !t.someProp("editable", (e) => e(t.state) === !1);
}
function jwe(t, e) {
	let n = Math.min(
		t.$anchor.sharedDepth(t.head),
		e.$anchor.sharedDepth(e.head),
	);
	return t.$anchor.start(n) != e.$anchor.start(n);
}
function x7(t) {
	let e = Object.create(null);
	function n(r) {
		for (let i in r)
			Object.prototype.hasOwnProperty.call(e, i) || (e[i] = r[i]);
	}
	return t.someProp("nodeViews", n), t.someProp("markViews", n), e;
}
function _we(t, e) {
	let n = 0,
		r = 0;
	for (let i in t) {
		if (t[i] != e[i]) return !0;
		n++;
	}
	for (let i in e) r++;
	return n != r;
}
function k7(t) {
	if (t.spec.state || t.spec.filterTransaction || t.spec.appendTransaction)
		throw new RangeError(
			"Plugins passed directly to the view must not have a state component",
		);
}
const zwe = /[\uD800-\uDBFF]/,
	Lwe = /[\uDC00-\uDFFF]/,
	Vwe = (t, e) => {
		let n = 0,
			r = 0;
		for (; n < t.length && n < e.length && t[n] === e[n]; ) n++;
		for (
			n > 0 && zwe.test(t[n - 1]) && n--;
			r + n < t.length &&
			r + n < e.length &&
			t[t.length - r - 1] === e[e.length - r - 1];

		)
			r++;
		return (
			r > 0 && Lwe.test(t[t.length - r]) && r--,
			{
				index: n,
				remove: t.length - n - r,
				insert: e.slice(n, e.length - r),
			}
		);
	},
	Kwe = Vwe,
	dn = new Os("y-sync"),
	ad = new Os("y-undo"),
	cm = new Os("yjs-cursor"),
	Sy = (t, e) =>
		e === void 0
			? !t.deleted
			: e.sv.has(t.id.client) &&
				e.sv.get(t.id.client) > t.id.clock &&
				!ip(e.ds, t.id),
	Uwe = [{ light: "#ecd44433", dark: "#ecd444" }],
	Hwe = (t, e, n) => {
		if (!t.has(n)) {
			if (t.size < e.length) {
				const r = xl();
				t.forEach((i) => r.add(i)), (e = e.filter((i) => !r.has(i)));
			}
			t.set(n, Oge(e));
		}
		return t.get(n);
	},
	Wwe = (
		t,
		{
			colors: e = Uwe,
			colorMapping: n = new Map(),
			permanentUserData: r = null,
			onFirstRender: i = () => {},
			mapping: o,
		} = {},
	) => {
		let s = !1;
		const a = new Gwe(t, o),
			l = new Gn({
				props: {
					editable: (u) => {
						const c = dn.getState(u);
						return c.snapshot == null && c.prevSnapshot == null;
					},
				},
				key: dn,
				state: {
					init: (u, c) => ({
						type: t,
						doc: t.doc,
						binding: a,
						snapshot: null,
						prevSnapshot: null,
						isChangeOrigin: !1,
						isUndoRedoOperation: !1,
						addToHistory: !0,
						colors: e,
						colorMapping: n,
						permanentUserData: r,
					}),
					apply: (u, c) => {
						const d = u.getMeta(dn);
						if (d !== void 0) {
							c = Object.assign({}, c);
							for (const f in d) c[f] = d[f];
						}
						return (
							(c.addToHistory = u.getMeta("addToHistory") !== !1),
							(c.isChangeOrigin =
								d !== void 0 && !!d.isChangeOrigin),
							(c.isUndoRedoOperation =
								d !== void 0 &&
								!!d.isChangeOrigin &&
								!!d.isUndoRedoOperation),
							a.prosemirrorView !== null &&
								d !== void 0 &&
								(d.snapshot != null ||
									d.prevSnapshot != null) &&
								FS(0, () => {
									a.prosemirrorView != null &&
										(d.restore == null
											? a._renderSnapshot(
													d.snapshot,
													d.prevSnapshot,
													c,
												)
											: (a._renderSnapshot(
													d.snapshot,
													d.snapshot,
													c,
												),
												delete c.restore,
												delete c.snapshot,
												delete c.prevSnapshot,
												a.mux(() => {
													a._prosemirrorChanged(
														a.prosemirrorView.state
															.doc,
													);
												})));
								}),
							c
						);
					},
				},
				view: (u) => (
					a.initView(u),
					o == null && a._forceRerender(),
					i(),
					{
						update: () => {
							const c = l.getState(u.state);
							if (
								c.snapshot == null &&
								c.prevSnapshot == null &&
								(s ||
									u.state.doc.content.findDiffStart(
										u.state.doc.type.createAndFill()
											.content,
									) !== null)
							) {
								if (
									((s = !0),
									c.addToHistory === !1 && !c.isChangeOrigin)
								) {
									const d = ad.getState(u.state),
										f = d && d.undoManager;
									f && f.stopCapturing();
								}
								a.mux(() => {
									c.doc.transact((d) => {
										d.meta.set(
											"addToHistory",
											c.addToHistory,
										),
											a._prosemirrorChanged(u.state.doc);
									}, dn);
								});
							}
						},
						destroy: () => {
							a.destroy();
						},
					}
				),
			});
		return l;
	},
	qwe = (t, e, n) => {
		if (e !== null && e.anchor !== null && e.head !== null) {
			const r = Rg(n.doc, n.type, e.anchor, n.mapping),
				i = Rg(n.doc, n.type, e.head, n.mapping);
			r !== null &&
				i !== null &&
				(t = t.setSelection(kt.create(t.doc, r, i)));
		}
	},
	tE = (t, e) => ({
		anchor: Ty(e.selection.anchor, t.type, t.mapping),
		head: Ty(e.selection.head, t.type, t.mapping),
	});
class Gwe {
	constructor(e, n = new Map()) {
		(this.type = e),
			(this.prosemirrorView = null),
			(this.mux = XK()),
			(this.mapping = n),
			(this._observeFunction = this._typeChanged.bind(this)),
			(this.doc = e.doc),
			(this.beforeTransactionSelection = null),
			(this.beforeAllTransactions = () => {
				this.beforeTransactionSelection === null &&
					this.prosemirrorView != null &&
					(this.beforeTransactionSelection = tE(
						this,
						this.prosemirrorView.state,
					));
			}),
			(this.afterAllTransactions = () => {
				this.beforeTransactionSelection = null;
			}),
			(this._domSelectionInView = null);
	}
	get _tr() {
		return this.prosemirrorView.state.tr.setMeta("addToHistory", !1);
	}
	_isLocalCursorInView() {
		return this.prosemirrorView.hasFocus()
			? (IS &&
					this._domSelectionInView === null &&
					(FS(0, () => {
						this._domSelectionInView = null;
					}),
					(this._domSelectionInView = this._isDomSelectionInView())),
				this._domSelectionInView)
			: !1;
	}
	_isDomSelectionInView() {
		const e = this.prosemirrorView._root.getSelection(),
			n = this.prosemirrorView._root.createRange();
		n.setStart(e.anchorNode, e.anchorOffset),
			n.setEnd(e.focusNode, e.focusOffset),
			n.getClientRects().length === 0 &&
				n.startContainer &&
				n.collapsed &&
				n.selectNodeContents(n.startContainer);
		const i = n.getBoundingClientRect(),
			o = t0e.documentElement;
		return (
			i.bottom >= 0 &&
			i.right >= 0 &&
			i.left <= (window.innerWidth || o.clientWidth || 0) &&
			i.top <= (window.innerHeight || o.clientHeight || 0)
		);
	}
	renderSnapshot(e, n) {
		n || (n = fK(iK(), new Map())),
			this.prosemirrorView.dispatch(
				this._tr.setMeta(dn, { snapshot: e, prevSnapshot: n }),
			);
	}
	unrenderSnapshot() {
		this.mapping.clear(),
			this.mux(() => {
				const e = this.type
						.toArray()
						.map((r) =>
							Ib(
								r,
								this.prosemirrorView.state.schema,
								this.mapping,
							),
						)
						.filter((r) => r !== null),
					n = this._tr.replace(
						0,
						this.prosemirrorView.state.doc.content.size,
						new Ee(be.from(e), 0, 0),
					);
				n.setMeta(dn, { snapshot: null, prevSnapshot: null }),
					this.prosemirrorView.dispatch(n);
			});
	}
	_forceRerender() {
		this.mapping.clear(),
			this.mux(() => {
				const e =
						this.beforeTransactionSelection !== null
							? null
							: this.prosemirrorView.state.selection,
					n = this.type
						.toArray()
						.map((i) =>
							Ib(
								i,
								this.prosemirrorView.state.schema,
								this.mapping,
							),
						)
						.filter((i) => i !== null),
					r = this._tr.replace(
						0,
						this.prosemirrorView.state.doc.content.size,
						new Ee(be.from(n), 0, 0),
					);
				e && r.setSelection(kt.create(r.doc, e.anchor, e.head)),
					this.prosemirrorView.dispatch(
						r.setMeta(dn, { isChangeOrigin: !0, binding: this }),
					);
			});
	}
	_renderSnapshot(e, n, r) {
		let i = this.doc;
		e || (e = Tk(this.doc)),
			(e instanceof Uint8Array || n instanceof Uint8Array) &&
				((!(e instanceof Uint8Array) || !(n instanceof Uint8Array)) &&
					go(),
				(i = new Ki({ gc: !1 })),
				Gv(i, n),
				(n = Tk(i)),
				Gv(i, e),
				(e = Tk(i))),
			this.mapping.clear(),
			this.mux(() => {
				i.transact((o) => {
					const s = r.permanentUserData;
					s &&
						s.dss.forEach((c) => {
							Wu(o, c, (d) => {});
						});
					const a = (c, d) => {
							const f =
								c === "added"
									? s.getUserByClientId(d.client)
									: s.getUserByDeletedId(d);
							return {
								user: f,
								type: c,
								color: Hwe(r.colorMapping, r.colors, f),
							};
						},
						l = EK(this.type, new zS(n.ds, e.sv))
							.map((c) =>
								!c._item.deleted ||
								Sy(c._item, e) ||
								Sy(c._item, n)
									? Ib(
											c,
											this.prosemirrorView.state.schema,
											new Map(),
											e,
											n,
											a,
										)
									: null,
							)
							.filter((c) => c !== null),
						u = this._tr.replace(
							0,
							this.prosemirrorView.state.doc.content.size,
							new Ee(be.from(l), 0, 0),
						);
					this.prosemirrorView.dispatch(
						u.setMeta(dn, { isChangeOrigin: !0 }),
					);
				}, dn);
			});
	}
	_typeChanged(e, n) {
		if (this.prosemirrorView == null) return;
		const r = dn.getState(this.prosemirrorView.state);
		if (e.length === 0 || r.snapshot != null || r.prevSnapshot != null) {
			this.renderSnapshot(r.snapshot, r.prevSnapshot);
			return;
		}
		this.mux(() => {
			const i = (a, l) => this.mapping.delete(l);
			Wu(n, n.deleteSet, (a) => {
				if (a.constructor === Qt) {
					const l = a.content.type;
					l && this.mapping.delete(l);
				}
			}),
				n.changed.forEach(i),
				n.changedParentTypes.forEach(i);
			const o = this.type
				.toArray()
				.map((a) =>
					Hq(a, this.prosemirrorView.state.schema, this.mapping),
				)
				.filter((a) => a !== null);
			let s = this._tr.replace(
				0,
				this.prosemirrorView.state.doc.content.size,
				new Ee(be.from(o), 0, 0),
			);
			qwe(s, this.beforeTransactionSelection, this),
				(s = s.setMeta(dn, {
					isChangeOrigin: !0,
					isUndoRedoOperation: n.origin instanceof bK,
				})),
				this.beforeTransactionSelection !== null &&
					this._isLocalCursorInView() &&
					s.scrollIntoView(),
				this.prosemirrorView.dispatch(s);
		});
	}
	_prosemirrorChanged(e) {
		this.doc.transact(() => {
			$y(this.doc, this.type, e, this.mapping),
				(this.beforeTransactionSelection = tE(
					this,
					this.prosemirrorView.state,
				));
		}, dn);
	}
	initView(e) {
		this.prosemirrorView != null && this.destroy(),
			(this.prosemirrorView = e),
			this.doc.on("beforeAllTransactions", this.beforeAllTransactions),
			this.doc.on("afterAllTransactions", this.afterAllTransactions),
			this.type.observeDeep(this._observeFunction);
	}
	destroy() {
		this.prosemirrorView != null &&
			((this.prosemirrorView = null),
			this.type.unobserveDeep(this._observeFunction),
			this.doc.off("beforeAllTransactions", this.beforeAllTransactions),
			this.doc.off("afterAllTransactions", this.afterAllTransactions));
	}
}
const Hq = (t, e, n, r, i, o) => {
		const s = n.get(t);
		if (s === void 0) {
			if (t instanceof ci) return Ib(t, e, n, r, i, o);
			throw ws();
		}
		return s;
	},
	Ib = (t, e, n, r, i, o) => {
		const s = [],
			a = (l) => {
				var u;
				if (l.constructor === ci) {
					const c = Hq(l, e, n, r, i, o);
					c !== null && s.push(c);
				} else {
					const c =
						(u = l._item.right) == null ? void 0 : u.content.type;
					c instanceof qu &&
						!c._item.deleted &&
						c._item.id.client === c.doc.clientID &&
						(l.applyDelta([{ retain: l.length }, ...c.toDelta()]),
						c.doc.transact((f) => {
							c._item.delete(f);
						}));
					const d = Ywe(l, e, n, r, i, o);
					d !== null &&
						d.forEach((f) => {
							f !== null && s.push(f);
						});
				}
			};
		r === void 0 || i === void 0
			? t.toArray().forEach(a)
			: EK(t, new zS(i.ds, r.sv)).forEach(a);
		try {
			const l = t.getAttributes(r);
			r !== void 0 &&
				(Sy(t._item, r)
					? Sy(t._item, i) ||
						(l.ychange = o
							? o("added", t._item.id)
							: { type: "added" })
					: (l.ychange = o
							? o("removed", t._item.id)
							: { type: "removed" }));
			const u = e.node(t.nodeName, l, s);
			return n.set(t, u), u;
		} catch {
			return (
				t.doc.transact((u) => {
					t._item.delete(u);
				}, dn),
				n.delete(t),
				null
			);
		}
	},
	Ywe = (t, e, n, r, i, o) => {
		const s = [],
			a = t.toDelta(r, i, o);
		try {
			for (let l = 0; l < a.length; l++) {
				const u = a[l],
					c = [];
				for (const d in u.attributes)
					c.push(e.mark(d, u.attributes[d]));
				s.push(e.text(u.insert, c));
			}
		} catch {
			return (
				t.doc.transact((u) => {
					t._item.delete(u);
				}, dn),
				null
			);
		}
		return s;
	},
	Jwe = (t, e) => {
		const n = new lo(),
			r = t.map((i) => ({ insert: i.text, attributes: qq(i.marks) }));
		return n.applyDelta(r), e.set(n, t), n;
	},
	Xwe = (t, e) => {
		const n = new ci(t.type.name);
		for (const r in t.attrs) {
			const i = t.attrs[r];
			i !== null && r !== "ychange" && n.setAttribute(r, i);
		}
		return (
			n.insert(
				0,
				P3(t).map((r) => nE(r, e)),
			),
			e.set(n, t),
			n
		);
	},
	nE = (t, e) => (t instanceof Array ? Jwe(t, e) : Xwe(t, e)),
	C7 = (t) => typeof t == "object" && t !== null,
	K5 = (t, e) => {
		const n = Object.keys(t).filter((i) => t[i] !== null);
		let r = n.length === Object.keys(e).filter((i) => e[i] !== null).length;
		for (let i = 0; i < n.length && r; i++) {
			const o = n[i],
				s = t[o],
				a = e[o];
			r = o === "ychange" || s === a || (C7(s) && C7(a) && K5(s, a));
		}
		return r;
	},
	P3 = (t) => {
		const e = t.content.content,
			n = [];
		for (let r = 0; r < e.length; r++) {
			const i = e[r];
			if (i.isText) {
				const o = [];
				for (let s = e[r]; r < e.length && s.isText; s = e[++r])
					o.push(s);
				r--, n.push(o);
			} else n.push(i);
		}
		return n;
	},
	Wq = (t, e) => {
		const n = t.toDelta();
		return (
			n.length === e.length &&
			n.every(
				(r, i) =>
					r.insert === e[i].text &&
					$S(r.attributes || {}).length === e[i].marks.length &&
					e[i].marks.every((o) =>
						K5(r.attributes[o.type.name] || {}, o.attrs),
					),
			)
		);
	},
	Ng = (t, e) => {
		if (t instanceof ci && !(e instanceof Array) && rE(t, e)) {
			const n = P3(e);
			return (
				t._length === n.length &&
				K5(t.getAttributes(), e.attrs) &&
				t.toArray().every((r, i) => Ng(r, n[i]))
			);
		}
		return t instanceof lo && e instanceof Array && Wq(t, e);
	},
	Ay = (t, e) =>
		t === e ||
		(t instanceof Array &&
			e instanceof Array &&
			t.length === e.length &&
			t.every((n, r) => e[r] === n)),
	w7 = (t, e, n) => {
		const r = t.toArray(),
			i = P3(e),
			o = i.length,
			s = r.length,
			a = Su(s, o);
		let l = 0,
			u = 0,
			c = !1;
		for (; l < a; l++) {
			const d = r[l],
				f = i[l];
			if (Ay(n.get(d), f)) c = !0;
			else if (!Ng(d, f)) break;
		}
		for (; l + u < a; u++) {
			const d = r[s - u - 1],
				f = i[o - u - 1];
			if (Ay(n.get(d), f)) c = !0;
			else if (!Ng(d, f)) break;
		}
		return { equalityFactor: l + u, foundMappedChild: c };
	},
	Zwe = (t) => {
		let e = "",
			n = t._start;
		const r = {};
		for (; n !== null; )
			n.deleted ||
				(n.countable && n.content instanceof Bs
					? (e += n.content.str)
					: n.content instanceof Yn && (r[n.content.key] = null)),
				(n = n.right);
		return { str: e, nAttrs: r };
	},
	Qwe = (t, e, n) => {
		n.set(t, e);
		const { nAttrs: r, str: i } = Zwe(t),
			o = e.map((u) => ({
				insert: u.text,
				attributes: Object.assign({}, r, qq(u.marks)),
			})),
			{
				insert: s,
				remove: a,
				index: l,
			} = Kwe(i, o.map((u) => u.insert).join(""));
		t.delete(l, a),
			t.insert(l, s),
			t.applyDelta(
				o.map((u) => ({
					retain: u.insert.length,
					attributes: u.attributes,
				})),
			);
	},
	qq = (t) => {
		const e = {};
		return (
			t.forEach((n) => {
				n.type.name !== "ychange" && (e[n.type.name] = n.attrs);
			}),
			e
		);
	},
	$y = (t, e, n, r) => {
		if (e instanceof ci && e.nodeName !== n.type.name)
			throw new Error("node name mismatch!");
		if ((r.set(e, n), e instanceof ci)) {
			const d = e.getAttributes(),
				f = n.attrs;
			for (const h in f)
				f[h] !== null
					? d[h] !== f[h] &&
						h !== "ychange" &&
						e.setAttribute(h, f[h])
					: e.removeAttribute(h);
			for (const h in d) f[h] === void 0 && e.removeAttribute(h);
		}
		const i = P3(n),
			o = i.length,
			s = e.toArray(),
			a = s.length,
			l = Su(o, a);
		let u = 0,
			c = 0;
		for (; u < l; u++) {
			const d = s[u],
				f = i[u];
			if (!Ay(r.get(d), f))
				if (Ng(d, f)) r.set(d, f);
				else break;
		}
		for (; c + u + 1 < l; c++) {
			const d = s[a - c - 1],
				f = i[o - c - 1];
			if (!Ay(r.get(d), f))
				if (Ng(d, f)) r.set(d, f);
				else break;
		}
		t.transact(() => {
			for (; a - u - c > 0 && o - u - c > 0; ) {
				const f = s[u],
					h = i[u],
					p = s[a - c - 1],
					g = i[o - c - 1];
				if (f instanceof lo && h instanceof Array)
					Wq(f, h) || Qwe(f, h, r), (u += 1);
				else {
					let v = f instanceof ci && rE(f, h),
						b = p instanceof ci && rE(p, g);
					if (v && b) {
						const y = w7(f, h, r),
							x = w7(p, g, r);
						y.foundMappedChild && !x.foundMappedChild
							? (b = !1)
							: (!y.foundMappedChild && x.foundMappedChild) ||
								  y.equalityFactor < x.equalityFactor
								? (v = !1)
								: (b = !1);
					}
					v
						? ($y(t, f, h, r), (u += 1))
						: b
							? ($y(t, p, g, r), (c += 1))
							: (r.delete(e.get(u)),
								e.delete(u, 1),
								e.insert(u, [nE(h, r)]),
								(u += 1));
				}
			}
			const d = a - u - c;
			if (
				(a === 1 && o === 0 && s[0] instanceof lo
					? (r.delete(s[0]), s[0].delete(0, s[0].length))
					: d > 0 &&
						(e.slice(u, u + d).forEach((f) => r.delete(f)),
						e.delete(u, d)),
				u + c < o)
			) {
				const f = [];
				for (let h = u; h < o - c; h++) f.push(nE(i[h], r));
				e.insert(u, f);
			}
		}, dn);
	},
	rE = (t, e) => !(e instanceof Array) && t.nodeName === e.type.name;
let Im = null;
const e2e = () => {
		const t = Im;
		(Im = null),
			t.forEach((e, n) => {
				const r = n.state.tr,
					i = dn.getState(n.state);
				i &&
					i.binding &&
					!i.binding.isDestroyed &&
					(e.forEach((o, s) => {
						r.setMeta(s, o);
					}),
					n.dispatch(r));
			});
	},
	t2e = (t, e, n) => {
		Im || ((Im = new Map()), FS(0, e2e)), Ms(Im, t, hi).set(e, n);
	},
	Ty = (t, e, n) => {
		if (t === 0) return $k(e, 0, -1);
		let r = e._first === null ? null : e._first.content.type;
		for (; r !== null && e !== r; ) {
			if (r instanceof lo) {
				if (r._length >= t) return $k(r, t, -1);
				if (
					((t -= r._length),
					r._item !== null && r._item.next !== null)
				)
					r = r._item.next.content.type;
				else {
					do (r = r._item === null ? null : r._item.parent), t--;
					while (
						r !== e &&
						r !== null &&
						r._item !== null &&
						r._item.next === null
					);
					r !== null &&
						r !== e &&
						(r =
							r._item === null
								? null
								: r._item.next.content.type);
				}
			} else {
				const i = (n.get(r) || { nodeSize: 0 }).nodeSize;
				if (r._first !== null && t < i)
					(r = r._first.content.type), t--;
				else {
					if (t === 1 && r._length === 0 && i > 1)
						return new mg(
							r._item === null ? null : r._item.id,
							r._item === null ? hg(r) : null,
							null,
						);
					if (((t -= i), r._item !== null && r._item.next !== null))
						r = r._item.next.content.type;
					else {
						if (t === 0)
							return (
								(r = r._item === null ? r : r._item.parent),
								new mg(
									r._item === null ? null : r._item.id,
									r._item === null ? hg(r) : null,
									null,
								)
							);
						do (r = r._item.parent), t--;
						while (r !== e && r._item.next === null);
						r !== e && (r = r._item.next.content.type);
					}
				}
			}
			if (r === null) throw go();
			if (t === 0 && r.constructor !== lo && r !== e)
				return n2e(r._item.parent, r._item);
		}
		return $k(e, e._length, -1);
	},
	n2e = (t, e) => {
		let n = null,
			r = null;
		return (
			t._item === null
				? (r = hg(t))
				: (n = gt(t._item.id.client, t._item.id.clock)),
			new mg(n, r, e.id)
		);
	},
	Rg = (t, e, n, r) => {
		const i = I0e(n, t);
		if (i === null || (i.type !== e && !pg(e, i.type._item))) return null;
		let o = i.type,
			s = 0;
		if (o.constructor === lo) s = i.index;
		else if (o._item === null || !o._item.deleted) {
			let a = o._first,
				l = 0;
			for (; l < o._length && l < i.index && a !== null; ) {
				if (!a.deleted) {
					const u = a.content.type;
					l++,
						u instanceof lo
							? (s += u._length)
							: (s += r.get(u).nodeSize);
				}
				a = a.right;
			}
			s += 1;
		}
		for (; o !== e && o._item !== null; ) {
			const a = o._item.parent;
			if (a._item === null || !a._item.deleted) {
				s += 1;
				let l = a._first;
				for (; l !== null; ) {
					const u = l.content.type;
					if (u === o) break;
					l.deleted ||
						(u instanceof lo
							? (s += u._length)
							: (s += r.get(u).nodeSize)),
						(l = l.right);
				}
			}
			o = a;
		}
		return s - 1;
	};
function N3(t, e) {
	const n = e || new Gu(),
		r = n.doc ? n.doc : { transact: (i) => i(void 0) };
	return $y(r, n, t, new Map()), n;
}
function r2e(t, e) {
	const n = i2e(e);
	return ia.fromJSON(t, n);
}
function i2e(t) {
	const e = t.toArray();
	function n(r) {
		let i;
		if (!r.nodeName)
			i = r.toDelta().map((s) => {
				const a = { type: "text", text: s.insert };
				return (
					s.attributes &&
						(a.marks = Object.keys(s.attributes).map((l) => {
							const u = s.attributes[l],
								c = { type: l };
							return Object.keys(u) && (c.attrs = u), c;
						})),
					a
				);
			});
		else {
			i = { type: r.nodeName };
			const o = r.getAttributes();
			Object.keys(o).length && (i.attrs = o);
			const s = r.toArray();
			s.length && (i.content = s.map(n).flat());
		}
		return i;
	}
	return { type: "doc", content: e.map(n) };
}
const o2e = (t, e, n) => t !== e,
	s2e = (t) => {
		const e = document.createElement("span");
		e.classList.add("ProseMirror-yjs-cursor"),
			e.setAttribute("style", `border-color: ${t.color}`);
		const n = document.createElement("div");
		n.setAttribute("style", `background-color: ${t.color}`),
			n.insertBefore(document.createTextNode(t.name), null);
		const r = document.createTextNode("⁠"),
			i = document.createTextNode("⁠");
		return (
			e.insertBefore(r, null),
			e.insertBefore(n, null),
			e.insertBefore(i, null),
			e
		);
	},
	a2e = (t) => ({
		style: `background-color: ${t.color}70`,
		class: "ProseMirror-yjs-selection",
	}),
	l2e = /^#[0-9a-fA-F]{6}$/,
	E7 = (t, e, n, r, i) => {
		const o = dn.getState(t),
			s = o.doc,
			a = [];
		return o.snapshot != null ||
			o.prevSnapshot != null ||
			o.binding.mapping.size === 0
			? qt.create(t.doc, [])
			: (e.getStates().forEach((l, u) => {
					if (n(s.clientID, u, l) && l.cursor != null) {
						const c = l.user || {};
						c.color == null
							? (c.color = "#ffa500")
							: l2e.test(c.color) ||
								console.warn(
									"A user uses an unsupported color format",
									c,
								),
							c.name == null && (c.name = `User: ${u}`);
						let d = Rg(
								s,
								o.type,
								Dm(l.cursor.anchor),
								o.binding.mapping,
							),
							f = Rg(
								s,
								o.type,
								Dm(l.cursor.head),
								o.binding.mapping,
							);
						if (d !== null && f !== null) {
							const h = yl(t.doc.content.size - 1, 0);
							(d = Su(d, h)),
								(f = Su(f, h)),
								a.push(
									Hn.widget(f, () => r(c), {
										key: u + "",
										side: 10,
									}),
								);
							const p = Su(d, f),
								g = yl(d, f);
							a.push(
								Hn.inline(p, g, i(c), {
									inclusiveEnd: !0,
									inclusiveStart: !1,
								}),
							);
						}
					}
				}),
				qt.create(t.doc, a));
	},
	u2e = (
		t,
		{
			awarenessStateFilter: e = o2e,
			cursorBuilder: n = s2e,
			selectionBuilder: r = a2e,
			getSelection: i = (s) => s.selection,
		} = {},
		o = "cursor",
	) =>
		new Gn({
			key: cm,
			state: {
				init(s, a) {
					return E7(a, t, e, n, r);
				},
				apply(s, a, l, u) {
					const c = dn.getState(u),
						d = s.getMeta(cm);
					return (c && c.isChangeOrigin) || (d && d.awarenessUpdated)
						? E7(u, t, e, n, r)
						: a.map(s.mapping, s.doc);
				},
			},
			props: { decorations: (s) => cm.getState(s) },
			view: (s) => {
				const a = () => {
						s.docView && t2e(s, cm, { awarenessUpdated: !0 });
					},
					l = () => {
						const u = dn.getState(s.state),
							c = t.getLocalState() || {};
						if (s.hasFocus()) {
							const d = i(s.state),
								f = Ty(d.anchor, u.type, u.binding.mapping),
								h = Ty(d.head, u.type, u.binding.mapping);
							(c.cursor == null ||
								!CB(Dm(c.cursor.anchor), f) ||
								!CB(Dm(c.cursor.head), h)) &&
								t.setLocalStateField(o, { anchor: f, head: h });
						} else
							c.cursor != null &&
								Rg(
									u.doc,
									u.type,
									Dm(c.cursor.anchor),
									u.binding.mapping,
								) !== null &&
								t.setLocalStateField(o, null);
					};
				return (
					t.on("change", a),
					s.dom.addEventListener("focusin", l),
					s.dom.addEventListener("focusout", l),
					{
						update: l,
						destroy: () => {
							s.dom.removeEventListener("focusin", l),
								s.dom.removeEventListener("focusout", l),
								t.off("change", a),
								t.setLocalStateField(o, null);
						},
					}
				);
			},
		}),
	c2e = (t) => {
		const e = ad.getState(t).undoManager;
		if (e != null) return e.undo(), !0;
	},
	D7 = (t) => {
		const e = ad.getState(t).undoManager;
		if (e != null) return e.redo(), !0;
	},
	d2e = new Set(["paragraph"]),
	f2e = (t, e) =>
		!(t instanceof Qt) ||
		!(t.content instanceof js) ||
		!(
			t.content.type instanceof qu ||
			(t.content.type instanceof ci && e.has(t.content.type.nodeName))
		) ||
		t.content.type._length === 0,
	h2e = ({
		protectedNodes: t = d2e,
		trackedOrigins: e = [],
		undoManager: n = null,
	} = {}) =>
		new Gn({
			key: ad,
			state: {
				init: (r, i) => {
					const o = dn.getState(i),
						s =
							n ||
							new bK(o.type, {
								trackedOrigins: new Set([dn].concat(e)),
								deleteFilter: (a) => f2e(a, t),
								captureTransaction: (a) =>
									a.meta.get("addToHistory") !== !1,
							});
					return {
						undoManager: s,
						prevSel: null,
						hasUndoOps: s.undoStack.length > 0,
						hasRedoOps: s.redoStack.length > 0,
					};
				},
				apply: (r, i, o, s) => {
					const a = dn.getState(s).binding,
						l = i.undoManager,
						u = l.undoStack.length > 0,
						c = l.redoStack.length > 0;
					return a
						? {
								undoManager: l,
								prevSel: tE(a, o),
								hasUndoOps: u,
								hasRedoOps: c,
							}
						: u !== i.hasUndoOps || c !== i.hasRedoOps
							? Object.assign({}, i, {
									hasUndoOps: l.undoStack.length > 0,
									hasRedoOps: l.redoStack.length > 0,
								})
							: i;
				},
			},
			view: (r) => {
				const i = dn.getState(r.state),
					o = ad.getState(r.state).undoManager;
				return (
					o.on("stack-item-added", ({ stackItem: s }) => {
						const a = i.binding;
						a && s.meta.set(a, ad.getState(r.state).prevSel);
					}),
					o.on("stack-item-popped", ({ stackItem: s }) => {
						const a = i.binding;
						a &&
							(a.beforeTransactionSelection =
								s.meta.get(a) || a.beforeTransactionSelection);
					}),
					{
						destroy: () => {
							o.destroy();
						},
					}
				);
			},
		}),
	Gq = m.jsxs(m.Fragment, {
		children: [
			m.jsx("rect", { width: 18, height: 18, x: 3, y: 3, rx: 2, ry: 2 }),
			m.jsx("path", { d: "M3 9h18M3 15h18M9 9v12M15 9v12" }),
		],
	}),
	S7 = (t) => typeof t == "object" && t != null && t.nodeType === 1,
	A7 = (t, e) => (!e || t !== "hidden") && t !== "visible" && t !== "clip",
	sC = (t, e) => {
		if (t.clientHeight < t.scrollHeight || t.clientWidth < t.scrollWidth) {
			const n = getComputedStyle(t, null);
			return (
				A7(n.overflowY, e) ||
				A7(n.overflowX, e) ||
				((r) => {
					const i = ((o) => {
						if (!o.ownerDocument || !o.ownerDocument.defaultView)
							return null;
						try {
							return o.ownerDocument.defaultView.frameElement;
						} catch {
							return null;
						}
					})(r);
					return (
						!!i &&
						(i.clientHeight < r.scrollHeight ||
							i.clientWidth < r.scrollWidth)
					);
				})(t)
			);
		}
		return !1;
	},
	H1 = (t, e, n, r, i, o, s, a) =>
		(o < t && s > e) || (o > t && s < e)
			? 0
			: (o <= t && a <= n) || (s >= e && a >= n)
				? o - t - r
				: (s > e && a < n) || (o < t && a > n)
					? s - e + i
					: 0,
	p2e = (t) => {
		const e = t.parentElement;
		return e ?? (t.getRootNode().host || null);
	},
	$7 = (t, e) => {
		var n, r, i, o;
		if (typeof document > "u") return [];
		const {
				scrollMode: s,
				block: a,
				inline: l,
				boundary: u,
				skipOverflowHiddenElements: c,
			} = e,
			d = typeof u == "function" ? u : (_) => _ !== u;
		if (!S7(t)) throw new TypeError("Invalid target");
		const f = document.scrollingElement || document.documentElement,
			h = [];
		let p = t;
		for (; S7(p) && d(p); ) {
			if (((p = p2e(p)), p === f)) {
				h.push(p);
				break;
			}
			(p != null &&
				p === document.body &&
				sC(p) &&
				!sC(document.documentElement)) ||
				(p != null && sC(p, c) && h.push(p));
		}
		const g =
				(r = (n = window.visualViewport) == null ? void 0 : n.width) !=
				null
					? r
					: innerWidth,
			v =
				(o = (i = window.visualViewport) == null ? void 0 : i.height) !=
				null
					? o
					: innerHeight,
			{ scrollX: b, scrollY: y } = window,
			{
				height: x,
				width: C,
				top: k,
				right: w,
				bottom: D,
				left: S,
			} = t.getBoundingClientRect(),
			{
				top: $,
				right: A,
				bottom: T,
				left: I,
			} = ((_) => {
				const j = window.getComputedStyle(_);
				return {
					top: parseFloat(j.scrollMarginTop) || 0,
					right: parseFloat(j.scrollMarginRight) || 0,
					bottom: parseFloat(j.scrollMarginBottom) || 0,
					left: parseFloat(j.scrollMarginLeft) || 0,
				};
			})(t);
		let F =
				a === "start" || a === "nearest"
					? k - $
					: a === "end"
						? D + T
						: k + x / 2 - $ + T,
			N =
				l === "center"
					? S + C / 2 - I + A
					: l === "end"
						? w + A
						: S - I;
		const O = [];
		for (let _ = 0; _ < h.length; _++) {
			const j = h[_],
				{
					height: V,
					width: K,
					top: M,
					right: G,
					bottom: H,
					left: P,
				} = j.getBoundingClientRect();
			if (
				s === "if-needed" &&
				k >= 0 &&
				S >= 0 &&
				D <= v &&
				w <= g &&
				k >= M &&
				D <= H &&
				S >= P &&
				w <= G
			)
				return O;
			const q = getComputedStyle(j),
				J = parseInt(q.borderLeftWidth, 10),
				Z = parseInt(q.borderTopWidth, 10),
				oe = parseInt(q.borderRightWidth, 10),
				ne = parseInt(q.borderBottomWidth, 10);
			let de = 0,
				se = 0;
			const re =
					"offsetWidth" in j
						? j.offsetWidth - j.clientWidth - J - oe
						: 0,
				he =
					"offsetHeight" in j
						? j.offsetHeight - j.clientHeight - Z - ne
						: 0,
				ye =
					"offsetWidth" in j
						? j.offsetWidth === 0
							? 0
							: K / j.offsetWidth
						: 0,
				Ae =
					"offsetHeight" in j
						? j.offsetHeight === 0
							? 0
							: V / j.offsetHeight
						: 0;
			if (f === j)
				(de =
					a === "start"
						? F
						: a === "end"
							? F - v
							: a === "nearest"
								? H1(y, y + v, v, Z, ne, y + F, y + F + x, x)
								: F - v / 2),
					(se =
						l === "start"
							? N
							: l === "center"
								? N - g / 2
								: l === "end"
									? N - g
									: H1(
											b,
											b + g,
											g,
											J,
											oe,
											b + N,
											b + N + C,
											C,
										)),
					(de = Math.max(0, de + y)),
					(se = Math.max(0, se + b));
			else {
				(de =
					a === "start"
						? F - M - Z
						: a === "end"
							? F - H + ne + he
							: a === "nearest"
								? H1(M, H, V, Z, ne + he, F, F + x, x)
								: F - (M + V / 2) + he / 2),
					(se =
						l === "start"
							? N - P - J
							: l === "center"
								? N - (P + K / 2) + re / 2
								: l === "end"
									? N - G + oe + re
									: H1(P, G, K, J, oe + re, N, N + C, C));
				const { scrollLeft: Pe, scrollTop: we } = j;
				(de =
					Ae === 0
						? 0
						: Math.max(
								0,
								Math.min(
									we + de / Ae,
									j.scrollHeight - V / Ae + he,
								),
							)),
					(se =
						ye === 0
							? 0
							: Math.max(
									0,
									Math.min(
										Pe + se / ye,
										j.scrollWidth - K / ye + re,
									),
								)),
					(F += we - de),
					(N += Pe - se);
			}
			O.push({ el: j, top: de, left: se });
		}
		return O;
	},
	m2e = (t) =>
		t === !1
			? { block: "end", inline: "nearest" }
			: ((e) => e === Object(e) && Object.keys(e).length !== 0)(t)
				? t
				: { block: "start", inline: "nearest" };
function g2e(t, e) {
	if (
		!t.isConnected ||
		!((i) => {
			let o = i;
			for (; o && o.parentNode; ) {
				if (o.parentNode === document) return !0;
				o =
					o.parentNode instanceof ShadowRoot
						? o.parentNode.host
						: o.parentNode;
			}
			return !1;
		})(t)
	)
		return;
	const n = ((i) => {
		const o = window.getComputedStyle(i);
		return {
			top: parseFloat(o.scrollMarginTop) || 0,
			right: parseFloat(o.scrollMarginRight) || 0,
			bottom: parseFloat(o.scrollMarginBottom) || 0,
			left: parseFloat(o.scrollMarginLeft) || 0,
		};
	})(t);
	if (((i) => typeof i == "object" && typeof i.behavior == "function")(e))
		return e.behavior($7(t, e));
	const r = typeof e == "boolean" || e == null ? void 0 : e.behavior;
	for (const { el: i, top: o, left: s } of $7(t, m2e(e))) {
		const a = o - n.top + n.bottom,
			l = s - n.left + n.right;
		i.scroll({ top: a, left: l, behavior: r });
	}
}
var b2e = {
		isHistory(t) {
			return (
				Ar(t) &&
				Array.isArray(t.redos) &&
				Array.isArray(t.undos) &&
				(t.redos.length === 0 ||
					bu.isOperationList(t.redos[0].operations)) &&
				(t.undos.length === 0 ||
					bu.isOperationList(t.undos[0].operations))
			);
		},
	},
	aC = new WeakMap(),
	lC = new WeakMap(),
	Uf = {
		isHistoryEditor(t) {
			return b2e.isHistory(t.history) && R.isEditor(t);
		},
		isMerging(t) {
			return lC.get(t);
		},
		isSaving(t) {
			return aC.get(t);
		},
		redo(t) {
			t.redo();
		},
		undo(t) {
			t.undo();
		},
		withoutMerging(t, e) {
			var n = Uf.isMerging(t);
			lC.set(t, !1), e(), lC.set(t, n);
		},
		withoutSaving(t, e) {
			var n = Uf.isSaving(t);
			aC.set(t, !1), e(), aC.set(t, n);
		},
	},
	v2e = (t) => {
		var e = t,
			{ apply: n } = e;
		return (
			(e.history = { undos: [], redos: [] }),
			(e.redo = () => {
				var { history: r } = e,
					{ redos: i } = r;
				if (i.length > 0) {
					var o = i[i.length - 1];
					o.selectionBefore && W.setSelection(e, o.selectionBefore),
						Uf.withoutSaving(e, () => {
							R.withoutNormalizing(e, () => {
								for (var s of o.operations) e.apply(s);
							});
						}),
						r.redos.pop(),
						r.undos.push(o);
				}
			}),
			(e.undo = () => {
				var { history: r } = e,
					{ undos: i } = r;
				if (i.length > 0) {
					var o = i[i.length - 1];
					Uf.withoutSaving(e, () => {
						R.withoutNormalizing(e, () => {
							var s = o.operations.map(bu.inverse).reverse();
							for (var a of s) e.apply(a);
							o.selectionBefore &&
								W.setSelection(e, o.selectionBefore);
						});
					}),
						r.redos.push(o),
						r.undos.pop();
				}
			}),
			(e.apply = (r) => {
				var { operations: i, history: o } = e,
					{ undos: s } = o,
					a = s[s.length - 1],
					l = a && a.operations[a.operations.length - 1],
					u = Uf.isSaving(e),
					c = Uf.isMerging(e);
				if ((u == null && (u = x2e(r)), u)) {
					if (
						(c == null &&
							(a == null
								? (c = !1)
								: i.length !== 0
									? (c = !0)
									: (c = y2e(r, l))),
						a && c)
					)
						a.operations.push(r);
					else {
						var d = {
							operations: [r],
							selectionBefore: e.selection,
						};
						s.push(d);
					}
					for (; s.length > 100; ) s.shift();
					o.redos = [];
				}
				n(r);
			}),
			e
		);
	},
	y2e = (t, e) =>
		!!(
			(e &&
				t.type === "insert_text" &&
				e.type === "insert_text" &&
				t.offset === e.offset + e.text.length &&
				Y.equals(t.path, e.path)) ||
			(e &&
				t.type === "remove_text" &&
				e.type === "remove_text" &&
				t.offset + t.text.length === e.offset &&
				Y.equals(t.path, e.path))
		),
	x2e = (t, e) => t.type !== "set_selection";
const k2e = {};
function U5(t, e) {
	const n = k2e,
		r = typeof n.includeImageAlt == "boolean" ? n.includeImageAlt : !0,
		i = typeof n.includeHtml == "boolean" ? n.includeHtml : !0;
	return Yq(t, r, i);
}
function Yq(t, e, n) {
	if (C2e(t)) {
		if ("value" in t) return t.type === "html" && !n ? "" : t.value;
		if (e && "alt" in t && t.alt) return t.alt;
		if ("children" in t) return T7(t.children, e, n);
	}
	return Array.isArray(t) ? T7(t, e, n) : "";
}
function T7(t, e, n) {
	const r = [];
	let i = -1;
	for (; ++i < t.length; ) r[i] = Yq(t[i], e, n);
	return r.join("");
}
function C2e(t) {
	return !!(t && typeof t == "object");
}
const B7 = document.createElement("i");
function Og(t) {
	const e = "&" + t + ";";
	B7.innerHTML = e;
	const n = B7.textContent;
	return (n.charCodeAt(n.length - 1) === 59 && t !== "semi") || n === e
		? !1
		: n;
}
function Uo(t, e, n, r) {
	const i = t.length;
	let o = 0,
		s;
	if (
		(e < 0 ? (e = -e > i ? 0 : i + e) : (e = e > i ? i : e),
		(n = n > 0 ? n : 0),
		r.length < 1e4)
	)
		(s = Array.from(r)), s.unshift(e, n), t.splice(...s);
	else
		for (n && t.splice(e, n); o < r.length; )
			(s = r.slice(o, o + 1e4)),
				s.unshift(e, 0),
				t.splice(...s),
				(o += 1e4),
				(e += 1e4);
}
function Fo(t, e) {
	return t.length > 0 ? (Uo(t, t.length, 0, e), t) : e;
}
const I7 = {}.hasOwnProperty;
function H5(t) {
	const e = {};
	let n = -1;
	for (; ++n < t.length; ) w2e(e, t[n]);
	return e;
}
function w2e(t, e) {
	let n;
	for (n in e) {
		const i = (I7.call(t, n) ? t[n] : void 0) || (t[n] = {}),
			o = e[n];
		let s;
		if (o)
			for (s in o) {
				I7.call(i, s) || (i[s] = []);
				const a = o[s];
				E2e(i[s], Array.isArray(a) ? a : a ? [a] : []);
			}
	}
}
function E2e(t, e) {
	let n = -1;
	const r = [];
	for (; ++n < e.length; ) (e[n].add === "after" ? t : r).push(e[n]);
	Uo(t, 0, 0, r);
}
function Jq(t, e) {
	const n = Number.parseInt(t, e);
	return n < 9 ||
		n === 11 ||
		(n > 13 && n < 32) ||
		(n > 126 && n < 160) ||
		(n > 55295 && n < 57344) ||
		(n > 64975 && n < 65008) ||
		(n & 65535) === 65535 ||
		(n & 65535) === 65534 ||
		n > 1114111
		? "�"
		: String.fromCodePoint(n);
}
function Ds(t) {
	return t
		.replace(/[\t\n\r ]+/g, " ")
		.replace(/^ | $/g, "")
		.toLowerCase()
		.toUpperCase();
}
const Vr = sc(/[A-Za-z]/),
	Oi = sc(/[\dA-Za-z]/),
	D2e = sc(/[#-'*+\--9=?A-Z^-~]/);
function By(t) {
	return t !== null && (t < 32 || t === 127);
}
const iE = sc(/\d/),
	S2e = sc(/[\dA-Fa-f]/),
	A2e = sc(/[!-/:-@[-`{-~]/);
function He(t) {
	return t !== null && t < -2;
}
function It(t) {
	return t !== null && (t < 0 || t === 32);
}
function xt(t) {
	return t === -2 || t === -1 || t === 32;
}
const R3 = sc(new RegExp("\\p{P}|\\p{S}", "u")),
	ai = sc(/\s/);
function sc(t) {
	return e;
	function e(n) {
		return n !== null && n > -1 && t.test(String.fromCharCode(n));
	}
}
function At(t, e, n, r) {
	const i = r ? r - 1 : Number.POSITIVE_INFINITY;
	let o = 0;
	return s;
	function s(l) {
		return xt(l) ? (t.enter(n), a(l)) : e(l);
	}
	function a(l) {
		return xt(l) && o++ < i ? (t.consume(l), a) : (t.exit(n), e(l));
	}
}
const $2e = { tokenize: T2e };
function T2e(t) {
	const e = t.attempt(this.parser.constructs.contentInitial, r, i);
	let n;
	return e;
	function r(a) {
		if (a === null) {
			t.consume(a);
			return;
		}
		return (
			t.enter("lineEnding"),
			t.consume(a),
			t.exit("lineEnding"),
			At(t, e, "linePrefix")
		);
	}
	function i(a) {
		return t.enter("paragraph"), o(a);
	}
	function o(a) {
		const l = t.enter("chunkText", { contentType: "text", previous: n });
		return n && (n.next = l), (n = l), s(a);
	}
	function s(a) {
		if (a === null) {
			t.exit("chunkText"), t.exit("paragraph"), t.consume(a);
			return;
		}
		return He(a)
			? (t.consume(a), t.exit("chunkText"), o)
			: (t.consume(a), s);
	}
}
const B2e = { tokenize: I2e },
	F7 = { tokenize: F2e };
function I2e(t) {
	const e = this,
		n = [];
	let r = 0,
		i,
		o,
		s;
	return a;
	function a(x) {
		if (r < n.length) {
			const C = n[r];
			return (
				(e.containerState = C[1]), t.attempt(C[0].continuation, l, u)(x)
			);
		}
		return u(x);
	}
	function l(x) {
		if ((r++, e.containerState._closeFlow)) {
			(e.containerState._closeFlow = void 0), i && y();
			const C = e.events.length;
			let k = C,
				w;
			for (; k--; )
				if (
					e.events[k][0] === "exit" &&
					e.events[k][1].type === "chunkFlow"
				) {
					w = e.events[k][1].end;
					break;
				}
			b(r);
			let D = C;
			for (; D < e.events.length; )
				(e.events[D][1].end = Object.assign({}, w)), D++;
			return (
				Uo(e.events, k + 1, 0, e.events.slice(C)),
				(e.events.length = D),
				u(x)
			);
		}
		return a(x);
	}
	function u(x) {
		if (r === n.length) {
			if (!i) return f(x);
			if (i.currentConstruct && i.currentConstruct.concrete) return p(x);
			e.interrupt = !!(
				i.currentConstruct && !i._gfmTableDynamicInterruptHack
			);
		}
		return (e.containerState = {}), t.check(F7, c, d)(x);
	}
	function c(x) {
		return i && y(), b(r), f(x);
	}
	function d(x) {
		return (
			(e.parser.lazy[e.now().line] = r !== n.length),
			(s = e.now().offset),
			p(x)
		);
	}
	function f(x) {
		return (e.containerState = {}), t.attempt(F7, h, p)(x);
	}
	function h(x) {
		return r++, n.push([e.currentConstruct, e.containerState]), f(x);
	}
	function p(x) {
		if (x === null) {
			i && y(), b(0), t.consume(x);
			return;
		}
		return (
			(i = i || e.parser.flow(e.now())),
			t.enter("chunkFlow", {
				contentType: "flow",
				previous: o,
				_tokenizer: i,
			}),
			g(x)
		);
	}
	function g(x) {
		if (x === null) {
			v(t.exit("chunkFlow"), !0), b(0), t.consume(x);
			return;
		}
		return He(x)
			? (t.consume(x),
				v(t.exit("chunkFlow")),
				(r = 0),
				(e.interrupt = void 0),
				a)
			: (t.consume(x), g);
	}
	function v(x, C) {
		const k = e.sliceStream(x);
		if (
			(C && k.push(null),
			(x.previous = o),
			o && (o.next = x),
			(o = x),
			i.defineSkip(x.start),
			i.write(k),
			e.parser.lazy[x.start.line])
		) {
			let w = i.events.length;
			for (; w--; )
				if (
					i.events[w][1].start.offset < s &&
					(!i.events[w][1].end || i.events[w][1].end.offset > s)
				)
					return;
			const D = e.events.length;
			let S = D,
				$,
				A;
			for (; S--; )
				if (
					e.events[S][0] === "exit" &&
					e.events[S][1].type === "chunkFlow"
				) {
					if ($) {
						A = e.events[S][1].end;
						break;
					}
					$ = !0;
				}
			for (b(r), w = D; w < e.events.length; )
				(e.events[w][1].end = Object.assign({}, A)), w++;
			Uo(e.events, S + 1, 0, e.events.slice(D)), (e.events.length = w);
		}
	}
	function b(x) {
		let C = n.length;
		for (; C-- > x; ) {
			const k = n[C];
			(e.containerState = k[1]), k[0].exit.call(e, t);
		}
		n.length = x;
	}
	function y() {
		i.write([null]),
			(o = void 0),
			(i = void 0),
			(e.containerState._closeFlow = void 0);
	}
}
function F2e(t, e, n) {
	return At(
		t,
		t.attempt(this.parser.constructs.document, e, n),
		"linePrefix",
		this.parser.constructs.disable.null.includes("codeIndented")
			? void 0
			: 4,
	);
}
function Iy(t) {
	if (t === null || It(t) || ai(t)) return 1;
	if (R3(t)) return 2;
}
function O3(t, e, n) {
	const r = [];
	let i = -1;
	for (; ++i < t.length; ) {
		const o = t[i].resolveAll;
		o && !r.includes(o) && ((e = o(e, n)), r.push(o));
	}
	return e;
}
const oE = { name: "attention", tokenize: N2e, resolveAll: P2e };
function P2e(t, e) {
	let n = -1,
		r,
		i,
		o,
		s,
		a,
		l,
		u,
		c;
	for (; ++n < t.length; )
		if (
			t[n][0] === "enter" &&
			t[n][1].type === "attentionSequence" &&
			t[n][1]._close
		) {
			for (r = n; r--; )
				if (
					t[r][0] === "exit" &&
					t[r][1].type === "attentionSequence" &&
					t[r][1]._open &&
					e.sliceSerialize(t[r][1]).charCodeAt(0) ===
						e.sliceSerialize(t[n][1]).charCodeAt(0)
				) {
					if (
						(t[r][1]._close || t[n][1]._open) &&
						(t[n][1].end.offset - t[n][1].start.offset) % 3 &&
						!(
							(t[r][1].end.offset -
								t[r][1].start.offset +
								t[n][1].end.offset -
								t[n][1].start.offset) %
							3
						)
					)
						continue;
					l =
						t[r][1].end.offset - t[r][1].start.offset > 1 &&
						t[n][1].end.offset - t[n][1].start.offset > 1
							? 2
							: 1;
					const d = Object.assign({}, t[r][1].end),
						f = Object.assign({}, t[n][1].start);
					P7(d, -l),
						P7(f, l),
						(s = {
							type: l > 1 ? "strongSequence" : "emphasisSequence",
							start: d,
							end: Object.assign({}, t[r][1].end),
						}),
						(a = {
							type: l > 1 ? "strongSequence" : "emphasisSequence",
							start: Object.assign({}, t[n][1].start),
							end: f,
						}),
						(o = {
							type: l > 1 ? "strongText" : "emphasisText",
							start: Object.assign({}, t[r][1].end),
							end: Object.assign({}, t[n][1].start),
						}),
						(i = {
							type: l > 1 ? "strong" : "emphasis",
							start: Object.assign({}, s.start),
							end: Object.assign({}, a.end),
						}),
						(t[r][1].end = Object.assign({}, s.start)),
						(t[n][1].start = Object.assign({}, a.end)),
						(u = []),
						t[r][1].end.offset - t[r][1].start.offset &&
							(u = Fo(u, [
								["enter", t[r][1], e],
								["exit", t[r][1], e],
							])),
						(u = Fo(u, [
							["enter", i, e],
							["enter", s, e],
							["exit", s, e],
							["enter", o, e],
						])),
						(u = Fo(
							u,
							O3(
								e.parser.constructs.insideSpan.null,
								t.slice(r + 1, n),
								e,
							),
						)),
						(u = Fo(u, [
							["exit", o, e],
							["enter", a, e],
							["exit", a, e],
							["exit", i, e],
						])),
						t[n][1].end.offset - t[n][1].start.offset
							? ((c = 2),
								(u = Fo(u, [
									["enter", t[n][1], e],
									["exit", t[n][1], e],
								])))
							: (c = 0),
						Uo(t, r - 1, n - r + 3, u),
						(n = r + u.length - c - 2);
					break;
				}
		}
	for (n = -1; ++n < t.length; )
		t[n][1].type === "attentionSequence" && (t[n][1].type = "data");
	return t;
}
function N2e(t, e) {
	const n = this.parser.constructs.attentionMarkers.null,
		r = this.previous,
		i = Iy(r);
	let o;
	return s;
	function s(l) {
		return (o = l), t.enter("attentionSequence"), a(l);
	}
	function a(l) {
		if (l === o) return t.consume(l), a;
		const u = t.exit("attentionSequence"),
			c = Iy(l),
			d = !c || (c === 2 && i) || n.includes(l),
			f = !i || (i === 2 && c) || n.includes(r);
		return (
			(u._open = !!(o === 42 ? d : d && (i || !f))),
			(u._close = !!(o === 42 ? f : f && (c || !d))),
			e(l)
		);
	}
}
function P7(t, e) {
	(t.column += e), (t.offset += e), (t._bufferIndex += e);
}
const R2e = { name: "autolink", tokenize: O2e };
function O2e(t, e, n) {
	let r = 0;
	return i;
	function i(h) {
		return (
			t.enter("autolink"),
			t.enter("autolinkMarker"),
			t.consume(h),
			t.exit("autolinkMarker"),
			t.enter("autolinkProtocol"),
			o
		);
	}
	function o(h) {
		return Vr(h) ? (t.consume(h), s) : h === 64 ? n(h) : u(h);
	}
	function s(h) {
		return h === 43 || h === 45 || h === 46 || Oi(h)
			? ((r = 1), a(h))
			: u(h);
	}
	function a(h) {
		return h === 58
			? (t.consume(h), (r = 0), l)
			: (h === 43 || h === 45 || h === 46 || Oi(h)) && r++ < 32
				? (t.consume(h), a)
				: ((r = 0), u(h));
	}
	function l(h) {
		return h === 62
			? (t.exit("autolinkProtocol"),
				t.enter("autolinkMarker"),
				t.consume(h),
				t.exit("autolinkMarker"),
				t.exit("autolink"),
				e)
			: h === null || h === 32 || h === 60 || By(h)
				? n(h)
				: (t.consume(h), l);
	}
	function u(h) {
		return h === 64 ? (t.consume(h), c) : D2e(h) ? (t.consume(h), u) : n(h);
	}
	function c(h) {
		return Oi(h) ? d(h) : n(h);
	}
	function d(h) {
		return h === 46
			? (t.consume(h), (r = 0), c)
			: h === 62
				? ((t.exit("autolinkProtocol").type = "autolinkEmail"),
					t.enter("autolinkMarker"),
					t.consume(h),
					t.exit("autolinkMarker"),
					t.exit("autolink"),
					e)
				: f(h);
	}
	function f(h) {
		if ((h === 45 || Oi(h)) && r++ < 63) {
			const p = h === 45 ? f : d;
			return t.consume(h), p;
		}
		return n(h);
	}
}
const mp = { tokenize: M2e, partial: !0 };
function M2e(t, e, n) {
	return r;
	function r(o) {
		return xt(o) ? At(t, i, "linePrefix")(o) : i(o);
	}
	function i(o) {
		return o === null || He(o) ? e(o) : n(o);
	}
}
const Xq = {
	name: "blockQuote",
	tokenize: j2e,
	continuation: { tokenize: _2e },
	exit: z2e,
};
function j2e(t, e, n) {
	const r = this;
	return i;
	function i(s) {
		if (s === 62) {
			const a = r.containerState;
			return (
				a.open ||
					(t.enter("blockQuote", { _container: !0 }), (a.open = !0)),
				t.enter("blockQuotePrefix"),
				t.enter("blockQuoteMarker"),
				t.consume(s),
				t.exit("blockQuoteMarker"),
				o
			);
		}
		return n(s);
	}
	function o(s) {
		return xt(s)
			? (t.enter("blockQuotePrefixWhitespace"),
				t.consume(s),
				t.exit("blockQuotePrefixWhitespace"),
				t.exit("blockQuotePrefix"),
				e)
			: (t.exit("blockQuotePrefix"), e(s));
	}
}
function _2e(t, e, n) {
	const r = this;
	return i;
	function i(s) {
		return xt(s)
			? At(
					t,
					o,
					"linePrefix",
					r.parser.constructs.disable.null.includes("codeIndented")
						? void 0
						: 4,
				)(s)
			: o(s);
	}
	function o(s) {
		return t.attempt(Xq, e, n)(s);
	}
}
function z2e(t) {
	t.exit("blockQuote");
}
const Zq = { name: "characterEscape", tokenize: L2e };
function L2e(t, e, n) {
	return r;
	function r(o) {
		return (
			t.enter("characterEscape"),
			t.enter("escapeMarker"),
			t.consume(o),
			t.exit("escapeMarker"),
			i
		);
	}
	function i(o) {
		return A2e(o)
			? (t.enter("characterEscapeValue"),
				t.consume(o),
				t.exit("characterEscapeValue"),
				t.exit("characterEscape"),
				e)
			: n(o);
	}
}
const Qq = { name: "characterReference", tokenize: V2e };
function V2e(t, e, n) {
	const r = this;
	let i = 0,
		o,
		s;
	return a;
	function a(d) {
		return (
			t.enter("characterReference"),
			t.enter("characterReferenceMarker"),
			t.consume(d),
			t.exit("characterReferenceMarker"),
			l
		);
	}
	function l(d) {
		return d === 35
			? (t.enter("characterReferenceMarkerNumeric"),
				t.consume(d),
				t.exit("characterReferenceMarkerNumeric"),
				u)
			: (t.enter("characterReferenceValue"), (o = 31), (s = Oi), c(d));
	}
	function u(d) {
		return d === 88 || d === 120
			? (t.enter("characterReferenceMarkerHexadecimal"),
				t.consume(d),
				t.exit("characterReferenceMarkerHexadecimal"),
				t.enter("characterReferenceValue"),
				(o = 6),
				(s = S2e),
				c)
			: (t.enter("characterReferenceValue"), (o = 7), (s = iE), c(d));
	}
	function c(d) {
		if (d === 59 && i) {
			const f = t.exit("characterReferenceValue");
			return s === Oi && !Og(r.sliceSerialize(f))
				? n(d)
				: (t.enter("characterReferenceMarker"),
					t.consume(d),
					t.exit("characterReferenceMarker"),
					t.exit("characterReference"),
					e);
		}
		return s(d) && i++ < o ? (t.consume(d), c) : n(d);
	}
}
const N7 = { tokenize: U2e, partial: !0 },
	R7 = { name: "codeFenced", tokenize: K2e, concrete: !0 };
function K2e(t, e, n) {
	const r = this,
		i = { tokenize: k, partial: !0 };
	let o = 0,
		s = 0,
		a;
	return l;
	function l(w) {
		return u(w);
	}
	function u(w) {
		const D = r.events[r.events.length - 1];
		return (
			(o =
				D && D[1].type === "linePrefix"
					? D[2].sliceSerialize(D[1], !0).length
					: 0),
			(a = w),
			t.enter("codeFenced"),
			t.enter("codeFencedFence"),
			t.enter("codeFencedFenceSequence"),
			c(w)
		);
	}
	function c(w) {
		return w === a
			? (s++, t.consume(w), c)
			: s < 3
				? n(w)
				: (t.exit("codeFencedFenceSequence"),
					xt(w) ? At(t, d, "whitespace")(w) : d(w));
	}
	function d(w) {
		return w === null || He(w)
			? (t.exit("codeFencedFence"),
				r.interrupt ? e(w) : t.check(N7, g, C)(w))
			: (t.enter("codeFencedFenceInfo"),
				t.enter("chunkString", { contentType: "string" }),
				f(w));
	}
	function f(w) {
		return w === null || He(w)
			? (t.exit("chunkString"), t.exit("codeFencedFenceInfo"), d(w))
			: xt(w)
				? (t.exit("chunkString"),
					t.exit("codeFencedFenceInfo"),
					At(t, h, "whitespace")(w))
				: w === 96 && w === a
					? n(w)
					: (t.consume(w), f);
	}
	function h(w) {
		return w === null || He(w)
			? d(w)
			: (t.enter("codeFencedFenceMeta"),
				t.enter("chunkString", { contentType: "string" }),
				p(w));
	}
	function p(w) {
		return w === null || He(w)
			? (t.exit("chunkString"), t.exit("codeFencedFenceMeta"), d(w))
			: w === 96 && w === a
				? n(w)
				: (t.consume(w), p);
	}
	function g(w) {
		return t.attempt(i, C, v)(w);
	}
	function v(w) {
		return t.enter("lineEnding"), t.consume(w), t.exit("lineEnding"), b;
	}
	function b(w) {
		return o > 0 && xt(w) ? At(t, y, "linePrefix", o + 1)(w) : y(w);
	}
	function y(w) {
		return w === null || He(w)
			? t.check(N7, g, C)(w)
			: (t.enter("codeFlowValue"), x(w));
	}
	function x(w) {
		return w === null || He(w)
			? (t.exit("codeFlowValue"), y(w))
			: (t.consume(w), x);
	}
	function C(w) {
		return t.exit("codeFenced"), e(w);
	}
	function k(w, D, S) {
		let $ = 0;
		return A;
		function A(O) {
			return w.enter("lineEnding"), w.consume(O), w.exit("lineEnding"), T;
		}
		function T(O) {
			return (
				w.enter("codeFencedFence"),
				xt(O)
					? At(
							w,
							I,
							"linePrefix",
							r.parser.constructs.disable.null.includes(
								"codeIndented",
							)
								? void 0
								: 4,
						)(O)
					: I(O)
			);
		}
		function I(O) {
			return O === a ? (w.enter("codeFencedFenceSequence"), F(O)) : S(O);
		}
		function F(O) {
			return O === a
				? ($++, w.consume(O), F)
				: $ >= s
					? (w.exit("codeFencedFenceSequence"),
						xt(O) ? At(w, N, "whitespace")(O) : N(O))
					: S(O);
		}
		function N(O) {
			return O === null || He(O)
				? (w.exit("codeFencedFence"), D(O))
				: S(O);
		}
	}
}
function U2e(t, e, n) {
	const r = this;
	return i;
	function i(s) {
		return s === null
			? n(s)
			: (t.enter("lineEnding"), t.consume(s), t.exit("lineEnding"), o);
	}
	function o(s) {
		return r.parser.lazy[r.now().line] ? n(s) : e(s);
	}
}
const uC = { name: "codeIndented", tokenize: W2e },
	H2e = { tokenize: q2e, partial: !0 };
function W2e(t, e, n) {
	const r = this;
	return i;
	function i(u) {
		return t.enter("codeIndented"), At(t, o, "linePrefix", 5)(u);
	}
	function o(u) {
		const c = r.events[r.events.length - 1];
		return c &&
			c[1].type === "linePrefix" &&
			c[2].sliceSerialize(c[1], !0).length >= 4
			? s(u)
			: n(u);
	}
	function s(u) {
		return u === null
			? l(u)
			: He(u)
				? t.attempt(H2e, s, l)(u)
				: (t.enter("codeFlowValue"), a(u));
	}
	function a(u) {
		return u === null || He(u)
			? (t.exit("codeFlowValue"), s(u))
			: (t.consume(u), a);
	}
	function l(u) {
		return t.exit("codeIndented"), e(u);
	}
}
function q2e(t, e, n) {
	const r = this;
	return i;
	function i(s) {
		return r.parser.lazy[r.now().line]
			? n(s)
			: He(s)
				? (t.enter("lineEnding"), t.consume(s), t.exit("lineEnding"), i)
				: At(t, o, "linePrefix", 5)(s);
	}
	function o(s) {
		const a = r.events[r.events.length - 1];
		return a &&
			a[1].type === "linePrefix" &&
			a[2].sliceSerialize(a[1], !0).length >= 4
			? e(s)
			: He(s)
				? i(s)
				: n(s);
	}
}
const G2e = { name: "codeText", tokenize: X2e, resolve: Y2e, previous: J2e };
function Y2e(t) {
	let e = t.length - 4,
		n = 3,
		r,
		i;
	if (
		(t[n][1].type === "lineEnding" || t[n][1].type === "space") &&
		(t[e][1].type === "lineEnding" || t[e][1].type === "space")
	) {
		for (r = n; ++r < e; )
			if (t[r][1].type === "codeTextData") {
				(t[n][1].type = "codeTextPadding"),
					(t[e][1].type = "codeTextPadding"),
					(n += 2),
					(e -= 2);
				break;
			}
	}
	for (r = n - 1, e++; ++r <= e; )
		i === void 0
			? r !== e && t[r][1].type !== "lineEnding" && (i = r)
			: (r === e || t[r][1].type === "lineEnding") &&
				((t[i][1].type = "codeTextData"),
				r !== i + 2 &&
					((t[i][1].end = t[r - 1][1].end),
					t.splice(i + 2, r - i - 2),
					(e -= r - i - 2),
					(r = i + 2)),
				(i = void 0));
	return t;
}
function J2e(t) {
	return (
		t !== 96 ||
		this.events[this.events.length - 1][1].type === "characterEscape"
	);
}
function X2e(t, e, n) {
	let r = 0,
		i,
		o;
	return s;
	function s(d) {
		return t.enter("codeText"), t.enter("codeTextSequence"), a(d);
	}
	function a(d) {
		return d === 96
			? (t.consume(d), r++, a)
			: (t.exit("codeTextSequence"), l(d));
	}
	function l(d) {
		return d === null
			? n(d)
			: d === 32
				? (t.enter("space"), t.consume(d), t.exit("space"), l)
				: d === 96
					? ((o = t.enter("codeTextSequence")), (i = 0), c(d))
					: He(d)
						? (t.enter("lineEnding"),
							t.consume(d),
							t.exit("lineEnding"),
							l)
						: (t.enter("codeTextData"), u(d));
	}
	function u(d) {
		return d === null || d === 32 || d === 96 || He(d)
			? (t.exit("codeTextData"), l(d))
			: (t.consume(d), u);
	}
	function c(d) {
		return d === 96
			? (t.consume(d), i++, c)
			: i === r
				? (t.exit("codeTextSequence"), t.exit("codeText"), e(d))
				: ((o.type = "codeTextData"), u(d));
	}
}
class Z2e {
	constructor(e) {
		(this.left = e ? [...e] : []), (this.right = []);
	}
	get(e) {
		if (e < 0 || e >= this.left.length + this.right.length)
			throw new RangeError(
				"Cannot access index `" +
					e +
					"` in a splice buffer of size `" +
					(this.left.length + this.right.length) +
					"`",
			);
		return e < this.left.length
			? this.left[e]
			: this.right[this.right.length - e + this.left.length - 1];
	}
	get length() {
		return this.left.length + this.right.length;
	}
	shift() {
		return this.setCursor(0), this.right.pop();
	}
	slice(e, n) {
		const r = n ?? Number.POSITIVE_INFINITY;
		return r < this.left.length
			? this.left.slice(e, r)
			: e > this.left.length
				? this.right
						.slice(
							this.right.length - r + this.left.length,
							this.right.length - e + this.left.length,
						)
						.reverse()
				: this.left
						.slice(e)
						.concat(
							this.right
								.slice(this.right.length - r + this.left.length)
								.reverse(),
						);
	}
	splice(e, n, r) {
		const i = n || 0;
		this.setCursor(Math.trunc(e));
		const o = this.right.splice(
			this.right.length - i,
			Number.POSITIVE_INFINITY,
		);
		return r && Mp(this.left, r), o.reverse();
	}
	pop() {
		return this.setCursor(Number.POSITIVE_INFINITY), this.left.pop();
	}
	push(e) {
		this.setCursor(Number.POSITIVE_INFINITY), this.left.push(e);
	}
	pushMany(e) {
		this.setCursor(Number.POSITIVE_INFINITY), Mp(this.left, e);
	}
	unshift(e) {
		this.setCursor(0), this.right.push(e);
	}
	unshiftMany(e) {
		this.setCursor(0), Mp(this.right, e.reverse());
	}
	setCursor(e) {
		if (
			!(
				e === this.left.length ||
				(e > this.left.length && this.right.length === 0) ||
				(e < 0 && this.left.length === 0)
			)
		)
			if (e < this.left.length) {
				const n = this.left.splice(e, Number.POSITIVE_INFINITY);
				Mp(this.right, n.reverse());
			} else {
				const n = this.right.splice(
					this.left.length + this.right.length - e,
					Number.POSITIVE_INFINITY,
				);
				Mp(this.left, n.reverse());
			}
	}
}
function Mp(t, e) {
	let n = 0;
	if (e.length < 1e4) t.push(...e);
	else for (; n < e.length; ) t.push(...e.slice(n, n + 1e4)), (n += 1e4);
}
function eG(t) {
	const e = {};
	let n = -1,
		r,
		i,
		o,
		s,
		a,
		l,
		u;
	const c = new Z2e(t);
	for (; ++n < c.length; ) {
		for (; n in e; ) n = e[n];
		if (
			((r = c.get(n)),
			n &&
				r[1].type === "chunkFlow" &&
				c.get(n - 1)[1].type === "listItemPrefix" &&
				((l = r[1]._tokenizer.events),
				(o = 0),
				o < l.length && l[o][1].type === "lineEndingBlank" && (o += 2),
				o < l.length && l[o][1].type === "content"))
		)
			for (; ++o < l.length && l[o][1].type !== "content"; )
				l[o][1].type === "chunkText" &&
					((l[o][1]._isInFirstContentOfListItem = !0), o++);
		if (r[0] === "enter")
			r[1].contentType &&
				(Object.assign(e, Q2e(c, n)), (n = e[n]), (u = !0));
		else if (r[1]._container) {
			for (
				o = n, i = void 0;
				o-- &&
				((s = c.get(o)),
				s[1].type === "lineEnding" || s[1].type === "lineEndingBlank");

			)
				s[0] === "enter" &&
					(i && (c.get(i)[1].type = "lineEndingBlank"),
					(s[1].type = "lineEnding"),
					(i = o));
			i &&
				((r[1].end = Object.assign({}, c.get(i)[1].start)),
				(a = c.slice(i, n)),
				a.unshift(r),
				c.splice(i, n - i + 1, a));
		}
	}
	return Uo(t, 0, Number.POSITIVE_INFINITY, c.slice(0)), !u;
}
function Q2e(t, e) {
	const n = t.get(e)[1],
		r = t.get(e)[2];
	let i = e - 1;
	const o = [],
		s = n._tokenizer || r.parser[n.contentType](n.start),
		a = s.events,
		l = [],
		u = {};
	let c,
		d,
		f = -1,
		h = n,
		p = 0,
		g = 0;
	const v = [g];
	for (; h; ) {
		for (; t.get(++i)[1] !== h; );
		o.push(i),
			h._tokenizer ||
				((c = r.sliceStream(h)),
				h.next || c.push(null),
				d && s.defineSkip(h.start),
				h._isInFirstContentOfListItem &&
					(s._gfmTasklistFirstContentOfListItem = !0),
				s.write(c),
				h._isInFirstContentOfListItem &&
					(s._gfmTasklistFirstContentOfListItem = void 0)),
			(d = h),
			(h = h.next);
	}
	for (h = n; ++f < a.length; )
		a[f][0] === "exit" &&
			a[f - 1][0] === "enter" &&
			a[f][1].type === a[f - 1][1].type &&
			a[f][1].start.line !== a[f][1].end.line &&
			((g = f + 1),
			v.push(g),
			(h._tokenizer = void 0),
			(h.previous = void 0),
			(h = h.next));
	for (
		s.events = [],
			h ? ((h._tokenizer = void 0), (h.previous = void 0)) : v.pop(),
			f = v.length;
		f--;

	) {
		const b = a.slice(v[f], v[f + 1]),
			y = o.pop();
		l.push([y, y + b.length - 1]), t.splice(y, 2, b);
	}
	for (l.reverse(), f = -1; ++f < l.length; )
		(u[p + l[f][0]] = p + l[f][1]), (p += l[f][1] - l[f][0] - 1);
	return u;
}
const eEe = { tokenize: rEe, resolve: nEe },
	tEe = { tokenize: iEe, partial: !0 };
function nEe(t) {
	return eG(t), t;
}
function rEe(t, e) {
	let n;
	return r;
	function r(a) {
		return (
			t.enter("content"),
			(n = t.enter("chunkContent", { contentType: "content" })),
			i(a)
		);
	}
	function i(a) {
		return a === null
			? o(a)
			: He(a)
				? t.check(tEe, s, o)(a)
				: (t.consume(a), i);
	}
	function o(a) {
		return t.exit("chunkContent"), t.exit("content"), e(a);
	}
	function s(a) {
		return (
			t.consume(a),
			t.exit("chunkContent"),
			(n.next = t.enter("chunkContent", {
				contentType: "content",
				previous: n,
			})),
			(n = n.next),
			i
		);
	}
}
function iEe(t, e, n) {
	const r = this;
	return i;
	function i(s) {
		return (
			t.exit("chunkContent"),
			t.enter("lineEnding"),
			t.consume(s),
			t.exit("lineEnding"),
			At(t, o, "linePrefix")
		);
	}
	function o(s) {
		if (s === null || He(s)) return n(s);
		const a = r.events[r.events.length - 1];
		return !r.parser.constructs.disable.null.includes("codeIndented") &&
			a &&
			a[1].type === "linePrefix" &&
			a[2].sliceSerialize(a[1], !0).length >= 4
			? e(s)
			: t.interrupt(r.parser.constructs.flow, n, e)(s);
	}
}
function tG(t, e, n, r, i, o, s, a, l) {
	const u = l || Number.POSITIVE_INFINITY;
	let c = 0;
	return d;
	function d(b) {
		return b === 60
			? (t.enter(r), t.enter(i), t.enter(o), t.consume(b), t.exit(o), f)
			: b === null || b === 32 || b === 41 || By(b)
				? n(b)
				: (t.enter(r),
					t.enter(s),
					t.enter(a),
					t.enter("chunkString", { contentType: "string" }),
					g(b));
	}
	function f(b) {
		return b === 62
			? (t.enter(o), t.consume(b), t.exit(o), t.exit(i), t.exit(r), e)
			: (t.enter(a),
				t.enter("chunkString", { contentType: "string" }),
				h(b));
	}
	function h(b) {
		return b === 62
			? (t.exit("chunkString"), t.exit(a), f(b))
			: b === null || b === 60 || He(b)
				? n(b)
				: (t.consume(b), b === 92 ? p : h);
	}
	function p(b) {
		return b === 60 || b === 62 || b === 92 ? (t.consume(b), h) : h(b);
	}
	function g(b) {
		return !c && (b === null || b === 41 || It(b))
			? (t.exit("chunkString"), t.exit(a), t.exit(s), t.exit(r), e(b))
			: c < u && b === 40
				? (t.consume(b), c++, g)
				: b === 41
					? (t.consume(b), c--, g)
					: b === null || b === 32 || b === 40 || By(b)
						? n(b)
						: (t.consume(b), b === 92 ? v : g);
	}
	function v(b) {
		return b === 40 || b === 41 || b === 92 ? (t.consume(b), g) : g(b);
	}
}
function nG(t, e, n, r, i, o) {
	const s = this;
	let a = 0,
		l;
	return u;
	function u(h) {
		return t.enter(r), t.enter(i), t.consume(h), t.exit(i), t.enter(o), c;
	}
	function c(h) {
		return a > 999 ||
			h === null ||
			h === 91 ||
			(h === 93 && !l) ||
			(h === 94 && !a && "_hiddenFootnoteSupport" in s.parser.constructs)
			? n(h)
			: h === 93
				? (t.exit(o), t.enter(i), t.consume(h), t.exit(i), t.exit(r), e)
				: He(h)
					? (t.enter("lineEnding"),
						t.consume(h),
						t.exit("lineEnding"),
						c)
					: (t.enter("chunkString", { contentType: "string" }), d(h));
	}
	function d(h) {
		return h === null || h === 91 || h === 93 || He(h) || a++ > 999
			? (t.exit("chunkString"), c(h))
			: (t.consume(h), l || (l = !xt(h)), h === 92 ? f : d);
	}
	function f(h) {
		return h === 91 || h === 92 || h === 93 ? (t.consume(h), a++, d) : d(h);
	}
}
function rG(t, e, n, r, i, o) {
	let s;
	return a;
	function a(f) {
		return f === 34 || f === 39 || f === 40
			? (t.enter(r),
				t.enter(i),
				t.consume(f),
				t.exit(i),
				(s = f === 40 ? 41 : f),
				l)
			: n(f);
	}
	function l(f) {
		return f === s
			? (t.enter(i), t.consume(f), t.exit(i), t.exit(r), e)
			: (t.enter(o), u(f));
	}
	function u(f) {
		return f === s
			? (t.exit(o), l(s))
			: f === null
				? n(f)
				: He(f)
					? (t.enter("lineEnding"),
						t.consume(f),
						t.exit("lineEnding"),
						At(t, u, "linePrefix"))
					: (t.enter("chunkString", { contentType: "string" }), c(f));
	}
	function c(f) {
		return f === s || f === null || He(f)
			? (t.exit("chunkString"), u(f))
			: (t.consume(f), f === 92 ? d : c);
	}
	function d(f) {
		return f === s || f === 92 ? (t.consume(f), c) : c(f);
	}
}
function Fm(t, e) {
	let n;
	return r;
	function r(i) {
		return He(i)
			? (t.enter("lineEnding"),
				t.consume(i),
				t.exit("lineEnding"),
				(n = !0),
				r)
			: xt(i)
				? At(t, r, n ? "linePrefix" : "lineSuffix")(i)
				: e(i);
	}
}
const oEe = { name: "definition", tokenize: aEe },
	sEe = { tokenize: lEe, partial: !0 };
function aEe(t, e, n) {
	const r = this;
	let i;
	return o;
	function o(h) {
		return t.enter("definition"), s(h);
	}
	function s(h) {
		return nG.call(
			r,
			t,
			a,
			n,
			"definitionLabel",
			"definitionLabelMarker",
			"definitionLabelString",
		)(h);
	}
	function a(h) {
		return (
			(i = Ds(
				r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1),
			)),
			h === 58
				? (t.enter("definitionMarker"),
					t.consume(h),
					t.exit("definitionMarker"),
					l)
				: n(h)
		);
	}
	function l(h) {
		return It(h) ? Fm(t, u)(h) : u(h);
	}
	function u(h) {
		return tG(
			t,
			c,
			n,
			"definitionDestination",
			"definitionDestinationLiteral",
			"definitionDestinationLiteralMarker",
			"definitionDestinationRaw",
			"definitionDestinationString",
		)(h);
	}
	function c(h) {
		return t.attempt(sEe, d, d)(h);
	}
	function d(h) {
		return xt(h) ? At(t, f, "whitespace")(h) : f(h);
	}
	function f(h) {
		return h === null || He(h)
			? (t.exit("definition"), r.parser.defined.push(i), e(h))
			: n(h);
	}
}
function lEe(t, e, n) {
	return r;
	function r(a) {
		return It(a) ? Fm(t, i)(a) : n(a);
	}
	function i(a) {
		return rG(
			t,
			o,
			n,
			"definitionTitle",
			"definitionTitleMarker",
			"definitionTitleString",
		)(a);
	}
	function o(a) {
		return xt(a) ? At(t, s, "whitespace")(a) : s(a);
	}
	function s(a) {
		return a === null || He(a) ? e(a) : n(a);
	}
}
const uEe = { name: "hardBreakEscape", tokenize: cEe };
function cEe(t, e, n) {
	return r;
	function r(o) {
		return t.enter("hardBreakEscape"), t.consume(o), i;
	}
	function i(o) {
		return He(o) ? (t.exit("hardBreakEscape"), e(o)) : n(o);
	}
}
const dEe = { name: "headingAtx", tokenize: hEe, resolve: fEe };
function fEe(t, e) {
	let n = t.length - 2,
		r = 3,
		i,
		o;
	return (
		t[r][1].type === "whitespace" && (r += 2),
		n - 2 > r && t[n][1].type === "whitespace" && (n -= 2),
		t[n][1].type === "atxHeadingSequence" &&
			(r === n - 1 || (n - 4 > r && t[n - 2][1].type === "whitespace")) &&
			(n -= r + 1 === n ? 2 : 4),
		n > r &&
			((i = {
				type: "atxHeadingText",
				start: t[r][1].start,
				end: t[n][1].end,
			}),
			(o = {
				type: "chunkText",
				start: t[r][1].start,
				end: t[n][1].end,
				contentType: "text",
			}),
			Uo(t, r, n - r + 1, [
				["enter", i, e],
				["enter", o, e],
				["exit", o, e],
				["exit", i, e],
			])),
		t
	);
}
function hEe(t, e, n) {
	let r = 0;
	return i;
	function i(c) {
		return t.enter("atxHeading"), o(c);
	}
	function o(c) {
		return t.enter("atxHeadingSequence"), s(c);
	}
	function s(c) {
		return c === 35 && r++ < 6
			? (t.consume(c), s)
			: c === null || It(c)
				? (t.exit("atxHeadingSequence"), a(c))
				: n(c);
	}
	function a(c) {
		return c === 35
			? (t.enter("atxHeadingSequence"), l(c))
			: c === null || He(c)
				? (t.exit("atxHeading"), e(c))
				: xt(c)
					? At(t, a, "whitespace")(c)
					: (t.enter("atxHeadingText"), u(c));
	}
	function l(c) {
		return c === 35
			? (t.consume(c), l)
			: (t.exit("atxHeadingSequence"), a(c));
	}
	function u(c) {
		return c === null || c === 35 || It(c)
			? (t.exit("atxHeadingText"), a(c))
			: (t.consume(c), u);
	}
}
const pEe = [
		"address",
		"article",
		"aside",
		"base",
		"basefont",
		"blockquote",
		"body",
		"caption",
		"center",
		"col",
		"colgroup",
		"dd",
		"details",
		"dialog",
		"dir",
		"div",
		"dl",
		"dt",
		"fieldset",
		"figcaption",
		"figure",
		"footer",
		"form",
		"frame",
		"frameset",
		"h1",
		"h2",
		"h3",
		"h4",
		"h5",
		"h6",
		"head",
		"header",
		"hr",
		"html",
		"iframe",
		"legend",
		"li",
		"link",
		"main",
		"menu",
		"menuitem",
		"nav",
		"noframes",
		"ol",
		"optgroup",
		"option",
		"p",
		"param",
		"search",
		"section",
		"summary",
		"table",
		"tbody",
		"td",
		"tfoot",
		"th",
		"thead",
		"title",
		"tr",
		"track",
		"ul",
	],
	O7 = ["pre", "script", "style", "textarea"],
	mEe = { name: "htmlFlow", tokenize: yEe, resolveTo: vEe, concrete: !0 },
	gEe = { tokenize: kEe, partial: !0 },
	bEe = { tokenize: xEe, partial: !0 };
function vEe(t) {
	let e = t.length;
	for (; e-- && !(t[e][0] === "enter" && t[e][1].type === "htmlFlow"); );
	return (
		e > 1 &&
			t[e - 2][1].type === "linePrefix" &&
			((t[e][1].start = t[e - 2][1].start),
			(t[e + 1][1].start = t[e - 2][1].start),
			t.splice(e - 2, 2)),
		t
	);
}
function yEe(t, e, n) {
	const r = this;
	let i, o, s, a, l;
	return u;
	function u(P) {
		return c(P);
	}
	function c(P) {
		return t.enter("htmlFlow"), t.enter("htmlFlowData"), t.consume(P), d;
	}
	function d(P) {
		return P === 33
			? (t.consume(P), f)
			: P === 47
				? (t.consume(P), (o = !0), g)
				: P === 63
					? (t.consume(P), (i = 3), r.interrupt ? e : M)
					: Vr(P)
						? (t.consume(P), (s = String.fromCharCode(P)), v)
						: n(P);
	}
	function f(P) {
		return P === 45
			? (t.consume(P), (i = 2), h)
			: P === 91
				? (t.consume(P), (i = 5), (a = 0), p)
				: Vr(P)
					? (t.consume(P), (i = 4), r.interrupt ? e : M)
					: n(P);
	}
	function h(P) {
		return P === 45 ? (t.consume(P), r.interrupt ? e : M) : n(P);
	}
	function p(P) {
		const q = "CDATA[";
		return P === q.charCodeAt(a++)
			? (t.consume(P), a === q.length ? (r.interrupt ? e : I) : p)
			: n(P);
	}
	function g(P) {
		return Vr(P) ? (t.consume(P), (s = String.fromCharCode(P)), v) : n(P);
	}
	function v(P) {
		if (P === null || P === 47 || P === 62 || It(P)) {
			const q = P === 47,
				J = s.toLowerCase();
			return !q && !o && O7.includes(J)
				? ((i = 1), r.interrupt ? e(P) : I(P))
				: pEe.includes(s.toLowerCase())
					? ((i = 6),
						q ? (t.consume(P), b) : r.interrupt ? e(P) : I(P))
					: ((i = 7),
						r.interrupt && !r.parser.lazy[r.now().line]
							? n(P)
							: o
								? y(P)
								: x(P));
		}
		return P === 45 || Oi(P)
			? (t.consume(P), (s += String.fromCharCode(P)), v)
			: n(P);
	}
	function b(P) {
		return P === 62 ? (t.consume(P), r.interrupt ? e : I) : n(P);
	}
	function y(P) {
		return xt(P) ? (t.consume(P), y) : A(P);
	}
	function x(P) {
		return P === 47
			? (t.consume(P), A)
			: P === 58 || P === 95 || Vr(P)
				? (t.consume(P), C)
				: xt(P)
					? (t.consume(P), x)
					: A(P);
	}
	function C(P) {
		return P === 45 || P === 46 || P === 58 || P === 95 || Oi(P)
			? (t.consume(P), C)
			: k(P);
	}
	function k(P) {
		return P === 61 ? (t.consume(P), w) : xt(P) ? (t.consume(P), k) : x(P);
	}
	function w(P) {
		return P === null || P === 60 || P === 61 || P === 62 || P === 96
			? n(P)
			: P === 34 || P === 39
				? (t.consume(P), (l = P), D)
				: xt(P)
					? (t.consume(P), w)
					: S(P);
	}
	function D(P) {
		return P === l
			? (t.consume(P), (l = null), $)
			: P === null || He(P)
				? n(P)
				: (t.consume(P), D);
	}
	function S(P) {
		return P === null ||
			P === 34 ||
			P === 39 ||
			P === 47 ||
			P === 60 ||
			P === 61 ||
			P === 62 ||
			P === 96 ||
			It(P)
			? k(P)
			: (t.consume(P), S);
	}
	function $(P) {
		return P === 47 || P === 62 || xt(P) ? x(P) : n(P);
	}
	function A(P) {
		return P === 62 ? (t.consume(P), T) : n(P);
	}
	function T(P) {
		return P === null || He(P) ? I(P) : xt(P) ? (t.consume(P), T) : n(P);
	}
	function I(P) {
		return P === 45 && i === 2
			? (t.consume(P), _)
			: P === 60 && i === 1
				? (t.consume(P), j)
				: P === 62 && i === 4
					? (t.consume(P), G)
					: P === 63 && i === 3
						? (t.consume(P), M)
						: P === 93 && i === 5
							? (t.consume(P), K)
							: He(P) && (i === 6 || i === 7)
								? (t.exit("htmlFlowData"),
									t.check(gEe, H, F)(P))
								: P === null || He(P)
									? (t.exit("htmlFlowData"), F(P))
									: (t.consume(P), I);
	}
	function F(P) {
		return t.check(bEe, N, H)(P);
	}
	function N(P) {
		return t.enter("lineEnding"), t.consume(P), t.exit("lineEnding"), O;
	}
	function O(P) {
		return P === null || He(P) ? F(P) : (t.enter("htmlFlowData"), I(P));
	}
	function _(P) {
		return P === 45 ? (t.consume(P), M) : I(P);
	}
	function j(P) {
		return P === 47 ? (t.consume(P), (s = ""), V) : I(P);
	}
	function V(P) {
		if (P === 62) {
			const q = s.toLowerCase();
			return O7.includes(q) ? (t.consume(P), G) : I(P);
		}
		return Vr(P) && s.length < 8
			? (t.consume(P), (s += String.fromCharCode(P)), V)
			: I(P);
	}
	function K(P) {
		return P === 93 ? (t.consume(P), M) : I(P);
	}
	function M(P) {
		return P === 62
			? (t.consume(P), G)
			: P === 45 && i === 2
				? (t.consume(P), M)
				: I(P);
	}
	function G(P) {
		return P === null || He(P)
			? (t.exit("htmlFlowData"), H(P))
			: (t.consume(P), G);
	}
	function H(P) {
		return t.exit("htmlFlow"), e(P);
	}
}
function xEe(t, e, n) {
	const r = this;
	return i;
	function i(s) {
		return He(s)
			? (t.enter("lineEnding"), t.consume(s), t.exit("lineEnding"), o)
			: n(s);
	}
	function o(s) {
		return r.parser.lazy[r.now().line] ? n(s) : e(s);
	}
}
function kEe(t, e, n) {
	return r;
	function r(i) {
		return (
			t.enter("lineEnding"),
			t.consume(i),
			t.exit("lineEnding"),
			t.attempt(mp, e, n)
		);
	}
}
const CEe = { name: "htmlText", tokenize: wEe };
function wEe(t, e, n) {
	const r = this;
	let i, o, s;
	return a;
	function a(M) {
		return t.enter("htmlText"), t.enter("htmlTextData"), t.consume(M), l;
	}
	function l(M) {
		return M === 33
			? (t.consume(M), u)
			: M === 47
				? (t.consume(M), k)
				: M === 63
					? (t.consume(M), x)
					: Vr(M)
						? (t.consume(M), S)
						: n(M);
	}
	function u(M) {
		return M === 45
			? (t.consume(M), c)
			: M === 91
				? (t.consume(M), (o = 0), p)
				: Vr(M)
					? (t.consume(M), y)
					: n(M);
	}
	function c(M) {
		return M === 45 ? (t.consume(M), h) : n(M);
	}
	function d(M) {
		return M === null
			? n(M)
			: M === 45
				? (t.consume(M), f)
				: He(M)
					? ((s = d), j(M))
					: (t.consume(M), d);
	}
	function f(M) {
		return M === 45 ? (t.consume(M), h) : d(M);
	}
	function h(M) {
		return M === 62 ? _(M) : M === 45 ? f(M) : d(M);
	}
	function p(M) {
		const G = "CDATA[";
		return M === G.charCodeAt(o++)
			? (t.consume(M), o === G.length ? g : p)
			: n(M);
	}
	function g(M) {
		return M === null
			? n(M)
			: M === 93
				? (t.consume(M), v)
				: He(M)
					? ((s = g), j(M))
					: (t.consume(M), g);
	}
	function v(M) {
		return M === 93 ? (t.consume(M), b) : g(M);
	}
	function b(M) {
		return M === 62 ? _(M) : M === 93 ? (t.consume(M), b) : g(M);
	}
	function y(M) {
		return M === null || M === 62
			? _(M)
			: He(M)
				? ((s = y), j(M))
				: (t.consume(M), y);
	}
	function x(M) {
		return M === null
			? n(M)
			: M === 63
				? (t.consume(M), C)
				: He(M)
					? ((s = x), j(M))
					: (t.consume(M), x);
	}
	function C(M) {
		return M === 62 ? _(M) : x(M);
	}
	function k(M) {
		return Vr(M) ? (t.consume(M), w) : n(M);
	}
	function w(M) {
		return M === 45 || Oi(M) ? (t.consume(M), w) : D(M);
	}
	function D(M) {
		return He(M) ? ((s = D), j(M)) : xt(M) ? (t.consume(M), D) : _(M);
	}
	function S(M) {
		return M === 45 || Oi(M)
			? (t.consume(M), S)
			: M === 47 || M === 62 || It(M)
				? $(M)
				: n(M);
	}
	function $(M) {
		return M === 47
			? (t.consume(M), _)
			: M === 58 || M === 95 || Vr(M)
				? (t.consume(M), A)
				: He(M)
					? ((s = $), j(M))
					: xt(M)
						? (t.consume(M), $)
						: _(M);
	}
	function A(M) {
		return M === 45 || M === 46 || M === 58 || M === 95 || Oi(M)
			? (t.consume(M), A)
			: T(M);
	}
	function T(M) {
		return M === 61
			? (t.consume(M), I)
			: He(M)
				? ((s = T), j(M))
				: xt(M)
					? (t.consume(M), T)
					: $(M);
	}
	function I(M) {
		return M === null || M === 60 || M === 61 || M === 62 || M === 96
			? n(M)
			: M === 34 || M === 39
				? (t.consume(M), (i = M), F)
				: He(M)
					? ((s = I), j(M))
					: xt(M)
						? (t.consume(M), I)
						: (t.consume(M), N);
	}
	function F(M) {
		return M === i
			? (t.consume(M), (i = void 0), O)
			: M === null
				? n(M)
				: He(M)
					? ((s = F), j(M))
					: (t.consume(M), F);
	}
	function N(M) {
		return M === null ||
			M === 34 ||
			M === 39 ||
			M === 60 ||
			M === 61 ||
			M === 96
			? n(M)
			: M === 47 || M === 62 || It(M)
				? $(M)
				: (t.consume(M), N);
	}
	function O(M) {
		return M === 47 || M === 62 || It(M) ? $(M) : n(M);
	}
	function _(M) {
		return M === 62
			? (t.consume(M), t.exit("htmlTextData"), t.exit("htmlText"), e)
			: n(M);
	}
	function j(M) {
		return (
			t.exit("htmlTextData"),
			t.enter("lineEnding"),
			t.consume(M),
			t.exit("lineEnding"),
			V
		);
	}
	function V(M) {
		return xt(M)
			? At(
					t,
					K,
					"linePrefix",
					r.parser.constructs.disable.null.includes("codeIndented")
						? void 0
						: 4,
				)(M)
			: K(M);
	}
	function K(M) {
		return t.enter("htmlTextData"), s(M);
	}
}
const W5 = { name: "labelEnd", tokenize: TEe, resolveTo: $Ee, resolveAll: AEe },
	EEe = { tokenize: BEe },
	DEe = { tokenize: IEe },
	SEe = { tokenize: FEe };
function AEe(t) {
	let e = -1;
	for (; ++e < t.length; ) {
		const n = t[e][1];
		(n.type === "labelImage" ||
			n.type === "labelLink" ||
			n.type === "labelEnd") &&
			(t.splice(e + 1, n.type === "labelImage" ? 4 : 2),
			(n.type = "data"),
			e++);
	}
	return t;
}
function $Ee(t, e) {
	let n = t.length,
		r = 0,
		i,
		o,
		s,
		a;
	for (; n--; )
		if (((i = t[n][1]), o)) {
			if (i.type === "link" || (i.type === "labelLink" && i._inactive))
				break;
			t[n][0] === "enter" && i.type === "labelLink" && (i._inactive = !0);
		} else if (s) {
			if (
				t[n][0] === "enter" &&
				(i.type === "labelImage" || i.type === "labelLink") &&
				!i._balanced &&
				((o = n), i.type !== "labelLink")
			) {
				r = 2;
				break;
			}
		} else i.type === "labelEnd" && (s = n);
	const l = {
			type: t[o][1].type === "labelLink" ? "link" : "image",
			start: Object.assign({}, t[o][1].start),
			end: Object.assign({}, t[t.length - 1][1].end),
		},
		u = {
			type: "label",
			start: Object.assign({}, t[o][1].start),
			end: Object.assign({}, t[s][1].end),
		},
		c = {
			type: "labelText",
			start: Object.assign({}, t[o + r + 2][1].end),
			end: Object.assign({}, t[s - 2][1].start),
		};
	return (
		(a = [
			["enter", l, e],
			["enter", u, e],
		]),
		(a = Fo(a, t.slice(o + 1, o + r + 3))),
		(a = Fo(a, [["enter", c, e]])),
		(a = Fo(
			a,
			O3(
				e.parser.constructs.insideSpan.null,
				t.slice(o + r + 4, s - 3),
				e,
			),
		)),
		(a = Fo(a, [["exit", c, e], t[s - 2], t[s - 1], ["exit", u, e]])),
		(a = Fo(a, t.slice(s + 1))),
		(a = Fo(a, [["exit", l, e]])),
		Uo(t, o, t.length, a),
		t
	);
}
function TEe(t, e, n) {
	const r = this;
	let i = r.events.length,
		o,
		s;
	for (; i--; )
		if (
			(r.events[i][1].type === "labelImage" ||
				r.events[i][1].type === "labelLink") &&
			!r.events[i][1]._balanced
		) {
			o = r.events[i][1];
			break;
		}
	return a;
	function a(f) {
		return o
			? o._inactive
				? d(f)
				: ((s = r.parser.defined.includes(
						Ds(r.sliceSerialize({ start: o.end, end: r.now() })),
					)),
					t.enter("labelEnd"),
					t.enter("labelMarker"),
					t.consume(f),
					t.exit("labelMarker"),
					t.exit("labelEnd"),
					l)
			: n(f);
	}
	function l(f) {
		return f === 40
			? t.attempt(EEe, c, s ? c : d)(f)
			: f === 91
				? t.attempt(DEe, c, s ? u : d)(f)
				: s
					? c(f)
					: d(f);
	}
	function u(f) {
		return t.attempt(SEe, c, d)(f);
	}
	function c(f) {
		return e(f);
	}
	function d(f) {
		return (o._balanced = !0), n(f);
	}
}
function BEe(t, e, n) {
	return r;
	function r(d) {
		return (
			t.enter("resource"),
			t.enter("resourceMarker"),
			t.consume(d),
			t.exit("resourceMarker"),
			i
		);
	}
	function i(d) {
		return It(d) ? Fm(t, o)(d) : o(d);
	}
	function o(d) {
		return d === 41
			? c(d)
			: tG(
					t,
					s,
					a,
					"resourceDestination",
					"resourceDestinationLiteral",
					"resourceDestinationLiteralMarker",
					"resourceDestinationRaw",
					"resourceDestinationString",
					32,
				)(d);
	}
	function s(d) {
		return It(d) ? Fm(t, l)(d) : c(d);
	}
	function a(d) {
		return n(d);
	}
	function l(d) {
		return d === 34 || d === 39 || d === 40
			? rG(
					t,
					u,
					n,
					"resourceTitle",
					"resourceTitleMarker",
					"resourceTitleString",
				)(d)
			: c(d);
	}
	function u(d) {
		return It(d) ? Fm(t, c)(d) : c(d);
	}
	function c(d) {
		return d === 41
			? (t.enter("resourceMarker"),
				t.consume(d),
				t.exit("resourceMarker"),
				t.exit("resource"),
				e)
			: n(d);
	}
}
function IEe(t, e, n) {
	const r = this;
	return i;
	function i(a) {
		return nG.call(
			r,
			t,
			o,
			s,
			"reference",
			"referenceMarker",
			"referenceString",
		)(a);
	}
	function o(a) {
		return r.parser.defined.includes(
			Ds(r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1)),
		)
			? e(a)
			: n(a);
	}
	function s(a) {
		return n(a);
	}
}
function FEe(t, e, n) {
	return r;
	function r(o) {
		return (
			t.enter("reference"),
			t.enter("referenceMarker"),
			t.consume(o),
			t.exit("referenceMarker"),
			i
		);
	}
	function i(o) {
		return o === 93
			? (t.enter("referenceMarker"),
				t.consume(o),
				t.exit("referenceMarker"),
				t.exit("reference"),
				e)
			: n(o);
	}
}
const PEe = {
	name: "labelStartImage",
	tokenize: NEe,
	resolveAll: W5.resolveAll,
};
function NEe(t, e, n) {
	const r = this;
	return i;
	function i(a) {
		return (
			t.enter("labelImage"),
			t.enter("labelImageMarker"),
			t.consume(a),
			t.exit("labelImageMarker"),
			o
		);
	}
	function o(a) {
		return a === 91
			? (t.enter("labelMarker"),
				t.consume(a),
				t.exit("labelMarker"),
				t.exit("labelImage"),
				s)
			: n(a);
	}
	function s(a) {
		return a === 94 && "_hiddenFootnoteSupport" in r.parser.constructs
			? n(a)
			: e(a);
	}
}
const REe = {
	name: "labelStartLink",
	tokenize: OEe,
	resolveAll: W5.resolveAll,
};
function OEe(t, e, n) {
	const r = this;
	return i;
	function i(s) {
		return (
			t.enter("labelLink"),
			t.enter("labelMarker"),
			t.consume(s),
			t.exit("labelMarker"),
			t.exit("labelLink"),
			o
		);
	}
	function o(s) {
		return s === 94 && "_hiddenFootnoteSupport" in r.parser.constructs
			? n(s)
			: e(s);
	}
}
const cC = { name: "lineEnding", tokenize: MEe };
function MEe(t, e) {
	return n;
	function n(r) {
		return (
			t.enter("lineEnding"),
			t.consume(r),
			t.exit("lineEnding"),
			At(t, e, "linePrefix")
		);
	}
}
const Fb = { name: "thematicBreak", tokenize: jEe };
function jEe(t, e, n) {
	let r = 0,
		i;
	return o;
	function o(u) {
		return t.enter("thematicBreak"), s(u);
	}
	function s(u) {
		return (i = u), a(u);
	}
	function a(u) {
		return u === i
			? (t.enter("thematicBreakSequence"), l(u))
			: r >= 3 && (u === null || He(u))
				? (t.exit("thematicBreak"), e(u))
				: n(u);
	}
	function l(u) {
		return u === i
			? (t.consume(u), r++, l)
			: (t.exit("thematicBreakSequence"),
				xt(u) ? At(t, a, "whitespace")(u) : a(u));
	}
}
const Si = {
		name: "list",
		tokenize: LEe,
		continuation: { tokenize: VEe },
		exit: UEe,
	},
	_Ee = { tokenize: HEe, partial: !0 },
	zEe = { tokenize: KEe, partial: !0 };
function LEe(t, e, n) {
	const r = this,
		i = r.events[r.events.length - 1];
	let o =
			i && i[1].type === "linePrefix"
				? i[2].sliceSerialize(i[1], !0).length
				: 0,
		s = 0;
	return a;
	function a(h) {
		const p =
			r.containerState.type ||
			(h === 42 || h === 43 || h === 45
				? "listUnordered"
				: "listOrdered");
		if (
			p === "listUnordered"
				? !r.containerState.marker || h === r.containerState.marker
				: iE(h)
		) {
			if (
				(r.containerState.type ||
					((r.containerState.type = p),
					t.enter(p, { _container: !0 })),
				p === "listUnordered")
			)
				return (
					t.enter("listItemPrefix"),
					h === 42 || h === 45 ? t.check(Fb, n, u)(h) : u(h)
				);
			if (!r.interrupt || h === 49)
				return (
					t.enter("listItemPrefix"), t.enter("listItemValue"), l(h)
				);
		}
		return n(h);
	}
	function l(h) {
		return iE(h) && ++s < 10
			? (t.consume(h), l)
			: (!r.interrupt || s < 2) &&
				  (r.containerState.marker
						? h === r.containerState.marker
						: h === 41 || h === 46)
				? (t.exit("listItemValue"), u(h))
				: n(h);
	}
	function u(h) {
		return (
			t.enter("listItemMarker"),
			t.consume(h),
			t.exit("listItemMarker"),
			(r.containerState.marker = r.containerState.marker || h),
			t.check(mp, r.interrupt ? n : c, t.attempt(_Ee, f, d))
		);
	}
	function c(h) {
		return (r.containerState.initialBlankLine = !0), o++, f(h);
	}
	function d(h) {
		return xt(h)
			? (t.enter("listItemPrefixWhitespace"),
				t.consume(h),
				t.exit("listItemPrefixWhitespace"),
				f)
			: n(h);
	}
	function f(h) {
		return (
			(r.containerState.size =
				o + r.sliceSerialize(t.exit("listItemPrefix"), !0).length),
			e(h)
		);
	}
}
function VEe(t, e, n) {
	const r = this;
	return (r.containerState._closeFlow = void 0), t.check(mp, i, o);
	function i(a) {
		return (
			(r.containerState.furtherBlankLines =
				r.containerState.furtherBlankLines ||
				r.containerState.initialBlankLine),
			At(t, e, "listItemIndent", r.containerState.size + 1)(a)
		);
	}
	function o(a) {
		return r.containerState.furtherBlankLines || !xt(a)
			? ((r.containerState.furtherBlankLines = void 0),
				(r.containerState.initialBlankLine = void 0),
				s(a))
			: ((r.containerState.furtherBlankLines = void 0),
				(r.containerState.initialBlankLine = void 0),
				t.attempt(zEe, e, s)(a));
	}
	function s(a) {
		return (
			(r.containerState._closeFlow = !0),
			(r.interrupt = void 0),
			At(
				t,
				t.attempt(Si, e, n),
				"linePrefix",
				r.parser.constructs.disable.null.includes("codeIndented")
					? void 0
					: 4,
			)(a)
		);
	}
}
function KEe(t, e, n) {
	const r = this;
	return At(t, i, "listItemIndent", r.containerState.size + 1);
	function i(o) {
		const s = r.events[r.events.length - 1];
		return s &&
			s[1].type === "listItemIndent" &&
			s[2].sliceSerialize(s[1], !0).length === r.containerState.size
			? e(o)
			: n(o);
	}
}
function UEe(t) {
	t.exit(this.containerState.type);
}
function HEe(t, e, n) {
	const r = this;
	return At(
		t,
		i,
		"listItemPrefixWhitespace",
		r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 5,
	);
	function i(o) {
		const s = r.events[r.events.length - 1];
		return !xt(o) && s && s[1].type === "listItemPrefixWhitespace"
			? e(o)
			: n(o);
	}
}
const M7 = { name: "setextUnderline", tokenize: qEe, resolveTo: WEe };
function WEe(t, e) {
	let n = t.length,
		r,
		i,
		o;
	for (; n--; )
		if (t[n][0] === "enter") {
			if (t[n][1].type === "content") {
				r = n;
				break;
			}
			t[n][1].type === "paragraph" && (i = n);
		} else
			t[n][1].type === "content" && t.splice(n, 1),
				!o && t[n][1].type === "definition" && (o = n);
	const s = {
		type: "setextHeading",
		start: Object.assign({}, t[i][1].start),
		end: Object.assign({}, t[t.length - 1][1].end),
	};
	return (
		(t[i][1].type = "setextHeadingText"),
		o
			? (t.splice(i, 0, ["enter", s, e]),
				t.splice(o + 1, 0, ["exit", t[r][1], e]),
				(t[r][1].end = Object.assign({}, t[o][1].end)))
			: (t[r][1] = s),
		t.push(["exit", s, e]),
		t
	);
}
function qEe(t, e, n) {
	const r = this;
	let i;
	return o;
	function o(u) {
		let c = r.events.length,
			d;
		for (; c--; )
			if (
				r.events[c][1].type !== "lineEnding" &&
				r.events[c][1].type !== "linePrefix" &&
				r.events[c][1].type !== "content"
			) {
				d = r.events[c][1].type === "paragraph";
				break;
			}
		return !r.parser.lazy[r.now().line] && (r.interrupt || d)
			? (t.enter("setextHeadingLine"), (i = u), s(u))
			: n(u);
	}
	function s(u) {
		return t.enter("setextHeadingLineSequence"), a(u);
	}
	function a(u) {
		return u === i
			? (t.consume(u), a)
			: (t.exit("setextHeadingLineSequence"),
				xt(u) ? At(t, l, "lineSuffix")(u) : l(u));
	}
	function l(u) {
		return u === null || He(u) ? (t.exit("setextHeadingLine"), e(u)) : n(u);
	}
}
const GEe = { tokenize: YEe };
function YEe(t) {
	const e = this,
		n = t.attempt(
			mp,
			r,
			t.attempt(
				this.parser.constructs.flowInitial,
				i,
				At(
					t,
					t.attempt(
						this.parser.constructs.flow,
						i,
						t.attempt(eEe, i),
					),
					"linePrefix",
				),
			),
		);
	return n;
	function r(o) {
		if (o === null) {
			t.consume(o);
			return;
		}
		return (
			t.enter("lineEndingBlank"),
			t.consume(o),
			t.exit("lineEndingBlank"),
			(e.currentConstruct = void 0),
			n
		);
	}
	function i(o) {
		if (o === null) {
			t.consume(o);
			return;
		}
		return (
			t.enter("lineEnding"),
			t.consume(o),
			t.exit("lineEnding"),
			(e.currentConstruct = void 0),
			n
		);
	}
}
const JEe = { resolveAll: oG() },
	XEe = iG("string"),
	ZEe = iG("text");
function iG(t) {
	return { tokenize: e, resolveAll: oG(t === "text" ? QEe : void 0) };
	function e(n) {
		const r = this,
			i = this.parser.constructs[t],
			o = n.attempt(i, s, a);
		return s;
		function s(c) {
			return u(c) ? o(c) : a(c);
		}
		function a(c) {
			if (c === null) {
				n.consume(c);
				return;
			}
			return n.enter("data"), n.consume(c), l;
		}
		function l(c) {
			return u(c) ? (n.exit("data"), o(c)) : (n.consume(c), l);
		}
		function u(c) {
			if (c === null) return !0;
			const d = i[c];
			let f = -1;
			if (d)
				for (; ++f < d.length; ) {
					const h = d[f];
					if (!h.previous || h.previous.call(r, r.previous))
						return !0;
				}
			return !1;
		}
	}
}
function oG(t) {
	return e;
	function e(n, r) {
		let i = -1,
			o;
		for (; ++i <= n.length; )
			o === void 0
				? n[i] && n[i][1].type === "data" && ((o = i), i++)
				: (!n[i] || n[i][1].type !== "data") &&
					(i !== o + 2 &&
						((n[o][1].end = n[i - 1][1].end),
						n.splice(o + 2, i - o - 2),
						(i = o + 2)),
					(o = void 0));
		return t ? t(n, r) : n;
	}
}
function QEe(t, e) {
	let n = 0;
	for (; ++n <= t.length; )
		if (
			(n === t.length || t[n][1].type === "lineEnding") &&
			t[n - 1][1].type === "data"
		) {
			const r = t[n - 1][1],
				i = e.sliceStream(r);
			let o = i.length,
				s = -1,
				a = 0,
				l;
			for (; o--; ) {
				const u = i[o];
				if (typeof u == "string") {
					for (s = u.length; u.charCodeAt(s - 1) === 32; ) a++, s--;
					if (s) break;
					s = -1;
				} else if (u === -2) (l = !0), a++;
				else if (u !== -1) {
					o++;
					break;
				}
			}
			if (a) {
				const u = {
					type:
						n === t.length || l || a < 2
							? "lineSuffix"
							: "hardBreakTrailing",
					start: {
						line: r.end.line,
						column: r.end.column - a,
						offset: r.end.offset - a,
						_index: r.start._index + o,
						_bufferIndex: o ? s : r.start._bufferIndex + s,
					},
					end: Object.assign({}, r.end),
				};
				(r.end = Object.assign({}, u.start)),
					r.start.offset === r.end.offset
						? Object.assign(r, u)
						: (t.splice(n, 0, ["enter", u, e], ["exit", u, e]),
							(n += 2));
			}
			n++;
		}
	return t;
}
function eDe(t, e, n) {
	let r = Object.assign(
		n ? Object.assign({}, n) : { line: 1, column: 1, offset: 0 },
		{ _index: 0, _bufferIndex: -1 },
	);
	const i = {},
		o = [];
	let s = [],
		a = [];
	const l = {
			consume: y,
			enter: x,
			exit: C,
			attempt: D(k),
			check: D(w),
			interrupt: D(w, { interrupt: !0 }),
		},
		u = {
			previous: null,
			code: null,
			containerState: {},
			events: [],
			parser: t,
			sliceStream: h,
			sliceSerialize: f,
			now: p,
			defineSkip: g,
			write: d,
		};
	let c = e.tokenize.call(u, l);
	return e.resolveAll && o.push(e), u;
	function d(T) {
		return (
			(s = Fo(s, T)),
			v(),
			s[s.length - 1] !== null
				? []
				: (S(e, 0), (u.events = O3(o, u.events, u)), u.events)
		);
	}
	function f(T, I) {
		return nDe(h(T), I);
	}
	function h(T) {
		return tDe(s, T);
	}
	function p() {
		const { line: T, column: I, offset: F, _index: N, _bufferIndex: O } = r;
		return { line: T, column: I, offset: F, _index: N, _bufferIndex: O };
	}
	function g(T) {
		(i[T.line] = T.column), A();
	}
	function v() {
		let T;
		for (; r._index < s.length; ) {
			const I = s[r._index];
			if (typeof I == "string")
				for (
					T = r._index, r._bufferIndex < 0 && (r._bufferIndex = 0);
					r._index === T && r._bufferIndex < I.length;

				)
					b(I.charCodeAt(r._bufferIndex));
			else b(I);
		}
	}
	function b(T) {
		c = c(T);
	}
	function y(T) {
		He(T)
			? (r.line++, (r.column = 1), (r.offset += T === -3 ? 2 : 1), A())
			: T !== -1 && (r.column++, r.offset++),
			r._bufferIndex < 0
				? r._index++
				: (r._bufferIndex++,
					r._bufferIndex === s[r._index].length &&
						((r._bufferIndex = -1), r._index++)),
			(u.previous = T);
	}
	function x(T, I) {
		const F = I || {};
		return (
			(F.type = T),
			(F.start = p()),
			u.events.push(["enter", F, u]),
			a.push(F),
			F
		);
	}
	function C(T) {
		const I = a.pop();
		return (I.end = p()), u.events.push(["exit", I, u]), I;
	}
	function k(T, I) {
		S(T, I.from);
	}
	function w(T, I) {
		I.restore();
	}
	function D(T, I) {
		return F;
		function F(N, O, _) {
			let j, V, K, M;
			return Array.isArray(N) ? H(N) : "tokenize" in N ? H([N]) : G(N);
			function G(Z) {
				return oe;
				function oe(ne) {
					const de = ne !== null && Z[ne],
						se = ne !== null && Z.null,
						re = [
							...(Array.isArray(de) ? de : de ? [de] : []),
							...(Array.isArray(se) ? se : se ? [se] : []),
						];
					return H(re)(ne);
				}
			}
			function H(Z) {
				return (j = Z), (V = 0), Z.length === 0 ? _ : P(Z[V]);
			}
			function P(Z) {
				return oe;
				function oe(ne) {
					return (
						(M = $()),
						(K = Z),
						Z.partial || (u.currentConstruct = Z),
						Z.name &&
						u.parser.constructs.disable.null.includes(Z.name)
							? J()
							: Z.tokenize.call(
									I ? Object.assign(Object.create(u), I) : u,
									l,
									q,
									J,
								)(ne)
					);
				}
			}
			function q(Z) {
				return T(K, M), O;
			}
			function J(Z) {
				return M.restore(), ++V < j.length ? P(j[V]) : _;
			}
		}
	}
	function S(T, I) {
		T.resolveAll && !o.includes(T) && o.push(T),
			T.resolve &&
				Uo(
					u.events,
					I,
					u.events.length - I,
					T.resolve(u.events.slice(I), u),
				),
			T.resolveTo && (u.events = T.resolveTo(u.events, u));
	}
	function $() {
		const T = p(),
			I = u.previous,
			F = u.currentConstruct,
			N = u.events.length,
			O = Array.from(a);
		return { restore: _, from: N };
		function _() {
			(r = T),
				(u.previous = I),
				(u.currentConstruct = F),
				(u.events.length = N),
				(a = O),
				A();
		}
	}
	function A() {
		r.line in i &&
			r.column < 2 &&
			((r.column = i[r.line]), (r.offset += i[r.line] - 1));
	}
}
function tDe(t, e) {
	const n = e.start._index,
		r = e.start._bufferIndex,
		i = e.end._index,
		o = e.end._bufferIndex;
	let s;
	if (n === i) s = [t[n].slice(r, o)];
	else {
		if (((s = t.slice(n, i)), r > -1)) {
			const a = s[0];
			typeof a == "string" ? (s[0] = a.slice(r)) : s.shift();
		}
		o > 0 && s.push(t[i].slice(0, o));
	}
	return s;
}
function nDe(t, e) {
	let n = -1;
	const r = [];
	let i;
	for (; ++n < t.length; ) {
		const o = t[n];
		let s;
		if (typeof o == "string") s = o;
		else
			switch (o) {
				case -5: {
					s = "\r";
					break;
				}
				case -4: {
					s = `
`;
					break;
				}
				case -3: {
					s = `\r
`;
					break;
				}
				case -2: {
					s = e ? " " : "	";
					break;
				}
				case -1: {
					if (!e && i) continue;
					s = " ";
					break;
				}
				default:
					s = String.fromCharCode(o);
			}
		(i = o === -2), r.push(s);
	}
	return r.join("");
}
const rDe = {
		42: Si,
		43: Si,
		45: Si,
		48: Si,
		49: Si,
		50: Si,
		51: Si,
		52: Si,
		53: Si,
		54: Si,
		55: Si,
		56: Si,
		57: Si,
		62: Xq,
	},
	iDe = { 91: oEe },
	oDe = { [-2]: uC, [-1]: uC, 32: uC },
	sDe = {
		35: dEe,
		42: Fb,
		45: [M7, Fb],
		60: mEe,
		61: M7,
		95: Fb,
		96: R7,
		126: R7,
	},
	aDe = { 38: Qq, 92: Zq },
	lDe = {
		[-5]: cC,
		[-4]: cC,
		[-3]: cC,
		33: PEe,
		38: Qq,
		42: oE,
		60: [R2e, CEe],
		91: REe,
		92: [uEe, Zq],
		93: W5,
		95: oE,
		96: G2e,
	},
	uDe = { null: [oE, JEe] },
	cDe = { null: [42, 95] },
	dDe = { null: [] },
	fDe = Object.freeze(
		Object.defineProperty(
			{
				__proto__: null,
				attentionMarkers: cDe,
				contentInitial: iDe,
				disable: dDe,
				document: rDe,
				flow: sDe,
				flowInitial: oDe,
				insideSpan: uDe,
				string: aDe,
				text: lDe,
			},
			Symbol.toStringTag,
			{ value: "Module" },
		),
	);
function hDe(t) {
	const n = H5([fDe, ...((t || {}).extensions || [])]),
		r = {
			defined: [],
			lazy: {},
			constructs: n,
			content: i($2e),
			document: i(B2e),
			flow: i(GEe),
			string: i(XEe),
			text: i(ZEe),
		};
	return r;
	function i(o) {
		return s;
		function s(a) {
			return eDe(r, o, a);
		}
	}
}
function pDe(t) {
	for (; !eG(t); );
	return t;
}
const j7 = /[\0\t\n\r]/g;
function mDe() {
	let t = 1,
		e = "",
		n = !0,
		r;
	return i;
	function i(o, s, a) {
		const l = [];
		let u, c, d, f, h;
		for (
			o =
				e +
				(typeof o == "string"
					? o.toString()
					: new TextDecoder(s || void 0).decode(o)),
				d = 0,
				e = "",
				n && (o.charCodeAt(0) === 65279 && d++, (n = void 0));
			d < o.length;

		) {
			if (
				((j7.lastIndex = d),
				(u = j7.exec(o)),
				(f = u && u.index !== void 0 ? u.index : o.length),
				(h = o.charCodeAt(f)),
				!u)
			) {
				e = o.slice(d);
				break;
			}
			if (h === 10 && d === f && r) l.push(-3), (r = void 0);
			else
				switch (
					(r && (l.push(-5), (r = void 0)),
					d < f && (l.push(o.slice(d, f)), (t += f - d)),
					h)
				) {
					case 0: {
						l.push(65533), t++;
						break;
					}
					case 9: {
						for (c = Math.ceil(t / 4) * 4, l.push(-2); t++ < c; )
							l.push(-1);
						break;
					}
					case 10: {
						l.push(-4), (t = 1);
						break;
					}
					default:
						(r = !0), (t = 1);
				}
			d = f + 1;
		}
		return a && (r && l.push(-5), e && l.push(e), l.push(null)), l;
	}
}
const gDe = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
function sG(t) {
	return t.replace(gDe, bDe);
}
function bDe(t, e, n) {
	if (e) return e;
	if (n.charCodeAt(0) === 35) {
		const i = n.charCodeAt(1),
			o = i === 120 || i === 88;
		return Jq(n.slice(o ? 2 : 1), o ? 16 : 10);
	}
	return Og(n) || t;
}
function Pb(t) {
	return !t || typeof t != "object"
		? ""
		: "position" in t || "type" in t
			? _7(t.position)
			: "start" in t || "end" in t
				? _7(t)
				: "line" in t || "column" in t
					? sE(t)
					: "";
}
function sE(t) {
	return z7(t && t.line) + ":" + z7(t && t.column);
}
function _7(t) {
	return sE(t && t.start) + "-" + sE(t && t.end);
}
function z7(t) {
	return t && typeof t == "number" ? t : 1;
}
const aG = {}.hasOwnProperty;
function lG(t, e, n) {
	return (
		typeof e != "string" && ((n = e), (e = void 0)),
		vDe(n)(
			pDe(
				hDe(n)
					.document()
					.write(mDe()(t, e, !0)),
			),
		)
	);
}
function vDe(t) {
	const e = {
		transforms: [],
		canContainEols: [
			"emphasis",
			"fragment",
			"heading",
			"paragraph",
			"strong",
		],
		enter: {
			autolink: o(Ce),
			autolinkProtocol: $,
			autolinkEmail: $,
			atxHeading: o(Pe),
			blockQuote: o(se),
			characterEscape: $,
			characterReference: $,
			codeFenced: o(re),
			codeFencedFenceInfo: s,
			codeFencedFenceMeta: s,
			codeIndented: o(re, s),
			codeText: o(he, s),
			codeTextData: $,
			data: $,
			codeFlowValue: $,
			definition: o(ye),
			definitionDestinationString: s,
			definitionLabelString: s,
			definitionTitleString: s,
			emphasis: o(Ae),
			hardBreakEscape: o(we),
			hardBreakTrailing: o(we),
			htmlFlow: o(Ke, s),
			htmlFlowData: $,
			htmlText: o(Ke, s),
			htmlTextData: $,
			image: o(rt),
			label: s,
			link: o(Ce),
			listItem: o(me),
			listItemValue: f,
			listOrdered: o(Me, d),
			listUnordered: o(Me),
			paragraph: o(De),
			reference: P,
			referenceString: s,
			resourceDestinationString: s,
			resourceTitleString: s,
			setextHeading: o(Pe),
			strong: o(_e),
			thematicBreak: o(Et),
		},
		exit: {
			atxHeading: l(),
			atxHeadingSequence: k,
			autolink: l(),
			autolinkEmail: de,
			autolinkProtocol: ne,
			blockQuote: l(),
			characterEscapeValue: A,
			characterReferenceMarkerHexadecimal: J,
			characterReferenceMarkerNumeric: J,
			characterReferenceValue: Z,
			characterReference: oe,
			codeFenced: l(v),
			codeFencedFence: g,
			codeFencedFenceInfo: h,
			codeFencedFenceMeta: p,
			codeFlowValue: A,
			codeIndented: l(b),
			codeText: l(O),
			codeTextData: A,
			data: A,
			definition: l(),
			definitionDestinationString: C,
			definitionLabelString: y,
			definitionTitleString: x,
			emphasis: l(),
			hardBreakEscape: l(I),
			hardBreakTrailing: l(I),
			htmlFlow: l(F),
			htmlFlowData: A,
			htmlText: l(N),
			htmlTextData: A,
			image: l(j),
			label: K,
			labelText: V,
			lineEnding: T,
			link: l(_),
			listItem: l(),
			listOrdered: l(),
			listUnordered: l(),
			paragraph: l(),
			referenceString: q,
			resourceDestinationString: M,
			resourceTitleString: G,
			resource: H,
			setextHeading: l(S),
			setextHeadingLineSequence: D,
			setextHeadingText: w,
			strong: l(),
			thematicBreak: l(),
		},
	};
	uG(e, (t || {}).mdastExtensions || []);
	const n = {};
	return r;
	function r(ae) {
		let fe = { type: "root", children: [] };
		const U = {
				stack: [fe],
				tokenStack: [],
				config: e,
				enter: a,
				exit: u,
				buffer: s,
				resume: c,
				data: n,
			},
			tt = [];
		let Dt = -1;
		for (; ++Dt < ae.length; )
			if (
				ae[Dt][1].type === "listOrdered" ||
				ae[Dt][1].type === "listUnordered"
			)
				if (ae[Dt][0] === "enter") tt.push(Dt);
				else {
					const Xt = tt.pop();
					Dt = i(ae, Xt, Dt);
				}
		for (Dt = -1; ++Dt < ae.length; ) {
			const Xt = e[ae[Dt][0]];
			aG.call(Xt, ae[Dt][1].type) &&
				Xt[ae[Dt][1].type].call(
					Object.assign(
						{ sliceSerialize: ae[Dt][2].sliceSerialize },
						U,
					),
					ae[Dt][1],
				);
		}
		if (U.tokenStack.length > 0) {
			const Xt = U.tokenStack[U.tokenStack.length - 1];
			(Xt[1] || L7).call(U, void 0, Xt[0]);
		}
		for (
			fe.position = {
				start: Vl(
					ae.length > 0
						? ae[0][1].start
						: { line: 1, column: 1, offset: 0 },
				),
				end: Vl(
					ae.length > 0
						? ae[ae.length - 2][1].end
						: { line: 1, column: 1, offset: 0 },
				),
			},
				Dt = -1;
			++Dt < e.transforms.length;

		)
			fe = e.transforms[Dt](fe) || fe;
		return fe;
	}
	function i(ae, fe, U) {
		let tt = fe - 1,
			Dt = -1,
			Xt = !1,
			bn,
			Qr,
			Na,
			lc;
		for (; ++tt <= U; ) {
			const ei = ae[tt];
			switch (ei[1].type) {
				case "listUnordered":
				case "listOrdered":
				case "blockQuote": {
					ei[0] === "enter" ? Dt++ : Dt--, (lc = void 0);
					break;
				}
				case "lineEndingBlank": {
					ei[0] === "enter" &&
						(bn && !lc && !Dt && !Na && (Na = tt), (lc = void 0));
					break;
				}
				case "linePrefix":
				case "listItemValue":
				case "listItemMarker":
				case "listItemPrefix":
				case "listItemPrefixWhitespace":
					break;
				default:
					lc = void 0;
			}
			if (
				(!Dt && ei[0] === "enter" && ei[1].type === "listItemPrefix") ||
				(Dt === -1 &&
					ei[0] === "exit" &&
					(ei[1].type === "listUnordered" ||
						ei[1].type === "listOrdered"))
			) {
				if (bn) {
					let jl = tt;
					for (Qr = void 0; jl--; ) {
						const ts = ae[jl];
						if (
							ts[1].type === "lineEnding" ||
							ts[1].type === "lineEndingBlank"
						) {
							if (ts[0] === "exit") continue;
							Qr &&
								((ae[Qr][1].type = "lineEndingBlank"),
								(Xt = !0)),
								(ts[1].type = "lineEnding"),
								(Qr = jl);
						} else if (
							!(
								ts[1].type === "linePrefix" ||
								ts[1].type === "blockQuotePrefix" ||
								ts[1].type === "blockQuotePrefixWhitespace" ||
								ts[1].type === "blockQuoteMarker" ||
								ts[1].type === "listItemIndent"
							)
						)
							break;
					}
					Na && (!Qr || Na < Qr) && (bn._spread = !0),
						(bn.end = Object.assign(
							{},
							Qr ? ae[Qr][1].start : ei[1].end,
						)),
						ae.splice(Qr || tt, 0, ["exit", bn, ei[2]]),
						tt++,
						U++;
				}
				if (ei[1].type === "listItemPrefix") {
					const jl = {
						type: "listItem",
						_spread: !1,
						start: Object.assign({}, ei[1].start),
						end: void 0,
					};
					(bn = jl),
						ae.splice(tt, 0, ["enter", jl, ei[2]]),
						tt++,
						U++,
						(Na = void 0),
						(lc = !0);
				}
			}
		}
		return (ae[fe][1]._spread = Xt), U;
	}
	function o(ae, fe) {
		return U;
		function U(tt) {
			a.call(this, ae(tt), tt), fe && fe.call(this, tt);
		}
	}
	function s() {
		this.stack.push({ type: "fragment", children: [] });
	}
	function a(ae, fe, U) {
		this.stack[this.stack.length - 1].children.push(ae),
			this.stack.push(ae),
			this.tokenStack.push([fe, U]),
			(ae.position = { start: Vl(fe.start), end: void 0 });
	}
	function l(ae) {
		return fe;
		function fe(U) {
			ae && ae.call(this, U), u.call(this, U);
		}
	}
	function u(ae, fe) {
		const U = this.stack.pop(),
			tt = this.tokenStack.pop();
		if (tt)
			tt[0].type !== ae.type &&
				(fe
					? fe.call(this, ae, tt[0])
					: (tt[1] || L7).call(this, ae, tt[0]));
		else
			throw new Error(
				"Cannot close `" +
					ae.type +
					"` (" +
					Pb({ start: ae.start, end: ae.end }) +
					"): it’s not open",
			);
		U.position.end = Vl(ae.end);
	}
	function c() {
		return U5(this.stack.pop());
	}
	function d() {
		this.data.expectingFirstListItemValue = !0;
	}
	function f(ae) {
		if (this.data.expectingFirstListItemValue) {
			const fe = this.stack[this.stack.length - 2];
			(fe.start = Number.parseInt(this.sliceSerialize(ae), 10)),
				(this.data.expectingFirstListItemValue = void 0);
		}
	}
	function h() {
		const ae = this.resume(),
			fe = this.stack[this.stack.length - 1];
		fe.lang = ae;
	}
	function p() {
		const ae = this.resume(),
			fe = this.stack[this.stack.length - 1];
		fe.meta = ae;
	}
	function g() {
		this.data.flowCodeInside ||
			(this.buffer(), (this.data.flowCodeInside = !0));
	}
	function v() {
		const ae = this.resume(),
			fe = this.stack[this.stack.length - 1];
		(fe.value = ae.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, "")),
			(this.data.flowCodeInside = void 0);
	}
	function b() {
		const ae = this.resume(),
			fe = this.stack[this.stack.length - 1];
		fe.value = ae.replace(/(\r?\n|\r)$/g, "");
	}
	function y(ae) {
		const fe = this.resume(),
			U = this.stack[this.stack.length - 1];
		(U.label = fe),
			(U.identifier = Ds(this.sliceSerialize(ae)).toLowerCase());
	}
	function x() {
		const ae = this.resume(),
			fe = this.stack[this.stack.length - 1];
		fe.title = ae;
	}
	function C() {
		const ae = this.resume(),
			fe = this.stack[this.stack.length - 1];
		fe.url = ae;
	}
	function k(ae) {
		const fe = this.stack[this.stack.length - 1];
		if (!fe.depth) {
			const U = this.sliceSerialize(ae).length;
			fe.depth = U;
		}
	}
	function w() {
		this.data.setextHeadingSlurpLineEnding = !0;
	}
	function D(ae) {
		const fe = this.stack[this.stack.length - 1];
		fe.depth = this.sliceSerialize(ae).codePointAt(0) === 61 ? 1 : 2;
	}
	function S() {
		this.data.setextHeadingSlurpLineEnding = void 0;
	}
	function $(ae) {
		const U = this.stack[this.stack.length - 1].children;
		let tt = U[U.length - 1];
		(!tt || tt.type !== "text") &&
			((tt = We()),
			(tt.position = { start: Vl(ae.start), end: void 0 }),
			U.push(tt)),
			this.stack.push(tt);
	}
	function A(ae) {
		const fe = this.stack.pop();
		(fe.value += this.sliceSerialize(ae)), (fe.position.end = Vl(ae.end));
	}
	function T(ae) {
		const fe = this.stack[this.stack.length - 1];
		if (this.data.atHardBreak) {
			const U = fe.children[fe.children.length - 1];
			(U.position.end = Vl(ae.end)), (this.data.atHardBreak = void 0);
			return;
		}
		!this.data.setextHeadingSlurpLineEnding &&
			e.canContainEols.includes(fe.type) &&
			($.call(this, ae), A.call(this, ae));
	}
	function I() {
		this.data.atHardBreak = !0;
	}
	function F() {
		const ae = this.resume(),
			fe = this.stack[this.stack.length - 1];
		fe.value = ae;
	}
	function N() {
		const ae = this.resume(),
			fe = this.stack[this.stack.length - 1];
		fe.value = ae;
	}
	function O() {
		const ae = this.resume(),
			fe = this.stack[this.stack.length - 1];
		fe.value = ae;
	}
	function _() {
		const ae = this.stack[this.stack.length - 1];
		if (this.data.inReference) {
			const fe = this.data.referenceType || "shortcut";
			(ae.type += "Reference"),
				(ae.referenceType = fe),
				delete ae.url,
				delete ae.title;
		} else delete ae.identifier, delete ae.label;
		this.data.referenceType = void 0;
	}
	function j() {
		const ae = this.stack[this.stack.length - 1];
		if (this.data.inReference) {
			const fe = this.data.referenceType || "shortcut";
			(ae.type += "Reference"),
				(ae.referenceType = fe),
				delete ae.url,
				delete ae.title;
		} else delete ae.identifier, delete ae.label;
		this.data.referenceType = void 0;
	}
	function V(ae) {
		const fe = this.sliceSerialize(ae),
			U = this.stack[this.stack.length - 2];
		(U.label = sG(fe)), (U.identifier = Ds(fe).toLowerCase());
	}
	function K() {
		const ae = this.stack[this.stack.length - 1],
			fe = this.resume(),
			U = this.stack[this.stack.length - 1];
		if (((this.data.inReference = !0), U.type === "link")) {
			const tt = ae.children;
			U.children = tt;
		} else U.alt = fe;
	}
	function M() {
		const ae = this.resume(),
			fe = this.stack[this.stack.length - 1];
		fe.url = ae;
	}
	function G() {
		const ae = this.resume(),
			fe = this.stack[this.stack.length - 1];
		fe.title = ae;
	}
	function H() {
		this.data.inReference = void 0;
	}
	function P() {
		this.data.referenceType = "collapsed";
	}
	function q(ae) {
		const fe = this.resume(),
			U = this.stack[this.stack.length - 1];
		(U.label = fe),
			(U.identifier = Ds(this.sliceSerialize(ae)).toLowerCase()),
			(this.data.referenceType = "full");
	}
	function J(ae) {
		this.data.characterReferenceType = ae.type;
	}
	function Z(ae) {
		const fe = this.sliceSerialize(ae),
			U = this.data.characterReferenceType;
		let tt;
		U
			? ((tt = Jq(fe, U === "characterReferenceMarkerNumeric" ? 10 : 16)),
				(this.data.characterReferenceType = void 0))
			: (tt = Og(fe));
		const Dt = this.stack[this.stack.length - 1];
		Dt.value += tt;
	}
	function oe(ae) {
		const fe = this.stack.pop();
		fe.position.end = Vl(ae.end);
	}
	function ne(ae) {
		A.call(this, ae);
		const fe = this.stack[this.stack.length - 1];
		fe.url = this.sliceSerialize(ae);
	}
	function de(ae) {
		A.call(this, ae);
		const fe = this.stack[this.stack.length - 1];
		fe.url = "mailto:" + this.sliceSerialize(ae);
	}
	function se() {
		return { type: "blockquote", children: [] };
	}
	function re() {
		return { type: "code", lang: null, meta: null, value: "" };
	}
	function he() {
		return { type: "inlineCode", value: "" };
	}
	function ye() {
		return {
			type: "definition",
			identifier: "",
			label: null,
			title: null,
			url: "",
		};
	}
	function Ae() {
		return { type: "emphasis", children: [] };
	}
	function Pe() {
		return { type: "heading", depth: 0, children: [] };
	}
	function we() {
		return { type: "break" };
	}
	function Ke() {
		return { type: "html", value: "" };
	}
	function rt() {
		return { type: "image", title: null, url: "", alt: null };
	}
	function Ce() {
		return { type: "link", title: null, url: "", children: [] };
	}
	function Me(ae) {
		return {
			type: "list",
			ordered: ae.type === "listOrdered",
			start: null,
			spread: ae._spread,
			children: [],
		};
	}
	function me(ae) {
		return {
			type: "listItem",
			spread: ae._spread,
			checked: null,
			children: [],
		};
	}
	function De() {
		return { type: "paragraph", children: [] };
	}
	function _e() {
		return { type: "strong", children: [] };
	}
	function We() {
		return { type: "text", value: "" };
	}
	function Et() {
		return { type: "thematicBreak" };
	}
}
function Vl(t) {
	return { line: t.line, column: t.column, offset: t.offset };
}
function uG(t, e) {
	let n = -1;
	for (; ++n < e.length; ) {
		const r = e[n];
		Array.isArray(r) ? uG(t, r) : yDe(t, r);
	}
}
function yDe(t, e) {
	let n;
	for (n in e)
		if (aG.call(e, n))
			switch (n) {
				case "canContainEols": {
					const r = e[n];
					r && t[n].push(...r);
					break;
				}
				case "transforms": {
					const r = e[n];
					r && t[n].push(...r);
					break;
				}
				case "enter":
				case "exit": {
					const r = e[n];
					r && Object.assign(t[n], r);
					break;
				}
			}
}
function L7(t, e) {
	throw t
		? new Error(
				"Cannot close `" +
					t.type +
					"` (" +
					Pb({ start: t.start, end: t.end }) +
					"): a different token (`" +
					e.type +
					"`, " +
					Pb({ start: e.start, end: e.end }) +
					") is open",
			)
		: new Error(
				"Cannot close document, a token (`" +
					e.type +
					"`, " +
					Pb({ start: e.start, end: e.end }) +
					") is still open",
			);
}
function Fy(t, e) {
	const n = String(t);
	if (typeof e != "string") throw new TypeError("Expected character");
	let r = 0,
		i = n.indexOf(e);
	for (; i !== -1; ) r++, (i = n.indexOf(e, i + e.length));
	return r;
}
function xDe(t) {
	if (typeof t != "string") throw new TypeError("Expected a string");
	return t.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
const M3 = function (t) {
	if (t == null) return EDe;
	if (typeof t == "function") return j3(t);
	if (typeof t == "object") return Array.isArray(t) ? kDe(t) : CDe(t);
	if (typeof t == "string") return wDe(t);
	throw new Error("Expected function, string, or object as test");
};
function kDe(t) {
	const e = [];
	let n = -1;
	for (; ++n < t.length; ) e[n] = M3(t[n]);
	return j3(r);
	function r(...i) {
		let o = -1;
		for (; ++o < e.length; ) if (e[o].apply(this, i)) return !0;
		return !1;
	}
}
function CDe(t) {
	const e = t;
	return j3(n);
	function n(r) {
		const i = r;
		let o;
		for (o in t) if (i[o] !== e[o]) return !1;
		return !0;
	}
}
function wDe(t) {
	return j3(e);
	function e(n) {
		return n && n.type === t;
	}
}
function j3(t) {
	return e;
	function e(n, r, i) {
		return !!(
			DDe(n) &&
			t.call(this, n, typeof r == "number" ? r : void 0, i || void 0)
		);
	}
}
function EDe() {
	return !0;
}
function DDe(t) {
	return t !== null && typeof t == "object" && "type" in t;
}
const cG = [],
	SDe = !0,
	aE = !1,
	ADe = "skip";
function dG(t, e, n, r) {
	let i;
	typeof e == "function" && typeof n != "function"
		? ((r = n), (n = e))
		: (i = e);
	const o = M3(i),
		s = r ? -1 : 1;
	a(t, void 0, [])();
	function a(l, u, c) {
		const d = l && typeof l == "object" ? l : {};
		if (typeof d.type == "string") {
			const h =
				typeof d.tagName == "string"
					? d.tagName
					: typeof d.name == "string"
						? d.name
						: void 0;
			Object.defineProperty(f, "name", {
				value: "node (" + (l.type + (h ? "<" + h + ">" : "")) + ")",
			});
		}
		return f;
		function f() {
			let h = cG,
				p,
				g,
				v;
			if (
				(!e || o(l, u, c[c.length - 1] || void 0)) &&
				((h = $De(n(l, c))), h[0] === aE)
			)
				return h;
			if ("children" in l && l.children) {
				const b = l;
				if (b.children && h[0] !== ADe)
					for (
						g = (r ? b.children.length : -1) + s, v = c.concat(b);
						g > -1 && g < b.children.length;

					) {
						const y = b.children[g];
						if (((p = a(y, g, v)()), p[0] === aE)) return p;
						g = typeof p[1] == "number" ? p[1] : g + s;
					}
			}
			return h;
		}
	}
}
function $De(t) {
	return Array.isArray(t)
		? t
		: typeof t == "number"
			? [SDe, t]
			: t == null
				? cG
				: [t];
}
function TDe(t, e, n) {
	const i = M3((n || {}).ignore || []),
		o = BDe(e);
	let s = -1;
	for (; ++s < o.length; ) dG(t, "text", a);
	function a(u, c) {
		let d = -1,
			f;
		for (; ++d < c.length; ) {
			const h = c[d],
				p = f ? f.children : void 0;
			if (i(h, p ? p.indexOf(h) : void 0, f)) return;
			f = h;
		}
		if (f) return l(u, c);
	}
	function l(u, c) {
		const d = c[c.length - 1],
			f = o[s][0],
			h = o[s][1];
		let p = 0;
		const v = d.children.indexOf(u);
		let b = !1,
			y = [];
		f.lastIndex = 0;
		let x = f.exec(u.value);
		for (; x; ) {
			const C = x.index,
				k = { index: x.index, input: x.input, stack: [...c, u] };
			let w = h(...x, k);
			if (
				(typeof w == "string" &&
					(w = w.length > 0 ? { type: "text", value: w } : void 0),
				w === !1
					? (f.lastIndex = C + 1)
					: (p !== C &&
							y.push({
								type: "text",
								value: u.value.slice(p, C),
							}),
						Array.isArray(w) ? y.push(...w) : w && y.push(w),
						(p = C + x[0].length),
						(b = !0)),
				!f.global)
			)
				break;
			x = f.exec(u.value);
		}
		return (
			b
				? (p < u.value.length &&
						y.push({ type: "text", value: u.value.slice(p) }),
					d.children.splice(v, 1, ...y))
				: (y = [u]),
			v + y.length
		);
	}
}
function BDe(t) {
	const e = [];
	if (!Array.isArray(t))
		throw new TypeError(
			"Expected find and replace tuple or list of tuples",
		);
	const n = !t[0] || Array.isArray(t[0]) ? t : [t];
	let r = -1;
	for (; ++r < n.length; ) {
		const i = n[r];
		e.push([IDe(i[0]), FDe(i[1])]);
	}
	return e;
}
function IDe(t) {
	return typeof t == "string" ? new RegExp(xDe(t), "g") : t;
}
function FDe(t) {
	return typeof t == "function"
		? t
		: function () {
				return t;
			};
}
const dC = "phrasing",
	fC = ["autolink", "link", "image", "label"];
function fG() {
	return {
		transforms: [_De],
		enter: {
			literalAutolink: NDe,
			literalAutolinkEmail: hC,
			literalAutolinkHttp: hC,
			literalAutolinkWww: hC,
		},
		exit: {
			literalAutolink: jDe,
			literalAutolinkEmail: MDe,
			literalAutolinkHttp: RDe,
			literalAutolinkWww: ODe,
		},
	};
}
function PDe() {
	return {
		unsafe: [
			{
				character: "@",
				before: "[+\\-.\\w]",
				after: "[\\-.\\w]",
				inConstruct: dC,
				notInConstruct: fC,
			},
			{
				character: ".",
				before: "[Ww]",
				after: "[\\-.\\w]",
				inConstruct: dC,
				notInConstruct: fC,
			},
			{
				character: ":",
				before: "[ps]",
				after: "\\/",
				inConstruct: dC,
				notInConstruct: fC,
			},
		],
	};
}
function NDe(t) {
	this.enter({ type: "link", title: null, url: "", children: [] }, t);
}
function hC(t) {
	this.config.enter.autolinkProtocol.call(this, t);
}
function RDe(t) {
	this.config.exit.autolinkProtocol.call(this, t);
}
function ODe(t) {
	this.config.exit.data.call(this, t);
	const e = this.stack[this.stack.length - 1];
	e.type, (e.url = "http://" + this.sliceSerialize(t));
}
function MDe(t) {
	this.config.exit.autolinkEmail.call(this, t);
}
function jDe(t) {
	this.exit(t);
}
function _De(t) {
	TDe(
		t,
		[
			[/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/gi, zDe],
			[
				new RegExp(
					"(?<=^|\\s|\\p{P}|\\p{S})([-.\\w+]+)@([-\\w]+(?:\\.[-\\w]+)+)",
					"gu",
				),
				LDe,
			],
		],
		{ ignore: ["link", "linkReference"] },
	);
}
function zDe(t, e, n, r, i) {
	let o = "";
	if (
		!hG(i) ||
		(/^w/i.test(e) && ((n = e + n), (e = ""), (o = "http://")), !VDe(n))
	)
		return !1;
	const s = KDe(n + r);
	if (!s[0]) return !1;
	const a = {
		type: "link",
		title: null,
		url: o + e + s[0],
		children: [{ type: "text", value: e + s[0] }],
	};
	return s[1] ? [a, { type: "text", value: s[1] }] : a;
}
function LDe(t, e, n, r) {
	return !hG(r, !0) || /[-\d_]$/.test(n)
		? !1
		: {
				type: "link",
				title: null,
				url: "mailto:" + e + "@" + n,
				children: [{ type: "text", value: e + "@" + n }],
			};
}
function VDe(t) {
	const e = t.split(".");
	return !(
		e.length < 2 ||
		(e[e.length - 1] &&
			(/_/.test(e[e.length - 1]) ||
				!/[a-zA-Z\d]/.test(e[e.length - 1]))) ||
		(e[e.length - 2] &&
			(/_/.test(e[e.length - 2]) || !/[a-zA-Z\d]/.test(e[e.length - 2])))
	);
}
function KDe(t) {
	const e = /[!"&'),.:;<>?\]}]+$/.exec(t);
	if (!e) return [t, void 0];
	t = t.slice(0, e.index);
	let n = e[0],
		r = n.indexOf(")");
	const i = Fy(t, "(");
	let o = Fy(t, ")");
	for (; r !== -1 && i > o; )
		(t += n.slice(0, r + 1)),
			(n = n.slice(r + 1)),
			(r = n.indexOf(")")),
			o++;
	return [t, n];
}
function hG(t, e) {
	const n = t.input.charCodeAt(t.index - 1);
	return (t.index === 0 || ai(n) || R3(n)) && (!e || n !== 47);
}
const UDe = { tokenize: YDe, partial: !0 },
	pG = { tokenize: JDe, partial: !0 },
	mG = { tokenize: XDe, partial: !0 },
	gG = { tokenize: ZDe, partial: !0 },
	HDe = { tokenize: QDe, partial: !0 },
	bG = { name: "wwwAutolink", tokenize: qDe, previous: xG },
	vG = { name: "protocolAutolink", tokenize: GDe, previous: kG },
	Ol = { name: "emailAutolink", tokenize: WDe, previous: CG },
	Aa = {};
function yG() {
	return { text: Aa };
}
let pc = 48;
for (; pc < 123; )
	(Aa[pc] = Ol), pc++, pc === 58 ? (pc = 65) : pc === 91 && (pc = 97);
Aa[43] = Ol;
Aa[45] = Ol;
Aa[46] = Ol;
Aa[95] = Ol;
Aa[72] = [Ol, vG];
Aa[104] = [Ol, vG];
Aa[87] = [Ol, bG];
Aa[119] = [Ol, bG];
function WDe(t, e, n) {
	const r = this;
	let i, o;
	return s;
	function s(d) {
		return !lE(d) || !CG.call(r, r.previous) || q5(r.events)
			? n(d)
			: (t.enter("literalAutolink"),
				t.enter("literalAutolinkEmail"),
				a(d));
	}
	function a(d) {
		return lE(d) ? (t.consume(d), a) : d === 64 ? (t.consume(d), l) : n(d);
	}
	function l(d) {
		return d === 46
			? t.check(HDe, c, u)(d)
			: d === 45 || d === 95 || Oi(d)
				? ((o = !0), t.consume(d), l)
				: c(d);
	}
	function u(d) {
		return t.consume(d), (i = !0), l;
	}
	function c(d) {
		return o && i && Vr(r.previous)
			? (t.exit("literalAutolinkEmail"), t.exit("literalAutolink"), e(d))
			: n(d);
	}
}
function qDe(t, e, n) {
	const r = this;
	return i;
	function i(s) {
		return (s !== 87 && s !== 119) ||
			!xG.call(r, r.previous) ||
			q5(r.events)
			? n(s)
			: (t.enter("literalAutolink"),
				t.enter("literalAutolinkWww"),
				t.check(UDe, t.attempt(pG, t.attempt(mG, o), n), n)(s));
	}
	function o(s) {
		return t.exit("literalAutolinkWww"), t.exit("literalAutolink"), e(s);
	}
}
function GDe(t, e, n) {
	const r = this;
	let i = "",
		o = !1;
	return s;
	function s(d) {
		return (d === 72 || d === 104) &&
			kG.call(r, r.previous) &&
			!q5(r.events)
			? (t.enter("literalAutolink"),
				t.enter("literalAutolinkHttp"),
				(i += String.fromCodePoint(d)),
				t.consume(d),
				a)
			: n(d);
	}
	function a(d) {
		if (Vr(d) && i.length < 5)
			return (i += String.fromCodePoint(d)), t.consume(d), a;
		if (d === 58) {
			const f = i.toLowerCase();
			if (f === "http" || f === "https") return t.consume(d), l;
		}
		return n(d);
	}
	function l(d) {
		return d === 47 ? (t.consume(d), o ? u : ((o = !0), l)) : n(d);
	}
	function u(d) {
		return d === null || By(d) || It(d) || ai(d) || R3(d)
			? n(d)
			: t.attempt(pG, t.attempt(mG, c), n)(d);
	}
	function c(d) {
		return t.exit("literalAutolinkHttp"), t.exit("literalAutolink"), e(d);
	}
}
function YDe(t, e, n) {
	let r = 0;
	return i;
	function i(s) {
		return (s === 87 || s === 119) && r < 3
			? (r++, t.consume(s), i)
			: s === 46 && r === 3
				? (t.consume(s), o)
				: n(s);
	}
	function o(s) {
		return s === null ? n(s) : e(s);
	}
}
function JDe(t, e, n) {
	let r, i, o;
	return s;
	function s(u) {
		return u === 46 || u === 95
			? t.check(gG, l, a)(u)
			: u === null || It(u) || ai(u) || (u !== 45 && R3(u))
				? l(u)
				: ((o = !0), t.consume(u), s);
	}
	function a(u) {
		return u === 95 ? (r = !0) : ((i = r), (r = void 0)), t.consume(u), s;
	}
	function l(u) {
		return i || r || !o ? n(u) : e(u);
	}
}
function XDe(t, e) {
	let n = 0,
		r = 0;
	return i;
	function i(s) {
		return s === 40
			? (n++, t.consume(s), i)
			: s === 41 && r < n
				? o(s)
				: s === 33 ||
					  s === 34 ||
					  s === 38 ||
					  s === 39 ||
					  s === 41 ||
					  s === 42 ||
					  s === 44 ||
					  s === 46 ||
					  s === 58 ||
					  s === 59 ||
					  s === 60 ||
					  s === 63 ||
					  s === 93 ||
					  s === 95 ||
					  s === 126
					? t.check(gG, e, o)(s)
					: s === null || It(s) || ai(s)
						? e(s)
						: (t.consume(s), i);
	}
	function o(s) {
		return s === 41 && r++, t.consume(s), i;
	}
}
function ZDe(t, e, n) {
	return r;
	function r(a) {
		return a === 33 ||
			a === 34 ||
			a === 39 ||
			a === 41 ||
			a === 42 ||
			a === 44 ||
			a === 46 ||
			a === 58 ||
			a === 59 ||
			a === 63 ||
			a === 95 ||
			a === 126
			? (t.consume(a), r)
			: a === 38
				? (t.consume(a), o)
				: a === 93
					? (t.consume(a), i)
					: a === 60 || a === null || It(a) || ai(a)
						? e(a)
						: n(a);
	}
	function i(a) {
		return a === null || a === 40 || a === 91 || It(a) || ai(a)
			? e(a)
			: r(a);
	}
	function o(a) {
		return Vr(a) ? s(a) : n(a);
	}
	function s(a) {
		return a === 59 ? (t.consume(a), r) : Vr(a) ? (t.consume(a), s) : n(a);
	}
}
function QDe(t, e, n) {
	return r;
	function r(o) {
		return t.consume(o), i;
	}
	function i(o) {
		return Oi(o) ? n(o) : e(o);
	}
}
function xG(t) {
	return (
		t === null ||
		t === 40 ||
		t === 42 ||
		t === 95 ||
		t === 91 ||
		t === 93 ||
		t === 126 ||
		It(t)
	);
}
function kG(t) {
	return !Vr(t);
}
function CG(t) {
	return !(t === 47 || lE(t));
}
function lE(t) {
	return t === 43 || t === 45 || t === 46 || t === 95 || Oi(t);
}
function q5(t) {
	let e = t.length,
		n = !1;
	for (; e--; ) {
		const r = t[e][1];
		if (
			(r.type === "labelLink" || r.type === "labelImage") &&
			!r._balanced
		) {
			n = !0;
			break;
		}
		if (r._gfmAutolinkLiteralWalkedInto) {
			n = !1;
			break;
		}
	}
	return (
		t.length > 0 &&
			!n &&
			(t[t.length - 1][1]._gfmAutolinkLiteralWalkedInto = !0),
		n
	);
}
const eSe = [
	"autolink",
	"destinationLiteral",
	"destinationRaw",
	"reference",
	"titleQuote",
	"titleApostrophe",
];
EG.peek = iSe;
function wG() {
	return {
		canContainEols: ["delete"],
		enter: { strikethrough: nSe },
		exit: { strikethrough: rSe },
	};
}
function tSe() {
	return {
		unsafe: [
			{ character: "~", inConstruct: "phrasing", notInConstruct: eSe },
		],
		handlers: { delete: EG },
	};
}
function nSe(t) {
	this.enter({ type: "delete", children: [] }, t);
}
function rSe(t) {
	this.exit(t);
}
function EG(t, e, n, r) {
	const i = n.createTracker(r),
		o = n.enter("strikethrough");
	let s = i.move("~~");
	return (
		(s += n.containerPhrasing(t, {
			...i.current(),
			before: s,
			after: "~",
		})),
		(s += i.move("~~")),
		o(),
		s
	);
}
function iSe() {
	return "~";
}
function DG(t) {
	let n = {}.singleTilde;
	const r = { name: "strikethrough", tokenize: o, resolveAll: i };
	return (
		n == null && (n = !0),
		{
			text: { 126: r },
			insideSpan: { null: [r] },
			attentionMarkers: { null: [126] },
		}
	);
	function i(s, a) {
		let l = -1;
		for (; ++l < s.length; )
			if (
				s[l][0] === "enter" &&
				s[l][1].type === "strikethroughSequenceTemporary" &&
				s[l][1]._close
			) {
				let u = l;
				for (; u--; )
					if (
						s[u][0] === "exit" &&
						s[u][1].type === "strikethroughSequenceTemporary" &&
						s[u][1]._open &&
						s[l][1].end.offset - s[l][1].start.offset ===
							s[u][1].end.offset - s[u][1].start.offset
					) {
						(s[l][1].type = "strikethroughSequence"),
							(s[u][1].type = "strikethroughSequence");
						const c = {
								type: "strikethrough",
								start: Object.assign({}, s[u][1].start),
								end: Object.assign({}, s[l][1].end),
							},
							d = {
								type: "strikethroughText",
								start: Object.assign({}, s[u][1].end),
								end: Object.assign({}, s[l][1].start),
							},
							f = [
								["enter", c, a],
								["enter", s[u][1], a],
								["exit", s[u][1], a],
								["enter", d, a],
							],
							h = a.parser.constructs.insideSpan.null;
						h && Uo(f, f.length, 0, O3(h, s.slice(u + 1, l), a)),
							Uo(f, f.length, 0, [
								["exit", d, a],
								["enter", s[l][1], a],
								["exit", s[l][1], a],
								["exit", c, a],
							]),
							Uo(s, u - 1, l - u + 3, f),
							(l = u + f.length - 2);
						break;
					}
			}
		for (l = -1; ++l < s.length; )
			s[l][1].type === "strikethroughSequenceTemporary" &&
				(s[l][1].type = "data");
		return s;
	}
	function o(s, a, l) {
		const u = this.previous,
			c = this.events;
		let d = 0;
		return f;
		function f(p) {
			return u === 126 && c[c.length - 1][1].type !== "characterEscape"
				? l(p)
				: (s.enter("strikethroughSequenceTemporary"), h(p));
		}
		function h(p) {
			const g = Iy(u);
			if (p === 126) return d > 1 ? l(p) : (s.consume(p), d++, h);
			if (d < 2 && !n) return l(p);
			const v = s.exit("strikethroughSequenceTemporary"),
				b = Iy(p);
			return (
				(v._open = !b || (b === 2 && !!g)),
				(v._close = !g || (g === 2 && !!b)),
				a(p)
			);
		}
	}
}
var Xu = {
		8: "Backspace",
		9: "Tab",
		10: "Enter",
		12: "NumLock",
		13: "Enter",
		16: "Shift",
		17: "Control",
		18: "Alt",
		20: "CapsLock",
		27: "Escape",
		32: " ",
		33: "PageUp",
		34: "PageDown",
		35: "End",
		36: "Home",
		37: "ArrowLeft",
		38: "ArrowUp",
		39: "ArrowRight",
		40: "ArrowDown",
		44: "PrintScreen",
		45: "Insert",
		46: "Delete",
		59: ";",
		61: "=",
		91: "Meta",
		92: "Meta",
		106: "*",
		107: "+",
		108: ",",
		109: "-",
		110: ".",
		111: "/",
		144: "NumLock",
		145: "ScrollLock",
		160: "Shift",
		161: "Shift",
		162: "Control",
		163: "Control",
		164: "Alt",
		165: "Alt",
		173: "-",
		186: ";",
		187: "=",
		188: ",",
		189: "-",
		190: ".",
		191: "/",
		192: "`",
		219: "[",
		220: "\\",
		221: "]",
		222: "'",
	},
	Py = {
		48: ")",
		49: "!",
		50: "@",
		51: "#",
		52: "$",
		53: "%",
		54: "^",
		55: "&",
		56: "*",
		57: "(",
		59: ":",
		61: "+",
		173: "_",
		186: ":",
		187: "+",
		188: "<",
		189: "_",
		190: ">",
		191: "?",
		192: "~",
		219: "{",
		220: "|",
		221: "}",
		222: '"',
	},
	oSe = typeof navigator < "u" && /Mac/.test(navigator.platform),
	sSe =
		typeof navigator < "u" &&
		/MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(
			navigator.userAgent,
		);
for (var Tr = 0; Tr < 10; Tr++) Xu[48 + Tr] = Xu[96 + Tr] = String(Tr);
for (var Tr = 1; Tr <= 24; Tr++) Xu[Tr + 111] = "F" + Tr;
for (var Tr = 65; Tr <= 90; Tr++)
	(Xu[Tr] = String.fromCharCode(Tr + 32)), (Py[Tr] = String.fromCharCode(Tr));
for (var pC in Xu) Py.hasOwnProperty(pC) || (Py[pC] = Xu[pC]);
function aSe(t) {
	var e =
			(oSe && t.metaKey && t.shiftKey && !t.ctrlKey && !t.altKey) ||
			(sSe && t.shiftKey && t.key && t.key.length == 1) ||
			t.key == "Unidentified",
		n =
			(!e && t.key) ||
			(t.shiftKey ? Py : Xu)[t.keyCode] ||
			t.key ||
			"Unidentified";
	return (
		n == "Esc" && (n = "Escape"),
		n == "Del" && (n = "Delete"),
		n == "Left" && (n = "ArrowLeft"),
		n == "Up" && (n = "ArrowUp"),
		n == "Right" && (n = "ArrowRight"),
		n == "Down" && (n = "ArrowDown"),
		n
	);
}
const lSe =
	typeof navigator < "u" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : !1;
function uSe(t) {
	let e = t.split(/-(?!$)/),
		n = e[e.length - 1];
	n == "Space" && (n = " ");
	let r, i, o, s;
	for (let a = 0; a < e.length - 1; a++) {
		let l = e[a];
		if (/^(cmd|meta|m)$/i.test(l)) s = !0;
		else if (/^a(lt)?$/i.test(l)) r = !0;
		else if (/^(c|ctrl|control)$/i.test(l)) i = !0;
		else if (/^s(hift)?$/i.test(l)) o = !0;
		else if (/^mod$/i.test(l)) lSe ? (s = !0) : (i = !0);
		else throw new Error("Unrecognized modifier name: " + l);
	}
	return (
		r && (n = "Alt-" + n),
		i && (n = "Ctrl-" + n),
		s && (n = "Meta-" + n),
		o && (n = "Shift-" + n),
		n
	);
}
function cSe(t) {
	let e = Object.create(null);
	for (let n in t) e[uSe(n)] = t[n];
	return e;
}
function mC(t, e, n = !0) {
	return (
		e.altKey && (t = "Alt-" + t),
		e.ctrlKey && (t = "Ctrl-" + t),
		e.metaKey && (t = "Meta-" + t),
		n && e.shiftKey && (t = "Shift-" + t),
		t
	);
}
function dSe(t) {
	return new Gn({ props: { handleKeyDown: G5(t) } });
}
function G5(t) {
	let e = cSe(t);
	return function (n, r) {
		let i = aSe(r),
			o,
			s = e[mC(i, r)];
		if (s && s(n.state, n.dispatch, n)) return !0;
		if (i.length == 1 && i != " ") {
			if (r.shiftKey) {
				let a = e[mC(i, r, !1)];
				if (a && a(n.state, n.dispatch, n)) return !0;
			}
			if (
				(r.shiftKey ||
					r.altKey ||
					r.metaKey ||
					i.charCodeAt(0) > 127) &&
				(o = Xu[r.keyCode]) &&
				o != i
			) {
				let a = e[mC(o, r)];
				if (a && a(n.state, n.dispatch, n)) return !0;
			}
		}
		return !1;
	};
}
var uE, cE;
if (typeof WeakMap < "u") {
	let t = new WeakMap();
	(uE = (e) => t.get(e)), (cE = (e, n) => (t.set(e, n), n));
} else {
	const t = [];
	let n = 0;
	(uE = (r) => {
		for (let i = 0; i < t.length; i += 2) if (t[i] == r) return t[i + 1];
	}),
		(cE = (r, i) => (n == 10 && (n = 0), (t[n++] = r), (t[n++] = i)));
}
var Br = class {
	constructor(t, e, n, r) {
		(this.width = t),
			(this.height = e),
			(this.map = n),
			(this.problems = r);
	}
	findCell(t) {
		for (let e = 0; e < this.map.length; e++) {
			const n = this.map[e];
			if (n != t) continue;
			const r = e % this.width,
				i = (e / this.width) | 0;
			let o = r + 1,
				s = i + 1;
			for (let a = 1; o < this.width && this.map[e + a] == n; a++) o++;
			for (
				let a = 1;
				s < this.height && this.map[e + this.width * a] == n;
				a++
			)
				s++;
			return { left: r, top: i, right: o, bottom: s };
		}
		throw new RangeError(`No cell with offset ${t} found`);
	}
	colCount(t) {
		for (let e = 0; e < this.map.length; e++)
			if (this.map[e] == t) return e % this.width;
		throw new RangeError(`No cell with offset ${t} found`);
	}
	nextCell(t, e, n) {
		const { left: r, right: i, top: o, bottom: s } = this.findCell(t);
		return e == "horiz"
			? (n < 0 ? r == 0 : i == this.width)
				? null
				: this.map[o * this.width + (n < 0 ? r - 1 : i)]
			: (n < 0 ? o == 0 : s == this.height)
				? null
				: this.map[r + this.width * (n < 0 ? o - 1 : s)];
	}
	rectBetween(t, e) {
		const { left: n, right: r, top: i, bottom: o } = this.findCell(t),
			{ left: s, right: a, top: l, bottom: u } = this.findCell(e);
		return {
			left: Math.min(n, s),
			top: Math.min(i, l),
			right: Math.max(r, a),
			bottom: Math.max(o, u),
		};
	}
	cellsInRect(t) {
		const e = [],
			n = {};
		for (let r = t.top; r < t.bottom; r++)
			for (let i = t.left; i < t.right; i++) {
				const o = r * this.width + i,
					s = this.map[o];
				n[s] ||
					((n[s] = !0),
					!(
						(i == t.left && i && this.map[o - 1] == s) ||
						(r == t.top && r && this.map[o - this.width] == s)
					) && e.push(s));
			}
		return e;
	}
	positionAt(t, e, n) {
		for (let r = 0, i = 0; ; r++) {
			const o = i + n.child(r).nodeSize;
			if (r == t) {
				let s = e + t * this.width;
				const a = (t + 1) * this.width;
				for (; s < a && this.map[s] < i; ) s++;
				return s == a ? o - 1 : this.map[s];
			}
			i = o;
		}
	}
	static get(t) {
		return uE(t) || cE(t, fSe(t));
	}
};
function fSe(t) {
	if (t.type.spec.tableRole != "table")
		throw new RangeError("Not a table node: " + t.type.name);
	const e = hSe(t),
		n = t.childCount,
		r = [];
	let i = 0,
		o = null;
	const s = [];
	for (let u = 0, c = e * n; u < c; u++) r[u] = 0;
	for (let u = 0, c = 0; u < n; u++) {
		const d = t.child(u);
		c++;
		for (let p = 0; ; p++) {
			for (; i < r.length && r[i] != 0; ) i++;
			if (p == d.childCount) break;
			const g = d.child(p),
				{ colspan: v, rowspan: b, colwidth: y } = g.attrs;
			for (let x = 0; x < b; x++) {
				if (x + u >= n) {
					(o || (o = [])).push({
						type: "overlong_rowspan",
						pos: c,
						n: b - x,
					});
					break;
				}
				const C = i + x * e;
				for (let k = 0; k < v; k++) {
					r[C + k] == 0
						? (r[C + k] = c)
						: (o || (o = [])).push({
								type: "collision",
								row: u,
								pos: c,
								n: v - k,
							});
					const w = y && y[k];
					if (w) {
						const D = ((C + k) % e) * 2,
							S = s[D];
						S == null || (S != w && s[D + 1] == 1)
							? ((s[D] = w), (s[D + 1] = 1))
							: S == w && s[D + 1]++;
					}
				}
			}
			(i += v), (c += g.nodeSize);
		}
		const f = (u + 1) * e;
		let h = 0;
		for (; i < f; ) r[i++] == 0 && h++;
		h && (o || (o = [])).push({ type: "missing", row: u, n: h }), c++;
	}
	const a = new Br(e, n, r, o);
	let l = !1;
	for (let u = 0; !l && u < s.length; u += 2)
		s[u] != null && s[u + 1] < n && (l = !0);
	return l && pSe(a, s, t), a;
}
function hSe(t) {
	let e = -1,
		n = !1;
	for (let r = 0; r < t.childCount; r++) {
		const i = t.child(r);
		let o = 0;
		if (n)
			for (let s = 0; s < r; s++) {
				const a = t.child(s);
				for (let l = 0; l < a.childCount; l++) {
					const u = a.child(l);
					s + u.attrs.rowspan > r && (o += u.attrs.colspan);
				}
			}
		for (let s = 0; s < i.childCount; s++) {
			const a = i.child(s);
			(o += a.attrs.colspan), a.attrs.rowspan > 1 && (n = !0);
		}
		e == -1 ? (e = o) : e != o && (e = Math.max(e, o));
	}
	return e;
}
function pSe(t, e, n) {
	t.problems || (t.problems = []);
	const r = {};
	for (let i = 0; i < t.map.length; i++) {
		const o = t.map[i];
		if (r[o]) continue;
		r[o] = !0;
		const s = n.nodeAt(o);
		if (!s) throw new RangeError(`No cell with offset ${o} found`);
		let a = null;
		const l = s.attrs;
		for (let u = 0; u < l.colspan; u++) {
			const c = (i + u) % t.width,
				d = e[c * 2];
			d != null &&
				(!l.colwidth || l.colwidth[u] != d) &&
				((a || (a = mSe(l)))[u] = d);
		}
		a &&
			t.problems.unshift({
				type: "colwidth mismatch",
				pos: o,
				colwidth: a,
			});
	}
}
function mSe(t) {
	if (t.colwidth) return t.colwidth.slice();
	const e = [];
	for (let n = 0; n < t.colspan; n++) e.push(0);
	return e;
}
function Ui(t) {
	let e = t.cached.tableNodeTypes;
	if (!e) {
		e = t.cached.tableNodeTypes = {};
		for (const n in t.nodes) {
			const r = t.nodes[n],
				i = r.spec.tableRole;
			i && (e[i] = r);
		}
	}
	return e;
}
var lu = new Os("selectingCells");
function _3(t) {
	for (let e = t.depth - 1; e > 0; e--)
		if (t.node(e).type.spec.tableRole == "row")
			return t.node(0).resolve(t.before(e + 1));
	return null;
}
function rf(t) {
	const e = t.selection.$head;
	for (let n = e.depth; n > 0; n--)
		if (e.node(n).type.spec.tableRole == "row") return !0;
	return !1;
}
function SG(t) {
	const e = t.selection;
	if ("$anchorCell" in e && e.$anchorCell)
		return e.$anchorCell.pos > e.$headCell.pos
			? e.$anchorCell
			: e.$headCell;
	if ("node" in e && e.node && e.node.type.spec.tableRole == "cell")
		return e.$anchor;
	const n = _3(e.$head) || gSe(e.$head);
	if (n) return n;
	throw new RangeError(`No cell found around position ${e.head}`);
}
function gSe(t) {
	for (let e = t.nodeAfter, n = t.pos; e; e = e.firstChild, n++) {
		const r = e.type.spec.tableRole;
		if (r == "cell" || r == "header_cell") return t.doc.resolve(n);
	}
	for (let e = t.nodeBefore, n = t.pos; e; e = e.lastChild, n--) {
		const r = e.type.spec.tableRole;
		if (r == "cell" || r == "header_cell")
			return t.doc.resolve(n - e.nodeSize);
	}
}
function V7(t) {
	return t.parent.type.spec.tableRole == "row" && !!t.nodeAfter;
}
function Y5(t, e) {
	return t.depth == e.depth && t.pos >= e.start(-1) && t.pos <= e.end(-1);
}
function AG(t, e, n) {
	const r = t.node(-1),
		i = Br.get(r),
		o = t.start(-1),
		s = i.nextCell(t.pos - o, e, n);
	return s == null ? null : t.node(0).resolve(o + s);
}
function Nd(t, e, n = 1) {
	const r = { ...t, colspan: t.colspan - n };
	return (
		r.colwidth &&
			((r.colwidth = r.colwidth.slice()),
			r.colwidth.splice(e, n),
			r.colwidth.some((i) => i > 0) || (r.colwidth = null)),
		r
	);
}
function bSe(t, e, n = 1) {
	const r = { ...t, colspan: t.colspan + n };
	if (r.colwidth) {
		r.colwidth = r.colwidth.slice();
		for (let i = 0; i < n; i++) r.colwidth.splice(e, 0, 0);
	}
	return r;
}
function vSe(t, e, n) {
	const r = Ui(e.type.schema).header_cell;
	for (let i = 0; i < t.height; i++)
		if (e.nodeAt(t.map[n + i * t.width]).type != r) return !1;
	return !0;
}
var gr = class Ha extends mt {
	constructor(e, n = e) {
		const r = e.node(-1),
			i = Br.get(r),
			o = e.start(-1),
			s = i.rectBetween(e.pos - o, n.pos - o),
			a = e.node(0),
			l = i.cellsInRect(s).filter((c) => c != n.pos - o);
		l.unshift(n.pos - o);
		const u = l.map((c) => {
			const d = r.nodeAt(c);
			if (!d) throw RangeError(`No cell with offset ${c} found`);
			const f = o + c + 1;
			return new mj(a.resolve(f), a.resolve(f + d.content.size));
		});
		super(u[0].$from, u[0].$to, u),
			(this.$anchorCell = e),
			(this.$headCell = n);
	}
	map(e, n) {
		const r = e.resolve(n.map(this.$anchorCell.pos)),
			i = e.resolve(n.map(this.$headCell.pos));
		if (V7(r) && V7(i) && Y5(r, i)) {
			const o = this.$anchorCell.node(-1) != r.node(-1);
			return o && this.isRowSelection()
				? Ha.rowSelection(r, i)
				: o && this.isColSelection()
					? Ha.colSelection(r, i)
					: new Ha(r, i);
		}
		return kt.between(r, i);
	}
	content() {
		const e = this.$anchorCell.node(-1),
			n = Br.get(e),
			r = this.$anchorCell.start(-1),
			i = n.rectBetween(this.$anchorCell.pos - r, this.$headCell.pos - r),
			o = {},
			s = [];
		for (let l = i.top; l < i.bottom; l++) {
			const u = [];
			for (
				let c = l * n.width + i.left, d = i.left;
				d < i.right;
				d++, c++
			) {
				const f = n.map[c];
				if (o[f]) continue;
				o[f] = !0;
				const h = n.findCell(f);
				let p = e.nodeAt(f);
				if (!p) throw RangeError(`No cell with offset ${f} found`);
				const g = i.left - h.left,
					v = h.right - i.right;
				if (g > 0 || v > 0) {
					let b = p.attrs;
					if (
						(g > 0 && (b = Nd(b, 0, g)),
						v > 0 && (b = Nd(b, b.colspan - v, v)),
						h.left < i.left)
					) {
						if (((p = p.type.createAndFill(b)), !p))
							throw RangeError(
								`Could not create cell with attrs ${JSON.stringify(b)}`,
							);
					} else p = p.type.create(b, p.content);
				}
				if (h.top < i.top || h.bottom > i.bottom) {
					const b = {
						...p.attrs,
						rowspan:
							Math.min(h.bottom, i.bottom) -
							Math.max(h.top, i.top),
					};
					h.top < i.top
						? (p = p.type.createAndFill(b))
						: (p = p.type.create(b, p.content));
				}
				u.push(p);
			}
			s.push(e.child(l).copy(be.from(u)));
		}
		const a = this.isColSelection() && this.isRowSelection() ? e : s;
		return new Ee(be.from(a), 1, 1);
	}
	replace(e, n = Ee.empty) {
		const r = e.steps.length,
			i = this.ranges;
		for (let s = 0; s < i.length; s++) {
			const { $from: a, $to: l } = i[s],
				u = e.mapping.slice(r);
			e.replace(u.map(a.pos), u.map(l.pos), s ? Ee.empty : n);
		}
		const o = mt.findFrom(
			e.doc.resolve(e.mapping.slice(r).map(this.to)),
			-1,
		);
		o && e.setSelection(o);
	}
	replaceWith(e, n) {
		this.replace(e, new Ee(be.from(n), 0, 0));
	}
	forEachCell(e) {
		const n = this.$anchorCell.node(-1),
			r = Br.get(n),
			i = this.$anchorCell.start(-1),
			o = r.cellsInRect(
				r.rectBetween(this.$anchorCell.pos - i, this.$headCell.pos - i),
			);
		for (let s = 0; s < o.length; s++) e(n.nodeAt(o[s]), i + o[s]);
	}
	isColSelection() {
		const e = this.$anchorCell.index(-1),
			n = this.$headCell.index(-1);
		if (Math.min(e, n) > 0) return !1;
		const r = e + this.$anchorCell.nodeAfter.attrs.rowspan,
			i = n + this.$headCell.nodeAfter.attrs.rowspan;
		return Math.max(r, i) == this.$headCell.node(-1).childCount;
	}
	static colSelection(e, n = e) {
		const r = e.node(-1),
			i = Br.get(r),
			o = e.start(-1),
			s = i.findCell(e.pos - o),
			a = i.findCell(n.pos - o),
			l = e.node(0);
		return (
			s.top <= a.top
				? (s.top > 0 && (e = l.resolve(o + i.map[s.left])),
					a.bottom < i.height &&
						(n = l.resolve(
							o + i.map[i.width * (i.height - 1) + a.right - 1],
						)))
				: (a.top > 0 && (n = l.resolve(o + i.map[a.left])),
					s.bottom < i.height &&
						(e = l.resolve(
							o + i.map[i.width * (i.height - 1) + s.right - 1],
						))),
			new Ha(e, n)
		);
	}
	isRowSelection() {
		const e = this.$anchorCell.node(-1),
			n = Br.get(e),
			r = this.$anchorCell.start(-1),
			i = n.colCount(this.$anchorCell.pos - r),
			o = n.colCount(this.$headCell.pos - r);
		if (Math.min(i, o) > 0) return !1;
		const s = i + this.$anchorCell.nodeAfter.attrs.colspan,
			a = o + this.$headCell.nodeAfter.attrs.colspan;
		return Math.max(s, a) == n.width;
	}
	eq(e) {
		return (
			e instanceof Ha &&
			e.$anchorCell.pos == this.$anchorCell.pos &&
			e.$headCell.pos == this.$headCell.pos
		);
	}
	static rowSelection(e, n = e) {
		const r = e.node(-1),
			i = Br.get(r),
			o = e.start(-1),
			s = i.findCell(e.pos - o),
			a = i.findCell(n.pos - o),
			l = e.node(0);
		return (
			s.left <= a.left
				? (s.left > 0 && (e = l.resolve(o + i.map[s.top * i.width])),
					a.right < i.width &&
						(n = l.resolve(o + i.map[i.width * (a.top + 1) - 1])))
				: (a.left > 0 && (n = l.resolve(o + i.map[a.top * i.width])),
					s.right < i.width &&
						(e = l.resolve(o + i.map[i.width * (s.top + 1) - 1]))),
			new Ha(e, n)
		);
	}
	toJSON() {
		return {
			type: "cell",
			anchor: this.$anchorCell.pos,
			head: this.$headCell.pos,
		};
	}
	static fromJSON(e, n) {
		return new Ha(e.resolve(n.anchor), e.resolve(n.head));
	}
	static create(e, n, r = n) {
		return new Ha(e.resolve(n), e.resolve(r));
	}
	getBookmark() {
		return new ySe(this.$anchorCell.pos, this.$headCell.pos);
	}
};
gr.prototype.visible = !1;
mt.jsonID("cell", gr);
var ySe = class $G {
	constructor(e, n) {
		(this.anchor = e), (this.head = n);
	}
	map(e) {
		return new $G(e.map(this.anchor), e.map(this.head));
	}
	resolve(e) {
		const n = e.resolve(this.anchor),
			r = e.resolve(this.head);
		return n.parent.type.spec.tableRole == "row" &&
			r.parent.type.spec.tableRole == "row" &&
			n.index() < n.parent.childCount &&
			r.index() < r.parent.childCount &&
			Y5(n, r)
			? new gr(n, r)
			: mt.near(r, 1);
	}
};
function xSe(t) {
	if (!(t.selection instanceof gr)) return null;
	const e = [];
	return (
		t.selection.forEachCell((n, r) => {
			e.push(Hn.node(r, r + n.nodeSize, { class: "selectedCell" }));
		}),
		qt.create(t.doc, e)
	);
}
function kSe({ $from: t, $to: e }) {
	if (t.pos == e.pos || t.pos < t.pos - 6) return !1;
	let n = t.pos,
		r = e.pos,
		i = t.depth;
	for (; i >= 0 && !(t.after(i + 1) < t.end(i)); i--, n++);
	for (let o = e.depth; o >= 0 && !(e.before(o + 1) > e.start(o)); o--, r--);
	return n == r && /row|table/.test(t.node(i).type.spec.tableRole);
}
function CSe({ $from: t, $to: e }) {
	let n, r;
	for (let i = t.depth; i > 0; i--) {
		const o = t.node(i);
		if (
			o.type.spec.tableRole === "cell" ||
			o.type.spec.tableRole === "header_cell"
		) {
			n = o;
			break;
		}
	}
	for (let i = e.depth; i > 0; i--) {
		const o = e.node(i);
		if (
			o.type.spec.tableRole === "cell" ||
			o.type.spec.tableRole === "header_cell"
		) {
			r = o;
			break;
		}
	}
	return n !== r && e.parentOffset === 0;
}
function wSe(t, e, n) {
	const r = (e || t).selection,
		i = (e || t).doc;
	let o, s;
	if (r instanceof Qe && (s = r.node.type.spec.tableRole)) {
		if (s == "cell" || s == "header_cell") o = gr.create(i, r.from);
		else if (s == "row") {
			const a = i.resolve(r.from + 1);
			o = gr.rowSelection(a, a);
		} else if (!n) {
			const a = Br.get(r.node),
				l = r.from + 1,
				u = l + a.map[a.width * a.height - 1];
			o = gr.create(i, l + 1, u);
		}
	} else
		r instanceof kt && kSe(r)
			? (o = kt.create(i, r.from))
			: r instanceof kt &&
				CSe(r) &&
				(o = kt.create(i, r.$from.start(), r.$from.end()));
	return o && (e || (e = t.tr)).setSelection(o), e;
}
var ESe = new Os("fix-tables");
function TG(t, e, n, r) {
	const i = t.childCount,
		o = e.childCount;
	e: for (let s = 0, a = 0; s < o; s++) {
		const l = e.child(s);
		for (let u = a, c = Math.min(i, s + 3); u < c; u++)
			if (t.child(u) == l) {
				(a = u + 1), (n += l.nodeSize);
				continue e;
			}
		r(l, n),
			a < i && t.child(a).sameMarkup(l)
				? TG(t.child(a), l, n + 1, r)
				: l.nodesBetween(0, l.content.size, r, n + 1),
			(n += l.nodeSize);
	}
}
function DSe(t, e) {
	let n;
	const r = (i, o) => {
		i.type.spec.tableRole == "table" && (n = SSe(t, i, o, n));
	};
	return (
		e ? e.doc != t.doc && TG(e.doc, t.doc, 0, r) : t.doc.descendants(r), n
	);
}
function SSe(t, e, n, r) {
	const i = Br.get(e);
	if (!i.problems) return r;
	r || (r = t.tr);
	const o = [];
	for (let l = 0; l < i.height; l++) o.push(0);
	for (let l = 0; l < i.problems.length; l++) {
		const u = i.problems[l];
		if (u.type == "collision") {
			const c = e.nodeAt(u.pos);
			if (!c) continue;
			const d = c.attrs;
			for (let f = 0; f < d.rowspan; f++) o[u.row + f] += u.n;
			r.setNodeMarkup(
				r.mapping.map(n + 1 + u.pos),
				null,
				Nd(d, d.colspan - u.n, u.n),
			);
		} else if (u.type == "missing") o[u.row] += u.n;
		else if (u.type == "overlong_rowspan") {
			const c = e.nodeAt(u.pos);
			if (!c) continue;
			r.setNodeMarkup(r.mapping.map(n + 1 + u.pos), null, {
				...c.attrs,
				rowspan: c.attrs.rowspan - u.n,
			});
		} else if (u.type == "colwidth mismatch") {
			const c = e.nodeAt(u.pos);
			if (!c) continue;
			r.setNodeMarkup(r.mapping.map(n + 1 + u.pos), null, {
				...c.attrs,
				colwidth: u.colwidth,
			});
		}
	}
	let s, a;
	for (let l = 0; l < o.length; l++) o[l] && (s == null && (s = l), (a = l));
	for (let l = 0, u = n + 1; l < i.height; l++) {
		const c = e.child(l),
			d = u + c.nodeSize,
			f = o[l];
		if (f > 0) {
			let h = "cell";
			c.firstChild && (h = c.firstChild.type.spec.tableRole);
			const p = [];
			for (let v = 0; v < f; v++) {
				const b = Ui(t.schema)[h].createAndFill();
				b && p.push(b);
			}
			const g = (l == 0 || s == l - 1) && a == l ? u + 1 : d - 1;
			r.insert(r.mapping.map(g), p);
		}
		u = d;
	}
	return r.setMeta(ESe, { fixTables: !0 });
}
function gp(t) {
	const e = t.selection,
		n = SG(t),
		r = n.node(-1),
		i = n.start(-1),
		o = Br.get(r);
	return {
		...(e instanceof gr
			? o.rectBetween(e.$anchorCell.pos - i, e.$headCell.pos - i)
			: o.findCell(n.pos - i)),
		tableStart: i,
		map: o,
		table: r,
	};
}
function ASe(t, { map: e, tableStart: n, table: r }, i) {
	let o = i > 0 ? -1 : 0;
	vSe(e, r, i + o) && (o = i == 0 || i == e.width ? null : 0);
	for (let s = 0; s < e.height; s++) {
		const a = s * e.width + i;
		if (i > 0 && i < e.width && e.map[a - 1] == e.map[a]) {
			const l = e.map[a],
				u = r.nodeAt(l);
			t.setNodeMarkup(
				t.mapping.map(n + l),
				null,
				bSe(u.attrs, i - e.colCount(l)),
			),
				(s += u.attrs.rowspan - 1);
		} else {
			const l =
					o == null
						? Ui(r.type.schema).cell
						: r.nodeAt(e.map[a + o]).type,
				u = e.positionAt(s, i, r);
			t.insert(t.mapping.map(n + u), l.createAndFill());
		}
	}
	return t;
}
function $Se(t, e) {
	if (!rf(t)) return !1;
	if (e) {
		const n = gp(t);
		e(ASe(t.tr, n, n.right));
	}
	return !0;
}
function TSe(t, { map: e, table: n, tableStart: r }, i) {
	const o = t.mapping.maps.length;
	for (let s = 0; s < e.height; ) {
		const a = s * e.width + i,
			l = e.map[a],
			u = n.nodeAt(l),
			c = u.attrs;
		if (
			(i > 0 && e.map[a - 1] == l) ||
			(i < e.width - 1 && e.map[a + 1] == l)
		)
			t.setNodeMarkup(
				t.mapping.slice(o).map(r + l),
				null,
				Nd(c, i - e.colCount(l)),
			);
		else {
			const d = t.mapping.slice(o).map(r + l);
			t.delete(d, d + u.nodeSize);
		}
		s += c.rowspan;
	}
}
function BSe(t, e) {
	if (!rf(t)) return !1;
	if (e) {
		const n = gp(t),
			r = t.tr;
		if (n.left == 0 && n.right == n.map.width) return !1;
		for (let i = n.right - 1; TSe(r, n, i), i != n.left; i--) {
			const o = n.tableStart ? r.doc.nodeAt(n.tableStart - 1) : r.doc;
			if (!o) throw RangeError("No table found");
			(n.table = o), (n.map = Br.get(o));
		}
		e(r);
	}
	return !0;
}
function ISe(t, e, n) {
	var r;
	const i = Ui(e.type.schema).header_cell;
	for (let o = 0; o < t.width; o++)
		if (
			((r = e.nodeAt(t.map[o + n * t.width])) == null
				? void 0
				: r.type) != i
		)
			return !1;
	return !0;
}
function FSe(t, { map: e, tableStart: n, table: r }, i) {
	var o;
	let s = n;
	for (let u = 0; u < i; u++) s += r.child(u).nodeSize;
	const a = [];
	let l = i > 0 ? -1 : 0;
	ISe(e, r, i + l) && (l = i == 0 || i == e.height ? null : 0);
	for (let u = 0, c = e.width * i; u < e.width; u++, c++)
		if (i > 0 && i < e.height && e.map[c] == e.map[c - e.width]) {
			const d = e.map[c],
				f = r.nodeAt(d).attrs;
			t.setNodeMarkup(n + d, null, { ...f, rowspan: f.rowspan + 1 }),
				(u += f.colspan - 1);
		} else {
			const d =
					l == null
						? Ui(r.type.schema).cell
						: (o = r.nodeAt(e.map[c + l * e.width])) == null
							? void 0
							: o.type,
				f = d == null ? void 0 : d.createAndFill();
			f && a.push(f);
		}
	return t.insert(s, Ui(r.type.schema).row.create(null, a)), t;
}
function PSe(t, e) {
	if (!rf(t)) return !1;
	if (e) {
		const n = gp(t);
		e(FSe(t.tr, n, n.bottom));
	}
	return !0;
}
function NSe(t, { map: e, table: n, tableStart: r }, i) {
	let o = 0;
	for (let u = 0; u < i; u++) o += n.child(u).nodeSize;
	const s = o + n.child(i).nodeSize,
		a = t.mapping.maps.length;
	t.delete(o + r, s + r);
	const l = new Set();
	for (let u = 0, c = i * e.width; u < e.width; u++, c++) {
		const d = e.map[c];
		if (!l.has(d)) {
			if ((l.add(d), i > 0 && d == e.map[c - e.width])) {
				const f = n.nodeAt(d).attrs;
				t.setNodeMarkup(t.mapping.slice(a).map(d + r), null, {
					...f,
					rowspan: f.rowspan - 1,
				}),
					(u += f.colspan - 1);
			} else if (i < e.height && d == e.map[c + e.width]) {
				const f = n.nodeAt(d),
					h = f.attrs,
					p = f.type.create(
						{ ...h, rowspan: f.attrs.rowspan - 1 },
						f.content,
					),
					g = e.positionAt(i + 1, u, n);
				t.insert(t.mapping.slice(a).map(r + g), p),
					(u += h.colspan - 1);
			}
		}
	}
}
function RSe(t, e) {
	if (!rf(t)) return !1;
	if (e) {
		const n = gp(t),
			r = t.tr;
		if (n.top == 0 && n.bottom == n.map.height) return !1;
		for (let i = n.bottom - 1; NSe(r, n, i), i != n.top; i--) {
			const o = n.tableStart ? r.doc.nodeAt(n.tableStart - 1) : r.doc;
			if (!o) throw RangeError("No table found");
			(n.table = o), (n.map = Br.get(n.table));
		}
		e(r);
	}
	return !0;
}
function OSe(t) {
	return function (e, n) {
		if (!rf(e)) return !1;
		if (n) {
			const r = Ui(e.schema),
				i = gp(e),
				o = e.tr,
				s = i.map.cellsInRect(
					t == "column"
						? {
								left: i.left,
								top: 0,
								right: i.right,
								bottom: i.map.height,
							}
						: t == "row"
							? {
									left: 0,
									top: i.top,
									right: i.map.width,
									bottom: i.bottom,
								}
							: i,
				),
				a = s.map((l) => i.table.nodeAt(l));
			for (let l = 0; l < s.length; l++)
				a[l].type == r.header_cell &&
					o.setNodeMarkup(i.tableStart + s[l], r.cell, a[l].attrs);
			if (o.steps.length == 0)
				for (let l = 0; l < s.length; l++)
					o.setNodeMarkup(
						i.tableStart + s[l],
						r.header_cell,
						a[l].attrs,
					);
			n(o);
		}
		return !0;
	};
}
function K7(t, e, n) {
	const r = e.map.cellsInRect({
		left: 0,
		top: 0,
		right: t == "row" ? e.map.width : 1,
		bottom: t == "column" ? e.map.height : 1,
	});
	for (let i = 0; i < r.length; i++) {
		const o = e.table.nodeAt(r[i]);
		if (o && o.type !== n.header_cell) return !1;
	}
	return !0;
}
function z3(t, e) {
	return (
		(e = e || { useDeprecatedLogic: !1 }),
		e.useDeprecatedLogic
			? OSe(t)
			: function (n, r) {
					if (!rf(n)) return !1;
					if (r) {
						const i = Ui(n.schema),
							o = gp(n),
							s = n.tr,
							a = K7("row", o, i),
							l = K7("column", o, i),
							c = (t === "column" ? a : t === "row" ? l : !1)
								? 1
								: 0,
							d =
								t == "column"
									? {
											left: 0,
											top: c,
											right: 1,
											bottom: o.map.height,
										}
									: t == "row"
										? {
												left: c,
												top: 0,
												right: o.map.width,
												bottom: 1,
											}
										: o,
							f =
								t == "column"
									? l
										? i.cell
										: i.header_cell
									: t == "row"
										? a
											? i.cell
											: i.header_cell
										: i.cell;
						o.map.cellsInRect(d).forEach((h) => {
							const p = h + o.tableStart,
								g = s.doc.nodeAt(p);
							g && s.setNodeMarkup(p, f, g.attrs);
						}),
							r(s);
					}
					return !0;
				}
	);
}
z3("row", { useDeprecatedLogic: !0 });
z3("column", { useDeprecatedLogic: !0 });
z3("cell", { useDeprecatedLogic: !0 });
function W1(t, e) {
	const n = t.selection;
	if (!(n instanceof gr)) return !1;
	if (e) {
		const r = t.tr,
			i = Ui(t.schema).cell.createAndFill().content;
		n.forEachCell((o, s) => {
			o.content.eq(i) ||
				r.replace(
					r.mapping.map(s + 1),
					r.mapping.map(s + o.nodeSize - 1),
					new Ee(i, 0, 0),
				);
		}),
			r.docChanged && e(r);
	}
	return !0;
}
function MSe(t) {
	if (!t.size) return null;
	let { content: e, openStart: n, openEnd: r } = t;
	for (
		;
		e.childCount == 1 &&
		((n > 0 && r > 0) || e.child(0).type.spec.tableRole == "table");

	)
		n--, r--, (e = e.child(0).content);
	const i = e.child(0),
		o = i.type.spec.tableRole,
		s = i.type.schema,
		a = [];
	if (o == "row")
		for (let l = 0; l < e.childCount; l++) {
			let u = e.child(l).content;
			const c = l ? 0 : Math.max(0, n - 1),
				d = l < e.childCount - 1 ? 0 : Math.max(0, r - 1);
			(c || d) && (u = dE(Ui(s).row, new Ee(u, c, d)).content), a.push(u);
		}
	else if (o == "cell" || o == "header_cell")
		a.push(n || r ? dE(Ui(s).row, new Ee(e, n, r)).content : e);
	else return null;
	return jSe(s, a);
}
function jSe(t, e) {
	const n = [];
	for (let i = 0; i < e.length; i++) {
		const o = e[i];
		for (let s = o.childCount - 1; s >= 0; s--) {
			const { rowspan: a, colspan: l } = o.child(s).attrs;
			for (let u = i; u < i + a; u++) n[u] = (n[u] || 0) + l;
		}
	}
	let r = 0;
	for (let i = 0; i < n.length; i++) r = Math.max(r, n[i]);
	for (let i = 0; i < n.length; i++)
		if ((i >= e.length && e.push(be.empty), n[i] < r)) {
			const o = Ui(t).cell.createAndFill(),
				s = [];
			for (let a = n[i]; a < r; a++) s.push(o);
			e[i] = e[i].append(be.from(s));
		}
	return { height: e.length, width: r, rows: e };
}
function dE(t, e) {
	const n = t.createAndFill();
	return new pj(n).replace(0, n.content.size, e).doc;
}
function _Se({ width: t, height: e, rows: n }, r, i) {
	if (t != r) {
		const o = [],
			s = [];
		for (let a = 0; a < n.length; a++) {
			const l = n[a],
				u = [];
			for (let c = o[a] || 0, d = 0; c < r; d++) {
				let f = l.child(d % l.childCount);
				c + f.attrs.colspan > r &&
					(f = f.type.createChecked(
						Nd(f.attrs, f.attrs.colspan, c + f.attrs.colspan - r),
						f.content,
					)),
					u.push(f),
					(c += f.attrs.colspan);
				for (let h = 1; h < f.attrs.rowspan; h++)
					o[a + h] = (o[a + h] || 0) + f.attrs.colspan;
			}
			s.push(be.from(u));
		}
		(n = s), (t = r);
	}
	if (e != i) {
		const o = [];
		for (let s = 0, a = 0; s < i; s++, a++) {
			const l = [],
				u = n[a % e];
			for (let c = 0; c < u.childCount; c++) {
				let d = u.child(c);
				s + d.attrs.rowspan > i &&
					(d = d.type.create(
						{
							...d.attrs,
							rowspan: Math.max(1, i - d.attrs.rowspan),
						},
						d.content,
					)),
					l.push(d);
			}
			o.push(be.from(l));
		}
		(n = o), (e = i);
	}
	return { width: t, height: e, rows: n };
}
function zSe(t, e, n, r, i, o, s) {
	const a = t.doc.type.schema,
		l = Ui(a);
	let u, c;
	if (i > e.width)
		for (let d = 0, f = 0; d < e.height; d++) {
			const h = n.child(d);
			f += h.nodeSize;
			const p = [];
			let g;
			h.lastChild == null || h.lastChild.type == l.cell
				? (g = u || (u = l.cell.createAndFill()))
				: (g = c || (c = l.header_cell.createAndFill()));
			for (let v = e.width; v < i; v++) p.push(g);
			t.insert(t.mapping.slice(s).map(f - 1 + r), p);
		}
	if (o > e.height) {
		const d = [];
		for (
			let p = 0, g = (e.height - 1) * e.width;
			p < Math.max(e.width, i);
			p++
		) {
			const v =
				p >= e.width
					? !1
					: n.nodeAt(e.map[g + p]).type == l.header_cell;
			d.push(
				v
					? c || (c = l.header_cell.createAndFill())
					: u || (u = l.cell.createAndFill()),
			);
		}
		const f = l.row.create(null, be.from(d)),
			h = [];
		for (let p = e.height; p < o; p++) h.push(f);
		t.insert(t.mapping.slice(s).map(r + n.nodeSize - 2), h);
	}
	return !!(u || c);
}
function U7(t, e, n, r, i, o, s, a) {
	if (s == 0 || s == e.height) return !1;
	let l = !1;
	for (let u = i; u < o; u++) {
		const c = s * e.width + u,
			d = e.map[c];
		if (e.map[c - e.width] == d) {
			l = !0;
			const f = n.nodeAt(d),
				{ top: h, left: p } = e.findCell(d);
			t.setNodeMarkup(t.mapping.slice(a).map(d + r), null, {
				...f.attrs,
				rowspan: s - h,
			}),
				t.insert(
					t.mapping.slice(a).map(e.positionAt(s, p, n)),
					f.type.createAndFill({
						...f.attrs,
						rowspan: h + f.attrs.rowspan - s,
					}),
				),
				(u += f.attrs.colspan - 1);
		}
	}
	return l;
}
function H7(t, e, n, r, i, o, s, a) {
	if (s == 0 || s == e.width) return !1;
	let l = !1;
	for (let u = i; u < o; u++) {
		const c = u * e.width + s,
			d = e.map[c];
		if (e.map[c - 1] == d) {
			l = !0;
			const f = n.nodeAt(d),
				h = e.colCount(d),
				p = t.mapping.slice(a).map(d + r);
			t.setNodeMarkup(
				p,
				null,
				Nd(f.attrs, s - h, f.attrs.colspan - (s - h)),
			),
				t.insert(
					p + f.nodeSize,
					f.type.createAndFill(Nd(f.attrs, 0, s - h)),
				),
				(u += f.attrs.rowspan - 1);
		}
	}
	return l;
}
function W7(t, e, n, r, i) {
	let o = n ? t.doc.nodeAt(n - 1) : t.doc;
	if (!o) throw new Error("No table found");
	let s = Br.get(o);
	const { top: a, left: l } = r,
		u = l + i.width,
		c = a + i.height,
		d = t.tr;
	let f = 0;
	function h() {
		if (((o = n ? d.doc.nodeAt(n - 1) : d.doc), !o))
			throw new Error("No table found");
		(s = Br.get(o)), (f = d.mapping.maps.length);
	}
	zSe(d, s, o, n, u, c, f) && h(),
		U7(d, s, o, n, l, u, a, f) && h(),
		U7(d, s, o, n, l, u, c, f) && h(),
		H7(d, s, o, n, a, c, l, f) && h(),
		H7(d, s, o, n, a, c, u, f) && h();
	for (let p = a; p < c; p++) {
		const g = s.positionAt(p, l, o),
			v = s.positionAt(p, u, o);
		d.replace(
			d.mapping.slice(f).map(g + n),
			d.mapping.slice(f).map(v + n),
			new Ee(i.rows[p - a], 0, 0),
		);
	}
	h(),
		d.setSelection(
			new gr(
				d.doc.resolve(n + s.positionAt(a, l, o)),
				d.doc.resolve(n + s.positionAt(c - 1, u - 1, o)),
			),
		),
		e(d);
}
var LSe = G5({
	ArrowLeft: q1("horiz", -1),
	ArrowRight: q1("horiz", 1),
	ArrowUp: q1("vert", -1),
	ArrowDown: q1("vert", 1),
	"Shift-ArrowLeft": G1("horiz", -1),
	"Shift-ArrowRight": G1("horiz", 1),
	"Shift-ArrowUp": G1("vert", -1),
	"Shift-ArrowDown": G1("vert", 1),
	Backspace: W1,
	"Mod-Backspace": W1,
	Delete: W1,
	"Mod-Delete": W1,
});
function Nb(t, e, n) {
	return n.eq(t.selection)
		? !1
		: (e && e(t.tr.setSelection(n).scrollIntoView()), !0);
}
function q1(t, e) {
	return (n, r, i) => {
		if (!i) return !1;
		const o = n.selection;
		if (o instanceof gr) return Nb(n, r, mt.near(o.$headCell, e));
		if (t != "horiz" && !o.empty) return !1;
		const s = BG(i, t, e);
		if (s == null) return !1;
		if (t == "horiz")
			return Nb(n, r, mt.near(n.doc.resolve(o.head + e), e));
		{
			const a = n.doc.resolve(s),
				l = AG(a, t, e);
			let u;
			return (
				l
					? (u = mt.near(l, 1))
					: e < 0
						? (u = mt.near(n.doc.resolve(a.before(-1)), -1))
						: (u = mt.near(n.doc.resolve(a.after(-1)), 1)),
				Nb(n, r, u)
			);
		}
	};
}
function G1(t, e) {
	return (n, r, i) => {
		if (!i) return !1;
		const o = n.selection;
		let s;
		if (o instanceof gr) s = o;
		else {
			const l = BG(i, t, e);
			if (l == null) return !1;
			s = new gr(n.doc.resolve(l));
		}
		const a = AG(s.$headCell, t, e);
		return a ? Nb(n, r, new gr(s.$anchorCell, a)) : !1;
	};
}
function VSe(t, e) {
	const n = t.state.doc,
		r = _3(n.resolve(e));
	return r ? (t.dispatch(t.state.tr.setSelection(new gr(r))), !0) : !1;
}
function KSe(t, e, n) {
	if (!rf(t.state)) return !1;
	let r = MSe(n);
	const i = t.state.selection;
	if (i instanceof gr) {
		r ||
			(r = {
				width: 1,
				height: 1,
				rows: [be.from(dE(Ui(t.state.schema).cell, n))],
			});
		const o = i.$anchorCell.node(-1),
			s = i.$anchorCell.start(-1),
			a = Br.get(o).rectBetween(
				i.$anchorCell.pos - s,
				i.$headCell.pos - s,
			);
		return (
			(r = _Se(r, a.right - a.left, a.bottom - a.top)),
			W7(t.state, t.dispatch, s, a, r),
			!0
		);
	} else if (r) {
		const o = SG(t.state),
			s = o.start(-1);
		return (
			W7(
				t.state,
				t.dispatch,
				s,
				Br.get(o.node(-1)).findCell(o.pos - s),
				r,
			),
			!0
		);
	} else return !1;
}
function USe(t, e) {
	var n;
	if (e.ctrlKey || e.metaKey) return;
	const r = q7(t, e.target);
	let i;
	if (e.shiftKey && t.state.selection instanceof gr)
		o(t.state.selection.$anchorCell, e), e.preventDefault();
	else if (
		e.shiftKey &&
		r &&
		(i = _3(t.state.selection.$anchor)) != null &&
		((n = gC(t, e)) == null ? void 0 : n.pos) != i.pos
	)
		o(i, e), e.preventDefault();
	else if (!r) return;
	function o(l, u) {
		let c = gC(t, u);
		const d = lu.getState(t.state) == null;
		if (!c || !Y5(l, c))
			if (d) c = l;
			else return;
		const f = new gr(l, c);
		if (d || !t.state.selection.eq(f)) {
			const h = t.state.tr.setSelection(f);
			d && h.setMeta(lu, l.pos), t.dispatch(h);
		}
	}
	function s() {
		t.root.removeEventListener("mouseup", s),
			t.root.removeEventListener("dragstart", s),
			t.root.removeEventListener("mousemove", a),
			lu.getState(t.state) != null &&
				t.dispatch(t.state.tr.setMeta(lu, -1));
	}
	function a(l) {
		const u = l,
			c = lu.getState(t.state);
		let d;
		if (c != null) d = t.state.doc.resolve(c);
		else if (q7(t, u.target) != r && ((d = gC(t, e)), !d)) return s();
		d && o(d, u);
	}
	t.root.addEventListener("mouseup", s),
		t.root.addEventListener("dragstart", s),
		t.root.addEventListener("mousemove", a);
}
function BG(t, e, n) {
	if (!(t.state.selection instanceof kt)) return null;
	const { $head: r } = t.state.selection;
	for (let i = r.depth - 1; i >= 0; i--) {
		const o = r.node(i);
		if (
			(n < 0 ? r.index(i) : r.indexAfter(i)) != (n < 0 ? 0 : o.childCount)
		)
			return null;
		if (
			o.type.spec.tableRole == "cell" ||
			o.type.spec.tableRole == "header_cell"
		) {
			const a = r.before(i),
				l =
					e == "vert"
						? n > 0
							? "down"
							: "up"
						: n > 0
							? "right"
							: "left";
			return t.endOfTextblock(l) ? a : null;
		}
	}
	return null;
}
function q7(t, e) {
	for (; e && e != t.dom; e = e.parentNode)
		if (e.nodeName == "TD" || e.nodeName == "TH") return e;
	return null;
}
function gC(t, e) {
	const n = t.posAtCoords({ left: e.clientX, top: e.clientY });
	return n && n ? _3(t.state.doc.resolve(n.pos)) : null;
}
new Os("tableColumnResizing");
function HSe({ allowTableNodeSelection: t = !1 } = {}) {
	return new Gn({
		key: lu,
		state: {
			init() {
				return null;
			},
			apply(e, n) {
				const r = e.getMeta(lu);
				if (r != null) return r == -1 ? null : r;
				if (n == null || !e.docChanged) return n;
				const { deleted: i, pos: o } = e.mapping.mapResult(n);
				return i ? null : o;
			},
		},
		props: {
			decorations: xSe,
			handleDOMEvents: { mousedown: USe },
			createSelectionBetween(e) {
				return lu.getState(e.state) != null ? e.state.selection : null;
			},
			handleTripleClick: VSe,
			handleKeyDown: LSe,
			handlePaste: KSe,
		},
		appendTransaction(e, n, r) {
			return wSe(r, DSe(r, n), t);
		},
	});
}
var Ny = 200,
	br = function () {};
br.prototype.append = function (e) {
	return e.length
		? ((e = br.from(e)),
			(!this.length && e) ||
				(e.length < Ny && this.leafAppend(e)) ||
				(this.length < Ny && e.leafPrepend(this)) ||
				this.appendInner(e))
		: this;
};
br.prototype.prepend = function (e) {
	return e.length ? br.from(e).append(this) : this;
};
br.prototype.appendInner = function (e) {
	return new WSe(this, e);
};
br.prototype.slice = function (e, n) {
	return (
		e === void 0 && (e = 0),
		n === void 0 && (n = this.length),
		e >= n
			? br.empty
			: this.sliceInner(Math.max(0, e), Math.min(this.length, n))
	);
};
br.prototype.get = function (e) {
	if (!(e < 0 || e >= this.length)) return this.getInner(e);
};
br.prototype.forEach = function (e, n, r) {
	n === void 0 && (n = 0),
		r === void 0 && (r = this.length),
		n <= r
			? this.forEachInner(e, n, r, 0)
			: this.forEachInvertedInner(e, n, r, 0);
};
br.prototype.map = function (e, n, r) {
	n === void 0 && (n = 0), r === void 0 && (r = this.length);
	var i = [];
	return (
		this.forEach(
			function (o, s) {
				return i.push(e(o, s));
			},
			n,
			r,
		),
		i
	);
};
br.from = function (e) {
	return e instanceof br ? e : e && e.length ? new IG(e) : br.empty;
};
var IG = (function (t) {
	function e(r) {
		t.call(this), (this.values = r);
	}
	t && (e.__proto__ = t),
		(e.prototype = Object.create(t && t.prototype)),
		(e.prototype.constructor = e);
	var n = { length: { configurable: !0 }, depth: { configurable: !0 } };
	return (
		(e.prototype.flatten = function () {
			return this.values;
		}),
		(e.prototype.sliceInner = function (i, o) {
			return i == 0 && o == this.length
				? this
				: new e(this.values.slice(i, o));
		}),
		(e.prototype.getInner = function (i) {
			return this.values[i];
		}),
		(e.prototype.forEachInner = function (i, o, s, a) {
			for (var l = o; l < s; l++)
				if (i(this.values[l], a + l) === !1) return !1;
		}),
		(e.prototype.forEachInvertedInner = function (i, o, s, a) {
			for (var l = o - 1; l >= s; l--)
				if (i(this.values[l], a + l) === !1) return !1;
		}),
		(e.prototype.leafAppend = function (i) {
			if (this.length + i.length <= Ny)
				return new e(this.values.concat(i.flatten()));
		}),
		(e.prototype.leafPrepend = function (i) {
			if (this.length + i.length <= Ny)
				return new e(i.flatten().concat(this.values));
		}),
		(n.length.get = function () {
			return this.values.length;
		}),
		(n.depth.get = function () {
			return 0;
		}),
		Object.defineProperties(e.prototype, n),
		e
	);
})(br);
br.empty = new IG([]);
var WSe = (function (t) {
	function e(n, r) {
		t.call(this),
			(this.left = n),
			(this.right = r),
			(this.length = n.length + r.length),
			(this.depth = Math.max(n.depth, r.depth) + 1);
	}
	return (
		t && (e.__proto__ = t),
		(e.prototype = Object.create(t && t.prototype)),
		(e.prototype.constructor = e),
		(e.prototype.flatten = function () {
			return this.left.flatten().concat(this.right.flatten());
		}),
		(e.prototype.getInner = function (r) {
			return r < this.left.length
				? this.left.get(r)
				: this.right.get(r - this.left.length);
		}),
		(e.prototype.forEachInner = function (r, i, o, s) {
			var a = this.left.length;
			if (
				(i < a &&
					this.left.forEachInner(r, i, Math.min(o, a), s) === !1) ||
				(o > a &&
					this.right.forEachInner(
						r,
						Math.max(i - a, 0),
						Math.min(this.length, o) - a,
						s + a,
					) === !1)
			)
				return !1;
		}),
		(e.prototype.forEachInvertedInner = function (r, i, o, s) {
			var a = this.left.length;
			if (
				(i > a &&
					this.right.forEachInvertedInner(
						r,
						i - a,
						Math.max(o, a) - a,
						s + a,
					) === !1) ||
				(o < a &&
					this.left.forEachInvertedInner(r, Math.min(i, a), o, s) ===
						!1)
			)
				return !1;
		}),
		(e.prototype.sliceInner = function (r, i) {
			if (r == 0 && i == this.length) return this;
			var o = this.left.length;
			return i <= o
				? this.left.slice(r, i)
				: r >= o
					? this.right.slice(r - o, i - o)
					: this.left.slice(r, o).append(this.right.slice(0, i - o));
		}),
		(e.prototype.leafAppend = function (r) {
			var i = this.right.leafAppend(r);
			if (i) return new e(this.left, i);
		}),
		(e.prototype.leafPrepend = function (r) {
			var i = this.left.leafPrepend(r);
			if (i) return new e(i, this.right);
		}),
		(e.prototype.appendInner = function (r) {
			return this.left.depth >= Math.max(this.right.depth, r.depth) + 1
				? new e(this.left, new e(this.right, r))
				: new e(this, r);
		}),
		e
	);
})(br);
const qSe = 500;
class bs {
	constructor(e, n) {
		(this.items = e), (this.eventCount = n);
	}
	popEvent(e, n) {
		if (this.eventCount == 0) return null;
		let r = this.items.length;
		for (; ; r--)
			if (this.items.get(r - 1).selection) {
				--r;
				break;
			}
		let i, o;
		n && ((i = this.remapping(r, this.items.length)), (o = i.maps.length));
		let s = e.tr,
			a,
			l,
			u = [],
			c = [];
		return (
			this.items.forEach(
				(d, f) => {
					if (!d.step) {
						i ||
							((i = this.remapping(r, f + 1)),
							(o = i.maps.length)),
							o--,
							c.push(d);
						return;
					}
					if (i) {
						c.push(new qs(d.map));
						let h = d.step.map(i.slice(o)),
							p;
						h &&
							s.maybeStep(h).doc &&
							((p = s.mapping.maps[s.mapping.maps.length - 1]),
							u.push(
								new qs(p, void 0, void 0, u.length + c.length),
							)),
							o--,
							p && i.appendMap(p, o);
					} else s.maybeStep(d.step);
					if (d.selection)
						return (
							(a = i ? d.selection.map(i.slice(o)) : d.selection),
							(l = new bs(
								this.items
									.slice(0, r)
									.append(c.reverse().concat(u)),
								this.eventCount - 1,
							)),
							!1
						);
				},
				this.items.length,
				0,
			),
			{ remaining: l, transform: s, selection: a }
		);
	}
	addTransform(e, n, r, i) {
		let o = [],
			s = this.eventCount,
			a = this.items,
			l = !i && a.length ? a.get(a.length - 1) : null;
		for (let c = 0; c < e.steps.length; c++) {
			let d = e.steps[c].invert(e.docs[c]),
				f = new qs(e.mapping.maps[c], d, n),
				h;
			(h = l && l.merge(f)) &&
				((f = h), c ? o.pop() : (a = a.slice(0, a.length - 1))),
				o.push(f),
				n && (s++, (n = void 0)),
				i || (l = f);
		}
		let u = s - r.depth;
		return u > YSe && ((a = GSe(a, u)), (s -= u)), new bs(a.append(o), s);
	}
	remapping(e, n) {
		let r = new th();
		return (
			this.items.forEach(
				(i, o) => {
					let s =
						i.mirrorOffset != null && o - i.mirrorOffset >= e
							? r.maps.length - i.mirrorOffset
							: void 0;
					r.appendMap(i.map, s);
				},
				e,
				n,
			),
			r
		);
	}
	addMaps(e) {
		return this.eventCount == 0
			? this
			: new bs(
					this.items.append(e.map((n) => new qs(n))),
					this.eventCount,
				);
	}
	rebased(e, n) {
		if (!this.eventCount) return this;
		let r = [],
			i = Math.max(0, this.items.length - n),
			o = e.mapping,
			s = e.steps.length,
			a = this.eventCount;
		this.items.forEach((f) => {
			f.selection && a--;
		}, i);
		let l = n;
		this.items.forEach((f) => {
			let h = o.getMirror(--l);
			if (h == null) return;
			s = Math.min(s, h);
			let p = o.maps[h];
			if (f.step) {
				let g = e.steps[h].invert(e.docs[h]),
					v = f.selection && f.selection.map(o.slice(l + 1, h));
				v && a++, r.push(new qs(p, g, v));
			} else r.push(new qs(p));
		}, i);
		let u = [];
		for (let f = n; f < s; f++) u.push(new qs(o.maps[f]));
		let c = this.items.slice(0, i).append(u).append(r),
			d = new bs(c, a);
		return (
			d.emptyItemCount() > qSe &&
				(d = d.compress(this.items.length - r.length)),
			d
		);
	}
	emptyItemCount() {
		let e = 0;
		return (
			this.items.forEach((n) => {
				n.step || e++;
			}),
			e
		);
	}
	compress(e = this.items.length) {
		let n = this.remapping(0, e),
			r = n.maps.length,
			i = [],
			o = 0;
		return (
			this.items.forEach(
				(s, a) => {
					if (a >= e) i.push(s), s.selection && o++;
					else if (s.step) {
						let l = s.step.map(n.slice(r)),
							u = l && l.getMap();
						if ((r--, u && n.appendMap(u, r), l)) {
							let c = s.selection && s.selection.map(n.slice(r));
							c && o++;
							let d = new qs(u.invert(), l, c),
								f,
								h = i.length - 1;
							(f = i.length && i[h].merge(d))
								? (i[h] = f)
								: i.push(d);
						}
					} else s.map && r--;
				},
				this.items.length,
				0,
			),
			new bs(br.from(i.reverse()), o)
		);
	}
}
bs.empty = new bs(br.empty, 0);
function GSe(t, e) {
	let n;
	return (
		t.forEach((r, i) => {
			if (r.selection && e-- == 0) return (n = i), !1;
		}),
		t.slice(n)
	);
}
class qs {
	constructor(e, n, r, i) {
		(this.map = e),
			(this.step = n),
			(this.selection = r),
			(this.mirrorOffset = i);
	}
	merge(e) {
		if (this.step && e.step && !e.selection) {
			let n = e.step.merge(this.step);
			if (n) return new qs(n.getMap().invert(), n, this.selection);
		}
	}
}
class ru {
	constructor(e, n, r, i, o) {
		(this.done = e),
			(this.undone = n),
			(this.prevRanges = r),
			(this.prevTime = i),
			(this.prevComposition = o);
	}
}
const YSe = 20;
function JSe(t, e, n, r) {
	let i = n.getMeta(ld),
		o;
	if (i) return i.historyState;
	n.getMeta(FG) && (t = new ru(t.done, t.undone, null, 0, -1));
	let s = n.getMeta("appendedTransaction");
	if (n.steps.length == 0) return t;
	if (s && s.getMeta(ld))
		return s.getMeta(ld).redo
			? new ru(
					t.done.addTransform(n, void 0, r, Rb(e)),
					t.undone,
					G7(n.mapping.maps),
					t.prevTime,
					t.prevComposition,
				)
			: new ru(
					t.done,
					t.undone.addTransform(n, void 0, r, Rb(e)),
					null,
					t.prevTime,
					t.prevComposition,
				);
	if (
		n.getMeta("addToHistory") !== !1 &&
		!(s && s.getMeta("addToHistory") === !1)
	) {
		let a = n.getMeta("composition"),
			l =
				t.prevTime == 0 ||
				(!s &&
					t.prevComposition != a &&
					(t.prevTime < (n.time || 0) - r.newGroupDelay ||
						!XSe(n, t.prevRanges))),
			u = s ? bC(t.prevRanges, n.mapping) : G7(n.mapping.maps);
		return new ru(
			t.done.addTransform(
				n,
				l ? e.selection.getBookmark() : void 0,
				r,
				Rb(e),
			),
			bs.empty,
			u,
			n.time,
			a ?? t.prevComposition,
		);
	} else
		return (o = n.getMeta("rebased"))
			? new ru(
					t.done.rebased(n, o),
					t.undone.rebased(n, o),
					bC(t.prevRanges, n.mapping),
					t.prevTime,
					t.prevComposition,
				)
			: new ru(
					t.done.addMaps(n.mapping.maps),
					t.undone.addMaps(n.mapping.maps),
					bC(t.prevRanges, n.mapping),
					t.prevTime,
					t.prevComposition,
				);
}
function XSe(t, e) {
	if (!e) return !1;
	if (!t.docChanged) return !0;
	let n = !1;
	return (
		t.mapping.maps[0].forEach((r, i) => {
			for (let o = 0; o < e.length; o += 2)
				r <= e[o + 1] && i >= e[o] && (n = !0);
		}),
		n
	);
}
function G7(t) {
	let e = [];
	for (let n = t.length - 1; n >= 0 && e.length == 0; n--)
		t[n].forEach((r, i, o, s) => e.push(o, s));
	return e;
}
function bC(t, e) {
	if (!t) return null;
	let n = [];
	for (let r = 0; r < t.length; r += 2) {
		let i = e.map(t[r], 1),
			o = e.map(t[r + 1], -1);
		i <= o && n.push(i, o);
	}
	return n;
}
function ZSe(t, e, n) {
	let r = Rb(e),
		i = ld.get(e).spec.config,
		o = (n ? t.undone : t.done).popEvent(e, r);
	if (!o) return null;
	let s = o.selection.resolve(o.transform.doc),
		a = (n ? t.done : t.undone).addTransform(
			o.transform,
			e.selection.getBookmark(),
			i,
			r,
		),
		l = new ru(n ? a : o.remaining, n ? o.remaining : a, null, 0, -1);
	return o.transform
		.setSelection(s)
		.setMeta(ld, { redo: n, historyState: l });
}
let vC = !1,
	Y7 = null;
function Rb(t) {
	let e = t.plugins;
	if (Y7 != e) {
		(vC = !1), (Y7 = e);
		for (let n = 0; n < e.length; n++)
			if (e[n].spec.historyPreserveItems) {
				vC = !0;
				break;
			}
	}
	return vC;
}
function QSe(t) {
	return t.setMeta(FG, !0);
}
const ld = new Os("history"),
	FG = new Os("closeHistory");
function e5e(t = {}) {
	return (
		(t = { depth: t.depth || 100, newGroupDelay: t.newGroupDelay || 500 }),
		new Gn({
			key: ld,
			state: {
				init() {
					return new ru(bs.empty, bs.empty, null, 0, -1);
				},
				apply(e, n, r) {
					return JSe(n, r, e, t);
				},
			},
			config: t,
			props: {
				handleDOMEvents: {
					beforeinput(e, n) {
						let r = n.inputType,
							i =
								r == "historyUndo"
									? NG
									: r == "historyRedo"
										? fE
										: null;
						return i
							? (n.preventDefault(), i(e.state, e.dispatch))
							: !1;
					},
				},
			},
		})
	);
}
function PG(t, e) {
	return (n, r) => {
		let i = ld.getState(n);
		if (!i || (t ? i.undone : i.done).eventCount == 0) return !1;
		if (r) {
			let o = ZSe(i, n, t);
			o && r(e ? o.scrollIntoView() : o);
		}
		return !0;
	};
}
const NG = PG(!1, !0),
	fE = PG(!0, !0),
	J7 = {}.hasOwnProperty;
function t5e(t, e) {
	const n = e || {};
	function r(i, ...o) {
		let s = r.invalid;
		const a = r.handlers;
		if (i && J7.call(i, t)) {
			const l = String(i[t]);
			s = J7.call(a, l) ? a[l] : r.unknown;
		}
		if (s) return s.call(this, i, ...o);
	}
	return (
		(r.handlers = n.handlers || {}),
		(r.invalid = n.invalid),
		(r.unknown = n.unknown),
		r
	);
}
const n5e = {}.hasOwnProperty;
function RG(t, e) {
	let n = -1,
		r;
	if (e.extensions)
		for (; ++n < e.extensions.length; ) RG(t, e.extensions[n]);
	for (r in e)
		if (n5e.call(e, r))
			switch (r) {
				case "extensions":
					break;
				case "unsafe": {
					X7(t[r], e[r]);
					break;
				}
				case "join": {
					X7(t[r], e[r]);
					break;
				}
				case "handlers": {
					r5e(t[r], e[r]);
					break;
				}
				default:
					t.options[r] = e[r];
			}
	return t;
}
function X7(t, e) {
	e && t.push(...e);
}
function r5e(t, e) {
	e && Object.assign(t, e);
}
function i5e(t, e, n, r) {
	const i = n.enter("blockquote"),
		o = n.createTracker(r);
	o.move("> "), o.shift(2);
	const s = n.indentLines(n.containerFlow(t, o.current()), o5e);
	return i(), s;
}
function o5e(t, e, n) {
	return ">" + (n ? "" : " ") + t;
}
function OG(t, e) {
	return Z7(t, e.inConstruct, !0) && !Z7(t, e.notInConstruct, !1);
}
function Z7(t, e, n) {
	if ((typeof e == "string" && (e = [e]), !e || e.length === 0)) return n;
	let r = -1;
	for (; ++r < e.length; ) if (t.includes(e[r])) return !0;
	return !1;
}
function Q7(t, e, n, r) {
	let i = -1;
	for (; ++i < n.unsafe.length; )
		if (
			n.unsafe[i].character ===
				`
` &&
			OG(n.stack, n.unsafe[i])
		)
			return /[ \t]/.test(r.before) ? "" : " ";
	return `\\
`;
}
function s5e(t, e) {
	const n = String(t);
	let r = n.indexOf(e),
		i = r,
		o = 0,
		s = 0;
	if (typeof e != "string") throw new TypeError("Expected substring");
	for (; r !== -1; )
		r === i ? ++o > s && (s = o) : (o = 1),
			(i = r + e.length),
			(r = n.indexOf(e, i));
	return s;
}
function hE(t, e) {
	return !!(
		e.options.fences === !1 &&
		t.value &&
		!t.lang &&
		/[^ \r\n]/.test(t.value) &&
		!/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(t.value)
	);
}
function a5e(t) {
	const e = t.options.fence || "`";
	if (e !== "`" && e !== "~")
		throw new Error(
			"Cannot serialize code with `" +
				e +
				"` for `options.fence`, expected `` ` `` or `~`",
		);
	return e;
}
function l5e(t, e, n, r) {
	const i = a5e(n),
		o = t.value || "",
		s = i === "`" ? "GraveAccent" : "Tilde";
	if (hE(t, n)) {
		const d = n.enter("codeIndented"),
			f = n.indentLines(o, u5e);
		return d(), f;
	}
	const a = n.createTracker(r),
		l = i.repeat(Math.max(s5e(o, i) + 1, 3)),
		u = n.enter("codeFenced");
	let c = a.move(l);
	if (t.lang) {
		const d = n.enter(`codeFencedLang${s}`);
		(c += a.move(
			n.safe(t.lang, {
				before: c,
				after: " ",
				encode: ["`"],
				...a.current(),
			}),
		)),
			d();
	}
	if (t.lang && t.meta) {
		const d = n.enter(`codeFencedMeta${s}`);
		(c += a.move(" ")),
			(c += a.move(
				n.safe(t.meta, {
					before: c,
					after: `
`,
					encode: ["`"],
					...a.current(),
				}),
			)),
			d();
	}
	return (
		(c += a.move(`
`)),
		o &&
			(c += a.move(
				o +
					`
`,
			)),
		(c += a.move(l)),
		u(),
		c
	);
}
function u5e(t, e, n) {
	return (n ? "" : "    ") + t;
}
function J5(t) {
	const e = t.options.quote || '"';
	if (e !== '"' && e !== "'")
		throw new Error(
			"Cannot serialize title with `" +
				e +
				"` for `options.quote`, expected `\"`, or `'`",
		);
	return e;
}
function c5e(t, e, n, r) {
	const i = J5(n),
		o = i === '"' ? "Quote" : "Apostrophe",
		s = n.enter("definition");
	let a = n.enter("label");
	const l = n.createTracker(r);
	let u = l.move("[");
	return (
		(u += l.move(
			n.safe(n.associationId(t), {
				before: u,
				after: "]",
				...l.current(),
			}),
		)),
		(u += l.move("]: ")),
		a(),
		!t.url || /[\0- \u007F]/.test(t.url)
			? ((a = n.enter("destinationLiteral")),
				(u += l.move("<")),
				(u += l.move(
					n.safe(t.url, { before: u, after: ">", ...l.current() }),
				)),
				(u += l.move(">")))
			: ((a = n.enter("destinationRaw")),
				(u += l.move(
					n.safe(t.url, {
						before: u,
						after: t.title
							? " "
							: `
`,
						...l.current(),
					}),
				))),
		a(),
		t.title &&
			((a = n.enter(`title${o}`)),
			(u += l.move(" " + i)),
			(u += l.move(
				n.safe(t.title, { before: u, after: i, ...l.current() }),
			)),
			(u += l.move(i)),
			a()),
		s(),
		u
	);
}
function d5e(t) {
	const e = t.options.emphasis || "*";
	if (e !== "*" && e !== "_")
		throw new Error(
			"Cannot serialize emphasis with `" +
				e +
				"` for `options.emphasis`, expected `*`, or `_`",
		);
	return e;
}
MG.peek = f5e;
function MG(t, e, n, r) {
	const i = d5e(n),
		o = n.enter("emphasis"),
		s = n.createTracker(r);
	let a = s.move(i);
	return (
		(a += s.move(
			n.containerPhrasing(t, { before: a, after: i, ...s.current() }),
		)),
		(a += s.move(i)),
		o(),
		a
	);
}
function f5e(t, e, n) {
	return n.options.emphasis || "*";
}
function jG(t, e, n, r) {
	let i, o, s;
	typeof e == "function" && typeof n != "function"
		? ((o = void 0), (s = e), (i = n))
		: ((o = e), (s = n), (i = r)),
		dG(t, o, a, i);
	function a(l, u) {
		const c = u[u.length - 1],
			d = c ? c.children.indexOf(l) : void 0;
		return s(l, d, c);
	}
}
function _G(t, e) {
	let n = !1;
	return (
		jG(t, function (r) {
			if (
				("value" in r && /\r?\n|\r/.test(r.value)) ||
				r.type === "break"
			)
				return (n = !0), aE;
		}),
		!!((!t.depth || t.depth < 3) && U5(t) && (e.options.setext || n))
	);
}
function h5e(t, e, n, r) {
	const i = Math.max(Math.min(6, t.depth || 1), 1),
		o = n.createTracker(r);
	if (_G(t, n)) {
		const c = n.enter("headingSetext"),
			d = n.enter("phrasing"),
			f = n.containerPhrasing(t, {
				...o.current(),
				before: `
`,
				after: `
`,
			});
		return (
			d(),
			c(),
			f +
				`
` +
				(i === 1 ? "=" : "-").repeat(
					f.length -
						(Math.max(
							f.lastIndexOf("\r"),
							f.lastIndexOf(`
`),
						) +
							1),
				)
		);
	}
	const s = "#".repeat(i),
		a = n.enter("headingAtx"),
		l = n.enter("phrasing");
	o.move(s + " ");
	let u = n.containerPhrasing(t, {
		before: "# ",
		after: `
`,
		...o.current(),
	});
	return (
		/^[\t ]/.test(u) &&
			(u =
				"&#x" +
				u.charCodeAt(0).toString(16).toUpperCase() +
				";" +
				u.slice(1)),
		(u = u ? s + " " + u : s),
		n.options.closeAtx && (u += " " + s),
		l(),
		a(),
		u
	);
}
zG.peek = p5e;
function zG(t) {
	return t.value || "";
}
function p5e() {
	return "<";
}
LG.peek = m5e;
function LG(t, e, n, r) {
	const i = J5(n),
		o = i === '"' ? "Quote" : "Apostrophe",
		s = n.enter("image");
	let a = n.enter("label");
	const l = n.createTracker(r);
	let u = l.move("![");
	return (
		(u += l.move(n.safe(t.alt, { before: u, after: "]", ...l.current() }))),
		(u += l.move("](")),
		a(),
		(!t.url && t.title) || /[\0- \u007F]/.test(t.url)
			? ((a = n.enter("destinationLiteral")),
				(u += l.move("<")),
				(u += l.move(
					n.safe(t.url, { before: u, after: ">", ...l.current() }),
				)),
				(u += l.move(">")))
			: ((a = n.enter("destinationRaw")),
				(u += l.move(
					n.safe(t.url, {
						before: u,
						after: t.title ? " " : ")",
						...l.current(),
					}),
				))),
		a(),
		t.title &&
			((a = n.enter(`title${o}`)),
			(u += l.move(" " + i)),
			(u += l.move(
				n.safe(t.title, { before: u, after: i, ...l.current() }),
			)),
			(u += l.move(i)),
			a()),
		(u += l.move(")")),
		s(),
		u
	);
}
function m5e() {
	return "!";
}
VG.peek = g5e;
function VG(t, e, n, r) {
	const i = t.referenceType,
		o = n.enter("imageReference");
	let s = n.enter("label");
	const a = n.createTracker(r);
	let l = a.move("![");
	const u = n.safe(t.alt, { before: l, after: "]", ...a.current() });
	(l += a.move(u + "][")), s();
	const c = n.stack;
	(n.stack = []), (s = n.enter("reference"));
	const d = n.safe(n.associationId(t), {
		before: l,
		after: "]",
		...a.current(),
	});
	return (
		s(),
		(n.stack = c),
		o(),
		i === "full" || !u || u !== d
			? (l += a.move(d + "]"))
			: i === "shortcut"
				? (l = l.slice(0, -1))
				: (l += a.move("]")),
		l
	);
}
function g5e() {
	return "!";
}
KG.peek = b5e;
function KG(t, e, n) {
	let r = t.value || "",
		i = "`",
		o = -1;
	for (; new RegExp("(^|[^`])" + i + "([^`]|$)").test(r); ) i += "`";
	for (
		/[^ \r\n]/.test(r) &&
		((/^[ \r\n]/.test(r) && /[ \r\n]$/.test(r)) || /^`|`$/.test(r)) &&
		(r = " " + r + " ");
		++o < n.unsafe.length;

	) {
		const s = n.unsafe[o],
			a = n.compilePattern(s);
		let l;
		if (s.atBreak)
			for (; (l = a.exec(r)); ) {
				let u = l.index;
				r.charCodeAt(u) === 10 && r.charCodeAt(u - 1) === 13 && u--,
					(r = r.slice(0, u) + " " + r.slice(l.index + 1));
			}
	}
	return i + r + i;
}
function b5e() {
	return "`";
}
function UG(t, e) {
	const n = U5(t);
	return !!(
		!e.options.resourceLink &&
		t.url &&
		!t.title &&
		t.children &&
		t.children.length === 1 &&
		t.children[0].type === "text" &&
		(n === t.url || "mailto:" + n === t.url) &&
		/^[a-z][a-z+.-]+:/i.test(t.url) &&
		!/[\0- <>\u007F]/.test(t.url)
	);
}
HG.peek = v5e;
function HG(t, e, n, r) {
	const i = J5(n),
		o = i === '"' ? "Quote" : "Apostrophe",
		s = n.createTracker(r);
	let a, l;
	if (UG(t, n)) {
		const c = n.stack;
		(n.stack = []), (a = n.enter("autolink"));
		let d = s.move("<");
		return (
			(d += s.move(
				n.containerPhrasing(t, {
					before: d,
					after: ">",
					...s.current(),
				}),
			)),
			(d += s.move(">")),
			a(),
			(n.stack = c),
			d
		);
	}
	(a = n.enter("link")), (l = n.enter("label"));
	let u = s.move("[");
	return (
		(u += s.move(
			n.containerPhrasing(t, { before: u, after: "](", ...s.current() }),
		)),
		(u += s.move("](")),
		l(),
		(!t.url && t.title) || /[\0- \u007F]/.test(t.url)
			? ((l = n.enter("destinationLiteral")),
				(u += s.move("<")),
				(u += s.move(
					n.safe(t.url, { before: u, after: ">", ...s.current() }),
				)),
				(u += s.move(">")))
			: ((l = n.enter("destinationRaw")),
				(u += s.move(
					n.safe(t.url, {
						before: u,
						after: t.title ? " " : ")",
						...s.current(),
					}),
				))),
		l(),
		t.title &&
			((l = n.enter(`title${o}`)),
			(u += s.move(" " + i)),
			(u += s.move(
				n.safe(t.title, { before: u, after: i, ...s.current() }),
			)),
			(u += s.move(i)),
			l()),
		(u += s.move(")")),
		a(),
		u
	);
}
function v5e(t, e, n) {
	return UG(t, n) ? "<" : "[";
}
WG.peek = y5e;
function WG(t, e, n, r) {
	const i = t.referenceType,
		o = n.enter("linkReference");
	let s = n.enter("label");
	const a = n.createTracker(r);
	let l = a.move("[");
	const u = n.containerPhrasing(t, { before: l, after: "]", ...a.current() });
	(l += a.move(u + "][")), s();
	const c = n.stack;
	(n.stack = []), (s = n.enter("reference"));
	const d = n.safe(n.associationId(t), {
		before: l,
		after: "]",
		...a.current(),
	});
	return (
		s(),
		(n.stack = c),
		o(),
		i === "full" || !u || u !== d
			? (l += a.move(d + "]"))
			: i === "shortcut"
				? (l = l.slice(0, -1))
				: (l += a.move("]")),
		l
	);
}
function y5e() {
	return "[";
}
function X5(t) {
	const e = t.options.bullet || "*";
	if (e !== "*" && e !== "+" && e !== "-")
		throw new Error(
			"Cannot serialize items with `" +
				e +
				"` for `options.bullet`, expected `*`, `+`, or `-`",
		);
	return e;
}
function x5e(t) {
	const e = X5(t),
		n = t.options.bulletOther;
	if (!n) return e === "*" ? "-" : "*";
	if (n !== "*" && n !== "+" && n !== "-")
		throw new Error(
			"Cannot serialize items with `" +
				n +
				"` for `options.bulletOther`, expected `*`, `+`, or `-`",
		);
	if (n === e)
		throw new Error(
			"Expected `bullet` (`" +
				e +
				"`) and `bulletOther` (`" +
				n +
				"`) to be different",
		);
	return n;
}
function k5e(t) {
	const e = t.options.bulletOrdered || ".";
	if (e !== "." && e !== ")")
		throw new Error(
			"Cannot serialize items with `" +
				e +
				"` for `options.bulletOrdered`, expected `.` or `)`",
		);
	return e;
}
function qG(t) {
	const e = t.options.rule || "*";
	if (e !== "*" && e !== "-" && e !== "_")
		throw new Error(
			"Cannot serialize rules with `" +
				e +
				"` for `options.rule`, expected `*`, `-`, or `_`",
		);
	return e;
}
function C5e(t, e, n, r) {
	const i = n.enter("list"),
		o = n.bulletCurrent;
	let s = t.ordered ? k5e(n) : X5(n);
	const a = t.ordered ? (s === "." ? ")" : ".") : x5e(n);
	let l = e && n.bulletLastUsed ? s === n.bulletLastUsed : !1;
	if (!t.ordered) {
		const c = t.children ? t.children[0] : void 0;
		if (
			((s === "*" || s === "-") &&
				c &&
				(!c.children || !c.children[0]) &&
				n.stack[n.stack.length - 1] === "list" &&
				n.stack[n.stack.length - 2] === "listItem" &&
				n.stack[n.stack.length - 3] === "list" &&
				n.stack[n.stack.length - 4] === "listItem" &&
				n.indexStack[n.indexStack.length - 1] === 0 &&
				n.indexStack[n.indexStack.length - 2] === 0 &&
				n.indexStack[n.indexStack.length - 3] === 0 &&
				(l = !0),
			qG(n) === s && c)
		) {
			let d = -1;
			for (; ++d < t.children.length; ) {
				const f = t.children[d];
				if (
					f &&
					f.type === "listItem" &&
					f.children &&
					f.children[0] &&
					f.children[0].type === "thematicBreak"
				) {
					l = !0;
					break;
				}
			}
		}
	}
	l && (s = a), (n.bulletCurrent = s);
	const u = n.containerFlow(t, r);
	return (n.bulletLastUsed = s), (n.bulletCurrent = o), i(), u;
}
function w5e(t) {
	const e = t.options.listItemIndent || "one";
	if (e !== "tab" && e !== "one" && e !== "mixed")
		throw new Error(
			"Cannot serialize items with `" +
				e +
				"` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`",
		);
	return e;
}
function E5e(t, e, n, r) {
	const i = w5e(n);
	let o = n.bulletCurrent || X5(n);
	e &&
		e.type === "list" &&
		e.ordered &&
		(o =
			(typeof e.start == "number" && e.start > -1 ? e.start : 1) +
			(n.options.incrementListMarker === !1 ? 0 : e.children.indexOf(t)) +
			o);
	let s = o.length + 1;
	(i === "tab" ||
		(i === "mixed" &&
			((e && e.type === "list" && e.spread) || t.spread))) &&
		(s = Math.ceil(s / 4) * 4);
	const a = n.createTracker(r);
	a.move(o + " ".repeat(s - o.length)), a.shift(s);
	const l = n.enter("listItem"),
		u = n.indentLines(n.containerFlow(t, a.current()), c);
	return l(), u;
	function c(d, f, h) {
		return f
			? (h ? "" : " ".repeat(s)) + d
			: (h ? o : o + " ".repeat(s - o.length)) + d;
	}
}
function D5e(t, e, n, r) {
	const i = n.enter("paragraph"),
		o = n.enter("phrasing"),
		s = n.containerPhrasing(t, r);
	return o(), i(), s;
}
const S5e = M3([
	"break",
	"delete",
	"emphasis",
	"footnote",
	"footnoteReference",
	"image",
	"imageReference",
	"inlineCode",
	"inlineMath",
	"link",
	"linkReference",
	"mdxJsxTextElement",
	"mdxTextExpression",
	"strong",
	"text",
	"textDirective",
]);
function A5e(t, e, n, r) {
	return (
		t.children.some(function (s) {
			return S5e(s);
		})
			? n.containerPhrasing
			: n.containerFlow
	).call(n, t, r);
}
function $5e(t) {
	const e = t.options.strong || "*";
	if (e !== "*" && e !== "_")
		throw new Error(
			"Cannot serialize strong with `" +
				e +
				"` for `options.strong`, expected `*`, or `_`",
		);
	return e;
}
GG.peek = T5e;
function GG(t, e, n, r) {
	const i = $5e(n),
		o = n.enter("strong"),
		s = n.createTracker(r);
	let a = s.move(i + i);
	return (
		(a += s.move(
			n.containerPhrasing(t, { before: a, after: i, ...s.current() }),
		)),
		(a += s.move(i + i)),
		o(),
		a
	);
}
function T5e(t, e, n) {
	return n.options.strong || "*";
}
function B5e(t, e, n, r) {
	return n.safe(t.value, r);
}
function I5e(t) {
	const e = t.options.ruleRepetition || 3;
	if (e < 3)
		throw new Error(
			"Cannot serialize rules with repetition `" +
				e +
				"` for `options.ruleRepetition`, expected `3` or more",
		);
	return e;
}
function F5e(t, e, n) {
	const r = (qG(n) + (n.options.ruleSpaces ? " " : "")).repeat(I5e(n));
	return n.options.ruleSpaces ? r.slice(0, -1) : r;
}
const Z5 = {
		blockquote: i5e,
		break: Q7,
		code: l5e,
		definition: c5e,
		emphasis: MG,
		hardBreak: Q7,
		heading: h5e,
		html: zG,
		image: LG,
		imageReference: VG,
		inlineCode: KG,
		link: HG,
		linkReference: WG,
		list: C5e,
		listItem: E5e,
		paragraph: D5e,
		root: A5e,
		strong: GG,
		text: B5e,
		thematicBreak: F5e,
	},
	P5e = [N5e];
function N5e(t, e, n, r) {
	if (
		e.type === "code" &&
		hE(e, r) &&
		(t.type === "list" || (t.type === e.type && hE(t, r)))
	)
		return !1;
	if ("spread" in n && typeof n.spread == "boolean")
		return t.type === "paragraph" &&
			(t.type === e.type ||
				e.type === "definition" ||
				(e.type === "heading" && _G(e, r)))
			? void 0
			: n.spread
				? 1
				: 0;
}
const mc = [
		"autolink",
		"destinationLiteral",
		"destinationRaw",
		"reference",
		"titleQuote",
		"titleApostrophe",
	],
	R5e = [
		{ character: "	", after: "[\\r\\n]", inConstruct: "phrasing" },
		{ character: "	", before: "[\\r\\n]", inConstruct: "phrasing" },
		{
			character: "	",
			inConstruct: ["codeFencedLangGraveAccent", "codeFencedLangTilde"],
		},
		{
			character: "\r",
			inConstruct: [
				"codeFencedLangGraveAccent",
				"codeFencedLangTilde",
				"codeFencedMetaGraveAccent",
				"codeFencedMetaTilde",
				"destinationLiteral",
				"headingAtx",
			],
		},
		{
			character: `
`,
			inConstruct: [
				"codeFencedLangGraveAccent",
				"codeFencedLangTilde",
				"codeFencedMetaGraveAccent",
				"codeFencedMetaTilde",
				"destinationLiteral",
				"headingAtx",
			],
		},
		{ character: " ", after: "[\\r\\n]", inConstruct: "phrasing" },
		{ character: " ", before: "[\\r\\n]", inConstruct: "phrasing" },
		{
			character: " ",
			inConstruct: ["codeFencedLangGraveAccent", "codeFencedLangTilde"],
		},
		{
			character: "!",
			after: "\\[",
			inConstruct: "phrasing",
			notInConstruct: mc,
		},
		{ character: '"', inConstruct: "titleQuote" },
		{ atBreak: !0, character: "#" },
		{
			character: "#",
			inConstruct: "headingAtx",
			after: `(?:[\r
]|$)`,
		},
		{ character: "&", after: "[#A-Za-z]", inConstruct: "phrasing" },
		{ character: "'", inConstruct: "titleApostrophe" },
		{ character: "(", inConstruct: "destinationRaw" },
		{
			before: "\\]",
			character: "(",
			inConstruct: "phrasing",
			notInConstruct: mc,
		},
		{ atBreak: !0, before: "\\d+", character: ")" },
		{ character: ")", inConstruct: "destinationRaw" },
		{
			atBreak: !0,
			character: "*",
			after: `(?:[ 	\r
*])`,
		},
		{ character: "*", inConstruct: "phrasing", notInConstruct: mc },
		{
			atBreak: !0,
			character: "+",
			after: `(?:[ 	\r
])`,
		},
		{
			atBreak: !0,
			character: "-",
			after: `(?:[ 	\r
-])`,
		},
		{
			atBreak: !0,
			before: "\\d+",
			character: ".",
			after: `(?:[ 	\r
]|$)`,
		},
		{ atBreak: !0, character: "<", after: "[!/?A-Za-z]" },
		{
			character: "<",
			after: "[!/?A-Za-z]",
			inConstruct: "phrasing",
			notInConstruct: mc,
		},
		{ character: "<", inConstruct: "destinationLiteral" },
		{ atBreak: !0, character: "=" },
		{ atBreak: !0, character: ">" },
		{ character: ">", inConstruct: "destinationLiteral" },
		{ atBreak: !0, character: "[" },
		{ character: "[", inConstruct: "phrasing", notInConstruct: mc },
		{ character: "[", inConstruct: ["label", "reference"] },
		{ character: "\\", after: "[\\r\\n]", inConstruct: "phrasing" },
		{ character: "]", inConstruct: ["label", "reference"] },
		{ atBreak: !0, character: "_" },
		{ character: "_", inConstruct: "phrasing", notInConstruct: mc },
		{ atBreak: !0, character: "`" },
		{
			character: "`",
			inConstruct: [
				"codeFencedLangGraveAccent",
				"codeFencedMetaGraveAccent",
			],
		},
		{ character: "`", inConstruct: "phrasing", notInConstruct: mc },
		{ atBreak: !0, character: "~" },
	];
function O5e(t) {
	return t.label || !t.identifier ? t.label || "" : sG(t.identifier);
}
function M5e(t) {
	if (!t._compiled) {
		const e =
			(t.atBreak ? "[\\r\\n][\\t ]*" : "") +
			(t.before ? "(?:" + t.before + ")" : "");
		t._compiled = new RegExp(
			(e ? "(" + e + ")" : "") +
				(/[|\\{}()[\]^$+*?.-]/.test(t.character) ? "\\" : "") +
				t.character +
				(t.after ? "(?:" + t.after + ")" : ""),
			"g",
		);
	}
	return t._compiled;
}
function j5e(t, e, n) {
	const r = e.indexStack,
		i = t.children || [],
		o = [];
	let s = -1,
		a = n.before;
	r.push(-1);
	let l = e.createTracker(n);
	for (; ++s < i.length; ) {
		const u = i[s];
		let c;
		if (((r[r.length - 1] = s), s + 1 < i.length)) {
			let d = e.handle.handlers[i[s + 1].type];
			d && d.peek && (d = d.peek),
				(c = d
					? d(i[s + 1], t, e, {
							before: "",
							after: "",
							...l.current(),
						}).charAt(0)
					: "");
		} else c = n.after;
		o.length > 0 &&
			(a === "\r" ||
				a ===
					`
`) &&
			u.type === "html" &&
			((o[o.length - 1] = o[o.length - 1].replace(/(\r?\n|\r)$/, " ")),
			(a = " "),
			(l = e.createTracker(n)),
			l.move(o.join(""))),
			o.push(
				l.move(
					e.handle(u, t, e, { ...l.current(), before: a, after: c }),
				),
			),
			(a = o[o.length - 1].slice(-1));
	}
	return r.pop(), o.join("");
}
function _5e(t, e, n) {
	const r = e.indexStack,
		i = t.children || [],
		o = e.createTracker(n),
		s = [];
	let a = -1;
	for (r.push(-1); ++a < i.length; ) {
		const l = i[a];
		(r[r.length - 1] = a),
			s.push(
				o.move(
					e.handle(l, t, e, {
						before: `
`,
						after: `
`,
						...o.current(),
					}),
				),
			),
			l.type !== "list" && (e.bulletLastUsed = void 0),
			a < i.length - 1 && s.push(o.move(z5e(l, i[a + 1], t, e)));
	}
	return r.pop(), s.join("");
}
function z5e(t, e, n, r) {
	let i = r.join.length;
	for (; i--; ) {
		const o = r.join[i](t, e, n, r);
		if (o === !0 || o === 1) break;
		if (typeof o == "number")
			return `
`.repeat(1 + o);
		if (o === !1)
			return `

<!---->

`;
	}
	return `

`;
}
const L5e = /\r?\n|\r/g;
function V5e(t, e) {
	const n = [];
	let r = 0,
		i = 0,
		o;
	for (; (o = L5e.exec(t)); )
		s(t.slice(r, o.index)), n.push(o[0]), (r = o.index + o[0].length), i++;
	return s(t.slice(r)), n.join("");
	function s(a) {
		n.push(e(a, i, !a));
	}
}
function K5e(t, e, n) {
	const r = (n.before || "") + (e || "") + (n.after || ""),
		i = [],
		o = [],
		s = {};
	let a = -1;
	for (; ++a < t.unsafe.length; ) {
		const c = t.unsafe[a];
		if (!OG(t.stack, c)) continue;
		const d = t.compilePattern(c);
		let f;
		for (; (f = d.exec(r)); ) {
			const h = "before" in c || !!c.atBreak,
				p = "after" in c,
				g = f.index + (h ? f[1].length : 0);
			i.includes(g)
				? (s[g].before && !h && (s[g].before = !1),
					s[g].after && !p && (s[g].after = !1))
				: (i.push(g), (s[g] = { before: h, after: p }));
		}
	}
	i.sort(U5e);
	let l = n.before ? n.before.length : 0;
	const u = r.length - (n.after ? n.after.length : 0);
	for (a = -1; ++a < i.length; ) {
		const c = i[a];
		c < l ||
			c >= u ||
			(c + 1 < u &&
				i[a + 1] === c + 1 &&
				s[c].after &&
				!s[c + 1].before &&
				!s[c + 1].after) ||
			(i[a - 1] === c - 1 &&
				s[c].before &&
				!s[c - 1].before &&
				!s[c - 1].after) ||
			(l !== c && o.push(eF(r.slice(l, c), "\\")),
			(l = c),
			/[!-/:-@[-`{-~]/.test(r.charAt(c)) &&
			(!n.encode || !n.encode.includes(r.charAt(c)))
				? o.push("\\")
				: (o.push(
						"&#x" +
							r.charCodeAt(c).toString(16).toUpperCase() +
							";",
					),
					l++));
	}
	return o.push(eF(r.slice(l, u), n.after)), o.join("");
}
function U5e(t, e) {
	return t - e;
}
function eF(t, e) {
	const n = /\\(?=[!-/:-@[-`{-~])/g,
		r = [],
		i = [],
		o = t + e;
	let s = -1,
		a = 0,
		l;
	for (; (l = n.exec(o)); ) r.push(l.index);
	for (; ++s < r.length; )
		a !== r[s] && i.push(t.slice(a, r[s])), i.push("\\"), (a = r[s]);
	return i.push(t.slice(a)), i.join("");
}
function H5e(t) {
	const e = t || {},
		n = e.now || {};
	let r = e.lineShift || 0,
		i = n.line || 1,
		o = n.column || 1;
	return { move: l, current: s, shift: a };
	function s() {
		return { now: { line: i, column: o }, lineShift: r };
	}
	function a(u) {
		r += u;
	}
	function l(u) {
		const c = u || "",
			d = c.split(/\r?\n|\r/g),
			f = d[d.length - 1];
		return (
			(i += d.length - 1),
			(o = d.length === 1 ? o + f.length : 1 + f.length + r),
			c
		);
	}
}
function YG(t, e = {}) {
	const n = {
		enter: i,
		indentLines: V5e,
		associationId: O5e,
		containerPhrasing: Y5e,
		containerFlow: J5e,
		createTracker: H5e,
		compilePattern: M5e,
		safe: X5e,
		stack: [],
		unsafe: [...R5e],
		join: [...P5e],
		handlers: { ...Z5 },
		options: {},
		indexStack: [],
		handle: void 0,
	};
	RG(n, e),
		n.options.tightDefinitions && n.join.push(G5e),
		(n.handle = t5e("type", {
			invalid: W5e,
			unknown: q5e,
			handlers: n.handlers,
		}));
	let r = n.handle(t, void 0, n, {
		before: `
`,
		after: `
`,
		now: { line: 1, column: 1 },
		lineShift: 0,
	});
	return (
		r &&
			r.charCodeAt(r.length - 1) !== 10 &&
			r.charCodeAt(r.length - 1) !== 13 &&
			(r += `
`),
		r
	);
	function i(o) {
		return n.stack.push(o), s;
		function s() {
			n.stack.pop();
		}
	}
}
function W5e(t) {
	throw new Error("Cannot handle value `" + t + "`, expected node");
}
function q5e(t) {
	const e = t;
	throw new Error("Cannot handle unknown node `" + e.type + "`");
}
function G5e(t, e) {
	if (t.type === "definition" && t.type === e.type) return 0;
}
function Y5e(t, e) {
	return j5e(t, this, e);
}
function J5e(t, e) {
	return _5e(t, this, e);
}
function X5e(t, e) {
	return K5e(this, t, e);
}
JG.peek = lAe;
function Z5e() {
	return {
		enter: {
			gfmFootnoteDefinition: eAe,
			gfmFootnoteDefinitionLabelString: tAe,
			gfmFootnoteCall: iAe,
			gfmFootnoteCallString: oAe,
		},
		exit: {
			gfmFootnoteDefinition: rAe,
			gfmFootnoteDefinitionLabelString: nAe,
			gfmFootnoteCall: aAe,
			gfmFootnoteCallString: sAe,
		},
	};
}
function Q5e() {
	return {
		unsafe: [
			{ character: "[", inConstruct: ["phrasing", "label", "reference"] },
		],
		handlers: { footnoteDefinition: uAe, footnoteReference: JG },
	};
}
function eAe(t) {
	this.enter(
		{ type: "footnoteDefinition", identifier: "", label: "", children: [] },
		t,
	);
}
function tAe() {
	this.buffer();
}
function nAe(t) {
	const e = this.resume(),
		n = this.stack[this.stack.length - 1];
	n.type,
		(n.label = e),
		(n.identifier = Ds(this.sliceSerialize(t)).toLowerCase());
}
function rAe(t) {
	this.exit(t);
}
function iAe(t) {
	this.enter({ type: "footnoteReference", identifier: "", label: "" }, t);
}
function oAe() {
	this.buffer();
}
function sAe(t) {
	const e = this.resume(),
		n = this.stack[this.stack.length - 1];
	n.type,
		(n.label = e),
		(n.identifier = Ds(this.sliceSerialize(t)).toLowerCase());
}
function aAe(t) {
	this.exit(t);
}
function JG(t, e, n, r) {
	const i = n.createTracker(r);
	let o = i.move("[^");
	const s = n.enter("footnoteReference"),
		a = n.enter("reference");
	return (
		(o += i.move(
			n.safe(n.associationId(t), {
				...i.current(),
				before: o,
				after: "]",
			}),
		)),
		a(),
		s(),
		(o += i.move("]")),
		o
	);
}
function lAe() {
	return "[";
}
function uAe(t, e, n, r) {
	const i = n.createTracker(r);
	let o = i.move("[^");
	const s = n.enter("footnoteDefinition"),
		a = n.enter("label");
	return (
		(o += i.move(
			n.safe(n.associationId(t), {
				...i.current(),
				before: o,
				after: "]",
			}),
		)),
		a(),
		(o += i.move("]:" + (t.children && t.children.length > 0 ? " " : ""))),
		i.shift(4),
		(o += i.move(n.indentLines(n.containerFlow(t, i.current()), cAe))),
		s(),
		o
	);
}
function cAe(t, e, n) {
	return e === 0 ? t : (n ? "" : "    ") + t;
}
function dAe(t, e = {}) {
	const n = (e.align || []).concat(),
		r = e.stringLength || hAe,
		i = [],
		o = [],
		s = [],
		a = [];
	let l = 0,
		u = -1;
	for (; ++u < t.length; ) {
		const p = [],
			g = [];
		let v = -1;
		for (t[u].length > l && (l = t[u].length); ++v < t[u].length; ) {
			const b = fAe(t[u][v]);
			if (e.alignDelimiters !== !1) {
				const y = r(b);
				(g[v] = y), (a[v] === void 0 || y > a[v]) && (a[v] = y);
			}
			p.push(b);
		}
		(o[u] = p), (s[u] = g);
	}
	let c = -1;
	if (typeof n == "object" && "length" in n)
		for (; ++c < l; ) i[c] = tF(n[c]);
	else {
		const p = tF(n);
		for (; ++c < l; ) i[c] = p;
	}
	c = -1;
	const d = [],
		f = [];
	for (; ++c < l; ) {
		const p = i[c];
		let g = "",
			v = "";
		p === 99
			? ((g = ":"), (v = ":"))
			: p === 108
				? (g = ":")
				: p === 114 && (v = ":");
		let b =
			e.alignDelimiters === !1
				? 1
				: Math.max(1, a[c] - g.length - v.length);
		const y = g + "-".repeat(b) + v;
		e.alignDelimiters !== !1 &&
			((b = g.length + b + v.length), b > a[c] && (a[c] = b), (f[c] = b)),
			(d[c] = y);
	}
	o.splice(1, 0, d), s.splice(1, 0, f), (u = -1);
	const h = [];
	for (; ++u < o.length; ) {
		const p = o[u],
			g = s[u];
		c = -1;
		const v = [];
		for (; ++c < l; ) {
			const b = p[c] || "";
			let y = "",
				x = "";
			if (e.alignDelimiters !== !1) {
				const C = a[c] - (g[c] || 0),
					k = i[c];
				k === 114
					? (y = " ".repeat(C))
					: k === 99
						? C % 2
							? ((y = " ".repeat(C / 2 + 0.5)),
								(x = " ".repeat(C / 2 - 0.5)))
							: ((y = " ".repeat(C / 2)), (x = y))
						: (x = " ".repeat(C));
			}
			e.delimiterStart !== !1 && !c && v.push("|"),
				e.padding !== !1 &&
					!(e.alignDelimiters === !1 && b === "") &&
					(e.delimiterStart !== !1 || c) &&
					v.push(" "),
				e.alignDelimiters !== !1 && v.push(y),
				v.push(b),
				e.alignDelimiters !== !1 && v.push(x),
				e.padding !== !1 && v.push(" "),
				(e.delimiterEnd !== !1 || c !== l - 1) && v.push("|");
		}
		h.push(
			e.delimiterEnd === !1 ? v.join("").replace(/ +$/, "") : v.join(""),
		);
	}
	return h.join(`
`);
}
function fAe(t) {
	return t == null ? "" : String(t);
}
function hAe(t) {
	return t.length;
}
function tF(t) {
	const e = typeof t == "string" ? t.codePointAt(0) : 0;
	return e === 67 || e === 99
		? 99
		: e === 76 || e === 108
			? 108
			: e === 82 || e === 114
				? 114
				: 0;
}
function pAe() {
	return {
		enter: { table: mAe, tableData: nF, tableHeader: nF, tableRow: bAe },
		exit: {
			codeText: vAe,
			table: gAe,
			tableData: yC,
			tableHeader: yC,
			tableRow: yC,
		},
	};
}
function mAe(t) {
	const e = t._align;
	this.enter(
		{
			type: "table",
			align: e.map(function (n) {
				return n === "none" ? null : n;
			}),
			children: [],
		},
		t,
	),
		(this.data.inTable = !0);
}
function gAe(t) {
	this.exit(t), (this.data.inTable = void 0);
}
function bAe(t) {
	this.enter({ type: "tableRow", children: [] }, t);
}
function yC(t) {
	this.exit(t);
}
function nF(t) {
	this.enter({ type: "tableCell", children: [] }, t);
}
function vAe(t) {
	let e = this.resume();
	this.data.inTable && (e = e.replace(/\\([\\|])/g, yAe));
	const n = this.stack[this.stack.length - 1];
	n.type, (n.value = e), this.exit(t);
}
function yAe(t, e) {
	return e === "|" ? e : t;
}
function xAe(t) {
	const e = {},
		n = e.tableCellPadding,
		r = e.tablePipeAlign,
		i = e.stringLength,
		o = n ? " " : "|";
	return {
		unsafe: [
			{ character: "\r", inConstruct: "tableCell" },
			{
				character: `
`,
				inConstruct: "tableCell",
			},
			{ atBreak: !0, character: "|", after: "[	 :-]" },
			{ character: "|", inConstruct: "tableCell" },
			{ atBreak: !0, character: ":", after: "-" },
			{ atBreak: !0, character: "-", after: "[:|-]" },
		],
		handlers: { inlineCode: f, table: s, tableCell: l, tableRow: a },
	};
	function s(h, p, g, v) {
		return u(c(h, g, v), h.align);
	}
	function a(h, p, g, v) {
		const b = d(h, g, v),
			y = u([b]);
		return y.slice(
			0,
			y.indexOf(`
`),
		);
	}
	function l(h, p, g, v) {
		const b = g.enter("tableCell"),
			y = g.enter("phrasing"),
			x = g.containerPhrasing(h, { ...v, before: o, after: o });
		return y(), b(), x;
	}
	function u(h, p) {
		return dAe(h, {
			align: p,
			alignDelimiters: r,
			padding: n,
			stringLength: i,
		});
	}
	function c(h, p, g) {
		const v = h.children;
		let b = -1;
		const y = [],
			x = p.enter("table");
		for (; ++b < v.length; ) y[b] = d(v[b], p, g);
		return x(), y;
	}
	function d(h, p, g) {
		const v = h.children;
		let b = -1;
		const y = [],
			x = p.enter("tableRow");
		for (; ++b < v.length; ) y[b] = l(v[b], h, p, g);
		return x(), y;
	}
	function f(h, p, g) {
		let v = Z5.inlineCode(h, p, g);
		return (
			g.stack.includes("tableCell") && (v = v.replace(/\|/g, "\\$&")), v
		);
	}
}
function kAe() {
	return {
		exit: {
			taskListCheckValueChecked: rF,
			taskListCheckValueUnchecked: rF,
			paragraph: wAe,
		},
	};
}
function CAe() {
	return {
		unsafe: [{ atBreak: !0, character: "-", after: "[:|-]" }],
		handlers: { listItem: EAe },
	};
}
function rF(t) {
	const e = this.stack[this.stack.length - 2];
	e.type, (e.checked = t.type === "taskListCheckValueChecked");
}
function wAe(t) {
	const e = this.stack[this.stack.length - 2];
	if (e && e.type === "listItem" && typeof e.checked == "boolean") {
		const n = this.stack[this.stack.length - 1];
		n.type;
		const r = n.children[0];
		if (r && r.type === "text") {
			const i = e.children;
			let o = -1,
				s;
			for (; ++o < i.length; ) {
				const a = i[o];
				if (a.type === "paragraph") {
					s = a;
					break;
				}
			}
			s === n &&
				((r.value = r.value.slice(1)),
				r.value.length === 0
					? n.children.shift()
					: n.position &&
						r.position &&
						typeof r.position.start.offset == "number" &&
						(r.position.start.column++,
						r.position.start.offset++,
						(n.position.start = Object.assign(
							{},
							r.position.start,
						))));
		}
	}
	this.exit(t);
}
function EAe(t, e, n, r) {
	const i = t.children[0],
		o = typeof t.checked == "boolean" && i && i.type === "paragraph",
		s = "[" + (t.checked ? "x" : " ") + "] ",
		a = n.createTracker(r);
	o && a.move(s);
	let l = Z5.listItem(t, e, n, { ...r, ...a.current() });
	return o && (l = l.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, u)), l;
	function u(c) {
		return c + s;
	}
}
function DAe() {
	return [fG(), Z5e(), wG(), pAe(), kAe()];
}
function XG(t) {
	return { extensions: [PDe(), Q5e(), tSe(), xAe(), CAe()] };
}
function SAe() {
	return {
		enter: { mdxFlowExpression: $Ae, mdxTextExpression: TAe },
		exit: {
			mdxFlowExpression: iF,
			mdxFlowExpressionChunk: oF,
			mdxTextExpression: iF,
			mdxTextExpressionChunk: oF,
		},
	};
}
function AAe() {
	return {
		handlers: { mdxFlowExpression: sF, mdxTextExpression: sF },
		unsafe: [
			{ character: "{", inConstruct: ["phrasing"] },
			{ atBreak: !0, character: "{" },
		],
	};
}
function $Ae(t) {
	this.enter({ type: "mdxFlowExpression", value: "" }, t), this.buffer();
}
function TAe(t) {
	this.enter({ type: "mdxTextExpression", value: "" }, t), this.buffer();
}
function iF(t) {
	const e = this.resume(),
		n = t.estree,
		r = this.stack[this.stack.length - 1];
	r.type === "mdxFlowExpression" || r.type,
		this.exit(t),
		(r.value = e),
		n && (r.data = { estree: n });
}
function oF(t) {
	this.config.enter.data.call(this, t), this.config.exit.data.call(this, t);
}
function sF(t, e, n) {
	const r = t.value || "";
	return (
		"{" +
		n.indentLines(r, function (o, s, a) {
			return (s === 0 || a ? "" : "  ") + o;
		}) +
		"}"
	);
}
const BAe = [
		"AElig",
		"AMP",
		"Aacute",
		"Acirc",
		"Agrave",
		"Aring",
		"Atilde",
		"Auml",
		"COPY",
		"Ccedil",
		"ETH",
		"Eacute",
		"Ecirc",
		"Egrave",
		"Euml",
		"GT",
		"Iacute",
		"Icirc",
		"Igrave",
		"Iuml",
		"LT",
		"Ntilde",
		"Oacute",
		"Ocirc",
		"Ograve",
		"Oslash",
		"Otilde",
		"Ouml",
		"QUOT",
		"REG",
		"THORN",
		"Uacute",
		"Ucirc",
		"Ugrave",
		"Uuml",
		"Yacute",
		"aacute",
		"acirc",
		"acute",
		"aelig",
		"agrave",
		"amp",
		"aring",
		"atilde",
		"auml",
		"brvbar",
		"ccedil",
		"cedil",
		"cent",
		"copy",
		"curren",
		"deg",
		"divide",
		"eacute",
		"ecirc",
		"egrave",
		"eth",
		"euml",
		"frac12",
		"frac14",
		"frac34",
		"gt",
		"iacute",
		"icirc",
		"iexcl",
		"igrave",
		"iquest",
		"iuml",
		"laquo",
		"lt",
		"macr",
		"micro",
		"middot",
		"nbsp",
		"not",
		"ntilde",
		"oacute",
		"ocirc",
		"ograve",
		"ordf",
		"ordm",
		"oslash",
		"otilde",
		"ouml",
		"para",
		"plusmn",
		"pound",
		"quot",
		"raquo",
		"reg",
		"sect",
		"shy",
		"sup1",
		"sup2",
		"sup3",
		"szlig",
		"thorn",
		"times",
		"uacute",
		"ucirc",
		"ugrave",
		"uml",
		"uuml",
		"yacute",
		"yen",
		"yuml",
	],
	aF = {
		0: "�",
		128: "€",
		130: "‚",
		131: "ƒ",
		132: "„",
		133: "…",
		134: "†",
		135: "‡",
		136: "ˆ",
		137: "‰",
		138: "Š",
		139: "‹",
		140: "Œ",
		142: "Ž",
		145: "‘",
		146: "’",
		147: "“",
		148: "”",
		149: "•",
		150: "–",
		151: "—",
		152: "˜",
		153: "™",
		154: "š",
		155: "›",
		156: "œ",
		158: "ž",
		159: "Ÿ",
	};
function ZG(t) {
	const e = typeof t == "string" ? t.charCodeAt(0) : t;
	return e >= 48 && e <= 57;
}
function IAe(t) {
	const e = typeof t == "string" ? t.charCodeAt(0) : t;
	return (
		(e >= 97 && e <= 102) || (e >= 65 && e <= 70) || (e >= 48 && e <= 57)
	);
}
function FAe(t) {
	const e = typeof t == "string" ? t.charCodeAt(0) : t;
	return (e >= 97 && e <= 122) || (e >= 65 && e <= 90);
}
function lF(t) {
	return FAe(t) || ZG(t);
}
const xf = String.fromCharCode,
	PAe = [
		"",
		"Named character references must be terminated by a semicolon",
		"Numeric character references must be terminated by a semicolon",
		"Named character references cannot be empty",
		"Numeric character references cannot be empty",
		"Named character references must be known",
		"Numeric character references cannot be disallowed",
		"Numeric character references cannot be outside the permissible Unicode range",
	];
function NAe(t, e = {}) {
	const n =
			typeof e.additional == "string"
				? e.additional.charCodeAt(0)
				: e.additional,
		r = [];
	let i = 0,
		o = -1,
		s = "",
		a,
		l;
	e.position &&
		("start" in e.position || "indent" in e.position
			? ((l = e.position.indent), (a = e.position.start))
			: (a = e.position));
	let u = (a ? a.line : 0) || 1,
		c = (a ? a.column : 0) || 1,
		d = h(),
		f;
	for (i--; ++i <= t.length; )
		if (
			(f === 10 && (c = (l ? l[o] : 0) || 1),
			(f = t.charCodeAt(i)),
			f === 38)
		) {
			const v = t.charCodeAt(i + 1);
			if (
				v === 9 ||
				v === 10 ||
				v === 12 ||
				v === 32 ||
				v === 38 ||
				v === 60 ||
				Number.isNaN(v) ||
				(n && v === n)
			) {
				(s += xf(f)), c++;
				continue;
			}
			const b = i + 1;
			let y = b,
				x = b,
				C;
			if (v === 35) {
				x = ++y;
				const I = t.charCodeAt(x);
				I === 88 || I === 120
					? ((C = "hexadecimal"), (x = ++y))
					: (C = "decimal");
			} else C = "named";
			let k = "",
				w = "",
				D = "";
			const S = C === "named" ? lF : C === "decimal" ? ZG : IAe;
			for (x--; ++x <= t.length; ) {
				const I = t.charCodeAt(x);
				if (!S(I)) break;
				(D += xf(I)),
					C === "named" && BAe.includes(D) && ((k = D), (w = Og(D)));
			}
			let $ = t.charCodeAt(x) === 59;
			if ($) {
				x++;
				const I = C === "named" ? Og(D) : !1;
				I && ((k = D), (w = I));
			}
			let A = 1 + x - b,
				T = "";
			if (!(!$ && e.nonTerminated === !1))
				if (!D) C !== "named" && p(4, A);
				else if (C === "named") {
					if ($ && !w) p(5, 1);
					else if (
						(k !== D &&
							((x = y + k.length), (A = 1 + x - y), ($ = !1)),
						!$)
					) {
						const I = k ? 1 : 3;
						if (e.attribute) {
							const F = t.charCodeAt(x);
							F === 61
								? (p(I, A), (w = ""))
								: lF(F)
									? (w = "")
									: p(I, A);
						} else p(I, A);
					}
					T = w;
				} else {
					$ || p(2, A);
					let I = Number.parseInt(D, C === "hexadecimal" ? 16 : 10);
					if (RAe(I)) p(7, A), (T = xf(65533));
					else if (I in aF) p(6, A), (T = aF[I]);
					else {
						let F = "";
						OAe(I) && p(6, A),
							I > 65535 &&
								((I -= 65536),
								(F += xf((I >>> 10) | 55296)),
								(I = 56320 | (I & 1023))),
							(T = F + xf(I));
					}
				}
			if (T) {
				g(), (d = h()), (i = x - 1), (c += x - b + 1), r.push(T);
				const I = h();
				I.offset++,
					e.reference &&
						e.reference.call(
							e.referenceContext,
							T,
							{ start: d, end: I },
							t.slice(b - 1, x),
						),
					(d = I);
			} else
				(D = t.slice(b - 1, x)), (s += D), (c += D.length), (i = x - 1);
		} else
			f === 10 && (u++, o++, (c = 0)),
				Number.isNaN(f) ? g() : ((s += xf(f)), c++);
	return r.join("");
	function h() {
		return { line: u, column: c, offset: i + ((a ? a.offset : 0) || 0) };
	}
	function p(v, b) {
		let y;
		e.warning &&
			((y = h()),
			(y.column += b),
			(y.offset += b),
			e.warning.call(e.warningContext, PAe[v], y, v));
	}
	function g() {
		s &&
			(r.push(s),
			e.text && e.text.call(e.textContext, s, { start: d, end: h() }),
			(s = ""));
	}
}
function RAe(t) {
	return (t >= 55296 && t <= 57343) || t > 1114111;
}
function OAe(t) {
	return (
		(t >= 1 && t <= 8) ||
		t === 11 ||
		(t >= 13 && t <= 31) ||
		(t >= 127 && t <= 159) ||
		(t >= 64976 && t <= 65007) ||
		(t & 65535) === 65535 ||
		(t & 65535) === 65534
	);
}
const MAe = /["&'<>`]/g,
	jAe = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g,
	_Ae = /[\x01-\t\v\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g,
	zAe = /[|\\{}()[\]^$+*?.]/g,
	uF = new WeakMap();
function LAe(t, e) {
	if (
		((t = t.replace(e.subset ? VAe(e.subset) : MAe, r)),
		e.subset || e.escapeOnly)
	)
		return t;
	return t.replace(jAe, n).replace(_Ae, r);
	function n(i, o, s) {
		return e.format(
			(i.charCodeAt(0) - 55296) * 1024 + i.charCodeAt(1) - 56320 + 65536,
			s.charCodeAt(o + 2),
			e,
		);
	}
	function r(i, o, s) {
		return e.format(i.charCodeAt(0), s.charCodeAt(o + 1), e);
	}
}
function VAe(t) {
	let e = uF.get(t);
	return e || ((e = KAe(t)), uF.set(t, e)), e;
}
function KAe(t) {
	const e = [];
	let n = -1;
	for (; ++n < t.length; ) e.push(t[n].replace(zAe, "\\$&"));
	return new RegExp("(?:" + e.join("|") + ")", "g");
}
function UAe(t) {
	return "&#x" + t.toString(16).toUpperCase() + ";";
}
function HAe(t, e) {
	return LAe(t, Object.assign({ format: UAe }, e));
}
function Y1(t) {
	return !t || typeof t != "object"
		? ""
		: "position" in t || "type" in t
			? cF(t.position)
			: "start" in t || "end" in t
				? cF(t)
				: "line" in t || "column" in t
					? pE(t)
					: "";
}
function pE(t) {
	return dF(t && t.line) + ":" + dF(t && t.column);
}
function cF(t) {
	return pE(t && t.start) + "-" + pE(t && t.end);
}
function dF(t) {
	return t && typeof t == "number" ? t : 1;
}
function WAe(t) {
	return !t || typeof t != "object"
		? ""
		: "position" in t || "type" in t
			? fF(t.position)
			: "start" in t || "end" in t
				? fF(t)
				: "line" in t || "column" in t
					? mE(t)
					: "";
}
function mE(t) {
	return hF(t && t.line) + ":" + hF(t && t.column);
}
function fF(t) {
	return mE(t && t.start) + "-" + mE(t && t.end);
}
function hF(t) {
	return t && typeof t == "number" ? t : 1;
}
class _t extends Error {
	constructor(e, n, r) {
		super(), typeof n == "string" && ((r = n), (n = void 0));
		let i = "",
			o = {},
			s = !1;
		if (
			(n &&
				("line" in n && "column" in n
					? (o = { place: n })
					: "start" in n && "end" in n
						? (o = { place: n })
						: "type" in n
							? (o = { ancestors: [n], place: n.position })
							: (o = { ...n })),
			typeof e == "string"
				? (i = e)
				: !o.cause && e && ((s = !0), (i = e.message), (o.cause = e)),
			!o.ruleId && !o.source && typeof r == "string")
		) {
			const l = r.indexOf(":");
			l === -1
				? (o.ruleId = r)
				: ((o.source = r.slice(0, l)), (o.ruleId = r.slice(l + 1)));
		}
		if (!o.place && o.ancestors && o.ancestors) {
			const l = o.ancestors[o.ancestors.length - 1];
			l && (o.place = l.position);
		}
		const a = o.place && "start" in o.place ? o.place.start : o.place;
		(this.ancestors = o.ancestors || void 0),
			(this.cause = o.cause || void 0),
			(this.column = a ? a.column : void 0),
			(this.fatal = void 0),
			this.file,
			(this.message = i),
			(this.line = a ? a.line : void 0),
			(this.name = WAe(o.place) || "1:1"),
			(this.place = o.place || void 0),
			(this.reason = this.message),
			(this.ruleId = o.ruleId || void 0),
			(this.source = o.source || void 0),
			(this.stack =
				s && o.cause && typeof o.cause.stack == "string"
					? o.cause.stack
					: ""),
			this.actual,
			this.expected,
			this.note,
			this.url;
	}
}
_t.prototype.file = "";
_t.prototype.name = "";
_t.prototype.reason = "";
_t.prototype.message = "";
_t.prototype.stack = "";
_t.prototype.column = void 0;
_t.prototype.line = void 0;
_t.prototype.ancestors = void 0;
_t.prototype.cause = void 0;
_t.prototype.fatal = void 0;
_t.prototype.place = void 0;
_t.prototype.ruleId = void 0;
_t.prototype.source = void 0;
const QG = "  ";
function qAe() {
	return {
		canContainEols: ["mdxJsxTextElement"],
		enter: {
			mdxJsxFlowTag: r,
			mdxJsxFlowTagClosingMarker: i,
			mdxJsxFlowTagAttribute: d,
			mdxJsxFlowTagExpressionAttribute: f,
			mdxJsxFlowTagAttributeValueLiteral: t,
			mdxJsxFlowTagAttributeValueExpression: t,
			mdxJsxFlowTagSelfClosingMarker: s,
			mdxJsxTextTag: r,
			mdxJsxTextTagClosingMarker: i,
			mdxJsxTextTagAttribute: d,
			mdxJsxTextTagExpressionAttribute: f,
			mdxJsxTextTagAttributeValueLiteral: t,
			mdxJsxTextTagAttributeValueExpression: t,
			mdxJsxTextTagSelfClosingMarker: s,
		},
		exit: {
			mdxJsxFlowTagClosingMarker: a,
			mdxJsxFlowTagNamePrimary: l,
			mdxJsxFlowTagNameMember: u,
			mdxJsxFlowTagNameLocal: c,
			mdxJsxFlowTagExpressionAttribute: h,
			mdxJsxFlowTagExpressionAttributeValue: n,
			mdxJsxFlowTagAttributeNamePrimary: p,
			mdxJsxFlowTagAttributeNameLocal: g,
			mdxJsxFlowTagAttributeValueLiteral: v,
			mdxJsxFlowTagAttributeValueLiteralValue: n,
			mdxJsxFlowTagAttributeValueExpression: b,
			mdxJsxFlowTagAttributeValueExpressionValue: n,
			mdxJsxFlowTagSelfClosingMarker: y,
			mdxJsxFlowTag: x,
			mdxJsxTextTagClosingMarker: a,
			mdxJsxTextTagNamePrimary: l,
			mdxJsxTextTagNameMember: u,
			mdxJsxTextTagNameLocal: c,
			mdxJsxTextTagExpressionAttribute: h,
			mdxJsxTextTagExpressionAttributeValue: n,
			mdxJsxTextTagAttributeNamePrimary: p,
			mdxJsxTextTagAttributeNameLocal: g,
			mdxJsxTextTagAttributeValueLiteral: v,
			mdxJsxTextTagAttributeValueLiteralValue: n,
			mdxJsxTextTagAttributeValueExpression: b,
			mdxJsxTextTagAttributeValueExpressionValue: n,
			mdxJsxTextTagSelfClosingMarker: y,
			mdxJsxTextTag: x,
		},
	};
	function t() {
		this.buffer();
	}
	function e(D) {
		return { line: D.line, column: D.column, offset: D.offset };
	}
	function n(D) {
		this.config.enter.data.call(this, D),
			this.config.exit.data.call(this, D);
	}
	function r(D) {
		const S = {
			name: void 0,
			attributes: [],
			close: !1,
			selfClosing: !1,
			start: D.start,
			end: D.end,
		};
		this.data.mdxJsxTagStack || (this.data.mdxJsxTagStack = []),
			(this.data.mdxJsxTag = S),
			this.buffer();
	}
	function i(D) {
		if (this.data.mdxJsxTagStack.length === 0)
			throw new _t(
				"Unexpected closing slash `/` in tag, expected an open tag first",
				{ start: D.start, end: D.end },
				"mdast-util-mdx-jsx:unexpected-closing-slash",
			);
	}
	function o(D) {
		if (this.data.mdxJsxTag.close)
			throw new _t(
				"Unexpected attribute in closing tag, expected the end of the tag",
				{ start: D.start, end: D.end },
				"mdast-util-mdx-jsx:unexpected-attribute",
			);
	}
	function s(D) {
		if (this.data.mdxJsxTag.close)
			throw new _t(
				"Unexpected self-closing slash `/` in closing tag, expected the end of the tag",
				{ start: D.start, end: D.end },
				"mdast-util-mdx-jsx:unexpected-self-closing-slash",
			);
	}
	function a() {
		const D = this.data.mdxJsxTag;
		D.close = !0;
	}
	function l(D) {
		const S = this.data.mdxJsxTag;
		S.name = this.sliceSerialize(D);
	}
	function u(D) {
		const S = this.data.mdxJsxTag;
		S.name += "." + this.sliceSerialize(D);
	}
	function c(D) {
		const S = this.data.mdxJsxTag;
		S.name += ":" + this.sliceSerialize(D);
	}
	function d(D) {
		const S = this.data.mdxJsxTag;
		o.call(this, D),
			S.attributes.push({
				type: "mdxJsxAttribute",
				name: "",
				value: null,
				position: { start: e(D.start), end: void 0 },
			});
	}
	function f(D) {
		const S = this.data.mdxJsxTag;
		o.call(this, D),
			S.attributes.push({ type: "mdxJsxExpressionAttribute", value: "" }),
			this.buffer();
	}
	function h(D) {
		const S = this.data.mdxJsxTag,
			$ = S.attributes[S.attributes.length - 1];
		$.type;
		const A = D.estree;
		($.value = this.resume()), A && ($.data = { estree: A });
	}
	function p(D) {
		const S = this.data.mdxJsxTag,
			$ = S.attributes[S.attributes.length - 1];
		$.type,
			($.name = this.sliceSerialize(D)),
			$.position,
			($.position.end = e(D.end));
	}
	function g(D) {
		const S = this.data.mdxJsxTag,
			$ = S.attributes[S.attributes.length - 1];
		$.type,
			($.name += ":" + this.sliceSerialize(D)),
			$.position,
			($.position.end = e(D.end));
	}
	function v(D) {
		const S = this.data.mdxJsxTag,
			$ = S.attributes[S.attributes.length - 1];
		($.value = NAe(this.resume(), { nonTerminated: !1 })),
			$.position,
			($.position.end = e(D.end));
	}
	function b(D) {
		const S = this.data.mdxJsxTag,
			$ = S.attributes[S.attributes.length - 1];
		$.type;
		const A = {
				type: "mdxJsxAttributeValueExpression",
				value: this.resume(),
			},
			T = D.estree;
		T && (A.data = { estree: T }),
			($.value = A),
			$.position,
			($.position.end = e(D.end));
	}
	function y() {
		const D = this.data.mdxJsxTag;
		D.selfClosing = !0;
	}
	function x(D) {
		const S = this.data.mdxJsxTag,
			$ = this.data.mdxJsxTagStack,
			A = $[$.length - 1];
		if (S.close && A.name !== S.name)
			throw new _t(
				"Unexpected closing tag `" +
					w(S) +
					"`, expected corresponding closing tag for `" +
					w(A) +
					"` (" +
					Y1(A) +
					")",
				{ start: D.start, end: D.end },
				"mdast-util-mdx-jsx:end-tag-mismatch",
			);
		this.resume(),
			S.close
				? $.pop()
				: this.enter(
						{
							type:
								D.type === "mdxJsxTextTag"
									? "mdxJsxTextElement"
									: "mdxJsxFlowElement",
							name: S.name || null,
							attributes: S.attributes,
							children: [],
						},
						D,
						C,
					),
			S.selfClosing || S.close ? this.exit(D, k) : $.push(S);
	}
	function C(D, S) {
		const $ = this.data.mdxJsxTagStack,
			A = $[$.length - 1],
			T = D ? " before the end of `" + D.type + "`" : "",
			I = D ? { start: D.start, end: D.end } : void 0;
		throw new _t(
			"Expected a closing tag for `" +
				w(A) +
				"` (" +
				Y1({ start: S.start, end: S.end }) +
				")" +
				T,
			I,
			"mdast-util-mdx-jsx:end-tag-mismatch",
		);
	}
	function k(D, S) {
		const $ = this.data.mdxJsxTag;
		throw new _t(
			"Expected the closing tag `" +
				w($) +
				"` either after the end of `" +
				S.type +
				"` (" +
				Y1(S.end) +
				") or another opening tag after the start of `" +
				S.type +
				"` (" +
				Y1(S.start) +
				")",
			{ start: D.start, end: D.end },
			"mdast-util-mdx-jsx:end-tag-mismatch",
		);
	}
	function w(D) {
		return "<" + (D.close ? "/" : "") + (D.name || "") + ">";
	}
}
function GAe(t) {
	const e = {},
		n = e.quote || '"',
		r = e.quoteSmart || !1,
		i = e.tightSelfClosing || !1,
		o = e.printWidth || Number.POSITIVE_INFINITY,
		s = n === '"' ? "'" : '"';
	if (n !== '"' && n !== "'")
		throw new Error(
			"Cannot serialize attribute values with `" +
				n +
				"` for `options.quote`, expected `\"`, or `'`",
		);
	return (
		(a.peek = JAe),
		{
			handlers: { mdxJsxFlowElement: a, mdxJsxTextElement: a },
			unsafe: [
				{ character: "<", inConstruct: ["phrasing"] },
				{ atBreak: !0, character: "<" },
			],
			fences: !0,
			resourceLink: !0,
		}
	);
	function a(l, u, c, d) {
		const f = l.type === "mdxJsxFlowElement",
			h = l.name ? !l.children || l.children.length === 0 : !1,
			p = eY(c),
			g = tY(p),
			v = c.createTracker(d),
			b = c.createTracker(d),
			y = [],
			x = (f ? g : "") + "<" + (l.name || ""),
			C = c.enter(l.type);
		if ((v.move(x), b.move(x), l.attributes && l.attributes.length > 0)) {
			if (!l.name)
				throw new Error("Cannot serialize fragment w/ attributes");
			let $ = -1;
			for (; ++$ < l.attributes.length; ) {
				const A = l.attributes[$];
				let T;
				if (A.type === "mdxJsxExpressionAttribute")
					T = "{" + (A.value || "") + "}";
				else {
					if (!A.name)
						throw new Error("Cannot serialize attribute w/o name");
					const I = A.value,
						F = A.name;
					let N = "";
					if (I != null)
						if (typeof I == "object")
							N = "{" + (I.value || "") + "}";
						else {
							const O = r && Fy(I, n) > Fy(I, s) ? s : n;
							N = O + HAe(I, { subset: [O] }) + O;
						}
					T = F + (N ? "=" : "") + N;
				}
				y.push(T);
			}
		}
		let k = !1;
		const w = y.join(" ");
		f &&
			(/\r?\n|\r/.test(w) ||
				v.current().now.column + w.length + (h ? (i ? 2 : 3) : 1) >
					o) &&
			(k = !0);
		let D = v,
			S = x;
		if (k) {
			D = b;
			let $ = -1;
			for (; ++$ < y.length; ) y[$] = g + QG + y[$];
			S += D.move(
				`
` +
					y.join(`
`) +
					`
` +
					g,
			);
		} else w && (S += D.move(" " + w));
		return (
			h && (S += D.move((i || k ? "" : " ") + "/")),
			(S += D.move(">")),
			l.children &&
				l.children.length > 0 &&
				(l.type === "mdxJsxTextElement"
					? (S += D.move(
							c.containerPhrasing(l, {
								...D.current(),
								before: ">",
								after: "<",
							}),
						))
					: (D.shift(2),
						(S += D.move(`
`)),
						(S += D.move(YAe(l, c, D.current()))),
						(S += D.move(`
`)))),
			h || (S += D.move((f ? g : "") + "</" + (l.name || "") + ">")),
			C(),
			S
		);
	}
}
function YAe(t, e, n) {
	const r = e.indexStack,
		i = t.children,
		o = e.createTracker(n),
		s = tY(eY(e)),
		a = [];
	let l = -1;
	for (r.push(-1); ++l < i.length; ) {
		const u = i[l];
		r[r.length - 1] = l;
		const c = {
				before: `
`,
				after: `
`,
				...o.current(),
			},
			d = e.handle(u, t, e, c),
			f =
				u.type === "mdxJsxFlowElement"
					? d
					: e.indentLines(d, function (h, p, g) {
							return (g ? "" : s) + h;
						});
		a.push(o.move(f)),
			u.type !== "list" && (e.bulletLastUsed = void 0),
			l < i.length - 1 &&
				a.push(
					o.move(`

`),
				);
	}
	return r.pop(), a.join("");
}
function eY(t) {
	let e = 0,
		n = t.stack.length;
	for (; --n > -1; ) {
		const r = t.stack[n];
		if (r === "blockquote" || r === "listItem") break;
		r === "mdxJsxFlowElement" && e++;
	}
	return e;
}
function tY(t) {
	return QG.repeat(t);
}
function JAe() {
	return "<";
}
function XAe() {
	return {
		enter: { mdxjsEsm: QAe },
		exit: { mdxjsEsm: e6e, mdxjsEsmData: t6e },
	};
}
function ZAe() {
	return { handlers: { mdxjsEsm: n6e } };
}
function QAe(t) {
	this.enter({ type: "mdxjsEsm", value: "" }, t), this.buffer();
}
function e6e(t) {
	const e = this.resume(),
		n = this.stack[this.stack.length - 1];
	n.type, this.exit(t);
	const r = t.estree;
	(n.value = e), r && (n.data = { estree: r });
}
function t6e(t) {
	this.config.enter.data.call(this, t), this.config.exit.data.call(this, t);
}
function n6e(t) {
	return t.value || "";
}
function r6e() {
	return [SAe(), qAe(), XAe()];
}
function nY(t) {
	return { extensions: [AAe(), GAe(), ZAe()] };
}
const i6e = { tokenize: f6e, partial: !0 };
function o6e() {
	return {
		document: {
			91: {
				name: "gfmFootnoteDefinition",
				tokenize: u6e,
				continuation: { tokenize: c6e },
				exit: d6e,
			},
		},
		text: {
			91: { name: "gfmFootnoteCall", tokenize: l6e },
			93: {
				name: "gfmPotentialFootnoteCall",
				add: "after",
				tokenize: s6e,
				resolveTo: a6e,
			},
		},
	};
}
function s6e(t, e, n) {
	const r = this;
	let i = r.events.length;
	const o = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
	let s;
	for (; i--; ) {
		const l = r.events[i][1];
		if (l.type === "labelImage") {
			s = l;
			break;
		}
		if (
			l.type === "gfmFootnoteCall" ||
			l.type === "labelLink" ||
			l.type === "label" ||
			l.type === "image" ||
			l.type === "link"
		)
			break;
	}
	return a;
	function a(l) {
		if (!s || !s._balanced) return n(l);
		const u = Ds(r.sliceSerialize({ start: s.end, end: r.now() }));
		return u.codePointAt(0) !== 94 || !o.includes(u.slice(1))
			? n(l)
			: (t.enter("gfmFootnoteCallLabelMarker"),
				t.consume(l),
				t.exit("gfmFootnoteCallLabelMarker"),
				e(l));
	}
}
function a6e(t, e) {
	let n = t.length;
	for (; n--; )
		if (t[n][1].type === "labelImage" && t[n][0] === "enter") {
			t[n][1];
			break;
		}
	(t[n + 1][1].type = "data"),
		(t[n + 3][1].type = "gfmFootnoteCallLabelMarker");
	const r = {
			type: "gfmFootnoteCall",
			start: Object.assign({}, t[n + 3][1].start),
			end: Object.assign({}, t[t.length - 1][1].end),
		},
		i = {
			type: "gfmFootnoteCallMarker",
			start: Object.assign({}, t[n + 3][1].end),
			end: Object.assign({}, t[n + 3][1].end),
		};
	i.end.column++, i.end.offset++, i.end._bufferIndex++;
	const o = {
			type: "gfmFootnoteCallString",
			start: Object.assign({}, i.end),
			end: Object.assign({}, t[t.length - 1][1].start),
		},
		s = {
			type: "chunkString",
			contentType: "string",
			start: Object.assign({}, o.start),
			end: Object.assign({}, o.end),
		},
		a = [
			t[n + 1],
			t[n + 2],
			["enter", r, e],
			t[n + 3],
			t[n + 4],
			["enter", i, e],
			["exit", i, e],
			["enter", o, e],
			["enter", s, e],
			["exit", s, e],
			["exit", o, e],
			t[t.length - 2],
			t[t.length - 1],
			["exit", r, e],
		];
	return t.splice(n, t.length - n + 1, ...a), t;
}
function l6e(t, e, n) {
	const r = this,
		i = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
	let o = 0,
		s;
	return a;
	function a(d) {
		return (
			t.enter("gfmFootnoteCall"),
			t.enter("gfmFootnoteCallLabelMarker"),
			t.consume(d),
			t.exit("gfmFootnoteCallLabelMarker"),
			l
		);
	}
	function l(d) {
		return d !== 94
			? n(d)
			: (t.enter("gfmFootnoteCallMarker"),
				t.consume(d),
				t.exit("gfmFootnoteCallMarker"),
				t.enter("gfmFootnoteCallString"),
				(t.enter("chunkString").contentType = "string"),
				u);
	}
	function u(d) {
		if (o > 999 || (d === 93 && !s) || d === null || d === 91 || It(d))
			return n(d);
		if (d === 93) {
			t.exit("chunkString");
			const f = t.exit("gfmFootnoteCallString");
			return i.includes(Ds(r.sliceSerialize(f)))
				? (t.enter("gfmFootnoteCallLabelMarker"),
					t.consume(d),
					t.exit("gfmFootnoteCallLabelMarker"),
					t.exit("gfmFootnoteCall"),
					e)
				: n(d);
		}
		return It(d) || (s = !0), o++, t.consume(d), d === 92 ? c : u;
	}
	function c(d) {
		return d === 91 || d === 92 || d === 93 ? (t.consume(d), o++, u) : u(d);
	}
}
function u6e(t, e, n) {
	const r = this,
		i = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
	let o,
		s = 0,
		a;
	return l;
	function l(p) {
		return (
			(t.enter("gfmFootnoteDefinition")._container = !0),
			t.enter("gfmFootnoteDefinitionLabel"),
			t.enter("gfmFootnoteDefinitionLabelMarker"),
			t.consume(p),
			t.exit("gfmFootnoteDefinitionLabelMarker"),
			u
		);
	}
	function u(p) {
		return p === 94
			? (t.enter("gfmFootnoteDefinitionMarker"),
				t.consume(p),
				t.exit("gfmFootnoteDefinitionMarker"),
				t.enter("gfmFootnoteDefinitionLabelString"),
				(t.enter("chunkString").contentType = "string"),
				c)
			: n(p);
	}
	function c(p) {
		if (s > 999 || (p === 93 && !a) || p === null || p === 91 || It(p))
			return n(p);
		if (p === 93) {
			t.exit("chunkString");
			const g = t.exit("gfmFootnoteDefinitionLabelString");
			return (
				(o = Ds(r.sliceSerialize(g))),
				t.enter("gfmFootnoteDefinitionLabelMarker"),
				t.consume(p),
				t.exit("gfmFootnoteDefinitionLabelMarker"),
				t.exit("gfmFootnoteDefinitionLabel"),
				f
			);
		}
		return It(p) || (a = !0), s++, t.consume(p), p === 92 ? d : c;
	}
	function d(p) {
		return p === 91 || p === 92 || p === 93 ? (t.consume(p), s++, c) : c(p);
	}
	function f(p) {
		return p === 58
			? (t.enter("definitionMarker"),
				t.consume(p),
				t.exit("definitionMarker"),
				i.includes(o) || i.push(o),
				At(t, h, "gfmFootnoteDefinitionWhitespace"))
			: n(p);
	}
	function h(p) {
		return e(p);
	}
}
function c6e(t, e, n) {
	return t.check(mp, e, t.attempt(i6e, e, n));
}
function d6e(t) {
	t.exit("gfmFootnoteDefinition");
}
function f6e(t, e, n) {
	const r = this;
	return At(t, i, "gfmFootnoteDefinitionIndent", 5);
	function i(o) {
		const s = r.events[r.events.length - 1];
		return s &&
			s[1].type === "gfmFootnoteDefinitionIndent" &&
			s[2].sliceSerialize(s[1], !0).length === 4
			? e(o)
			: n(o);
	}
}
class h6e {
	constructor() {
		this.map = [];
	}
	add(e, n, r) {
		p6e(this, e, n, r);
	}
	consume(e) {
		if (
			(this.map.sort(function (o, s) {
				return o[0] - s[0];
			}),
			this.map.length === 0)
		)
			return;
		let n = this.map.length;
		const r = [];
		for (; n > 0; )
			(n -= 1),
				r.push(
					e.slice(this.map[n][0] + this.map[n][1]),
					this.map[n][2],
				),
				(e.length = this.map[n][0]);
		r.push([...e]), (e.length = 0);
		let i = r.pop();
		for (; i; ) e.push(...i), (i = r.pop());
		this.map.length = 0;
	}
}
function p6e(t, e, n, r) {
	let i = 0;
	if (!(n === 0 && r.length === 0)) {
		for (; i < t.map.length; ) {
			if (t.map[i][0] === e) {
				(t.map[i][1] += n), t.map[i][2].push(...r);
				return;
			}
			i += 1;
		}
		t.map.push([e, n, r]);
	}
}
function m6e(t, e) {
	let n = !1;
	const r = [];
	for (; e < t.length; ) {
		const i = t[e];
		if (n) {
			if (i[0] === "enter")
				i[1].type === "tableContent" &&
					r.push(
						t[e + 1][1].type === "tableDelimiterMarker"
							? "left"
							: "none",
					);
			else if (i[1].type === "tableContent") {
				if (t[e - 1][1].type === "tableDelimiterMarker") {
					const o = r.length - 1;
					r[o] = r[o] === "left" ? "center" : "right";
				}
			} else if (i[1].type === "tableDelimiterRow") break;
		} else
			i[0] === "enter" && i[1].type === "tableDelimiterRow" && (n = !0);
		e += 1;
	}
	return r;
}
function g6e() {
	return {
		flow: { null: { name: "table", tokenize: b6e, resolveAll: v6e } },
	};
}
function b6e(t, e, n) {
	const r = this;
	let i = 0,
		o = 0,
		s;
	return a;
	function a(A) {
		let T = r.events.length - 1;
		for (; T > -1; ) {
			const N = r.events[T][1].type;
			if (N === "lineEnding" || N === "linePrefix") T--;
			else break;
		}
		const I = T > -1 ? r.events[T][1].type : null,
			F = I === "tableHead" || I === "tableRow" ? w : l;
		return F === w && r.parser.lazy[r.now().line] ? n(A) : F(A);
	}
	function l(A) {
		return t.enter("tableHead"), t.enter("tableRow"), u(A);
	}
	function u(A) {
		return A === 124 || ((s = !0), (o += 1)), c(A);
	}
	function c(A) {
		return A === null
			? n(A)
			: He(A)
				? o > 1
					? ((o = 0),
						(r.interrupt = !0),
						t.exit("tableRow"),
						t.enter("lineEnding"),
						t.consume(A),
						t.exit("lineEnding"),
						h)
					: n(A)
				: xt(A)
					? At(t, c, "whitespace")(A)
					: ((o += 1),
						s && ((s = !1), (i += 1)),
						A === 124
							? (t.enter("tableCellDivider"),
								t.consume(A),
								t.exit("tableCellDivider"),
								(s = !0),
								c)
							: (t.enter("data"), d(A)));
	}
	function d(A) {
		return A === null || A === 124 || It(A)
			? (t.exit("data"), c(A))
			: (t.consume(A), A === 92 ? f : d);
	}
	function f(A) {
		return A === 92 || A === 124 ? (t.consume(A), d) : d(A);
	}
	function h(A) {
		return (
			(r.interrupt = !1),
			r.parser.lazy[r.now().line]
				? n(A)
				: (t.enter("tableDelimiterRow"),
					(s = !1),
					xt(A)
						? At(
								t,
								p,
								"linePrefix",
								r.parser.constructs.disable.null.includes(
									"codeIndented",
								)
									? void 0
									: 4,
							)(A)
						: p(A))
		);
	}
	function p(A) {
		return A === 45 || A === 58
			? v(A)
			: A === 124
				? ((s = !0),
					t.enter("tableCellDivider"),
					t.consume(A),
					t.exit("tableCellDivider"),
					g)
				: k(A);
	}
	function g(A) {
		return xt(A) ? At(t, v, "whitespace")(A) : v(A);
	}
	function v(A) {
		return A === 58
			? ((o += 1),
				(s = !0),
				t.enter("tableDelimiterMarker"),
				t.consume(A),
				t.exit("tableDelimiterMarker"),
				b)
			: A === 45
				? ((o += 1), b(A))
				: A === null || He(A)
					? C(A)
					: k(A);
	}
	function b(A) {
		return A === 45 ? (t.enter("tableDelimiterFiller"), y(A)) : k(A);
	}
	function y(A) {
		return A === 45
			? (t.consume(A), y)
			: A === 58
				? ((s = !0),
					t.exit("tableDelimiterFiller"),
					t.enter("tableDelimiterMarker"),
					t.consume(A),
					t.exit("tableDelimiterMarker"),
					x)
				: (t.exit("tableDelimiterFiller"), x(A));
	}
	function x(A) {
		return xt(A) ? At(t, C, "whitespace")(A) : C(A);
	}
	function C(A) {
		return A === 124
			? p(A)
			: A === null || He(A)
				? !s || i !== o
					? k(A)
					: (t.exit("tableDelimiterRow"), t.exit("tableHead"), e(A))
				: k(A);
	}
	function k(A) {
		return n(A);
	}
	function w(A) {
		return t.enter("tableRow"), D(A);
	}
	function D(A) {
		return A === 124
			? (t.enter("tableCellDivider"),
				t.consume(A),
				t.exit("tableCellDivider"),
				D)
			: A === null || He(A)
				? (t.exit("tableRow"), e(A))
				: xt(A)
					? At(t, D, "whitespace")(A)
					: (t.enter("data"), S(A));
	}
	function S(A) {
		return A === null || A === 124 || It(A)
			? (t.exit("data"), D(A))
			: (t.consume(A), A === 92 ? $ : S);
	}
	function $(A) {
		return A === 92 || A === 124 ? (t.consume(A), S) : S(A);
	}
}
function v6e(t, e) {
	let n = -1,
		r = !0,
		i = 0,
		o = [0, 0, 0, 0],
		s = [0, 0, 0, 0],
		a = !1,
		l = 0,
		u,
		c,
		d;
	const f = new h6e();
	for (; ++n < t.length; ) {
		const h = t[n],
			p = h[1];
		h[0] === "enter"
			? p.type === "tableHead"
				? ((a = !1),
					l !== 0 && (pF(f, e, l, u, c), (c = void 0), (l = 0)),
					(u = {
						type: "table",
						start: Object.assign({}, p.start),
						end: Object.assign({}, p.end),
					}),
					f.add(n, 0, [["enter", u, e]]))
				: p.type === "tableRow" || p.type === "tableDelimiterRow"
					? ((r = !0),
						(d = void 0),
						(o = [0, 0, 0, 0]),
						(s = [0, n + 1, 0, 0]),
						a &&
							((a = !1),
							(c = {
								type: "tableBody",
								start: Object.assign({}, p.start),
								end: Object.assign({}, p.end),
							}),
							f.add(n, 0, [["enter", c, e]])),
						(i = p.type === "tableDelimiterRow" ? 2 : c ? 3 : 1))
					: i &&
						  (p.type === "data" ||
								p.type === "tableDelimiterMarker" ||
								p.type === "tableDelimiterFiller")
						? ((r = !1),
							s[2] === 0 &&
								(o[1] !== 0 &&
									((s[0] = s[1]),
									(d = J1(f, e, o, i, void 0, d)),
									(o = [0, 0, 0, 0])),
								(s[2] = n)))
						: p.type === "tableCellDivider" &&
							(r
								? (r = !1)
								: (o[1] !== 0 &&
										((s[0] = s[1]),
										(d = J1(f, e, o, i, void 0, d))),
									(o = s),
									(s = [o[1], n, 0, 0])))
			: p.type === "tableHead"
				? ((a = !0), (l = n))
				: p.type === "tableRow" || p.type === "tableDelimiterRow"
					? ((l = n),
						o[1] !== 0
							? ((s[0] = s[1]), (d = J1(f, e, o, i, n, d)))
							: s[1] !== 0 && (d = J1(f, e, s, i, n, d)),
						(i = 0))
					: i &&
						(p.type === "data" ||
							p.type === "tableDelimiterMarker" ||
							p.type === "tableDelimiterFiller") &&
						(s[3] = n);
	}
	for (
		l !== 0 && pF(f, e, l, u, c), f.consume(e.events), n = -1;
		++n < e.events.length;

	) {
		const h = e.events[n];
		h[0] === "enter" &&
			h[1].type === "table" &&
			(h[1]._align = m6e(e.events, n));
	}
	return t;
}
function J1(t, e, n, r, i, o) {
	const s =
			r === 1 ? "tableHeader" : r === 2 ? "tableDelimiter" : "tableData",
		a = "tableContent";
	n[0] !== 0 &&
		((o.end = Object.assign({}, Ff(e.events, n[0]))),
		t.add(n[0], 0, [["exit", o, e]]));
	const l = Ff(e.events, n[1]);
	if (
		((o = {
			type: s,
			start: Object.assign({}, l),
			end: Object.assign({}, l),
		}),
		t.add(n[1], 0, [["enter", o, e]]),
		n[2] !== 0)
	) {
		const u = Ff(e.events, n[2]),
			c = Ff(e.events, n[3]),
			d = {
				type: a,
				start: Object.assign({}, u),
				end: Object.assign({}, c),
			};
		if ((t.add(n[2], 0, [["enter", d, e]]), r !== 2)) {
			const f = e.events[n[2]],
				h = e.events[n[3]];
			if (
				((f[1].end = Object.assign({}, h[1].end)),
				(f[1].type = "chunkText"),
				(f[1].contentType = "text"),
				n[3] > n[2] + 1)
			) {
				const p = n[2] + 1,
					g = n[3] - n[2] - 1;
				t.add(p, g, []);
			}
		}
		t.add(n[3] + 1, 0, [["exit", d, e]]);
	}
	return (
		i !== void 0 &&
			((o.end = Object.assign({}, Ff(e.events, i))),
			t.add(i, 0, [["exit", o, e]]),
			(o = void 0)),
		o
	);
}
function pF(t, e, n, r, i) {
	const o = [],
		s = Ff(e.events, n);
	i && ((i.end = Object.assign({}, s)), o.push(["exit", i, e])),
		(r.end = Object.assign({}, s)),
		o.push(["exit", r, e]),
		t.add(n + 1, 0, o);
}
function Ff(t, e) {
	const n = t[e],
		r = n[0] === "enter" ? "start" : "end";
	return n[1][r];
}
const y6e = { name: "tasklistCheck", tokenize: k6e };
function x6e() {
	return { text: { 91: y6e } };
}
function k6e(t, e, n) {
	const r = this;
	return i;
	function i(l) {
		return r.previous !== null || !r._gfmTasklistFirstContentOfListItem
			? n(l)
			: (t.enter("taskListCheck"),
				t.enter("taskListCheckMarker"),
				t.consume(l),
				t.exit("taskListCheckMarker"),
				o);
	}
	function o(l) {
		return It(l)
			? (t.enter("taskListCheckValueUnchecked"),
				t.consume(l),
				t.exit("taskListCheckValueUnchecked"),
				s)
			: l === 88 || l === 120
				? (t.enter("taskListCheckValueChecked"),
					t.consume(l),
					t.exit("taskListCheckValueChecked"),
					s)
				: n(l);
	}
	function s(l) {
		return l === 93
			? (t.enter("taskListCheckMarker"),
				t.consume(l),
				t.exit("taskListCheckMarker"),
				t.exit("taskListCheck"),
				a)
			: n(l);
	}
	function a(l) {
		return He(l)
			? e(l)
			: xt(l)
				? t.check({ tokenize: C6e }, e, n)(l)
				: n(l);
	}
}
function C6e(t, e, n) {
	return At(t, r, "whitespace");
	function r(i) {
		return i === null ? n(i) : e(i);
	}
}
function w6e(t) {
	return H5([yG(), o6e(), DG(), g6e(), x6e()]);
}
var E6e = [
		509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166,
		1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10,
		3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13,
		2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1,
		2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82,
		19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5,
		9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6,
		4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57,
		21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9,
		9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9,
		87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628,
		1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49,
		513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1,
		2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6,
		9, 4759, 9, 787719, 239,
	],
	rY = [
		0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4,
		48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35,
		5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2,
		1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1,
		4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1,
		65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21,
		11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28,
		11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33,
		24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36,
		17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3,
		21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47,
		21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38,
		6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7,
		3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72,
		264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1,
		2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110,
		18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78,
		18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12,
		65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16,
		0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84,
		2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2,
		6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2,
		30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61,
		147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2,
		14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3,
		2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0,
		2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2,
		2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621,
		2467, 541, 1507, 4938, 6, 4191,
	],
	D6e =
		"‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛࢘-࢟࣊-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄ఼ా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ೳഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ඁ-ඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-໎໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜕ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠏-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᪿ-ᫎᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷿‌‍‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯・꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿･",
	iY =
		"ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࡰ-ࢇࢉ-ࢎࢠ-ࣉऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౝౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೝೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜑᜟ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭌᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲈᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꟊꟐꟑꟓꟕ-ꟙꟲ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ",
	xC = {
		3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
		5: "class enum extends super const export import",
		6: "enum",
		strict: "implements interface let package private protected public static yield",
		strictBind: "eval arguments",
	},
	kC =
		"break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this",
	S6e = {
		5: kC,
		"5module": kC + " export import",
		6: kC + " const class extends export import super",
	},
	A6e = /^in(stanceof)?$/,
	$6e = new RegExp("[" + iY + "]"),
	T6e = new RegExp("[" + iY + D6e + "]");
function gE(t, e) {
	for (var n = 65536, r = 0; r < e.length; r += 2) {
		if (((n += e[r]), n > t)) return !1;
		if (((n += e[r + 1]), n >= t)) return !0;
	}
	return !1;
}
function Ca(t, e) {
	return t < 65
		? t === 36
		: t < 91
			? !0
			: t < 97
				? t === 95
				: t < 123
					? !0
					: t <= 65535
						? t >= 170 && $6e.test(String.fromCharCode(t))
						: e === !1
							? !1
							: gE(t, rY);
}
function Rd(t, e) {
	return t < 48
		? t === 36
		: t < 58
			? !0
			: t < 65
				? !1
				: t < 91
					? !0
					: t < 97
						? t === 95
						: t < 123
							? !0
							: t <= 65535
								? t >= 170 && T6e.test(String.fromCharCode(t))
								: e === !1
									? !1
									: gE(t, rY) || gE(t, E6e);
}
var Bt = function (e, n) {
	n === void 0 && (n = {}),
		(this.label = e),
		(this.keyword = n.keyword),
		(this.beforeExpr = !!n.beforeExpr),
		(this.startsExpr = !!n.startsExpr),
		(this.isLoop = !!n.isLoop),
		(this.isAssign = !!n.isAssign),
		(this.prefix = !!n.prefix),
		(this.postfix = !!n.postfix),
		(this.binop = n.binop || null),
		(this.updateContext = null);
};
function wo(t, e) {
	return new Bt(t, { beforeExpr: !0, binop: e });
}
var Eo = { beforeExpr: !0 },
	Di = { startsExpr: !0 },
	L3 = {};
function Tt(t, e) {
	return e === void 0 && (e = {}), (e.keyword = t), (L3[t] = new Bt(t, e));
}
var L = {
		num: new Bt("num", Di),
		regexp: new Bt("regexp", Di),
		string: new Bt("string", Di),
		name: new Bt("name", Di),
		privateId: new Bt("privateId", Di),
		eof: new Bt("eof"),
		bracketL: new Bt("[", { beforeExpr: !0, startsExpr: !0 }),
		bracketR: new Bt("]"),
		braceL: new Bt("{", { beforeExpr: !0, startsExpr: !0 }),
		braceR: new Bt("}"),
		parenL: new Bt("(", { beforeExpr: !0, startsExpr: !0 }),
		parenR: new Bt(")"),
		comma: new Bt(",", Eo),
		semi: new Bt(";", Eo),
		colon: new Bt(":", Eo),
		dot: new Bt("."),
		question: new Bt("?", Eo),
		questionDot: new Bt("?."),
		arrow: new Bt("=>", Eo),
		template: new Bt("template"),
		invalidTemplate: new Bt("invalidTemplate"),
		ellipsis: new Bt("...", Eo),
		backQuote: new Bt("`", Di),
		dollarBraceL: new Bt("${", { beforeExpr: !0, startsExpr: !0 }),
		eq: new Bt("=", { beforeExpr: !0, isAssign: !0 }),
		assign: new Bt("_=", { beforeExpr: !0, isAssign: !0 }),
		incDec: new Bt("++/--", { prefix: !0, postfix: !0, startsExpr: !0 }),
		prefix: new Bt("!/~", { beforeExpr: !0, prefix: !0, startsExpr: !0 }),
		logicalOR: wo("||", 1),
		logicalAND: wo("&&", 2),
		bitwiseOR: wo("|", 3),
		bitwiseXOR: wo("^", 4),
		bitwiseAND: wo("&", 5),
		equality: wo("==/!=/===/!==", 6),
		relational: wo("</>/<=/>=", 7),
		bitShift: wo("<</>>/>>>", 8),
		plusMin: new Bt("+/-", {
			beforeExpr: !0,
			binop: 9,
			prefix: !0,
			startsExpr: !0,
		}),
		modulo: wo("%", 10),
		star: wo("*", 10),
		slash: wo("/", 10),
		starstar: new Bt("**", { beforeExpr: !0 }),
		coalesce: wo("??", 1),
		_break: Tt("break"),
		_case: Tt("case", Eo),
		_catch: Tt("catch"),
		_continue: Tt("continue"),
		_debugger: Tt("debugger"),
		_default: Tt("default", Eo),
		_do: Tt("do", { isLoop: !0, beforeExpr: !0 }),
		_else: Tt("else", Eo),
		_finally: Tt("finally"),
		_for: Tt("for", { isLoop: !0 }),
		_function: Tt("function", Di),
		_if: Tt("if"),
		_return: Tt("return", Eo),
		_switch: Tt("switch"),
		_throw: Tt("throw", Eo),
		_try: Tt("try"),
		_var: Tt("var"),
		_const: Tt("const"),
		_while: Tt("while", { isLoop: !0 }),
		_with: Tt("with"),
		_new: Tt("new", { beforeExpr: !0, startsExpr: !0 }),
		_this: Tt("this", Di),
		_super: Tt("super", Di),
		_class: Tt("class", Di),
		_extends: Tt("extends", Eo),
		_export: Tt("export"),
		_import: Tt("import", Di),
		_null: Tt("null", Di),
		_true: Tt("true", Di),
		_false: Tt("false", Di),
		_in: Tt("in", { beforeExpr: !0, binop: 7 }),
		_instanceof: Tt("instanceof", { beforeExpr: !0, binop: 7 }),
		_typeof: Tt("typeof", { beforeExpr: !0, prefix: !0, startsExpr: !0 }),
		_void: Tt("void", { beforeExpr: !0, prefix: !0, startsExpr: !0 }),
		_delete: Tt("delete", { beforeExpr: !0, prefix: !0, startsExpr: !0 }),
	},
	yo = /\r\n?|\n|\u2028|\u2029/,
	oY = new RegExp(yo.source, "g");
function of(t) {
	return t === 10 || t === 13 || t === 8232 || t === 8233;
}
function sY(t, e, n) {
	n === void 0 && (n = t.length);
	for (var r = e; r < n; r++) {
		var i = t.charCodeAt(r);
		if (of(i))
			return r < n - 1 && i === 13 && t.charCodeAt(r + 1) === 10
				? r + 2
				: r + 1;
	}
	return -1;
}
var Q5 = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/,
	Po = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g,
	aY = Object.prototype,
	B6e = aY.hasOwnProperty,
	I6e = aY.toString,
	W0 =
		Object.hasOwn ||
		function (t, e) {
			return B6e.call(t, e);
		},
	mF =
		Array.isArray ||
		function (t) {
			return I6e.call(t) === "[object Array]";
		},
	gF = Object.create(null);
function Cu(t) {
	return gF[t] || (gF[t] = new RegExp("^(?:" + t.replace(/ /g, "|") + ")$"));
}
function Zu(t) {
	return t <= 65535
		? String.fromCharCode(t)
		: ((t -= 65536),
			String.fromCharCode((t >> 10) + 55296, (t & 1023) + 56320));
}
var F6e =
		/(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/,
	_h = function (e, n) {
		(this.line = e), (this.column = n);
	};
_h.prototype.offset = function (e) {
	return new _h(this.line, this.column + e);
};
var q0 = function (e, n, r) {
	(this.start = n),
		(this.end = r),
		e.sourceFile !== null && (this.source = e.sourceFile);
};
function eA(t, e) {
	for (var n = 1, r = 0; ; ) {
		var i = sY(t, r, e);
		if (i < 0) return new _h(n, e - r);
		++n, (r = i);
	}
}
var Ry = {
		ecmaVersion: null,
		sourceType: "script",
		onInsertedSemicolon: null,
		onTrailingComma: null,
		allowReserved: null,
		allowReturnOutsideFunction: !1,
		allowImportExportEverywhere: !1,
		allowAwaitOutsideFunction: null,
		allowSuperOutsideMethod: null,
		allowHashBang: !1,
		checkPrivateFields: !0,
		locations: !1,
		onToken: null,
		onComment: null,
		ranges: !1,
		program: null,
		sourceFile: null,
		directSourceFile: null,
		preserveParens: !1,
	},
	bF = !1;
function P6e(t) {
	var e = {};
	for (var n in Ry) e[n] = t && W0(t, n) ? t[n] : Ry[n];
	if (
		(e.ecmaVersion === "latest"
			? (e.ecmaVersion = 1e8)
			: e.ecmaVersion == null
				? (!bF &&
						typeof console == "object" &&
						console.warn &&
						((bF = !0),
						console.warn(`Since Acorn 8.0.0, options.ecmaVersion is required.
Defaulting to 2020, but this will stop working in the future.`)),
					(e.ecmaVersion = 11))
				: e.ecmaVersion >= 2015 && (e.ecmaVersion -= 2009),
		e.allowReserved == null && (e.allowReserved = e.ecmaVersion < 5),
		(!t || t.allowHashBang == null) &&
			(e.allowHashBang = e.ecmaVersion >= 14),
		mF(e.onToken))
	) {
		var r = e.onToken;
		e.onToken = function (i) {
			return r.push(i);
		};
	}
	return mF(e.onComment) && (e.onComment = N6e(e, e.onComment)), e;
}
function N6e(t, e) {
	return function (n, r, i, o, s, a) {
		var l = { type: n ? "Block" : "Line", value: r, start: i, end: o };
		t.locations && (l.loc = new q0(this, s, a)),
			t.ranges && (l.range = [i, o]),
			e.push(l);
	};
}
var Mg = 1,
	bp = 2,
	tA = 4,
	lY = 8,
	uY = 16,
	cY = 32,
	nA = 64,
	dY = 128,
	G0 = 256,
	rA = Mg | bp | G0;
function iA(t, e) {
	return bp | (t ? tA : 0) | (e ? lY : 0);
}
var Oy = 0,
	oA = 1,
	Ml = 2,
	fY = 3,
	hY = 4,
	pY = 5,
	kn = function (e, n, r) {
		(this.options = e = P6e(e)),
			(this.sourceFile = e.sourceFile),
			(this.keywords = Cu(
				S6e[
					e.ecmaVersion >= 6
						? 6
						: e.sourceType === "module"
							? "5module"
							: 5
				],
			));
		var i = "";
		e.allowReserved !== !0 &&
			((i = xC[e.ecmaVersion >= 6 ? 6 : e.ecmaVersion === 5 ? 5 : 3]),
			e.sourceType === "module" && (i += " await")),
			(this.reservedWords = Cu(i));
		var o = (i ? i + " " : "") + xC.strict;
		(this.reservedWordsStrict = Cu(o)),
			(this.reservedWordsStrictBind = Cu(o + " " + xC.strictBind)),
			(this.input = String(n)),
			(this.containsEsc = !1),
			r
				? ((this.pos = r),
					(this.lineStart =
						this.input.lastIndexOf(
							`
`,
							r - 1,
						) + 1),
					(this.curLine = this.input
						.slice(0, this.lineStart)
						.split(yo).length))
				: ((this.pos = this.lineStart = 0), (this.curLine = 1)),
			(this.type = L.eof),
			(this.value = null),
			(this.start = this.end = this.pos),
			(this.startLoc = this.endLoc = this.curPosition()),
			(this.lastTokEndLoc = this.lastTokStartLoc = null),
			(this.lastTokStart = this.lastTokEnd = this.pos),
			(this.context = this.initialContext()),
			(this.exprAllowed = !0),
			(this.inModule = e.sourceType === "module"),
			(this.strict = this.inModule || this.strictDirective(this.pos)),
			(this.potentialArrowAt = -1),
			(this.potentialArrowInForAwait = !1),
			(this.yieldPos = this.awaitPos = this.awaitIdentPos = 0),
			(this.labels = []),
			(this.undefinedExports = Object.create(null)),
			this.pos === 0 &&
				e.allowHashBang &&
				this.input.slice(0, 2) === "#!" &&
				this.skipLineComment(2),
			(this.scopeStack = []),
			this.enterScope(Mg),
			(this.regexpState = null),
			(this.privateNameStack = []);
	},
	$a = {
		inFunction: { configurable: !0 },
		inGenerator: { configurable: !0 },
		inAsync: { configurable: !0 },
		canAwait: { configurable: !0 },
		allowSuper: { configurable: !0 },
		allowDirectSuper: { configurable: !0 },
		treatFunctionsAsVar: { configurable: !0 },
		allowNewDotTarget: { configurable: !0 },
		inClassStaticBlock: { configurable: !0 },
	};
kn.prototype.parse = function () {
	var e = this.options.program || this.startNode();
	return this.nextToken(), this.parseTopLevel(e);
};
$a.inFunction.get = function () {
	return (this.currentVarScope().flags & bp) > 0;
};
$a.inGenerator.get = function () {
	return (
		(this.currentVarScope().flags & lY) > 0 &&
		!this.currentVarScope().inClassFieldInit
	);
};
$a.inAsync.get = function () {
	return (
		(this.currentVarScope().flags & tA) > 0 &&
		!this.currentVarScope().inClassFieldInit
	);
};
$a.canAwait.get = function () {
	for (var t = this.scopeStack.length - 1; t >= 0; t--) {
		var e = this.scopeStack[t];
		if (e.inClassFieldInit || e.flags & G0) return !1;
		if (e.flags & bp) return (e.flags & tA) > 0;
	}
	return (
		(this.inModule && this.options.ecmaVersion >= 13) ||
		this.options.allowAwaitOutsideFunction
	);
};
$a.allowSuper.get = function () {
	var t = this.currentThisScope(),
		e = t.flags,
		n = t.inClassFieldInit;
	return (e & nA) > 0 || n || this.options.allowSuperOutsideMethod;
};
$a.allowDirectSuper.get = function () {
	return (this.currentThisScope().flags & dY) > 0;
};
$a.treatFunctionsAsVar.get = function () {
	return this.treatFunctionsAsVarInScope(this.currentScope());
};
$a.allowNewDotTarget.get = function () {
	var t = this.currentThisScope(),
		e = t.flags,
		n = t.inClassFieldInit;
	return (e & (bp | G0)) > 0 || n;
};
$a.inClassStaticBlock.get = function () {
	return (this.currentVarScope().flags & G0) > 0;
};
kn.extend = function () {
	for (var e = [], n = arguments.length; n--; ) e[n] = arguments[n];
	for (var r = this, i = 0; i < e.length; i++) r = e[i](r);
	return r;
};
kn.parse = function (e, n) {
	return new this(n, e).parse();
};
kn.parseExpressionAt = function (e, n, r) {
	var i = new this(r, e, n);
	return i.nextToken(), i.parseExpression();
};
kn.tokenizer = function (e, n) {
	return new this(n, e);
};
Object.defineProperties(kn.prototype, $a);
var ki = kn.prototype,
	R6e = /^(?:'((?:\\[^]|[^'\\])*?)'|"((?:\\[^]|[^"\\])*?)")/;
ki.strictDirective = function (t) {
	if (this.options.ecmaVersion < 5) return !1;
	for (;;) {
		(Po.lastIndex = t), (t += Po.exec(this.input)[0].length);
		var e = R6e.exec(this.input.slice(t));
		if (!e) return !1;
		if ((e[1] || e[2]) === "use strict") {
			Po.lastIndex = t + e[0].length;
			var n = Po.exec(this.input),
				r = n.index + n[0].length,
				i = this.input.charAt(r);
			return (
				i === ";" ||
				i === "}" ||
				(yo.test(n[0]) &&
					!(
						/[(`.[+\-/*%<>=,?^&]/.test(i) ||
						(i === "!" && this.input.charAt(r + 1) === "=")
					))
			);
		}
		(t += e[0].length),
			(Po.lastIndex = t),
			(t += Po.exec(this.input)[0].length),
			this.input[t] === ";" && t++;
	}
};
ki.eat = function (t) {
	return this.type === t ? (this.next(), !0) : !1;
};
ki.isContextual = function (t) {
	return this.type === L.name && this.value === t && !this.containsEsc;
};
ki.eatContextual = function (t) {
	return this.isContextual(t) ? (this.next(), !0) : !1;
};
ki.expectContextual = function (t) {
	this.eatContextual(t) || this.unexpected();
};
ki.canInsertSemicolon = function () {
	return (
		this.type === L.eof ||
		this.type === L.braceR ||
		yo.test(this.input.slice(this.lastTokEnd, this.start))
	);
};
ki.insertSemicolon = function () {
	if (this.canInsertSemicolon())
		return (
			this.options.onInsertedSemicolon &&
				this.options.onInsertedSemicolon(
					this.lastTokEnd,
					this.lastTokEndLoc,
				),
			!0
		);
};
ki.semicolon = function () {
	!this.eat(L.semi) && !this.insertSemicolon() && this.unexpected();
};
ki.afterTrailingComma = function (t, e) {
	if (this.type === t)
		return (
			this.options.onTrailingComma &&
				this.options.onTrailingComma(
					this.lastTokStart,
					this.lastTokStartLoc,
				),
			e || this.next(),
			!0
		);
};
ki.expect = function (t) {
	this.eat(t) || this.unexpected();
};
ki.unexpected = function (t) {
	this.raise(t ?? this.start, "Unexpected token");
};
var V3 = function () {
	this.shorthandAssign =
		this.trailingComma =
		this.parenthesizedAssign =
		this.parenthesizedBind =
		this.doubleProto =
			-1;
};
ki.checkPatternErrors = function (t, e) {
	if (t) {
		t.trailingComma > -1 &&
			this.raiseRecoverable(
				t.trailingComma,
				"Comma is not permitted after the rest element",
			);
		var n = e ? t.parenthesizedAssign : t.parenthesizedBind;
		n > -1 &&
			this.raiseRecoverable(
				n,
				e ? "Assigning to rvalue" : "Parenthesized pattern",
			);
	}
};
ki.checkExpressionErrors = function (t, e) {
	if (!t) return !1;
	var n = t.shorthandAssign,
		r = t.doubleProto;
	if (!e) return n >= 0 || r >= 0;
	n >= 0 &&
		this.raise(
			n,
			"Shorthand property assignments are valid only in destructuring patterns",
		),
		r >= 0 &&
			this.raiseRecoverable(r, "Redefinition of __proto__ property");
};
ki.checkYieldAwaitInDefaultParams = function () {
	this.yieldPos &&
		(!this.awaitPos || this.yieldPos < this.awaitPos) &&
		this.raise(this.yieldPos, "Yield expression cannot be a default value"),
		this.awaitPos &&
			this.raise(
				this.awaitPos,
				"Await expression cannot be a default value",
			);
};
ki.isSimpleAssignTarget = function (t) {
	return t.type === "ParenthesizedExpression"
		? this.isSimpleAssignTarget(t.expression)
		: t.type === "Identifier" || t.type === "MemberExpression";
};
var Ye = kn.prototype;
Ye.parseTopLevel = function (t) {
	var e = Object.create(null);
	for (t.body || (t.body = []); this.type !== L.eof; ) {
		var n = this.parseStatement(null, !0, e);
		t.body.push(n);
	}
	if (this.inModule)
		for (
			var r = 0, i = Object.keys(this.undefinedExports);
			r < i.length;
			r += 1
		) {
			var o = i[r];
			this.raiseRecoverable(
				this.undefinedExports[o].start,
				"Export '" + o + "' is not defined",
			);
		}
	return (
		this.adaptDirectivePrologue(t.body),
		this.next(),
		(t.sourceType = this.options.sourceType),
		this.finishNode(t, "Program")
	);
};
var sA = { kind: "loop" },
	O6e = { kind: "switch" };
Ye.isLet = function (t) {
	if (this.options.ecmaVersion < 6 || !this.isContextual("let")) return !1;
	Po.lastIndex = this.pos;
	var e = Po.exec(this.input),
		n = this.pos + e[0].length,
		r = this.input.charCodeAt(n);
	if (r === 91 || r === 92) return !0;
	if (t) return !1;
	if (r === 123 || (r > 55295 && r < 56320)) return !0;
	if (Ca(r, !0)) {
		for (var i = n + 1; Rd((r = this.input.charCodeAt(i)), !0); ) ++i;
		if (r === 92 || (r > 55295 && r < 56320)) return !0;
		var o = this.input.slice(n, i);
		if (!A6e.test(o)) return !0;
	}
	return !1;
};
Ye.isAsyncFunction = function () {
	if (this.options.ecmaVersion < 8 || !this.isContextual("async")) return !1;
	Po.lastIndex = this.pos;
	var t = Po.exec(this.input),
		e = this.pos + t[0].length,
		n;
	return (
		!yo.test(this.input.slice(this.pos, e)) &&
		this.input.slice(e, e + 8) === "function" &&
		(e + 8 === this.input.length ||
			!(
				Rd((n = this.input.charCodeAt(e + 8))) ||
				(n > 55295 && n < 56320)
			))
	);
};
Ye.parseStatement = function (t, e, n) {
	var r = this.type,
		i = this.startNode(),
		o;
	switch ((this.isLet(t) && ((r = L._var), (o = "let")), r)) {
		case L._break:
		case L._continue:
			return this.parseBreakContinueStatement(i, r.keyword);
		case L._debugger:
			return this.parseDebuggerStatement(i);
		case L._do:
			return this.parseDoStatement(i);
		case L._for:
			return this.parseForStatement(i);
		case L._function:
			return (
				t &&
					(this.strict || (t !== "if" && t !== "label")) &&
					this.options.ecmaVersion >= 6 &&
					this.unexpected(),
				this.parseFunctionStatement(i, !1, !t)
			);
		case L._class:
			return t && this.unexpected(), this.parseClass(i, !0);
		case L._if:
			return this.parseIfStatement(i);
		case L._return:
			return this.parseReturnStatement(i);
		case L._switch:
			return this.parseSwitchStatement(i);
		case L._throw:
			return this.parseThrowStatement(i);
		case L._try:
			return this.parseTryStatement(i);
		case L._const:
		case L._var:
			return (
				(o = o || this.value),
				t && o !== "var" && this.unexpected(),
				this.parseVarStatement(i, o)
			);
		case L._while:
			return this.parseWhileStatement(i);
		case L._with:
			return this.parseWithStatement(i);
		case L.braceL:
			return this.parseBlock(!0, i);
		case L.semi:
			return this.parseEmptyStatement(i);
		case L._export:
		case L._import:
			if (this.options.ecmaVersion > 10 && r === L._import) {
				Po.lastIndex = this.pos;
				var s = Po.exec(this.input),
					a = this.pos + s[0].length,
					l = this.input.charCodeAt(a);
				if (l === 40 || l === 46)
					return this.parseExpressionStatement(
						i,
						this.parseExpression(),
					);
			}
			return (
				this.options.allowImportExportEverywhere ||
					(e ||
						this.raise(
							this.start,
							"'import' and 'export' may only appear at the top level",
						),
					this.inModule ||
						this.raise(
							this.start,
							"'import' and 'export' may appear only with 'sourceType: module'",
						)),
				r === L._import ? this.parseImport(i) : this.parseExport(i, n)
			);
		default:
			if (this.isAsyncFunction())
				return (
					t && this.unexpected(),
					this.next(),
					this.parseFunctionStatement(i, !0, !t)
				);
			var u = this.value,
				c = this.parseExpression();
			return r === L.name && c.type === "Identifier" && this.eat(L.colon)
				? this.parseLabeledStatement(i, u, c, t)
				: this.parseExpressionStatement(i, c);
	}
};
Ye.parseBreakContinueStatement = function (t, e) {
	var n = e === "break";
	this.next(),
		this.eat(L.semi) || this.insertSemicolon()
			? (t.label = null)
			: this.type !== L.name
				? this.unexpected()
				: ((t.label = this.parseIdent()), this.semicolon());
	for (var r = 0; r < this.labels.length; ++r) {
		var i = this.labels[r];
		if (
			(t.label == null || i.name === t.label.name) &&
			((i.kind != null && (n || i.kind === "loop")) || (t.label && n))
		)
			break;
	}
	return (
		r === this.labels.length && this.raise(t.start, "Unsyntactic " + e),
		this.finishNode(t, n ? "BreakStatement" : "ContinueStatement")
	);
};
Ye.parseDebuggerStatement = function (t) {
	return (
		this.next(), this.semicolon(), this.finishNode(t, "DebuggerStatement")
	);
};
Ye.parseDoStatement = function (t) {
	return (
		this.next(),
		this.labels.push(sA),
		(t.body = this.parseStatement("do")),
		this.labels.pop(),
		this.expect(L._while),
		(t.test = this.parseParenExpression()),
		this.options.ecmaVersion >= 6 ? this.eat(L.semi) : this.semicolon(),
		this.finishNode(t, "DoWhileStatement")
	);
};
Ye.parseForStatement = function (t) {
	this.next();
	var e =
		this.options.ecmaVersion >= 9 &&
		this.canAwait &&
		this.eatContextual("await")
			? this.lastTokStart
			: -1;
	if (
		(this.labels.push(sA),
		this.enterScope(0),
		this.expect(L.parenL),
		this.type === L.semi)
	)
		return e > -1 && this.unexpected(e), this.parseFor(t, null);
	var n = this.isLet();
	if (this.type === L._var || this.type === L._const || n) {
		var r = this.startNode(),
			i = n ? "let" : this.value;
		return (
			this.next(),
			this.parseVar(r, !0, i),
			this.finishNode(r, "VariableDeclaration"),
			(this.type === L._in ||
				(this.options.ecmaVersion >= 6 && this.isContextual("of"))) &&
			r.declarations.length === 1
				? (this.options.ecmaVersion >= 9 &&
						(this.type === L._in
							? e > -1 && this.unexpected(e)
							: (t.await = e > -1)),
					this.parseForIn(t, r))
				: (e > -1 && this.unexpected(e), this.parseFor(t, r))
		);
	}
	var o = this.isContextual("let"),
		s = !1,
		a = this.containsEsc,
		l = new V3(),
		u = this.start,
		c =
			e > -1
				? this.parseExprSubscripts(l, "await")
				: this.parseExpression(!0, l);
	return this.type === L._in ||
		(s = this.options.ecmaVersion >= 6 && this.isContextual("of"))
		? (e > -1
				? (this.type === L._in && this.unexpected(e), (t.await = !0))
				: s &&
					this.options.ecmaVersion >= 8 &&
					(c.start === u &&
					!a &&
					c.type === "Identifier" &&
					c.name === "async"
						? this.unexpected()
						: this.options.ecmaVersion >= 9 && (t.await = !1)),
			o &&
				s &&
				this.raise(
					c.start,
					"The left-hand side of a for-of loop may not start with 'let'.",
				),
			this.toAssignable(c, !1, l),
			this.checkLValPattern(c),
			this.parseForIn(t, c))
		: (this.checkExpressionErrors(l, !0),
			e > -1 && this.unexpected(e),
			this.parseFor(t, c));
};
Ye.parseFunctionStatement = function (t, e, n) {
	return this.next(), this.parseFunction(t, Pm | (n ? 0 : bE), !1, e);
};
Ye.parseIfStatement = function (t) {
	return (
		this.next(),
		(t.test = this.parseParenExpression()),
		(t.consequent = this.parseStatement("if")),
		(t.alternate = this.eat(L._else) ? this.parseStatement("if") : null),
		this.finishNode(t, "IfStatement")
	);
};
Ye.parseReturnStatement = function (t) {
	return (
		!this.inFunction &&
			!this.options.allowReturnOutsideFunction &&
			this.raise(this.start, "'return' outside of function"),
		this.next(),
		this.eat(L.semi) || this.insertSemicolon()
			? (t.argument = null)
			: ((t.argument = this.parseExpression()), this.semicolon()),
		this.finishNode(t, "ReturnStatement")
	);
};
Ye.parseSwitchStatement = function (t) {
	this.next(),
		(t.discriminant = this.parseParenExpression()),
		(t.cases = []),
		this.expect(L.braceL),
		this.labels.push(O6e),
		this.enterScope(0);
	for (var e, n = !1; this.type !== L.braceR; )
		if (this.type === L._case || this.type === L._default) {
			var r = this.type === L._case;
			e && this.finishNode(e, "SwitchCase"),
				t.cases.push((e = this.startNode())),
				(e.consequent = []),
				this.next(),
				r
					? (e.test = this.parseExpression())
					: (n &&
							this.raiseRecoverable(
								this.lastTokStart,
								"Multiple default clauses",
							),
						(n = !0),
						(e.test = null)),
				this.expect(L.colon);
		} else
			e || this.unexpected(),
				e.consequent.push(this.parseStatement(null));
	return (
		this.exitScope(),
		e && this.finishNode(e, "SwitchCase"),
		this.next(),
		this.labels.pop(),
		this.finishNode(t, "SwitchStatement")
	);
};
Ye.parseThrowStatement = function (t) {
	return (
		this.next(),
		yo.test(this.input.slice(this.lastTokEnd, this.start)) &&
			this.raise(this.lastTokEnd, "Illegal newline after throw"),
		(t.argument = this.parseExpression()),
		this.semicolon(),
		this.finishNode(t, "ThrowStatement")
	);
};
var M6e = [];
Ye.parseCatchClauseParam = function () {
	var t = this.parseBindingAtom(),
		e = t.type === "Identifier";
	return (
		this.enterScope(e ? cY : 0),
		this.checkLValPattern(t, e ? hY : Ml),
		this.expect(L.parenR),
		t
	);
};
Ye.parseTryStatement = function (t) {
	if (
		(this.next(),
		(t.block = this.parseBlock()),
		(t.handler = null),
		this.type === L._catch)
	) {
		var e = this.startNode();
		this.next(),
			this.eat(L.parenL)
				? (e.param = this.parseCatchClauseParam())
				: (this.options.ecmaVersion < 10 && this.unexpected(),
					(e.param = null),
					this.enterScope(0)),
			(e.body = this.parseBlock(!1)),
			this.exitScope(),
			(t.handler = this.finishNode(e, "CatchClause"));
	}
	return (
		(t.finalizer = this.eat(L._finally) ? this.parseBlock() : null),
		!t.handler &&
			!t.finalizer &&
			this.raise(t.start, "Missing catch or finally clause"),
		this.finishNode(t, "TryStatement")
	);
};
Ye.parseVarStatement = function (t, e, n) {
	return (
		this.next(),
		this.parseVar(t, !1, e, n),
		this.semicolon(),
		this.finishNode(t, "VariableDeclaration")
	);
};
Ye.parseWhileStatement = function (t) {
	return (
		this.next(),
		(t.test = this.parseParenExpression()),
		this.labels.push(sA),
		(t.body = this.parseStatement("while")),
		this.labels.pop(),
		this.finishNode(t, "WhileStatement")
	);
};
Ye.parseWithStatement = function (t) {
	return (
		this.strict && this.raise(this.start, "'with' in strict mode"),
		this.next(),
		(t.object = this.parseParenExpression()),
		(t.body = this.parseStatement("with")),
		this.finishNode(t, "WithStatement")
	);
};
Ye.parseEmptyStatement = function (t) {
	return this.next(), this.finishNode(t, "EmptyStatement");
};
Ye.parseLabeledStatement = function (t, e, n, r) {
	for (var i = 0, o = this.labels; i < o.length; i += 1) {
		var s = o[i];
		s.name === e &&
			this.raise(n.start, "Label '" + e + "' is already declared");
	}
	for (
		var a = this.type.isLoop
				? "loop"
				: this.type === L._switch
					? "switch"
					: null,
			l = this.labels.length - 1;
		l >= 0;
		l--
	) {
		var u = this.labels[l];
		if (u.statementStart === t.start)
			(u.statementStart = this.start), (u.kind = a);
		else break;
	}
	return (
		this.labels.push({ name: e, kind: a, statementStart: this.start }),
		(t.body = this.parseStatement(
			r ? (r.indexOf("label") === -1 ? r + "label" : r) : "label",
		)),
		this.labels.pop(),
		(t.label = n),
		this.finishNode(t, "LabeledStatement")
	);
};
Ye.parseExpressionStatement = function (t, e) {
	return (
		(t.expression = e),
		this.semicolon(),
		this.finishNode(t, "ExpressionStatement")
	);
};
Ye.parseBlock = function (t, e, n) {
	for (
		t === void 0 && (t = !0),
			e === void 0 && (e = this.startNode()),
			e.body = [],
			this.expect(L.braceL),
			t && this.enterScope(0);
		this.type !== L.braceR;

	) {
		var r = this.parseStatement(null);
		e.body.push(r);
	}
	return (
		n && (this.strict = !1),
		this.next(),
		t && this.exitScope(),
		this.finishNode(e, "BlockStatement")
	);
};
Ye.parseFor = function (t, e) {
	return (
		(t.init = e),
		this.expect(L.semi),
		(t.test = this.type === L.semi ? null : this.parseExpression()),
		this.expect(L.semi),
		(t.update = this.type === L.parenR ? null : this.parseExpression()),
		this.expect(L.parenR),
		(t.body = this.parseStatement("for")),
		this.exitScope(),
		this.labels.pop(),
		this.finishNode(t, "ForStatement")
	);
};
Ye.parseForIn = function (t, e) {
	var n = this.type === L._in;
	return (
		this.next(),
		e.type === "VariableDeclaration" &&
			e.declarations[0].init != null &&
			(!n ||
				this.options.ecmaVersion < 8 ||
				this.strict ||
				e.kind !== "var" ||
				e.declarations[0].id.type !== "Identifier") &&
			this.raise(
				e.start,
				(n ? "for-in" : "for-of") +
					" loop variable declaration may not have an initializer",
			),
		(t.left = e),
		(t.right = n ? this.parseExpression() : this.parseMaybeAssign()),
		this.expect(L.parenR),
		(t.body = this.parseStatement("for")),
		this.exitScope(),
		this.labels.pop(),
		this.finishNode(t, n ? "ForInStatement" : "ForOfStatement")
	);
};
Ye.parseVar = function (t, e, n, r) {
	for (t.declarations = [], t.kind = n; ; ) {
		var i = this.startNode();
		if (
			(this.parseVarId(i, n),
			this.eat(L.eq)
				? (i.init = this.parseMaybeAssign(e))
				: !r &&
					  n === "const" &&
					  !(
							this.type === L._in ||
							(this.options.ecmaVersion >= 6 &&
								this.isContextual("of"))
					  )
					? this.unexpected()
					: !r &&
						  i.id.type !== "Identifier" &&
						  !(
								e &&
								(this.type === L._in || this.isContextual("of"))
						  )
						? this.raise(
								this.lastTokEnd,
								"Complex binding patterns require an initialization value",
							)
						: (i.init = null),
			t.declarations.push(this.finishNode(i, "VariableDeclarator")),
			!this.eat(L.comma))
		)
			break;
	}
	return t;
};
Ye.parseVarId = function (t, e) {
	(t.id = this.parseBindingAtom()),
		this.checkLValPattern(t.id, e === "var" ? oA : Ml, !1);
};
var Pm = 1,
	bE = 2,
	mY = 4;
Ye.parseFunction = function (t, e, n, r, i) {
	this.initFunction(t),
		(this.options.ecmaVersion >= 9 ||
			(this.options.ecmaVersion >= 6 && !r)) &&
			(this.type === L.star && e & bE && this.unexpected(),
			(t.generator = this.eat(L.star))),
		this.options.ecmaVersion >= 8 && (t.async = !!r),
		e & Pm &&
			((t.id = e & mY && this.type !== L.name ? null : this.parseIdent()),
			t.id &&
				!(e & bE) &&
				this.checkLValSimple(
					t.id,
					this.strict || t.generator || t.async
						? this.treatFunctionsAsVar
							? oA
							: Ml
						: fY,
				));
	var o = this.yieldPos,
		s = this.awaitPos,
		a = this.awaitIdentPos;
	return (
		(this.yieldPos = 0),
		(this.awaitPos = 0),
		(this.awaitIdentPos = 0),
		this.enterScope(iA(t.async, t.generator)),
		e & Pm || (t.id = this.type === L.name ? this.parseIdent() : null),
		this.parseFunctionParams(t),
		this.parseFunctionBody(t, n, !1, i),
		(this.yieldPos = o),
		(this.awaitPos = s),
		(this.awaitIdentPos = a),
		this.finishNode(
			t,
			e & Pm ? "FunctionDeclaration" : "FunctionExpression",
		)
	);
};
Ye.parseFunctionParams = function (t) {
	this.expect(L.parenL),
		(t.params = this.parseBindingList(
			L.parenR,
			!1,
			this.options.ecmaVersion >= 8,
		)),
		this.checkYieldAwaitInDefaultParams();
};
Ye.parseClass = function (t, e) {
	this.next();
	var n = this.strict;
	(this.strict = !0), this.parseClassId(t, e), this.parseClassSuper(t);
	var r = this.enterClassBody(),
		i = this.startNode(),
		o = !1;
	for (i.body = [], this.expect(L.braceL); this.type !== L.braceR; ) {
		var s = this.parseClassElement(t.superClass !== null);
		s &&
			(i.body.push(s),
			s.type === "MethodDefinition" && s.kind === "constructor"
				? (o &&
						this.raiseRecoverable(
							s.start,
							"Duplicate constructor in the same class",
						),
					(o = !0))
				: s.key &&
					s.key.type === "PrivateIdentifier" &&
					j6e(r, s) &&
					this.raiseRecoverable(
						s.key.start,
						"Identifier '#" +
							s.key.name +
							"' has already been declared",
					));
	}
	return (
		(this.strict = n),
		this.next(),
		(t.body = this.finishNode(i, "ClassBody")),
		this.exitClassBody(),
		this.finishNode(t, e ? "ClassDeclaration" : "ClassExpression")
	);
};
Ye.parseClassElement = function (t) {
	if (this.eat(L.semi)) return null;
	var e = this.options.ecmaVersion,
		n = this.startNode(),
		r = "",
		i = !1,
		o = !1,
		s = "method",
		a = !1;
	if (this.eatContextual("static")) {
		if (e >= 13 && this.eat(L.braceL))
			return this.parseClassStaticBlock(n), n;
		this.isClassElementNameStart() || this.type === L.star
			? (a = !0)
			: (r = "static");
	}
	if (
		((n.static = a),
		!r &&
			e >= 8 &&
			this.eatContextual("async") &&
			((this.isClassElementNameStart() || this.type === L.star) &&
			!this.canInsertSemicolon()
				? (o = !0)
				: (r = "async")),
		!r && (e >= 9 || !o) && this.eat(L.star) && (i = !0),
		!r && !o && !i)
	) {
		var l = this.value;
		(this.eatContextual("get") || this.eatContextual("set")) &&
			(this.isClassElementNameStart() ? (s = l) : (r = l));
	}
	if (
		(r
			? ((n.computed = !1),
				(n.key = this.startNodeAt(
					this.lastTokStart,
					this.lastTokStartLoc,
				)),
				(n.key.name = r),
				this.finishNode(n.key, "Identifier"))
			: this.parseClassElementName(n),
		e < 13 || this.type === L.parenL || s !== "method" || i || o)
	) {
		var u = !n.static && My(n, "constructor"),
			c = u && t;
		u &&
			s !== "method" &&
			this.raise(n.key.start, "Constructor can't have get/set modifier"),
			(n.kind = u ? "constructor" : s),
			this.parseClassMethod(n, i, o, c);
	} else this.parseClassField(n);
	return n;
};
Ye.isClassElementNameStart = function () {
	return (
		this.type === L.name ||
		this.type === L.privateId ||
		this.type === L.num ||
		this.type === L.string ||
		this.type === L.bracketL ||
		this.type.keyword
	);
};
Ye.parseClassElementName = function (t) {
	this.type === L.privateId
		? (this.value === "constructor" &&
				this.raise(
					this.start,
					"Classes can't have an element named '#constructor'",
				),
			(t.computed = !1),
			(t.key = this.parsePrivateIdent()))
		: this.parsePropertyName(t);
};
Ye.parseClassMethod = function (t, e, n, r) {
	var i = t.key;
	t.kind === "constructor"
		? (e && this.raise(i.start, "Constructor can't be a generator"),
			n && this.raise(i.start, "Constructor can't be an async method"))
		: t.static &&
			My(t, "prototype") &&
			this.raise(
				i.start,
				"Classes may not have a static property named prototype",
			);
	var o = (t.value = this.parseMethod(e, n, r));
	return (
		t.kind === "get" &&
			o.params.length !== 0 &&
			this.raiseRecoverable(o.start, "getter should have no params"),
		t.kind === "set" &&
			o.params.length !== 1 &&
			this.raiseRecoverable(
				o.start,
				"setter should have exactly one param",
			),
		t.kind === "set" &&
			o.params[0].type === "RestElement" &&
			this.raiseRecoverable(
				o.params[0].start,
				"Setter cannot use rest params",
			),
		this.finishNode(t, "MethodDefinition")
	);
};
Ye.parseClassField = function (t) {
	if (
		(My(t, "constructor")
			? this.raise(
					t.key.start,
					"Classes can't have a field named 'constructor'",
				)
			: t.static &&
				My(t, "prototype") &&
				this.raise(
					t.key.start,
					"Classes can't have a static field named 'prototype'",
				),
		this.eat(L.eq))
	) {
		var e = this.currentThisScope(),
			n = e.inClassFieldInit;
		(e.inClassFieldInit = !0),
			(t.value = this.parseMaybeAssign()),
			(e.inClassFieldInit = n);
	} else t.value = null;
	return this.semicolon(), this.finishNode(t, "PropertyDefinition");
};
Ye.parseClassStaticBlock = function (t) {
	t.body = [];
	var e = this.labels;
	for (this.labels = [], this.enterScope(G0 | nA); this.type !== L.braceR; ) {
		var n = this.parseStatement(null);
		t.body.push(n);
	}
	return (
		this.next(),
		this.exitScope(),
		(this.labels = e),
		this.finishNode(t, "StaticBlock")
	);
};
Ye.parseClassId = function (t, e) {
	this.type === L.name
		? ((t.id = this.parseIdent()), e && this.checkLValSimple(t.id, Ml, !1))
		: (e === !0 && this.unexpected(), (t.id = null));
};
Ye.parseClassSuper = function (t) {
	t.superClass = this.eat(L._extends)
		? this.parseExprSubscripts(null, !1)
		: null;
};
Ye.enterClassBody = function () {
	var t = { declared: Object.create(null), used: [] };
	return this.privateNameStack.push(t), t.declared;
};
Ye.exitClassBody = function () {
	var t = this.privateNameStack.pop(),
		e = t.declared,
		n = t.used;
	if (this.options.checkPrivateFields)
		for (
			var r = this.privateNameStack.length,
				i = r === 0 ? null : this.privateNameStack[r - 1],
				o = 0;
			o < n.length;
			++o
		) {
			var s = n[o];
			W0(e, s.name) ||
				(i
					? i.used.push(s)
					: this.raiseRecoverable(
							s.start,
							"Private field '#" +
								s.name +
								"' must be declared in an enclosing class",
						));
		}
};
function j6e(t, e) {
	var n = e.key.name,
		r = t[n],
		i = "true";
	return (
		e.type === "MethodDefinition" &&
			(e.kind === "get" || e.kind === "set") &&
			(i = (e.static ? "s" : "i") + e.kind),
		(r === "iget" && i === "iset") ||
		(r === "iset" && i === "iget") ||
		(r === "sget" && i === "sset") ||
		(r === "sset" && i === "sget")
			? ((t[n] = "true"), !1)
			: r
				? !0
				: ((t[n] = i), !1)
	);
}
function My(t, e) {
	var n = t.computed,
		r = t.key;
	return (
		!n &&
		((r.type === "Identifier" && r.name === e) ||
			(r.type === "Literal" && r.value === e))
	);
}
Ye.parseExportAllDeclaration = function (t, e) {
	return (
		this.options.ecmaVersion >= 11 &&
			(this.eatContextual("as")
				? ((t.exported = this.parseModuleExportName()),
					this.checkExport(e, t.exported, this.lastTokStart))
				: (t.exported = null)),
		this.expectContextual("from"),
		this.type !== L.string && this.unexpected(),
		(t.source = this.parseExprAtom()),
		this.semicolon(),
		this.finishNode(t, "ExportAllDeclaration")
	);
};
Ye.parseExport = function (t, e) {
	if ((this.next(), this.eat(L.star)))
		return this.parseExportAllDeclaration(t, e);
	if (this.eat(L._default))
		return (
			this.checkExport(e, "default", this.lastTokStart),
			(t.declaration = this.parseExportDefaultDeclaration()),
			this.finishNode(t, "ExportDefaultDeclaration")
		);
	if (this.shouldParseExportStatement())
		(t.declaration = this.parseExportDeclaration(t)),
			t.declaration.type === "VariableDeclaration"
				? this.checkVariableExport(e, t.declaration.declarations)
				: this.checkExport(e, t.declaration.id, t.declaration.id.start),
			(t.specifiers = []),
			(t.source = null);
	else {
		if (
			((t.declaration = null),
			(t.specifiers = this.parseExportSpecifiers(e)),
			this.eatContextual("from"))
		)
			this.type !== L.string && this.unexpected(),
				(t.source = this.parseExprAtom());
		else {
			for (var n = 0, r = t.specifiers; n < r.length; n += 1) {
				var i = r[n];
				this.checkUnreserved(i.local),
					this.checkLocalExport(i.local),
					i.local.type === "Literal" &&
						this.raise(
							i.local.start,
							"A string literal cannot be used as an exported binding without `from`.",
						);
			}
			t.source = null;
		}
		this.semicolon();
	}
	return this.finishNode(t, "ExportNamedDeclaration");
};
Ye.parseExportDeclaration = function (t) {
	return this.parseStatement(null);
};
Ye.parseExportDefaultDeclaration = function () {
	var t;
	if (this.type === L._function || (t = this.isAsyncFunction())) {
		var e = this.startNode();
		return (
			this.next(), t && this.next(), this.parseFunction(e, Pm | mY, !1, t)
		);
	} else if (this.type === L._class) {
		var n = this.startNode();
		return this.parseClass(n, "nullableID");
	} else {
		var r = this.parseMaybeAssign();
		return this.semicolon(), r;
	}
};
Ye.checkExport = function (t, e, n) {
	t &&
		(typeof e != "string" &&
			(e = e.type === "Identifier" ? e.name : e.value),
		W0(t, e) && this.raiseRecoverable(n, "Duplicate export '" + e + "'"),
		(t[e] = !0));
};
Ye.checkPatternExport = function (t, e) {
	var n = e.type;
	if (n === "Identifier") this.checkExport(t, e, e.start);
	else if (n === "ObjectPattern")
		for (var r = 0, i = e.properties; r < i.length; r += 1) {
			var o = i[r];
			this.checkPatternExport(t, o);
		}
	else if (n === "ArrayPattern")
		for (var s = 0, a = e.elements; s < a.length; s += 1) {
			var l = a[s];
			l && this.checkPatternExport(t, l);
		}
	else
		n === "Property"
			? this.checkPatternExport(t, e.value)
			: n === "AssignmentPattern"
				? this.checkPatternExport(t, e.left)
				: n === "RestElement" && this.checkPatternExport(t, e.argument);
};
Ye.checkVariableExport = function (t, e) {
	if (t)
		for (var n = 0, r = e; n < r.length; n += 1) {
			var i = r[n];
			this.checkPatternExport(t, i.id);
		}
};
Ye.shouldParseExportStatement = function () {
	return (
		this.type.keyword === "var" ||
		this.type.keyword === "const" ||
		this.type.keyword === "class" ||
		this.type.keyword === "function" ||
		this.isLet() ||
		this.isAsyncFunction()
	);
};
Ye.parseExportSpecifier = function (t) {
	var e = this.startNode();
	return (
		(e.local = this.parseModuleExportName()),
		(e.exported = this.eatContextual("as")
			? this.parseModuleExportName()
			: e.local),
		this.checkExport(t, e.exported, e.exported.start),
		this.finishNode(e, "ExportSpecifier")
	);
};
Ye.parseExportSpecifiers = function (t) {
	var e = [],
		n = !0;
	for (this.expect(L.braceL); !this.eat(L.braceR); ) {
		if (n) n = !1;
		else if ((this.expect(L.comma), this.afterTrailingComma(L.braceR)))
			break;
		e.push(this.parseExportSpecifier(t));
	}
	return e;
};
Ye.parseImport = function (t) {
	return (
		this.next(),
		this.type === L.string
			? ((t.specifiers = M6e), (t.source = this.parseExprAtom()))
			: ((t.specifiers = this.parseImportSpecifiers()),
				this.expectContextual("from"),
				(t.source =
					this.type === L.string
						? this.parseExprAtom()
						: this.unexpected())),
		this.semicolon(),
		this.finishNode(t, "ImportDeclaration")
	);
};
Ye.parseImportSpecifier = function () {
	var t = this.startNode();
	return (
		(t.imported = this.parseModuleExportName()),
		this.eatContextual("as")
			? (t.local = this.parseIdent())
			: (this.checkUnreserved(t.imported), (t.local = t.imported)),
		this.checkLValSimple(t.local, Ml),
		this.finishNode(t, "ImportSpecifier")
	);
};
Ye.parseImportDefaultSpecifier = function () {
	var t = this.startNode();
	return (
		(t.local = this.parseIdent()),
		this.checkLValSimple(t.local, Ml),
		this.finishNode(t, "ImportDefaultSpecifier")
	);
};
Ye.parseImportNamespaceSpecifier = function () {
	var t = this.startNode();
	return (
		this.next(),
		this.expectContextual("as"),
		(t.local = this.parseIdent()),
		this.checkLValSimple(t.local, Ml),
		this.finishNode(t, "ImportNamespaceSpecifier")
	);
};
Ye.parseImportSpecifiers = function () {
	var t = [],
		e = !0;
	if (
		this.type === L.name &&
		(t.push(this.parseImportDefaultSpecifier()), !this.eat(L.comma))
	)
		return t;
	if (this.type === L.star)
		return t.push(this.parseImportNamespaceSpecifier()), t;
	for (this.expect(L.braceL); !this.eat(L.braceR); ) {
		if (e) e = !1;
		else if ((this.expect(L.comma), this.afterTrailingComma(L.braceR)))
			break;
		t.push(this.parseImportSpecifier());
	}
	return t;
};
Ye.parseModuleExportName = function () {
	if (this.options.ecmaVersion >= 13 && this.type === L.string) {
		var t = this.parseLiteral(this.value);
		return (
			F6e.test(t.value) &&
				this.raise(
					t.start,
					"An export name cannot include a lone surrogate.",
				),
			t
		);
	}
	return this.parseIdent(!0);
};
Ye.adaptDirectivePrologue = function (t) {
	for (var e = 0; e < t.length && this.isDirectiveCandidate(t[e]); ++e)
		t[e].directive = t[e].expression.raw.slice(1, -1);
};
Ye.isDirectiveCandidate = function (t) {
	return (
		this.options.ecmaVersion >= 5 &&
		t.type === "ExpressionStatement" &&
		t.expression.type === "Literal" &&
		typeof t.expression.value == "string" &&
		(this.input[t.start] === '"' || this.input[t.start] === "'")
	);
};
var es = kn.prototype;
es.toAssignable = function (t, e, n) {
	if (this.options.ecmaVersion >= 6 && t)
		switch (t.type) {
			case "Identifier":
				this.inAsync &&
					t.name === "await" &&
					this.raise(
						t.start,
						"Cannot use 'await' as identifier inside an async function",
					);
				break;
			case "ObjectPattern":
			case "ArrayPattern":
			case "AssignmentPattern":
			case "RestElement":
				break;
			case "ObjectExpression":
				(t.type = "ObjectPattern"), n && this.checkPatternErrors(n, !0);
				for (var r = 0, i = t.properties; r < i.length; r += 1) {
					var o = i[r];
					this.toAssignable(o, e),
						o.type === "RestElement" &&
							(o.argument.type === "ArrayPattern" ||
								o.argument.type === "ObjectPattern") &&
							this.raise(o.argument.start, "Unexpected token");
				}
				break;
			case "Property":
				t.kind !== "init" &&
					this.raise(
						t.key.start,
						"Object pattern can't contain getter or setter",
					),
					this.toAssignable(t.value, e);
				break;
			case "ArrayExpression":
				(t.type = "ArrayPattern"),
					n && this.checkPatternErrors(n, !0),
					this.toAssignableList(t.elements, e);
				break;
			case "SpreadElement":
				(t.type = "RestElement"),
					this.toAssignable(t.argument, e),
					t.argument.type === "AssignmentPattern" &&
						this.raise(
							t.argument.start,
							"Rest elements cannot have a default value",
						);
				break;
			case "AssignmentExpression":
				t.operator !== "=" &&
					this.raise(
						t.left.end,
						"Only '=' operator can be used for specifying default value.",
					),
					(t.type = "AssignmentPattern"),
					delete t.operator,
					this.toAssignable(t.left, e);
				break;
			case "ParenthesizedExpression":
				this.toAssignable(t.expression, e, n);
				break;
			case "ChainExpression":
				this.raiseRecoverable(
					t.start,
					"Optional chaining cannot appear in left-hand side",
				);
				break;
			case "MemberExpression":
				if (!e) break;
			default:
				this.raise(t.start, "Assigning to rvalue");
		}
	else n && this.checkPatternErrors(n, !0);
	return t;
};
es.toAssignableList = function (t, e) {
	for (var n = t.length, r = 0; r < n; r++) {
		var i = t[r];
		i && this.toAssignable(i, e);
	}
	if (n) {
		var o = t[n - 1];
		this.options.ecmaVersion === 6 &&
			e &&
			o &&
			o.type === "RestElement" &&
			o.argument.type !== "Identifier" &&
			this.unexpected(o.argument.start);
	}
	return t;
};
es.parseSpread = function (t) {
	var e = this.startNode();
	return (
		this.next(),
		(e.argument = this.parseMaybeAssign(!1, t)),
		this.finishNode(e, "SpreadElement")
	);
};
es.parseRestBinding = function () {
	var t = this.startNode();
	return (
		this.next(),
		this.options.ecmaVersion === 6 &&
			this.type !== L.name &&
			this.unexpected(),
		(t.argument = this.parseBindingAtom()),
		this.finishNode(t, "RestElement")
	);
};
es.parseBindingAtom = function () {
	if (this.options.ecmaVersion >= 6)
		switch (this.type) {
			case L.bracketL:
				var t = this.startNode();
				return (
					this.next(),
					(t.elements = this.parseBindingList(L.bracketR, !0, !0)),
					this.finishNode(t, "ArrayPattern")
				);
			case L.braceL:
				return this.parseObj(!0);
		}
	return this.parseIdent();
};
es.parseBindingList = function (t, e, n, r) {
	for (var i = [], o = !0; !this.eat(t); )
		if ((o ? (o = !1) : this.expect(L.comma), e && this.type === L.comma))
			i.push(null);
		else {
			if (n && this.afterTrailingComma(t)) break;
			if (this.type === L.ellipsis) {
				var s = this.parseRestBinding();
				this.parseBindingListItem(s),
					i.push(s),
					this.type === L.comma &&
						this.raiseRecoverable(
							this.start,
							"Comma is not permitted after the rest element",
						),
					this.expect(t);
				break;
			} else i.push(this.parseAssignableListItem(r));
		}
	return i;
};
es.parseAssignableListItem = function (t) {
	var e = this.parseMaybeDefault(this.start, this.startLoc);
	return this.parseBindingListItem(e), e;
};
es.parseBindingListItem = function (t) {
	return t;
};
es.parseMaybeDefault = function (t, e, n) {
	if (
		((n = n || this.parseBindingAtom()),
		this.options.ecmaVersion < 6 || !this.eat(L.eq))
	)
		return n;
	var r = this.startNodeAt(t, e);
	return (
		(r.left = n),
		(r.right = this.parseMaybeAssign()),
		this.finishNode(r, "AssignmentPattern")
	);
};
es.checkLValSimple = function (t, e, n) {
	e === void 0 && (e = Oy);
	var r = e !== Oy;
	switch (t.type) {
		case "Identifier":
			this.strict &&
				this.reservedWordsStrictBind.test(t.name) &&
				this.raiseRecoverable(
					t.start,
					(r ? "Binding " : "Assigning to ") +
						t.name +
						" in strict mode",
				),
				r &&
					(e === Ml &&
						t.name === "let" &&
						this.raiseRecoverable(
							t.start,
							"let is disallowed as a lexically bound name",
						),
					n &&
						(W0(n, t.name) &&
							this.raiseRecoverable(
								t.start,
								"Argument name clash",
							),
						(n[t.name] = !0)),
					e !== pY && this.declareName(t.name, e, t.start));
			break;
		case "ChainExpression":
			this.raiseRecoverable(
				t.start,
				"Optional chaining cannot appear in left-hand side",
			);
			break;
		case "MemberExpression":
			r && this.raiseRecoverable(t.start, "Binding member expression");
			break;
		case "ParenthesizedExpression":
			return (
				r &&
					this.raiseRecoverable(
						t.start,
						"Binding parenthesized expression",
					),
				this.checkLValSimple(t.expression, e, n)
			);
		default:
			this.raise(t.start, (r ? "Binding" : "Assigning to") + " rvalue");
	}
};
es.checkLValPattern = function (t, e, n) {
	switch ((e === void 0 && (e = Oy), t.type)) {
		case "ObjectPattern":
			for (var r = 0, i = t.properties; r < i.length; r += 1) {
				var o = i[r];
				this.checkLValInnerPattern(o, e, n);
			}
			break;
		case "ArrayPattern":
			for (var s = 0, a = t.elements; s < a.length; s += 1) {
				var l = a[s];
				l && this.checkLValInnerPattern(l, e, n);
			}
			break;
		default:
			this.checkLValSimple(t, e, n);
	}
};
es.checkLValInnerPattern = function (t, e, n) {
	switch ((e === void 0 && (e = Oy), t.type)) {
		case "Property":
			this.checkLValInnerPattern(t.value, e, n);
			break;
		case "AssignmentPattern":
			this.checkLValPattern(t.left, e, n);
			break;
		case "RestElement":
			this.checkLValPattern(t.argument, e, n);
			break;
		default:
			this.checkLValPattern(t, e, n);
	}
};
var So = function (e, n, r, i, o) {
		(this.token = e),
			(this.isExpr = !!n),
			(this.preserveSpace = !!r),
			(this.override = i),
			(this.generator = !!o);
	},
	sn = {
		b_stat: new So("{", !1),
		b_expr: new So("{", !0),
		b_tmpl: new So("${", !1),
		p_stat: new So("(", !1),
		p_expr: new So("(", !0),
		q_tmpl: new So("`", !0, !0, function (t) {
			return t.tryReadTemplateToken();
		}),
		f_stat: new So("function", !1),
		f_expr: new So("function", !0),
		f_expr_gen: new So("function", !0, !1, null, !0),
		f_gen: new So("function", !1, !1, null, !0),
	},
	vp = kn.prototype;
vp.initialContext = function () {
	return [sn.b_stat];
};
vp.curContext = function () {
	return this.context[this.context.length - 1];
};
vp.braceIsBlock = function (t) {
	var e = this.curContext();
	return e === sn.f_expr || e === sn.f_stat
		? !0
		: t === L.colon && (e === sn.b_stat || e === sn.b_expr)
			? !e.isExpr
			: t === L._return || (t === L.name && this.exprAllowed)
				? yo.test(this.input.slice(this.lastTokEnd, this.start))
				: t === L._else ||
					  t === L.semi ||
					  t === L.eof ||
					  t === L.parenR ||
					  t === L.arrow
					? !0
					: t === L.braceL
						? e === sn.b_stat
						: t === L._var || t === L._const || t === L.name
							? !1
							: !this.exprAllowed;
};
vp.inGeneratorContext = function () {
	for (var t = this.context.length - 1; t >= 1; t--) {
		var e = this.context[t];
		if (e.token === "function") return e.generator;
	}
	return !1;
};
vp.updateContext = function (t) {
	var e,
		n = this.type;
	n.keyword && t === L.dot
		? (this.exprAllowed = !1)
		: (e = n.updateContext)
			? e.call(this, t)
			: (this.exprAllowed = n.beforeExpr);
};
vp.overrideContext = function (t) {
	this.curContext() !== t && (this.context[this.context.length - 1] = t);
};
L.parenR.updateContext = L.braceR.updateContext = function () {
	if (this.context.length === 1) {
		this.exprAllowed = !0;
		return;
	}
	var t = this.context.pop();
	t === sn.b_stat &&
		this.curContext().token === "function" &&
		(t = this.context.pop()),
		(this.exprAllowed = !t.isExpr);
};
L.braceL.updateContext = function (t) {
	this.context.push(this.braceIsBlock(t) ? sn.b_stat : sn.b_expr),
		(this.exprAllowed = !0);
};
L.dollarBraceL.updateContext = function () {
	this.context.push(sn.b_tmpl), (this.exprAllowed = !0);
};
L.parenL.updateContext = function (t) {
	var e = t === L._if || t === L._for || t === L._with || t === L._while;
	this.context.push(e ? sn.p_stat : sn.p_expr), (this.exprAllowed = !0);
};
L.incDec.updateContext = function () {};
L._function.updateContext = L._class.updateContext = function (t) {
	t.beforeExpr &&
	t !== L._else &&
	!(t === L.semi && this.curContext() !== sn.p_stat) &&
	!(
		t === L._return &&
		yo.test(this.input.slice(this.lastTokEnd, this.start))
	) &&
	!((t === L.colon || t === L.braceL) && this.curContext() === sn.b_stat)
		? this.context.push(sn.f_expr)
		: this.context.push(sn.f_stat),
		(this.exprAllowed = !1);
};
L.colon.updateContext = function () {
	this.curContext().token === "function" && this.context.pop(),
		(this.exprAllowed = !0);
};
L.backQuote.updateContext = function () {
	this.curContext() === sn.q_tmpl
		? this.context.pop()
		: this.context.push(sn.q_tmpl),
		(this.exprAllowed = !1);
};
L.star.updateContext = function (t) {
	if (t === L._function) {
		var e = this.context.length - 1;
		this.context[e] === sn.f_expr
			? (this.context[e] = sn.f_expr_gen)
			: (this.context[e] = sn.f_gen);
	}
	this.exprAllowed = !0;
};
L.name.updateContext = function (t) {
	var e = !1;
	this.options.ecmaVersion >= 6 &&
		t !== L.dot &&
		((this.value === "of" && !this.exprAllowed) ||
			(this.value === "yield" && this.inGeneratorContext())) &&
		(e = !0),
		(this.exprAllowed = e);
};
var ct = kn.prototype;
ct.checkPropClash = function (t, e, n) {
	if (
		!(this.options.ecmaVersion >= 9 && t.type === "SpreadElement") &&
		!(
			this.options.ecmaVersion >= 6 &&
			(t.computed || t.method || t.shorthand)
		)
	) {
		var r = t.key,
			i;
		switch (r.type) {
			case "Identifier":
				i = r.name;
				break;
			case "Literal":
				i = String(r.value);
				break;
			default:
				return;
		}
		var o = t.kind;
		if (this.options.ecmaVersion >= 6) {
			i === "__proto__" &&
				o === "init" &&
				(e.proto &&
					(n
						? n.doubleProto < 0 && (n.doubleProto = r.start)
						: this.raiseRecoverable(
								r.start,
								"Redefinition of __proto__ property",
							)),
				(e.proto = !0));
			return;
		}
		i = "$" + i;
		var s = e[i];
		if (s) {
			var a;
			o === "init"
				? (a = (this.strict && s.init) || s.get || s.set)
				: (a = s.init || s[o]),
				a && this.raiseRecoverable(r.start, "Redefinition of property");
		} else s = e[i] = { init: !1, get: !1, set: !1 };
		s[o] = !0;
	}
};
ct.parseExpression = function (t, e) {
	var n = this.start,
		r = this.startLoc,
		i = this.parseMaybeAssign(t, e);
	if (this.type === L.comma) {
		var o = this.startNodeAt(n, r);
		for (o.expressions = [i]; this.eat(L.comma); )
			o.expressions.push(this.parseMaybeAssign(t, e));
		return this.finishNode(o, "SequenceExpression");
	}
	return i;
};
ct.parseMaybeAssign = function (t, e, n) {
	if (this.isContextual("yield")) {
		if (this.inGenerator) return this.parseYield(t);
		this.exprAllowed = !1;
	}
	var r = !1,
		i = -1,
		o = -1,
		s = -1;
	e
		? ((i = e.parenthesizedAssign),
			(o = e.trailingComma),
			(s = e.doubleProto),
			(e.parenthesizedAssign = e.trailingComma = -1))
		: ((e = new V3()), (r = !0));
	var a = this.start,
		l = this.startLoc;
	(this.type === L.parenL || this.type === L.name) &&
		((this.potentialArrowAt = this.start),
		(this.potentialArrowInForAwait = t === "await"));
	var u = this.parseMaybeConditional(t, e);
	if ((n && (u = n.call(this, u, a, l)), this.type.isAssign)) {
		var c = this.startNodeAt(a, l);
		return (
			(c.operator = this.value),
			this.type === L.eq && (u = this.toAssignable(u, !1, e)),
			r || (e.parenthesizedAssign = e.trailingComma = e.doubleProto = -1),
			e.shorthandAssign >= u.start && (e.shorthandAssign = -1),
			this.type === L.eq
				? this.checkLValPattern(u)
				: this.checkLValSimple(u),
			(c.left = u),
			this.next(),
			(c.right = this.parseMaybeAssign(t)),
			s > -1 && (e.doubleProto = s),
			this.finishNode(c, "AssignmentExpression")
		);
	} else r && this.checkExpressionErrors(e, !0);
	return (
		i > -1 && (e.parenthesizedAssign = i),
		o > -1 && (e.trailingComma = o),
		u
	);
};
ct.parseMaybeConditional = function (t, e) {
	var n = this.start,
		r = this.startLoc,
		i = this.parseExprOps(t, e);
	if (this.checkExpressionErrors(e)) return i;
	if (this.eat(L.question)) {
		var o = this.startNodeAt(n, r);
		return (
			(o.test = i),
			(o.consequent = this.parseMaybeAssign()),
			this.expect(L.colon),
			(o.alternate = this.parseMaybeAssign(t)),
			this.finishNode(o, "ConditionalExpression")
		);
	}
	return i;
};
ct.parseExprOps = function (t, e) {
	var n = this.start,
		r = this.startLoc,
		i = this.parseMaybeUnary(e, !1, !1, t);
	return this.checkExpressionErrors(e) ||
		(i.start === n && i.type === "ArrowFunctionExpression")
		? i
		: this.parseExprOp(i, n, r, -1, t);
};
ct.parseExprOp = function (t, e, n, r, i) {
	var o = this.type.binop;
	if (o != null && (!i || this.type !== L._in) && o > r) {
		var s = this.type === L.logicalOR || this.type === L.logicalAND,
			a = this.type === L.coalesce;
		a && (o = L.logicalAND.binop);
		var l = this.value;
		this.next();
		var u = this.start,
			c = this.startLoc,
			d = this.parseExprOp(
				this.parseMaybeUnary(null, !1, !1, i),
				u,
				c,
				o,
				i,
			),
			f = this.buildBinary(e, n, t, d, l, s || a);
		return (
			((s && this.type === L.coalesce) ||
				(a &&
					(this.type === L.logicalOR ||
						this.type === L.logicalAND))) &&
				this.raiseRecoverable(
					this.start,
					"Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses",
				),
			this.parseExprOp(f, e, n, r, i)
		);
	}
	return t;
};
ct.buildBinary = function (t, e, n, r, i, o) {
	r.type === "PrivateIdentifier" &&
		this.raise(
			r.start,
			"Private identifier can only be left side of binary expression",
		);
	var s = this.startNodeAt(t, e);
	return (
		(s.left = n),
		(s.operator = i),
		(s.right = r),
		this.finishNode(s, o ? "LogicalExpression" : "BinaryExpression")
	);
};
ct.parseMaybeUnary = function (t, e, n, r) {
	var i = this.start,
		o = this.startLoc,
		s;
	if (this.isContextual("await") && this.canAwait)
		(s = this.parseAwait(r)), (e = !0);
	else if (this.type.prefix) {
		var a = this.startNode(),
			l = this.type === L.incDec;
		(a.operator = this.value),
			(a.prefix = !0),
			this.next(),
			(a.argument = this.parseMaybeUnary(null, !0, l, r)),
			this.checkExpressionErrors(t, !0),
			l
				? this.checkLValSimple(a.argument)
				: this.strict && a.operator === "delete" && gY(a.argument)
					? this.raiseRecoverable(
							a.start,
							"Deleting local variable in strict mode",
						)
					: a.operator === "delete" && vE(a.argument)
						? this.raiseRecoverable(
								a.start,
								"Private fields can not be deleted",
							)
						: (e = !0),
			(s = this.finishNode(
				a,
				l ? "UpdateExpression" : "UnaryExpression",
			));
	} else if (!e && this.type === L.privateId)
		(r || this.privateNameStack.length === 0) &&
			this.options.checkPrivateFields &&
			this.unexpected(),
			(s = this.parsePrivateIdent()),
			this.type !== L._in && this.unexpected();
	else {
		if (
			((s = this.parseExprSubscripts(t, r)),
			this.checkExpressionErrors(t))
		)
			return s;
		for (; this.type.postfix && !this.canInsertSemicolon(); ) {
			var u = this.startNodeAt(i, o);
			(u.operator = this.value),
				(u.prefix = !1),
				(u.argument = s),
				this.checkLValSimple(s),
				this.next(),
				(s = this.finishNode(u, "UpdateExpression"));
		}
	}
	if (!n && this.eat(L.starstar))
		if (e) this.unexpected(this.lastTokStart);
		else
			return this.buildBinary(
				i,
				o,
				s,
				this.parseMaybeUnary(null, !1, !1, r),
				"**",
				!1,
			);
	else return s;
};
function gY(t) {
	return (
		t.type === "Identifier" ||
		(t.type === "ParenthesizedExpression" && gY(t.expression))
	);
}
function vE(t) {
	return (
		(t.type === "MemberExpression" &&
			t.property.type === "PrivateIdentifier") ||
		(t.type === "ChainExpression" && vE(t.expression)) ||
		(t.type === "ParenthesizedExpression" && vE(t.expression))
	);
}
ct.parseExprSubscripts = function (t, e) {
	var n = this.start,
		r = this.startLoc,
		i = this.parseExprAtom(t, e);
	if (
		i.type === "ArrowFunctionExpression" &&
		this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")"
	)
		return i;
	var o = this.parseSubscripts(i, n, r, !1, e);
	return (
		t &&
			o.type === "MemberExpression" &&
			(t.parenthesizedAssign >= o.start && (t.parenthesizedAssign = -1),
			t.parenthesizedBind >= o.start && (t.parenthesizedBind = -1),
			t.trailingComma >= o.start && (t.trailingComma = -1)),
		o
	);
};
ct.parseSubscripts = function (t, e, n, r, i) {
	for (
		var o =
				this.options.ecmaVersion >= 8 &&
				t.type === "Identifier" &&
				t.name === "async" &&
				this.lastTokEnd === t.end &&
				!this.canInsertSemicolon() &&
				t.end - t.start === 5 &&
				this.potentialArrowAt === t.start,
			s = !1;
		;

	) {
		var a = this.parseSubscript(t, e, n, r, o, s, i);
		if (
			(a.optional && (s = !0),
			a === t || a.type === "ArrowFunctionExpression")
		) {
			if (s) {
				var l = this.startNodeAt(e, n);
				(l.expression = a), (a = this.finishNode(l, "ChainExpression"));
			}
			return a;
		}
		t = a;
	}
};
ct.shouldParseAsyncArrow = function () {
	return !this.canInsertSemicolon() && this.eat(L.arrow);
};
ct.parseSubscriptAsyncArrow = function (t, e, n, r) {
	return this.parseArrowExpression(this.startNodeAt(t, e), n, !0, r);
};
ct.parseSubscript = function (t, e, n, r, i, o, s) {
	var a = this.options.ecmaVersion >= 11,
		l = a && this.eat(L.questionDot);
	r &&
		l &&
		this.raise(
			this.lastTokStart,
			"Optional chaining cannot appear in the callee of new expressions",
		);
	var u = this.eat(L.bracketL);
	if (
		u ||
		(l && this.type !== L.parenL && this.type !== L.backQuote) ||
		this.eat(L.dot)
	) {
		var c = this.startNodeAt(e, n);
		(c.object = t),
			u
				? ((c.property = this.parseExpression()),
					this.expect(L.bracketR))
				: this.type === L.privateId && t.type !== "Super"
					? (c.property = this.parsePrivateIdent())
					: (c.property = this.parseIdent(
							this.options.allowReserved !== "never",
						)),
			(c.computed = !!u),
			a && (c.optional = l),
			(t = this.finishNode(c, "MemberExpression"));
	} else if (!r && this.eat(L.parenL)) {
		var d = new V3(),
			f = this.yieldPos,
			h = this.awaitPos,
			p = this.awaitIdentPos;
		(this.yieldPos = 0), (this.awaitPos = 0), (this.awaitIdentPos = 0);
		var g = this.parseExprList(
			L.parenR,
			this.options.ecmaVersion >= 8,
			!1,
			d,
		);
		if (i && !l && this.shouldParseAsyncArrow())
			return (
				this.checkPatternErrors(d, !1),
				this.checkYieldAwaitInDefaultParams(),
				this.awaitIdentPos > 0 &&
					this.raise(
						this.awaitIdentPos,
						"Cannot use 'await' as identifier inside an async function",
					),
				(this.yieldPos = f),
				(this.awaitPos = h),
				(this.awaitIdentPos = p),
				this.parseSubscriptAsyncArrow(e, n, g, s)
			);
		this.checkExpressionErrors(d, !0),
			(this.yieldPos = f || this.yieldPos),
			(this.awaitPos = h || this.awaitPos),
			(this.awaitIdentPos = p || this.awaitIdentPos);
		var v = this.startNodeAt(e, n);
		(v.callee = t),
			(v.arguments = g),
			a && (v.optional = l),
			(t = this.finishNode(v, "CallExpression"));
	} else if (this.type === L.backQuote) {
		(l || o) &&
			this.raise(
				this.start,
				"Optional chaining cannot appear in the tag of tagged template expressions",
			);
		var b = this.startNodeAt(e, n);
		(b.tag = t),
			(b.quasi = this.parseTemplate({ isTagged: !0 })),
			(t = this.finishNode(b, "TaggedTemplateExpression"));
	}
	return t;
};
ct.parseExprAtom = function (t, e, n) {
	this.type === L.slash && this.readRegexp();
	var r,
		i = this.potentialArrowAt === this.start;
	switch (this.type) {
		case L._super:
			return (
				this.allowSuper ||
					this.raise(this.start, "'super' keyword outside a method"),
				(r = this.startNode()),
				this.next(),
				this.type === L.parenL &&
					!this.allowDirectSuper &&
					this.raise(
						r.start,
						"super() call outside constructor of a subclass",
					),
				this.type !== L.dot &&
					this.type !== L.bracketL &&
					this.type !== L.parenL &&
					this.unexpected(),
				this.finishNode(r, "Super")
			);
		case L._this:
			return (
				(r = this.startNode()),
				this.next(),
				this.finishNode(r, "ThisExpression")
			);
		case L.name:
			var o = this.start,
				s = this.startLoc,
				a = this.containsEsc,
				l = this.parseIdent(!1);
			if (
				this.options.ecmaVersion >= 8 &&
				!a &&
				l.name === "async" &&
				!this.canInsertSemicolon() &&
				this.eat(L._function)
			)
				return (
					this.overrideContext(sn.f_expr),
					this.parseFunction(this.startNodeAt(o, s), 0, !1, !0, e)
				);
			if (i && !this.canInsertSemicolon()) {
				if (this.eat(L.arrow))
					return this.parseArrowExpression(
						this.startNodeAt(o, s),
						[l],
						!1,
						e,
					);
				if (
					this.options.ecmaVersion >= 8 &&
					l.name === "async" &&
					this.type === L.name &&
					!a &&
					(!this.potentialArrowInForAwait ||
						this.value !== "of" ||
						this.containsEsc)
				)
					return (
						(l = this.parseIdent(!1)),
						(this.canInsertSemicolon() || !this.eat(L.arrow)) &&
							this.unexpected(),
						this.parseArrowExpression(
							this.startNodeAt(o, s),
							[l],
							!0,
							e,
						)
					);
			}
			return l;
		case L.regexp:
			var u = this.value;
			return (
				(r = this.parseLiteral(u.value)),
				(r.regex = { pattern: u.pattern, flags: u.flags }),
				r
			);
		case L.num:
		case L.string:
			return this.parseLiteral(this.value);
		case L._null:
		case L._true:
		case L._false:
			return (
				(r = this.startNode()),
				(r.value =
					this.type === L._null ? null : this.type === L._true),
				(r.raw = this.type.keyword),
				this.next(),
				this.finishNode(r, "Literal")
			);
		case L.parenL:
			var c = this.start,
				d = this.parseParenAndDistinguishExpression(i, e);
			return (
				t &&
					(t.parenthesizedAssign < 0 &&
						!this.isSimpleAssignTarget(d) &&
						(t.parenthesizedAssign = c),
					t.parenthesizedBind < 0 && (t.parenthesizedBind = c)),
				d
			);
		case L.bracketL:
			return (
				(r = this.startNode()),
				this.next(),
				(r.elements = this.parseExprList(L.bracketR, !0, !0, t)),
				this.finishNode(r, "ArrayExpression")
			);
		case L.braceL:
			return this.overrideContext(sn.b_expr), this.parseObj(!1, t);
		case L._function:
			return (
				(r = this.startNode()), this.next(), this.parseFunction(r, 0)
			);
		case L._class:
			return this.parseClass(this.startNode(), !1);
		case L._new:
			return this.parseNew();
		case L.backQuote:
			return this.parseTemplate();
		case L._import:
			return this.options.ecmaVersion >= 11
				? this.parseExprImport(n)
				: this.unexpected();
		default:
			return this.parseExprAtomDefault();
	}
};
ct.parseExprAtomDefault = function () {
	this.unexpected();
};
ct.parseExprImport = function (t) {
	var e = this.startNode();
	if (
		(this.containsEsc &&
			this.raiseRecoverable(
				this.start,
				"Escape sequence in keyword import",
			),
		this.next(),
		this.type === L.parenL && !t)
	)
		return this.parseDynamicImport(e);
	if (this.type === L.dot) {
		var n = this.startNodeAt(e.start, e.loc && e.loc.start);
		return (
			(n.name = "import"),
			(e.meta = this.finishNode(n, "Identifier")),
			this.parseImportMeta(e)
		);
	} else this.unexpected();
};
ct.parseDynamicImport = function (t) {
	if (
		(this.next(), (t.source = this.parseMaybeAssign()), !this.eat(L.parenR))
	) {
		var e = this.start;
		this.eat(L.comma) && this.eat(L.parenR)
			? this.raiseRecoverable(
					e,
					"Trailing comma is not allowed in import()",
				)
			: this.unexpected(e);
	}
	return this.finishNode(t, "ImportExpression");
};
ct.parseImportMeta = function (t) {
	this.next();
	var e = this.containsEsc;
	return (
		(t.property = this.parseIdent(!0)),
		t.property.name !== "meta" &&
			this.raiseRecoverable(
				t.property.start,
				"The only valid meta property for import is 'import.meta'",
			),
		e &&
			this.raiseRecoverable(
				t.start,
				"'import.meta' must not contain escaped characters",
			),
		this.options.sourceType !== "module" &&
			!this.options.allowImportExportEverywhere &&
			this.raiseRecoverable(
				t.start,
				"Cannot use 'import.meta' outside a module",
			),
		this.finishNode(t, "MetaProperty")
	);
};
ct.parseLiteral = function (t) {
	var e = this.startNode();
	return (
		(e.value = t),
		(e.raw = this.input.slice(this.start, this.end)),
		e.raw.charCodeAt(e.raw.length - 1) === 110 &&
			(e.bigint = e.raw.slice(0, -1).replace(/_/g, "")),
		this.next(),
		this.finishNode(e, "Literal")
	);
};
ct.parseParenExpression = function () {
	this.expect(L.parenL);
	var t = this.parseExpression();
	return this.expect(L.parenR), t;
};
ct.shouldParseArrow = function (t) {
	return !this.canInsertSemicolon();
};
ct.parseParenAndDistinguishExpression = function (t, e) {
	var n = this.start,
		r = this.startLoc,
		i,
		o = this.options.ecmaVersion >= 8;
	if (this.options.ecmaVersion >= 6) {
		this.next();
		var s = this.start,
			a = this.startLoc,
			l = [],
			u = !0,
			c = !1,
			d = new V3(),
			f = this.yieldPos,
			h = this.awaitPos,
			p;
		for (this.yieldPos = 0, this.awaitPos = 0; this.type !== L.parenR; )
			if (
				(u ? (u = !1) : this.expect(L.comma),
				o && this.afterTrailingComma(L.parenR, !0))
			) {
				c = !0;
				break;
			} else if (this.type === L.ellipsis) {
				(p = this.start),
					l.push(this.parseParenItem(this.parseRestBinding())),
					this.type === L.comma &&
						this.raiseRecoverable(
							this.start,
							"Comma is not permitted after the rest element",
						);
				break;
			} else l.push(this.parseMaybeAssign(!1, d, this.parseParenItem));
		var g = this.lastTokEnd,
			v = this.lastTokEndLoc;
		if (
			(this.expect(L.parenR),
			t && this.shouldParseArrow(l) && this.eat(L.arrow))
		)
			return (
				this.checkPatternErrors(d, !1),
				this.checkYieldAwaitInDefaultParams(),
				(this.yieldPos = f),
				(this.awaitPos = h),
				this.parseParenArrowList(n, r, l, e)
			);
		(!l.length || c) && this.unexpected(this.lastTokStart),
			p && this.unexpected(p),
			this.checkExpressionErrors(d, !0),
			(this.yieldPos = f || this.yieldPos),
			(this.awaitPos = h || this.awaitPos),
			l.length > 1
				? ((i = this.startNodeAt(s, a)),
					(i.expressions = l),
					this.finishNodeAt(i, "SequenceExpression", g, v))
				: (i = l[0]);
	} else i = this.parseParenExpression();
	if (this.options.preserveParens) {
		var b = this.startNodeAt(n, r);
		return (
			(b.expression = i), this.finishNode(b, "ParenthesizedExpression")
		);
	} else return i;
};
ct.parseParenItem = function (t) {
	return t;
};
ct.parseParenArrowList = function (t, e, n, r) {
	return this.parseArrowExpression(this.startNodeAt(t, e), n, !1, r);
};
var _6e = [];
ct.parseNew = function () {
	this.containsEsc &&
		this.raiseRecoverable(this.start, "Escape sequence in keyword new");
	var t = this.startNode();
	if ((this.next(), this.options.ecmaVersion >= 6 && this.type === L.dot)) {
		var e = this.startNodeAt(t.start, t.loc && t.loc.start);
		(e.name = "new"),
			(t.meta = this.finishNode(e, "Identifier")),
			this.next();
		var n = this.containsEsc;
		return (
			(t.property = this.parseIdent(!0)),
			t.property.name !== "target" &&
				this.raiseRecoverable(
					t.property.start,
					"The only valid meta property for new is 'new.target'",
				),
			n &&
				this.raiseRecoverable(
					t.start,
					"'new.target' must not contain escaped characters",
				),
			this.allowNewDotTarget ||
				this.raiseRecoverable(
					t.start,
					"'new.target' can only be used in functions and class static block",
				),
			this.finishNode(t, "MetaProperty")
		);
	}
	var r = this.start,
		i = this.startLoc;
	return (
		(t.callee = this.parseSubscripts(
			this.parseExprAtom(null, !1, !0),
			r,
			i,
			!0,
			!1,
		)),
		this.eat(L.parenL)
			? (t.arguments = this.parseExprList(
					L.parenR,
					this.options.ecmaVersion >= 8,
					!1,
				))
			: (t.arguments = _6e),
		this.finishNode(t, "NewExpression")
	);
};
ct.parseTemplateElement = function (t) {
	var e = t.isTagged,
		n = this.startNode();
	return (
		this.type === L.invalidTemplate
			? (e ||
					this.raiseRecoverable(
						this.start,
						"Bad escape sequence in untagged template literal",
					),
				(n.value = {
					raw: this.value.replace(
						/\r\n?/g,
						`
`,
					),
					cooked: null,
				}))
			: (n.value = {
					raw: this.input.slice(this.start, this.end).replace(
						/\r\n?/g,
						`
`,
					),
					cooked: this.value,
				}),
		this.next(),
		(n.tail = this.type === L.backQuote),
		this.finishNode(n, "TemplateElement")
	);
};
ct.parseTemplate = function (t) {
	t === void 0 && (t = {});
	var e = t.isTagged;
	e === void 0 && (e = !1);
	var n = this.startNode();
	this.next(), (n.expressions = []);
	var r = this.parseTemplateElement({ isTagged: e });
	for (n.quasis = [r]; !r.tail; )
		this.type === L.eof &&
			this.raise(this.pos, "Unterminated template literal"),
			this.expect(L.dollarBraceL),
			n.expressions.push(this.parseExpression()),
			this.expect(L.braceR),
			n.quasis.push((r = this.parseTemplateElement({ isTagged: e })));
	return this.next(), this.finishNode(n, "TemplateLiteral");
};
ct.isAsyncProp = function (t) {
	return (
		!t.computed &&
		t.key.type === "Identifier" &&
		t.key.name === "async" &&
		(this.type === L.name ||
			this.type === L.num ||
			this.type === L.string ||
			this.type === L.bracketL ||
			this.type.keyword ||
			(this.options.ecmaVersion >= 9 && this.type === L.star)) &&
		!yo.test(this.input.slice(this.lastTokEnd, this.start))
	);
};
ct.parseObj = function (t, e) {
	var n = this.startNode(),
		r = !0,
		i = {};
	for (n.properties = [], this.next(); !this.eat(L.braceR); ) {
		if (r) r = !1;
		else if (
			(this.expect(L.comma),
			this.options.ecmaVersion >= 5 && this.afterTrailingComma(L.braceR))
		)
			break;
		var o = this.parseProperty(t, e);
		t || this.checkPropClash(o, i, e), n.properties.push(o);
	}
	return this.finishNode(n, t ? "ObjectPattern" : "ObjectExpression");
};
ct.parseProperty = function (t, e) {
	var n = this.startNode(),
		r,
		i,
		o,
		s;
	if (this.options.ecmaVersion >= 9 && this.eat(L.ellipsis))
		return t
			? ((n.argument = this.parseIdent(!1)),
				this.type === L.comma &&
					this.raiseRecoverable(
						this.start,
						"Comma is not permitted after the rest element",
					),
				this.finishNode(n, "RestElement"))
			: ((n.argument = this.parseMaybeAssign(!1, e)),
				this.type === L.comma &&
					e &&
					e.trailingComma < 0 &&
					(e.trailingComma = this.start),
				this.finishNode(n, "SpreadElement"));
	this.options.ecmaVersion >= 6 &&
		((n.method = !1),
		(n.shorthand = !1),
		(t || e) && ((o = this.start), (s = this.startLoc)),
		t || (r = this.eat(L.star)));
	var a = this.containsEsc;
	return (
		this.parsePropertyName(n),
		!t && !a && this.options.ecmaVersion >= 8 && !r && this.isAsyncProp(n)
			? ((i = !0),
				(r = this.options.ecmaVersion >= 9 && this.eat(L.star)),
				this.parsePropertyName(n))
			: (i = !1),
		this.parsePropertyValue(n, t, r, i, o, s, e, a),
		this.finishNode(n, "Property")
	);
};
ct.parseGetterSetter = function (t) {
	(t.kind = t.key.name),
		this.parsePropertyName(t),
		(t.value = this.parseMethod(!1));
	var e = t.kind === "get" ? 0 : 1;
	if (t.value.params.length !== e) {
		var n = t.value.start;
		t.kind === "get"
			? this.raiseRecoverable(n, "getter should have no params")
			: this.raiseRecoverable(n, "setter should have exactly one param");
	} else
		t.kind === "set" &&
			t.value.params[0].type === "RestElement" &&
			this.raiseRecoverable(
				t.value.params[0].start,
				"Setter cannot use rest params",
			);
};
ct.parsePropertyValue = function (t, e, n, r, i, o, s, a) {
	(n || r) && this.type === L.colon && this.unexpected(),
		this.eat(L.colon)
			? ((t.value = e
					? this.parseMaybeDefault(this.start, this.startLoc)
					: this.parseMaybeAssign(!1, s)),
				(t.kind = "init"))
			: this.options.ecmaVersion >= 6 && this.type === L.parenL
				? (e && this.unexpected(),
					(t.kind = "init"),
					(t.method = !0),
					(t.value = this.parseMethod(n, r)))
				: !e &&
					  !a &&
					  this.options.ecmaVersion >= 5 &&
					  !t.computed &&
					  t.key.type === "Identifier" &&
					  (t.key.name === "get" || t.key.name === "set") &&
					  this.type !== L.comma &&
					  this.type !== L.braceR &&
					  this.type !== L.eq
					? ((n || r) && this.unexpected(), this.parseGetterSetter(t))
					: this.options.ecmaVersion >= 6 &&
						  !t.computed &&
						  t.key.type === "Identifier"
						? ((n || r) && this.unexpected(),
							this.checkUnreserved(t.key),
							t.key.name === "await" &&
								!this.awaitIdentPos &&
								(this.awaitIdentPos = i),
							(t.kind = "init"),
							e
								? (t.value = this.parseMaybeDefault(
										i,
										o,
										this.copyNode(t.key),
									))
								: this.type === L.eq && s
									? (s.shorthandAssign < 0 &&
											(s.shorthandAssign = this.start),
										(t.value = this.parseMaybeDefault(
											i,
											o,
											this.copyNode(t.key),
										)))
									: (t.value = this.copyNode(t.key)),
							(t.shorthand = !0))
						: this.unexpected();
};
ct.parsePropertyName = function (t) {
	if (this.options.ecmaVersion >= 6) {
		if (this.eat(L.bracketL))
			return (
				(t.computed = !0),
				(t.key = this.parseMaybeAssign()),
				this.expect(L.bracketR),
				t.key
			);
		t.computed = !1;
	}
	return (t.key =
		this.type === L.num || this.type === L.string
			? this.parseExprAtom()
			: this.parseIdent(this.options.allowReserved !== "never"));
};
ct.initFunction = function (t) {
	(t.id = null),
		this.options.ecmaVersion >= 6 && (t.generator = t.expression = !1),
		this.options.ecmaVersion >= 8 && (t.async = !1);
};
ct.parseMethod = function (t, e, n) {
	var r = this.startNode(),
		i = this.yieldPos,
		o = this.awaitPos,
		s = this.awaitIdentPos;
	return (
		this.initFunction(r),
		this.options.ecmaVersion >= 6 && (r.generator = t),
		this.options.ecmaVersion >= 8 && (r.async = !!e),
		(this.yieldPos = 0),
		(this.awaitPos = 0),
		(this.awaitIdentPos = 0),
		this.enterScope(iA(e, r.generator) | nA | (n ? dY : 0)),
		this.expect(L.parenL),
		(r.params = this.parseBindingList(
			L.parenR,
			!1,
			this.options.ecmaVersion >= 8,
		)),
		this.checkYieldAwaitInDefaultParams(),
		this.parseFunctionBody(r, !1, !0, !1),
		(this.yieldPos = i),
		(this.awaitPos = o),
		(this.awaitIdentPos = s),
		this.finishNode(r, "FunctionExpression")
	);
};
ct.parseArrowExpression = function (t, e, n, r) {
	var i = this.yieldPos,
		o = this.awaitPos,
		s = this.awaitIdentPos;
	return (
		this.enterScope(iA(n, !1) | uY),
		this.initFunction(t),
		this.options.ecmaVersion >= 8 && (t.async = !!n),
		(this.yieldPos = 0),
		(this.awaitPos = 0),
		(this.awaitIdentPos = 0),
		(t.params = this.toAssignableList(e, !0)),
		this.parseFunctionBody(t, !0, !1, r),
		(this.yieldPos = i),
		(this.awaitPos = o),
		(this.awaitIdentPos = s),
		this.finishNode(t, "ArrowFunctionExpression")
	);
};
ct.parseFunctionBody = function (t, e, n, r) {
	var i = e && this.type !== L.braceL,
		o = this.strict,
		s = !1;
	if (i)
		(t.body = this.parseMaybeAssign(r)),
			(t.expression = !0),
			this.checkParams(t, !1);
	else {
		var a =
			this.options.ecmaVersion >= 7 && !this.isSimpleParamList(t.params);
		(!o || a) &&
			((s = this.strictDirective(this.end)),
			s &&
				a &&
				this.raiseRecoverable(
					t.start,
					"Illegal 'use strict' directive in function with non-simple parameter list",
				));
		var l = this.labels;
		(this.labels = []),
			s && (this.strict = !0),
			this.checkParams(
				t,
				!o && !s && !e && !n && this.isSimpleParamList(t.params),
			),
			this.strict && t.id && this.checkLValSimple(t.id, pY),
			(t.body = this.parseBlock(!1, void 0, s && !o)),
			(t.expression = !1),
			this.adaptDirectivePrologue(t.body.body),
			(this.labels = l);
	}
	this.exitScope();
};
ct.isSimpleParamList = function (t) {
	for (var e = 0, n = t; e < n.length; e += 1) {
		var r = n[e];
		if (r.type !== "Identifier") return !1;
	}
	return !0;
};
ct.checkParams = function (t, e) {
	for (
		var n = Object.create(null), r = 0, i = t.params;
		r < i.length;
		r += 1
	) {
		var o = i[r];
		this.checkLValInnerPattern(o, oA, e ? null : n);
	}
};
ct.parseExprList = function (t, e, n, r) {
	for (var i = [], o = !0; !this.eat(t); ) {
		if (o) o = !1;
		else if ((this.expect(L.comma), e && this.afterTrailingComma(t))) break;
		var s = void 0;
		n && this.type === L.comma
			? (s = null)
			: this.type === L.ellipsis
				? ((s = this.parseSpread(r)),
					r &&
						this.type === L.comma &&
						r.trailingComma < 0 &&
						(r.trailingComma = this.start))
				: (s = this.parseMaybeAssign(!1, r)),
			i.push(s);
	}
	return i;
};
ct.checkUnreserved = function (t) {
	var e = t.start,
		n = t.end,
		r = t.name;
	if (
		(this.inGenerator &&
			r === "yield" &&
			this.raiseRecoverable(
				e,
				"Cannot use 'yield' as identifier inside a generator",
			),
		this.inAsync &&
			r === "await" &&
			this.raiseRecoverable(
				e,
				"Cannot use 'await' as identifier inside an async function",
			),
		this.currentThisScope().inClassFieldInit &&
			r === "arguments" &&
			this.raiseRecoverable(
				e,
				"Cannot use 'arguments' in class field initializer",
			),
		this.inClassStaticBlock &&
			(r === "arguments" || r === "await") &&
			this.raise(
				e,
				"Cannot use " + r + " in class static initialization block",
			),
		this.keywords.test(r) &&
			this.raise(e, "Unexpected keyword '" + r + "'"),
		!(
			this.options.ecmaVersion < 6 &&
			this.input.slice(e, n).indexOf("\\") !== -1
		))
	) {
		var i = this.strict ? this.reservedWordsStrict : this.reservedWords;
		i.test(r) &&
			(!this.inAsync &&
				r === "await" &&
				this.raiseRecoverable(
					e,
					"Cannot use keyword 'await' outside an async function",
				),
			this.raiseRecoverable(e, "The keyword '" + r + "' is reserved"));
	}
};
ct.parseIdent = function (t) {
	var e = this.parseIdentNode();
	return (
		this.next(!!t),
		this.finishNode(e, "Identifier"),
		t ||
			(this.checkUnreserved(e),
			e.name === "await" &&
				!this.awaitIdentPos &&
				(this.awaitIdentPos = e.start)),
		e
	);
};
ct.parseIdentNode = function () {
	var t = this.startNode();
	return (
		this.type === L.name
			? (t.name = this.value)
			: this.type.keyword
				? ((t.name = this.type.keyword),
					(t.name === "class" || t.name === "function") &&
						(this.lastTokEnd !== this.lastTokStart + 1 ||
							this.input.charCodeAt(this.lastTokStart) !== 46) &&
						this.context.pop(),
					(this.type = L.name))
				: this.unexpected(),
		t
	);
};
ct.parsePrivateIdent = function () {
	var t = this.startNode();
	return (
		this.type === L.privateId ? (t.name = this.value) : this.unexpected(),
		this.next(),
		this.finishNode(t, "PrivateIdentifier"),
		this.options.checkPrivateFields &&
			(this.privateNameStack.length === 0
				? this.raise(
						t.start,
						"Private field '#" +
							t.name +
							"' must be declared in an enclosing class",
					)
				: this.privateNameStack[
						this.privateNameStack.length - 1
					].used.push(t)),
		t
	);
};
ct.parseYield = function (t) {
	this.yieldPos || (this.yieldPos = this.start);
	var e = this.startNode();
	return (
		this.next(),
		this.type === L.semi ||
		this.canInsertSemicolon() ||
		(this.type !== L.star && !this.type.startsExpr)
			? ((e.delegate = !1), (e.argument = null))
			: ((e.delegate = this.eat(L.star)),
				(e.argument = this.parseMaybeAssign(t))),
		this.finishNode(e, "YieldExpression")
	);
};
ct.parseAwait = function (t) {
	this.awaitPos || (this.awaitPos = this.start);
	var e = this.startNode();
	return (
		this.next(),
		(e.argument = this.parseMaybeUnary(null, !0, !1, t)),
		this.finishNode(e, "AwaitExpression")
	);
};
var jy = kn.prototype;
jy.raise = function (t, e) {
	var n = eA(this.input, t);
	e += " (" + n.line + ":" + n.column + ")";
	var r = new SyntaxError(e);
	throw ((r.pos = t), (r.loc = n), (r.raisedAt = this.pos), r);
};
jy.raiseRecoverable = jy.raise;
jy.curPosition = function () {
	if (this.options.locations)
		return new _h(this.curLine, this.pos - this.lineStart);
};
var ac = kn.prototype,
	z6e = function (e) {
		(this.flags = e),
			(this.var = []),
			(this.lexical = []),
			(this.functions = []),
			(this.inClassFieldInit = !1);
	};
ac.enterScope = function (t) {
	this.scopeStack.push(new z6e(t));
};
ac.exitScope = function () {
	this.scopeStack.pop();
};
ac.treatFunctionsAsVarInScope = function (t) {
	return t.flags & bp || (!this.inModule && t.flags & Mg);
};
ac.declareName = function (t, e, n) {
	var r = !1;
	if (e === Ml) {
		var i = this.currentScope();
		(r =
			i.lexical.indexOf(t) > -1 ||
			i.functions.indexOf(t) > -1 ||
			i.var.indexOf(t) > -1),
			i.lexical.push(t),
			this.inModule && i.flags & Mg && delete this.undefinedExports[t];
	} else if (e === hY) {
		var o = this.currentScope();
		o.lexical.push(t);
	} else if (e === fY) {
		var s = this.currentScope();
		this.treatFunctionsAsVar
			? (r = s.lexical.indexOf(t) > -1)
			: (r = s.lexical.indexOf(t) > -1 || s.var.indexOf(t) > -1),
			s.functions.push(t);
	} else
		for (var a = this.scopeStack.length - 1; a >= 0; --a) {
			var l = this.scopeStack[a];
			if (
				(l.lexical.indexOf(t) > -1 &&
					!(l.flags & cY && l.lexical[0] === t)) ||
				(!this.treatFunctionsAsVarInScope(l) &&
					l.functions.indexOf(t) > -1)
			) {
				r = !0;
				break;
			}
			if (
				(l.var.push(t),
				this.inModule &&
					l.flags & Mg &&
					delete this.undefinedExports[t],
				l.flags & rA)
			)
				break;
		}
	r &&
		this.raiseRecoverable(
			n,
			"Identifier '" + t + "' has already been declared",
		);
};
ac.checkLocalExport = function (t) {
	this.scopeStack[0].lexical.indexOf(t.name) === -1 &&
		this.scopeStack[0].var.indexOf(t.name) === -1 &&
		(this.undefinedExports[t.name] = t);
};
ac.currentScope = function () {
	return this.scopeStack[this.scopeStack.length - 1];
};
ac.currentVarScope = function () {
	for (var t = this.scopeStack.length - 1; ; t--) {
		var e = this.scopeStack[t];
		if (e.flags & rA) return e;
	}
};
ac.currentThisScope = function () {
	for (var t = this.scopeStack.length - 1; ; t--) {
		var e = this.scopeStack[t];
		if (e.flags & rA && !(e.flags & uY)) return e;
	}
};
var Y0 = function (e, n, r) {
		(this.type = ""),
			(this.start = n),
			(this.end = 0),
			e.options.locations && (this.loc = new q0(e, r)),
			e.options.directSourceFile &&
				(this.sourceFile = e.options.directSourceFile),
			e.options.ranges && (this.range = [n, 0]);
	},
	J0 = kn.prototype;
J0.startNode = function () {
	return new Y0(this, this.start, this.startLoc);
};
J0.startNodeAt = function (t, e) {
	return new Y0(this, t, e);
};
function bY(t, e, n, r) {
	return (
		(t.type = e),
		(t.end = n),
		this.options.locations && (t.loc.end = r),
		this.options.ranges && (t.range[1] = n),
		t
	);
}
J0.finishNode = function (t, e) {
	return bY.call(this, t, e, this.lastTokEnd, this.lastTokEndLoc);
};
J0.finishNodeAt = function (t, e, n, r) {
	return bY.call(this, t, e, n, r);
};
J0.copyNode = function (t) {
	var e = new Y0(this, t.start, this.startLoc);
	for (var n in t) e[n] = t[n];
	return e;
};
var vY =
		"ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS",
	yY = vY + " Extended_Pictographic",
	xY = yY,
	kY = xY + " EBase EComp EMod EPres ExtPict",
	CY = kY,
	L6e = CY,
	V6e = { 9: vY, 10: yY, 11: xY, 12: kY, 13: CY, 14: L6e },
	K6e =
		"Basic_Emoji Emoji_Keycap_Sequence RGI_Emoji_Modifier_Sequence RGI_Emoji_Flag_Sequence RGI_Emoji_Tag_Sequence RGI_Emoji_ZWJ_Sequence RGI_Emoji",
	U6e = { 9: "", 10: "", 11: "", 12: "", 13: "", 14: K6e },
	vF =
		"Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu",
	wY =
		"Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb",
	EY =
		wY +
		" Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd",
	DY =
		EY +
		" Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho",
	SY =
		DY +
		" Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi",
	AY =
		SY +
		" Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith",
	H6e = AY + " Hrkt Katakana_Or_Hiragana Kawi Nag_Mundari Nagm Unknown Zzzz",
	W6e = { 9: wY, 10: EY, 11: DY, 12: SY, 13: AY, 14: H6e },
	$Y = {};
function q6e(t) {
	var e = ($Y[t] = {
		binary: Cu(V6e[t] + " " + vF),
		binaryOfStrings: Cu(U6e[t]),
		nonBinary: { General_Category: Cu(vF), Script: Cu(W6e[t]) },
	});
	(e.nonBinary.Script_Extensions = e.nonBinary.Script),
		(e.nonBinary.gc = e.nonBinary.General_Category),
		(e.nonBinary.sc = e.nonBinary.Script),
		(e.nonBinary.scx = e.nonBinary.Script_Extensions);
}
for (var CC = 0, yF = [9, 10, 11, 12, 13, 14]; CC < yF.length; CC += 1) {
	var G6e = yF[CC];
	q6e(G6e);
}
var Ve = kn.prototype,
	_y = function (e, n) {
		(this.parent = e), (this.base = n || this);
	};
_y.prototype.separatedFrom = function (e) {
	for (var n = this; n; n = n.parent)
		for (var r = e; r; r = r.parent)
			if (n.base === r.base && n !== r) return !0;
	return !1;
};
_y.prototype.sibling = function () {
	return new _y(this.parent, this.base);
};
var Ta = function (e) {
	(this.parser = e),
		(this.validFlags =
			"gim" +
			(e.options.ecmaVersion >= 6 ? "uy" : "") +
			(e.options.ecmaVersion >= 9 ? "s" : "") +
			(e.options.ecmaVersion >= 13 ? "d" : "") +
			(e.options.ecmaVersion >= 15 ? "v" : "")),
		(this.unicodeProperties =
			$Y[e.options.ecmaVersion >= 14 ? 14 : e.options.ecmaVersion]),
		(this.source = ""),
		(this.flags = ""),
		(this.start = 0),
		(this.switchU = !1),
		(this.switchV = !1),
		(this.switchN = !1),
		(this.pos = 0),
		(this.lastIntValue = 0),
		(this.lastStringValue = ""),
		(this.lastAssertionIsQuantifiable = !1),
		(this.numCapturingParens = 0),
		(this.maxBackReference = 0),
		(this.groupNames = Object.create(null)),
		(this.backReferenceNames = []),
		(this.branchID = null);
};
Ta.prototype.reset = function (e, n, r) {
	var i = r.indexOf("v") !== -1,
		o = r.indexOf("u") !== -1;
	(this.start = e | 0),
		(this.source = n + ""),
		(this.flags = r),
		i && this.parser.options.ecmaVersion >= 15
			? ((this.switchU = !0), (this.switchV = !0), (this.switchN = !0))
			: ((this.switchU = o && this.parser.options.ecmaVersion >= 6),
				(this.switchV = !1),
				(this.switchN = o && this.parser.options.ecmaVersion >= 9));
};
Ta.prototype.raise = function (e) {
	this.parser.raiseRecoverable(
		this.start,
		"Invalid regular expression: /" + this.source + "/: " + e,
	);
};
Ta.prototype.at = function (e, n) {
	n === void 0 && (n = !1);
	var r = this.source,
		i = r.length;
	if (e >= i) return -1;
	var o = r.charCodeAt(e);
	if (!(n || this.switchU) || o <= 55295 || o >= 57344 || e + 1 >= i)
		return o;
	var s = r.charCodeAt(e + 1);
	return s >= 56320 && s <= 57343 ? (o << 10) + s - 56613888 : o;
};
Ta.prototype.nextIndex = function (e, n) {
	n === void 0 && (n = !1);
	var r = this.source,
		i = r.length;
	if (e >= i) return i;
	var o = r.charCodeAt(e),
		s;
	return !(n || this.switchU) ||
		o <= 55295 ||
		o >= 57344 ||
		e + 1 >= i ||
		(s = r.charCodeAt(e + 1)) < 56320 ||
		s > 57343
		? e + 1
		: e + 2;
};
Ta.prototype.current = function (e) {
	return e === void 0 && (e = !1), this.at(this.pos, e);
};
Ta.prototype.lookahead = function (e) {
	return e === void 0 && (e = !1), this.at(this.nextIndex(this.pos, e), e);
};
Ta.prototype.advance = function (e) {
	e === void 0 && (e = !1), (this.pos = this.nextIndex(this.pos, e));
};
Ta.prototype.eat = function (e, n) {
	return (
		n === void 0 && (n = !1),
		this.current(n) === e ? (this.advance(n), !0) : !1
	);
};
Ta.prototype.eatChars = function (e, n) {
	n === void 0 && (n = !1);
	for (var r = this.pos, i = 0, o = e; i < o.length; i += 1) {
		var s = o[i],
			a = this.at(r, n);
		if (a === -1 || a !== s) return !1;
		r = this.nextIndex(r, n);
	}
	return (this.pos = r), !0;
};
Ve.validateRegExpFlags = function (t) {
	for (
		var e = t.validFlags, n = t.flags, r = !1, i = !1, o = 0;
		o < n.length;
		o++
	) {
		var s = n.charAt(o);
		e.indexOf(s) === -1 &&
			this.raise(t.start, "Invalid regular expression flag"),
			n.indexOf(s, o + 1) > -1 &&
				this.raise(t.start, "Duplicate regular expression flag"),
			s === "u" && (r = !0),
			s === "v" && (i = !0);
	}
	this.options.ecmaVersion >= 15 &&
		r &&
		i &&
		this.raise(t.start, "Invalid regular expression flag");
};
function Y6e(t) {
	for (var e in t) return !0;
	return !1;
}
Ve.validateRegExpPattern = function (t) {
	this.regexp_pattern(t),
		!t.switchN &&
			this.options.ecmaVersion >= 9 &&
			Y6e(t.groupNames) &&
			((t.switchN = !0), this.regexp_pattern(t));
};
Ve.regexp_pattern = function (t) {
	(t.pos = 0),
		(t.lastIntValue = 0),
		(t.lastStringValue = ""),
		(t.lastAssertionIsQuantifiable = !1),
		(t.numCapturingParens = 0),
		(t.maxBackReference = 0),
		(t.groupNames = Object.create(null)),
		(t.backReferenceNames.length = 0),
		(t.branchID = null),
		this.regexp_disjunction(t),
		t.pos !== t.source.length &&
			(t.eat(41) && t.raise("Unmatched ')'"),
			(t.eat(93) || t.eat(125)) && t.raise("Lone quantifier brackets")),
		t.maxBackReference > t.numCapturingParens && t.raise("Invalid escape");
	for (var e = 0, n = t.backReferenceNames; e < n.length; e += 1) {
		var r = n[e];
		t.groupNames[r] || t.raise("Invalid named capture referenced");
	}
};
Ve.regexp_disjunction = function (t) {
	var e = this.options.ecmaVersion >= 16;
	for (
		e && (t.branchID = new _y(t.branchID, null)),
			this.regexp_alternative(t);
		t.eat(124);

	)
		e && (t.branchID = t.branchID.sibling()), this.regexp_alternative(t);
	e && (t.branchID = t.branchID.parent),
		this.regexp_eatQuantifier(t, !0) && t.raise("Nothing to repeat"),
		t.eat(123) && t.raise("Lone quantifier brackets");
};
Ve.regexp_alternative = function (t) {
	for (; t.pos < t.source.length && this.regexp_eatTerm(t); );
};
Ve.regexp_eatTerm = function (t) {
	return this.regexp_eatAssertion(t)
		? (t.lastAssertionIsQuantifiable &&
				this.regexp_eatQuantifier(t) &&
				t.switchU &&
				t.raise("Invalid quantifier"),
			!0)
		: (t.switchU ? this.regexp_eatAtom(t) : this.regexp_eatExtendedAtom(t))
			? (this.regexp_eatQuantifier(t), !0)
			: !1;
};
Ve.regexp_eatAssertion = function (t) {
	var e = t.pos;
	if (((t.lastAssertionIsQuantifiable = !1), t.eat(94) || t.eat(36)))
		return !0;
	if (t.eat(92)) {
		if (t.eat(66) || t.eat(98)) return !0;
		t.pos = e;
	}
	if (t.eat(40) && t.eat(63)) {
		var n = !1;
		if (
			(this.options.ecmaVersion >= 9 && (n = t.eat(60)),
			t.eat(61) || t.eat(33))
		)
			return (
				this.regexp_disjunction(t),
				t.eat(41) || t.raise("Unterminated group"),
				(t.lastAssertionIsQuantifiable = !n),
				!0
			);
	}
	return (t.pos = e), !1;
};
Ve.regexp_eatQuantifier = function (t, e) {
	return (
		e === void 0 && (e = !1),
		this.regexp_eatQuantifierPrefix(t, e) ? (t.eat(63), !0) : !1
	);
};
Ve.regexp_eatQuantifierPrefix = function (t, e) {
	return (
		t.eat(42) ||
		t.eat(43) ||
		t.eat(63) ||
		this.regexp_eatBracedQuantifier(t, e)
	);
};
Ve.regexp_eatBracedQuantifier = function (t, e) {
	var n = t.pos;
	if (t.eat(123)) {
		var r = 0,
			i = -1;
		if (
			this.regexp_eatDecimalDigits(t) &&
			((r = t.lastIntValue),
			t.eat(44) &&
				this.regexp_eatDecimalDigits(t) &&
				(i = t.lastIntValue),
			t.eat(125))
		)
			return (
				i !== -1 &&
					i < r &&
					!e &&
					t.raise("numbers out of order in {} quantifier"),
				!0
			);
		t.switchU && !e && t.raise("Incomplete quantifier"), (t.pos = n);
	}
	return !1;
};
Ve.regexp_eatAtom = function (t) {
	return (
		this.regexp_eatPatternCharacters(t) ||
		t.eat(46) ||
		this.regexp_eatReverseSolidusAtomEscape(t) ||
		this.regexp_eatCharacterClass(t) ||
		this.regexp_eatUncapturingGroup(t) ||
		this.regexp_eatCapturingGroup(t)
	);
};
Ve.regexp_eatReverseSolidusAtomEscape = function (t) {
	var e = t.pos;
	if (t.eat(92)) {
		if (this.regexp_eatAtomEscape(t)) return !0;
		t.pos = e;
	}
	return !1;
};
Ve.regexp_eatUncapturingGroup = function (t) {
	var e = t.pos;
	if (t.eat(40)) {
		if (t.eat(63) && t.eat(58)) {
			if ((this.regexp_disjunction(t), t.eat(41))) return !0;
			t.raise("Unterminated group");
		}
		t.pos = e;
	}
	return !1;
};
Ve.regexp_eatCapturingGroup = function (t) {
	if (t.eat(40)) {
		if (
			(this.options.ecmaVersion >= 9
				? this.regexp_groupSpecifier(t)
				: t.current() === 63 && t.raise("Invalid group"),
			this.regexp_disjunction(t),
			t.eat(41))
		)
			return (t.numCapturingParens += 1), !0;
		t.raise("Unterminated group");
	}
	return !1;
};
Ve.regexp_eatExtendedAtom = function (t) {
	return (
		t.eat(46) ||
		this.regexp_eatReverseSolidusAtomEscape(t) ||
		this.regexp_eatCharacterClass(t) ||
		this.regexp_eatUncapturingGroup(t) ||
		this.regexp_eatCapturingGroup(t) ||
		this.regexp_eatInvalidBracedQuantifier(t) ||
		this.regexp_eatExtendedPatternCharacter(t)
	);
};
Ve.regexp_eatInvalidBracedQuantifier = function (t) {
	return (
		this.regexp_eatBracedQuantifier(t, !0) && t.raise("Nothing to repeat"),
		!1
	);
};
Ve.regexp_eatSyntaxCharacter = function (t) {
	var e = t.current();
	return TY(e) ? ((t.lastIntValue = e), t.advance(), !0) : !1;
};
function TY(t) {
	return (
		t === 36 ||
		(t >= 40 && t <= 43) ||
		t === 46 ||
		t === 63 ||
		(t >= 91 && t <= 94) ||
		(t >= 123 && t <= 125)
	);
}
Ve.regexp_eatPatternCharacters = function (t) {
	for (var e = t.pos, n = 0; (n = t.current()) !== -1 && !TY(n); )
		t.advance();
	return t.pos !== e;
};
Ve.regexp_eatExtendedPatternCharacter = function (t) {
	var e = t.current();
	return e !== -1 &&
		e !== 36 &&
		!(e >= 40 && e <= 43) &&
		e !== 46 &&
		e !== 63 &&
		e !== 91 &&
		e !== 94 &&
		e !== 124
		? (t.advance(), !0)
		: !1;
};
Ve.regexp_groupSpecifier = function (t) {
	if (t.eat(63)) {
		this.regexp_eatGroupName(t) || t.raise("Invalid group");
		var e = this.options.ecmaVersion >= 16,
			n = t.groupNames[t.lastStringValue];
		if (n)
			if (e)
				for (var r = 0, i = n; r < i.length; r += 1) {
					var o = i[r];
					o.separatedFrom(t.branchID) ||
						t.raise("Duplicate capture group name");
				}
			else t.raise("Duplicate capture group name");
		e
			? (n || (t.groupNames[t.lastStringValue] = [])).push(t.branchID)
			: (t.groupNames[t.lastStringValue] = !0);
	}
};
Ve.regexp_eatGroupName = function (t) {
	if (((t.lastStringValue = ""), t.eat(60))) {
		if (this.regexp_eatRegExpIdentifierName(t) && t.eat(62)) return !0;
		t.raise("Invalid capture group name");
	}
	return !1;
};
Ve.regexp_eatRegExpIdentifierName = function (t) {
	if (((t.lastStringValue = ""), this.regexp_eatRegExpIdentifierStart(t))) {
		for (
			t.lastStringValue += Zu(t.lastIntValue);
			this.regexp_eatRegExpIdentifierPart(t);

		)
			t.lastStringValue += Zu(t.lastIntValue);
		return !0;
	}
	return !1;
};
Ve.regexp_eatRegExpIdentifierStart = function (t) {
	var e = t.pos,
		n = this.options.ecmaVersion >= 11,
		r = t.current(n);
	return (
		t.advance(n),
		r === 92 &&
			this.regexp_eatRegExpUnicodeEscapeSequence(t, n) &&
			(r = t.lastIntValue),
		J6e(r) ? ((t.lastIntValue = r), !0) : ((t.pos = e), !1)
	);
};
function J6e(t) {
	return Ca(t, !0) || t === 36 || t === 95;
}
Ve.regexp_eatRegExpIdentifierPart = function (t) {
	var e = t.pos,
		n = this.options.ecmaVersion >= 11,
		r = t.current(n);
	return (
		t.advance(n),
		r === 92 &&
			this.regexp_eatRegExpUnicodeEscapeSequence(t, n) &&
			(r = t.lastIntValue),
		X6e(r) ? ((t.lastIntValue = r), !0) : ((t.pos = e), !1)
	);
};
function X6e(t) {
	return Rd(t, !0) || t === 36 || t === 95 || t === 8204 || t === 8205;
}
Ve.regexp_eatAtomEscape = function (t) {
	return this.regexp_eatBackReference(t) ||
		this.regexp_eatCharacterClassEscape(t) ||
		this.regexp_eatCharacterEscape(t) ||
		(t.switchN && this.regexp_eatKGroupName(t))
		? !0
		: (t.switchU &&
				(t.current() === 99 && t.raise("Invalid unicode escape"),
				t.raise("Invalid escape")),
			!1);
};
Ve.regexp_eatBackReference = function (t) {
	var e = t.pos;
	if (this.regexp_eatDecimalEscape(t)) {
		var n = t.lastIntValue;
		if (t.switchU)
			return n > t.maxBackReference && (t.maxBackReference = n), !0;
		if (n <= t.numCapturingParens) return !0;
		t.pos = e;
	}
	return !1;
};
Ve.regexp_eatKGroupName = function (t) {
	if (t.eat(107)) {
		if (this.regexp_eatGroupName(t))
			return t.backReferenceNames.push(t.lastStringValue), !0;
		t.raise("Invalid named reference");
	}
	return !1;
};
Ve.regexp_eatCharacterEscape = function (t) {
	return (
		this.regexp_eatControlEscape(t) ||
		this.regexp_eatCControlLetter(t) ||
		this.regexp_eatZero(t) ||
		this.regexp_eatHexEscapeSequence(t) ||
		this.regexp_eatRegExpUnicodeEscapeSequence(t, !1) ||
		(!t.switchU && this.regexp_eatLegacyOctalEscapeSequence(t)) ||
		this.regexp_eatIdentityEscape(t)
	);
};
Ve.regexp_eatCControlLetter = function (t) {
	var e = t.pos;
	if (t.eat(99)) {
		if (this.regexp_eatControlLetter(t)) return !0;
		t.pos = e;
	}
	return !1;
};
Ve.regexp_eatZero = function (t) {
	return t.current() === 48 && !K3(t.lookahead())
		? ((t.lastIntValue = 0), t.advance(), !0)
		: !1;
};
Ve.regexp_eatControlEscape = function (t) {
	var e = t.current();
	return e === 116
		? ((t.lastIntValue = 9), t.advance(), !0)
		: e === 110
			? ((t.lastIntValue = 10), t.advance(), !0)
			: e === 118
				? ((t.lastIntValue = 11), t.advance(), !0)
				: e === 102
					? ((t.lastIntValue = 12), t.advance(), !0)
					: e === 114
						? ((t.lastIntValue = 13), t.advance(), !0)
						: !1;
};
Ve.regexp_eatControlLetter = function (t) {
	var e = t.current();
	return BY(e) ? ((t.lastIntValue = e % 32), t.advance(), !0) : !1;
};
function BY(t) {
	return (t >= 65 && t <= 90) || (t >= 97 && t <= 122);
}
Ve.regexp_eatRegExpUnicodeEscapeSequence = function (t, e) {
	e === void 0 && (e = !1);
	var n = t.pos,
		r = e || t.switchU;
	if (t.eat(117)) {
		if (this.regexp_eatFixedHexDigits(t, 4)) {
			var i = t.lastIntValue;
			if (r && i >= 55296 && i <= 56319) {
				var o = t.pos;
				if (
					t.eat(92) &&
					t.eat(117) &&
					this.regexp_eatFixedHexDigits(t, 4)
				) {
					var s = t.lastIntValue;
					if (s >= 56320 && s <= 57343)
						return (
							(t.lastIntValue =
								(i - 55296) * 1024 + (s - 56320) + 65536),
							!0
						);
				}
				(t.pos = o), (t.lastIntValue = i);
			}
			return !0;
		}
		if (
			r &&
			t.eat(123) &&
			this.regexp_eatHexDigits(t) &&
			t.eat(125) &&
			Z6e(t.lastIntValue)
		)
			return !0;
		r && t.raise("Invalid unicode escape"), (t.pos = n);
	}
	return !1;
};
function Z6e(t) {
	return t >= 0 && t <= 1114111;
}
Ve.regexp_eatIdentityEscape = function (t) {
	if (t.switchU)
		return this.regexp_eatSyntaxCharacter(t)
			? !0
			: t.eat(47)
				? ((t.lastIntValue = 47), !0)
				: !1;
	var e = t.current();
	return e !== 99 && (!t.switchN || e !== 107)
		? ((t.lastIntValue = e), t.advance(), !0)
		: !1;
};
Ve.regexp_eatDecimalEscape = function (t) {
	t.lastIntValue = 0;
	var e = t.current();
	if (e >= 49 && e <= 57) {
		do (t.lastIntValue = 10 * t.lastIntValue + (e - 48)), t.advance();
		while ((e = t.current()) >= 48 && e <= 57);
		return !0;
	}
	return !1;
};
var IY = 0,
	wl = 1,
	Mo = 2;
Ve.regexp_eatCharacterClassEscape = function (t) {
	var e = t.current();
	if (Q6e(e)) return (t.lastIntValue = -1), t.advance(), wl;
	var n = !1;
	if (
		t.switchU &&
		this.options.ecmaVersion >= 9 &&
		((n = e === 80) || e === 112)
	) {
		(t.lastIntValue = -1), t.advance();
		var r;
		if (
			t.eat(123) &&
			(r = this.regexp_eatUnicodePropertyValueExpression(t)) &&
			t.eat(125)
		)
			return n && r === Mo && t.raise("Invalid property name"), r;
		t.raise("Invalid property name");
	}
	return IY;
};
function Q6e(t) {
	return (
		t === 100 || t === 68 || t === 115 || t === 83 || t === 119 || t === 87
	);
}
Ve.regexp_eatUnicodePropertyValueExpression = function (t) {
	var e = t.pos;
	if (this.regexp_eatUnicodePropertyName(t) && t.eat(61)) {
		var n = t.lastStringValue;
		if (this.regexp_eatUnicodePropertyValue(t)) {
			var r = t.lastStringValue;
			return this.regexp_validateUnicodePropertyNameAndValue(t, n, r), wl;
		}
	}
	if (((t.pos = e), this.regexp_eatLoneUnicodePropertyNameOrValue(t))) {
		var i = t.lastStringValue;
		return this.regexp_validateUnicodePropertyNameOrValue(t, i);
	}
	return IY;
};
Ve.regexp_validateUnicodePropertyNameAndValue = function (t, e, n) {
	W0(t.unicodeProperties.nonBinary, e) || t.raise("Invalid property name"),
		t.unicodeProperties.nonBinary[e].test(n) ||
			t.raise("Invalid property value");
};
Ve.regexp_validateUnicodePropertyNameOrValue = function (t, e) {
	if (t.unicodeProperties.binary.test(e)) return wl;
	if (t.switchV && t.unicodeProperties.binaryOfStrings.test(e)) return Mo;
	t.raise("Invalid property name");
};
Ve.regexp_eatUnicodePropertyName = function (t) {
	var e = 0;
	for (t.lastStringValue = ""; FY((e = t.current())); )
		(t.lastStringValue += Zu(e)), t.advance();
	return t.lastStringValue !== "";
};
function FY(t) {
	return BY(t) || t === 95;
}
Ve.regexp_eatUnicodePropertyValue = function (t) {
	var e = 0;
	for (t.lastStringValue = ""; e$e((e = t.current())); )
		(t.lastStringValue += Zu(e)), t.advance();
	return t.lastStringValue !== "";
};
function e$e(t) {
	return FY(t) || K3(t);
}
Ve.regexp_eatLoneUnicodePropertyNameOrValue = function (t) {
	return this.regexp_eatUnicodePropertyValue(t);
};
Ve.regexp_eatCharacterClass = function (t) {
	if (t.eat(91)) {
		var e = t.eat(94),
			n = this.regexp_classContents(t);
		return (
			t.eat(93) || t.raise("Unterminated character class"),
			e &&
				n === Mo &&
				t.raise("Negated character class may contain strings"),
			!0
		);
	}
	return !1;
};
Ve.regexp_classContents = function (t) {
	return t.current() === 93
		? wl
		: t.switchV
			? this.regexp_classSetExpression(t)
			: (this.regexp_nonEmptyClassRanges(t), wl);
};
Ve.regexp_nonEmptyClassRanges = function (t) {
	for (; this.regexp_eatClassAtom(t); ) {
		var e = t.lastIntValue;
		if (t.eat(45) && this.regexp_eatClassAtom(t)) {
			var n = t.lastIntValue;
			t.switchU &&
				(e === -1 || n === -1) &&
				t.raise("Invalid character class"),
				e !== -1 &&
					n !== -1 &&
					e > n &&
					t.raise("Range out of order in character class");
		}
	}
};
Ve.regexp_eatClassAtom = function (t) {
	var e = t.pos;
	if (t.eat(92)) {
		if (this.regexp_eatClassEscape(t)) return !0;
		if (t.switchU) {
			var n = t.current();
			(n === 99 || RY(n)) && t.raise("Invalid class escape"),
				t.raise("Invalid escape");
		}
		t.pos = e;
	}
	var r = t.current();
	return r !== 93 ? ((t.lastIntValue = r), t.advance(), !0) : !1;
};
Ve.regexp_eatClassEscape = function (t) {
	var e = t.pos;
	if (t.eat(98)) return (t.lastIntValue = 8), !0;
	if (t.switchU && t.eat(45)) return (t.lastIntValue = 45), !0;
	if (!t.switchU && t.eat(99)) {
		if (this.regexp_eatClassControlLetter(t)) return !0;
		t.pos = e;
	}
	return (
		this.regexp_eatCharacterClassEscape(t) ||
		this.regexp_eatCharacterEscape(t)
	);
};
Ve.regexp_classSetExpression = function (t) {
	var e = wl,
		n;
	if (!this.regexp_eatClassSetRange(t))
		if ((n = this.regexp_eatClassSetOperand(t))) {
			n === Mo && (e = Mo);
			for (var r = t.pos; t.eatChars([38, 38]); ) {
				if (
					t.current() !== 38 &&
					(n = this.regexp_eatClassSetOperand(t))
				) {
					n !== Mo && (e = wl);
					continue;
				}
				t.raise("Invalid character in character class");
			}
			if (r !== t.pos) return e;
			for (; t.eatChars([45, 45]); )
				this.regexp_eatClassSetOperand(t) ||
					t.raise("Invalid character in character class");
			if (r !== t.pos) return e;
		} else t.raise("Invalid character in character class");
	for (;;)
		if (!this.regexp_eatClassSetRange(t)) {
			if (((n = this.regexp_eatClassSetOperand(t)), !n)) return e;
			n === Mo && (e = Mo);
		}
};
Ve.regexp_eatClassSetRange = function (t) {
	var e = t.pos;
	if (this.regexp_eatClassSetCharacter(t)) {
		var n = t.lastIntValue;
		if (t.eat(45) && this.regexp_eatClassSetCharacter(t)) {
			var r = t.lastIntValue;
			return (
				n !== -1 &&
					r !== -1 &&
					n > r &&
					t.raise("Range out of order in character class"),
				!0
			);
		}
		t.pos = e;
	}
	return !1;
};
Ve.regexp_eatClassSetOperand = function (t) {
	return this.regexp_eatClassSetCharacter(t)
		? wl
		: this.regexp_eatClassStringDisjunction(t) ||
				this.regexp_eatNestedClass(t);
};
Ve.regexp_eatNestedClass = function (t) {
	var e = t.pos;
	if (t.eat(91)) {
		var n = t.eat(94),
			r = this.regexp_classContents(t);
		if (t.eat(93))
			return (
				n &&
					r === Mo &&
					t.raise("Negated character class may contain strings"),
				r
			);
		t.pos = e;
	}
	if (t.eat(92)) {
		var i = this.regexp_eatCharacterClassEscape(t);
		if (i) return i;
		t.pos = e;
	}
	return null;
};
Ve.regexp_eatClassStringDisjunction = function (t) {
	var e = t.pos;
	if (t.eatChars([92, 113])) {
		if (t.eat(123)) {
			var n = this.regexp_classStringDisjunctionContents(t);
			if (t.eat(125)) return n;
		} else t.raise("Invalid escape");
		t.pos = e;
	}
	return null;
};
Ve.regexp_classStringDisjunctionContents = function (t) {
	for (var e = this.regexp_classString(t); t.eat(124); )
		this.regexp_classString(t) === Mo && (e = Mo);
	return e;
};
Ve.regexp_classString = function (t) {
	for (var e = 0; this.regexp_eatClassSetCharacter(t); ) e++;
	return e === 1 ? wl : Mo;
};
Ve.regexp_eatClassSetCharacter = function (t) {
	var e = t.pos;
	if (t.eat(92))
		return this.regexp_eatCharacterEscape(t) ||
			this.regexp_eatClassSetReservedPunctuator(t)
			? !0
			: t.eat(98)
				? ((t.lastIntValue = 8), !0)
				: ((t.pos = e), !1);
	var n = t.current();
	return n < 0 || (n === t.lookahead() && t$e(n)) || n$e(n)
		? !1
		: (t.advance(), (t.lastIntValue = n), !0);
};
function t$e(t) {
	return (
		t === 33 ||
		(t >= 35 && t <= 38) ||
		(t >= 42 && t <= 44) ||
		t === 46 ||
		(t >= 58 && t <= 64) ||
		t === 94 ||
		t === 96 ||
		t === 126
	);
}
function n$e(t) {
	return (
		t === 40 ||
		t === 41 ||
		t === 45 ||
		t === 47 ||
		(t >= 91 && t <= 93) ||
		(t >= 123 && t <= 125)
	);
}
Ve.regexp_eatClassSetReservedPunctuator = function (t) {
	var e = t.current();
	return r$e(e) ? ((t.lastIntValue = e), t.advance(), !0) : !1;
};
function r$e(t) {
	return (
		t === 33 ||
		t === 35 ||
		t === 37 ||
		t === 38 ||
		t === 44 ||
		t === 45 ||
		(t >= 58 && t <= 62) ||
		t === 64 ||
		t === 96 ||
		t === 126
	);
}
Ve.regexp_eatClassControlLetter = function (t) {
	var e = t.current();
	return K3(e) || e === 95
		? ((t.lastIntValue = e % 32), t.advance(), !0)
		: !1;
};
Ve.regexp_eatHexEscapeSequence = function (t) {
	var e = t.pos;
	if (t.eat(120)) {
		if (this.regexp_eatFixedHexDigits(t, 2)) return !0;
		t.switchU && t.raise("Invalid escape"), (t.pos = e);
	}
	return !1;
};
Ve.regexp_eatDecimalDigits = function (t) {
	var e = t.pos,
		n = 0;
	for (t.lastIntValue = 0; K3((n = t.current())); )
		(t.lastIntValue = 10 * t.lastIntValue + (n - 48)), t.advance();
	return t.pos !== e;
};
function K3(t) {
	return t >= 48 && t <= 57;
}
Ve.regexp_eatHexDigits = function (t) {
	var e = t.pos,
		n = 0;
	for (t.lastIntValue = 0; PY((n = t.current())); )
		(t.lastIntValue = 16 * t.lastIntValue + NY(n)), t.advance();
	return t.pos !== e;
};
function PY(t) {
	return (
		(t >= 48 && t <= 57) || (t >= 65 && t <= 70) || (t >= 97 && t <= 102)
	);
}
function NY(t) {
	return t >= 65 && t <= 70
		? 10 + (t - 65)
		: t >= 97 && t <= 102
			? 10 + (t - 97)
			: t - 48;
}
Ve.regexp_eatLegacyOctalEscapeSequence = function (t) {
	if (this.regexp_eatOctalDigit(t)) {
		var e = t.lastIntValue;
		if (this.regexp_eatOctalDigit(t)) {
			var n = t.lastIntValue;
			e <= 3 && this.regexp_eatOctalDigit(t)
				? (t.lastIntValue = e * 64 + n * 8 + t.lastIntValue)
				: (t.lastIntValue = e * 8 + n);
		} else t.lastIntValue = e;
		return !0;
	}
	return !1;
};
Ve.regexp_eatOctalDigit = function (t) {
	var e = t.current();
	return RY(e)
		? ((t.lastIntValue = e - 48), t.advance(), !0)
		: ((t.lastIntValue = 0), !1);
};
function RY(t) {
	return t >= 48 && t <= 55;
}
Ve.regexp_eatFixedHexDigits = function (t, e) {
	var n = t.pos;
	t.lastIntValue = 0;
	for (var r = 0; r < e; ++r) {
		var i = t.current();
		if (!PY(i)) return (t.pos = n), !1;
		(t.lastIntValue = 16 * t.lastIntValue + NY(i)), t.advance();
	}
	return !0;
};
var U3 = function (e) {
		(this.type = e.type),
			(this.value = e.value),
			(this.start = e.start),
			(this.end = e.end),
			e.options.locations && (this.loc = new q0(e, e.startLoc, e.endLoc)),
			e.options.ranges && (this.range = [e.start, e.end]);
	},
	$t = kn.prototype;
$t.next = function (t) {
	!t &&
		this.type.keyword &&
		this.containsEsc &&
		this.raiseRecoverable(
			this.start,
			"Escape sequence in keyword " + this.type.keyword,
		),
		this.options.onToken && this.options.onToken(new U3(this)),
		(this.lastTokEnd = this.end),
		(this.lastTokStart = this.start),
		(this.lastTokEndLoc = this.endLoc),
		(this.lastTokStartLoc = this.startLoc),
		this.nextToken();
};
$t.getToken = function () {
	return this.next(), new U3(this);
};
typeof Symbol < "u" &&
	($t[Symbol.iterator] = function () {
		var t = this;
		return {
			next: function () {
				var e = t.getToken();
				return { done: e.type === L.eof, value: e };
			},
		};
	});
$t.nextToken = function () {
	var t = this.curContext();
	if (
		((!t || !t.preserveSpace) && this.skipSpace(),
		(this.start = this.pos),
		this.options.locations && (this.startLoc = this.curPosition()),
		this.pos >= this.input.length)
	)
		return this.finishToken(L.eof);
	if (t.override) return t.override(this);
	this.readToken(this.fullCharCodeAtPos());
};
$t.readToken = function (t) {
	return Ca(t, this.options.ecmaVersion >= 6) || t === 92
		? this.readWord()
		: this.getTokenFromCode(t);
};
$t.fullCharCodeAtPos = function () {
	var t = this.input.charCodeAt(this.pos);
	if (t <= 55295 || t >= 56320) return t;
	var e = this.input.charCodeAt(this.pos + 1);
	return e <= 56319 || e >= 57344 ? t : (t << 10) + e - 56613888;
};
$t.skipBlockComment = function () {
	var t = this.options.onComment && this.curPosition(),
		e = this.pos,
		n = this.input.indexOf("*/", (this.pos += 2));
	if (
		(n === -1 && this.raise(this.pos - 2, "Unterminated comment"),
		(this.pos = n + 2),
		this.options.locations)
	)
		for (var r = void 0, i = e; (r = sY(this.input, i, this.pos)) > -1; )
			++this.curLine, (i = this.lineStart = r);
	this.options.onComment &&
		this.options.onComment(
			!0,
			this.input.slice(e + 2, n),
			e,
			this.pos,
			t,
			this.curPosition(),
		);
};
$t.skipLineComment = function (t) {
	for (
		var e = this.pos,
			n = this.options.onComment && this.curPosition(),
			r = this.input.charCodeAt((this.pos += t));
		this.pos < this.input.length && !of(r);

	)
		r = this.input.charCodeAt(++this.pos);
	this.options.onComment &&
		this.options.onComment(
			!1,
			this.input.slice(e + t, this.pos),
			e,
			this.pos,
			n,
			this.curPosition(),
		);
};
$t.skipSpace = function () {
	e: for (; this.pos < this.input.length; ) {
		var t = this.input.charCodeAt(this.pos);
		switch (t) {
			case 32:
			case 160:
				++this.pos;
				break;
			case 13:
				this.input.charCodeAt(this.pos + 1) === 10 && ++this.pos;
			case 10:
			case 8232:
			case 8233:
				++this.pos,
					this.options.locations &&
						(++this.curLine, (this.lineStart = this.pos));
				break;
			case 47:
				switch (this.input.charCodeAt(this.pos + 1)) {
					case 42:
						this.skipBlockComment();
						break;
					case 47:
						this.skipLineComment(2);
						break;
					default:
						break e;
				}
				break;
			default:
				if (
					(t > 8 && t < 14) ||
					(t >= 5760 && Q5.test(String.fromCharCode(t)))
				)
					++this.pos;
				else break e;
		}
	}
};
$t.finishToken = function (t, e) {
	(this.end = this.pos),
		this.options.locations && (this.endLoc = this.curPosition());
	var n = this.type;
	(this.type = t), (this.value = e), this.updateContext(n);
};
$t.readToken_dot = function () {
	var t = this.input.charCodeAt(this.pos + 1);
	if (t >= 48 && t <= 57) return this.readNumber(!0);
	var e = this.input.charCodeAt(this.pos + 2);
	return this.options.ecmaVersion >= 6 && t === 46 && e === 46
		? ((this.pos += 3), this.finishToken(L.ellipsis))
		: (++this.pos, this.finishToken(L.dot));
};
$t.readToken_slash = function () {
	var t = this.input.charCodeAt(this.pos + 1);
	return this.exprAllowed
		? (++this.pos, this.readRegexp())
		: t === 61
			? this.finishOp(L.assign, 2)
			: this.finishOp(L.slash, 1);
};
$t.readToken_mult_modulo_exp = function (t) {
	var e = this.input.charCodeAt(this.pos + 1),
		n = 1,
		r = t === 42 ? L.star : L.modulo;
	return (
		this.options.ecmaVersion >= 7 &&
			t === 42 &&
			e === 42 &&
			(++n, (r = L.starstar), (e = this.input.charCodeAt(this.pos + 2))),
		e === 61 ? this.finishOp(L.assign, n + 1) : this.finishOp(r, n)
	);
};
$t.readToken_pipe_amp = function (t) {
	var e = this.input.charCodeAt(this.pos + 1);
	if (e === t) {
		if (this.options.ecmaVersion >= 12) {
			var n = this.input.charCodeAt(this.pos + 2);
			if (n === 61) return this.finishOp(L.assign, 3);
		}
		return this.finishOp(t === 124 ? L.logicalOR : L.logicalAND, 2);
	}
	return e === 61
		? this.finishOp(L.assign, 2)
		: this.finishOp(t === 124 ? L.bitwiseOR : L.bitwiseAND, 1);
};
$t.readToken_caret = function () {
	var t = this.input.charCodeAt(this.pos + 1);
	return t === 61
		? this.finishOp(L.assign, 2)
		: this.finishOp(L.bitwiseXOR, 1);
};
$t.readToken_plus_min = function (t) {
	var e = this.input.charCodeAt(this.pos + 1);
	return e === t
		? e === 45 &&
			!this.inModule &&
			this.input.charCodeAt(this.pos + 2) === 62 &&
			(this.lastTokEnd === 0 ||
				yo.test(this.input.slice(this.lastTokEnd, this.pos)))
			? (this.skipLineComment(3), this.skipSpace(), this.nextToken())
			: this.finishOp(L.incDec, 2)
		: e === 61
			? this.finishOp(L.assign, 2)
			: this.finishOp(L.plusMin, 1);
};
$t.readToken_lt_gt = function (t) {
	var e = this.input.charCodeAt(this.pos + 1),
		n = 1;
	return e === t
		? ((n = t === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2),
			this.input.charCodeAt(this.pos + n) === 61
				? this.finishOp(L.assign, n + 1)
				: this.finishOp(L.bitShift, n))
		: e === 33 &&
			  t === 60 &&
			  !this.inModule &&
			  this.input.charCodeAt(this.pos + 2) === 45 &&
			  this.input.charCodeAt(this.pos + 3) === 45
			? (this.skipLineComment(4), this.skipSpace(), this.nextToken())
			: (e === 61 && (n = 2), this.finishOp(L.relational, n));
};
$t.readToken_eq_excl = function (t) {
	var e = this.input.charCodeAt(this.pos + 1);
	return e === 61
		? this.finishOp(
				L.equality,
				this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2,
			)
		: t === 61 && e === 62 && this.options.ecmaVersion >= 6
			? ((this.pos += 2), this.finishToken(L.arrow))
			: this.finishOp(t === 61 ? L.eq : L.prefix, 1);
};
$t.readToken_question = function () {
	var t = this.options.ecmaVersion;
	if (t >= 11) {
		var e = this.input.charCodeAt(this.pos + 1);
		if (e === 46) {
			var n = this.input.charCodeAt(this.pos + 2);
			if (n < 48 || n > 57) return this.finishOp(L.questionDot, 2);
		}
		if (e === 63) {
			if (t >= 12) {
				var r = this.input.charCodeAt(this.pos + 2);
				if (r === 61) return this.finishOp(L.assign, 3);
			}
			return this.finishOp(L.coalesce, 2);
		}
	}
	return this.finishOp(L.question, 1);
};
$t.readToken_numberSign = function () {
	var t = this.options.ecmaVersion,
		e = 35;
	if (
		t >= 13 &&
		(++this.pos, (e = this.fullCharCodeAtPos()), Ca(e, !0) || e === 92)
	)
		return this.finishToken(L.privateId, this.readWord1());
	this.raise(this.pos, "Unexpected character '" + Zu(e) + "'");
};
$t.getTokenFromCode = function (t) {
	switch (t) {
		case 46:
			return this.readToken_dot();
		case 40:
			return ++this.pos, this.finishToken(L.parenL);
		case 41:
			return ++this.pos, this.finishToken(L.parenR);
		case 59:
			return ++this.pos, this.finishToken(L.semi);
		case 44:
			return ++this.pos, this.finishToken(L.comma);
		case 91:
			return ++this.pos, this.finishToken(L.bracketL);
		case 93:
			return ++this.pos, this.finishToken(L.bracketR);
		case 123:
			return ++this.pos, this.finishToken(L.braceL);
		case 125:
			return ++this.pos, this.finishToken(L.braceR);
		case 58:
			return ++this.pos, this.finishToken(L.colon);
		case 96:
			if (this.options.ecmaVersion < 6) break;
			return ++this.pos, this.finishToken(L.backQuote);
		case 48:
			var e = this.input.charCodeAt(this.pos + 1);
			if (e === 120 || e === 88) return this.readRadixNumber(16);
			if (this.options.ecmaVersion >= 6) {
				if (e === 111 || e === 79) return this.readRadixNumber(8);
				if (e === 98 || e === 66) return this.readRadixNumber(2);
			}
		case 49:
		case 50:
		case 51:
		case 52:
		case 53:
		case 54:
		case 55:
		case 56:
		case 57:
			return this.readNumber(!1);
		case 34:
		case 39:
			return this.readString(t);
		case 47:
			return this.readToken_slash();
		case 37:
		case 42:
			return this.readToken_mult_modulo_exp(t);
		case 124:
		case 38:
			return this.readToken_pipe_amp(t);
		case 94:
			return this.readToken_caret();
		case 43:
		case 45:
			return this.readToken_plus_min(t);
		case 60:
		case 62:
			return this.readToken_lt_gt(t);
		case 61:
		case 33:
			return this.readToken_eq_excl(t);
		case 63:
			return this.readToken_question();
		case 126:
			return this.finishOp(L.prefix, 1);
		case 35:
			return this.readToken_numberSign();
	}
	this.raise(this.pos, "Unexpected character '" + Zu(t) + "'");
};
$t.finishOp = function (t, e) {
	var n = this.input.slice(this.pos, this.pos + e);
	return (this.pos += e), this.finishToken(t, n);
};
$t.readRegexp = function () {
	for (var t, e, n = this.pos; ; ) {
		this.pos >= this.input.length &&
			this.raise(n, "Unterminated regular expression");
		var r = this.input.charAt(this.pos);
		if ((yo.test(r) && this.raise(n, "Unterminated regular expression"), t))
			t = !1;
		else {
			if (r === "[") e = !0;
			else if (r === "]" && e) e = !1;
			else if (r === "/" && !e) break;
			t = r === "\\";
		}
		++this.pos;
	}
	var i = this.input.slice(n, this.pos);
	++this.pos;
	var o = this.pos,
		s = this.readWord1();
	this.containsEsc && this.unexpected(o);
	var a = this.regexpState || (this.regexpState = new Ta(this));
	a.reset(n, i, s),
		this.validateRegExpFlags(a),
		this.validateRegExpPattern(a);
	var l = null;
	try {
		l = new RegExp(i, s);
	} catch {}
	return this.finishToken(L.regexp, { pattern: i, flags: s, value: l });
};
$t.readInt = function (t, e, n) {
	for (
		var r = this.options.ecmaVersion >= 12 && e === void 0,
			i = n && this.input.charCodeAt(this.pos) === 48,
			o = this.pos,
			s = 0,
			a = 0,
			l = 0,
			u = e ?? 1 / 0;
		l < u;
		++l, ++this.pos
	) {
		var c = this.input.charCodeAt(this.pos),
			d = void 0;
		if (r && c === 95) {
			i &&
				this.raiseRecoverable(
					this.pos,
					"Numeric separator is not allowed in legacy octal numeric literals",
				),
				a === 95 &&
					this.raiseRecoverable(
						this.pos,
						"Numeric separator must be exactly one underscore",
					),
				l === 0 &&
					this.raiseRecoverable(
						this.pos,
						"Numeric separator is not allowed at the first of digits",
					),
				(a = c);
			continue;
		}
		if (
			(c >= 97
				? (d = c - 97 + 10)
				: c >= 65
					? (d = c - 65 + 10)
					: c >= 48 && c <= 57
						? (d = c - 48)
						: (d = 1 / 0),
			d >= t)
		)
			break;
		(a = c), (s = s * t + d);
	}
	return (
		r &&
			a === 95 &&
			this.raiseRecoverable(
				this.pos - 1,
				"Numeric separator is not allowed at the last of digits",
			),
		this.pos === o || (e != null && this.pos - o !== e) ? null : s
	);
};
function i$e(t, e) {
	return e ? parseInt(t, 8) : parseFloat(t.replace(/_/g, ""));
}
function OY(t) {
	return typeof BigInt != "function" ? null : BigInt(t.replace(/_/g, ""));
}
$t.readRadixNumber = function (t) {
	var e = this.pos;
	this.pos += 2;
	var n = this.readInt(t);
	return (
		n == null &&
			this.raise(this.start + 2, "Expected number in radix " + t),
		this.options.ecmaVersion >= 11 &&
		this.input.charCodeAt(this.pos) === 110
			? ((n = OY(this.input.slice(e, this.pos))), ++this.pos)
			: Ca(this.fullCharCodeAtPos()) &&
				this.raise(this.pos, "Identifier directly after number"),
		this.finishToken(L.num, n)
	);
};
$t.readNumber = function (t) {
	var e = this.pos;
	!t &&
		this.readInt(10, void 0, !0) === null &&
		this.raise(e, "Invalid number");
	var n = this.pos - e >= 2 && this.input.charCodeAt(e) === 48;
	n && this.strict && this.raise(e, "Invalid number");
	var r = this.input.charCodeAt(this.pos);
	if (!n && !t && this.options.ecmaVersion >= 11 && r === 110) {
		var i = OY(this.input.slice(e, this.pos));
		return (
			++this.pos,
			Ca(this.fullCharCodeAtPos()) &&
				this.raise(this.pos, "Identifier directly after number"),
			this.finishToken(L.num, i)
		);
	}
	n && /[89]/.test(this.input.slice(e, this.pos)) && (n = !1),
		r === 46 &&
			!n &&
			(++this.pos,
			this.readInt(10),
			(r = this.input.charCodeAt(this.pos))),
		(r === 69 || r === 101) &&
			!n &&
			((r = this.input.charCodeAt(++this.pos)),
			(r === 43 || r === 45) && ++this.pos,
			this.readInt(10) === null && this.raise(e, "Invalid number")),
		Ca(this.fullCharCodeAtPos()) &&
			this.raise(this.pos, "Identifier directly after number");
	var o = i$e(this.input.slice(e, this.pos), n);
	return this.finishToken(L.num, o);
};
$t.readCodePoint = function () {
	var t = this.input.charCodeAt(this.pos),
		e;
	if (t === 123) {
		this.options.ecmaVersion < 6 && this.unexpected();
		var n = ++this.pos;
		(e = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos)),
			++this.pos,
			e > 1114111 &&
				this.invalidStringToken(n, "Code point out of bounds");
	} else e = this.readHexChar(4);
	return e;
};
$t.readString = function (t) {
	for (var e = "", n = ++this.pos; ; ) {
		this.pos >= this.input.length &&
			this.raise(this.start, "Unterminated string constant");
		var r = this.input.charCodeAt(this.pos);
		if (r === t) break;
		r === 92
			? ((e += this.input.slice(n, this.pos)),
				(e += this.readEscapedChar(!1)),
				(n = this.pos))
			: r === 8232 || r === 8233
				? (this.options.ecmaVersion < 10 &&
						this.raise(this.start, "Unterminated string constant"),
					++this.pos,
					this.options.locations &&
						(this.curLine++, (this.lineStart = this.pos)))
				: (of(r) &&
						this.raise(this.start, "Unterminated string constant"),
					++this.pos);
	}
	return (
		(e += this.input.slice(n, this.pos++)), this.finishToken(L.string, e)
	);
};
var MY = {};
$t.tryReadTemplateToken = function () {
	this.inTemplateElement = !0;
	try {
		this.readTmplToken();
	} catch (t) {
		if (t === MY) this.readInvalidTemplateToken();
		else throw t;
	}
	this.inTemplateElement = !1;
};
$t.invalidStringToken = function (t, e) {
	if (this.inTemplateElement && this.options.ecmaVersion >= 9) throw MY;
	this.raise(t, e);
};
$t.readTmplToken = function () {
	for (var t = "", e = this.pos; ; ) {
		this.pos >= this.input.length &&
			this.raise(this.start, "Unterminated template");
		var n = this.input.charCodeAt(this.pos);
		if (
			n === 96 ||
			(n === 36 && this.input.charCodeAt(this.pos + 1) === 123)
		)
			return this.pos === this.start &&
				(this.type === L.template || this.type === L.invalidTemplate)
				? n === 36
					? ((this.pos += 2), this.finishToken(L.dollarBraceL))
					: (++this.pos, this.finishToken(L.backQuote))
				: ((t += this.input.slice(e, this.pos)),
					this.finishToken(L.template, t));
		if (n === 92)
			(t += this.input.slice(e, this.pos)),
				(t += this.readEscapedChar(!0)),
				(e = this.pos);
		else if (of(n)) {
			switch (((t += this.input.slice(e, this.pos)), ++this.pos, n)) {
				case 13:
					this.input.charCodeAt(this.pos) === 10 && ++this.pos;
				case 10:
					t += `
`;
					break;
				default:
					t += String.fromCharCode(n);
					break;
			}
			this.options.locations &&
				(++this.curLine, (this.lineStart = this.pos)),
				(e = this.pos);
		} else ++this.pos;
	}
};
$t.readInvalidTemplateToken = function () {
	for (; this.pos < this.input.length; this.pos++)
		switch (this.input[this.pos]) {
			case "\\":
				++this.pos;
				break;
			case "$":
				if (this.input[this.pos + 1] !== "{") break;
			case "`":
				return this.finishToken(
					L.invalidTemplate,
					this.input.slice(this.start, this.pos),
				);
			case "\r":
				this.input[this.pos + 1] ===
					`
` && ++this.pos;
			case `
`:
			case "\u2028":
			case "\u2029":
				++this.curLine, (this.lineStart = this.pos + 1);
				break;
		}
	this.raise(this.start, "Unterminated template");
};
$t.readEscapedChar = function (t) {
	var e = this.input.charCodeAt(++this.pos);
	switch ((++this.pos, e)) {
		case 110:
			return `
`;
		case 114:
			return "\r";
		case 120:
			return String.fromCharCode(this.readHexChar(2));
		case 117:
			return Zu(this.readCodePoint());
		case 116:
			return "	";
		case 98:
			return "\b";
		case 118:
			return "\v";
		case 102:
			return "\f";
		case 13:
			this.input.charCodeAt(this.pos) === 10 && ++this.pos;
		case 10:
			return (
				this.options.locations &&
					((this.lineStart = this.pos), ++this.curLine),
				""
			);
		case 56:
		case 57:
			if (
				(this.strict &&
					this.invalidStringToken(
						this.pos - 1,
						"Invalid escape sequence",
					),
				t)
			) {
				var n = this.pos - 1;
				this.invalidStringToken(
					n,
					"Invalid escape sequence in template string",
				);
			}
		default:
			if (e >= 48 && e <= 55) {
				var r = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0],
					i = parseInt(r, 8);
				return (
					i > 255 && ((r = r.slice(0, -1)), (i = parseInt(r, 8))),
					(this.pos += r.length - 1),
					(e = this.input.charCodeAt(this.pos)),
					(r !== "0" || e === 56 || e === 57) &&
						(this.strict || t) &&
						this.invalidStringToken(
							this.pos - 1 - r.length,
							t
								? "Octal literal in template string"
								: "Octal literal in strict mode",
						),
					String.fromCharCode(i)
				);
			}
			return of(e)
				? (this.options.locations &&
						((this.lineStart = this.pos), ++this.curLine),
					"")
				: String.fromCharCode(e);
	}
};
$t.readHexChar = function (t) {
	var e = this.pos,
		n = this.readInt(16, t);
	return (
		n === null &&
			this.invalidStringToken(e, "Bad character escape sequence"),
		n
	);
};
$t.readWord1 = function () {
	this.containsEsc = !1;
	for (
		var t = "", e = !0, n = this.pos, r = this.options.ecmaVersion >= 6;
		this.pos < this.input.length;

	) {
		var i = this.fullCharCodeAtPos();
		if (Rd(i, r)) this.pos += i <= 65535 ? 1 : 2;
		else if (i === 92) {
			(this.containsEsc = !0), (t += this.input.slice(n, this.pos));
			var o = this.pos;
			this.input.charCodeAt(++this.pos) !== 117 &&
				this.invalidStringToken(
					this.pos,
					"Expecting Unicode escape sequence \\uXXXX",
				),
				++this.pos;
			var s = this.readCodePoint();
			(e ? Ca : Rd)(s, r) ||
				this.invalidStringToken(o, "Invalid Unicode escape"),
				(t += Zu(s)),
				(n = this.pos);
		} else break;
		e = !1;
	}
	return t + this.input.slice(n, this.pos);
};
$t.readWord = function () {
	var t = this.readWord1(),
		e = L.name;
	return this.keywords.test(t) && (e = L3[t]), this.finishToken(e, t);
};
var jY = "8.12.1";
kn.acorn = {
	Parser: kn,
	version: jY,
	defaultOptions: Ry,
	Position: _h,
	SourceLocation: q0,
	getLineInfo: eA,
	Node: Y0,
	TokenType: Bt,
	tokTypes: L,
	keywordTypes: L3,
	TokContext: So,
	tokContexts: sn,
	isIdentifierChar: Rd,
	isIdentifierStart: Ca,
	Token: U3,
	isNewLine: of,
	lineBreak: yo,
	lineBreakG: oY,
	nonASCIIwhitespace: Q5,
};
function o$e(t, e) {
	return kn.parse(t, e);
}
function s$e(t, e, n) {
	return kn.parseExpressionAt(t, e, n);
}
function a$e(t, e) {
	return kn.tokenizer(t, e);
}
const l$e = Object.freeze(
	Object.defineProperty(
		{
			__proto__: null,
			Node: Y0,
			Parser: kn,
			Position: _h,
			SourceLocation: q0,
			TokContext: So,
			Token: U3,
			TokenType: Bt,
			defaultOptions: Ry,
			getLineInfo: eA,
			isIdentifierChar: Rd,
			isIdentifierStart: Ca,
			isNewLine: of,
			keywordTypes: L3,
			lineBreak: yo,
			lineBreakG: oY,
			nonASCIIwhitespace: Q5,
			parse: o$e,
			parseExpressionAt: s$e,
			tokContexts: sn,
			tokTypes: L,
			tokenizer: a$e,
			version: jY,
		},
		Symbol.toStringTag,
		{ value: "Module" },
	),
);
var _Y = { exports: {} },
	u$e = {
		quot: '"',
		amp: "&",
		apos: "'",
		lt: "<",
		gt: ">",
		nbsp: " ",
		iexcl: "¡",
		cent: "¢",
		pound: "£",
		curren: "¤",
		yen: "¥",
		brvbar: "¦",
		sect: "§",
		uml: "¨",
		copy: "©",
		ordf: "ª",
		laquo: "«",
		not: "¬",
		shy: "­",
		reg: "®",
		macr: "¯",
		deg: "°",
		plusmn: "±",
		sup2: "²",
		sup3: "³",
		acute: "´",
		micro: "µ",
		para: "¶",
		middot: "·",
		cedil: "¸",
		sup1: "¹",
		ordm: "º",
		raquo: "»",
		frac14: "¼",
		frac12: "½",
		frac34: "¾",
		iquest: "¿",
		Agrave: "À",
		Aacute: "Á",
		Acirc: "Â",
		Atilde: "Ã",
		Auml: "Ä",
		Aring: "Å",
		AElig: "Æ",
		Ccedil: "Ç",
		Egrave: "È",
		Eacute: "É",
		Ecirc: "Ê",
		Euml: "Ë",
		Igrave: "Ì",
		Iacute: "Í",
		Icirc: "Î",
		Iuml: "Ï",
		ETH: "Ð",
		Ntilde: "Ñ",
		Ograve: "Ò",
		Oacute: "Ó",
		Ocirc: "Ô",
		Otilde: "Õ",
		Ouml: "Ö",
		times: "×",
		Oslash: "Ø",
		Ugrave: "Ù",
		Uacute: "Ú",
		Ucirc: "Û",
		Uuml: "Ü",
		Yacute: "Ý",
		THORN: "Þ",
		szlig: "ß",
		agrave: "à",
		aacute: "á",
		acirc: "â",
		atilde: "ã",
		auml: "ä",
		aring: "å",
		aelig: "æ",
		ccedil: "ç",
		egrave: "è",
		eacute: "é",
		ecirc: "ê",
		euml: "ë",
		igrave: "ì",
		iacute: "í",
		icirc: "î",
		iuml: "ï",
		eth: "ð",
		ntilde: "ñ",
		ograve: "ò",
		oacute: "ó",
		ocirc: "ô",
		otilde: "õ",
		ouml: "ö",
		divide: "÷",
		oslash: "ø",
		ugrave: "ù",
		uacute: "ú",
		ucirc: "û",
		uuml: "ü",
		yacute: "ý",
		thorn: "þ",
		yuml: "ÿ",
		OElig: "Œ",
		oelig: "œ",
		Scaron: "Š",
		scaron: "š",
		Yuml: "Ÿ",
		fnof: "ƒ",
		circ: "ˆ",
		tilde: "˜",
		Alpha: "Α",
		Beta: "Β",
		Gamma: "Γ",
		Delta: "Δ",
		Epsilon: "Ε",
		Zeta: "Ζ",
		Eta: "Η",
		Theta: "Θ",
		Iota: "Ι",
		Kappa: "Κ",
		Lambda: "Λ",
		Mu: "Μ",
		Nu: "Ν",
		Xi: "Ξ",
		Omicron: "Ο",
		Pi: "Π",
		Rho: "Ρ",
		Sigma: "Σ",
		Tau: "Τ",
		Upsilon: "Υ",
		Phi: "Φ",
		Chi: "Χ",
		Psi: "Ψ",
		Omega: "Ω",
		alpha: "α",
		beta: "β",
		gamma: "γ",
		delta: "δ",
		epsilon: "ε",
		zeta: "ζ",
		eta: "η",
		theta: "θ",
		iota: "ι",
		kappa: "κ",
		lambda: "λ",
		mu: "μ",
		nu: "ν",
		xi: "ξ",
		omicron: "ο",
		pi: "π",
		rho: "ρ",
		sigmaf: "ς",
		sigma: "σ",
		tau: "τ",
		upsilon: "υ",
		phi: "φ",
		chi: "χ",
		psi: "ψ",
		omega: "ω",
		thetasym: "ϑ",
		upsih: "ϒ",
		piv: "ϖ",
		ensp: " ",
		emsp: " ",
		thinsp: " ",
		zwnj: "‌",
		zwj: "‍",
		lrm: "‎",
		rlm: "‏",
		ndash: "–",
		mdash: "—",
		lsquo: "‘",
		rsquo: "’",
		sbquo: "‚",
		ldquo: "“",
		rdquo: "”",
		bdquo: "„",
		dagger: "†",
		Dagger: "‡",
		bull: "•",
		hellip: "…",
		permil: "‰",
		prime: "′",
		Prime: "″",
		lsaquo: "‹",
		rsaquo: "›",
		oline: "‾",
		frasl: "⁄",
		euro: "€",
		image: "ℑ",
		weierp: "℘",
		real: "ℜ",
		trade: "™",
		alefsym: "ℵ",
		larr: "←",
		uarr: "↑",
		rarr: "→",
		darr: "↓",
		harr: "↔",
		crarr: "↵",
		lArr: "⇐",
		uArr: "⇑",
		rArr: "⇒",
		dArr: "⇓",
		hArr: "⇔",
		forall: "∀",
		part: "∂",
		exist: "∃",
		empty: "∅",
		nabla: "∇",
		isin: "∈",
		notin: "∉",
		ni: "∋",
		prod: "∏",
		sum: "∑",
		minus: "−",
		lowast: "∗",
		radic: "√",
		prop: "∝",
		infin: "∞",
		ang: "∠",
		and: "∧",
		or: "∨",
		cap: "∩",
		cup: "∪",
		int: "∫",
		there4: "∴",
		sim: "∼",
		cong: "≅",
		asymp: "≈",
		ne: "≠",
		equiv: "≡",
		le: "≤",
		ge: "≥",
		sub: "⊂",
		sup: "⊃",
		nsub: "⊄",
		sube: "⊆",
		supe: "⊇",
		oplus: "⊕",
		otimes: "⊗",
		perp: "⊥",
		sdot: "⋅",
		lceil: "⌈",
		rceil: "⌉",
		lfloor: "⌊",
		rfloor: "⌋",
		lang: "〈",
		rang: "〉",
		loz: "◊",
		spades: "♠",
		clubs: "♣",
		hearts: "♥",
		diams: "♦",
	};
const xF = yQ(l$e);
(function (t) {
	const e = u$e,
		n = /^[\da-fA-F]+$/,
		r = /^\d+$/,
		i = new WeakMap();
	function o(l) {
		l = l.Parser.acorn || l;
		let u = i.get(l);
		if (!u) {
			const c = l.tokTypes,
				d = l.TokContext,
				f = l.TokenType,
				h = new d("<tag", !1),
				p = new d("</tag", !1),
				g = new d("<tag>...</tag>", !0, !0),
				v = { tc_oTag: h, tc_cTag: p, tc_expr: g },
				b = {
					jsxName: new f("jsxName"),
					jsxText: new f("jsxText", { beforeExpr: !0 }),
					jsxTagStart: new f("jsxTagStart", { startsExpr: !0 }),
					jsxTagEnd: new f("jsxTagEnd"),
				};
			(b.jsxTagStart.updateContext = function () {
				this.context.push(g),
					this.context.push(h),
					(this.exprAllowed = !1);
			}),
				(b.jsxTagEnd.updateContext = function (y) {
					let x = this.context.pop();
					(x === h && y === c.slash) || x === p
						? (this.context.pop(),
							(this.exprAllowed = this.curContext() === g))
						: (this.exprAllowed = !0);
				}),
				(u = { tokContexts: v, tokTypes: b }),
				i.set(l, u);
		}
		return u;
	}
	function s(l) {
		if (!l) return l;
		if (l.type === "JSXIdentifier") return l.name;
		if (l.type === "JSXNamespacedName")
			return l.namespace.name + ":" + l.name.name;
		if (l.type === "JSXMemberExpression")
			return s(l.object) + "." + s(l.property);
	}
	(t.exports = function (l) {
		return (
			(l = l || {}),
			function (u) {
				return a(
					{
						allowNamespaces: l.allowNamespaces !== !1,
						allowNamespacedObjects: !!l.allowNamespacedObjects,
					},
					u,
				);
			}
		);
	}),
		Object.defineProperty(t.exports, "tokTypes", {
			get: function () {
				return o(xF).tokTypes;
			},
			configurable: !0,
			enumerable: !0,
		});
	function a(l, u) {
		const c = u.acorn || xF,
			d = o(c),
			f = c.tokTypes,
			h = d.tokTypes,
			p = c.tokContexts,
			g = d.tokContexts.tc_oTag,
			v = d.tokContexts.tc_cTag,
			b = d.tokContexts.tc_expr,
			y = c.isNewLine,
			x = c.isIdentifierStart,
			C = c.isIdentifierChar;
		return class extends u {
			static get acornJsx() {
				return d;
			}
			jsx_readToken() {
				let k = "",
					w = this.pos;
				for (;;) {
					this.pos >= this.input.length &&
						this.raise(this.start, "Unterminated JSX contents");
					let D = this.input.charCodeAt(this.pos);
					switch (D) {
						case 60:
						case 123:
							return this.pos === this.start
								? D === 60 && this.exprAllowed
									? (++this.pos,
										this.finishToken(h.jsxTagStart))
									: this.getTokenFromCode(D)
								: ((k += this.input.slice(w, this.pos)),
									this.finishToken(h.jsxText, k));
						case 38:
							(k += this.input.slice(w, this.pos)),
								(k += this.jsx_readEntity()),
								(w = this.pos);
							break;
						case 62:
						case 125:
							this.raise(
								this.pos,
								"Unexpected token `" +
									this.input[this.pos] +
									"`. Did you mean `" +
									(D === 62 ? "&gt;" : "&rbrace;") +
									'` or `{"' +
									this.input[this.pos] +
									'"}`?',
							);
						default:
							y(D)
								? ((k += this.input.slice(w, this.pos)),
									(k += this.jsx_readNewLine(!0)),
									(w = this.pos))
								: ++this.pos;
					}
				}
			}
			jsx_readNewLine(k) {
				let w = this.input.charCodeAt(this.pos),
					D;
				return (
					++this.pos,
					w === 13 && this.input.charCodeAt(this.pos) === 10
						? (++this.pos,
							(D = k
								? `
`
								: `\r
`))
						: (D = String.fromCharCode(w)),
					this.options.locations &&
						(++this.curLine, (this.lineStart = this.pos)),
					D
				);
			}
			jsx_readString(k) {
				let w = "",
					D = ++this.pos;
				for (;;) {
					this.pos >= this.input.length &&
						this.raise(this.start, "Unterminated string constant");
					let S = this.input.charCodeAt(this.pos);
					if (S === k) break;
					S === 38
						? ((w += this.input.slice(D, this.pos)),
							(w += this.jsx_readEntity()),
							(D = this.pos))
						: y(S)
							? ((w += this.input.slice(D, this.pos)),
								(w += this.jsx_readNewLine(!1)),
								(D = this.pos))
							: ++this.pos;
				}
				return (
					(w += this.input.slice(D, this.pos++)),
					this.finishToken(f.string, w)
				);
			}
			jsx_readEntity() {
				let k = "",
					w = 0,
					D,
					S = this.input[this.pos];
				S !== "&" &&
					this.raise(this.pos, "Entity must start with an ampersand");
				let $ = ++this.pos;
				for (; this.pos < this.input.length && w++ < 10; ) {
					if (((S = this.input[this.pos++]), S === ";")) {
						k[0] === "#"
							? k[1] === "x"
								? ((k = k.substr(2)),
									n.test(k) &&
										(D = String.fromCharCode(
											parseInt(k, 16),
										)))
								: ((k = k.substr(1)),
									r.test(k) &&
										(D = String.fromCharCode(
											parseInt(k, 10),
										)))
							: (D = e[k]);
						break;
					}
					k += S;
				}
				return D || ((this.pos = $), "&");
			}
			jsx_readWord() {
				let k,
					w = this.pos;
				do k = this.input.charCodeAt(++this.pos);
				while (C(k) || k === 45);
				return this.finishToken(
					h.jsxName,
					this.input.slice(w, this.pos),
				);
			}
			jsx_parseIdentifier() {
				let k = this.startNode();
				return (
					this.type === h.jsxName
						? (k.name = this.value)
						: this.type.keyword
							? (k.name = this.type.keyword)
							: this.unexpected(),
					this.next(),
					this.finishNode(k, "JSXIdentifier")
				);
			}
			jsx_parseNamespacedName() {
				let k = this.start,
					w = this.startLoc,
					D = this.jsx_parseIdentifier();
				if (!l.allowNamespaces || !this.eat(f.colon)) return D;
				var S = this.startNodeAt(k, w);
				return (
					(S.namespace = D),
					(S.name = this.jsx_parseIdentifier()),
					this.finishNode(S, "JSXNamespacedName")
				);
			}
			jsx_parseElementName() {
				if (this.type === h.jsxTagEnd) return "";
				let k = this.start,
					w = this.startLoc,
					D = this.jsx_parseNamespacedName();
				for (
					this.type === f.dot &&
					D.type === "JSXNamespacedName" &&
					!l.allowNamespacedObjects &&
					this.unexpected();
					this.eat(f.dot);

				) {
					let S = this.startNodeAt(k, w);
					(S.object = D),
						(S.property = this.jsx_parseIdentifier()),
						(D = this.finishNode(S, "JSXMemberExpression"));
				}
				return D;
			}
			jsx_parseAttributeValue() {
				switch (this.type) {
					case f.braceL:
						let k = this.jsx_parseExpressionContainer();
						return (
							k.expression.type === "JSXEmptyExpression" &&
								this.raise(
									k.start,
									"JSX attributes must only be assigned a non-empty expression",
								),
							k
						);
					case h.jsxTagStart:
					case f.string:
						return this.parseExprAtom();
					default:
						this.raise(
							this.start,
							"JSX value should be either an expression or a quoted JSX text",
						);
				}
			}
			jsx_parseEmptyExpression() {
				let k = this.startNodeAt(this.lastTokEnd, this.lastTokEndLoc);
				return this.finishNodeAt(
					k,
					"JSXEmptyExpression",
					this.start,
					this.startLoc,
				);
			}
			jsx_parseExpressionContainer() {
				let k = this.startNode();
				return (
					this.next(),
					(k.expression =
						this.type === f.braceR
							? this.jsx_parseEmptyExpression()
							: this.parseExpression()),
					this.expect(f.braceR),
					this.finishNode(k, "JSXExpressionContainer")
				);
			}
			jsx_parseAttribute() {
				let k = this.startNode();
				return this.eat(f.braceL)
					? (this.expect(f.ellipsis),
						(k.argument = this.parseMaybeAssign()),
						this.expect(f.braceR),
						this.finishNode(k, "JSXSpreadAttribute"))
					: ((k.name = this.jsx_parseNamespacedName()),
						(k.value = this.eat(f.eq)
							? this.jsx_parseAttributeValue()
							: null),
						this.finishNode(k, "JSXAttribute"));
			}
			jsx_parseOpeningElementAt(k, w) {
				let D = this.startNodeAt(k, w);
				D.attributes = [];
				let S = this.jsx_parseElementName();
				for (
					S && (D.name = S);
					this.type !== f.slash && this.type !== h.jsxTagEnd;

				)
					D.attributes.push(this.jsx_parseAttribute());
				return (
					(D.selfClosing = this.eat(f.slash)),
					this.expect(h.jsxTagEnd),
					this.finishNode(
						D,
						S ? "JSXOpeningElement" : "JSXOpeningFragment",
					)
				);
			}
			jsx_parseClosingElementAt(k, w) {
				let D = this.startNodeAt(k, w),
					S = this.jsx_parseElementName();
				return (
					S && (D.name = S),
					this.expect(h.jsxTagEnd),
					this.finishNode(
						D,
						S ? "JSXClosingElement" : "JSXClosingFragment",
					)
				);
			}
			jsx_parseElementAt(k, w) {
				let D = this.startNodeAt(k, w),
					S = [],
					$ = this.jsx_parseOpeningElementAt(k, w),
					A = null;
				if (!$.selfClosing) {
					e: for (;;)
						switch (this.type) {
							case h.jsxTagStart:
								if (
									((k = this.start),
									(w = this.startLoc),
									this.next(),
									this.eat(f.slash))
								) {
									A = this.jsx_parseClosingElementAt(k, w);
									break e;
								}
								S.push(this.jsx_parseElementAt(k, w));
								break;
							case h.jsxText:
								S.push(this.parseExprAtom());
								break;
							case f.braceL:
								S.push(this.jsx_parseExpressionContainer());
								break;
							default:
								this.unexpected();
						}
					s(A.name) !== s($.name) &&
						this.raise(
							A.start,
							"Expected corresponding JSX closing tag for <" +
								s($.name) +
								">",
						);
				}
				let T = $.name ? "Element" : "Fragment";
				return (
					(D["opening" + T] = $),
					(D["closing" + T] = A),
					(D.children = S),
					this.type === f.relational &&
						this.value === "<" &&
						this.raise(
							this.start,
							"Adjacent JSX elements must be wrapped in an enclosing tag",
						),
					this.finishNode(D, "JSX" + T)
				);
			}
			jsx_parseText() {
				let k = this.parseLiteral(this.value);
				return (k.type = "JSXText"), k;
			}
			jsx_parseElement() {
				let k = this.start,
					w = this.startLoc;
				return this.next(), this.jsx_parseElementAt(k, w);
			}
			parseExprAtom(k) {
				return this.type === h.jsxText
					? this.jsx_parseText()
					: this.type === h.jsxTagStart
						? this.jsx_parseElement()
						: super.parseExprAtom(k);
			}
			readToken(k) {
				let w = this.curContext();
				if (w === b) return this.jsx_readToken();
				if (w === g || w === v) {
					if (x(k)) return this.jsx_readWord();
					if (k == 62)
						return ++this.pos, this.finishToken(h.jsxTagEnd);
					if ((k === 34 || k === 39) && w == g)
						return this.jsx_readString(k);
				}
				return k === 60 &&
					this.exprAllowed &&
					this.input.charCodeAt(this.pos + 1) !== 33
					? (++this.pos, this.finishToken(h.jsxTagStart))
					: super.readToken(k);
			}
			updateContext(k) {
				if (this.type == f.braceL) {
					var w = this.curContext();
					w == g
						? this.context.push(p.b_expr)
						: w == b
							? this.context.push(p.b_tmpl)
							: super.updateContext(k),
						(this.exprAllowed = !0);
				} else if (this.type === f.slash && k === h.jsxTagStart)
					(this.context.length -= 2),
						this.context.push(v),
						(this.exprAllowed = !1);
				else return super.updateContext(k);
			}
		};
	}
})(_Y);
var c$e = _Y.exports;
const d$e = Dl(c$e);
const f$e = {}.hasOwnProperty,
	h$e = Symbol("continue"),
	wC = Symbol("exit"),
	p$e = Symbol("skip");
function m$e(t, e) {
	let n, r;
	typeof e == "function"
		? (n = e)
		: e &&
			typeof e == "object" &&
			(e.enter && (n = e.enter), e.leave && (r = e.leave)),
		i(t, void 0, void 0, [])();
	function i(o, s, a, l) {
		return EC(o) && (u.displayName = "node (" + o.type + ")"), u;
		function u() {
			const c = n ? kF(n(o, s, a, l)) : [];
			if (c[0] === wC) return c;
			if (c[0] !== p$e) {
				let d;
				for (d in o)
					if (
						f$e.call(o, d) &&
						o[d] &&
						typeof o[d] == "object" &&
						d !== "data" &&
						d !== "position"
					) {
						const f = l.concat(o),
							h = o[d];
						if (Array.isArray(h)) {
							const p = h;
							let g = 0;
							for (; g > -1 && g < p.length; ) {
								const v = p[g];
								if (EC(v)) {
									const b = i(v, d, g, f)();
									if (b[0] === wC) return b;
									g = typeof b[1] == "number" ? b[1] : g + 1;
								} else g++;
							}
						} else if (EC(h)) {
							const p = i(h, d, void 0, f)();
							if (p[0] === wC) return p;
						}
					}
			}
			return r ? kF(r(o, s, a, l)) : c;
		}
	}
}
function kF(t) {
	return Array.isArray(t) ? t : typeof t == "number" ? [h$e, t] : [t];
}
function EC(t) {
	return !!(
		t &&
		typeof t == "object" &&
		"type" in t &&
		typeof t.type == "string" &&
		t.type.length > 0
	);
}
function zY(t, e) {
	const n = e.prefix || "",
		r = e.suffix || "",
		i = Object.assign({}, e.acornOptions),
		o = [],
		s = [],
		a = i.onComment,
		l = i.onToken;
	let u = !1,
		c,
		d;
	const f = Object.assign({}, i, { onComment: o, preserveParens: !0 });
	l && (f.onToken = s);
	const h = g$e(t, e.tokenTypes),
		p = h.value,
		g = n + p + r,
		v = e.expression && CF(p);
	if (v && !e.allowEmpty)
		throw new _t("Unexpected empty expression", {
			place: y(0),
			ruleId: "unexpected-empty-expression",
			source: "micromark-extension-mdx-expression",
		});
	try {
		c =
			e.expression && !v
				? e.acorn.parseExpressionAt(g, 0, f)
				: e.acorn.parse(g, f);
	} catch (x) {
		const C = x,
			k = y(C.pos);
		(C.message = String(C.message).replace(/ \(\d+:\d+\)$/, "")),
			(C.pos = k.offset),
			(C.loc = { line: k.line, column: k.column - 1 }),
			(d = C),
			(u =
				C.raisedAt >= n.length + p.length ||
				C.message === "Unterminated comment");
	}
	if (c && e.expression && !v)
		if (CF(g.slice(c.end, g.length - r.length)))
			c = {
				type: "Program",
				start: 0,
				end: n.length + p.length,
				body: [
					{
						type: "ExpressionStatement",
						expression: c,
						start: 0,
						end: n.length + p.length,
					},
				],
				sourceType: "module",
				comments: [],
			};
		else {
			const x = y(c.end),
				C = new Error("Unexpected content after expression");
			(C.pos = x.offset),
				(C.loc = { line: x.line, column: x.column - 1 }),
				(d = C),
				(c = void 0);
		}
	if (c) {
		if (
			((c.comments = o),
			m$e(c, function (x, C, k, w) {
				let D = w[w.length - 1],
					S = C;
				x.type === "ParenthesizedExpression" &&
					D &&
					S &&
					(typeof k == "number" && ((D = D[S]), (S = k)),
					(D[S] = x.expression)),
					b(x);
			}),
			Array.isArray(a))
		)
			a.push(...o);
		else if (typeof a == "function")
			for (const x of o)
				a(
					x.type === "Block",
					x.value,
					x.start,
					x.end,
					x.loc.start,
					x.loc.end,
				);
		for (const x of s)
			x.end <= n.length ||
				x.start - n.length >= p.length ||
				(b(x), Array.isArray(l) ? l.push(x) : l(x));
	}
	return { estree: c, error: d, swallow: u };
	function b(x) {
		const C = y(x.start),
			k = y(x.end);
		(x.start = C.offset),
			(x.end = k.offset),
			(x.loc = {
				start: { line: C.line, column: C.column - 1, offset: C.offset },
				end: { line: k.line, column: k.column - 1, offset: k.offset },
			}),
			(x.range = [x.start, x.end]);
	}
	function y(x) {
		let C = x - n.length;
		C < 0 ? (C = 0) : C > p.length && (C = p.length);
		let k = b$e(h.stops, C);
		return (
			k ||
				(k = {
					line: e.start.line,
					column: e.start.column,
					offset: e.start.offset,
				}),
			k
		);
	}
}
function CF(t) {
	return /^\s*$/.test(
		t
			.replace(/\/\*[\s\S]*?\*\//g, "")
			.replace(/\/\/[^\r\n]*(\r\n|\n|\r)/g, ""),
	);
}
function g$e(t, e) {
	const n = { value: "", stops: [] };
	let r = -1;
	for (; ++r < t.length; ) {
		const i = t[r];
		if (i[0] === "enter") {
			const o = i[1].type;
			if (o === "lineEnding" || e.includes(o)) {
				const s = i[2].sliceStream(i[1]);
				for (; s.length > 0 && s[0] === -1; ) s.shift();
				const a = v$e(s);
				n.stops.push([n.value.length, i[1].start]),
					(n.value += a),
					n.stops.push([n.value.length, i[1].end]);
			}
		}
	}
	return n;
}
function b$e(t, e) {
	let n = 0;
	for (; n < t.length && t[n][0] <= e; ) n += 1;
	if (n === 0) return;
	const [r, i] = t[n - 1],
		o = e - r;
	return { line: i.line, column: i.column + o, offset: i.offset + o };
}
function v$e(t) {
	let e = -1;
	const n = [];
	let r;
	for (; ++e < t.length; ) {
		const i = t[e];
		let o;
		if (typeof i == "string") o = i;
		else
			switch (i) {
				case -5: {
					o = "\r";
					break;
				}
				case -4: {
					o = `
`;
					break;
				}
				case -3: {
					o = `\r
`;
					break;
				}
				case -2: {
					o = "	";
					break;
				}
				case -1: {
					if (r) continue;
					o = " ";
					break;
				}
				default:
					o = String.fromCharCode(i);
			}
		(r = i === -2), n.push(o);
	}
	return n.join("");
}
function DC(t) {
	const e = t || {},
		n = e.loc || {},
		r = e.range || [void 0, void 0],
		i = wF(n.start, r[0] || e.start),
		o = wF(n.end, r[1] || e.end);
	if (i && o) return { start: i, end: o };
}
function wF(t, e) {
	if (t && typeof t == "object") {
		const n = "line" in t ? SC(t.line) : void 0,
			r = "column" in t ? SC(t.column) : void 0;
		if (n && r !== void 0) return { line: n, column: r + 1, offset: SC(e) };
	}
}
function SC(t) {
	return typeof t == "number" && t > -1 ? t : void 0;
}
const y$e = 2,
	Hf =
		"https://github.com/micromark/micromark-extension-mdx-expression/tree/main/packages/micromark-extension-mdx-expression",
	x$e =
		"#unexpected-end-of-file-in-expression-expected-a-corresponding-closing-brace-for-",
	k$e =
		"#unexpected-lazy-line-in-expression-in-container-expected-line-to-be-prefixed",
	EF = "#unexpected-type-in-code-expected-an-object-spread-spread",
	C$e =
		"#unexpected-extra-content-in-spread-only-a-single-spread-is-supported",
	w$e = "#could-not-parse-expression-with-acorn";
function zy(t, e, n, r, i, o, s, a, l, u, c) {
	const d = this,
		f = this.events.length + 3;
	let h = 0,
		p,
		g;
	return v;
	function v(C) {
		return (
			t.enter(n), t.enter(r), t.consume(C), t.exit(r), (p = d.now()), b
		);
	}
	function b(C) {
		if (C === null) {
			if (g) throw g;
			const k = new _t(
				"Unexpected end of file in expression, expected a corresponding closing brace for `{`",
				{
					place: d.now(),
					ruleId: "unexpected-eof",
					source: "micromark-extension-mdx-expression",
				},
			);
			throw ((k.url = Hf + x$e), k);
		}
		if (He(C))
			return t.enter("lineEnding"), t.consume(C), t.exit("lineEnding"), x;
		if (C === 125 && h === 0) {
			const k = o
				? E$e.call(d, o, s, i, f, p, u || !1, l || !1)
				: { type: "ok", estree: void 0 };
			if (k.type === "ok") {
				t.enter(r), t.consume(C), t.exit(r);
				const w = t.exit(n);
				return (
					a && k.estree && Object.assign(w, { estree: k.estree }), e
				);
			}
			return (g = k.message), t.enter(i), t.consume(C), y;
		}
		return t.enter(i), y(C);
	}
	function y(C) {
		return (C === 125 && h === 0) || C === null || He(C)
			? (t.exit(i), b(C))
			: (C === 123 && !o ? (h += 1) : C === 125 && (h -= 1),
				t.consume(C),
				y);
	}
	function x(C) {
		const k = d.now();
		if (k.line !== p.line && !c && d.parser.lazy[k.line]) {
			const w = new _t(
				"Unexpected lazy line in expression in container, expected line to be prefixed with `>` when in a block quote, whitespace when in a list, etc",
				{
					place: d.now(),
					ruleId: "unexpected-lazy",
					source: "micromark-extension-mdx-expression",
				},
			);
			throw ((w.url = Hf + k$e), w);
		}
		return xt(C) ? At(t, b, "linePrefix", y$e + 1)(C) : b(C);
	}
}
function E$e(t, e, n, r, i, o, s) {
	const a = zY(this.events.slice(r), {
			acorn: t,
			tokenTypes: [n],
			acornOptions: e,
			start: i,
			expression: !0,
			allowEmpty: o,
			prefix: s ? "({" : "",
			suffix: s ? "})" : "",
		}),
		l = a.estree;
	if (s && l) {
		const u = l.body[0];
		if (
			u.type !== "ExpressionStatement" ||
			u.expression.type !== "ObjectExpression"
		) {
			const c = DC(u),
				d = new _t(
					"Unexpected `" +
						u.type +
						"` in code: expected an object spread (`{...spread}`)",
					{
						place: c.start,
						ruleId: "non-spread",
						source: "micromark-extension-mdx-expression",
					},
				);
			throw ((d.url = Hf + EF), d);
		}
		if (u.expression.properties[1]) {
			const c = DC(u.expression.properties[1]),
				d = new _t(
					"Unexpected extra content in spread: only a single spread is supported",
					{
						place: c.start,
						ruleId: "spread-extra",
						source: "micromark-extension-mdx-expression",
					},
				);
			throw ((d.url = Hf + C$e), d);
		}
		if (
			u.expression.properties[0] &&
			u.expression.properties[0].type !== "SpreadElement"
		) {
			const c = DC(u.expression.properties[0]),
				d = new _t(
					"Unexpected `" +
						u.expression.properties[0].type +
						"` in code: only spread elements are supported",
					{
						place: c.start,
						ruleId: "non-spread",
						source: "micromark-extension-mdx-expression",
					},
				);
			throw ((d.url = Hf + EF), d);
		}
	}
	if (a.error) {
		const u = new _t("Could not parse expression with acorn", {
			cause: a.error,
			place: {
				line: a.error.loc.line,
				column: a.error.loc.column + 1,
				offset: a.error.pos,
			},
			ruleId: "acorn",
			source: "micromark-extension-mdx-expression",
		});
		return (u.url = Hf + w$e), { type: "nok", message: u };
	}
	return { type: "ok", estree: l };
}
function D$e(t) {
	const e = t || {},
		n = e.addResult,
		r = e.acorn,
		i = e.spread;
	let o = e.allowEmpty,
		s;
	if ((o == null && (o = !0), r)) {
		if (!r.parseExpressionAt)
			throw new Error(
				"Expected a proper `acorn` instance passed in as `options.acorn`",
			);
		s = Object.assign(
			{ ecmaVersion: 2024, sourceType: "module" },
			e.acornOptions,
		);
	} else if (e.acornOptions || e.addResult)
		throw new Error(
			"Expected an `acorn` instance passed in as `options.acorn`",
		);
	return {
		flow: { 123: { name: "mdxFlowExpression", tokenize: a, concrete: !0 } },
		text: { 123: { name: "mdxTextExpression", tokenize: l } },
	};
	function a(u, c, d) {
		const f = this;
		return h;
		function h(b) {
			return p(b);
		}
		function p(b) {
			return zy.call(
				f,
				u,
				g,
				"mdxFlowExpression",
				"mdxFlowExpressionMarker",
				"mdxFlowExpressionChunk",
				r,
				s,
				n,
				i,
				o,
			)(b);
		}
		function g(b) {
			return xt(b) ? At(u, v, "whitespace")(b) : v(b);
		}
		function v(b) {
			const y = f.parser.constructs.flow[60],
				C = (Array.isArray(y) ? y : y ? [y] : []).find(function (k) {
					return k.name === "mdxJsxFlowTag";
				});
			return b === 60 && C
				? u.attempt(C, v, d)(b)
				: b === null || He(b)
					? c(b)
					: d(b);
		}
	}
	function l(u, c) {
		const d = this;
		return f;
		function f(h) {
			return zy.call(
				d,
				u,
				c,
				"mdxTextExpression",
				"mdxTextExpressionMarker",
				"mdxTextExpressionChunk",
				r,
				s,
				n,
				i,
				o,
				!0,
			)(h);
		}
	}
}
const S$e = /[$_\p{ID_Start}]/u,
	A$e = /[$_\u{200C}\u{200D}\p{ID_Continue}]/u,
	$$e = /[-$_\u{200C}\u{200D}\p{ID_Continue}]/u,
	T$e = {};
function ns(t) {
	return t ? S$e.test(String.fromCodePoint(t)) : !1;
}
function jp(t, e) {
	const r = (e || T$e).jsx ? $$e : A$e;
	return t ? r.test(String.fromCodePoint(t)) : !1;
}
const DF = "https://github.com/micromark/micromark-extension-mdx-jsx";
function LY(
	t,
	e,
	n,
	r,
	i,
	o,
	s,
	a,
	l,
	u,
	c,
	d,
	f,
	h,
	p,
	g,
	v,
	b,
	y,
	x,
	C,
	k,
	w,
	D,
	S,
	$,
	A,
	T,
	I,
	F,
	N,
	O,
) {
	const _ = this;
	let j, V;
	return K;
	function K(U) {
		return t.enter(a), t.enter(l), t.consume(U), t.exit(l), M;
	}
	function M(U) {
		return It(U) ? n(U) : ((j = G), We(U));
	}
	function G(U) {
		if (U === 47) return t.enter(u), t.consume(U), t.exit(u), (j = H), We;
		if (U === 62) return _e(U);
		if (U !== null && U >= 0 && ns(U))
			return t.enter(d), t.enter(f), t.consume(U), P;
		fe(
			U,
			"before name",
			"a character that can start a name, such as a letter, `$`, or `_`" +
				(U === 33
					? " (note: to create a comment in MDX, use `{/* text */}`)"
					: ""),
		);
	}
	function H(U) {
		if (U === 62) return _e(U);
		if (U !== null && U >= 0 && ns(U))
			return t.enter(d), t.enter(f), t.consume(U), P;
		fe(
			U,
			"before name",
			"a character that can start a name, such as a letter, `$`, or `_`" +
				(U === 42 || U === 47
					? " (note: JS comments in JSX tags are not supported in MDX)"
					: ""),
		);
	}
	function P(U) {
		if (U !== null && U >= 0 && jp(U, { jsx: !0 })) return t.consume(U), P;
		if (
			U === 46 ||
			U === 47 ||
			U === 58 ||
			U === 62 ||
			U === 123 ||
			It(U) ||
			ai(U)
		)
			return t.exit(f), (j = q), We(U);
		fe(
			U,
			"in name",
			"a name character such as letters, digits, `$`, or `_`; whitespace before attributes; or the end of the tag" +
				(U === 64
					? " (note: to create a link in MDX, use `[text](url)`)"
					: ""),
		);
	}
	function q(U) {
		if (U === 46) return t.enter(h), t.consume(U), t.exit(h), (j = J), We;
		if (U === 58) return t.enter(g), t.consume(U), t.exit(g), (j = ne), We;
		if (
			U === 47 ||
			U === 62 ||
			U === 123 ||
			(U !== null && U >= 0 && ns(U))
		)
			return t.exit(d), re(U);
		fe(
			U,
			"after name",
			"a character that can start an attribute name, such as a letter, `$`, or `_`; whitespace before attributes; or the end of the tag",
		);
	}
	function J(U) {
		if (U !== null && U >= 0 && ns(U)) return t.enter(p), t.consume(U), Z;
		fe(
			U,
			"before member name",
			"a character that can start an attribute name, such as a letter, `$`, or `_`; whitespace before attributes; or the end of the tag",
		);
	}
	function Z(U) {
		if (U !== null && U >= 0 && jp(U, { jsx: !0 })) return t.consume(U), Z;
		if (U === 46 || U === 47 || U === 62 || U === 123 || It(U) || ai(U))
			return t.exit(p), (j = oe), We(U);
		fe(
			U,
			"in member name",
			"a name character such as letters, digits, `$`, or `_`; whitespace before attributes; or the end of the tag" +
				(U === 64
					? " (note: to create a link in MDX, use `[text](url)`)"
					: ""),
		);
	}
	function oe(U) {
		if (U === 46) return t.enter(h), t.consume(U), t.exit(h), (j = J), We;
		if (
			U === 47 ||
			U === 62 ||
			U === 123 ||
			(U !== null && U >= 0 && ns(U))
		)
			return t.exit(d), re(U);
		fe(
			U,
			"after member name",
			"a character that can start an attribute name, such as a letter, `$`, or `_`; whitespace before attributes; or the end of the tag",
		);
	}
	function ne(U) {
		if (U !== null && U >= 0 && ns(U)) return t.enter(v), t.consume(U), de;
		fe(
			U,
			"before local name",
			"a character that can start a name, such as a letter, `$`, or `_`" +
				(U === 43 || (U !== null && U > 46 && U < 58)
					? " (note: to create a link in MDX, use `[text](url)`)"
					: ""),
		);
	}
	function de(U) {
		if (U !== null && U >= 0 && jp(U, { jsx: !0 })) return t.consume(U), de;
		if (U === 47 || U === 62 || U === 123 || It(U) || ai(U))
			return t.exit(v), (j = se), We(U);
		fe(
			U,
			"in local name",
			"a name character such as letters, digits, `$`, or `_`; whitespace before attributes; or the end of the tag",
		);
	}
	function se(U) {
		if (
			U === 47 ||
			U === 62 ||
			U === 123 ||
			(U !== null && U >= 0 && ns(U))
		)
			return t.exit(d), re(U);
		fe(
			U,
			"after local name",
			"a character that can start an attribute name, such as a letter, `$`, or `_`; whitespace before attributes; or the end of the tag",
		);
	}
	function re(U) {
		if (U === 47) return t.enter(c), t.consume(U), t.exit(c), (j = De), We;
		if (U === 62) return _e(U);
		if (U === 123) return zy.call(_, t, he, b, y, x, r, i, o, !0, !1, s)(U);
		if (U !== null && U >= 0 && ns(U))
			return t.enter(C), t.enter(k), t.enter(w), t.consume(U), ye;
		fe(
			U,
			"before attribute name",
			"a character that can start an attribute name, such as a letter, `$`, or `_`; whitespace before attributes; or the end of the tag",
		);
	}
	function he(U) {
		return (j = re), We(U);
	}
	function ye(U) {
		if (U !== null && U >= 0 && jp(U, { jsx: !0 })) return t.consume(U), ye;
		if (
			U === 47 ||
			U === 58 ||
			U === 61 ||
			U === 62 ||
			U === 123 ||
			It(U) ||
			ai(U)
		)
			return t.exit(w), (j = Ae), We(U);
		fe(
			U,
			"in attribute name",
			"an attribute name character such as letters, digits, `$`, or `_`; `=` to initialize a value; whitespace before attributes; or the end of the tag",
		);
	}
	function Ae(U) {
		if (U === 58) return t.enter(D), t.consume(U), t.exit(D), (j = Pe), We;
		if (U === 61)
			return t.exit(k), t.enter($), t.consume(U), t.exit($), (j = rt), We;
		if (
			U === 47 ||
			U === 62 ||
			U === 123 ||
			It(U) ||
			ai(U) ||
			(U !== null && U >= 0 && ns(U))
		)
			return t.exit(k), t.exit(C), (j = re), We(U);
		fe(
			U,
			"after attribute name",
			"a character that can start an attribute name, such as a letter, `$`, or `_`; `=` to initialize a value; or the end of the tag",
		);
	}
	function Pe(U) {
		if (U !== null && U >= 0 && ns(U)) return t.enter(S), t.consume(U), we;
		fe(
			U,
			"before local attribute name",
			"a character that can start an attribute name, such as a letter, `$`, or `_`; `=` to initialize a value; or the end of the tag",
		);
	}
	function we(U) {
		if (U !== null && U >= 0 && jp(U, { jsx: !0 })) return t.consume(U), we;
		if (U === 47 || U === 61 || U === 62 || U === 123 || It(U) || ai(U))
			return t.exit(S), t.exit(k), (j = Ke), We(U);
		fe(
			U,
			"in local attribute name",
			"an attribute name character such as letters, digits, `$`, or `_`; `=` to initialize a value; whitespace before attributes; or the end of the tag",
		);
	}
	function Ke(U) {
		if (U === 61) return t.enter($), t.consume(U), t.exit($), (j = rt), We;
		if (
			U === 47 ||
			U === 62 ||
			U === 123 ||
			(U !== null && U >= 0 && ns(U))
		)
			return t.exit(C), re(U);
		fe(
			U,
			"after local attribute name",
			"a character that can start an attribute name, such as a letter, `$`, or `_`; `=` to initialize a value; or the end of the tag",
		);
	}
	function rt(U) {
		if (U === 34 || U === 39)
			return t.enter(A), t.enter(T), t.consume(U), t.exit(T), (V = U), Me;
		if (U === 123) return zy.call(_, t, Ce, F, N, O, r, i, o, !1, !1, s)(U);
		fe(
			U,
			"before attribute value",
			"a character that can start an attribute value, such as `\"`, `'`, or `{`" +
				(U === 60
					? " (note: to use an element or fragment as a prop value in MDX, use `{<element />}`)"
					: ""),
		);
	}
	function Ce(U) {
		return t.exit(C), (j = re), We(U);
	}
	function Me(U) {
		return (
			U === null &&
				fe(
					U,
					"in attribute value",
					"a corresponding closing quote `" +
						String.fromCodePoint(V) +
						"`",
				),
			U === V
				? (t.enter(T),
					t.consume(U),
					t.exit(T),
					t.exit(A),
					t.exit(C),
					(V = void 0),
					(j = re),
					We)
				: He(U)
					? ((j = Me), We(U))
					: (t.enter(I), me(U))
		);
	}
	function me(U) {
		return U === null || U === V || He(U)
			? (t.exit(I), Me(U))
			: (t.consume(U), me);
	}
	function De(U) {
		if (U === 62) return _e(U);
		fe(
			U,
			"after self-closing slash",
			"`>` to end the tag" +
				(U === 42 || U === 47
					? " (note: JS comments in JSX tags are not supported in MDX)"
					: ""),
		);
	}
	function _e(U) {
		return t.enter(l), t.consume(U), t.exit(l), t.exit(a), e;
	}
	function We(U) {
		return He(U)
			? (t.enter("lineEnding"), t.consume(U), t.exit("lineEnding"), ae)
			: xt(U) || ai(U)
				? (t.enter("esWhitespace"), Et(U))
				: j(U);
	}
	function Et(U) {
		return He(U)
			? (t.exit("esWhitespace"), We(U))
			: xt(U) || ai(U)
				? (t.consume(U), Et)
				: (t.exit("esWhitespace"), j(U));
	}
	function ae(U) {
		if (!s && _.parser.lazy[_.now().line]) {
			const tt = new _t(
				"Unexpected lazy line in container, expected line to be prefixed with `>` when in a block quote, whitespace when in a list, etc",
				_.now(),
				"micromark-extension-mdx-jsx:unexpected-lazy",
			);
			throw (
				((tt.url =
					DF +
					"#unexpected-lazy-line-in-container-expected-line-to-be"),
				tt)
			);
		}
		return We(U);
	}
	function fe(U, tt, Dt) {
		const Xt = new _t(
			"Unexpected " +
				(U === null
					? "end of file"
					: "character `" +
						(U === 96 ? "` ` `" : String.fromCodePoint(U)) +
						"` (" +
						B$e(U) +
						")") +
				" " +
				tt +
				", expected " +
				Dt,
			_.now(),
			"micromark-extension-mdx-jsx:unexpected-" +
				(U === null ? "eof" : "character"),
		);
		throw (
			((Xt.url =
				DF +
				(U === null
					? "#unexpected-end-of-file-at-expected-expect"
					: "#unexpected-character-at-expected-expect")),
			Xt)
		);
	}
}
function B$e(t) {
	return "U+" + t.toString(16).toUpperCase().padStart(4, "0");
}
function I$e(t, e) {
	return { name: "mdxJsxTextTag", tokenize: n };
	function n(r, i, o) {
		return LY.call(
			this,
			r,
			i,
			o,
			t,
			e.acornOptions,
			e.addResult,
			!0,
			"mdxJsxTextTag",
			"mdxJsxTextTagMarker",
			"mdxJsxTextTagClosingMarker",
			"mdxJsxTextTagSelfClosingMarker",
			"mdxJsxTextTagName",
			"mdxJsxTextTagNamePrimary",
			"mdxJsxTextTagNameMemberMarker",
			"mdxJsxTextTagNameMember",
			"mdxJsxTextTagNamePrefixMarker",
			"mdxJsxTextTagNameLocal",
			"mdxJsxTextTagExpressionAttribute",
			"mdxJsxTextTagExpressionAttributeMarker",
			"mdxJsxTextTagExpressionAttributeValue",
			"mdxJsxTextTagAttribute",
			"mdxJsxTextTagAttributeName",
			"mdxJsxTextTagAttributeNamePrimary",
			"mdxJsxTextTagAttributeNamePrefixMarker",
			"mdxJsxTextTagAttributeNameLocal",
			"mdxJsxTextTagAttributeInitializerMarker",
			"mdxJsxTextTagAttributeValueLiteral",
			"mdxJsxTextTagAttributeValueLiteralMarker",
			"mdxJsxTextTagAttributeValueLiteralValue",
			"mdxJsxTextTagAttributeValueExpression",
			"mdxJsxTextTagAttributeValueExpressionMarker",
			"mdxJsxTextTagAttributeValueExpressionValue",
		);
	}
}
function F$e(t, e) {
	return { name: "mdxJsxFlowTag", tokenize: n, concrete: !0 };
	function n(r, i, o) {
		const s = this;
		return a;
		function a(d) {
			return l(d);
		}
		function l(d) {
			return LY.call(
				s,
				r,
				u,
				o,
				t,
				e.acornOptions,
				e.addResult,
				!1,
				"mdxJsxFlowTag",
				"mdxJsxFlowTagMarker",
				"mdxJsxFlowTagClosingMarker",
				"mdxJsxFlowTagSelfClosingMarker",
				"mdxJsxFlowTagName",
				"mdxJsxFlowTagNamePrimary",
				"mdxJsxFlowTagNameMemberMarker",
				"mdxJsxFlowTagNameMember",
				"mdxJsxFlowTagNamePrefixMarker",
				"mdxJsxFlowTagNameLocal",
				"mdxJsxFlowTagExpressionAttribute",
				"mdxJsxFlowTagExpressionAttributeMarker",
				"mdxJsxFlowTagExpressionAttributeValue",
				"mdxJsxFlowTagAttribute",
				"mdxJsxFlowTagAttributeName",
				"mdxJsxFlowTagAttributeNamePrimary",
				"mdxJsxFlowTagAttributeNamePrefixMarker",
				"mdxJsxFlowTagAttributeNameLocal",
				"mdxJsxFlowTagAttributeInitializerMarker",
				"mdxJsxFlowTagAttributeValueLiteral",
				"mdxJsxFlowTagAttributeValueLiteralMarker",
				"mdxJsxFlowTagAttributeValueLiteralValue",
				"mdxJsxFlowTagAttributeValueExpression",
				"mdxJsxFlowTagAttributeValueExpressionMarker",
				"mdxJsxFlowTagAttributeValueExpressionValue",
			)(d);
		}
		function u(d) {
			return xt(d) ? At(r, c, "whitespace")(d) : c(d);
		}
		function c(d) {
			const f = s.parser.constructs.flow[123],
				p = (Array.isArray(f) ? f : f ? [f] : []).find(
					(g) => g.name === "mdxFlowExpression",
				);
			return d === 60
				? a(d)
				: d === 123 && p
					? r.attempt(p, c, o)(d)
					: d === null || He(d)
						? i(d)
						: o(d);
		}
	}
}
function P$e(t) {
	const e = t || {},
		n = e.acorn;
	let r;
	if (n) {
		if (!n.parse || !n.parseExpressionAt)
			throw new Error(
				"Expected a proper `acorn` instance passed in as `options.acorn`",
			);
		r = Object.assign(
			{ ecmaVersion: 2024, sourceType: "module" },
			e.acornOptions,
			{ locations: !0 },
		);
	} else if (e.acornOptions || e.addResult)
		throw new Error(
			"Expected an `acorn` instance passed in as `options.acorn`",
		);
	return {
		flow: {
			60: F$e(n || void 0, {
				acornOptions: r,
				addResult: e.addResult || void 0,
			}),
		},
		text: {
			60: I$e(n || void 0, {
				acornOptions: r,
				addResult: e.addResult || void 0,
			}),
		},
	};
}
function N$e() {
	return {
		disable: { null: ["autolink", "codeIndented", "htmlFlow", "htmlText"] },
	};
}
function R$e(t) {
	const e = t || {},
		n = e.loc || {},
		r = e.range || [void 0, void 0],
		i = SF(n.start, r[0] || e.start),
		o = SF(n.end, r[1] || e.end);
	if (i && o) return { start: i, end: o };
}
function SF(t, e) {
	if (t && typeof t == "object") {
		const n = "line" in t ? AC(t.line) : void 0,
			r = "column" in t ? AC(t.column) : void 0;
		if (n && r !== void 0) return { line: n, column: r + 1, offset: AC(e) };
	}
}
function AC(t) {
	return typeof t == "number" && t > -1 ? t : void 0;
}
const O$e = { tokenize: _$e, partial: !0 },
	AF = "https://github.com/micromark/micromark-extension-mdxjs-esm",
	M$e = new Set([
		"ExportAllDeclaration",
		"ExportDefaultDeclaration",
		"ExportNamedDeclaration",
		"ImportDeclaration",
	]);
function j$e(t) {
	const e = { tokenize: i, concrete: !0 };
	if (!t || !t.acorn || !t.acorn.parse)
		throw new Error(
			"Expected an `acorn` instance passed in as `options.acorn`",
		);
	const n = t.acorn,
		r = Object.assign(
			{ ecmaVersion: 2024, sourceType: "module" },
			t.acornOptions,
			{ locations: !0 },
		);
	return { flow: { 101: e, 105: e } };
	function i(o, s, a) {
		const l = this,
			u =
				l.parser.definedModuleSpecifiers ||
				(l.parser.definedModuleSpecifiers = []),
			c = this.events.length + 1;
		let d = "";
		return l.interrupt ? a : f;
		function f(y) {
			return l.now().column > 1
				? a(y)
				: (o.enter("mdxjsEsm"),
					o.enter("mdxjsEsmData"),
					o.consume(y),
					(d += String.fromCharCode(y)),
					h);
		}
		function h(y) {
			return Vr(y)
				? (o.consume(y), (d += String.fromCharCode(y)), h)
				: (d === "import" || d === "export") && y === 32
					? (o.consume(y), p)
					: a(y);
		}
		function p(y) {
			return y === null || He(y)
				? (o.exit("mdxjsEsmData"), g(y))
				: (o.consume(y), p);
		}
		function g(y) {
			return y === null
				? b(y)
				: He(y)
					? o.check(O$e, b, v)(y)
					: (o.enter("mdxjsEsmData"), p(y));
		}
		function v(y) {
			return o.enter("lineEnding"), o.consume(y), o.exit("lineEnding"), g;
		}
		function b(y) {
			const x = zY(l.events.slice(c), {
				acorn: n,
				acornOptions: r,
				tokenTypes: ["mdxjsEsmData"],
				prefix:
					u.length > 0
						? "var " +
							u.join(",") +
							`
`
						: "",
			});
			if (x.error) {
				if (y !== null && x.swallow) return v(y);
				const k = new _t("Could not parse import/exports with acorn", {
					cause: x.error,
					place: {
						line: x.error.loc.line,
						column: x.error.loc.column + 1,
						offset: x.error.pos,
					},
					ruleId: "acorn",
					source: "micromark-extension-mdxjs-esm",
				});
				throw (
					((k.url = AF + "#could-not-parse-importexports-with-acorn"),
					k)
				);
			}
			u.length > 0 && x.estree.body.shift();
			let C = -1;
			for (; ++C < x.estree.body.length; ) {
				const k = x.estree.body[C];
				if (!M$e.has(k.type)) {
					const w = new _t(
						"Unexpected `" +
							k.type +
							"` in code: only import/exports are supported",
						{
							place: R$e(k),
							ruleId: "non-esm",
							source: "micromark-extension-mdxjs-esm",
						},
					);
					throw (
						((w.url =
							AF +
							"#unexpected-type-in-code-only-importexports-are-supported"),
						w)
					);
				}
				if (k.type === "ImportDeclaration" && !l.interrupt) {
					let w = -1;
					for (; ++w < k.specifiers.length; ) {
						const D = k.specifiers[w];
						u.push(D.local.name);
					}
				}
			}
			return (
				Object.assign(
					o.exit("mdxjsEsm"),
					t.addResult ? { estree: x.estree } : void 0,
				),
				s(y)
			);
		}
	}
}
function _$e(t, e, n) {
	return r;
	function r(i) {
		return (
			t.enter("lineEndingBlank"),
			t.consume(i),
			t.exit("lineEndingBlank"),
			t.attempt(mp, e, n)
		);
	}
}
function z$e(t) {
	const e = Object.assign(
		{
			acorn: kn.extend(d$e()),
			acornOptions: { ecmaVersion: 2024, sourceType: "module" },
			addResult: !0,
		},
		t,
	);
	return H5([j$e(e), D$e(e), P$e(e), N$e()]);
}
const Ht = {
		"ar-AE": {
			basedOn: "مرتكز على",
			add: "يضيف",
			branchName: "اسم الفرع",
			cancel: "يلغي",
			clear: "مسح",
			branches: "الفروع",
			collections: "المجموعات",
			collection: "مجموعة",
			create: "يخلق",
			createPullRequest: "إنشاء طلب سحب",
			currentBranch: "الفرع الحالي",
			dashboard: "لوحة القيادة",
			defaultBranch: "الفرع الافتراضي",
			delete: "يمسح",
			edit: "يحرر",
			loading: "جارٍ التحميل",
			deleteBranch: "حذف الفرع",
			newBranch: "فرع جديد",
			otherBranches: "الفروع الأخرى",
			pullRequests: "طلبات السحب",
			save: "يحفظ",
			search: "بحث",
			singleton: "سينجلتون",
			singletons: "الفردي",
			theCurrentlyCheckedOutBranch:
				"الفرع المعاد حاليا. اختر هذا إذا كنت بحاجة إلى البناء على العمل الحالي من الفرع الحالي.",
			theDefaultBranchInYourRepository:
				"الفرع الافتراضي في المستودع الخاص بك. اختر هذا لبدء شيء جديد لا يعتمد على فرعك الحالي.",
			viewPullRequests: "عرض طلبات السحب",
		},
		"bg-BG": {
			add: "Добавете",
			branchName: "Име на клон",
			basedOn: "Базиран на",
			branches: "Клонове",
			cancel: "Отказ",
			clear: "Изчисти",
			collection: "колекция",
			collections: "Колекции",
			create: "Създавайте",
			createPullRequest: "Създайте заявка за изтегляне",
			currentBranch: "Текущ клон",
			dashboard: "Табло",
			defaultBranch: "Клон по подразбиране",
			delete: "Изтрий",
			deleteBranch: "Изтриване на клон",
			loading: "Зареждане",
			edit: "редактиране",
			newBranch: "Нов клон",
			otherBranches: "Други клонове",
			pullRequests: "Заявки за изтегляне",
			save: "Запазване",
			search: "Търсене",
			singletons: "Единични",
			singleton: "Сингълтън",
			theCurrentlyCheckedOutBranch:
				"Текущо провереният клон. Изберете това, ако трябва да надграждате върху съществуваща работа от текущия клон.",
			theDefaultBranchInYourRepository:
				"Клонът по подразбиране във вашето хранилище. Изберете това, за да започнете с нещо ново, което не зависи от текущия ви клон.",
			viewPullRequests: "Преглед на заявките за изтегляне",
		},
		"da-DK": {
			add: "Tilføje",
			basedOn: "Baseret på",
			branchName: "Afdelingsnavn",
			branches: "Grene",
			cancel: "Afbestille",
			clear: "Ryd",
			collection: "Kollektion",
			collections: "Samlinger",
			create: "skab",
			currentBranch: "Nuværende filial",
			createPullRequest: "Opret pull-anmodning",
			dashboard: "Dashboard",
			defaultBranch: "Standard gren",
			deleteBranch: "Slet filial",
			delete: "Slet",
			edit: "Redigere",
			loading: "Indlæser",
			otherBranches: "Andre grene",
			newBranch: "Ny filial",
			pullRequests: "Træk anmodninger",
			save: "Gemme",
			search: "Søg",
			singleton: "Singleton",
			singletons: "Singletoner",
			theCurrentlyCheckedOutBranch:
				"Den aktuelt tjekkede filial. Vælg dette, hvis du skal bygge videre på eksisterende arbejde fra den nuværende filial.",
			theDefaultBranchInYourRepository:
				"Standardgrenen i dit lager. Vælg dette for at starte på noget nyt, der ikke er afhængigt af din nuværende filial.",
			viewPullRequests: "Se pull-anmodninger",
		},
		"de-DE": {
			add: "Hinzufügen",
			basedOn: "Bezogen auf",
			branchName: "Zweigname",
			branches: "Zweig",
			cancel: "Abbrechen",
			clear: "Löschen",
			collection: "Sammlung",
			collections: "Sammlungen",
			createPullRequest: "Pull-Request erstellen",
			create: "Erstellen",
			currentBranch: "Aktueller Zweig",
			dashboard: "Dashboard",
			delete: "Löschen",
			defaultBranch: "Standardzweig",
			loading: "Wird geladen",
			edit: "Bearbeiten",
			deleteBranch: "Zweig löschen",
			newBranch: "Neuer Zweig",
			otherBranches: "Andere Zweige",
			pullRequests: "Pull-Requests",
			save: "Speichern",
			singleton: "Einzeln",
			singletons: "Einzelne",
			theCurrentlyCheckedOutBranch:
				"Der aktuell ausgecheckte Zweig. Wählen Sie diese Option, wenn Sie auf vorhandener Arbeit aus dem aktuellen Zweig aufbauen müssen.",
			theDefaultBranchInYourRepository:
				"Der Standard-Branch in Ihrem Repository. Wählen Sie dies, um etwas Neues zu starten, das nicht von Ihrem aktuellen Zweig abhängt.",
			search: "Suchen",
			viewPullRequests: "Pull-Requests anzeigen",
		},
		"el-GR": {
			add: "Προσθήκη",
			basedOn: "Βασισμένο στο",
			branches: "Κλαδια δεντρου",
			branchName: "Όνομα υποκαταστήματος",
			cancel: "Ματαίωση",
			clear: "Καθαρισμός",
			create: "Δημιουργώ",
			collection: "Συλλογή",
			collections: "Συλλογές",
			createPullRequest: "Δημιουργία αιτήματος έλξης",
			currentBranch: "Τρέχον υποκατάστημα",
			defaultBranch: "Προεπιλεγμένος κλάδος",
			delete: "Διαγράφω",
			deleteBranch: "Διαγραφή υποκαταστήματος",
			edit: "Επεξεργασία",
			loading: "Φόρτωση",
			dashboard: "Ταμπλό",
			newBranch: "Νέο υποκατάστημα",
			otherBranches: "Άλλα υποκαταστήματα",
			pullRequests: "Τραβήξτε αιτήματα",
			search: "Αναζήτηση",
			save: "Αποθηκεύσετε",
			singleton: "Μοναδικό χαρτί",
			singletons: "Singletons",
			theCurrentlyCheckedOutBranch:
				"Το υποκατάστημα που ελέγχεται αυτήν τη στιγμή. Επιλέξτε αυτό εάν χρειάζεται να βασιστείτε σε υπάρχουσες εργασίες από τον τρέχοντα κλάδο.",
			theDefaultBranchInYourRepository:
				"Ο προεπιλεγμένος κλάδος στο αποθετήριο σας. Επιλέξτε αυτό για να ξεκινήσετε κάτι νέο που δεν εξαρτάται από το τρέχον υποκατάστημά σας.",
			viewPullRequests: "Προβολή αιτημάτων έλξης",
		},
		"en-US": {
			add: "Add",
			basedOn: "Based on",
			branchName: "Branch name",
			cancel: "Cancel",
			branches: "Branches",
			clear: "Clear",
			collection: "Collection",
			create: "Create",
			collections: "Collections",
			currentBranch: "Current branch",
			createPullRequest: "Create pull request",
			dashboard: "Dashboard",
			defaultBranch: "Default branch",
			delete: "Delete",
			deleteBranch: "Delete branch",
			edit: "Edit",
			loading: "Loading",
			otherBranches: "Other branches",
			newBranch: "New branch…",
			pullRequests: "Pull requests",
			save: "Save",
			search: "Search",
			singleton: "Singleton",
			singletons: "Singletons",
			theCurrentlyCheckedOutBranch:
				"The currently checked out branch. Choose this if you need to build on existing work from the current branch.",
			theDefaultBranchInYourRepository:
				"The default branch in your repository. Choose this to start something new that's not dependent on your current branch.",
			viewPullRequests: "View pull requests",
		},
		"es-ES": {
			add: "Agregar",
			basedOn: "Residencia en",
			branchName: "Nombre de la sucursal",
			branches: "Sucursales",
			cancel: "Cancelar",
			collection: "Colección",
			clear: "Borrar",
			collections: "Colecciones",
			create: "Crear",
			createPullRequest: "Crear solicitud de extracción",
			currentBranch: "Rama actual",
			defaultBranch: "Rama predeterminada",
			dashboard: "Panel",
			delete: "Borrar",
			edit: "Editar",
			deleteBranch: "Eliminar rama",
			newBranch: "Nueva sucursal",
			loading: "Cargando",
			otherBranches: "Otras sucursales",
			pullRequests: "Solicitudes de extracción",
			save: "Ahorrar",
			singleton: "Semifallo",
			search: "Buscar",
			singletons: "Solteros",
			theCurrentlyCheckedOutBranch:
				"La sucursal actualmente desprotegida. Elija esto si necesita desarrollar el trabajo existente de la rama actual.",
			viewPullRequests: "Ver solicitudes de extracción",
			theDefaultBranchInYourRepository:
				"La rama predeterminada en su repositorio. Elija esto para comenzar algo nuevo que no dependa de su sucursal actual.",
		},
		"cs-CZ": {
			add: "Přidat",
			basedOn: "Na základě",
			branchName: "Jméno pobočky",
			branches: "Větve",
			cancel: "zrušení",
			clear: "Vymazat",
			collection: "Sbírka",
			collections: "Sbírky",
			create: "Vytvořit",
			currentBranch: "Současná pobočka",
			dashboard: "Přístrojová deska",
			createPullRequest: "Vytvořit požadavek na stažení",
			defaultBranch: "Výchozí větev",
			delete: "Vymazat",
			deleteBranch: "Smazat větev",
			edit: "Upravit",
			loading: "Načítání",
			newBranch: "Nová pobočka",
			search: "Hledat",
			pullRequests: "Vytáhněte požadavky",
			otherBranches: "Ostatní pobočky",
			singletons: "Singletons",
			singleton: "Jedináček",
			theCurrentlyCheckedOutBranch:
				"Aktuálně odhlášená pobočka. Tuto možnost vyberte, pokud potřebujete navázat na stávající práci z aktuální pobočky.",
			theDefaultBranchInYourRepository:
				"Výchozí větev ve vašem úložišti. Zvolte tuto možnost, chcete-li začít s něčím novým, co není závislé na vaší aktuální větvi.",
			viewPullRequests: "Zobrazit žádosti o stažení",
			save: "Uložit",
		},
		"fi-FI": {
			add: "Lisätä",
			basedOn: "Perustuen",
			branches: "Oksat",
			branchName: "Sivukonttorin nimi",
			cancel: "Tühista",
			clear: "Kirkas",
			collection: "Kokoelma",
			collections: "Kokoelmat",
			create: "Luoda",
			createPullRequest: "Luo vetopyyntö",
			dashboard: "Kojelauta",
			defaultBranch: "Oletushaara",
			currentBranch: "Nykyinen haara",
			delete: "Poistaa",
			deleteBranch: "Poista haara",
			edit: "Muokata",
			loading: "Ladataan",
			newBranch: "Uusi haara",
			pullRequests: "Vedä pyyntöjä",
			otherBranches: "Muut haarat",
			save: "Tallentaa",
			search: "Hae",
			singleton: "Singleton",
			singletons: "Singletons",
			theDefaultBranchInYourRepository:
				"Oletushaara arkistossasi. Valitse tämä aloittaaksesi jotain uutta, joka ei ole riippuvainen nykyisestä haarastasi.",
			theCurrentlyCheckedOutBranch:
				"Tällä hetkellä uloskirjautunut sivuliike. Valitse tämä, jos haluat rakentaa nykyisen haaran olemassa olevaan työhön.",
			viewPullRequests: "Näytä vetopyynnöt",
		},
		"fr-FR": {
			add: "Ajouter",
			basedOn: "Basé sur",
			branchName: "Nom de la filiale",
			branches: "Branches",
			cancel: "Annuler",
			clear: "Effacer",
			collection: "Collection",
			create: "Créer",
			collections: "Collections",
			createPullRequest: "Créer une demande d'extraction",
			dashboard: "Tableau de bord",
			currentBranch: "Succursale actuelle",
			defaultBranch: "Branche par défaut",
			deleteBranch: "Supprimer la branche",
			delete: "Supprimer",
			edit: "Modifier",
			loading: "Chargement en cours",
			otherBranches: "Autres succursales",
			pullRequests: "Demandes d'extraction",
			newBranch: "Nouvelle branche",
			save: "Sauvegarder",
			search: "Rechercher",
			singleton: "Singleton",
			singletons: "Singletons",
			theDefaultBranchInYourRepository:
				"La branche par défaut de votre référentiel. Choisissez ceci pour commencer quelque chose de nouveau qui ne dépend pas de votre branche actuelle.",
			theCurrentlyCheckedOutBranch:
				"La branche actuellement extraite. Choisissez cette option si vous devez vous appuyer sur le travail existant de la branche actuelle.",
			viewPullRequests: "Afficher les demandes d'extraction",
		},
		"he-IL": {
			add: "לְהוֹסִיף",
			branchName: "שם הסניף",
			branches: "ענפים",
			basedOn: "מבוסס על",
			cancel: "לְבַטֵל",
			clear: "נקי",
			collections: "אוספים",
			collection: "אוסף",
			create: "לִיצוֹר",
			currentBranch: "סניף נוכחי",
			createPullRequest: "צור בקשת משיכה",
			dashboard: "לוּחַ מַחווָנִים",
			defaultBranch: "סניף ברירת מחדל",
			deleteBranch: "מחק סניף",
			delete: "לִמְחוֹק",
			edit: "לַעֲרוֹך",
			loading: "טוען",
			newBranch: "סניף חדש",
			save: "להציל",
			otherBranches: "סניפים אחרים",
			search: "חפש",
			singleton: "קְלָף בּוֹדֵד",
			pullRequests: "משוך בקשות",
			singletons: "רווקים",
			theDefaultBranchInYourRepository:
				"סניף ברירת המחדל במאגר שלך. בחר באפשרות זו כדי להתחיל משהו חדש שאינו תלוי בסניף הנוכחי שלך.",
			theCurrentlyCheckedOutBranch:
				"הסניף שנקבע כעת. בחר באפשרות זו אם אתה צריך לבנות על עבודה קיימת מהסניף הנוכחי.",
			viewPullRequests: "הצג בקשות משיכה",
		},
		"et-EE": {
			add: "Lisama",
			basedOn: "Põhineb",
			branches: "Filiaalid",
			branchName: "Filiaali nimi",
			cancel: "Tühista",
			clear: "Puhasta",
			create: "Loo",
			collection: "Kollektsioon",
			collections: "Kollektsioonid",
			createPullRequest: "Loo tõmbamistaotlus",
			currentBranch: "Praegune filiaal",
			dashboard: "Armatuurlaud",
			defaultBranch: "Vaikeharu",
			edit: "Muuda",
			loading: "Laadimine",
			newBranch: "Uus filiaal",
			deleteBranch: "Kustuta haru",
			otherBranches: "Muud oksad",
			pullRequests: "Tõmbetaotlused",
			save: "Salvesta",
			search: "Otsi",
			singleton: "üksikud",
			theDefaultBranchInYourRepository:
				"Vaikeharu teie hoidlas. Valige see, et alustada midagi uut, mis ei sõltu teie praegusest harust.",
			theCurrentlyCheckedOutBranch:
				"Praegu välja registreeritud filiaal. Valige see, kui peate kasutama praeguse haru olemasolevaid töid.",
			singletons: "Üksikud",
			viewPullRequests: "Vaadake tõmbamistaotlusi",
			delete: "Kustuta",
		},
		"hr-HR": {
			branchName: "Naziv podružnice",
			basedOn: "Na temelju",
			add: "Dodati",
			cancel: "Otkazati",
			branches: "Podružnice",
			clear: "Izbriši",
			collections: "Zbirke",
			collection: "Kolekcija",
			create: "Stvoriti",
			createPullRequest: "Kreirajte zahtjev za povlačenjem",
			currentBranch: "Trenutna grana",
			dashboard: "Nadzorna ploča",
			defaultBranch: "Zadana grana",
			delete: "Izbrisati",
			loading: "Učitavam",
			edit: "Uredi",
			deleteBranch: "Izbriši granu",
			otherBranches: "Ostale grane",
			pullRequests: "Zahtjevi za povlačenjem",
			newBranch: "Nova grana",
			search: "Traži",
			singleton: "samac",
			singletons: "Samci",
			save: "Uštedjeti",
			theDefaultBranchInYourRepository:
				"Zadana grana u vašem spremištu. Odaberite ovo da započnete nešto novo što ne ovisi o vašoj trenutnoj grani.",
			theCurrentlyCheckedOutBranch:
				"Trenutno odjavljena poslovnica. Odaberite ovo ako trebate graditi na postojećem radu iz trenutne grane.",
			viewPullRequests: "Pregledajte zahtjeve za povlačenjem",
		},
		"it-IT": {
			add: "Aggiungere",
			basedOn: "Basato su",
			branchName: "Nome ramo",
			branches: "Rami",
			cancel: "Annulla",
			collection: "Collezione",
			clear: "Cancella",
			collections: "Collezioni",
			create: "Creare",
			defaultBranch: "Ramo predefinito",
			createPullRequest: "Crea richiesta pull",
			currentBranch: "Ramo attuale",
			dashboard: "Pannello di controllo",
			delete: "Eliminare",
			deleteBranch: "Elimina ramo",
			edit: "Modificare",
			loading: "Caricamento in corso",
			newBranch: "Nuova filiale",
			otherBranches: "Altri rami",
			save: "Salva",
			search: "Cerca",
			pullRequests: "Richieste pull",
			singleton: "Singleton",
			singletons: "Singletons",
			viewPullRequests: "Visualizza le richieste pull",
			theCurrentlyCheckedOutBranch:
				"La filiale attualmente verificata. Scegli questa opzione se devi basarti su un lavoro esistente dal ramo corrente.",
			theDefaultBranchInYourRepository:
				"Il ramo predefinito nel tuo repository. Scegli questa opzione per iniziare qualcosa di nuovo che non dipenda dal tuo ramo attuale.",
		},
		"ja-JP": {
			basedOn: "に基づく",
			add: "追加",
			branchName: "支店名",
			branches: "支店",
			clear: "クリア",
			cancel: "キャンセル",
			collections: "コレクション",
			createPullRequest: "プルリクエストを作成",
			create: "作成",
			collection: "コレクション",
			currentBranch: "現在のブランチ",
			defaultBranch: "デフォルトのブランチ",
			dashboard: "ダッシュボード",
			delete: "消去",
			loading: "読み込み中",
			edit: "編集",
			deleteBranch: "ブランチを削除",
			newBranch: "新しい支店",
			search: "検索",
			pullRequests: "プルリクエスト",
			otherBranches: "その他の支店",
			save: "保存",
			singleton: "シングルトン",
			singletons: "シングルトン",
			theDefaultBranchInYourRepository:
				"リポジトリのデフォルト ブランチ。 これを選択して、現在のブランチに依存しない新しい何かを開始します。",
			theCurrentlyCheckedOutBranch:
				"現在チェックアウトされているブランチ。 現在のブランチの既存の作業に基づいて構築する必要がある場合は、これを選択してください。",
			viewPullRequests: "プル リクエストを表示",
		},
		"ko-KR": {
			basedOn: "기반으로",
			add: "추가하다",
			branches: "가지",
			branchName: "지점명",
			cancel: "취소",
			clear: "지우기",
			collection: "수집",
			create: "만들다",
			createPullRequest: "풀 요청 생성",
			currentBranch: "현재 지점",
			collections: "컬렉션",
			dashboard: "계기반",
			defaultBranch: "기본 분기",
			deleteBranch: "분기 삭제",
			delete: "삭제",
			edit: "편집하다",
			newBranch: "새 지점",
			loading: "로드 중",
			otherBranches: "기타 지점",
			pullRequests: "풀 리퀘스트",
			search: "검색",
			singleton: "하나씩 일어나는 것",
			save: "구하다",
			singletons: "싱글톤",
			viewPullRequests: "풀 요청 보기",
			theCurrentlyCheckedOutBranch:
				"현재 체크아웃된 브랜치. 현재 브랜치의 기존 작업을 기반으로 빌드해야 하는 경우 이 옵션을 선택하세요.",
			theDefaultBranchInYourRepository:
				"리포지토리의 기본 브랜치입니다. 현재 분기에 의존하지 않는 새로운 것을 시작하려면 이것을 선택하십시오.",
		},
		"hu-HU": {
			add: "Hozzáadás",
			branchName: "Fiók neve",
			basedOn: "Alapján",
			cancel: "Megszünteti",
			clear: "Törlés",
			collection: "Gyűjtemény",
			branches: "Ágak",
			collections: "Gyűjtemények",
			create: "Teremt",
			createPullRequest: "Lehívási kérelem létrehozása",
			currentBranch: "Jelenlegi ág",
			dashboard: "Irányítópult",
			defaultBranch: "Alapértelmezett ág",
			delete: "Töröl",
			deleteBranch: "Elágazás törlése",
			loading: "Betöltés folyamatban",
			newBranch: "Új ág",
			otherBranches: "Egyéb ágak",
			pullRequests: "Lehívási kérések",
			save: "Megment",
			search: "Keresés",
			singletons: "Singletons",
			singleton: "szingli",
			viewPullRequests: "Lehívási kérelmek megtekintése",
			theCurrentlyCheckedOutBranch:
				"A jelenleg kivett fiók. Válassza ezt, ha az aktuális ág meglévő munkájára kell építenie.",
			theDefaultBranchInYourRepository:
				"Az alapértelmezett ág az adattárban. Válassza ezt, ha valami újat szeretne indítani, amely nem függ az aktuális ágtól.",
			edit: "Szerkesztés",
		},
		"lv-LV": {
			basedOn: "Balstoties uz",
			branchName: "Filiāles nosaukums",
			cancel: "Atcelt",
			add: "Pievienot",
			collection: "Kolekcija",
			branches: "Nozares",
			clear: "Notīrīt",
			collections: "Kolekcijas",
			create: "Izveidot",
			createPullRequest: "Izveidot izvilkšanas pieprasījumu",
			currentBranch: "Pašreizējā filiāle",
			defaultBranch: "Noklusējuma filiāle",
			delete: "Dzēst",
			dashboard: "Mērinstrumentu panelis",
			deleteBranch: "Dzēst filiāli",
			edit: "Rediģēt",
			loading: "Notiek ielāde",
			otherBranches: "Citas filiāles",
			newBranch: "Jauna filiāle",
			pullRequests: "Izvilkšanas pieprasījumi",
			save: "Saglabāt",
			search: "Meklēt",
			singleton: "Singleton",
			singletons: "Vientuļi",
			theCurrentlyCheckedOutBranch:
				"Pašlaik izrakstītā filiāle. Izvēlieties šo, ja vēlaties izmantot esošo darbu no pašreizējās filiāles.",
			viewPullRequests: "Skatīt izvilkšanas pieprasījumus",
			theDefaultBranchInYourRepository:
				"Noklusējuma filiāle jūsu repozitorijā. Izvēlieties šo, lai sāktu kaut ko jaunu, kas nav atkarīgs no jūsu pašreizējās filiāles.",
		},
		"nb-NO": {
			add: "Legg til",
			basedOn: "Basert på",
			branches: "Grener",
			branchName: "Filialnavn",
			cancel: "Avbryt",
			collections: "Samlinger",
			collection: "Samling",
			clear: "Tøm",
			create: "Skape",
			createPullRequest: "Opprett pull-forespørsel",
			currentBranch: "Nåværende gren",
			delete: "Slett",
			dashboard: "Dashbord",
			defaultBranch: "Standard gren",
			deleteBranch: "Slett filial",
			edit: "Redigere",
			loading: "Laster inn",
			otherBranches: "Andre grener",
			newBranch: "Ny gren",
			pullRequests: "Trekk forespørsler",
			search: "Søk",
			save: "Lagre",
			singleton: "Singleton",
			singletons: "Singletoner",
			theCurrentlyCheckedOutBranch:
				"Den utsjekkede grenen. Velg dette hvis du skal bygge på eksisterende arbeid fra gjeldende gren.",
			theDefaultBranchInYourRepository:
				"Standardgrenen i depotet ditt. Velg dette for å starte noe nytt som ikke er avhengig av din nåværende filial.",
			viewPullRequests: "Se pull-forespørsler",
		},
		"pl-PL": {
			add: "Dodać",
			basedOn: "Oparte na",
			branchName: "Nazwa filii",
			branches: "Gałęzie",
			cancel: "Anulować",
			clear: "Wyczyść",
			collection: "Kolekcja",
			collections: "Kolekcje",
			create: "Tworzyć",
			currentBranch: "Obecny oddział",
			createPullRequest: "Utwórz żądanie ściągnięcia",
			dashboard: "Panel",
			defaultBranch: "Oddział domyślny",
			delete: "Usuwać",
			deleteBranch: "Usuń oddział",
			edit: "Edytować",
			loading: "Trwa ładowanie",
			newBranch: "Nowa gałąź",
			otherBranches: "Inne gałęzie",
			pullRequests: "Żądania ściągnięcia",
			save: "Ratować",
			search: "Szukaj",
			singleton: "singel",
			singletons: "Singletony",
			theCurrentlyCheckedOutBranch:
				"Aktualnie wyewidencjonowana gałąź. Wybierz tę opcję, jeśli chcesz oprzeć się na istniejącej pracy z bieżącej gałęzi.",
			theDefaultBranchInYourRepository:
				"Domyślna gałąź w twoim repozytorium. Wybierz tę opcję, aby rozpocząć coś nowego, co nie jest zależne od bieżącej gałęzi.",
			viewPullRequests: "Wyświetl żądania ściągnięcia",
		},
		"nl-NL": {
			add: "Toevoegen",
			basedOn: "Gebaseerd op",
			branchName: "Filiaal naam",
			cancel: "Annuleren",
			branches: "Takken",
			clear: "Helder",
			collection: "Verzameling",
			collections: "Collecties",
			create: "Creëren",
			createPullRequest: "Pull-aanvraag maken",
			currentBranch: "Huidige tak",
			dashboard: "Dashboard",
			delete: "Verwijderen",
			defaultBranch: "Standaard filiaal",
			edit: "Bewerking",
			deleteBranch: "Filiaal verwijderen",
			loading: "Laden",
			newBranch: "Nieuwe tak",
			pullRequests: "Trek verzoeken",
			otherBranches: "Andere takken",
			singleton: "eenling",
			search: "Zoeken",
			singletons: "Eenlingen",
			theCurrentlyCheckedOutBranch:
				"Het momenteel uitgecheckte filiaal. Kies dit als u moet voortbouwen op bestaand werk van de huidige branch.",
			save: "Redden",
			theDefaultBranchInYourRepository:
				"De standaard branch in uw repository. Kies dit om iets nieuws te starten dat niet afhankelijk is van uw huidige branche.",
			viewPullRequests: "Bekijk pull-aanvragen",
		},
		"pt-BR": {
			add: "Adicionar",
			basedOn: "Baseado em",
			branchName: "Nome da filial",
			branches: "Galhos",
			cancel: "Cancelar",
			collection: "Coleção",
			clear: "Limpar",
			create: "Criar",
			createPullRequest: "Criar solicitação pull",
			collections: "Coleções",
			currentBranch: "filial atual",
			dashboard: "Painel",
			defaultBranch: "ramo padrão",
			deleteBranch: "Excluir ramificação",
			delete: "Excluir",
			edit: "Editar",
			newBranch: "Nova filial",
			loading: "Carregando",
			otherBranches: "Outros ramos",
			save: "Guardar",
			pullRequests: "Requisições pull",
			search: "Pesquisar",
			singleton: "solteiro",
			singletons: "Solteiros",
			theCurrentlyCheckedOutBranch:
				"A ramificação atualmente com check-out. Escolha esta opção se precisar criar um trabalho existente na ramificação atual.",
			theDefaultBranchInYourRepository:
				"A ramificação padrão em seu repositório. Escolha isso para iniciar algo novo que não dependa de sua ramificação atual.",
			viewPullRequests: "Ver solicitações pull",
		},
		"pt-PT": {
			add: "Adicionar",
			basedOn: "Baseado em",
			branchName: "Nome da filial",
			branches: "Galhos",
			cancel: "Cancelar",
			clear: "Limpar",
			collection: "Coleção",
			collections: "Coleções",
			create: "Criar",
			createPullRequest: "Criar solicitação pull",
			dashboard: "Painel",
			currentBranch: "filial atual",
			deleteBranch: "Excluir ramificação",
			delete: "Excluir",
			defaultBranch: "ramo padrão",
			edit: "Editar",
			newBranch: "Nova filial",
			loading: "A carregar",
			otherBranches: "Outros ramos",
			pullRequests: "Requisições pull",
			save: "Guardar",
			search: "Procurar",
			singleton: "solteiro",
			singletons: "Solteiros",
			theCurrentlyCheckedOutBranch:
				"A ramificação atualmente com check-out. Escolha esta opção se precisar criar um trabalho existente na ramificação atual.",
			theDefaultBranchInYourRepository:
				"A ramificação padrão em seu repositório. Escolha isso para iniciar algo novo que não dependa de sua ramificação atual.",
			viewPullRequests: "Ver solicitações pull",
		},
		"ro-RO": {
			add: "Adăuga",
			basedOn: "Bazat pe",
			branches: "Ramuri",
			branchName: "Numele sucursalei",
			cancel: "Anulare",
			clear: "Golire",
			collections: "Colecții",
			collection: "Colectie",
			create: "Crea",
			createPullRequest: "Creați cerere de tragere",
			currentBranch: "Filiala actuală",
			defaultBranch: "Ramura implicită",
			dashboard: "Bord",
			deleteBranch: "Ștergeți ramura",
			delete: "Șterge",
			edit: "Editați",
			loading: "Se încarcă",
			newBranch: "Filiala noua",
			otherBranches: "Alte ramuri",
			pullRequests: "Solicitări de tragere",
			save: "Salvați",
			search: "Căutare",
			singleton: "Singleton",
			singletons: "Singletons",
			theCurrentlyCheckedOutBranch:
				"Sucursala verificată în prezent. Alegeți acest lucru dacă trebuie să vă bazați pe munca existentă din ramura curentă.",
			theDefaultBranchInYourRepository:
				"Ramura implicită din depozitul dvs. Alegeți acest lucru pentru a începe ceva nou, care nu depinde de ramura dvs. actuală.",
			viewPullRequests: "Vizualizați solicitările de extragere",
		},
		"ru-RU": {
			add: "Добавлять",
			basedOn: "На основе",
			branchName: "Название филиала",
			branches: "Ветви",
			cancel: "Отмена",
			clear: "Очистить",
			collection: "Коллекция",
			create: "Создавать",
			collections: "Коллекции",
			createPullRequest: "Создать запрос на включение",
			currentBranch: "Текущая ветвь",
			dashboard: "Панель приборов",
			defaultBranch: "Ветка по умолчанию",
			delete: "Удалить",
			edit: "Редактировать",
			deleteBranch: "Удалить ветку",
			loading: "Загрузка",
			newBranch: "Новая ветка",
			otherBranches: "Другие филиалы",
			pullRequests: "Пулл-реквесты",
			save: "Сохранять",
			singleton: "Синглтон",
			search: "Поиск",
			singletons: "Одиночки",
			theCurrentlyCheckedOutBranch:
				"Текущая проверенная ветвь. Выберите это, если вам нужно опираться на существующую работу из текущей ветки.",
			viewPullRequests: "Посмотреть пул-реквесты",
			theDefaultBranchInYourRepository:
				"Ветка по умолчанию в вашем репозитории. Выберите это, чтобы начать что-то новое, не зависящее от вашей текущей ветки.",
		},
		"sk-SK": {
			add: "Pridať",
			basedOn: "Založené na",
			branchName: "Meno pobočky",
			branches: "Pobočky",
			cancel: "Zrušiť",
			clear: "Vymazať",
			collections: "zbierky",
			collection: "Zbierka",
			createPullRequest: "Vytvorte požiadavku na stiahnutie",
			currentBranch: "Aktuálna pobočka",
			create: "Vytvorte",
			dashboard: "Dashboard",
			delete: "Odstrániť",
			defaultBranch: "Predvolená vetva",
			deleteBranch: "Odstrániť vetvu",
			loading: "Načítava sa",
			edit: "Upraviť",
			newBranch: "Nová pobočka",
			otherBranches: "Ostatné pobočky",
			pullRequests: "Vytiahnite žiadosti",
			search: "Vyhľadávať",
			save: "Uložiť",
			singleton: "Singleton",
			singletons: "Singletons",
			theCurrentlyCheckedOutBranch:
				"Aktuálne odhlásená pobočka. Túto možnosť vyberte, ak potrebujete stavať na existujúcej práci z aktuálnej pobočky.",
			theDefaultBranchInYourRepository:
				"Predvolená vetva vo vašom úložisku. Zvoľte túto možnosť, ak chcete začať niečo nové, čo nezávisí od vašej aktuálnej pobočky.",
			viewPullRequests: "Zobraziť požiadavky na stiahnutie",
		},
		"sl-SI": {
			add: "Dodaj",
			branchName: "Ime podružnice",
			branches: "Podružnice",
			basedOn: "Temelji na",
			cancel: "Prekliči",
			collection: "Zbirka",
			clear: "Jasen",
			collections: "Zbirke",
			createPullRequest: "Ustvari zahtevo za vleko",
			create: "Ustvari",
			currentBranch: "Trenutna veja",
			defaultBranch: "Privzeta veja",
			dashboard: "Nadzorna plošča",
			delete: "Izbriši",
			deleteBranch: "Izbriši vejo",
			edit: "Uredi",
			loading: "Nalaganje",
			newBranch: "Nova podružnica",
			otherBranches: "Druge veje",
			pullRequests: "Zahteve za vlečenje",
			save: "Shrani",
			search: "Iskanje",
			singleton: "Singleton",
			theCurrentlyCheckedOutBranch:
				"Trenutno odjavljena podružnica. To izberite, če morate graditi na obstoječem delu iz trenutne veje.",
			singletons: "Samski",
			theDefaultBranchInYourRepository:
				"Privzeta veja v vašem skladišču. Izberite to, da začnete nekaj novega, kar ni odvisno od vaše trenutne veje.",
			viewPullRequests: "Oglejte si zahteve za vlečenje",
		},
		"sr-SP": {
			add: "Додати",
			branchName: "Назив огранка",
			basedOn: "На бази",
			branches: "Огранци",
			cancel: "Поништити, отказати",
			clear: "Izbriši",
			collection: "Цоллецтион",
			collections: "Збирке",
			createPullRequest: "Креирајте захтев за повлачење",
			create: "Креирај",
			currentBranch: "Тренутна грана",
			dashboard: "Командна табла",
			defaultBranch: "Подразумевана грана",
			delete: "Избриши",
			deleteBranch: "Обриши грану",
			edit: "Уредити",
			newBranch: "Нова грана",
			loading: "Učitavam",
			save: "сачувати",
			pullRequests: "Захтеви за повлачење",
			otherBranches: "Остале гране",
			singletons: "Синглетонс",
			search: "Pretraga",
			singleton: "Синглетон",
			theCurrentlyCheckedOutBranch:
				"Тренутно одјављена филијала. Изаберите ово ако треба да надоградите постојећи рад из тренутне гране.",
			viewPullRequests: "Прегледајте захтеве за повлачењем",
			theDefaultBranchInYourRepository:
				"Подразумевана грана у вашем спремишту. Изаберите ово да започнете нешто ново што не зависи од ваше тренутне гране.",
		},
		"sv-SE": {
			branchName: "Filialens namn",
			add: "Lägg till",
			basedOn: "Baserat på",
			branches: "Grenar",
			cancel: "Поништити, отказати",
			clear: "Rensa",
			collection: "Samling",
			collections: "Samlingar",
			create: "Skapa",
			createPullRequest: "Skapa pull-förfrågan",
			currentBranch: "Nuvarande gren",
			dashboard: "instrumentbräda",
			delete: "Radera",
			defaultBranch: "Standardgren",
			loading: "Läser in",
			edit: "Redigera",
			deleteBranch: "Ta bort gren",
			newBranch: "Ny gren",
			pullRequests: "Dra förfrågningar",
			otherBranches: "Andra grenar",
			search: "Sök",
			save: "Spara",
			singleton: "Singleton",
			theCurrentlyCheckedOutBranch:
				"Den utcheckade filialen. Välj detta om du behöver bygga på befintligt arbete från den aktuella grenen.",
			singletons: "Singlar",
			theDefaultBranchInYourRepository:
				"Standardgrenen i ditt arkiv. Välj detta för att starta något nytt som inte är beroende av din nuvarande filial.",
			viewPullRequests: "Visa pull-förfrågningar",
		},
		"tr-TR": {
			add: "Avbryt",
			basedOn: "Dayalı",
			branchName: "şube adı",
			branches: "Şubeler",
			cancel: "iptal etmek",
			clear: "Temizle",
			collection: "Toplamak",
			create: "Yaratmak",
			createPullRequest: "Çekme isteği oluştur",
			collections: "Koleksiyonlar",
			currentBranch: "Mevcut şube",
			dashboard: "Gösterge Paneli",
			defaultBranch: "varsayılan dal",
			delete: "Silmek",
			deleteBranch: "Şubeyi sil",
			edit: "Düzenlemek",
			loading: "Yükleniyor",
			otherBranches: "Diğer şubeler",
			newBranch: "Yeni dal",
			pullRequests: "Çekme istekleri",
			singleton: "Tekil",
			save: "Kaydetmek",
			search: "Ara",
			singletons: "Singleton'lar",
			theCurrentlyCheckedOutBranch:
				"Şu anda kontrol edilen şube. Geçerli daldaki mevcut işi geliştirmeniz gerekiyorsa bunu seçin.",
			theDefaultBranchInYourRepository:
				"Deponuzdaki varsayılan şube. Mevcut şubenize bağlı olmayan yeni bir şey başlatmak için bunu seçin.",
			viewPullRequests: "Çekme isteklerini görüntüle",
		},
		"uk-UA": {
			add: "Додати",
			branchName: "Назва гілки",
			branches: "Гілки",
			basedOn: "На основі",
			clear: "Очистити",
			cancel: "Скасувати",
			collection: "Колекція",
			collections: "Колекції",
			create: "Створити",
			createPullRequest: "Створити запит на злиття змін",
			currentBranch: "Поточна гілка",
			dashboard: "Дашборд",
			defaultBranch: "Типова гілка",
			deleteBranch: "Видалити гілку",
			delete: "Видалити",
			edit: "Редагувати",
			loading: "Завантаження",
			newBranch: "Нова гілка",
			otherBranches: "Інші гілки",
			save: "Зберегти",
			pullRequests: "Запити на злиття",
			search: "Пошук",
			singletons: "Одиночки",
			singleton: "Одиночка",
			viewPullRequests: "Перегляд запитів на злиття",
			theDefaultBranchInYourRepository:
				"Типова гілка у вашому репозиторії. Виберіть це, щоб почати щось нове, що не залежить від вашої поточної гілки.",
			theCurrentlyCheckedOutBranch:
				"Поточна обрана гілка. Виберіть це, якщо вам потрібно продовжити роботу на основі поточної гілки.",
		},
		"zh-CN": {
			add: "添加",
			basedOn: "基于",
			branchName: "分店名称",
			branches: "分支机构",
			cancel: "取消",
			collections: "收藏品",
			collection: "收藏",
			clear: "透明",
			create: "创造",
			createPullRequest: "创建拉取请求",
			currentBranch: "当前分支",
			dashboard: "仪表板",
			defaultBranch: "默认分支",
			delete: "删除",
			deleteBranch: "删除分支",
			edit: "编辑",
			loading: "正在加载",
			newBranch: "新分行",
			pullRequests: "拉取请求",
			otherBranches: "其他分行",
			search: "搜索",
			save: "节省",
			singleton: "单例",
			singletons: "单例",
			theCurrentlyCheckedOutBranch:
				"当前签出的分支。 如果您需要在当前分支的现有工作的基础上构建，请选择此项。",
			theDefaultBranchInYourRepository:
				"存储库中的默认分支。 选择此选项可开始一些不依赖于当前分支的新操作。",
			viewPullRequests: "查看拉取请求",
		},
		"zh-TW": {
			add: "添加",
			basedOn: "基於",
			branchName: "分店名稱",
			branches: "分支機構",
			clear: "清除",
			cancel: "取消",
			collection: "收藏",
			collections: "收藏品",
			createPullRequest: "創建拉取請求",
			create: "創造",
			currentBranch: "當前分支",
			dashboard: "儀表板",
			defaultBranch: "默認分支",
			delete: "刪除",
			deleteBranch: "刪除分支",
			edit: "編輯",
			loading: "正在載入",
			newBranch: "新分行",
			otherBranches: "其他分行",
			pullRequests: "拉取請求",
			save: "節省",
			singleton: "單例",
			search: "搜尋",
			singletons: "單例",
			theCurrentlyCheckedOutBranch:
				"當前簽出的分支。 如果您需要在當前分支的現有工作的基礎上構建，請選擇此項。",
			viewPullRequests: "查看拉取請求",
			theDefaultBranchInYourRepository:
				"存儲庫中的默認分支。 選擇此選項可開始一些不依賴於當前分支的新操作。",
		},
		"lt-LT": {
			add: "Papildyti",
			basedOn: "Remiantis",
			branchName: "Filialo pavadinimas",
			cancel: "Atšaukti",
			branches: "Filialai",
			collection: "Kolekcija",
			clear: "Skaidrus",
			collections: "Kolekcijos",
			create: "Sukurti",
			currentBranch: "Dabartinis filialas",
			createPullRequest: "Sukurti ištraukimo užklausą",
			dashboard: "Prietaisų skydelis",
			defaultBranch: "Numatytoji šaka",
			delete: "Ištrinti",
			deleteBranch: "Ištrinti šaką",
			loading: "Įkeliama",
			edit: "Redaguoti",
			newBranch: "Naujas filialas",
			search: "Ieškoti",
			pullRequests: "Ištraukti užklausas",
			otherBranches: "Kitos šakos",
			singleton: "vienvietis",
			save: "Sutaupyti",
			viewPullRequests: "Peržiūrėkite ištraukimo užklausas",
			theCurrentlyCheckedOutBranch:
				"Šiuo metu išregistruotas filialas. Pasirinkite tai, jei reikia remtis esamu darbu iš dabartinės šakos.",
			singletons: "Vienišiai",
			theDefaultBranchInYourRepository:
				"Numatytoji šaka jūsų saugykloje. Pasirinkite tai, kad pradėtumėte ką nors naujo, nepriklausančio nuo dabartinės šakos.",
		},
	},
	L$e = "keystatic-side-panel",
	V$e = "keystatic-main-panel",
	K$e = (t) => {
		const e = ee(2);
		let n;
		return (
			e[0] !== t
				? ((n = m.jsx(pr, {
						height: "100%",
						minHeight: 0,
						minWidth: 0,
						...t,
					})),
					(e[0] = t),
					(e[1] = n))
				: (n = e[1]),
			n
		);
	},
	Ob = (t) => {
		const e = ee(7);
		let n, r;
		e[0] !== t
			? (({ isDisabled: n, ...r } = t),
				(e[0] = t),
				(e[1] = n),
				(e[2] = r))
			: ((n = e[1]), (r = e[2]));
		const i = n ? void 0 : !0;
		let o;
		e[3] === Symbol.for("react.memo_cache_sentinel")
			? ((o = X({
					"&[data-scrollable]": {
						overflowY: "auto",
						WebkitOverflowScrolling: "touch",
					},
				})),
				(e[3] = o))
			: (o = e[3]);
		let s;
		return (
			e[4] !== i || e[5] !== r
				? ((s = m.jsx(K$e, {
						"data-scrollable": i,
						UNSAFE_className: o,
						...r,
					})),
					(e[4] = i),
					(e[5] = r),
					(e[6] = s))
				: (s = e[6]),
			s
		);
	},
	U$e = "---";
function VY() {
	var t;
	let { basePath: e } = mH(),
		n = Jn(),
		r = Le(Ht),
		i = qye();
	const o = Object.keys(n.collections || {}),
		s = Object.keys(n.singletons || {}),
		a = ((t = n.ui) === null || t === void 0 ? void 0 : t.navigation) || {
			...(!!o.length && { [r.format("collections")]: o }),
			...(!!s.length && { [r.format("singletons")]: s }),
		},
		l = { basePath: e, changeMap: i, config: n };
	return Array.isArray(a)
		? a.map((u) => $F(u, l))
		: Object.entries(a).map(([u, c]) => ({
				title: u,
				children: c.map((d) => $F(d, l)),
			}));
}
function $F(t, e) {
	let { basePath: n, changeMap: r, config: i } = e;
	if (t === U$e) return { isDivider: !0 };
	if (i.collections && t in i.collections) {
		const o = `${n}/collection/${encodeURIComponent(t)}`,
			s = r.collections.get(t),
			a = s ? s.changed.size + s.added.size + s.removed.size : 0,
			l = i.collections[t].label;
		return {
			key: t,
			href: o,
			label: l,
			changed: a,
			entryCount: s == null ? void 0 : s.totalCount,
		};
	}
	if (i.singletons && t in i.singletons) {
		const o = `${n}/singleton/${encodeURIComponent(t)}`,
			s = r.singletons.has(t),
			a = i.singletons[t].label;
		return { key: t, href: o, label: a, changed: s };
	}
	throw new Error(`Unknown navigation key: "${t}".`);
}
function Od(t, e) {
	const { singular: n, plural: r = n + "s", inclusive: i = !0 } = e,
		o = t === 1 ? n : r;
	return i ? `${t} ${o}` : o;
}
function H$e() {
	var t, e;
	const n = ee(9),
		{ colorScheme: r } = Rs(),
		i = Jn(),
		o = $l("(prefers-color-scheme: dark)");
	let s;
	n[0] === Symbol.for("react.memo_cache_sentinel")
		? ((s = m.jsx(W$e, {})), (n[0] = s))
		: (s = n[0]);
	let a = s,
		l = "Keystatic";
	if (
		(t = i.ui) !== null &&
		t !== void 0 &&
		(t = t.brand) !== null &&
		t !== void 0 &&
		t.mark
	) {
		const c = i.ui.brand.mark,
			d = r === "auto" ? (o ? "dark" : "light") : r;
		let f;
		n[1] !== c || n[2] !== d
			? ((f = m.jsx(c, { colorScheme: d })),
				(n[1] = c),
				(n[2] = d),
				(n[3] = f))
			: (f = n[3]),
			(a = f);
	}
	if ("repo" in i.storage) {
		let c;
		n[4] !== i.storage.repo
			? ((c = Td(i.storage.repo)), (n[4] = i.storage.repo), (n[5] = c))
			: (c = n[5]),
			(l = c);
	}
	i.cloud && (l = i.cloud.project),
		(e = i.ui) !== null &&
			e !== void 0 &&
			(e = e.brand) !== null &&
			e !== void 0 &&
			e.name &&
			(l = i.ui.brand.name);
	let u;
	return (
		n[6] !== a || n[7] !== l
			? ((u = { brandMark: a, brandName: l }),
				(n[6] = a),
				(n[7] = l),
				(n[8] = u))
			: (u = n[8]),
		u
	);
}
function W$e() {
	const t = ee(4);
	let e, n;
	t[0] === Symbol.for("react.memo_cache_sentinel")
		? ((e = m.jsx("path", {
				d: "M18 8L14 24L12 32L30 14L18 8Z",
				fill: "currentColor",
			})),
			(n = m.jsx("path", {
				d: "M2 18L20 0L18 8L2 18Z",
				fill: "currentColor",
			})),
			(t[0] = e),
			(t[1] = n))
		: ((e = t[0]), (n = t[1]));
	let r;
	t[2] === Symbol.for("react.memo_cache_sentinel")
		? ((r = m.jsx("path", {
				d: "M18 8L2 18L14 24L18 8Z",
				fill: "url(#brand-mark-gradient)",
			})),
			(t[2] = r))
		: (r = t[2]);
	let i;
	return (
		t[3] === Symbol.for("react.memo_cache_sentinel")
			? ((i = m.jsxs("svg", {
					width: 24,
					height: 24,
					viewBox: "0 0 32 32",
					fill: "none",
					xmlns: "http://www.w3.org/2000/svg",
					children: [
						e,
						n,
						r,
						m.jsx("defs", {
							children: m.jsxs("linearGradient", {
								id: "brand-mark-gradient",
								x1: "2",
								y1: "18",
								x2: "20",
								y2: "14",
								gradientUnits: "userSpaceOnUse",
								children: [
									m.jsx("stop", {
										stopColor: "currentColor",
										stopOpacity: "0.2",
									}),
									m.jsx("stop", {
										offset: "1",
										stopColor: "currentColor",
									}),
								],
							}),
						}),
					],
				})),
				(t[3] = i))
			: (i = t[3]),
		i
	);
}
function q$e() {
	const t = fp(),
		e = Qo(),
		n = Xr(),
		r = Le(Ht),
		i = En(),
		o = Jn(),
		s = c5(o),
		a = E.useMemo(() => {
			const u = [];
			if (e) {
				u.push({
					name: e.defaultBranch,
					description: r.format("defaultBranch"),
				});
				for (let c of t.keys())
					c !== e.defaultBranch && u.push({ name: c });
			}
			return u;
		}, [t, e, r]),
		l = E.useMemo(
			() =>
				a.filter(
					(u) =>
						u.name === (e == null ? void 0 : e.defaultBranch) ||
						!s ||
						u.name.startsWith(s) ||
						u.name === n,
				),
			[a, e, s, n],
		);
	return m.jsx(L0, {
		"aria-label": r.format("currentBranch"),
		defaultItems: l,
		loadingState: l.length === 0 ? "loading" : void 0,
		selectedKey: n,
		onSelectionChange: (u) => {
			typeof u == "string" &&
				i.push(
					i.href.replace(
						/\/branch\/[^/]+/,
						"/branch/" + encodeURIComponent(u),
					),
				);
		},
		menuTrigger: "focus",
		flex: !0,
		children: (u) =>
			m.jsxs(
				Mt,
				{
					textValue: u.name,
					children: [
						m.jsx(ve, { src: PW }),
						m.jsx(ue, { truncate: !0, children: u.name }),
						"description" in u &&
							m.jsx(ue, {
								slot: "description",
								children: u.description,
							}),
					],
				},
				u.name,
			),
	});
}
function KY(t) {
	const e = ee(51),
		n = Jn(),
		r = Qo(),
		i = fp(),
		o = Xr(),
		s = (r == null ? void 0 : r.defaultBranch) === o,
		a = Le(Ht),
		[l, u] = UY(),
		{ error: c, fetching: d } = l,
		[f, h] = E.useState(""),
		[p, g] = E.useState(r.defaultBranch);
	let v;
	e[0] !== n ? ((v = c5(n)), (e[0] = n), (e[1] = v)) : (v = e[1]);
	const b = v;
	let y;
	e[2] !== b
		? ((y = b
				? {
						UNSAFE_className: X({
							"& input": {
								paddingInlineStart: B.size.space.xsmall,
							},
						}),
						startElement: m.jsx(ke, {
							alignItems: "center",
							paddingStart: "regular",
							justifyContent: "center",
							pointerEvents: "none",
							children: m.jsx(ue, {
								color: "neutralSecondary",
								children: b,
							}),
						}),
					}
				: {}),
			(e[2] = b),
			(e[3] = y))
		: (y = e[3]);
	const x = y;
	let C;
	e[4] === Symbol.for("react.memo_cache_sentinel")
		? ((C = { display: "contents" }), (e[4] = C))
		: (C = e[4]);
	let k;
	e[5] !== b ||
	e[6] !== f ||
	e[7] !== u ||
	e[8] !== i ||
	e[9] !== p ||
	e[10] !== r ||
	e[11] !== t
		? ((k = async (V) => {
				var K;
				if (V.target !== V.currentTarget) return;
				V.preventDefault();
				const M = (b ?? "") + f,
					G = `refs/heads/${M}`;
				(K = (
					await u({
						input: {
							name: G,
							oid: i.get(p).commitSha,
							repositoryId: r.id,
						},
					})
				).data) !== null &&
					K !== void 0 &&
					(K = K.createRef) !== null &&
					K !== void 0 &&
					K.__typename &&
					t.onCreate(M);
			}),
			(e[5] = b),
			(e[6] = f),
			(e[7] = u),
			(e[8] = i),
			(e[9] = p),
			(e[10] = r),
			(e[11] = t),
			(e[12] = k))
		: (k = e[12]);
	let w;
	e[13] !== a
		? ((w = a.format("newBranch")), (e[13] = a), (e[14] = w))
		: (w = e[14]);
	let D;
	e[15] !== w
		? ((D = m.jsx(Ut, { children: w })), (e[15] = w), (e[16] = D))
		: (D = e[16]);
	let S;
	e[17] !== s ||
	e[18] !== a ||
	e[19] !== c ||
	e[20] !== f ||
	e[21] !== x ||
	e[22] !== r ||
	e[23] !== o ||
	e[24] !== p
		? ((S = m.jsx(Pr, {
				children: s
					? m.jsx(An, {
							value: f,
							onChange: h,
							label: a.format("branchName"),
							autoFocus: !0,
							errorMessage: yE(c),
							...x,
						})
					: m.jsxs(gd, {
							gap: "xlarge",
							children: [
								m.jsx(An, {
									label: a.format("branchName"),
									value: f,
									onChange: h,
									autoFocus: !0,
									errorMessage: yE(c),
									...x,
								}),
								m.jsxs(j3e, {
									label: a.format("basedOn"),
									value: p,
									onChange: g,
									children: [
										m.jsxs(EI, {
											value: r.defaultBranch,
											children: [
												m.jsxs(ue, {
													children: [
														r.defaultBranch,
														m.jsx(ue, {
															visuallyHidden: !0,
															children: ".",
														}),
													],
												}),
												m.jsx(ue, {
													slot: "description",
													children: a.format(
														"theDefaultBranchInYourRepository",
													),
												}),
											],
										}),
										m.jsxs(EI, {
											value: o,
											children: [
												m.jsxs(ue, {
													children: [
														o,
														m.jsx(ue, {
															visuallyHidden: !0,
															children: ".",
														}),
													],
												}),
												m.jsx(ue, {
													slot: "description",
													children: a.format(
														"theCurrentlyCheckedOutBranch",
													),
												}),
											],
										}),
									],
								}),
							],
						}),
			})),
			(e[17] = s),
			(e[18] = a),
			(e[19] = c),
			(e[20] = f),
			(e[21] = x),
			(e[22] = r),
			(e[23] = o),
			(e[24] = p),
			(e[25] = S))
		: (S = e[25]);
	let $;
	e[26] === Symbol.for("react.memo_cache_sentinel")
		? (($ = { justifyContent: "flex-end" }), (e[26] = $))
		: ($ = e[26]);
	let A;
	e[27] !== d
		? ((A =
				d &&
				m.jsx(Cr, {
					"aria-labelledby": "create-branch-submit-button",
					isIndeterminate: !0,
					size: "small",
				})),
			(e[27] = d),
			(e[28] = A))
		: (A = e[28]);
	let T;
	e[29] !== A
		? ((T = m.jsx(Mne, { UNSAFE_style: $, children: A })),
			(e[29] = A),
			(e[30] = T))
		: (T = e[30]);
	let I;
	e[31] !== a
		? ((I = a.format("cancel")), (e[31] = a), (e[32] = I))
		: (I = e[32]);
	let F;
	e[33] !== t.onDismiss || e[34] !== d || e[35] !== I
		? ((F = m.jsx(vt, {
				onPress: t.onDismiss,
				isDisabled: d,
				children: I,
			})),
			(e[33] = t.onDismiss),
			(e[34] = d),
			(e[35] = I),
			(e[36] = F))
		: (F = e[36]);
	let N;
	e[37] !== a
		? ((N = a.format("create")), (e[37] = a), (e[38] = N))
		: (N = e[38]);
	let O;
	e[39] !== d || e[40] !== N
		? ((O = m.jsx(vt, {
				isDisabled: d,
				prominence: "high",
				type: "submit",
				id: "create-branch-submit-button",
				children: N,
			})),
			(e[39] = d),
			(e[40] = N),
			(e[41] = O))
		: (O = e[41]);
	let _;
	e[42] !== F || e[43] !== O
		? ((_ = m.jsxs(Nr, { children: [F, O] })),
			(e[42] = F),
			(e[43] = O),
			(e[44] = _))
		: (_ = e[44]);
	let j;
	return (
		e[45] !== k || e[46] !== D || e[47] !== S || e[48] !== T || e[49] !== _
			? ((j = m.jsx(vr, {
					size: "small",
					children: m.jsxs("form", {
						style: C,
						onSubmit: k,
						children: [D, S, T, _],
					}),
				})),
				(e[45] = k),
				(e[46] = D),
				(e[47] = S),
				(e[48] = T),
				(e[49] = _),
				(e[50] = j))
			: (j = e[50]),
		j
	);
}
const G$e = [" ", "~", "^", ":", "*", "?", "[", "..", "@{", "\\"],
	Y$e = [".", "/"],
	J$e = [".", "/", ".lock"];
function yE(t) {
	if (t) {
		if (t.message.includes("is not a valid ref name")) {
			let e = t.message.match(/"([^"]+)"/),
				n = e ? e[1].replace("refs/heads/", "") : "";
			for (let i of Y$e)
				if (n.startsWith(i)) return `Cannot start with "${i}"`;
			for (let i of J$e)
				if (n.endsWith(i)) return `Cannot end with "${i}"`;
			let r = G$e.filter((i) => n.includes(i));
			if (r.length > 0) {
				let i = { style: "long", type: "conjunction" },
					o = new Intl.ListFormat("en-US", i),
					s = r.map((a) => `"${a}"`);
				return `Some characters are not allowed: ${o.format(s)}`;
			}
			return "Invalid branch name";
		}
		return t.message;
	}
}
function UY() {
	return f3(yr`
      mutation CreateBranch($input: CreateRefInput!) {
        createRef(input: $input) {
          __typename
          ref {
            ...Ref_base
          }
        }
      }
      ${m5}
    `);
}
const HY = E.createContext({
		theme: "auto",
		setTheme: () => {
			throw new Error("ThemeContext was not initialized.");
		},
	}),
	X$e = HY.Provider,
	TF = "keystatic-color-scheme";
function Z$e() {
	const t = ee(4);
	let e;
	t[0] === Symbol.for("react.memo_cache_sentinel")
		? ((e = () => {
				const a = localStorage.getItem(TF);
				return a === "light" || a === "dark" ? a : "auto";
			}),
			(t[0] = e))
		: (e = t[0]);
	const [n, r] = E.useState(e);
	let i;
	t[1] === Symbol.for("react.memo_cache_sentinel")
		? ((i = (a) => {
				localStorage.setItem(TF, a), r(a);
			}),
			(t[1] = i))
		: (i = t[1]);
	const o = i;
	let s;
	return (
		t[2] !== n
			? ((s = { theme: n, setTheme: o }), (t[2] = n), (t[3] = s))
			: (s = t[3]),
		s
	);
}
function Q$e() {
	return E.useContext(HY);
}
const aA = (t) => {
		const e = ee(4),
			{ attributes: n, children: r, draggable: i } = t,
			o = i === void 0 ? !1 : i;
		let s;
		return (
			e[0] !== o || e[1] !== n || e[2] !== r
				? ((s = m.jsx("div", {
						draggable: o,
						className: E3,
						...n,
						children: r,
					})),
					(e[0] = o),
					(e[1] = n),
					(e[2] = r),
					(e[3] = s))
				: (s = e[3]),
			s
		);
	},
	H3 = () => {
		const t = ee(1);
		let e;
		return (
			t[0] === Symbol.for("react.memo_cache_sentinel")
				? ((e = m.jsx(ra, { orientation: "vertical", flexShrink: 0 })),
					(t[0] = e))
				: (e = t[0]),
			e
		);
	},
	WY = {
		light: { icon: GH, label: "Light" },
		dark: { icon: qH, label: "Dark" },
		auto: { icon: g3e, label: "System" },
	},
	eTe = Object.entries(WY).map(([t, { icon: e, label: n }]) => ({
		id: t,
		icon: e,
		label: n,
	}));
function qY() {
	const t = ee(13),
		{ theme: e, setTheme: n } = Q$e(),
		r = $l("(prefers-color-scheme: dark)");
	let i = WY[e].icon;
	e === "auto" && (i = r ? qH : GH);
	let o;
	t[0] !== i
		? ((o = m.jsx(Re, {
				"aria-label": "theme",
				prominence: "low",
				children: m.jsx(ve, { src: i }),
			})),
			(t[0] = i),
			(t[1] = o))
		: (o = t[1]);
	let s;
	t[2] !== n
		? ((s = (d) => {
				const [f] = d;
				return n(f);
			}),
			(t[2] = n),
			(t[3] = s))
		: (s = t[3]);
	let a;
	t[4] !== e ? ((a = [e]), (t[4] = e), (t[5] = a)) : (a = t[5]);
	let l;
	t[6] === Symbol.for("react.memo_cache_sentinel")
		? ((l = (d) =>
				m.jsxs(Mt, {
					textValue: d.label,
					children: [
						m.jsx(ve, { src: d.icon }),
						m.jsx(ue, { children: d.label }),
					],
				})),
			(t[6] = l))
		: (l = t[6]);
	let u;
	t[7] !== s || t[8] !== a
		? ((u = m.jsx(Jo, {
				items: eTe,
				onSelectionChange: s,
				disallowEmptySelection: !0,
				selectedKeys: a,
				selectionMode: "single",
				children: l,
			})),
			(t[7] = s),
			(t[8] = a),
			(t[9] = u))
		: (u = t[9]);
	let c;
	return (
		t[10] !== o || t[11] !== u
			? ((c = m.jsxs(Xo, { align: "end", children: [o, u] })),
				(t[10] = o),
				(t[11] = u),
				(t[12] = c))
			: (c = t[12]),
		c
	);
}
function tTe() {
	const t = ee(5),
		e = Jn(),
		n = oTe(),
		r = En();
	if (!n) return null;
	if (n === "unauthorized") {
		let o;
		return (
			t[0] !== r.params || t[1] !== e
				? ((o = m.jsx(Re, {
						onPress: () => {
							O0(r.params.map(encodeURIComponent).join("/"), e);
						},
						flex: !0,
						children: "Sign into Cloud",
					})),
					(t[0] = r.params),
					(t[1] = e),
					(t[2] = o))
				: (o = t[2]),
			o
		);
	}
	let i;
	return (
		t[3] !== n
			? ((i = m.jsx(nTe, { ...n })), (t[3] = n), (t[4] = i))
			: (i = t[4]),
		i
	);
}
function nTe(t) {
	const e = ee(16),
		n = Jn(),
		r = _0(),
		i = SH();
	let o;
	const s =
		n.storage.kind === "github" ? "/api/keystatic/github/logout" : void 0;
	let a;
	if (e[0] !== s || e[1] !== n.cloud || e[2] !== r || e[3] !== i) {
		var l;
		(a = [{ key: "logout", label: "Log out", href: s, icon: p3e }]),
			(l = n.cloud) !== null &&
				l !== void 0 &&
				l.project &&
				a.unshift({
					key: "manage",
					label: "Account",
					icon: b3e,
					href: "https://keystatic.cloud/account",
					target: "_blank",
					rel: "noopener noreferrer",
				}),
			r != null &&
				r.team.images &&
				a.unshift({
					key: "image-library",
					label: "Image library",
					icon: E0,
					href: i,
					target: "_blank",
					rel: "noopener noreferrer",
				}),
			(e[0] = s),
			(e[1] = n.cloud),
			(e[2] = r),
			(e[3] = i),
			(e[4] = a);
	} else a = e[4];
	o = a;
	const u = o;
	if (!t) return null;
	let c;
	e[5] !== t
		? ((c = m.jsx(rTe, { ...t })), (e[5] = t), (e[6] = c))
		: (c = e[6]);
	let d;
	e[7] !== n
		? ((d = async (g) => {
				switch ((await Promise.all([Bye(), yye()]), g)) {
					case "logout":
						switch (n.storage.kind) {
							case "cloud":
							case "local": {
								var v;
								const b =
									(v = M0(n)) === null || v === void 0
										? void 0
										: v.accessToken;
								b &&
									(await fetch(`${Rl}/oauth/revoke`, {
										method: "POST",
										body: new URLSearchParams({
											token: b,
										}).toString(),
										headers: {
											"Content-Type":
												"application/x-www-form-urlencoded",
											...ic,
										},
									})),
									localStorage.removeItem(
										"keystatic-cloud-access-token",
									),
									window.location.reload();
							}
						}
				}
			}),
			(e[7] = n),
			(e[8] = d))
		: (d = e[8]);
	let f;
	e[9] === Symbol.for("react.memo_cache_sentinel")
		? ((f = (g) =>
				m.jsxs(
					Mt,
					{
						textValue: g.label,
						href: g.href,
						rel: g.rel,
						target: g.target,
						children: [
							m.jsx(ve, { src: g.icon }),
							m.jsx(ue, { children: g.label }),
						],
					},
					g.key,
				)),
			(e[9] = f))
		: (f = e[9]);
	let h;
	e[10] !== u || e[11] !== d
		? ((h = m.jsx(m.Fragment, {
				children: m.jsx(Jo, {
					items: u,
					minWidth: "scale.2400",
					onAction: d,
					children: f,
				}),
			})),
			(e[10] = u),
			(e[11] = d),
			(e[12] = h))
		: (h = e[12]);
	let p;
	return (
		e[13] !== c || e[14] !== h
			? ((p = m.jsxs(Xo, { children: [c, h] })),
				(e[13] = c),
				(e[14] = h),
				(e[15] = p))
			: (p = e[15]),
		p
	);
}
const rTe = E.forwardRef(function (e, n) {
	var r;
	const i = ee(24);
	let o, s, a, l;
	i[0] !== e
		? (({ avatarUrl: s, login: a, name: o, ...l } = e),
			(i[0] = e),
			(i[1] = o),
			(i[2] = s),
			(i[3] = a),
			(i[4] = l))
		: ((o = i[1]), (s = i[2]), (a = i[3]), (l = i[4]));
	let u;
	i[5] === Symbol.for("react.memo_cache_sentinel")
		? ((u = X({ justifyContent: "start", textAlign: "start" })), (i[5] = u))
		: (u = i[5]);
	const c = (r = o) !== null && r !== void 0 ? r : void 0;
	let d;
	i[6] !== s || i[7] !== c
		? ((d = m.jsx(m3, { src: s, name: c, size: "small" })),
			(i[6] = s),
			(i[7] = c),
			(i[8] = d))
		: (d = i[8]);
	let f;
	i[9] !== o
		? ((f = m.jsx(ue, {
				size: "small",
				weight: "semibold",
				color: "neutralEmphasis",
				children: o,
			})),
			(i[9] = o),
			(i[10] = f))
		: (f = i[10]);
	let h;
	i[11] !== o || i[12] !== a
		? ((h =
				o === a
					? null
					: m.jsx(ue, {
							size: "small",
							color: "neutralTertiary",
							children: a,
						})),
			(i[11] = o),
			(i[12] = a),
			(i[13] = h))
		: (h = i[13]);
	let p;
	i[14] !== f || i[15] !== h
		? ((p = m.jsx(c0, {
				children: m.jsxs(ke, {
					direction: "column",
					gap: "small",
					children: [f, h],
				}),
			})),
			(i[14] = f),
			(i[15] = h),
			(i[16] = p))
		: (p = i[16]);
	let g;
	i[17] !== d || i[18] !== p
		? ((g = m.jsxs(ke, {
				alignItems: "center",
				gap: "regular",
				children: [d, p],
			})),
			(i[17] = d),
			(i[18] = p),
			(i[19] = g))
		: (g = i[19]);
	let v;
	return (
		i[20] !== l || i[21] !== n || i[22] !== g
			? ((v = m.jsx(Re, {
					...l,
					ref: n,
					"aria-label": "User menu",
					prominence: "low",
					flexGrow: 1,
					UNSAFE_className: u,
					children: g,
				})),
				(i[20] = l),
				(i[21] = n),
				(i[22] = g),
				(i[23] = v))
			: (v = i[23]),
		v
	);
});
function GY() {
	var t, e, n;
	const r = ee(9),
		i = fp(),
		o = Qo(),
		s = Xr();
	let a;
	if (r[0] !== i || r[1] !== s) {
		var l;
		(a = (l = i.get(s)) === null || l === void 0 ? void 0 : l.id),
			(r[0] = i),
			(r[1] = s),
			(r[2] = a);
	} else a = r[2];
	const u = a;
	let c;
	r[3] === Symbol.for("react.memo_cache_sentinel")
		? ((c = yr`
      query PullRequestForBranch($refId: ID!) {
        node(id: $refId) {
          __typename
          id
          ... on Ref {
            associatedPullRequests(states: [OPEN], first: 1) {
              nodes {
                id
                number
              }
            }
          }
        }
      }
    `),
			(r[3] = c))
		: (c = r[3]);
	const d = !u || s === (o == null ? void 0 : o.defaultBranch);
	let f;
	r[4] !== u ? ((f = { refId: u }), (r[4] = u), (r[5] = f)) : (f = r[5]);
	let h;
	r[6] !== d || r[7] !== f
		? ((h = { query: c, pause: d, variables: f }),
			(r[6] = d),
			(r[7] = f),
			(r[8] = h))
		: (h = r[8]);
	const [p] = x2(h);
	return (t = p.data) !== null &&
		t !== void 0 &&
		t.node &&
		p.data.node.__typename === "Ref"
		? (e =
				(n = p.data.node.associatedPullRequests) === null ||
				n === void 0 ||
				(n = n.nodes) === null ||
				n === void 0 ||
				(n = n[0]) === null ||
				n === void 0
					? void 0
					: n.number) !== null && e !== void 0
			? e
			: !1
		: void 0;
}
function iTe() {
	const t = ee(84),
		e = fp(),
		n = Xr(),
		r = Qo(),
		i = GY(),
		o = Le(Ht);
	let s;
	t[0] === Symbol.for("react.memo_cache_sentinel")
		? ((s = (F) => !F), (t[0] = s))
		: (s = t[0]);
	const [a, l] = E.useReducer(s, !1);
	let u;
	t[1] === Symbol.for("react.memo_cache_sentinel")
		? ((u = (F) => !F), (t[1] = u))
		: (u = t[1]);
	const [c, d] = E.useReducer(u, !1);
	let f;
	t[2] === Symbol.for("react.memo_cache_sentinel")
		? ((f = yr`
      mutation DeleteBranch($refId: ID!) {
        deleteRef(input: { refId: $refId }) {
          __typename
        }
      }
    `),
			(t[2] = f))
		: (f = t[2]);
	const [, h] = f3(f);
	let p, g;
	t[3] !== r
		? ((g = r ? Cg(r.upstream) : ""), (t[3] = r), (t[4] = g))
		: (g = t[4]);
	const v = g,
		b = n === (r == null ? void 0 : r.defaultBranch);
	let y;
	if (
		t[5] !== o ||
		t[6] !== v ||
		t[7] !== b ||
		t[8] !== i ||
		t[9] !== n ||
		t[10] !== r
	) {
		y = [];
		let F;
		t[12] !== o
			? ((F = o.format("newBranch")), (t[12] = o), (t[13] = F))
			: (F = t[13]);
		let N;
		t[14] !== F
			? ((N = { key: "new-branch", icon: WH, label: F }),
				(t[14] = F),
				(t[15] = N))
			: (N = t[15]);
		let O, _, j;
		if (
			t[16] !== N ||
			t[17] !== v ||
			t[18] !== b ||
			t[19] !== i ||
			t[20] !== n ||
			t[21] !== o ||
			t[22] !== r
		) {
			(O = [N]), (_ = []);
			let V;
			if (
				(t[26] !== v
					? ((V = {
							key: "repo",
							icon: Ex,
							href: v,
							target: "_blank",
							rel: "noopener noreferrer",
							label: "Github repo",
						}),
						(t[26] = v),
						(t[27] = V))
					: (V = t[27]),
				(j = [V]),
				!b && i !== void 0)
			)
				if (i === !1) {
					const G = `${v}/pull/new/${n}`;
					let H;
					t[28] !== o
						? ((H = o.format("createPullRequest")),
							(t[28] = o),
							(t[29] = H))
						: (H = t[29]);
					let P;
					t[30] !== G || t[31] !== H
						? ((P = {
								key: "create-pull-request",
								icon: gy,
								href: G,
								target: "_blank",
								rel: "noopener noreferrer",
								label: H,
							}),
							(t[30] = G),
							(t[31] = H),
							(t[32] = P))
						: (P = t[32]),
						_.push(P);
					let q;
					t[33] !== o
						? ((q = o.format("deleteBranch")),
							(t[33] = o),
							(t[34] = q))
						: (q = t[34]);
					let J;
					t[35] !== q
						? ((J = { key: "delete-branch", icon: Wr, label: q }),
							(t[35] = q),
							(t[36] = J))
						: (J = t[36]),
						O.push(J);
				} else {
					const G = `${v}/pull/${i}`,
						H = `Pull Request #${i}`;
					let P;
					t[37] !== G || t[38] !== H
						? ((P = {
								key: "view-pull-request",
								icon: gy,
								href: G,
								target: "_blank",
								rel: "noopener noreferrer",
								label: H,
							}),
							(t[37] = G),
							(t[38] = H),
							(t[39] = P))
						: (P = t[39]),
						_.push(P);
				}
			let K;
			t[40] !== r
				? ((K = r ? Cg(r) : ""), (t[40] = r), (t[41] = K))
				: (K = t[41]);
			const M = K;
			if (M !== v) {
				let G;
				t[42] !== M
					? ((G = {
							key: "fork",
							icon: m3e,
							href: M,
							target: "_blank",
							rel: "noopener noreferrer",
							label: "View fork",
						}),
						(t[42] = M),
						(t[43] = G))
					: (G = t[43]),
					j.push(G);
			}
			(t[16] = N),
				(t[17] = v),
				(t[18] = b),
				(t[19] = i),
				(t[20] = n),
				(t[21] = o),
				(t[22] = r),
				(t[23] = O),
				(t[24] = _),
				(t[25] = j);
		} else (O = t[23]), (_ = t[24]), (j = t[25]);
		if (O.length) {
			let V;
			t[44] !== o
				? ((V = o.format("branches")), (t[44] = o), (t[45] = V))
				: (V = t[45]);
			let K;
			t[46] !== V || t[47] !== O
				? ((K = { key: "branch-section", label: V, children: O }),
					(t[46] = V),
					(t[47] = O),
					(t[48] = K))
				: (K = t[48]),
				y.push(K);
		}
		if (_.length) {
			let V;
			t[49] !== o
				? ((V = o.format("pullRequests")), (t[49] = o), (t[50] = V))
				: (V = t[50]);
			let K;
			t[51] !== V || t[52] !== _
				? ((K = { key: "pr-section", label: V, children: _ }),
					(t[51] = V),
					(t[52] = _),
					(t[53] = K))
				: (K = t[53]),
				y.push(K);
		}
		if (j.length) {
			let V;
			t[54] !== j
				? ((V = {
						key: "repo-section",
						label: "Repository",
						children: j,
					}),
					(t[54] = j),
					(t[55] = V))
				: (V = t[55]),
				y.push(V);
		}
		(t[5] = o),
			(t[6] = v),
			(t[7] = b),
			(t[8] = i),
			(t[9] = n),
			(t[10] = r),
			(t[11] = y);
	} else y = t[11];
	p = y;
	const x = p,
		C = En();
	let k;
	t[56] !== l || t[57] !== d
		? ((k = (F) => {
				e: switch (F) {
					case "new-branch": {
						l();
						break e;
					}
					case "delete-branch":
						d();
				}
			}),
			(t[56] = l),
			(t[57] = d),
			(t[58] = k))
		: (k = t[58]);
	let w;
	t[59] === Symbol.for("react.memo_cache_sentinel")
		? ((w = (F) =>
				m.jsx(
					sie,
					{
						items: F.children,
						"aria-label": F.label,
						children: (N) =>
							m.jsxs(
								Mt,
								{
									textValue: N.label,
									href: N.href,
									rel: N.rel,
									target: N.target,
									children: [
										m.jsx(ve, { src: N.icon }),
										m.jsx(ue, { children: N.label }),
									],
								},
								N.key,
							),
					},
					F.key,
				)),
			(t[59] = w))
		: (w = t[59]);
	let D;
	t[60] !== x || t[61] !== k
		? ((D = m.jsx(mce, {
				"aria-label": "git actions",
				align: "end",
				items: x,
				onAction: k,
				children: w,
			})),
			(t[60] = x),
			(t[61] = k),
			(t[62] = D))
		: (D = t[62]);
	let S;
	t[63] !== a || t[64] !== l || t[65] !== C
		? ((S =
				a &&
				m.jsx(KY, {
					onDismiss: l,
					onCreate: (F) => {
						l(),
							C.push(
								C.href.replace(
									/\/branch\/[^/]+/,
									"/branch/" + encodeURIComponent(F),
								),
							);
					},
				})),
			(t[63] = a),
			(t[64] = l),
			(t[65] = C),
			(t[66] = S))
		: (S = t[66]);
	let $;
	t[67] !== l || t[68] !== S
		? (($ = m.jsx(mn, { onDismiss: l, children: S })),
			(t[67] = l),
			(t[68] = S),
			(t[69] = $))
		: ($ = t[69]);
	let A;
	t[70] !== c ||
	t[71] !== r ||
	t[72] !== h ||
	t[73] !== e ||
	t[74] !== n ||
	t[75] !== C
		? ((A =
				c &&
				m.jsxs(Fw, {
					title: "Delete branch",
					tone: "critical",
					cancelLabel: "Cancel",
					primaryActionLabel: "Yes, delete",
					autoFocusButton: "cancel",
					onPrimaryAction: async () => {
						r &&
							(await h({ refId: e.get(n).id }),
							C.push(
								C.href.replace(
									/\/branch\/[^/]+/,
									"/branch/" +
										encodeURIComponent(r.defaultBranch),
								),
							));
					},
					children: [
						'Are you sure you want to delete the "',
						n,
						'" branch? This cannot be undone.',
					],
				})),
			(t[70] = c),
			(t[71] = r),
			(t[72] = h),
			(t[73] = e),
			(t[74] = n),
			(t[75] = C),
			(t[76] = A))
		: (A = t[76]);
	let T;
	t[77] !== d || t[78] !== A
		? ((T = m.jsx(mn, { onDismiss: d, children: A })),
			(t[77] = d),
			(t[78] = A),
			(t[79] = T))
		: (T = t[79]);
	let I;
	return (
		t[80] !== D || t[81] !== $ || t[82] !== T
			? ((I = m.jsxs(m.Fragment, { children: [D, $, T] })),
				(t[80] = D),
				(t[81] = $),
				(t[82] = T),
				(t[83] = I))
			: (I = t[83]),
		I
	);
}
function oTe() {
	const t = ee(8),
		e = Jn(),
		n = KU(),
		r = Kye();
	if (r) {
		if (r === "unauthorized") return r;
		let o;
		return (
			t[0] !== r.user.avatarUrl ||
			t[1] !== r.user.email ||
			t[2] !== r.user.name
				? ((o = {
						avatarUrl: r.user.avatarUrl,
						login: r.user.email,
						name: r.user.name,
					}),
					(t[0] = r.user.avatarUrl),
					(t[1] = r.user.email),
					(t[2] = r.user.name),
					(t[3] = o))
				: (o = t[3]),
			o
		);
	}
	if (va(e) && n) {
		var i;
		const o = (i = n.name) !== null && i !== void 0 ? i : n.login;
		let s;
		return (
			t[4] !== n.avatarUrl || t[5] !== n.login || t[6] !== o
				? ((s = { avatarUrl: n.avatarUrl, login: n.login, name: o }),
					(t[4] = n.avatarUrl),
					(t[5] = n.login),
					(t[6] = o),
					(t[7] = s))
				: (s = t[7]),
			s
		);
	}
}
const YY = E.createContext(null);
function lA() {
	const t = E.useContext(YY);
	if (!t) throw new Error("useSidebar must be within a SidebarProvider");
	return t;
}
const sTe = DP(Pn);
function aTe(t) {
	const e = ee(13),
		n = $P();
	let r;
	e[0] !== n
		? ((r = n.includes("desktop")), (e[0] = n), (e[1] = r))
		: (r = e[1]);
	let i;
	e[2] !== r
		? ((i = { defaultOpen: r }), (e[2] = r), (e[3] = i))
		: (i = e[3]);
	const o = Bl(i),
		s = sTe.indexOf(n[0]),
		a = Lne(s) || 0;
	let l;
	e[4] !== a || e[5] !== s || e[6] !== o
		? ((l = () => {
				a < s && s >= 2 ? o.open() : s < 2 && o.close();
			}),
			(e[4] = a),
			(e[5] = s),
			(e[6] = o),
			(e[7] = l))
		: (l = e[7]);
	let u;
	e[8] !== n ? ((u = [n]), (e[8] = n), (e[9] = u)) : (u = e[9]), o0(l, u);
	let c;
	return (
		e[10] !== o || e[11] !== t.children
			? ((c = m.jsx(YY.Provider, { value: o, children: t.children })),
				(e[10] = o),
				(e[11] = t.children),
				(e[12] = c))
			: (c = e[12]),
		c
	);
}
function lTe() {
	const t = ee(4);
	let e;
	t[0] === Symbol.for("react.memo_cache_sentinel")
		? ((e = m.jsx(JY, {})), (t[0] = e))
		: (e = t[0]);
	let n;
	t[1] === Symbol.for("react.memo_cache_sentinel")
		? ((n = m.jsx(ZY, {})), (t[1] = n))
		: (n = t[1]);
	let r;
	t[2] === Symbol.for("react.memo_cache_sentinel")
		? ((r = m.jsx(QY, {})), (t[2] = r))
		: (r = t[2]);
	let i;
	return (
		t[3] === Symbol.for("react.memo_cache_sentinel")
			? ((i = m.jsxs(Hr, {
					backgroundColor: "surface",
					height: "100%",
					children: [e, n, r, m.jsx(XY, {})],
				})),
				(t[3] = i))
			: (i = t[3]),
		i
	);
}
function JY() {
	const t = ee(12),
		e = eJ(),
		{ brandMark: n, brandName: r } = H$e();
	let i;
	t[0] === Symbol.for("react.memo_cache_sentinel")
		? ((i = { mobile: "element.large", tablet: "element.xlarge" }),
			(t[0] = i))
		: (i = t[0]);
	let o;
	t[1] === Symbol.for("react.memo_cache_sentinel")
		? ((o = X({
				color: B.color.foreground.neutralEmphasis,
				"& :first-child": { flexShrink: 0 },
			})),
			(t[1] = o))
		: (o = t[1]);
	let s;
	t[2] !== r
		? ((s = m.jsx(ue, {
				color: "inherit",
				weight: "medium",
				truncate: !0,
				children: r,
			})),
			(t[2] = r),
			(t[3] = s))
		: (s = t[3]);
	let a;
	t[4] !== n || t[5] !== s
		? ((a = m.jsxs(As, {
				flex: !0,
				alignItems: "center",
				gap: "regular",
				UNSAFE_className: o,
				children: [n, s],
			})),
			(t[4] = n),
			(t[5] = s),
			(t[6] = a))
		: (a = t[6]);
	let l;
	t[7] !== e
		? ((l = e && m.jsx(qY, {})), (t[7] = e), (t[8] = l))
		: (l = t[8]);
	let u;
	return (
		t[9] !== a || t[10] !== l
			? ((u = m.jsxs(As, {
					alignItems: "center",
					gap: "regular",
					paddingY: "regular",
					paddingX: "medium",
					height: i,
					children: [a, l],
				})),
				(t[9] = a),
				(t[10] = l),
				(t[11] = u))
			: (u = t[11]),
		u
	);
}
function XY() {
	const t = ee(2);
	if (eJ()) return null;
	let n;
	t[0] === Symbol.for("react.memo_cache_sentinel")
		? ((n = m.jsx(tTe, {})), (t[0] = n))
		: (n = t[0]);
	let r;
	return (
		t[1] === Symbol.for("react.memo_cache_sentinel")
			? ((r = m.jsxs(As, {
					alignItems: "center",
					paddingY: "regular",
					paddingX: "medium",
					gap: "regular",
					children: [n, m.jsx(qY, {})],
				})),
				(t[1] = r))
			: (r = t[1]),
		r
	);
}
function ZY() {
	const t = ee(2),
		e = Jn();
	if (cp(e)) return null;
	let n;
	t[0] === Symbol.for("react.memo_cache_sentinel")
		? ((n = m.jsx(q$e, {})), (t[0] = n))
		: (n = t[0]);
	let r;
	return (
		t[1] === Symbol.for("react.memo_cache_sentinel")
			? ((r = m.jsxs(As, {
					gap: "regular",
					paddingY: "regular",
					paddingX: "medium",
					children: [n, m.jsx(iTe, {})],
				})),
				(t[1] = r))
			: (r = t[1]),
		r
	);
}
function uTe() {
	const t = ee(25),
		e = lA(),
		n = En();
	let r;
	t[0] !== e
		? ((r = () => {
				e.close();
			}),
			(t[0] = e),
			(t[1] = r))
		: (r = t[1]);
	let i;
	t[2] !== n.href
		? ((i = [n.href]), (t[2] = n.href), (t[3] = i))
		: (i = t[3]),
		o0(r, i);
	const o = E.useRef(null);
	let s;
	t[4] === Symbol.for("react.memo_cache_sentinel")
		? ((s = { isDismissable: !0 }), (t[4] = s))
		: (s = t[4]);
	const { modalProps: a, underlayProps: l } = rD(s, e, o);
	let u;
	t[5] !== l || t[6] !== e.isOpen
		? ((u = m.jsx(Fx, { ...l, isOpen: e.isOpen, zIndex: 10 })),
			(t[5] = l),
			(t[6] = e.isOpen),
			(t[7] = u))
		: (u = t[7]);
	let c;
	t[8] === Symbol.for("react.memo_cache_sentinel")
		? ((c = bt("transform", { easing: "easeIn", duration: "short" })),
			(t[8] = c))
		: (c = t[8]);
	let d;
	t[9] === Symbol.for("react.memo_cache_sentinel")
		? ((d = [
				c,
				bt("visibility", {
					delay: "regular",
					duration: 0,
					easing: "linear",
				}),
			]),
			(t[9] = d))
		: (d = t[9]);
	let f;
	t[10] === Symbol.for("react.memo_cache_sentinel")
		? ((f = X({
				backgroundColor: B.color.background.surface,
				boxShadow: `${B.size.shadow.large} ${B.color.shadow.regular}`,
				display: "flex",
				flexDirection: "column",
				inset: 0,
				insetInlineEnd: "auto",
				maxWidth: `calc(100% - ${B.size.element.medium})`,
				minWidth: B.size.scale[3e3],
				outline: 0,
				pointerEvents: "none",
				position: "fixed",
				transform: "translateX(-100%)",
				visibility: "hidden",
				zIndex: 10,
				transition: d.join(", "),
				"&[data-visible=true]": {
					transform: "translateX(0)",
					transition: bt("transform", { easing: "easeOut" }),
					pointerEvents: "auto",
					visibility: "visible",
				},
			})),
			(t[10] = f))
		: (f = t[10]);
	let h;
	t[11] === Symbol.for("react.memo_cache_sentinel")
		? ((h = m.jsx(JY, {})), (t[11] = h))
		: (h = t[11]);
	let p;
	t[12] === Symbol.for("react.memo_cache_sentinel")
		? ((p = m.jsx(ZY, {})), (t[12] = p))
		: (p = t[12]);
	let g;
	t[13] === Symbol.for("react.memo_cache_sentinel")
		? ((g = m.jsx(QY, {})), (t[13] = g))
		: (g = t[13]);
	let v;
	t[14] === Symbol.for("react.memo_cache_sentinel")
		? ((v = m.jsx(XY, {})), (t[14] = v))
		: (v = t[14]);
	let b;
	t[15] !== e.close
		? ((b = m.jsx(Hm, { onDismiss: e.close })),
			(t[15] = e.close),
			(t[16] = b))
		: (b = t[16]);
	let y;
	t[17] !== e.isOpen || t[18] !== o || t[19] !== a || t[20] !== b
		? ((y = m.jsxs("div", {
				"data-visible": e.isOpen,
				id: L$e,
				ref: o,
				...a,
				className: f,
				children: [h, p, g, v, b],
			})),
			(t[17] = e.isOpen),
			(t[18] = o),
			(t[19] = a),
			(t[20] = b),
			(t[21] = y))
		: (y = t[21]);
	let x;
	return (
		t[22] !== u || t[23] !== y
			? ((x = m.jsxs(m.Fragment, { children: [u, y] })),
				(t[22] = u),
				(t[23] = y),
				(t[24] = x))
			: (x = t[24]),
		x
	);
}
function QY() {
	const t = ee(15),
		{ basePath: e } = mH(),
		n = Le(Ht),
		r = VY(),
		i = tJ();
	let o;
	t[0] !== i || t[1] !== e
		? ((o = i(e, { exact: !0 })), (t[0] = i), (t[1] = e), (t[2] = o))
		: (o = t[2]);
	let s;
	t[3] !== n
		? ((s = n.format("dashboard")), (t[3] = n), (t[4] = s))
		: (s = t[4]);
	let a;
	t[5] !== e || t[6] !== o || t[7] !== s
		? ((a = m.jsx(HH, { href: e, "aria-current": o, children: s })),
			(t[5] = e),
			(t[6] = o),
			(t[7] = s),
			(t[8] = a))
		: (a = t[8]);
	let l;
	if (t[9] !== r) {
		let c;
		t[11] === Symbol.for("react.memo_cache_sentinel")
			? ((c = (d, f) => m.jsx(nJ, { itemOrGroup: d }, f)), (t[11] = c))
			: (c = t[11]),
			(l = r.map(c)),
			(t[9] = r),
			(t[10] = l);
	} else l = t[10];
	let u;
	return (
		t[12] !== a || t[13] !== l
			? ((u = m.jsx(Sre, {
					flex: !0,
					paddingY: "large",
					paddingEnd: "medium",
					children: m.jsxs(s3e, { children: [a, l] }),
				})),
				(t[12] = a),
				(t[13] = l),
				(t[14] = u))
			: (u = t[14]),
		u
	);
}
function eJ() {
	const t = ee(2),
		e = Jn();
	let n;
	return (
		t[0] !== e
			? ((n = cp(e) && !e.cloud), (t[0] = e), (t[1] = n))
			: (n = t[1]),
		n
	);
}
function tJ() {
	const t = ee(2),
		e = En();
	let n;
	return (
		t[0] !== e.pathname
			? ((n = (r, i) => {
					const { exact: o } = i === void 0 ? {} : i;
					return (o === void 0 ? !1 : o)
						? r === e.pathname
							? "page"
							: void 0
						: r === e.pathname || e.pathname.startsWith(`${r}/`)
							? "page"
							: void 0;
				}),
				(t[0] = e.pathname),
				(t[1] = n))
			: (n = t[1]),
		n
	);
}
function nJ(t) {
	const e = ee(19),
		{ itemOrGroup: n } = t,
		r = tJ();
	if (n.isDivider) {
		let u;
		return (
			e[0] === Symbol.for("react.memo_cache_sentinel")
				? ((u = m.jsx(ra, {})), (e[0] = u))
				: (u = e[0]),
			u
		);
	}
	if (n.children) {
		let u;
		if (e[1] !== n.children) {
			let d;
			e[3] === Symbol.for("react.memo_cache_sentinel")
				? ((d = (f, h) => m.jsx(nJ, { itemOrGroup: f }, h)), (e[3] = d))
				: (d = e[3]),
				(u = n.children.map(d)),
				(e[1] = n.children),
				(e[2] = u);
		} else u = e[2];
		let c;
		return (
			e[4] !== n.title || e[5] !== u
				? ((c = m.jsx(c3e, { title: n.title, children: u })),
					(e[4] = n.title),
					(e[5] = u),
					(e[6] = c))
				: (c = e[6]),
			c
		);
	}
	let i;
	e: {
		if (!n.changed) {
			i = null;
			break e;
		}
		let u;
		e[7] !== n.changed
			? ((u =
					typeof n.changed == "number"
						? m.jsxs($g, {
								tone: "accent",
								marginStart: "auto",
								children: [
									m.jsx(ue, { children: n.changed }),
									m.jsx(ue, {
										visuallyHidden: !0,
										children: Od(n.changed, {
											singular: "change",
											plural: "changes",
											inclusive: !1,
										}),
									}),
								],
							})
						: m.jsx(h3e, {
								tone: "accent",
								marginStart: "auto",
								"aria-label": "Changed",
								role: "status",
							})),
				(e[7] = n.changed),
				(e[8] = u))
			: (u = e[8]),
			(i = u);
	}
	const o = i;
	let s;
	e[9] !== r || e[10] !== n.href
		? ((s = r(n.href)), (e[9] = r), (e[10] = n.href), (e[11] = s))
		: (s = e[11]);
	let a;
	e[12] !== n.label
		? ((a = m.jsx(ue, { truncate: !0, title: n.label, children: n.label })),
			(e[12] = n.label),
			(e[13] = a))
		: (a = e[13]);
	let l;
	return (
		e[14] !== n.href || e[15] !== s || e[16] !== a || e[17] !== o
			? ((l = m.jsxs(HH, {
					href: n.href,
					"aria-current": s,
					children: [a, o],
				})),
				(e[14] = n.href),
				(e[15] = s),
				(e[16] = a),
				(e[17] = o),
				(e[18] = l))
			: (l = e[18]),
		l
	);
}
const rJ = E.createContext({ containerWidth: "medium" }),
	cl = (t) => {
		const e = ee(7),
			{ children: n, containerWidth: r } = t,
			i = r === void 0 ? "medium" : r;
		let o;
		e[0] !== i
			? ((o = { containerWidth: i }), (e[0] = i), (e[1] = o))
			: (o = e[1]);
		let s;
		e[2] !== n
			? ((s = m.jsx(ke, {
					elementType: "main",
					direction: "column",
					id: V$e,
					flex: !0,
					height: "100%",
					minHeight: 0,
					minWidth: 0,
					children: n,
				})),
				(e[2] = n),
				(e[3] = s))
			: (s = e[3]);
		let a;
		return (
			e[4] !== o || e[5] !== s
				? ((a = m.jsx(rJ.Provider, { value: o, children: s })),
					(e[4] = o),
					(e[5] = s),
					(e[6] = a))
				: (a = e[6]),
			a
		);
	},
	yp = (t) => {
		const e = ee(17),
			{ children: n } = t,
			r = lA(),
			i = E.useRef(null),
			{ direction: o } = Vt();
		let s = r.isOpen ? r3e : n3e;
		o === "rtl" && (s = r.isOpen ? o3e : i3e);
		let a, l, u;
		e[0] === Symbol.for("react.memo_cache_sentinel")
			? ((a = { mobile: "small", tablet: "regular" }),
				(l = { mobile: "element.large", tablet: "element.xlarge" }),
				(u = {
					mobile: "medium",
					tablet: "xlarge",
					desktop: "xxlarge",
				}),
				(e[0] = a),
				(e[1] = l),
				(e[2] = u))
			: ((a = e[0]), (l = e[1]), (u = e[2]));
		let c;
		e[3] !== r.isOpen
			? ((c = r.isOpen ? { above: "tablet" } : void 0),
				(e[3] = r.isOpen),
				(e[4] = c))
			: (c = e[4]);
		let d;
		e[5] === Symbol.for("react.memo_cache_sentinel")
			? ((d = X({
					marginInlineStart: `calc(${B.size.space.regular} * -1)`,
				})),
				(e[5] = d))
			: (d = e[5]);
		let f;
		e[6] !== s
			? ((f = m.jsx(ve, { src: s })), (e[6] = s), (e[7] = f))
			: (f = e[7]);
		let h;
		e[8] !== r.isOpen ||
		e[9] !== r.toggle ||
		e[10] !== c ||
		e[11] !== i ||
		e[12] !== f
			? ((h = m.jsx(Re, {
					prominence: "low",
					"aria-label": "Open app navigation",
					"aria-pressed": r.isOpen,
					isHidden: c,
					onPress: r.toggle,
					ref: i,
					UNSAFE_className: d,
					children: f,
				})),
				(e[8] = r.isOpen),
				(e[9] = r.toggle),
				(e[10] = c),
				(e[11] = i),
				(e[12] = f),
				(e[13] = h))
			: (h = e[13]);
		let p;
		return (
			e[14] !== h || e[15] !== n
				? ((p = m.jsx(pr, {
						borderBottom: "muted",
						elementType: "header",
						flexShrink: 0,
						children: m.jsxs(ke, {
							alignItems: "center",
							gap: a,
							height: l,
							paddingX: u,
							children: [h, n],
						}),
					})),
					(e[14] = h),
					(e[15] = n),
					(e[16] = p))
				: (p = e[16]),
			p
		);
	},
	la = (t) => {
		const e = ee(5),
			{ children: n, isScrollable: r } = t,
			i = !r;
		let o;
		e[0] !== n
			? ((o = m.jsx(iJ, { paddingY: "xxlarge", children: n })),
				(e[0] = n),
				(e[1] = o))
			: (o = e[1]);
		let s;
		return (
			e[2] !== i || e[3] !== o
				? ((s = m.jsx(Ob, { isDisabled: i, children: o })),
					(e[2] = i),
					(e[3] = o),
					(e[4] = s))
				: (s = e[4]),
			s
		);
	},
	iJ = (t) => {
		const e = ee(4),
			{ containerWidth: n } = E.useContext(rJ),
			r = n === "none" ? void 0 : `container.${n}`;
		let i;
		e[0] === Symbol.for("react.memo_cache_sentinel")
			? ((i = { mobile: "medium", tablet: "xlarge", desktop: "xxlarge" }),
				(e[0] = i))
			: (i = e[0]);
		let o;
		return (
			e[1] !== r || e[2] !== t
				? ((o = m.jsx(pr, {
						minHeight: 0,
						minWidth: 0,
						maxWidth: r,
						paddingX: i,
						...t,
					})),
					(e[1] = r),
					(e[2] = t),
					(e[3] = o))
				: (o = e[3]),
			o
		);
	},
	Ly = 12,
	oJ = E.createContext(Ly),
	cTe = () => E.useContext(oJ),
	dTe = oJ.Provider;
function sJ(t, e, n) {
	var r, i;
	if (
		((r = t.validation) === null ||
		r === void 0 ||
		(r = r.length) === null ||
		r === void 0
			? void 0
			: r.min) !== void 0 &&
		e.length < t.validation.length.min
	)
		return new wu(
			new st(
				`Must have at least ${t.validation.length.min} element${t.validation.length.min === 1 ? "" : "s"}`,
			),
			n,
			t,
		);
	if (
		((i = t.validation) === null ||
		i === void 0 ||
		(i = i.length) === null ||
		i === void 0
			? void 0
			: i.max) !== void 0 &&
		e.length > t.validation.length.max
	)
		return new wu(
			new st(
				`Must have at most ${t.validation.length.max} element${t.validation.length.max === 1 ? "" : "s"}}`,
			),
			n,
			t,
		);
}
const Mb = new WeakMap();
let fTe = 0;
function Kr(t) {
	return (
		Mb.has(t) || Mb.set(t, Array.from({ length: t.length }, Md)), Mb.get(t)
	);
}
function sf(t, e) {
	Mb.set(t, e);
}
function Md() {
	return (fTe++).toString();
}
const an = hTe;
function hTe(t) {
	switch (t.kind) {
		case "form":
			return t.defaultValue();
		case "child":
			return t.options.kind === "block"
				? [{ type: "paragraph", children: [{ text: "" }] }]
				: null;
		case "conditional": {
			const e = t.discriminant.defaultValue();
			return { discriminant: e, value: an(t.values[e.toString()]) };
		}
		case "object": {
			const e = {};
			for (const n of Object.keys(t.fields)) e[n] = an(t.fields[n]);
			return e;
		}
		case "array":
			return [];
	}
	qn(t);
}
function ua(t, e) {
	switch (t.kind) {
		case "form":
			return e === void 0 ? t.defaultValue() : e;
		case "child":
			return (
				e ??
				(t.options.kind === "block"
					? [{ type: "paragraph", children: [{ text: "" }] }]
					: null)
			);
		case "conditional": {
			const n =
				e === void 0 ? t.discriminant.defaultValue() : e.discriminant;
			if (n === void 0) debugger;
			return {
				discriminant: n,
				value: ua(
					t.values[n.toString()],
					e === void 0 ? void 0 : e.value,
				),
			};
		}
		case "object": {
			const n = {};
			for (const r of Object.keys(t.fields))
				n[r] = ua(t.fields[r], e === void 0 ? void 0 : e[r]);
			return n;
		}
		case "array":
			return (e ?? []).map((n) => ua(t.element, n.value));
	}
	qn(t);
}
function vs(t, e, n) {
	if (n === void 0) return e;
	switch (t.kind) {
		case "form":
			return n;
		case "child":
			return n;
		case "conditional":
			return {
				discriminant: n.discriminant,
				value:
					n.discriminant === e.discriminant
						? vs(
								t.values[n.discriminant.toString()],
								e.value,
								n.value,
							)
						: ua(t.values[n.discriminant.toString()], n.value),
			};
		case "object": {
			const r = {};
			for (const i of Object.keys(t.fields))
				r[i] = vs(t.fields[i], e[i], n[i]);
			return r;
		}
		case "array": {
			const r = e,
				i = n,
				o = new Set();
			for (const c of i)
				if (c.key !== void 0) {
					if (o.has(c.key))
						throw new Error("Array elements must have unique keys");
					o.add(c.key);
				}
			const s = i.map((c) => {
					if (c.key !== void 0) return c.key;
					let d = Md();
					for (; o.has(d); ) d = Md();
					return o.add(d), d;
				}),
				a = Kr(r),
				l = new Map(r.map((c, d) => [a[d], c])),
				u = i.map((c, d) => {
					const f = s[d];
					return l.has(f)
						? vs(t.element, l.get(f), c.value)
						: ua(t.element, c.value);
				});
			return sf(u, s), u;
		}
	}
	qn(t);
}
class wu extends Error {
	constructor(e, n, r) {
		super(`field error at ${n.join(".")}`, { cause: e }),
			(this.path = n),
			(this.schema = r),
			(this.cause = e);
	}
}
function BF(t) {
	if (t !== null) return t;
}
const X1 = Array.isArray;
function jc(t, e, n, r, i, o) {
	let s = BF(e);
	if (t.kind === "form")
		try {
			return i(t, s, n, r);
		} catch (a) {
			throw new wu(a, n, t);
		}
	if (t.kind === "child") return null;
	if (t.kind === "conditional") {
		if (s === void 0) return an(t);
		try {
			if (
				typeof s != "object" ||
				s === null ||
				X1(s) ||
				s instanceof Date
			)
				throw new st("Must be an object");
			for (const l of Object.keys(s))
				if (l !== "discriminant" && l !== "value")
					throw new st(
						`Must only contain keys "discriminant" and "value", not "${l}"`,
					);
		} catch (l) {
			throw new wu(l, n, t);
		}
		const a = jc(
			t.discriminant,
			s.discriminant,
			n.concat("discriminant"),
			r.concat("discriminant"),
			i,
			o,
		);
		return {
			discriminant: a,
			value: jc(
				t.values[a],
				s.value,
				n.concat("value"),
				r.concat("value"),
				i,
				o,
			),
		};
	}
	if (t.kind === "object") {
		s === void 0 && (s = {});
		try {
			if (
				typeof s != "object" ||
				s === null ||
				X1(s) ||
				s instanceof Date
			)
				throw new st("Must be an object");
			const u = new Set(Object.keys(t.fields));
			for (const c of Object.keys(s))
				if (!u.has(c))
					throw new st(`Key on object value "${c}" is not allowed`);
		} catch (u) {
			throw new wu(u, n, t);
		}
		const a = {},
			l = [];
		for (const u of Object.keys(t.fields)) {
			let c = s[u];
			try {
				const d = jc(t.fields[u], c, n.concat(u), r.concat(u), i, o);
				a[u] = d;
			} catch (d) {
				l.push(d);
			}
		}
		if (l.length) throw new AggregateError(l);
		return a;
	}
	if (t.kind === "array") {
		if (s === void 0) return [];
		try {
			if (!X1(s)) throw new st("Must be an array");
		} catch (l) {
			throw new wu(l, n, t);
		}
		const a = [];
		try {
			if (o) {
				const l = sJ(t, s, n);
				l !== void 0 && a.push(l);
			}
			return s.map((l, u) => {
				try {
					let c = u.toString();
					if (
						t.slugField &&
						typeof l == "object" &&
						l !== null &&
						!X1(l) &&
						!(l instanceof Date)
					) {
						if (t.element.kind !== "object")
							throw new Error(
								"slugField on array fields requires the an object field element",
							);
						const d = t.element.fields[t.slugField];
						if (!d)
							throw new Error(
								`slugField "${t.slugField}" does not exist on object field`,
							);
						if (d.kind !== "form")
							throw new Error(
								`slugField "${t.slugField}" is not a form field`,
							);
						if (d.formKind !== "slug")
							throw new Error(
								`slugField "${t.slugField}" is not a slug field`,
							);
						let f;
						try {
							f = d.parse(BF(l[t.slugField]), void 0);
						} catch (h) {
							throw new AggregateError([h]);
						}
						c = d.serializeWithSlug(f).slug;
					}
					return jc(t.element, l, n.concat(u), r.concat(c), i, o);
				} catch (c) {
					a.push(c);
				}
			});
		} finally {
			if (a.length) throw new AggregateError(a);
		}
	}
	qn(t);
}
function aJ(t) {
	return t instanceof AggregateError ? t.errors.flatMap(aJ) : [t];
}
function lJ(t) {
	return aJ(t).map((n) =>
		n instanceof wu
			? `${n.path.join(".")}: ${n.cause instanceof st ? n.cause.message : `Unexpected error: ${n.cause}`}`
			: `Unexpected error: ${n}`,
	).join(`
`);
}
function uJ(t) {
	const e = lJ(t);
	return new Error(
		`Field validation failed:
` + e,
	);
}
function _s(t, e, n) {
	try {
		return jb(t, e, n), !0;
	} catch (r) {
		return console.warn(uJ(r)), !1;
	}
}
function jb(t, e, n, r = []) {
	switch (t.kind) {
		case "child":
			return;
		case "form": {
			try {
				if (n && r[r.length - 1] === (n == null ? void 0 : n.field)) {
					t.validate(e, {
						slugField: { slugs: n.slugs, glob: n.glob },
					});
					return;
				}
				t.validate(e, void 0);
			} catch (i) {
				throw new wu(i, r, t);
			}
			return;
		}
		case "conditional": {
			t.discriminant.validate(e.discriminant),
				jb(
					t.values[e.discriminant],
					e.value,
					void 0,
					r.concat("value"),
				);
			return;
		}
		case "object": {
			const i = [];
			for (const [o, s] of Object.entries(t.fields))
				try {
					jb(
						s,
						e[o],
						o === (n == null ? void 0 : n.field) ? n : void 0,
						r.concat(o),
					);
				} catch (a) {
					i.push(a);
				}
			if (i.length > 0) throw new AggregateError(i);
			return;
		}
		case "array": {
			let i;
			if (t.slugField !== void 0 && t.element.kind === "object") {
				const l = t.element.fields,
					{ slugField: u } = t;
				i = {
					slugField: u,
					slugs: e.map((c) => tr({ schema: l, slugField: u }, c)),
				};
			}
			const o = [],
				s = e,
				a = sJ(t, e, r);
			a !== void 0 && o.push(a);
			for (const [l, u] of s.entries())
				try {
					jb(
						t.element,
						u,
						i === void 0
							? void 0
							: {
									field: i.slugField,
									slugs: new Set(
										i.slugs.filter((c, d) => l !== d),
									),
									glob: "*",
								},
						r.concat(l),
					);
				} catch (c) {
					o.push(c);
				}
			if (o.length > 0) throw new AggregateError(o);
			return;
		}
	}
}
const pTe = Gm.below.tablet;
function mTe(t) {
	const e = ee(16),
		{
			field: n,
			fieldKey: r,
			span: i,
			forceValidation: o,
			firstFocusable: s,
			omitFieldAtPath: a,
		} = t,
		l = `span ${i}`;
	let u;
	e[0] !== l
		? ((u = X({ gridColumn: l, [pTe]: { gridColumn: `span ${Ly}` } })),
			(e[0] = l),
			(e[1] = u))
		: (u = e[1]);
	const c = r === s;
	let d;
	e[2] !== o || e[3] !== c || e[4] !== a || e[5] !== n
		? ((d = m.jsx(Uy, {
				forceValidation: o,
				autoFocus: c,
				omitFieldAtPath: a,
				...n,
			})),
			(e[2] = o),
			(e[3] = c),
			(e[4] = a),
			(e[5] = n),
			(e[6] = d))
		: (d = e[6]);
	let f;
	e[7] !== r || e[8] !== d
		? ((f = m.jsx(py, { part: r, children: d })),
			(e[7] = r),
			(e[8] = d),
			(e[9] = f))
		: (f = e[9]);
	let h;
	e[10] !== u || e[11] !== f
		? ((h = m.jsx("div", { className: u, children: f })),
			(e[10] = u),
			(e[11] = f),
			(e[12] = h))
		: (h = e[12]);
	let p;
	return (
		e[13] !== i || e[14] !== h
			? ((p = m.jsx(dTe, { value: i, children: h })),
				(e[13] = i),
				(e[14] = h),
				(e[15] = p))
			: (p = e[15]),
		p
	);
}
function gTe(t) {
	const e = ee(33),
		{
			schema: n,
			autoFocus: r,
			fields: i,
			forceValidation: o,
			omitFieldAtPath: s,
		} = t;
	bTe(n);
	let a;
	e[0] !== r || e[1] !== n
		? ((a = r ? vTe(n) : void 0), (e[0] = r), (e[1] = n), (e[2] = a))
		: (a = e[2]);
	const l = a;
	let u;
	e: {
		if (!s) {
			u = void 0;
			break e;
		}
		let w;
		e[3] !== s ? ((w = s.slice(1)), (e[3] = s), (e[4] = w)) : (w = e[4]),
			(u = w);
	}
	const c = u;
	let d;
	if (
		e[5] !== i ||
		e[6] !== n.layout ||
		e[7] !== o ||
		e[8] !== l ||
		e[9] !== s ||
		e[10] !== c
	) {
		let w;
		e[12] !== n.layout ||
		e[13] !== o ||
		e[14] !== l ||
		e[15] !== s ||
		e[16] !== c
			? ((w = (D, S) => {
					var $, A;
					const [T, I] = D,
						F =
							($ =
								(A = n.layout) === null || A === void 0
									? void 0
									: A[S]) !== null && $ !== void 0
								? $
								: Ly;
					return m.jsx(
						mTe,
						{
							span: F,
							field: I,
							fieldKey: T,
							forceValidation: o,
							firstFocusable: l,
							...((s == null ? void 0 : s[0]) === T
								? { omitFieldAtPath: c }
								: {}),
						},
						T,
					);
				}),
				(e[12] = n.layout),
				(e[13] = o),
				(e[14] = l),
				(e[15] = s),
				(e[16] = c),
				(e[17] = w))
			: (w = e[17]),
			(d = Object.entries(i).map(w)),
			(e[5] = i),
			(e[6] = n.layout),
			(e[7] = o),
			(e[8] = l),
			(e[9] = s),
			(e[10] = c),
			(e[11] = d);
	} else d = e[11];
	let f;
	e[18] !== d
		? ((f = m.jsx(gd, {
				columns: `repeat(${Ly}, minmax(auto, 1fr))`,
				columnGap: "medium",
				rowGap: "xlarge",
				children: d,
			})),
			(e[18] = d),
			(e[19] = f))
		: (f = e[19]);
	const h = f,
		p = E.useId();
	if (!n.label) return h;
	const g = `${p}-label`,
		v = `${p}-description`,
		b = n.description ? v : void 0;
	let y;
	e[20] !== g || e[21] !== n.label
		? ((y = m.jsx(ue, {
				color: "neutralEmphasis",
				size: "medium",
				weight: "semibold",
				id: g,
				children: n.label,
			})),
			(e[20] = g),
			(e[21] = n.label),
			(e[22] = y))
		: (y = e[22]);
	let x;
	e[23] !== n.description || e[24] !== v
		? ((x =
				!!n.description &&
				m.jsx(ue, {
					id: v,
					size: "regular",
					color: "neutralSecondary",
					children: n.description,
				})),
			(e[23] = n.description),
			(e[24] = v),
			(e[25] = x))
		: (x = e[25]);
	let C;
	e[26] === Symbol.for("react.memo_cache_sentinel")
		? ((C = m.jsx("div", {})), (e[26] = C))
		: (C = e[26]);
	let k;
	return (
		e[27] !== g || e[28] !== b || e[29] !== y || e[30] !== x || e[31] !== h
			? ((k = m.jsxs(gd, {
					role: "group",
					gap: "medium",
					marginY: "xlarge",
					"aria-labelledby": g,
					"aria-describedby": b,
					children: [y, x, C, h],
				})),
				(e[27] = g),
				(e[28] = b),
				(e[29] = y),
				(e[30] = x),
				(e[31] = h),
				(e[32] = k))
			: (k = e[32]),
		k
	);
}
function bTe(t) {
	t.layout &&
		(wt(
			t.layout.length === Object.keys(t.fields).length,
			'A column "span" is required for every field in the layout',
		),
		wt(
			t.layout.every((e) => e > 0),
			"The layout must not contain empty columns",
		),
		wt(
			t.layout.every((e) => e <= 12),
			"Fields may not span more than 12 columns",
		),
		wt(
			t.layout.reduce((e, n) => e + n, 0) % 12 === 0,
			"The layout must span exactly 12 columns",
		));
}
function vTe(t) {
	for (const [e, n] of Object.entries(t.fields)) if (cJ(n)) return e;
}
function cJ(t) {
	if (t.kind === "array" || t.kind === "conditional" || t.kind === "form")
		return !0;
	if (t.kind === "child") return !1;
	if (t.kind === "object") {
		for (const e of Object.values(t.fields)) if (cJ(e)) return !0;
		return !1;
	}
	qn(t);
}
function yTe(t) {
	const e = ee(18),
		{
			schema: n,
			autoFocus: r,
			discriminant: i,
			onChange: o,
			value: s,
			forceValidation: a,
			omitFieldAtPath: l,
		} = t,
		u = n.discriminant;
	let c;
	e: {
		if (!l) {
			c = void 0;
			break e;
		}
		let y;
		e[0] !== l ? ((y = l.slice(1)), (e[0] = l), (e[1] = y)) : (y = e[1]),
			(c = y);
	}
	const d = c;
	let f;
	const h = !!r;
	let p;
	e[2] !== u.Input || e[3] !== h || e[4] !== i || e[5] !== o || e[6] !== a
		? ((p = m.jsx(py, {
				part: "discriminant",
				children: m.jsx(u.Input, {
					autoFocus: h,
					value: i,
					onChange: o,
					forceValidation: a,
				}),
			})),
			(e[2] = u.Input),
			(e[3] = h),
			(e[4] = i),
			(e[5] = o),
			(e[6] = a),
			(e[7] = p))
		: (p = e[7]),
		(f = p);
	let g;
	e[8] !== l || e[9] !== d
		? ((g =
				(l == null ? void 0 : l[0]) === "value"
					? { omitFieldAtPath: d }
					: {}),
			(e[8] = l),
			(e[9] = d),
			(e[10] = g))
		: (g = e[10]);
	let v;
	e[11] !== a || e[12] !== s || e[13] !== g
		? ((v = m.jsx(py, {
				part: "value",
				children: m.jsx(Uy, { forceValidation: a, ...s, ...g }),
			})),
			(e[11] = a),
			(e[12] = s),
			(e[13] = g),
			(e[14] = v))
		: (v = e[14]);
	let b;
	return (
		e[15] !== f || e[16] !== v
			? ((b = m.jsxs(ke, {
					gap: "xlarge",
					direction: "column",
					children: [f, v],
				})),
				(e[15] = f),
				(e[16] = v),
				(e[17] = b))
			: (b = e[17]),
		b
	);
}
function xTe(t, e, n) {
	return t.has(e) || t.set(e, n(e)), t.get(e);
}
const dJ = new WeakMap();
function kTe(t) {
	let e = {};
	return dJ.set(e, t), e;
}
function uA(t) {
	const e = dJ.get(t._);
	if (!e) throw new Error("expected child field data to exist");
	return e;
}
function Ba(t, e, n) {
	const r = {
			form(u, c) {
				return (d) => c(() => d);
			},
			array(u, c) {
				return {
					rawOnChange: c,
					inner: new Map(),
					onChange(d) {
						c((f) => vs(u, f, d));
					},
				};
			},
			child(u, c) {
				return (d) => c(() => d);
			},
			conditional(u, c) {
				return {
					onChange: (d, f) =>
						c((h) => vs(u, h, { discriminant: d, value: f })),
					onChangeForValue: (d) =>
						c((f) => ({
							discriminant: f.discriminant,
							value: d(f.value),
						})),
				};
			},
			object(u, c) {
				return {
					onChange: (d) => {
						c((f) => vs(u, f, d));
					},
					innerOnChanges: Object.fromEntries(
						Object.keys(u.fields).map((d) => [
							d,
							(f) => {
								c((h) => ({ ...h, [d]: f(h[d]) }));
							},
						]),
					),
				};
			},
		},
		i = {
			form(u, c, d) {
				return { value: c, onChange: d, schema: u };
			},
			child(u, c, d, f) {
				return {
					element: n(f),
					schema: u,
					_: kTe({ value: c, onChange: d }),
				};
			},
			object(u, c, d, f, h) {
				const p = {};
				for (const v of Object.keys(u.fields))
					p[v] = h(u.fields[v], c[v], d.innerOnChanges[v], v);
				return { fields: p, onChange: d.onChange, schema: u };
			},
			array(u, c, d, f, h) {
				const p = c,
					g = Kr(p),
					v = new Set(Kr(c)),
					b = {
						elements: p.map((y, x) => {
							const C = g[x];
							v.delete(C);
							const k = xTe(d.inner, C, () => {
									const D = ($) => {
											d.rawOnChange((A) => {
												const T = Kr(A),
													I = T.indexOf(C),
													F = [...A];
												return (
													(F[I] = $(F[I])),
													sf(F, T),
													F
												);
											});
										},
										S = h(u.element, y, D, C);
									return {
										element: S,
										elementWithKey: { ...S, key: C },
										onChange: D,
									};
								}),
								w = h(u.element, y, k.onChange, C);
							return (
								k.element !== w &&
									((k.element = w),
									(k.elementWithKey = { ...w, key: C })),
								k.elementWithKey
							);
						}),
						schema: u,
						onChange: d.onChange,
					};
				for (const y of v) d.inner.delete(y);
				return b;
			},
			conditional(u, c, d, f, h) {
				return {
					discriminant: c.discriminant,
					onChange: d.onChange,
					value: h(
						u.values[c.discriminant.toString()],
						c.value,
						d.onChangeForValue,
						"value",
					),
					schema: u,
				};
			},
		};
	function o(u, c, d, f, h) {
		return i[u.kind](u, c, d, f, h);
	}
	function s(u, c, d, f) {
		const h = new Map(),
			p = r[u.kind](u, d);
		return {
			value: c,
			inner: h,
			props: o(u, c, p, f, (v, b, y, x) => {
				const C = s(v, b, y, f.concat(x));
				return h.set(x, C), C.props;
			}),
			schema: u,
			cached: p,
		};
	}
	function a(u, c, d, f, h) {
		if (f.schema !== u) return Object.assign(f, s(u, c, d, h)), f.props;
		if (f.value === c) return f.props;
		f.value = c;
		const p = new Set(f.inner.keys());
		f.props = o(u, c, f.cached, h, (g, v, b, y) => {
			if ((p.delete(y), !f.inner.has(y))) {
				const x = s(g, v, b, h.concat(y));
				return f.inner.set(y, x), x.props;
			}
			return a(g, v, b, f.inner.get(y), h.concat(y));
		});
		for (const g of p) f.inner.delete(g);
		return f.props;
	}
	let l;
	return (u) =>
		l === void 0 ? ((l = s(t, u, e, [])), l.props) : a(t, u, e, l, []);
}
const CTe = {
	child(t) {
		return uA(t).value;
	},
	form(t) {
		return t.value;
	},
	array(t) {
		const e = t.elements.map((n) => ch(n));
		return (
			sf(
				e,
				t.elements.map((n) => n.key),
			),
			e
		);
	},
	conditional(t) {
		return { discriminant: t.discriminant, value: ch(t.value) };
	},
	object(t) {
		return Object.fromEntries(
			Object.entries(t.fields).map(([e, n]) => [e, ch(n)]),
		);
	},
};
function ch(t) {
	return CTe[t.schema.kind](t);
}
const wTe = {
	child(t) {
		return t ?? void 0;
	},
	form(t) {
		return t;
	},
	array(t, e) {
		const n = Kr(t);
		return t.map((r, i) => ({ key: n[i], value: Pu(r, e.element) }));
	},
	conditional(t, e) {
		return {
			discriminant: t.discriminant,
			value: Pu(t.value, e.values[t.discriminant.toString()]),
		};
	},
	object(t, e) {
		return Object.fromEntries(
			Object.entries(e.fields).map(([n, r]) => [n, Pu(t[n], r)]),
		);
	},
};
function Pu(t, e) {
	return wTe[e.kind](t, e);
}
function jd(t, e) {
	if (_p(e, "child")) {
		const { onChange: n } = uA(e);
		n(t);
		return;
	}
	if (_p(e, "form") || _p(e, "object") || _p(e, "array")) {
		e.onChange(Pu(t, e.schema));
		return;
	}
	if (_p(e, "conditional")) {
		const n = Pu(t, e.schema);
		e.onChange(n.discriminant, n.value);
		return;
	}
	qn(e);
}
function _p(t, e) {
	return t.schema.kind === e;
}
function fJ(t, e, n) {
	n -= e.filter((o) => o < n).length;
	let r = e.map((o) => ({ from: o, to: n++ }));
	for (let o = 0; o < r.length; o++) {
		let s = r[o].from;
		for (let a = o; a < r.length; a++) r[a].from > s && r[a].from--;
	}
	for (let o = 0; o < r.length; o++) {
		let s = r[o];
		for (let a = r.length - 1; a > o; a--) {
			let l = r[a];
			l.from < s.to ? s.to++ : l.from++;
		}
	}
	let i = t.slice();
	for (let o of r) {
		let [s] = i.splice(o.from, 1);
		i.splice(o.to, 0, s);
	}
	return i;
}
function ETe(t) {
	var e, n;
	const r = ee(51),
		i =
			(e =
				(n = t.schema.validation) === null ||
				n === void 0 ||
				(n = n.length) === null ||
				n === void 0
					? void 0
					: n.min) !== null && e !== void 0
				? e
				: 0,
		o = E.useId(),
		s = Le(Ht),
		a = hJ(t),
		l = !!a;
	let u;
	r[0] !== t.schema.description ||
	r[1] !== t.schema.label ||
	r[2] !== a ||
	r[3] !== l
		? ((u = {
				description: t.schema.description,
				errorMessage: a,
				isInvalid: l,
				label: t.schema.label,
				labelElementType: "span",
			}),
			(r[0] = t.schema.description),
			(r[1] = t.schema.label),
			(r[2] = a),
			(r[3] = l),
			(r[4] = u))
		: (u = r[4]);
	const {
		descriptionProps: c,
		errorMessageProps: d,
		fieldProps: f,
		labelProps: h,
	} = Gd(u);
	let p;
	r[5] === Symbol.for("react.memo_cache_sentinel")
		? ((p = { state: "closed" }), (r[5] = p))
		: (p = r[5]);
	const [g, v] = E.useState(p),
		b = i > 0;
	let y;
	r[6] !== b || r[7] !== h || r[8] !== t.schema.label
		? ((y = m.jsx(qh, {
				elementType: "span",
				isRequired: b,
				supplementRequiredState: !0,
				...h,
				children: t.schema.label,
			})),
			(r[6] = b),
			(r[7] = h),
			(r[8] = t.schema.label),
			(r[9] = y))
		: (y = r[9]);
	let x;
	r[10] !== t.schema.description || r[11] !== c
		? ((x =
				t.schema.description &&
				m.jsx(ue, {
					size: "small",
					color: "neutralSecondary",
					...c,
					children: t.schema.description,
				})),
			(r[10] = t.schema.description),
			(r[11] = c),
			(r[12] = x))
		: (x = r[12]);
	let C;
	r[13] === Symbol.for("react.memo_cache_sentinel")
		? ((C = () => {
				v({ state: "new" });
			}),
			(r[13] = C))
		: (C = r[13]);
	let k;
	r[14] !== s
		? ((k = s.format("add")), (r[14] = s), (r[15] = k))
		: (k = r[15]);
	let w;
	r[16] !== t.autoFocus || r[17] !== k
		? ((w = m.jsx(Re, {
				autoFocus: t.autoFocus,
				onPress: C,
				alignSelf: "start",
				children: k,
			})),
			(r[16] = t.autoFocus),
			(r[17] = k),
			(r[18] = w))
		: (w = r[18]);
	let D;
	r[19] === Symbol.for("react.memo_cache_sentinel")
		? ((D = (N) => {
				v({ state: "edit", index: N });
			}),
			(r[19] = D))
		: (D = r[19]);
	let S;
	r[20] !== t
		? ((S = m.jsx(pJ, {
				...t,
				"aria-label": t.schema.label,
				onOpenItem: D,
			})),
			(r[20] = t),
			(r[21] = S))
		: (S = r[21]);
	let $;
	r[22] !== a || r[23] !== d
		? (($ = a && m.jsx(Gh, { ...d, children: a })),
			(r[22] = a),
			(r[23] = d),
			(r[24] = $))
		: ($ = r[24]);
	let A;
	r[25] === Symbol.for("react.memo_cache_sentinel")
		? ((A = () => {
				v({ state: "closed" });
			}),
			(r[25] = A))
		: (A = r[25]);
	let T;
	e: {
		if (t.schema.element.kind === "child") {
			T = void 0;
			break e;
		}
		if (g.state === "new") {
			let K;
			r[26] === Symbol.for("react.memo_cache_sentinel")
				? ((K = () => {
						v({ state: "closed" });
					}),
					(r[26] = K))
				: (K = r[26]);
			let M;
			r[27] !== o || r[28] !== t
				? ((M = m.jsx(DTe, { formId: o, onClose: K, previewProps: t })),
					(r[27] = o),
					(r[28] = t),
					(r[29] = M))
				: (M = r[29]),
				(T = M);
			break e;
		}
		if (g.state !== "edit") {
			T = void 0;
			break e;
		}
		let N;
		r[30] === Symbol.for("react.memo_cache_sentinel")
			? ((N = m.jsx(Ut, { children: "Edit item" })), (r[30] = N))
			: (N = r[30]);
		let O;
		r[31] === Symbol.for("react.memo_cache_sentinel")
			? ((O = () => {
					v({ state: "closed" });
				}),
				(r[31] = O))
			: (O = r[31]);
		let _;
		r[32] !== o || r[33] !== g.index || r[34] !== t
			? ((_ = m.jsx(STe, {
					formId: o,
					modalStateIndex: g.index,
					onClose: O,
					previewProps: t,
				})),
				(r[32] = o),
				(r[33] = g.index),
				(r[34] = t),
				(r[35] = _))
			: (_ = r[35]);
		let j;
		r[36] !== o
			? ((j = m.jsx(Nr, {
					children: m.jsx(vt, {
						form: o,
						prominence: "high",
						type: "submit",
						children: "Done",
					}),
				})),
				(r[36] = o),
				(r[37] = j))
			: (j = r[37]);
		let V;
		r[38] !== _ || r[39] !== j
			? ((V = m.jsxs(vr, { children: [N, _, j] })),
				(r[38] = _),
				(r[39] = j),
				(r[40] = V))
			: (V = r[40]),
			(T = V);
	}
	let I;
	r[41] !== T
		? ((I = m.jsx(mn, { onDismiss: A, children: T })),
			(r[41] = T),
			(r[42] = I))
		: (I = r[42]);
	let F;
	return (
		r[43] !== f ||
		r[44] !== y ||
		r[45] !== x ||
		r[46] !== w ||
		r[47] !== S ||
		r[48] !== $ ||
		r[49] !== I
			? ((F = m.jsxs(Hr, {
					gap: "medium",
					role: "group",
					minWidth: 0,
					...f,
					children: [y, x, w, S, $, I],
				})),
				(r[43] = f),
				(r[44] = y),
				(r[45] = x),
				(r[46] = w),
				(r[47] = S),
				(r[48] = $),
				(r[49] = I),
				(r[50] = F))
			: (F = r[50]),
		F
	);
}
function DTe(t) {
	const [e, n] = E.useState(!1),
		r = Le(Ht),
		i = E.useMemo(() => {
			if (
				t.previewProps.schema.slugField === void 0 ||
				t.previewProps.schema.element.kind !== "object"
			)
				return;
			const l = ch(t.previewProps),
				u = t.previewProps.schema.element.fields,
				c = t.previewProps.schema.slugField;
			return {
				slugs: new Set(
					l.map((f) => tr({ schema: u, slugField: c }, f)),
				),
				field: c,
				glob: "*",
			};
		}, [t.previewProps]),
		[o, s] = E.useState(() => an(t.previewProps.schema.element)),
		a = E.useMemo(
			() => Ba(t.previewProps.schema.element, s, () => {}),
			[t.previewProps.schema.element, s],
		)(o);
	return m.jsxs(vr, {
		children: [
			m.jsx(Ut, { children: "Add item" }),
			m.jsx(Pr, {
				children: m.jsx(Hr, {
					id: t.formId,
					elementType: "form",
					onSubmit: (l) => {
						if (l.target === l.currentTarget) {
							if (
								(l.preventDefault(),
								!_s(t.previewProps.schema.element, o, void 0))
							) {
								n(!0);
								return;
							}
							t.previewProps.onChange([
								...t.previewProps.elements.map((u) => ({
									key: u.key,
								})),
								{
									key: void 0,
									value: Pu(o, t.previewProps.schema.element),
								},
							]),
								t.onClose();
						}
					},
					gap: "xxlarge",
					children: m.jsx(Ia, {
						slugField: i,
						autoFocus: !0,
						...a,
						forceValidation: e,
					}),
				}),
			}),
			m.jsxs(Nr, {
				children: [
					m.jsx(vt, {
						onPress: () => {
							t.onClose();
						},
						children: r.format("cancel"),
					}),
					m.jsx(vt, {
						form: t.formId,
						prominence: "high",
						type: "submit",
						children: r.format("add"),
					}),
				],
			}),
		],
	});
}
function STe(t) {
	const e = ee(23);
	let n;
	e: {
		if (
			t.previewProps.schema.slugField === void 0 ||
			t.previewProps.schema.element.kind !== "object"
		) {
			n = void 0;
			break e;
		}
		const l = t.previewProps;
		let u, c;
		if (
			e[0] !== l ||
			e[1] !== t.previewProps.schema.element.fields ||
			e[2] !== t.previewProps.schema.slugField ||
			e[3] !== t.modalStateIndex
		) {
			const h = ch(l),
				p = t.previewProps.schema.element.fields;
			c = t.previewProps.schema.slugField;
			let g;
			e[6] !== t.modalStateIndex
				? ((g = (b, y) => y !== t.modalStateIndex),
					(e[6] = t.modalStateIndex),
					(e[7] = g))
				: (g = e[7]);
			let v;
			e[8] !== p || e[9] !== c
				? ((v = (b) => tr({ schema: p, slugField: c }, b)),
					(e[8] = p),
					(e[9] = c),
					(e[10] = v))
				: (v = e[10]),
				(u = new Set(h.filter(g).map(v))),
				(e[0] = l),
				(e[1] = t.previewProps.schema.element.fields),
				(e[2] = t.previewProps.schema.slugField),
				(e[3] = t.modalStateIndex),
				(e[4] = u),
				(e[5] = c);
		} else (u = e[4]), (c = e[5]);
		const d = u;
		let f;
		e[11] !== d || e[12] !== c
			? ((f = { slugs: d, field: c, glob: "*" }),
				(e[11] = d),
				(e[12] = c),
				(e[13] = f))
			: (f = e[13]),
			(n = f);
	}
	const r = n;
	let i;
	e[14] !== t
		? ((i = (l) => {
				l.target === l.currentTarget &&
					(l.preventDefault(), t.onClose());
			}),
			(e[14] = t),
			(e[15] = i))
		: (i = e[15]);
	const o = t.previewProps.elements[t.modalStateIndex];
	let s;
	e[16] !== r || e[17] !== o
		? ((s = m.jsx(Ia, { slugField: r, autoFocus: !0, ...o })),
			(e[16] = r),
			(e[17] = o),
			(e[18] = s))
		: (s = e[18]);
	let a;
	return (
		e[19] !== t.formId || e[20] !== i || e[21] !== s
			? ((a = m.jsx(Pr, {
					children: m.jsx(Hr, {
						id: t.formId,
						elementType: "form",
						onSubmit: i,
						gap: "xxlarge",
						children: s,
					}),
				})),
				(e[19] = t.formId),
				(e[20] = i),
				(e[21] = s),
				(e[22] = a))
			: (a = e[22]),
		a
	);
}
function hJ(t) {
	var e, n;
	const { elements: r, forceValidation: i, schema: o } = t,
		s =
			(e = o.validation) === null ||
			e === void 0 ||
			(e = e.length) === null ||
			e === void 0
				? void 0
				: e.min,
		a =
			(n = o.validation) === null ||
			n === void 0 ||
			(n = n.length) === null ||
			n === void 0
				? void 0
				: n.max;
	let l;
	e: {
		if (i) {
			if (s && r.length < s) {
				l = `Must have at least ${Od(s, { singular: "item" })}.`;
				break e;
			} else if (a && r.length > a) {
				l = `Must have at most ${Od(a, { singular: "item" })}.`;
				break e;
			}
		}
		l = void 0;
	}
	return l;
}
function pJ(t) {
	let e = (s, a) => {
		const l = t.elements.findIndex((f) => f.key === a.key);
		if (l === -1) return;
		const u = t.elements.map((f) => ({ key: f.key })),
			c = a.dropPosition === "before" ? l : l + 1,
			d = s.map((f) => u.findIndex((h) => h.key === f));
		t.onChange(fJ(u, d, c));
	};
	const n = E.useMemo(() => Math.random().toString(36), []);
	let { dragAndDropHooks: r } = TM({
		getItems(s) {
			return [...s].map(
				(a) => ((a = JSON.stringify(a)), { [n]: a, "text/plain": a }),
			);
		},
		getAllowedDropOperations() {
			return ["move", "cancel"];
		},
		async onDrop(s) {
			if (s.target.type !== "root" && s.target.dropPosition !== "on") {
				let a = [];
				for (let l of s.items)
					if (l.kind === "text") {
						let u;
						l.types.has(n)
							? ((u = JSON.parse(await l.getText(n))), a.push(u))
							: l.types.has("text/plain") &&
								((u = await l.getText("text/plain")),
								(a = u
									.split(
										`
`,
									)
									.map((c) => c.replaceAll('"', ""))));
					}
				e(a, s.target);
			}
		},
		getDropOperation(s) {
			return s.type === "root" || s.dropPosition === "on"
				? "cancel"
				: "move";
		},
	});
	const i = Ri((s) => {
			t.onChange(
				t.elements
					.map((a) => ({ key: a.key }))
					.filter((a) => a.key !== s),
			);
		}),
		o = Le(Ht);
	return m.jsx(RH, {
		"aria-label": t["aria-label"],
		items: t.elements,
		dragAndDropHooks: r,
		height: t.elements.length ? void 0 : "scale.2000",
		selectionMode: "none",
		renderEmptyState: ATe,
		onAction: (s) => {
			const a = t.elements.findIndex((l) => l.key === s);
			a !== -1 && t.onOpenItem(a);
		},
		children: (s) => {
			var a, l;
			const u =
				((a = (l = t.schema).itemLabel) === null || a === void 0
					? void 0
					: a.call(l, s)) || `Item ${t.elements.indexOf(s) + 1}`;
			return m.jsxs(
				Mt,
				{
					textValue: u,
					children: [
						m.jsx(ue, { children: u }),
						m.jsxs(Ze, {
							placement: "start",
							children: [
								m.jsx(Re, {
									onPress: () => {
										i(s.key);
									},
									children: m.jsx(ve, { src: Wr }),
								}),
								m.jsx(Xe, { children: o.format("delete") }),
							],
						}),
					],
				},
				s.key,
			);
		},
	});
}
function ATe() {
	return m.jsxs(Hr, {
		gap: "large",
		alignItems: "center",
		justifyContent: "center",
		height: "100%",
		padding: "regular",
		children: [
			m.jsx(ue, {
				elementType: "h3",
				align: "center",
				color: "neutralSecondary",
				size: "large",
				weight: "medium",
				children: "Empty list",
			}),
			m.jsx(ue, {
				align: "center",
				color: "neutralTertiary",
				children: "Add the first item to see it here.",
			}),
		],
	});
}
const $Te = (t) => t === "ordered-list" || t === "unordered-list",
	el = (t) => $Te(t.type);
function TTe(t) {
	if (t.selection) {
		const e = R.above(t, { match: mr("list-item") }),
			n = R.above(t, { match: el });
		if (e && n) return { isInside: !0, listItem: e, list: n };
	}
	return { isInside: !1 };
}
function BTe(t) {
	const { insertBreak: e, normalizeNode: n, deleteBackward: r } = t;
	return (
		(t.deleteBackward = (i) => {
			if (t.selection) {
				const o = TTe(t);
				if (
					o.isInside &&
					ie.isCollapsed(t.selection) &&
					R.isStart(t, t.selection.anchor, o.list[1])
				) {
					W.unwrapNodes(t, { match: el, split: !0 });
					return;
				}
			}
			r(i);
		}),
		(t.insertBreak = () => {
			const [i] = R.nodes(t, {
				match: (o) => o.type === "list-item",
				mode: "lowest",
			});
			if (i && pe.string(i[0]) === "") {
				W.unwrapNodes(t, { match: el, split: !0 });
				return;
			}
			e();
		}),
		(t.normalizeNode = (i) => {
			const [o, s] = i;
			if ($e.isElement(o) || R.isEditor(o)) {
				const l = el(o);
				for (const [u, c] of pe.children(t, s)) {
					const d = c[c.length - 1];
					if (el(u)) {
						var a;
						if (
							((a = o.children[c[c.length - 1] + 1]) === null ||
							a === void 0
								? void 0
								: a.type) === u.type
						) {
							const f = Y.next(c);
							Dg(t, f, [...c, u.children.length]),
								W.removeNodes(t, { at: f });
							return;
						}
						if (l) {
							const f = o.children[d - 1];
							$e.isElement(f)
								? W.moveNodes(t, {
										at: c,
										to: [
											...Y.previous(c),
											f.children.length - 1,
										],
									})
								: W.unwrapNodes(t, { at: c });
							return;
						}
					}
					if (
						o.type === "list-item" &&
						u.type !== "list-item-content" &&
						d === 0 &&
						Lt(u)
					) {
						if (s[s.length - 1] !== 0) {
							const f = pe.get(t, Y.previous(s));
							if ($e.isElement(f)) {
								W.moveNodes(t, {
									at: s,
									to: [...Y.previous(s), f.children.length],
								});
								return;
							}
						}
						W.unwrapNodes(t, { at: c });
						return;
					}
					if (
						o.type === "list-item" &&
						u.type === "list-item-content" &&
						d !== 0
					) {
						W.splitNodes(t, { at: c });
						return;
					}
				}
			}
			n(i);
		}),
		t
	);
}
const mJ = le.createContext(null);
function zs() {
	const t = E.useContext(mJ);
	if (!t)
		throw new Error(
			"ToolbarStateProvider must be used to use useToolbarState",
		);
	return t;
}
const ITe = (t, e, n) => {
	const r = z0(t, n, e) || {
		kind: "block",
		inlineMarks: "inherit",
		documentFeatures: {
			dividers: !0,
			formatting: {
				alignment: { center: !0, end: !0 },
				blockTypes: {
					blockquote: !0,
					code: n.formatting.blockTypes.code,
				},
				headings: n.formatting.headings,
				listTypes: { ordered: !0, unordered: !0 },
			},
			layouts: n.layouts,
			links: !0,
			images: n.images,
			tables: !0,
		},
		softBreaks: !0,
		componentBlocks: !0,
	};
	let [i] = R.nodes(t, { match: (d) => d.type !== "code" && Lt(d) });
	const o = R.marks(t) || {},
		s = Object.fromEntries(
			xH.map((d) => [
				d,
				{
					isDisabled:
						(r.inlineMarks !== "inherit" && !r.inlineMarks[d]) ||
						!i,
					isSelected: !!o[d],
				},
			]),
		);
	if (t.selection && ie.isExpanded(t.selection))
		for (const d of R.nodes(t, { match: Be.isText }))
			for (const f of Object.keys(d[0]))
				f === "insertMenu" ||
					f === "text" ||
					(f in s && (s[f].isSelected = !0));
	let [a] = R.nodes(t, { match: mr("heading") }),
		[l] = R.nodes(t, { match: el }),
		[u] = R.nodes(t, { match: mr("paragraph", "heading") });
	const c = gJ(t);
	return {
		marks: s,
		textStyles: {
			selected: a ? a[0].level : "normal",
			allowedHeadingLevels:
				r.kind === "block" && !l
					? r.documentFeatures.formatting.headings.levels
					: [],
		},
		code: {
			isSelected: Xs(t, "code"),
			isDisabled: !(
				r.kind === "block" &&
				r.documentFeatures.formatting.blockTypes.code
			),
		},
		lists: {
			ordered: {
				isSelected:
					Xs(t, "ordered-list") &&
					(c === "none" || c === "ordered-list"),
				isDisabled: !(
					r.kind === "block" &&
					r.documentFeatures.formatting.listTypes.ordered &&
					!a
				),
			},
			unordered: {
				isSelected:
					Xs(t, "unordered-list") &&
					(c === "none" || c === "unordered-list"),
				isDisabled: !(
					r.kind === "block" &&
					r.documentFeatures.formatting.listTypes.unordered &&
					!a
				),
			},
		},
		alignment: {
			isDisabled:
				!u &&
				!(
					r.kind === "block" &&
					r.documentFeatures.formatting.alignment
				),
			selected: (u == null ? void 0 : u[0].textAlign) || "start",
		},
		blockquote: {
			isDisabled: !(
				r.kind === "block" &&
				r.documentFeatures.formatting.blockTypes.blockquote
			),
			isSelected: Xs(t, "blockquote"),
		},
		layouts: { isSelected: Xs(t, "layout") },
		links: {
			isDisabled:
				!t.selection ||
				ie.isCollapsed(t.selection) ||
				!r.documentFeatures.links,
			isSelected: Xs(t, "link"),
		},
		editor: t,
		dividers: {
			isDisabled: r.kind === "inline" || !r.documentFeatures.dividers,
		},
		clearFormatting: {
			isDisabled: !(Object.values(s).some((d) => d.isSelected) || FTe(t)),
		},
		editorDocumentFeatures: n,
	};
};
function FTe(t) {
	const [e] = R.nodes(t, {
		match: (n) =>
			n.type === "heading" ||
			n.type === "code" ||
			n.type === "blockquote",
	});
	return !!e;
}
function gJ(t) {
	const e = R.above(t, { match: el });
	return e ? e[0].type : "none";
}
const bJ = E.createContext(null);
function Ls() {
	const t = E.useContext(bJ);
	if (!t)
		throw new Error(
			"useDocumentEditorConfig must be used within a DocumentEditorConfigContext.Provider",
		);
	return t;
}
const PTe = (t) => {
	const e = ee(13),
		{ children: n, componentBlocks: r, editorDocumentFeatures: i } = t,
		o = Gx();
	let s, a;
	e[0] !== r || e[1] !== i
		? ((a = { componentBlocks: r, documentFeatures: i }),
			(e[0] = r),
			(e[1] = i),
			(e[2] = a))
		: (a = e[2]),
		(s = a);
	let l;
	e[3] !== o || e[4] !== r || e[5] !== i
		? ((l = ITe(o, r, i)), (e[3] = o), (e[4] = r), (e[5] = i), (e[6] = l))
		: (l = e[6]);
	let u;
	e[7] !== l || e[8] !== n
		? ((u = m.jsx(mJ.Provider, { value: l, children: n })),
			(e[7] = l),
			(e[8] = n),
			(e[9] = u))
		: (u = e[9]);
	let c;
	return (
		e[10] !== s || e[11] !== u
			? ((c = m.jsx(bJ.Provider, { value: s, children: u })),
				(e[10] = s),
				(e[11] = u),
				(e[12] = c))
			: (c = e[12]),
		c
	);
};
globalThis.Prism = { manual: !0 };
var NTe = globalThis;
/**
 * Prism: Lightweight, robust, elegant syntax highlighting
 *
 * @license MIT <https://opensource.org/licenses/MIT>
 * @author Lea Verou <https://lea.verou.me>
 * @namespace
 * @public
 */ var Q = (function (t) {
	var e = /(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i,
		n = 0,
		r = {},
		i = {
			manual: t.Prism && t.Prism.manual,
			disableWorkerMessageHandler:
				t.Prism && t.Prism.disableWorkerMessageHandler,
			util: {
				encode: function g(v) {
					return v instanceof o
						? new o(v.type, g(v.content), v.alias)
						: Array.isArray(v)
							? v.map(g)
							: v
									.replace(/&/g, "&amp;")
									.replace(/</g, "&lt;")
									.replace(/\u00a0/g, " ");
				},
				type: function (g) {
					return Object.prototype.toString.call(g).slice(8, -1);
				},
				objId: function (g) {
					return (
						g.__id ||
							Object.defineProperty(g, "__id", { value: ++n }),
						g.__id
					);
				},
				clone: function g(v, b) {
					b = b || {};
					var y, x;
					switch (i.util.type(v)) {
						case "Object":
							if (((x = i.util.objId(v)), b[x])) return b[x];
							(y = {}), (b[x] = y);
							for (var C in v)
								v.hasOwnProperty(C) && (y[C] = g(v[C], b));
							return y;
						case "Array":
							return (
								(x = i.util.objId(v)),
								b[x]
									? b[x]
									: ((y = []),
										(b[x] = y),
										v.forEach(function (k, w) {
											y[w] = g(k, b);
										}),
										y)
							);
						default:
							return v;
					}
				},
				getLanguage: function (g) {
					for (; g; ) {
						var v = e.exec(g.className);
						if (v) return v[1].toLowerCase();
						g = g.parentElement;
					}
					return "none";
				},
				setLanguage: function (g, v) {
					(g.className = g.className.replace(RegExp(e, "gi"), "")),
						g.classList.add("language-" + v);
				},
				currentScript: function () {
					if (typeof document > "u") return null;
					if ("currentScript" in document)
						return document.currentScript;
					try {
						throw new Error();
					} catch (y) {
						var g = (/at [^(\r\n]*\((.*):[^:]+:[^:]+\)$/i.exec(
							y.stack,
						) || [])[1];
						if (g) {
							var v = document.getElementsByTagName("script");
							for (var b in v) if (v[b].src == g) return v[b];
						}
						return null;
					}
				},
				isActive: function (g, v, b) {
					for (var y = "no-" + v; g; ) {
						var x = g.classList;
						if (x.contains(v)) return !0;
						if (x.contains(y)) return !1;
						g = g.parentElement;
					}
					return !!b;
				},
			},
			languages: {
				plain: r,
				plaintext: r,
				text: r,
				txt: r,
				extend: function (g, v) {
					var b = i.util.clone(i.languages[g]);
					for (var y in v) b[y] = v[y];
					return b;
				},
				insertBefore: function (g, v, b, y) {
					y = y || i.languages;
					var x = y[g],
						C = {};
					for (var k in x)
						if (x.hasOwnProperty(k)) {
							if (k == v)
								for (var w in b)
									b.hasOwnProperty(w) && (C[w] = b[w]);
							b.hasOwnProperty(k) || (C[k] = x[k]);
						}
					var D = y[g];
					return (
						(y[g] = C),
						i.languages.DFS(i.languages, function (S, $) {
							$ === D && S != g && (this[S] = C);
						}),
						C
					);
				},
				DFS: function g(v, b, y, x) {
					x = x || {};
					var C = i.util.objId;
					for (var k in v)
						if (v.hasOwnProperty(k)) {
							b.call(v, k, v[k], y || k);
							var w = v[k],
								D = i.util.type(w);
							D === "Object" && !x[C(w)]
								? ((x[C(w)] = !0), g(w, b, null, x))
								: D === "Array" &&
									!x[C(w)] &&
									((x[C(w)] = !0), g(w, b, k, x));
						}
				},
			},
			plugins: {},
			highlightAll: function (g, v) {
				i.highlightAllUnder(document, g, v);
			},
			highlightAllUnder: function (g, v, b) {
				var y = {
					callback: b,
					container: g,
					selector:
						'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code',
				};
				i.hooks.run("before-highlightall", y),
					(y.elements = Array.prototype.slice.apply(
						y.container.querySelectorAll(y.selector),
					)),
					i.hooks.run("before-all-elements-highlight", y);
				for (var x = 0, C; (C = y.elements[x++]); )
					i.highlightElement(C, v === !0, y.callback);
			},
			highlightElement: function (g, v, b) {
				var y = i.util.getLanguage(g),
					x = i.languages[y];
				i.util.setLanguage(g, y);
				var C = g.parentElement;
				C &&
					C.nodeName.toLowerCase() === "pre" &&
					i.util.setLanguage(C, y);
				var k = g.textContent,
					w = { element: g, language: y, grammar: x, code: k };
				function D($) {
					(w.highlightedCode = $),
						i.hooks.run("before-insert", w),
						(w.element.innerHTML = w.highlightedCode),
						i.hooks.run("after-highlight", w),
						i.hooks.run("complete", w),
						b && b.call(w.element);
				}
				if (
					(i.hooks.run("before-sanity-check", w),
					(C = w.element.parentElement),
					C &&
						C.nodeName.toLowerCase() === "pre" &&
						!C.hasAttribute("tabindex") &&
						C.setAttribute("tabindex", "0"),
					!w.code)
				) {
					i.hooks.run("complete", w), b && b.call(w.element);
					return;
				}
				if ((i.hooks.run("before-highlight", w), !w.grammar)) {
					D(i.util.encode(w.code));
					return;
				}
				if (v && t.Worker) {
					var S = new Worker(i.filename);
					(S.onmessage = function ($) {
						D($.data);
					}),
						S.postMessage(
							JSON.stringify({
								language: w.language,
								code: w.code,
								immediateClose: !0,
							}),
						);
				} else D(i.highlight(w.code, w.grammar, w.language));
			},
			highlight: function (g, v, b) {
				var y = { code: g, grammar: v, language: b };
				if ((i.hooks.run("before-tokenize", y), !y.grammar))
					throw new Error(
						'The language "' + y.language + '" has no grammar.',
					);
				return (
					(y.tokens = i.tokenize(y.code, y.grammar)),
					i.hooks.run("after-tokenize", y),
					o.stringify(i.util.encode(y.tokens), y.language)
				);
			},
			tokenize: function (g, v) {
				var b = v.rest;
				if (b) {
					for (var y in b) v[y] = b[y];
					delete v.rest;
				}
				var x = new l();
				return u(x, x.head, g), a(g, x, v, x.head, 0), d(x);
			},
			hooks: {
				all: {},
				add: function (g, v) {
					var b = i.hooks.all;
					(b[g] = b[g] || []), b[g].push(v);
				},
				run: function (g, v) {
					var b = i.hooks.all[g];
					if (!(!b || !b.length))
						for (var y = 0, x; (x = b[y++]); ) x(v);
				},
			},
			Token: o,
		};
	t.Prism = i;
	function o(g, v, b, y) {
		(this.type = g),
			(this.content = v),
			(this.alias = b),
			(this.length = (y || "").length | 0);
	}
	o.stringify = function g(v, b) {
		if (typeof v == "string") return v;
		if (Array.isArray(v)) {
			var y = "";
			return (
				v.forEach(function (D) {
					y += g(D, b);
				}),
				y
			);
		}
		var x = {
				type: v.type,
				content: g(v.content, b),
				tag: "span",
				classes: ["token", v.type],
				attributes: {},
				language: b,
			},
			C = v.alias;
		C &&
			(Array.isArray(C)
				? Array.prototype.push.apply(x.classes, C)
				: x.classes.push(C)),
			i.hooks.run("wrap", x);
		var k = "";
		for (var w in x.attributes)
			k +=
				" " +
				w +
				'="' +
				(x.attributes[w] || "").replace(/"/g, "&quot;") +
				'"';
		return (
			"<" +
			x.tag +
			' class="' +
			x.classes.join(" ") +
			'"' +
			k +
			">" +
			x.content +
			"</" +
			x.tag +
			">"
		);
	};
	function s(g, v, b, y) {
		g.lastIndex = v;
		var x = g.exec(b);
		if (x && y && x[1]) {
			var C = x[1].length;
			(x.index += C), (x[0] = x[0].slice(C));
		}
		return x;
	}
	function a(g, v, b, y, x, C) {
		for (var k in b)
			if (!(!b.hasOwnProperty(k) || !b[k])) {
				var w = b[k];
				w = Array.isArray(w) ? w : [w];
				for (var D = 0; D < w.length; ++D) {
					if (C && C.cause == k + "," + D) return;
					var S = w[D],
						$ = S.inside,
						A = !!S.lookbehind,
						T = !!S.greedy,
						I = S.alias;
					if (T && !S.pattern.global) {
						var F = S.pattern.toString().match(/[imsuy]*$/)[0];
						S.pattern = RegExp(S.pattern.source, F + "g");
					}
					for (
						var N = S.pattern || S, O = y.next, _ = x;
						O !== v.tail && !(C && _ >= C.reach);
						_ += O.value.length, O = O.next
					) {
						var j = O.value;
						if (v.length > g.length) return;
						if (!(j instanceof o)) {
							var V = 1,
								K;
							if (T) {
								if (
									((K = s(N, _, g, A)),
									!K || K.index >= g.length)
								)
									break;
								var P = K.index,
									M = K.index + K[0].length,
									G = _;
								for (G += O.value.length; P >= G; )
									(O = O.next), (G += O.value.length);
								if (
									((G -= O.value.length),
									(_ = G),
									O.value instanceof o)
								)
									continue;
								for (
									var H = O;
									H !== v.tail &&
									(G < M || typeof H.value == "string");
									H = H.next
								)
									V++, (G += H.value.length);
								V--, (j = g.slice(_, G)), (K.index -= _);
							} else if (((K = s(N, 0, j, A)), !K)) continue;
							var P = K.index,
								q = K[0],
								J = j.slice(0, P),
								Z = j.slice(P + q.length),
								oe = _ + j.length;
							C && oe > C.reach && (C.reach = oe);
							var ne = O.prev;
							J && ((ne = u(v, ne, J)), (_ += J.length)),
								c(v, ne, V);
							var de = new o(k, $ ? i.tokenize(q, $) : q, I, q);
							if (((O = u(v, ne, de)), Z && u(v, O, Z), V > 1)) {
								var se = { cause: k + "," + D, reach: oe };
								a(g, v, b, O.prev, _, se),
									C &&
										se.reach > C.reach &&
										(C.reach = se.reach);
							}
						}
					}
				}
			}
	}
	function l() {
		var g = { value: null, prev: null, next: null },
			v = { value: null, prev: g, next: null };
		(g.next = v), (this.head = g), (this.tail = v), (this.length = 0);
	}
	function u(g, v, b) {
		var y = v.next,
			x = { value: b, prev: v, next: y };
		return (v.next = x), (y.prev = x), g.length++, x;
	}
	function c(g, v, b) {
		for (var y = v.next, x = 0; x < b && y !== g.tail; x++) y = y.next;
		(v.next = y), (y.prev = v), (g.length -= x);
	}
	function d(g) {
		for (var v = [], b = g.head.next; b !== g.tail; )
			v.push(b.value), (b = b.next);
		return v;
	}
	if (!t.document)
		return (
			t.addEventListener &&
				(i.disableWorkerMessageHandler ||
					t.addEventListener(
						"message",
						function (g) {
							var v = JSON.parse(g.data),
								b = v.language,
								y = v.code,
								x = v.immediateClose;
							t.postMessage(i.highlight(y, i.languages[b], b)),
								x && t.close();
						},
						!1,
					)),
			i
		);
	var f = i.util.currentScript();
	f &&
		((i.filename = f.src),
		f.hasAttribute("data-manual") && (i.manual = !0));
	function h() {
		i.manual || i.highlightAll();
	}
	if (!i.manual) {
		var p = document.readyState;
		p === "loading" || (p === "interactive" && f && f.defer)
			? document.addEventListener("DOMContentLoaded", h)
			: window.requestAnimationFrame
				? window.requestAnimationFrame(h)
				: window.setTimeout(h, 16);
	}
	return i;
})(NTe);
Q.languages.markup = {
	comment: { pattern: /<!--(?:(?!<!--)[\s\S])*?-->/, greedy: !0 },
	prolog: { pattern: /<\?[\s\S]+?\?>/, greedy: !0 },
	doctype: {
		pattern:
			/<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
		greedy: !0,
		inside: {
			"internal-subset": {
				pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
				lookbehind: !0,
				greedy: !0,
				inside: null,
			},
			string: { pattern: /"[^"]*"|'[^']*'/, greedy: !0 },
			punctuation: /^<!|>$|[[\]]/,
			"doctype-tag": /^DOCTYPE/i,
			name: /[^\s<>'"]+/,
		},
	},
	cdata: { pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i, greedy: !0 },
	tag: {
		pattern:
			/<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
		greedy: !0,
		inside: {
			tag: {
				pattern: /^<\/?[^\s>\/]+/,
				inside: { punctuation: /^<\/?/, namespace: /^[^\s>\/:]+:/ },
			},
			"special-attr": [],
			"attr-value": {
				pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
				inside: {
					punctuation: [
						{ pattern: /^=/, alias: "attr-equals" },
						{ pattern: /^(\s*)["']|["']$/, lookbehind: !0 },
					],
				},
			},
			punctuation: /\/?>/,
			"attr-name": {
				pattern: /[^\s>\/]+/,
				inside: { namespace: /^[^\s>\/:]+:/ },
			},
		},
	},
	entity: [
		{ pattern: /&[\da-z]{1,8};/i, alias: "named-entity" },
		/&#x?[\da-f]{1,8};/i,
	],
};
Q.languages.markup.tag.inside["attr-value"].inside.entity =
	Q.languages.markup.entity;
Q.languages.markup.doctype.inside["internal-subset"].inside =
	Q.languages.markup;
Q.hooks.add("wrap", function (t) {
	t.type === "entity" &&
		(t.attributes.title = t.content.replace(/&amp;/, "&"));
});
Object.defineProperty(Q.languages.markup.tag, "addInlined", {
	value: function (e, n) {
		var r = {};
		(r["language-" + n] = {
			pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
			lookbehind: !0,
			inside: Q.languages[n],
		}),
			(r.cdata = /^<!\[CDATA\[|\]\]>$/i);
		var i = {
			"included-cdata": {
				pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
				inside: r,
			},
		};
		i["language-" + n] = { pattern: /[\s\S]+/, inside: Q.languages[n] };
		var o = {};
		(o[e] = {
			pattern: RegExp(
				/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(
					/__/g,
					function () {
						return e;
					},
				),
				"i",
			),
			lookbehind: !0,
			greedy: !0,
			inside: i,
		}),
			Q.languages.insertBefore("markup", "cdata", o);
	},
});
Object.defineProperty(Q.languages.markup.tag, "addAttribute", {
	value: function (t, e) {
		Q.languages.markup.tag.inside["special-attr"].push({
			pattern: RegExp(
				/(^|["'\s])/.source +
					"(?:" +
					t +
					")" +
					/\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source,
				"i",
			),
			lookbehind: !0,
			inside: {
				"attr-name": /^[^\s=]+/,
				"attr-value": {
					pattern: /=[\s\S]+/,
					inside: {
						value: {
							pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
							lookbehind: !0,
							alias: [e, "language-" + e],
							inside: Q.languages[e],
						},
						punctuation: [
							{ pattern: /^=/, alias: "attr-equals" },
							/"|'/,
						],
					},
				},
			},
		});
	},
});
Q.languages.html = Q.languages.markup;
Q.languages.mathml = Q.languages.markup;
Q.languages.svg = Q.languages.markup;
Q.languages.xml = Q.languages.extend("markup", {});
Q.languages.ssml = Q.languages.xml;
Q.languages.atom = Q.languages.xml;
Q.languages.rss = Q.languages.xml;
(function (t) {
	var e =
		/(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
	(t.languages.css = {
		comment: /\/\*[\s\S]*?\*\//,
		atrule: {
			pattern: RegExp(
				"@[\\w-](?:" +
					/[^;{\s"']|\s+(?!\s)/.source +
					"|" +
					e.source +
					")*?" +
					/(?:;|(?=\s*\{))/.source,
			),
			inside: {
				rule: /^@[\w-]+/,
				"selector-function-argument": {
					pattern:
						/(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
					lookbehind: !0,
					alias: "selector",
				},
				keyword: {
					pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
					lookbehind: !0,
				},
			},
		},
		url: {
			pattern: RegExp(
				"\\burl\\((?:" +
					e.source +
					"|" +
					/(?:[^\\\r\n()"']|\\[\s\S])*/.source +
					")\\)",
				"i",
			),
			greedy: !0,
			inside: {
				function: /^url/i,
				punctuation: /^\(|\)$/,
				string: { pattern: RegExp("^" + e.source + "$"), alias: "url" },
			},
		},
		selector: {
			pattern: RegExp(
				`(^|[{}\\s])[^{}\\s](?:[^{};"'\\s]|\\s+(?![\\s{])|` +
					e.source +
					")*(?=\\s*\\{)",
			),
			lookbehind: !0,
		},
		string: { pattern: e, greedy: !0 },
		property: {
			pattern:
				/(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
			lookbehind: !0,
		},
		important: /!important\b/i,
		function: {
			pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
			lookbehind: !0,
		},
		punctuation: /[(){};:,]/,
	}),
		(t.languages.css.atrule.inside.rest = t.languages.css);
	var n = t.languages.markup;
	n && (n.tag.addInlined("style", "css"), n.tag.addAttribute("style", "css"));
})(Q);
Q.languages.clike = {
	comment: [
		{
			pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
			lookbehind: !0,
			greedy: !0,
		},
		{ pattern: /(^|[^\\:])\/\/.*/, lookbehind: !0, greedy: !0 },
	],
	string: {
		pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
		greedy: !0,
	},
	"class-name": {
		pattern:
			/(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
		lookbehind: !0,
		inside: { punctuation: /[.\\]/ },
	},
	keyword:
		/\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
	boolean: /\b(?:false|true)\b/,
	function: /\b\w+(?=\()/,
	number: /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
	operator: /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
	punctuation: /[{}[\];(),.:]/,
};
Q.languages.javascript = Q.languages.extend("clike", {
	"class-name": [
		Q.languages.clike["class-name"],
		{
			pattern:
				/(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
			lookbehind: !0,
		},
	],
	keyword: [
		{ pattern: /((?:^|\})\s*)catch\b/, lookbehind: !0 },
		{
			pattern:
				/(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
			lookbehind: !0,
		},
	],
	function:
		/#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
	number: {
		pattern: RegExp(
			/(^|[^\w$])/.source +
				"(?:" +
				(/NaN|Infinity/.source +
					"|" +
					/0[bB][01]+(?:_[01]+)*n?/.source +
					"|" +
					/0[oO][0-7]+(?:_[0-7]+)*n?/.source +
					"|" +
					/0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source +
					"|" +
					/\d+(?:_\d+)*n/.source +
					"|" +
					/(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/
						.source) +
				")" +
				/(?![\w$])/.source,
		),
		lookbehind: !0,
	},
	operator:
		/--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/,
});
Q.languages.javascript["class-name"][0].pattern =
	/(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/;
Q.languages.insertBefore("javascript", "keyword", {
	regex: {
		pattern: RegExp(
			/((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source +
				/\//.source +
				"(?:" +
				/(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/
					.source +
				"|" +
				/(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/
					.source +
				")" +
				/(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/
					.source,
		),
		lookbehind: !0,
		greedy: !0,
		inside: {
			"regex-source": {
				pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
				lookbehind: !0,
				alias: "language-regex",
				inside: Q.languages.regex,
			},
			"regex-delimiter": /^\/|\/$/,
			"regex-flags": /^[a-z]+$/,
		},
	},
	"function-variable": {
		pattern:
			/#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
		alias: "function",
	},
	parameter: [
		{
			pattern:
				/(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
			lookbehind: !0,
			inside: Q.languages.javascript,
		},
		{
			pattern:
				/(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
			lookbehind: !0,
			inside: Q.languages.javascript,
		},
		{
			pattern:
				/(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
			lookbehind: !0,
			inside: Q.languages.javascript,
		},
		{
			pattern:
				/((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
			lookbehind: !0,
			inside: Q.languages.javascript,
		},
	],
	constant: /\b[A-Z](?:[A-Z_]|\dx?)*\b/,
});
Q.languages.insertBefore("javascript", "string", {
	hashbang: { pattern: /^#!.*/, greedy: !0, alias: "comment" },
	"template-string": {
		pattern:
			/`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
		greedy: !0,
		inside: {
			"template-punctuation": { pattern: /^`|`$/, alias: "string" },
			interpolation: {
				pattern:
					/((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
				lookbehind: !0,
				inside: {
					"interpolation-punctuation": {
						pattern: /^\$\{|\}$/,
						alias: "punctuation",
					},
					rest: Q.languages.javascript,
				},
			},
			string: /[\s\S]+/,
		},
	},
	"string-property": {
		pattern:
			/((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
		lookbehind: !0,
		greedy: !0,
		alias: "property",
	},
});
Q.languages.insertBefore("javascript", "operator", {
	"literal-property": {
		pattern:
			/((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
		lookbehind: !0,
		alias: "property",
	},
});
Q.languages.markup &&
	(Q.languages.markup.tag.addInlined("script", "javascript"),
	Q.languages.markup.tag.addAttribute(
		/on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/
			.source,
		"javascript",
	));
Q.languages.js = Q.languages.javascript;
(function () {
	if (typeof Q > "u" || typeof document > "u") return;
	Element.prototype.matches ||
		(Element.prototype.matches =
			Element.prototype.msMatchesSelector ||
			Element.prototype.webkitMatchesSelector);
	var t = "Loading…",
		e = function (f, h) {
			return "✖ Error " + f + " while fetching file: " + h;
		},
		n = "✖ Error: File does not exist or is empty",
		r = {
			js: "javascript",
			py: "python",
			rb: "ruby",
			ps1: "powershell",
			psm1: "powershell",
			sh: "bash",
			bat: "batch",
			h: "c",
			tex: "latex",
		},
		i = "data-src-status",
		o = "loading",
		s = "loaded",
		a = "failed",
		l =
			"pre[data-src]:not([" +
			i +
			'="' +
			s +
			'"]):not([' +
			i +
			'="' +
			o +
			'"])';
	function u(f, h, p) {
		var g = new XMLHttpRequest();
		g.open("GET", f, !0),
			(g.onreadystatechange = function () {
				g.readyState == 4 &&
					(g.status < 400 && g.responseText
						? h(g.responseText)
						: g.status >= 400
							? p(e(g.status, g.statusText))
							: p(n));
			}),
			g.send(null);
	}
	function c(f) {
		var h = /^\s*(\d+)\s*(?:(,)\s*(?:(\d+)\s*)?)?$/.exec(f || "");
		if (h) {
			var p = Number(h[1]),
				g = h[2],
				v = h[3];
			return g ? (v ? [p, Number(v)] : [p, void 0]) : [p, p];
		}
	}
	Q.hooks.add("before-highlightall", function (f) {
		f.selector += ", " + l;
	}),
		Q.hooks.add("before-sanity-check", function (f) {
			var h = f.element;
			if (h.matches(l)) {
				(f.code = ""), h.setAttribute(i, o);
				var p = h.appendChild(document.createElement("CODE"));
				p.textContent = t;
				var g = h.getAttribute("data-src"),
					v = f.language;
				if (v === "none") {
					var b = (/\.(\w+)$/.exec(g) || [, "none"])[1];
					v = r[b] || b;
				}
				Q.util.setLanguage(p, v), Q.util.setLanguage(h, v);
				var y = Q.plugins.autoloader;
				y && y.loadLanguages(v),
					u(
						g,
						function (x) {
							h.setAttribute(i, s);
							var C = c(h.getAttribute("data-range"));
							if (C) {
								var k = x.split(/\r\n?|\n/g),
									w = C[0],
									D = C[1] == null ? k.length : C[1];
								w < 0 && (w += k.length),
									(w = Math.max(
										0,
										Math.min(w - 1, k.length),
									)),
									D < 0 && (D += k.length),
									(D = Math.max(0, Math.min(D, k.length))),
									(x = k.slice(w, D).join(`
`)),
									h.hasAttribute("data-start") ||
										h.setAttribute(
											"data-start",
											String(w + 1),
										);
							}
							(p.textContent = x), Q.highlightElement(p);
						},
						function (x) {
							h.setAttribute(i, a), (p.textContent = x);
						},
					);
			}
		}),
		(Q.plugins.fileHighlight = {
			highlight: function (h) {
				for (
					var p = (h || document).querySelectorAll(l), g = 0, v;
					(v = p[g++]);

				)
					Q.highlightElement(v);
			},
		});
	var d = !1;
	Q.fileHighlight = function () {
		d ||
			(console.warn(
				"Prism.fileHighlight is deprecated. Use `Prism.plugins.fileHighlight.highlight` instead.",
			),
			(d = !0)),
			Q.plugins.fileHighlight.highlight.apply(this, arguments);
	};
})();
Q.languages.clike = {
	comment: [
		{
			pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
			lookbehind: !0,
			greedy: !0,
		},
		{ pattern: /(^|[^\\:])\/\/.*/, lookbehind: !0, greedy: !0 },
	],
	string: {
		pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
		greedy: !0,
	},
	"class-name": {
		pattern:
			/(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
		lookbehind: !0,
		inside: { punctuation: /[.\\]/ },
	},
	keyword:
		/\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
	boolean: /\b(?:false|true)\b/,
	function: /\b\w+(?=\()/,
	number: /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
	operator: /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
	punctuation: /[{}[\];(),.:]/,
};
Q.languages.c = Q.languages.extend("clike", {
	comment: {
		pattern:
			/\/\/(?:[^\r\n\\]|\\(?:\r\n?|\n|(?![\r\n])))*|\/\*[\s\S]*?(?:\*\/|$)/,
		greedy: !0,
	},
	string: { pattern: /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/, greedy: !0 },
	"class-name": {
		pattern:
			/(\b(?:enum|struct)\s+(?:__attribute__\s*\(\([\s\S]*?\)\)\s*)?)\w+|\b[a-z]\w*_t\b/,
		lookbehind: !0,
	},
	keyword:
		/\b(?:_Alignas|_Alignof|_Atomic|_Bool|_Complex|_Generic|_Imaginary|_Noreturn|_Static_assert|_Thread_local|__attribute__|asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|inline|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|typeof|union|unsigned|void|volatile|while)\b/,
	function: /\b[a-z_]\w*(?=\s*\()/i,
	number: /(?:\b0x(?:[\da-f]+(?:\.[\da-f]*)?|\.[\da-f]+)(?:p[+-]?\d+)?|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)[ful]{0,4}/i,
	operator: />>=?|<<=?|->|([-+&|:])\1|[?:~]|[-+*/%&|^!=<>]=?/,
});
Q.languages.insertBefore("c", "string", {
	char: { pattern: /'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n]){0,32}'/, greedy: !0 },
});
Q.languages.insertBefore("c", "string", {
	macro: {
		pattern:
			/(^[\t ]*)#\s*[a-z](?:[^\r\n\\/]|\/(?!\*)|\/\*(?:[^*]|\*(?!\/))*\*\/|\\(?:\r\n|[\s\S]))*/im,
		lookbehind: !0,
		greedy: !0,
		alias: "property",
		inside: {
			string: [
				{ pattern: /^(#\s*include\s*)<[^>]+>/, lookbehind: !0 },
				Q.languages.c.string,
			],
			char: Q.languages.c.char,
			comment: Q.languages.c.comment,
			"macro-name": [
				{ pattern: /(^#\s*define\s+)\w+\b(?!\()/i, lookbehind: !0 },
				{
					pattern: /(^#\s*define\s+)\w+\b(?=\()/i,
					lookbehind: !0,
					alias: "function",
				},
			],
			directive: {
				pattern: /^(#\s*)[a-z]+/,
				lookbehind: !0,
				alias: "keyword",
			},
			"directive-hash": /^#/,
			punctuation: /##|\\(?=[\r\n])/,
			expression: { pattern: /\S[\s\S]*/, inside: Q.languages.c },
		},
	},
});
Q.languages.insertBefore("c", "function", {
	constant:
		/\b(?:EOF|NULL|SEEK_CUR|SEEK_END|SEEK_SET|__DATE__|__FILE__|__LINE__|__TIMESTAMP__|__TIME__|__func__|stderr|stdin|stdout)\b/,
});
delete Q.languages.c.boolean;
(function (t) {
	var e =
			/\b(?:alignas|alignof|asm|auto|bool|break|case|catch|char|char16_t|char32_t|char8_t|class|co_await|co_return|co_yield|compl|concept|const|const_cast|consteval|constexpr|constinit|continue|decltype|default|delete|do|double|dynamic_cast|else|enum|explicit|export|extern|final|float|for|friend|goto|if|import|inline|int|int16_t|int32_t|int64_t|int8_t|long|module|mutable|namespace|new|noexcept|nullptr|operator|override|private|protected|public|register|reinterpret_cast|requires|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|uint16_t|uint32_t|uint64_t|uint8_t|union|unsigned|using|virtual|void|volatile|wchar_t|while)\b/,
		n = /\b(?!<keyword>)\w+(?:\s*\.\s*\w+)*\b/.source.replace(
			/<keyword>/g,
			function () {
				return e.source;
			},
		);
	(t.languages.cpp = t.languages.extend("c", {
		"class-name": [
			{
				pattern: RegExp(
					/(\b(?:class|concept|enum|struct|typename)\s+)(?!<keyword>)\w+/.source.replace(
						/<keyword>/g,
						function () {
							return e.source;
						},
					),
				),
				lookbehind: !0,
			},
			/\b[A-Z]\w*(?=\s*::\s*\w+\s*\()/,
			/\b[A-Z_]\w*(?=\s*::\s*~\w+\s*\()/i,
			/\b\w+(?=\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>\s*::\s*\w+\s*\()/,
		],
		keyword: e,
		number: {
			pattern:
				/(?:\b0b[01']+|\b0x(?:[\da-f']+(?:\.[\da-f']*)?|\.[\da-f']+)(?:p[+-]?[\d']+)?|(?:\b[\d']+(?:\.[\d']*)?|\B\.[\d']+)(?:e[+-]?[\d']+)?)[ful]{0,4}/i,
			greedy: !0,
		},
		operator:
			/>>=?|<<=?|->|--|\+\+|&&|\|\||[?:~]|<=>|[-+*/%&|^!=<>]=?|\b(?:and|and_eq|bitand|bitor|not|not_eq|or|or_eq|xor|xor_eq)\b/,
		boolean: /\b(?:false|true)\b/,
	})),
		t.languages.insertBefore("cpp", "string", {
			module: {
				pattern: RegExp(
					/(\b(?:import|module)\s+)/.source +
						"(?:" +
						/"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|<[^<>\r\n]*>/
							.source +
						"|" +
						/<mod-name>(?:\s*:\s*<mod-name>)?|:\s*<mod-name>/.source.replace(
							/<mod-name>/g,
							function () {
								return n;
							},
						) +
						")",
				),
				lookbehind: !0,
				greedy: !0,
				inside: {
					string: /^[<"][\s\S]+/,
					operator: /:/,
					punctuation: /\./,
				},
			},
			"raw-string": {
				pattern: /R"([^()\\ ]{0,16})\([\s\S]*?\)\1"/,
				alias: "string",
				greedy: !0,
			},
		}),
		t.languages.insertBefore("cpp", "keyword", {
			"generic-function": {
				pattern:
					/\b(?!operator\b)[a-z_]\w*\s*<(?:[^<>]|<[^<>]*>)*>(?=\s*\()/i,
				inside: {
					function: /^\w+/,
					generic: {
						pattern: /<[\s\S]+/,
						alias: "class-name",
						inside: t.languages.cpp,
					},
				},
			},
		}),
		t.languages.insertBefore("cpp", "operator", {
			"double-colon": { pattern: /::/, alias: "punctuation" },
		}),
		t.languages.insertBefore("cpp", "class-name", {
			"base-clause": {
				pattern:
					/(\b(?:class|struct)\s+\w+\s*:\s*)[^;{}"'\s]+(?:\s+[^;{}"'\s]+)*(?=\s*[;{])/,
				lookbehind: !0,
				greedy: !0,
				inside: t.languages.extend("cpp", {}),
			},
		}),
		t.languages.insertBefore(
			"inside",
			"double-colon",
			{ "class-name": /\b[a-z_]\w*\b(?!\s*::)/i },
			t.languages.cpp["base-clause"],
		);
})(Q);
Q.languages.arduino = Q.languages.extend("cpp", {
	keyword:
		/\b(?:String|array|bool|boolean|break|byte|case|catch|continue|default|do|double|else|finally|for|function|goto|if|in|instanceof|int|integer|long|loop|new|null|return|setup|string|switch|throw|try|void|while|word)\b/,
	constant:
		/\b(?:ANALOG_MESSAGE|DEFAULT|DIGITAL_MESSAGE|EXTERNAL|FIRMATA_STRING|HIGH|INPUT|INPUT_PULLUP|INTERNAL|INTERNAL1V1|INTERNAL2V56|LED_BUILTIN|LOW|OUTPUT|REPORT_ANALOG|REPORT_DIGITAL|SET_PIN_MODE|SYSEX_START|SYSTEM_RESET)\b/,
	builtin:
		/\b(?:Audio|BSSID|Bridge|Client|Console|EEPROM|Esplora|EsploraTFT|Ethernet|EthernetClient|EthernetServer|EthernetUDP|File|FileIO|FileSystem|Firmata|GPRS|GSM|GSMBand|GSMClient|GSMModem|GSMPIN|GSMScanner|GSMServer|GSMVoiceCall|GSM_SMS|HttpClient|IPAddress|IRread|Keyboard|KeyboardController|LiquidCrystal|LiquidCrystal_I2C|Mailbox|Mouse|MouseController|PImage|Process|RSSI|RobotControl|RobotMotor|SD|SPI|SSID|Scheduler|Serial|Server|Servo|SoftwareSerial|Stepper|Stream|TFT|Task|USBHost|WiFi|WiFiClient|WiFiServer|WiFiUDP|Wire|YunClient|YunServer|abs|addParameter|analogRead|analogReadResolution|analogReference|analogWrite|analogWriteResolution|answerCall|attach|attachGPRS|attachInterrupt|attached|autoscroll|available|background|beep|begin|beginPacket|beginSD|beginSMS|beginSpeaker|beginTFT|beginTransmission|beginWrite|bit|bitClear|bitRead|bitSet|bitWrite|blink|blinkVersion|buffer|changePIN|checkPIN|checkPUK|checkReg|circle|cityNameRead|cityNameWrite|clear|clearScreen|click|close|compassRead|config|connect|connected|constrain|cos|countryNameRead|countryNameWrite|createChar|cursor|debugPrint|delay|delayMicroseconds|detach|detachInterrupt|digitalRead|digitalWrite|disconnect|display|displayLogos|drawBMP|drawCompass|encryptionType|end|endPacket|endSMS|endTransmission|endWrite|exists|exitValue|fill|find|findUntil|flush|gatewayIP|get|getAsynchronously|getBand|getButton|getCurrentCarrier|getIMEI|getKey|getModifiers|getOemKey|getPINUsed|getResult|getSignalStrength|getSocket|getVoiceCallStatus|getXChange|getYChange|hangCall|height|highByte|home|image|interrupts|isActionDone|isDirectory|isListening|isPIN|isPressed|isValid|keyPressed|keyReleased|keyboardRead|knobRead|leftToRight|line|lineFollowConfig|listen|listenOnLocalhost|loadImage|localIP|lowByte|macAddress|maintain|map|max|messageAvailable|micros|millis|min|mkdir|motorsStop|motorsWrite|mouseDragged|mouseMoved|mousePressed|mouseReleased|move|noAutoscroll|noBlink|noBuffer|noCursor|noDisplay|noFill|noInterrupts|noListenOnLocalhost|noStroke|noTone|onReceive|onRequest|open|openNextFile|overflow|parseCommand|parseFloat|parseInt|parsePacket|pauseMode|peek|pinMode|playFile|playMelody|point|pointTo|position|pow|prepare|press|print|printFirmwareVersion|printVersion|println|process|processInput|pulseIn|put|random|randomSeed|read|readAccelerometer|readBlue|readButton|readBytes|readBytesUntil|readGreen|readJoystickButton|readJoystickSwitch|readJoystickX|readJoystickY|readLightSensor|readMessage|readMicrophone|readNetworks|readRed|readSlider|readString|readStringUntil|readTemperature|ready|rect|release|releaseAll|remoteIP|remoteNumber|remotePort|remove|requestFrom|retrieveCallingNumber|rewindDirectory|rightToLeft|rmdir|robotNameRead|robotNameWrite|run|runAsynchronously|runShellCommand|runShellCommandAsynchronously|running|scanNetworks|scrollDisplayLeft|scrollDisplayRight|seek|sendAnalog|sendDigitalPortPair|sendDigitalPorts|sendString|sendSysex|serialEvent|setBand|setBitOrder|setClockDivider|setCursor|setDNS|setDataMode|setFirmwareVersion|setMode|setPINUsed|setSpeed|setTextSize|setTimeout|shiftIn|shiftOut|shutdown|sin|size|sqrt|startLoop|step|stop|stroke|subnetMask|switchPIN|tan|tempoWrite|text|tone|transfer|tuneWrite|turn|updateIR|userNameRead|userNameWrite|voiceCall|waitContinue|width|write|writeBlue|writeGreen|writeJSON|writeMessage|writeMicroseconds|writeRGB|writeRed|yield)\b/,
});
Q.languages.ino = Q.languages.arduino;
(function (t) {
	var e =
			"\\b(?:BASH|BASHOPTS|BASH_ALIASES|BASH_ARGC|BASH_ARGV|BASH_CMDS|BASH_COMPLETION_COMPAT_DIR|BASH_LINENO|BASH_REMATCH|BASH_SOURCE|BASH_VERSINFO|BASH_VERSION|COLORTERM|COLUMNS|COMP_WORDBREAKS|DBUS_SESSION_BUS_ADDRESS|DEFAULTS_PATH|DESKTOP_SESSION|DIRSTACK|DISPLAY|EUID|GDMSESSION|GDM_LANG|GNOME_KEYRING_CONTROL|GNOME_KEYRING_PID|GPG_AGENT_INFO|GROUPS|HISTCONTROL|HISTFILE|HISTFILESIZE|HISTSIZE|HOME|HOSTNAME|HOSTTYPE|IFS|INSTANCE|JOB|LANG|LANGUAGE|LC_ADDRESS|LC_ALL|LC_IDENTIFICATION|LC_MEASUREMENT|LC_MONETARY|LC_NAME|LC_NUMERIC|LC_PAPER|LC_TELEPHONE|LC_TIME|LESSCLOSE|LESSOPEN|LINES|LOGNAME|LS_COLORS|MACHTYPE|MAILCHECK|MANDATORY_PATH|NO_AT_BRIDGE|OLDPWD|OPTERR|OPTIND|ORBIT_SOCKETDIR|OSTYPE|PAPERSIZE|PATH|PIPESTATUS|PPID|PS1|PS2|PS3|PS4|PWD|RANDOM|REPLY|SECONDS|SELINUX_INIT|SESSION|SESSIONTYPE|SESSION_MANAGER|SHELL|SHELLOPTS|SHLVL|SSH_AUTH_SOCK|TERM|UID|UPSTART_EVENTS|UPSTART_INSTANCE|UPSTART_JOB|UPSTART_SESSION|USER|WINDOWID|XAUTHORITY|XDG_CONFIG_DIRS|XDG_CURRENT_DESKTOP|XDG_DATA_DIRS|XDG_GREETER_DATA_DIR|XDG_MENU_PREFIX|XDG_RUNTIME_DIR|XDG_SEAT|XDG_SEAT_PATH|XDG_SESSION_DESKTOP|XDG_SESSION_ID|XDG_SESSION_PATH|XDG_SESSION_TYPE|XDG_VTNR|XMODIFIERS)\\b",
		n = {
			pattern: /(^(["']?)\w+\2)[ \t]+\S.*/,
			lookbehind: !0,
			alias: "punctuation",
			inside: null,
		},
		r = {
			bash: n,
			environment: { pattern: RegExp("\\$" + e), alias: "constant" },
			variable: [
				{
					pattern: /\$?\(\([\s\S]+?\)\)/,
					greedy: !0,
					inside: {
						variable: [
							{ pattern: /(^\$\(\([\s\S]+)\)\)/, lookbehind: !0 },
							/^\$\(\(/,
						],
						number: /\b0x[\dA-Fa-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee]-?\d+)?/,
						operator:
							/--|\+\+|\*\*=?|<<=?|>>=?|&&|\|\||[=!+\-*/%<>^&|]=?|[?~:]/,
						punctuation: /\(\(?|\)\)?|,|;/,
					},
				},
				{
					pattern: /\$\((?:\([^)]+\)|[^()])+\)|`[^`]+`/,
					greedy: !0,
					inside: { variable: /^\$\(|^`|\)$|`$/ },
				},
				{
					pattern: /\$\{[^}]+\}/,
					greedy: !0,
					inside: {
						operator: /:[-=?+]?|[!\/]|##?|%%?|\^\^?|,,?/,
						punctuation: /[\[\]]/,
						environment: {
							pattern: RegExp("(\\{)" + e),
							lookbehind: !0,
							alias: "constant",
						},
					},
				},
				/\$(?:\w+|[#?*!@$])/,
			],
			entity: /\\(?:[abceEfnrtv\\"]|O?[0-7]{1,3}|U[0-9a-fA-F]{8}|u[0-9a-fA-F]{4}|x[0-9a-fA-F]{1,2})/,
		};
	(t.languages.bash = {
		shebang: { pattern: /^#!\s*\/.*/, alias: "important" },
		comment: { pattern: /(^|[^"{\\$])#.*/, lookbehind: !0 },
		"function-name": [
			{
				pattern: /(\bfunction\s+)[\w-]+(?=(?:\s*\(?:\s*\))?\s*\{)/,
				lookbehind: !0,
				alias: "function",
			},
			{ pattern: /\b[\w-]+(?=\s*\(\s*\)\s*\{)/, alias: "function" },
		],
		"for-or-select": {
			pattern: /(\b(?:for|select)\s+)\w+(?=\s+in\s)/,
			alias: "variable",
			lookbehind: !0,
		},
		"assign-left": {
			pattern: /(^|[\s;|&]|[<>]\()\w+(?:\.\w+)*(?=\+?=)/,
			inside: {
				environment: {
					pattern: RegExp("(^|[\\s;|&]|[<>]\\()" + e),
					lookbehind: !0,
					alias: "constant",
				},
			},
			alias: "variable",
			lookbehind: !0,
		},
		parameter: {
			pattern: /(^|\s)-{1,2}(?:\w+:[+-]?)?\w+(?:\.\w+)*(?=[=\s]|$)/,
			alias: "variable",
			lookbehind: !0,
		},
		string: [
			{
				pattern: /((?:^|[^<])<<-?\s*)(\w+)\s[\s\S]*?(?:\r?\n|\r)\2/,
				lookbehind: !0,
				greedy: !0,
				inside: r,
			},
			{
				pattern:
					/((?:^|[^<])<<-?\s*)(["'])(\w+)\2\s[\s\S]*?(?:\r?\n|\r)\3/,
				lookbehind: !0,
				greedy: !0,
				inside: { bash: n },
			},
			{
				pattern:
					/(^|[^\\](?:\\\\)*)"(?:\\[\s\S]|\$\([^)]+\)|\$(?!\()|`[^`]+`|[^"\\`$])*"/,
				lookbehind: !0,
				greedy: !0,
				inside: r,
			},
			{ pattern: /(^|[^$\\])'[^']*'/, lookbehind: !0, greedy: !0 },
			{
				pattern: /\$'(?:[^'\\]|\\[\s\S])*'/,
				greedy: !0,
				inside: { entity: r.entity },
			},
		],
		environment: { pattern: RegExp("\\$?" + e), alias: "constant" },
		variable: r.variable,
		function: {
			pattern:
				/(^|[\s;|&]|[<>]\()(?:add|apropos|apt|apt-cache|apt-get|aptitude|aspell|automysqlbackup|awk|basename|bash|bc|bconsole|bg|bzip2|cal|cargo|cat|cfdisk|chgrp|chkconfig|chmod|chown|chroot|cksum|clear|cmp|column|comm|composer|cp|cron|crontab|csplit|curl|cut|date|dc|dd|ddrescue|debootstrap|df|diff|diff3|dig|dir|dircolors|dirname|dirs|dmesg|docker|docker-compose|du|egrep|eject|env|ethtool|expand|expect|expr|fdformat|fdisk|fg|fgrep|file|find|fmt|fold|format|free|fsck|ftp|fuser|gawk|git|gparted|grep|groupadd|groupdel|groupmod|groups|grub-mkconfig|gzip|halt|head|hg|history|host|hostname|htop|iconv|id|ifconfig|ifdown|ifup|import|install|ip|java|jobs|join|kill|killall|less|link|ln|locate|logname|logrotate|look|lpc|lpr|lprint|lprintd|lprintq|lprm|ls|lsof|lynx|make|man|mc|mdadm|mkconfig|mkdir|mke2fs|mkfifo|mkfs|mkisofs|mknod|mkswap|mmv|more|most|mount|mtools|mtr|mutt|mv|nano|nc|netstat|nice|nl|node|nohup|notify-send|npm|nslookup|op|open|parted|passwd|paste|pathchk|ping|pkill|pnpm|podman|podman-compose|popd|pr|printcap|printenv|ps|pushd|pv|quota|quotacheck|quotactl|ram|rar|rcp|reboot|remsync|rename|renice|rev|rm|rmdir|rpm|rsync|scp|screen|sdiff|sed|sendmail|seq|service|sftp|sh|shellcheck|shuf|shutdown|sleep|slocate|sort|split|ssh|stat|strace|su|sudo|sum|suspend|swapon|sync|sysctl|tac|tail|tar|tee|time|timeout|top|touch|tr|traceroute|tsort|tty|umount|uname|unexpand|uniq|units|unrar|unshar|unzip|update-grub|uptime|useradd|userdel|usermod|users|uudecode|uuencode|v|vcpkg|vdir|vi|vim|virsh|vmstat|wait|watch|wc|wget|whereis|which|who|whoami|write|xargs|xdg-open|yarn|yes|zenity|zip|zsh|zypper)(?=$|[)\s;|&])/,
			lookbehind: !0,
		},
		keyword: {
			pattern:
				/(^|[\s;|&]|[<>]\()(?:case|do|done|elif|else|esac|fi|for|function|if|in|select|then|until|while)(?=$|[)\s;|&])/,
			lookbehind: !0,
		},
		builtin: {
			pattern:
				/(^|[\s;|&]|[<>]\()(?:\.|:|alias|bind|break|builtin|caller|cd|command|continue|declare|echo|enable|eval|exec|exit|export|getopts|hash|help|let|local|logout|mapfile|printf|pwd|read|readarray|readonly|return|set|shift|shopt|source|test|times|trap|type|typeset|ulimit|umask|unalias|unset)(?=$|[)\s;|&])/,
			lookbehind: !0,
			alias: "class-name",
		},
		boolean: {
			pattern: /(^|[\s;|&]|[<>]\()(?:false|true)(?=$|[)\s;|&])/,
			lookbehind: !0,
		},
		"file-descriptor": { pattern: /\B&\d\b/, alias: "important" },
		operator: {
			pattern:
				/\d?<>|>\||\+=|=[=~]?|!=?|<<[<-]?|[&\d]?>>|\d[<>]&?|[<>][&=]?|&[>&]?|\|[&|]?/,
			inside: {
				"file-descriptor": { pattern: /^\d/, alias: "important" },
			},
		},
		punctuation: /\$?\(\(?|\)\)?|\.\.|[{}[\];\\]/,
		number: {
			pattern: /(^|\s)(?:[1-9]\d*|0)(?:[.,]\d+)?\b/,
			lookbehind: !0,
		},
	}),
		(n.inside = t.languages.bash);
	for (
		var i = [
				"comment",
				"function-name",
				"for-or-select",
				"assign-left",
				"parameter",
				"string",
				"environment",
				"function",
				"keyword",
				"builtin",
				"boolean",
				"file-descriptor",
				"operator",
				"punctuation",
				"number",
			],
			o = r.variable[1].inside,
			s = 0;
		s < i.length;
		s++
	)
		o[i[s]] = t.languages.bash[i[s]];
	(t.languages.sh = t.languages.bash), (t.languages.shell = t.languages.bash);
})(Q);
(function (t) {
	function e(K, M) {
		return K.replace(/<<(\d+)>>/g, function (G, H) {
			return "(?:" + M[+H] + ")";
		});
	}
	function n(K, M, G) {
		return RegExp(e(K, M), "");
	}
	function r(K, M) {
		for (var G = 0; G < M; G++)
			K = K.replace(/<<self>>/g, function () {
				return "(?:" + K + ")";
			});
		return K.replace(/<<self>>/g, "[^\\s\\S]");
	}
	var i = {
		type: "bool byte char decimal double dynamic float int long object sbyte short string uint ulong ushort var void",
		typeDeclaration: "class enum interface record struct",
		contextual:
			"add alias and ascending async await by descending from(?=\\s*(?:\\w|$)) get global group into init(?=\\s*;) join let nameof not notnull on or orderby partial remove select set unmanaged value when where with(?=\\s*{)",
		other: "abstract as base break case catch checked const continue default delegate do else event explicit extern finally fixed for foreach goto if implicit in internal is lock namespace new null operator out override params private protected public readonly ref return sealed sizeof stackalloc static switch this throw try typeof unchecked unsafe using virtual volatile while yield",
	};
	function o(K) {
		return "\\b(?:" + K.trim().replace(/ /g, "|") + ")\\b";
	}
	var s = o(i.typeDeclaration),
		a = RegExp(
			o(
				i.type +
					" " +
					i.typeDeclaration +
					" " +
					i.contextual +
					" " +
					i.other,
			),
		),
		l = o(i.typeDeclaration + " " + i.contextual + " " + i.other),
		u = o(i.type + " " + i.typeDeclaration + " " + i.other),
		c = r(/<(?:[^<>;=+\-*/%&|^]|<<self>>)*>/.source, 2),
		d = r(/\((?:[^()]|<<self>>)*\)/.source, 2),
		f = /@?\b[A-Za-z_]\w*\b/.source,
		h = e(/<<0>>(?:\s*<<1>>)?/.source, [f, c]),
		p = e(/(?!<<0>>)<<1>>(?:\s*\.\s*<<1>>)*/.source, [l, h]),
		g = /\[\s*(?:,\s*)*\]/.source,
		v = e(/<<0>>(?:\s*(?:\?\s*)?<<1>>)*(?:\s*\?)?/.source, [p, g]),
		b = e(/[^,()<>[\];=+\-*/%&|^]|<<0>>|<<1>>|<<2>>/.source, [c, d, g]),
		y = e(/\(<<0>>+(?:,<<0>>+)+\)/.source, [b]),
		x = e(/(?:<<0>>|<<1>>)(?:\s*(?:\?\s*)?<<2>>)*(?:\s*\?)?/.source, [
			y,
			p,
			g,
		]),
		C = { keyword: a, punctuation: /[<>()?,.:[\]]/ },
		k = /'(?:[^\r\n'\\]|\\.|\\[Uux][\da-fA-F]{1,8})'/.source,
		w = /"(?:\\.|[^\\"\r\n])*"/.source,
		D = /@"(?:""|\\[\s\S]|[^\\"])*"(?!")/.source;
	(t.languages.csharp = t.languages.extend("clike", {
		string: [
			{
				pattern: n(/(^|[^$\\])<<0>>/.source, [D]),
				lookbehind: !0,
				greedy: !0,
			},
			{
				pattern: n(/(^|[^@$\\])<<0>>/.source, [w]),
				lookbehind: !0,
				greedy: !0,
			},
		],
		"class-name": [
			{
				pattern: n(/(\busing\s+static\s+)<<0>>(?=\s*;)/.source, [p]),
				lookbehind: !0,
				inside: C,
			},
			{
				pattern: n(/(\busing\s+<<0>>\s*=\s*)<<1>>(?=\s*;)/.source, [
					f,
					x,
				]),
				lookbehind: !0,
				inside: C,
			},
			{
				pattern: n(/(\busing\s+)<<0>>(?=\s*=)/.source, [f]),
				lookbehind: !0,
			},
			{
				pattern: n(/(\b<<0>>\s+)<<1>>/.source, [s, h]),
				lookbehind: !0,
				inside: C,
			},
			{
				pattern: n(/(\bcatch\s*\(\s*)<<0>>/.source, [p]),
				lookbehind: !0,
				inside: C,
			},
			{ pattern: n(/(\bwhere\s+)<<0>>/.source, [f]), lookbehind: !0 },
			{
				pattern: n(/(\b(?:is(?:\s+not)?|as)\s+)<<0>>/.source, [v]),
				lookbehind: !0,
				inside: C,
			},
			{
				pattern: n(
					/\b<<0>>(?=\s+(?!<<1>>|with\s*\{)<<2>>(?:\s*[=,;:{)\]]|\s+(?:in|when)\b))/
						.source,
					[x, u, f],
				),
				inside: C,
			},
		],
		keyword: a,
		number: /(?:\b0(?:x[\da-f_]*[\da-f]|b[01_]*[01])|(?:\B\.\d+(?:_+\d+)*|\b\d+(?:_+\d+)*(?:\.\d+(?:_+\d+)*)?)(?:e[-+]?\d+(?:_+\d+)*)?)(?:[dflmu]|lu|ul)?\b/i,
		operator: />>=?|<<=?|[-=]>|([-+&|])\1|~|\?\?=?|[-+*/%&|^!=<>]=?/,
		punctuation: /\?\.?|::|[{}[\];(),.:]/,
	})),
		t.languages.insertBefore("csharp", "number", {
			range: { pattern: /\.\./, alias: "operator" },
		}),
		t.languages.insertBefore("csharp", "punctuation", {
			"named-parameter": {
				pattern: n(/([(,]\s*)<<0>>(?=\s*:)/.source, [f]),
				lookbehind: !0,
				alias: "punctuation",
			},
		}),
		t.languages.insertBefore("csharp", "class-name", {
			namespace: {
				pattern: n(
					/(\b(?:namespace|using)\s+)<<0>>(?:\s*\.\s*<<0>>)*(?=\s*[;{])/
						.source,
					[f],
				),
				lookbehind: !0,
				inside: { punctuation: /\./ },
			},
			"type-expression": {
				pattern: n(
					/(\b(?:default|sizeof|typeof)\s*\(\s*(?!\s))(?:[^()\s]|\s(?!\s)|<<0>>)*(?=\s*\))/
						.source,
					[d],
				),
				lookbehind: !0,
				alias: "class-name",
				inside: C,
			},
			"return-type": {
				pattern: n(
					/<<0>>(?=\s+(?:<<1>>\s*(?:=>|[({]|\.\s*this\s*\[)|this\s*\[))/
						.source,
					[x, p],
				),
				inside: C,
				alias: "class-name",
			},
			"constructor-invocation": {
				pattern: n(/(\bnew\s+)<<0>>(?=\s*[[({])/.source, [x]),
				lookbehind: !0,
				inside: C,
				alias: "class-name",
			},
			"generic-method": {
				pattern: n(/<<0>>\s*<<1>>(?=\s*\()/.source, [f, c]),
				inside: {
					function: n(/^<<0>>/.source, [f]),
					generic: {
						pattern: RegExp(c),
						alias: "class-name",
						inside: C,
					},
				},
			},
			"type-list": {
				pattern: n(
					/\b((?:<<0>>\s+<<1>>|record\s+<<1>>\s*<<5>>|where\s+<<2>>)\s*:\s*)(?:<<3>>|<<4>>|<<1>>\s*<<5>>|<<6>>)(?:\s*,\s*(?:<<3>>|<<4>>|<<6>>))*(?=\s*(?:where|[{;]|=>|$))/
						.source,
					[s, h, f, x, a.source, d, /\bnew\s*\(\s*\)/.source],
				),
				lookbehind: !0,
				inside: {
					"record-arguments": {
						pattern: n(/(^(?!new\s*\()<<0>>\s*)<<1>>/.source, [
							h,
							d,
						]),
						lookbehind: !0,
						greedy: !0,
						inside: t.languages.csharp,
					},
					keyword: a,
					"class-name": { pattern: RegExp(x), greedy: !0, inside: C },
					punctuation: /[,()]/,
				},
			},
			preprocessor: {
				pattern: /(^[\t ]*)#.*/m,
				lookbehind: !0,
				alias: "property",
				inside: {
					directive: {
						pattern:
							/(#)\b(?:define|elif|else|endif|endregion|error|if|line|nullable|pragma|region|undef|warning)\b/,
						lookbehind: !0,
						alias: "keyword",
					},
				},
			},
		});
	var S = w + "|" + k,
		$ = e(
			/\/(?![*/])|\/\/[^\r\n]*[\r\n]|\/\*(?:[^*]|\*(?!\/))*\*\/|<<0>>/
				.source,
			[S],
		),
		A = r(e(/[^"'/()]|<<0>>|\(<<self>>*\)/.source, [$]), 2),
		T =
			/\b(?:assembly|event|field|method|module|param|property|return|type)\b/
				.source,
		I = e(/<<0>>(?:\s*\(<<1>>*\))?/.source, [p, A]);
	t.languages.insertBefore("csharp", "class-name", {
		attribute: {
			pattern: n(
				/((?:^|[^\s\w>)?])\s*\[\s*)(?:<<0>>\s*:\s*)?<<1>>(?:\s*,\s*<<1>>)*(?=\s*\])/
					.source,
				[T, I],
			),
			lookbehind: !0,
			greedy: !0,
			inside: {
				target: {
					pattern: n(/^<<0>>(?=\s*:)/.source, [T]),
					alias: "keyword",
				},
				"attribute-arguments": {
					pattern: n(/\(<<0>>*\)/.source, [A]),
					inside: t.languages.csharp,
				},
				"class-name": {
					pattern: RegExp(p),
					inside: { punctuation: /\./ },
				},
				punctuation: /[:,]/,
			},
		},
	});
	var F = /:[^}\r\n]+/.source,
		N = r(e(/[^"'/()]|<<0>>|\(<<self>>*\)/.source, [$]), 2),
		O = e(/\{(?!\{)(?:(?![}:])<<0>>)*<<1>>?\}/.source, [N, F]),
		_ = r(
			e(
				/[^"'/()]|\/(?!\*)|\/\*(?:[^*]|\*(?!\/))*\*\/|<<0>>|\(<<self>>*\)/
					.source,
				[S],
			),
			2,
		),
		j = e(/\{(?!\{)(?:(?![}:])<<0>>)*<<1>>?\}/.source, [_, F]);
	function V(K, M) {
		return {
			interpolation: {
				pattern: n(/((?:^|[^{])(?:\{\{)*)<<0>>/.source, [K]),
				lookbehind: !0,
				inside: {
					"format-string": {
						pattern: n(
							/(^\{(?:(?![}:])<<0>>)*)<<1>>(?=\}$)/.source,
							[M, F],
						),
						lookbehind: !0,
						inside: { punctuation: /^:/ },
					},
					punctuation: /^\{|\}$/,
					expression: {
						pattern: /[\s\S]+/,
						alias: "language-csharp",
						inside: t.languages.csharp,
					},
				},
			},
			string: /[\s\S]+/,
		};
	}
	t.languages.insertBefore("csharp", "string", {
		"interpolation-string": [
			{
				pattern: n(
					/(^|[^\\])(?:\$@|@\$)"(?:""|\\[\s\S]|\{\{|<<0>>|[^\\{"])*"/
						.source,
					[O],
				),
				lookbehind: !0,
				greedy: !0,
				inside: V(O, N),
			},
			{
				pattern: n(/(^|[^@\\])\$"(?:\\.|\{\{|<<0>>|[^\\"{])*"/.source, [
					j,
				]),
				lookbehind: !0,
				greedy: !0,
				inside: V(j, _),
			},
		],
		char: { pattern: RegExp(k), greedy: !0 },
	}),
		(t.languages.dotnet = t.languages.cs = t.languages.csharp);
})(Q);
Q.languages.markup = {
	comment: { pattern: /<!--(?:(?!<!--)[\s\S])*?-->/, greedy: !0 },
	prolog: { pattern: /<\?[\s\S]+?\?>/, greedy: !0 },
	doctype: {
		pattern:
			/<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
		greedy: !0,
		inside: {
			"internal-subset": {
				pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
				lookbehind: !0,
				greedy: !0,
				inside: null,
			},
			string: { pattern: /"[^"]*"|'[^']*'/, greedy: !0 },
			punctuation: /^<!|>$|[[\]]/,
			"doctype-tag": /^DOCTYPE/i,
			name: /[^\s<>'"]+/,
		},
	},
	cdata: { pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i, greedy: !0 },
	tag: {
		pattern:
			/<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
		greedy: !0,
		inside: {
			tag: {
				pattern: /^<\/?[^\s>\/]+/,
				inside: { punctuation: /^<\/?/, namespace: /^[^\s>\/:]+:/ },
			},
			"special-attr": [],
			"attr-value": {
				pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
				inside: {
					punctuation: [
						{ pattern: /^=/, alias: "attr-equals" },
						{ pattern: /^(\s*)["']|["']$/, lookbehind: !0 },
					],
				},
			},
			punctuation: /\/?>/,
			"attr-name": {
				pattern: /[^\s>\/]+/,
				inside: { namespace: /^[^\s>\/:]+:/ },
			},
		},
	},
	entity: [
		{ pattern: /&[\da-z]{1,8};/i, alias: "named-entity" },
		/&#x?[\da-f]{1,8};/i,
	],
};
Q.languages.markup.tag.inside["attr-value"].inside.entity =
	Q.languages.markup.entity;
Q.languages.markup.doctype.inside["internal-subset"].inside =
	Q.languages.markup;
Q.hooks.add("wrap", function (t) {
	t.type === "entity" &&
		(t.attributes.title = t.content.replace(/&amp;/, "&"));
});
Object.defineProperty(Q.languages.markup.tag, "addInlined", {
	value: function (e, n) {
		var r = {};
		(r["language-" + n] = {
			pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
			lookbehind: !0,
			inside: Q.languages[n],
		}),
			(r.cdata = /^<!\[CDATA\[|\]\]>$/i);
		var i = {
			"included-cdata": {
				pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
				inside: r,
			},
		};
		i["language-" + n] = { pattern: /[\s\S]+/, inside: Q.languages[n] };
		var o = {};
		(o[e] = {
			pattern: RegExp(
				/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(
					/__/g,
					function () {
						return e;
					},
				),
				"i",
			),
			lookbehind: !0,
			greedy: !0,
			inside: i,
		}),
			Q.languages.insertBefore("markup", "cdata", o);
	},
});
Object.defineProperty(Q.languages.markup.tag, "addAttribute", {
	value: function (t, e) {
		Q.languages.markup.tag.inside["special-attr"].push({
			pattern: RegExp(
				/(^|["'\s])/.source +
					"(?:" +
					t +
					")" +
					/\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source,
				"i",
			),
			lookbehind: !0,
			inside: {
				"attr-name": /^[^\s=]+/,
				"attr-value": {
					pattern: /=[\s\S]+/,
					inside: {
						value: {
							pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
							lookbehind: !0,
							alias: [e, "language-" + e],
							inside: Q.languages[e],
						},
						punctuation: [
							{ pattern: /^=/, alias: "attr-equals" },
							/"|'/,
						],
					},
				},
			},
		});
	},
});
Q.languages.html = Q.languages.markup;
Q.languages.mathml = Q.languages.markup;
Q.languages.svg = Q.languages.markup;
Q.languages.xml = Q.languages.extend("markup", {});
Q.languages.ssml = Q.languages.xml;
Q.languages.atom = Q.languages.xml;
Q.languages.rss = Q.languages.xml;
(function (t) {
	var e =
		/(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
	(t.languages.css = {
		comment: /\/\*[\s\S]*?\*\//,
		atrule: {
			pattern: RegExp(
				"@[\\w-](?:" +
					/[^;{\s"']|\s+(?!\s)/.source +
					"|" +
					e.source +
					")*?" +
					/(?:;|(?=\s*\{))/.source,
			),
			inside: {
				rule: /^@[\w-]+/,
				"selector-function-argument": {
					pattern:
						/(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
					lookbehind: !0,
					alias: "selector",
				},
				keyword: {
					pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
					lookbehind: !0,
				},
			},
		},
		url: {
			pattern: RegExp(
				"\\burl\\((?:" +
					e.source +
					"|" +
					/(?:[^\\\r\n()"']|\\[\s\S])*/.source +
					")\\)",
				"i",
			),
			greedy: !0,
			inside: {
				function: /^url/i,
				punctuation: /^\(|\)$/,
				string: { pattern: RegExp("^" + e.source + "$"), alias: "url" },
			},
		},
		selector: {
			pattern: RegExp(
				`(^|[{}\\s])[^{}\\s](?:[^{};"'\\s]|\\s+(?![\\s{])|` +
					e.source +
					")*(?=\\s*\\{)",
			),
			lookbehind: !0,
		},
		string: { pattern: e, greedy: !0 },
		property: {
			pattern:
				/(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
			lookbehind: !0,
		},
		important: /!important\b/i,
		function: {
			pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
			lookbehind: !0,
		},
		punctuation: /[(){};:,]/,
	}),
		(t.languages.css.atrule.inside.rest = t.languages.css);
	var n = t.languages.markup;
	n && (n.tag.addInlined("style", "css"), n.tag.addAttribute("style", "css"));
})(Q);
(function (t) {
	t.languages.diff = {
		coord: [/^(?:\*{3}|-{3}|\+{3}).*$/m, /^@@.*@@$/m, /^\d.*$/m],
	};
	var e = {
		"deleted-sign": "-",
		"deleted-arrow": "<",
		"inserted-sign": "+",
		"inserted-arrow": ">",
		unchanged: " ",
		diff: "!",
	};
	Object.keys(e).forEach(function (n) {
		var r = e[n],
			i = [];
		/^\w+$/.test(n) || i.push(/\w+/.exec(n)[0]),
			n === "diff" && i.push("bold"),
			(t.languages.diff[n] = {
				pattern: RegExp(
					"^(?:[" +
						r +
						`].*(?:\r
?|
|(?![\\s\\S])))+`,
					"m",
				),
				alias: i,
				inside: {
					line: {
						pattern: /(.)(?=[\s\S]).*(?:\r\n?|\n)?/,
						lookbehind: !0,
					},
					prefix: { pattern: /[\s\S]/, alias: /\w+/.exec(n)[0] },
				},
			});
	}),
		Object.defineProperty(t.languages.diff, "PREFIXES", { value: e });
})(Q);
Q.languages.go = Q.languages.extend("clike", {
	string: {
		pattern: /(^|[^\\])"(?:\\.|[^"\\\r\n])*"|`[^`]*`/,
		lookbehind: !0,
		greedy: !0,
	},
	keyword:
		/\b(?:break|case|chan|const|continue|default|defer|else|fallthrough|for|func|go(?:to)?|if|import|interface|map|package|range|return|select|struct|switch|type|var)\b/,
	boolean: /\b(?:_|false|iota|nil|true)\b/,
	number: [
		/\b0(?:b[01_]+|o[0-7_]+)i?\b/i,
		/\b0x(?:[a-f\d_]+(?:\.[a-f\d_]*)?|\.[a-f\d_]+)(?:p[+-]?\d+(?:_\d+)*)?i?(?!\w)/i,
		/(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.\d[\d_]*)(?:e[+-]?[\d_]+)?i?(?!\w)/i,
	],
	operator:
		/[*\/%^!=]=?|\+[=+]?|-[=-]?|\|[=|]?|&(?:=|&|\^=?)?|>(?:>=?|=)?|<(?:<=?|=|-)?|:=|\.\.\./,
	builtin:
		/\b(?:append|bool|byte|cap|close|complex|complex(?:64|128)|copy|delete|error|float(?:32|64)|u?int(?:8|16|32|64)?|imag|len|make|new|panic|print(?:ln)?|real|recover|rune|string|uintptr)\b/,
});
Q.languages.insertBefore("go", "string", {
	char: { pattern: /'(?:\\.|[^'\\\r\n]){0,10}'/, greedy: !0 },
});
delete Q.languages.go["class-name"];
Q.languages.ini = {
	comment: { pattern: /(^[ \f\t\v]*)[#;][^\n\r]*/m, lookbehind: !0 },
	section: {
		pattern: /(^[ \f\t\v]*)\[[^\n\r\]]*\]?/m,
		lookbehind: !0,
		inside: {
			"section-name": {
				pattern:
					/(^\[[ \f\t\v]*)[^ \f\t\v\]]+(?:[ \f\t\v]+[^ \f\t\v\]]+)*/,
				lookbehind: !0,
				alias: "selector",
			},
			punctuation: /\[|\]/,
		},
	},
	key: {
		pattern:
			/(^[ \f\t\v]*)[^ \f\n\r\t\v=]+(?:[ \f\t\v]+[^ \f\n\r\t\v=]+)*(?=[ \f\t\v]*=)/m,
		lookbehind: !0,
		alias: "attr-name",
	},
	value: {
		pattern: /(=[ \f\t\v]*)[^ \f\n\r\t\v]+(?:[ \f\t\v]+[^ \f\n\r\t\v]+)*/,
		lookbehind: !0,
		alias: "attr-value",
		inside: {
			"inner-value": { pattern: /^("|').+(?=\1$)/, lookbehind: !0 },
		},
	},
	punctuation: /=/,
};
(function (t) {
	var e =
			/\b(?:abstract|assert|boolean|break|byte|case|catch|char|class|const|continue|default|do|double|else|enum|exports|extends|final|finally|float|for|goto|if|implements|import|instanceof|int|interface|long|module|native|new|non-sealed|null|open|opens|package|permits|private|protected|provides|public|record(?!\s*[(){}[\]<>=%~.:,;?+\-*/&|^])|requires|return|sealed|short|static|strictfp|super|switch|synchronized|this|throw|throws|to|transient|transitive|try|uses|var|void|volatile|while|with|yield)\b/,
		n = /(?:[a-z]\w*\s*\.\s*)*(?:[A-Z]\w*\s*\.\s*)*/.source,
		r = {
			pattern: RegExp(
				/(^|[^\w.])/.source +
					n +
					/[A-Z](?:[\d_A-Z]*[a-z]\w*)?\b/.source,
			),
			lookbehind: !0,
			inside: {
				namespace: {
					pattern: /^[a-z]\w*(?:\s*\.\s*[a-z]\w*)*(?:\s*\.)?/,
					inside: { punctuation: /\./ },
				},
				punctuation: /\./,
			},
		};
	(t.languages.java = t.languages.extend("clike", {
		string: {
			pattern: /(^|[^\\])"(?:\\.|[^"\\\r\n])*"/,
			lookbehind: !0,
			greedy: !0,
		},
		"class-name": [
			r,
			{
				pattern: RegExp(
					/(^|[^\w.])/.source +
						n +
						/[A-Z]\w*(?=\s+\w+\s*[;,=()]|\s*(?:\[[\s,]*\]\s*)?::\s*new\b)/
							.source,
				),
				lookbehind: !0,
				inside: r.inside,
			},
			{
				pattern: RegExp(
					/(\b(?:class|enum|extends|implements|instanceof|interface|new|record|throws)\s+)/
						.source +
						n +
						/[A-Z]\w*\b/.source,
				),
				lookbehind: !0,
				inside: r.inside,
			},
		],
		keyword: e,
		function: [
			t.languages.clike.function,
			{ pattern: /(::\s*)[a-z_]\w*/, lookbehind: !0 },
		],
		number: /\b0b[01][01_]*L?\b|\b0x(?:\.[\da-f_p+-]+|[\da-f_]+(?:\.[\da-f_p+-]+)?)\b|(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.\d[\d_]*)(?:e[+-]?\d[\d_]*)?[dfl]?/i,
		operator: {
			pattern:
				/(^|[^.])(?:<<=?|>>>?=?|->|--|\+\+|&&|\|\||::|[?:~]|[-+*/%&|^!=<>]=?)/m,
			lookbehind: !0,
		},
		constant: /\b[A-Z][A-Z_\d]+\b/,
	})),
		t.languages.insertBefore("java", "string", {
			"triple-quoted-string": {
				pattern: /"""[ \t]*[\r\n](?:(?:"|"")?(?:\\.|[^"\\]))*"""/,
				greedy: !0,
				alias: "string",
			},
			char: { pattern: /'(?:\\.|[^'\\\r\n]){1,6}'/, greedy: !0 },
		}),
		t.languages.insertBefore("java", "class-name", {
			annotation: {
				pattern: /(^|[^.])@\w+(?:\s*\.\s*\w+)*/,
				lookbehind: !0,
				alias: "punctuation",
			},
			generics: {
				pattern:
					/<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&))*>)*>)*>)*>/,
				inside: {
					"class-name": r,
					keyword: e,
					punctuation: /[<>(),.:]/,
					operator: /[?&|]/,
				},
			},
			import: [
				{
					pattern: RegExp(
						/(\bimport\s+)/.source +
							n +
							/(?:[A-Z]\w*|\*)(?=\s*;)/.source,
					),
					lookbehind: !0,
					inside: {
						namespace: r.inside.namespace,
						punctuation: /\./,
						operator: /\*/,
						"class-name": /\w+/,
					},
				},
				{
					pattern: RegExp(
						/(\bimport\s+static\s+)/.source +
							n +
							/(?:\w+|\*)(?=\s*;)/.source,
					),
					lookbehind: !0,
					alias: "static",
					inside: {
						namespace: r.inside.namespace,
						static: /\b\w+$/,
						punctuation: /\./,
						operator: /\*/,
						"class-name": /\w+/,
					},
				},
			],
			namespace: {
				pattern: RegExp(
					/(\b(?:exports|import(?:\s+static)?|module|open|opens|package|provides|requires|to|transitive|uses|with)\s+)(?!<keyword>)[a-z]\w*(?:\.[a-z]\w*)*\.?/.source.replace(
						/<keyword>/g,
						function () {
							return e.source;
						},
					),
				),
				lookbehind: !0,
				inside: { punctuation: /\./ },
			},
		});
})(Q);
(function (t) {
	var e = { pattern: /\\[\\(){}[\]^$+*?|.]/, alias: "escape" },
		n =
			/\\(?:x[\da-fA-F]{2}|u[\da-fA-F]{4}|u\{[\da-fA-F]+\}|0[0-7]{0,2}|[123][0-7]{2}|c[a-zA-Z]|.)/,
		r = { pattern: /\.|\\[wsd]|\\p\{[^{}]+\}/i, alias: "class-name" },
		i = { pattern: /\\[wsd]|\\p\{[^{}]+\}/i, alias: "class-name" },
		o = "(?:[^\\\\-]|" + n.source + ")",
		s = RegExp(o + "-" + o),
		a = {
			pattern: /(<|')[^<>']+(?=[>']$)/,
			lookbehind: !0,
			alias: "variable",
		};
	t.languages.regex = {
		"char-class": {
			pattern: /((?:^|[^\\])(?:\\\\)*)\[(?:[^\\\]]|\\[\s\S])*\]/,
			lookbehind: !0,
			inside: {
				"char-class-negation": {
					pattern: /(^\[)\^/,
					lookbehind: !0,
					alias: "operator",
				},
				"char-class-punctuation": {
					pattern: /^\[|\]$/,
					alias: "punctuation",
				},
				range: {
					pattern: s,
					inside: {
						escape: n,
						"range-punctuation": {
							pattern: /-/,
							alias: "operator",
						},
					},
				},
				"special-escape": e,
				"char-set": i,
				escape: n,
			},
		},
		"special-escape": e,
		"char-set": r,
		backreference: [
			{ pattern: /\\(?![123][0-7]{2})[1-9]/, alias: "keyword" },
			{
				pattern: /\\k<[^<>']+>/,
				alias: "keyword",
				inside: { "group-name": a },
			},
		],
		anchor: { pattern: /[$^]|\\[ABbGZz]/, alias: "function" },
		escape: n,
		group: [
			{
				pattern:
					/\((?:\?(?:<[^<>']+>|'[^<>']+'|[>:]|<?[=!]|[idmnsuxU]+(?:-[idmnsuxU]+)?:?))?/,
				alias: "punctuation",
				inside: { "group-name": a },
			},
			{ pattern: /\)/, alias: "punctuation" },
		],
		quantifier: {
			pattern: /(?:[+*?]|\{\d+(?:,\d*)?\})[?+]?/,
			alias: "number",
		},
		alternation: { pattern: /\|/, alias: "keyword" },
	};
})(Q);
Q.languages.javascript = Q.languages.extend("clike", {
	"class-name": [
		Q.languages.clike["class-name"],
		{
			pattern:
				/(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
			lookbehind: !0,
		},
	],
	keyword: [
		{ pattern: /((?:^|\})\s*)catch\b/, lookbehind: !0 },
		{
			pattern:
				/(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
			lookbehind: !0,
		},
	],
	function:
		/#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
	number: {
		pattern: RegExp(
			/(^|[^\w$])/.source +
				"(?:" +
				(/NaN|Infinity/.source +
					"|" +
					/0[bB][01]+(?:_[01]+)*n?/.source +
					"|" +
					/0[oO][0-7]+(?:_[0-7]+)*n?/.source +
					"|" +
					/0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source +
					"|" +
					/\d+(?:_\d+)*n/.source +
					"|" +
					/(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/
						.source) +
				")" +
				/(?![\w$])/.source,
		),
		lookbehind: !0,
	},
	operator:
		/--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/,
});
Q.languages.javascript["class-name"][0].pattern =
	/(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/;
Q.languages.insertBefore("javascript", "keyword", {
	regex: {
		pattern: RegExp(
			/((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source +
				/\//.source +
				"(?:" +
				/(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/
					.source +
				"|" +
				/(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/
					.source +
				")" +
				/(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/
					.source,
		),
		lookbehind: !0,
		greedy: !0,
		inside: {
			"regex-source": {
				pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
				lookbehind: !0,
				alias: "language-regex",
				inside: Q.languages.regex,
			},
			"regex-delimiter": /^\/|\/$/,
			"regex-flags": /^[a-z]+$/,
		},
	},
	"function-variable": {
		pattern:
			/#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
		alias: "function",
	},
	parameter: [
		{
			pattern:
				/(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
			lookbehind: !0,
			inside: Q.languages.javascript,
		},
		{
			pattern:
				/(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
			lookbehind: !0,
			inside: Q.languages.javascript,
		},
		{
			pattern:
				/(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
			lookbehind: !0,
			inside: Q.languages.javascript,
		},
		{
			pattern:
				/((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
			lookbehind: !0,
			inside: Q.languages.javascript,
		},
	],
	constant: /\b[A-Z](?:[A-Z_]|\dx?)*\b/,
});
Q.languages.insertBefore("javascript", "string", {
	hashbang: { pattern: /^#!.*/, greedy: !0, alias: "comment" },
	"template-string": {
		pattern:
			/`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
		greedy: !0,
		inside: {
			"template-punctuation": { pattern: /^`|`$/, alias: "string" },
			interpolation: {
				pattern:
					/((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
				lookbehind: !0,
				inside: {
					"interpolation-punctuation": {
						pattern: /^\$\{|\}$/,
						alias: "punctuation",
					},
					rest: Q.languages.javascript,
				},
			},
			string: /[\s\S]+/,
		},
	},
	"string-property": {
		pattern:
			/((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
		lookbehind: !0,
		greedy: !0,
		alias: "property",
	},
});
Q.languages.insertBefore("javascript", "operator", {
	"literal-property": {
		pattern:
			/((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
		lookbehind: !0,
		alias: "property",
	},
});
Q.languages.markup &&
	(Q.languages.markup.tag.addInlined("script", "javascript"),
	Q.languages.markup.tag.addAttribute(
		/on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/
			.source,
		"javascript",
	));
Q.languages.js = Q.languages.javascript;
(function (t) {
	var e = t.util.clone(t.languages.javascript),
		n = /(?:\s|\/\/.*(?!.)|\/\*(?:[^*]|\*(?!\/))\*\/)/.source,
		r = /(?:\{(?:\{(?:\{[^{}]*\}|[^{}])*\}|[^{}])*\})/.source,
		i = /(?:\{<S>*\.{3}(?:[^{}]|<BRACES>)*\})/.source;
	function o(l, u) {
		return (
			(l = l
				.replace(/<S>/g, function () {
					return n;
				})
				.replace(/<BRACES>/g, function () {
					return r;
				})
				.replace(/<SPREAD>/g, function () {
					return i;
				})),
			RegExp(l, u)
		);
	}
	(i = o(i).source),
		(t.languages.jsx = t.languages.extend("markup", e)),
		(t.languages.jsx.tag.pattern = o(
			/<\/?(?:[\w.:-]+(?:<S>+(?:[\w.:$-]+(?:=(?:"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*'|[^\s{'"/>=]+|<BRACES>))?|<SPREAD>))*<S>*\/?)?>/
				.source,
		)),
		(t.languages.jsx.tag.inside.tag.pattern = /^<\/?[^\s>\/]*/),
		(t.languages.jsx.tag.inside["attr-value"].pattern =
			/=(?!\{)(?:"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*'|[^\s'">]+)/),
		(t.languages.jsx.tag.inside.tag.inside["class-name"] =
			/^[A-Z]\w*(?:\.[A-Z]\w*)*$/),
		(t.languages.jsx.tag.inside.comment = e.comment),
		t.languages.insertBefore(
			"inside",
			"attr-name",
			{
				spread: {
					pattern: o(/<SPREAD>/.source),
					inside: t.languages.jsx,
				},
			},
			t.languages.jsx.tag,
		),
		t.languages.insertBefore(
			"inside",
			"special-attr",
			{
				script: {
					pattern: o(/=<BRACES>/.source),
					alias: "language-javascript",
					inside: {
						"script-punctuation": {
							pattern: /^=(?=\{)/,
							alias: "punctuation",
						},
						rest: t.languages.jsx,
					},
				},
			},
			t.languages.jsx.tag,
		);
	var s = function (l) {
			return l
				? typeof l == "string"
					? l
					: typeof l.content == "string"
						? l.content
						: l.content.map(s).join("")
				: "";
		},
		a = function (l) {
			for (var u = [], c = 0; c < l.length; c++) {
				var d = l[c],
					f = !1;
				if (
					(typeof d != "string" &&
						(d.type === "tag" &&
						d.content[0] &&
						d.content[0].type === "tag"
							? d.content[0].content[0].content === "</"
								? u.length > 0 &&
									u[u.length - 1].tagName ===
										s(d.content[0].content[1]) &&
									u.pop()
								: d.content[d.content.length - 1].content ===
										"/>" ||
									u.push({
										tagName: s(d.content[0].content[1]),
										openedBraces: 0,
									})
							: u.length > 0 &&
								  d.type === "punctuation" &&
								  d.content === "{"
								? u[u.length - 1].openedBraces++
								: u.length > 0 &&
									  u[u.length - 1].openedBraces > 0 &&
									  d.type === "punctuation" &&
									  d.content === "}"
									? u[u.length - 1].openedBraces--
									: (f = !0)),
					(f || typeof d == "string") &&
						u.length > 0 &&
						u[u.length - 1].openedBraces === 0)
				) {
					var h = s(d);
					c < l.length - 1 &&
						(typeof l[c + 1] == "string" ||
							l[c + 1].type === "plain-text") &&
						((h += s(l[c + 1])), l.splice(c + 1, 1)),
						c > 0 &&
							(typeof l[c - 1] == "string" ||
								l[c - 1].type === "plain-text") &&
							((h = s(l[c - 1]) + h), l.splice(c - 1, 1), c--),
						(l[c] = new t.Token("plain-text", h, null, h));
				}
				d.content && typeof d.content != "string" && a(d.content);
			}
		};
	t.hooks.add("after-tokenize", function (l) {
		(l.language !== "jsx" && l.language !== "tsx") || a(l.tokens);
	});
})(Q);
Q.languages.json = {
	property: {
		pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?=\s*:)/,
		lookbehind: !0,
		greedy: !0,
	},
	string: {
		pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?!\s*:)/,
		lookbehind: !0,
		greedy: !0,
	},
	comment: { pattern: /\/\/.*|\/\*[\s\S]*?(?:\*\/|$)/, greedy: !0 },
	number: /-?\b\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i,
	punctuation: /[{}[\],]/,
	operator: /:/,
	boolean: /\b(?:false|true)\b/,
	null: { pattern: /\bnull\b/, alias: "keyword" },
};
Q.languages.webmanifest = Q.languages.json;
(function (t) {
	(t.languages.kotlin = t.languages.extend("clike", {
		keyword: {
			pattern:
				/(^|[^.])\b(?:abstract|actual|annotation|as|break|by|catch|class|companion|const|constructor|continue|crossinline|data|do|dynamic|else|enum|expect|external|final|finally|for|fun|get|if|import|in|infix|init|inline|inner|interface|internal|is|lateinit|noinline|null|object|open|operator|out|override|package|private|protected|public|reified|return|sealed|set|super|suspend|tailrec|this|throw|to|try|typealias|val|var|vararg|when|where|while)\b/,
			lookbehind: !0,
		},
		function: [
			{ pattern: /(?:`[^\r\n`]+`|\b\w+)(?=\s*\()/, greedy: !0 },
			{
				pattern: /(\.)(?:`[^\r\n`]+`|\w+)(?=\s*\{)/,
				lookbehind: !0,
				greedy: !0,
			},
		],
		number: /\b(?:0[xX][\da-fA-F]+(?:_[\da-fA-F]+)*|0[bB][01]+(?:_[01]+)*|\d+(?:_\d+)*(?:\.\d+(?:_\d+)*)?(?:[eE][+-]?\d+(?:_\d+)*)?[fFL]?)\b/,
		operator:
			/\+[+=]?|-[-=>]?|==?=?|!(?:!|==?)?|[\/*%<>]=?|[?:]:?|\.\.|&&|\|\||\b(?:and|inv|or|shl|shr|ushr|xor)\b/,
	})),
		delete t.languages.kotlin["class-name"];
	var e = {
		"interpolation-punctuation": {
			pattern: /^\$\{?|\}$/,
			alias: "punctuation",
		},
		expression: { pattern: /[\s\S]+/, inside: t.languages.kotlin },
	};
	t.languages.insertBefore("kotlin", "string", {
		"string-literal": [
			{
				pattern: /"""(?:[^$]|\$(?:(?!\{)|\{[^{}]*\}))*?"""/,
				alias: "multiline",
				inside: {
					interpolation: {
						pattern: /\$(?:[a-z_]\w*|\{[^{}]*\})/i,
						inside: e,
					},
					string: /[\s\S]+/,
				},
			},
			{
				pattern: /"(?:[^"\\\r\n$]|\\.|\$(?:(?!\{)|\{[^{}]*\}))*"/,
				alias: "singleline",
				inside: {
					interpolation: {
						pattern:
							/((?:^|[^\\])(?:\\{2})*)\$(?:[a-z_]\w*|\{[^{}]*\})/i,
						lookbehind: !0,
						inside: e,
					},
					string: /[\s\S]+/,
				},
			},
		],
		char: {
			pattern: /'(?:[^'\\\r\n]|\\(?:.|u[a-fA-F0-9]{0,4}))'/,
			greedy: !0,
		},
	}),
		delete t.languages.kotlin.string,
		t.languages.insertBefore("kotlin", "keyword", {
			annotation: {
				pattern: /\B@(?:\w+:)?(?:[A-Z]\w*|\[[^\]]+\])/,
				alias: "builtin",
			},
		}),
		t.languages.insertBefore("kotlin", "function", {
			label: { pattern: /\b\w+@|@\w+\b/, alias: "symbol" },
		}),
		(t.languages.kt = t.languages.kotlin),
		(t.languages.kts = t.languages.kotlin);
})(Q);
Q.languages.less = Q.languages.extend("css", {
	comment: [
		/\/\*[\s\S]*?\*\//,
		{ pattern: /(^|[^\\])\/\/.*/, lookbehind: !0 },
	],
	atrule: {
		pattern:
			/@[\w-](?:\((?:[^(){}]|\([^(){}]*\))*\)|[^(){};\s]|\s+(?!\s))*?(?=\s*\{)/,
		inside: { punctuation: /[:()]/ },
	},
	selector: {
		pattern:
			/(?:@\{[\w-]+\}|[^{};\s@])(?:@\{[\w-]+\}|\((?:[^(){}]|\([^(){}]*\))*\)|[^(){};@\s]|\s+(?!\s))*?(?=\s*\{)/,
		inside: { variable: /@+[\w-]+/ },
	},
	property: /(?:@\{[\w-]+\}|[\w-])+(?:\+_?)?(?=\s*:)/,
	operator: /[+\-*\/]/,
});
Q.languages.insertBefore("less", "property", {
	variable: [
		{ pattern: /@[\w-]+\s*:/, inside: { punctuation: /:/ } },
		/@@?[\w-]+/,
	],
	"mixin-usage": {
		pattern: /([{;]\s*)[.#](?!\d)[\w-].*?(?=[(;])/,
		lookbehind: !0,
		alias: "function",
	},
});
Q.languages.lua = {
	comment: /^#!.+|--(?:\[(=*)\[[\s\S]*?\]\1\]|.*)/m,
	string: {
		pattern:
			/(["'])(?:(?!\1)[^\\\r\n]|\\z(?:\r\n|\s)|\\(?:\r\n|[^z]))*\1|\[(=*)\[[\s\S]*?\]\2\]/,
		greedy: !0,
	},
	number: /\b0x[a-f\d]+(?:\.[a-f\d]*)?(?:p[+-]?\d+)?\b|\b\d+(?:\.\B|(?:\.\d*)?(?:e[+-]?\d+)?\b)|\B\.\d+(?:e[+-]?\d+)?\b/i,
	keyword:
		/\b(?:and|break|do|else|elseif|end|false|for|function|goto|if|in|local|nil|not|or|repeat|return|then|true|until|while)\b/,
	function: /(?!\d)\w+(?=\s*(?:[({]))/,
	operator: [
		/[-+*%^&|#]|\/\/?|<[<=]?|>[>=]?|[=~]=?/,
		{ pattern: /(^|[^.])\.\.(?!\.)/, lookbehind: !0 },
	],
	punctuation: /[\[\](){},;]|\.+|:+/,
};
Q.languages.makefile = {
	comment: {
		pattern: /(^|[^\\])#(?:\\(?:\r\n|[\s\S])|[^\\\r\n])*/,
		lookbehind: !0,
	},
	string: {
		pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
		greedy: !0,
	},
	"builtin-target": {
		pattern: /\.[A-Z][^:#=\s]+(?=\s*:(?!=))/,
		alias: "builtin",
	},
	target: {
		pattern: /^(?:[^:=\s]|[ \t]+(?![\s:]))+(?=\s*:(?!=))/m,
		alias: "symbol",
		inside: { variable: /\$+(?:(?!\$)[^(){}:#=\s]+|(?=[({]))/ },
	},
	variable: /\$+(?:(?!\$)[^(){}:#=\s]+|\([@*%<^+?][DF]\)|(?=[({]))/,
	keyword:
		/-include\b|\b(?:define|else|endef|endif|export|ifn?def|ifn?eq|include|override|private|sinclude|undefine|unexport|vpath)\b/,
	function: {
		pattern:
			/(\()(?:abspath|addsuffix|and|basename|call|dir|error|eval|file|filter(?:-out)?|findstring|firstword|flavor|foreach|guile|if|info|join|lastword|load|notdir|or|origin|patsubst|realpath|shell|sort|strip|subst|suffix|value|warning|wildcard|word(?:list|s)?)(?=[ \t])/,
		lookbehind: !0,
	},
	operator: /(?:::|[?:+!])?=|[|@]/,
	punctuation: /[:;(){}]/,
};
(function (t) {
	var e = /[*&][^\s[\]{},]+/,
		n =
			/!(?:<[\w\-%#;/?:@&=+$,.!~*'()[\]]+>|(?:[a-zA-Z\d-]*!)?[\w\-%#;/?:@&=+$.~*'()]+)?/,
		r =
			"(?:" +
			n.source +
			"(?:[ 	]+" +
			e.source +
			")?|" +
			e.source +
			"(?:[ 	]+" +
			n.source +
			")?)",
		i =
			/(?:[^\s\x00-\x08\x0e-\x1f!"#%&'*,\-:>?@[\]`{|}\x7f-\x84\x86-\x9f\ud800-\udfff\ufffe\uffff]|[?:-]<PLAIN>)(?:[ \t]*(?:(?![#:])<PLAIN>|:<PLAIN>))*/.source.replace(
				/<PLAIN>/g,
				function () {
					return /[^\s\x00-\x08\x0e-\x1f,[\]{}\x7f-\x84\x86-\x9f\ud800-\udfff\ufffe\uffff]/
						.source;
				},
			),
		o = /"(?:[^"\\\r\n]|\\.)*"|'(?:[^'\\\r\n]|\\.)*'/.source;
	function s(a, l) {
		l = (l || "").replace(/m/g, "") + "m";
		var u =
			/([:\-,[{]\s*(?:\s<<prop>>[ \t]+)?)(?:<<value>>)(?=[ \t]*(?:$|,|\]|\}|(?:[\r\n]\s*)?#))/.source
				.replace(/<<prop>>/g, function () {
					return r;
				})
				.replace(/<<value>>/g, function () {
					return a;
				});
		return RegExp(u, l);
	}
	(t.languages.yaml = {
		scalar: {
			pattern: RegExp(
				/([\-:]\s*(?:\s<<prop>>[ \t]+)?[|>])[ \t]*(?:((?:\r?\n|\r)[ \t]+)\S[^\r\n]*(?:\2[^\r\n]+)*)/.source.replace(
					/<<prop>>/g,
					function () {
						return r;
					},
				),
			),
			lookbehind: !0,
			alias: "string",
		},
		comment: /#.*/,
		key: {
			pattern: RegExp(
				/((?:^|[:\-,[{\r\n?])[ \t]*(?:<<prop>>[ \t]+)?)<<key>>(?=\s*:\s)/.source
					.replace(/<<prop>>/g, function () {
						return r;
					})
					.replace(/<<key>>/g, function () {
						return "(?:" + i + "|" + o + ")";
					}),
			),
			lookbehind: !0,
			greedy: !0,
			alias: "atrule",
		},
		directive: {
			pattern: /(^[ \t]*)%.+/m,
			lookbehind: !0,
			alias: "important",
		},
		datetime: {
			pattern: s(
				/\d{4}-\d\d?-\d\d?(?:[tT]|[ \t]+)\d\d?:\d{2}:\d{2}(?:\.\d*)?(?:[ \t]*(?:Z|[-+]\d\d?(?::\d{2})?))?|\d{4}-\d{2}-\d{2}|\d\d?:\d{2}(?::\d{2}(?:\.\d*)?)?/
					.source,
			),
			lookbehind: !0,
			alias: "number",
		},
		boolean: {
			pattern: s(/false|true/.source, "i"),
			lookbehind: !0,
			alias: "important",
		},
		null: {
			pattern: s(/null|~/.source, "i"),
			lookbehind: !0,
			alias: "important",
		},
		string: { pattern: s(o), lookbehind: !0, greedy: !0 },
		number: {
			pattern: s(
				/[+-]?(?:0x[\da-f]+|0o[0-7]+|(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?|\.inf|\.nan)/
					.source,
				"i",
			),
			lookbehind: !0,
		},
		tag: n,
		important: e,
		punctuation: /---|[:[\]{}\-,|>?]|\.\.\./,
	}),
		(t.languages.yml = t.languages.yaml);
})(Q);
(function (t) {
	var e = /(?:\\.|[^\\\n\r]|(?:\n|\r\n?)(?![\r\n]))/.source;
	function n(c) {
		return (
			(c = c.replace(/<inner>/g, function () {
				return e;
			})),
			RegExp(/((?:^|[^\\])(?:\\{2})*)/.source + "(?:" + c + ")")
		);
	}
	var r = /(?:\\.|``(?:[^`\r\n]|`(?!`))+``|`[^`\r\n]+`|[^\\|\r\n`])+/.source,
		i = /\|?__(?:\|__)+\|?(?:(?:\n|\r\n?)|(?![\s\S]))/.source.replace(
			/__/g,
			function () {
				return r;
			},
		),
		o =
			/\|?[ \t]*:?-{3,}:?[ \t]*(?:\|[ \t]*:?-{3,}:?[ \t]*)+\|?(?:\n|\r\n?)/
				.source;
	(t.languages.markdown = t.languages.extend("markup", {})),
		t.languages.insertBefore("markdown", "prolog", {
			"front-matter-block": {
				pattern: /(^(?:\s*[\r\n])?)---(?!.)[\s\S]*?[\r\n]---(?!.)/,
				lookbehind: !0,
				greedy: !0,
				inside: {
					punctuation: /^---|---$/,
					"front-matter": {
						pattern: /\S+(?:\s+\S+)*/,
						alias: ["yaml", "language-yaml"],
						inside: t.languages.yaml,
					},
				},
			},
			blockquote: { pattern: /^>(?:[\t ]*>)*/m, alias: "punctuation" },
			table: {
				pattern: RegExp("^" + i + o + "(?:" + i + ")*", "m"),
				inside: {
					"table-data-rows": {
						pattern: RegExp("^(" + i + o + ")(?:" + i + ")*$"),
						lookbehind: !0,
						inside: {
							"table-data": {
								pattern: RegExp(r),
								inside: t.languages.markdown,
							},
							punctuation: /\|/,
						},
					},
					"table-line": {
						pattern: RegExp("^(" + i + ")" + o + "$"),
						lookbehind: !0,
						inside: { punctuation: /\||:?-{3,}:?/ },
					},
					"table-header-row": {
						pattern: RegExp("^" + i + "$"),
						inside: {
							"table-header": {
								pattern: RegExp(r),
								alias: "important",
								inside: t.languages.markdown,
							},
							punctuation: /\|/,
						},
					},
				},
			},
			code: [
				{
					pattern:
						/((?:^|\n)[ \t]*\n|(?:^|\r\n?)[ \t]*\r\n?)(?: {4}|\t).+(?:(?:\n|\r\n?)(?: {4}|\t).+)*/,
					lookbehind: !0,
					alias: "keyword",
				},
				{
					pattern: /^```[\s\S]*?^```$/m,
					greedy: !0,
					inside: {
						"code-block": {
							pattern:
								/^(```.*(?:\n|\r\n?))[\s\S]+?(?=(?:\n|\r\n?)^```$)/m,
							lookbehind: !0,
						},
						"code-language": {
							pattern: /^(```).+/,
							lookbehind: !0,
						},
						punctuation: /```/,
					},
				},
			],
			title: [
				{
					pattern: /\S.*(?:\n|\r\n?)(?:==+|--+)(?=[ \t]*$)/m,
					alias: "important",
					inside: { punctuation: /==+$|--+$/ },
				},
				{
					pattern: /(^\s*)#.+/m,
					lookbehind: !0,
					alias: "important",
					inside: { punctuation: /^#+|#+$/ },
				},
			],
			hr: {
				pattern: /(^\s*)([*-])(?:[\t ]*\2){2,}(?=\s*$)/m,
				lookbehind: !0,
				alias: "punctuation",
			},
			list: {
				pattern: /(^\s*)(?:[*+-]|\d+\.)(?=[\t ].)/m,
				lookbehind: !0,
				alias: "punctuation",
			},
			"url-reference": {
				pattern:
					/!?\[[^\]]+\]:[\t ]+(?:\S+|<(?:\\.|[^>\\])+>)(?:[\t ]+(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\)))?/,
				inside: {
					variable: { pattern: /^(!?\[)[^\]]+/, lookbehind: !0 },
					string: /(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\))$/,
					punctuation: /^[\[\]!:]|[<>]/,
				},
				alias: "url",
			},
			bold: {
				pattern: n(
					/\b__(?:(?!_)<inner>|_(?:(?!_)<inner>)+_)+__\b|\*\*(?:(?!\*)<inner>|\*(?:(?!\*)<inner>)+\*)+\*\*/
						.source,
				),
				lookbehind: !0,
				greedy: !0,
				inside: {
					content: {
						pattern: /(^..)[\s\S]+(?=..$)/,
						lookbehind: !0,
						inside: {},
					},
					punctuation: /\*\*|__/,
				},
			},
			italic: {
				pattern: n(
					/\b_(?:(?!_)<inner>|__(?:(?!_)<inner>)+__)+_\b|\*(?:(?!\*)<inner>|\*\*(?:(?!\*)<inner>)+\*\*)+\*/
						.source,
				),
				lookbehind: !0,
				greedy: !0,
				inside: {
					content: {
						pattern: /(^.)[\s\S]+(?=.$)/,
						lookbehind: !0,
						inside: {},
					},
					punctuation: /[*_]/,
				},
			},
			strike: {
				pattern: n(/(~~?)(?:(?!~)<inner>)+\2/.source),
				lookbehind: !0,
				greedy: !0,
				inside: {
					content: {
						pattern: /(^~~?)[\s\S]+(?=\1$)/,
						lookbehind: !0,
						inside: {},
					},
					punctuation: /~~?/,
				},
			},
			"code-snippet": {
				pattern:
					/(^|[^\\`])(?:``[^`\r\n]+(?:`[^`\r\n]+)*``(?!`)|`[^`\r\n]+`(?!`))/,
				lookbehind: !0,
				greedy: !0,
				alias: ["code", "keyword"],
			},
			url: {
				pattern: n(
					/!?\[(?:(?!\])<inner>)+\](?:\([^\s)]+(?:[\t ]+"(?:\\.|[^"\\])*")?\)|[ \t]?\[(?:(?!\])<inner>)+\])/
						.source,
				),
				lookbehind: !0,
				greedy: !0,
				inside: {
					operator: /^!/,
					content: {
						pattern: /(^\[)[^\]]+(?=\])/,
						lookbehind: !0,
						inside: {},
					},
					variable: {
						pattern: /(^\][ \t]?\[)[^\]]+(?=\]$)/,
						lookbehind: !0,
					},
					url: { pattern: /(^\]\()[^\s)]+/, lookbehind: !0 },
					string: {
						pattern: /(^[ \t]+)"(?:\\.|[^"\\])*"(?=\)$)/,
						lookbehind: !0,
					},
				},
			},
		}),
		["url", "bold", "italic", "strike"].forEach(function (c) {
			["url", "bold", "italic", "strike", "code-snippet"].forEach(
				function (d) {
					c !== d &&
						(t.languages.markdown[c].inside.content.inside[d] =
							t.languages.markdown[d]);
				},
			);
		}),
		t.hooks.add("after-tokenize", function (c) {
			if (c.language !== "markdown" && c.language !== "md") return;
			function d(f) {
				if (!(!f || typeof f == "string"))
					for (var h = 0, p = f.length; h < p; h++) {
						var g = f[h];
						if (g.type !== "code") {
							d(g.content);
							continue;
						}
						var v = g.content[1],
							b = g.content[3];
						if (
							v &&
							b &&
							v.type === "code-language" &&
							b.type === "code-block" &&
							typeof v.content == "string"
						) {
							var y = v.content
								.replace(/\b#/g, "sharp")
								.replace(/\b\+\+/g, "pp");
							y = (/[a-z][\w-]*/i.exec(y) || [
								"",
							])[0].toLowerCase();
							var x = "language-" + y;
							b.alias
								? typeof b.alias == "string"
									? (b.alias = [b.alias, x])
									: b.alias.push(x)
								: (b.alias = [x]);
						}
					}
			}
			d(c.tokens);
		}),
		t.hooks.add("wrap", function (c) {
			if (c.type === "code-block") {
				for (var d = "", f = 0, h = c.classes.length; f < h; f++) {
					var p = c.classes[f],
						g = /language-(.+)/.exec(p);
					if (g) {
						d = g[1];
						break;
					}
				}
				var v = t.languages[d];
				if (v) c.content = t.highlight(u(c.content), v, d);
				else if (d && d !== "none" && t.plugins.autoloader) {
					var b =
						"md-" +
						new Date().valueOf() +
						"-" +
						Math.floor(Math.random() * 1e16);
					(c.attributes.id = b),
						t.plugins.autoloader.loadLanguages(d, function () {
							var y = document.getElementById(b);
							y &&
								(y.innerHTML = t.highlight(
									y.textContent,
									t.languages[d],
									d,
								));
						});
				}
			}
		});
	var s = RegExp(t.languages.markup.tag.pattern.source, "gi"),
		a = { amp: "&", lt: "<", gt: ">", quot: '"' },
		l = String.fromCodePoint || String.fromCharCode;
	function u(c) {
		var d = c.replace(s, "");
		return (
			(d = d.replace(/&(\w{1,8}|#x?[\da-f]{1,8});/gi, function (f, h) {
				if (((h = h.toLowerCase()), h[0] === "#")) {
					var p;
					return (
						h[1] === "x"
							? (p = parseInt(h.slice(2), 16))
							: (p = Number(h.slice(1))),
						l(p)
					);
				} else {
					var g = a[h];
					return g || f;
				}
			})),
			d
		);
	}
	t.languages.md = t.languages.markdown;
})(Q);
Q.languages.objectivec = Q.languages.extend("c", {
	string: { pattern: /@?"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/, greedy: !0 },
	keyword:
		/\b(?:asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|in|inline|int|long|register|return|self|short|signed|sizeof|static|struct|super|switch|typedef|typeof|union|unsigned|void|volatile|while)\b|(?:@interface|@end|@implementation|@protocol|@class|@public|@protected|@private|@property|@try|@catch|@finally|@throw|@synthesize|@dynamic|@selector)\b/,
	operator: /-[->]?|\+\+?|!=?|<<?=?|>>?=?|==?|&&?|\|\|?|[~^%?*\/@]/,
});
delete Q.languages.objectivec["class-name"];
Q.languages.objc = Q.languages.objectivec;
(function (t) {
	var e =
		/(?:\((?:[^()\\]|\\[\s\S])*\)|\{(?:[^{}\\]|\\[\s\S])*\}|\[(?:[^[\]\\]|\\[\s\S])*\]|<(?:[^<>\\]|\\[\s\S])*>)/
			.source;
	t.languages.perl = {
		comment: [
			{ pattern: /(^\s*)=\w[\s\S]*?=cut.*/m, lookbehind: !0, greedy: !0 },
			{ pattern: /(^|[^\\$])#.*/, lookbehind: !0, greedy: !0 },
		],
		string: [
			{
				pattern: RegExp(
					/\b(?:q|qq|qw|qx)(?![a-zA-Z0-9])\s*/.source +
						"(?:" +
						[
							/([^a-zA-Z0-9\s{(\[<])(?:(?!\1)[^\\]|\\[\s\S])*\1/
								.source,
							/([a-zA-Z0-9])(?:(?!\2)[^\\]|\\[\s\S])*\2/.source,
							e,
						].join("|") +
						")",
				),
				greedy: !0,
			},
			{ pattern: /("|`)(?:(?!\1)[^\\]|\\[\s\S])*\1/, greedy: !0 },
			{ pattern: /'(?:[^'\\\r\n]|\\.)*'/, greedy: !0 },
		],
		regex: [
			{
				pattern: RegExp(
					/\b(?:m|qr)(?![a-zA-Z0-9])\s*/.source +
						"(?:" +
						[
							/([^a-zA-Z0-9\s{(\[<])(?:(?!\1)[^\\]|\\[\s\S])*\1/
								.source,
							/([a-zA-Z0-9])(?:(?!\2)[^\\]|\\[\s\S])*\2/.source,
							e,
						].join("|") +
						")" +
						/[msixpodualngc]*/.source,
				),
				greedy: !0,
			},
			{
				pattern: RegExp(
					/(^|[^-])\b(?:s|tr|y)(?![a-zA-Z0-9])\s*/.source +
						"(?:" +
						[
							/([^a-zA-Z0-9\s{(\[<])(?:(?!\2)[^\\]|\\[\s\S])*\2(?:(?!\2)[^\\]|\\[\s\S])*\2/
								.source,
							/([a-zA-Z0-9])(?:(?!\3)[^\\]|\\[\s\S])*\3(?:(?!\3)[^\\]|\\[\s\S])*\3/
								.source,
							e + /\s*/.source + e,
						].join("|") +
						")" +
						/[msixpodualngcer]*/.source,
				),
				lookbehind: !0,
				greedy: !0,
			},
			{
				pattern:
					/\/(?:[^\/\\\r\n]|\\.)*\/[msixpodualngc]*(?=\s*(?:$|[\r\n,.;})&|\-+*~<>!?^]|(?:and|cmp|eq|ge|gt|le|lt|ne|not|or|x|xor)\b))/,
				greedy: !0,
			},
		],
		variable: [
			/[&*$@%]\{\^[A-Z]+\}/,
			/[&*$@%]\^[A-Z_]/,
			/[&*$@%]#?(?=\{)/,
			/[&*$@%]#?(?:(?:::)*'?(?!\d)[\w$]+(?![\w$]))+(?:::)*/,
			/[&*$@%]\d+/,
			/(?!%=)[$@%][!"#$%&'()*+,\-.\/:;<=>?@[\\\]^_`{|}~]/,
		],
		filehandle: { pattern: /<(?![<=])\S*?>|\b_\b/, alias: "symbol" },
		"v-string": {
			pattern: /v\d+(?:\.\d+)*|\d+(?:\.\d+){2,}/,
			alias: "string",
		},
		function: { pattern: /(\bsub[ \t]+)\w+/, lookbehind: !0 },
		keyword:
			/\b(?:any|break|continue|default|delete|die|do|else|elsif|eval|for|foreach|given|goto|if|last|local|my|next|our|package|print|redo|require|return|say|state|sub|switch|undef|unless|until|use|when|while)\b/,
		number: /\b(?:0x[\dA-Fa-f](?:_?[\dA-Fa-f])*|0b[01](?:_?[01])*|(?:(?:\d(?:_?\d)*)?\.)?\d(?:_?\d)*(?:[Ee][+-]?\d+)?)\b/,
		operator:
			/-[rwxoRWXOezsfdlpSbctugkTBMAC]\b|\+[+=]?|-[-=>]?|\*\*?=?|\/\/?=?|=[=~>]?|~[~=]?|\|\|?=?|&&?=?|<(?:=>?|<=?)?|>>?=?|![~=]?|[%^]=?|\.(?:=|\.\.?)?|[\\?]|\bx(?:=|\b)|\b(?:and|cmp|eq|ge|gt|le|lt|ne|not|or|xor)\b/,
		punctuation: /[{}[\];(),:]/,
	};
})(Q);
(function (t) {
	function e(n, r) {
		return "___" + n.toUpperCase() + r + "___";
	}
	Object.defineProperties((t.languages["markup-templating"] = {}), {
		buildPlaceholders: {
			value: function (n, r, i, o) {
				if (n.language === r) {
					var s = (n.tokenStack = []);
					(n.code = n.code.replace(i, function (a) {
						if (typeof o == "function" && !o(a)) return a;
						for (
							var l = s.length, u;
							n.code.indexOf((u = e(r, l))) !== -1;

						)
							++l;
						return (s[l] = a), u;
					})),
						(n.grammar = t.languages.markup);
				}
			},
		},
		tokenizePlaceholders: {
			value: function (n, r) {
				if (n.language !== r || !n.tokenStack) return;
				n.grammar = t.languages[r];
				var i = 0,
					o = Object.keys(n.tokenStack);
				function s(a) {
					for (var l = 0; l < a.length && !(i >= o.length); l++) {
						var u = a[l];
						if (
							typeof u == "string" ||
							(u.content && typeof u.content == "string")
						) {
							var c = o[i],
								d = n.tokenStack[c],
								f = typeof u == "string" ? u : u.content,
								h = e(r, c),
								p = f.indexOf(h);
							if (p > -1) {
								++i;
								var g = f.substring(0, p),
									v = new t.Token(
										r,
										t.tokenize(d, n.grammar),
										"language-" + r,
										d,
									),
									b = f.substring(p + h.length),
									y = [];
								g && y.push.apply(y, s([g])),
									y.push(v),
									b && y.push.apply(y, s([b])),
									typeof u == "string"
										? a.splice.apply(a, [l, 1].concat(y))
										: (u.content = y);
							}
						} else u.content && s(u.content);
					}
					return a;
				}
				s(n.tokens);
			},
		},
	});
})(Q);
(function (t) {
	var e = /\/\*[\s\S]*?\*\/|\/\/.*|#(?!\[).*/,
		n = [
			{ pattern: /\b(?:false|true)\b/i, alias: "boolean" },
			{
				pattern: /(::\s*)\b[a-z_]\w*\b(?!\s*\()/i,
				greedy: !0,
				lookbehind: !0,
			},
			{
				pattern: /(\b(?:case|const)\s+)\b[a-z_]\w*(?=\s*[;=])/i,
				greedy: !0,
				lookbehind: !0,
			},
			/\b(?:null)\b/i,
			/\b[A-Z_][A-Z0-9_]*\b(?!\s*\()/,
		],
		r =
			/\b0b[01]+(?:_[01]+)*\b|\b0o[0-7]+(?:_[0-7]+)*\b|\b0x[\da-f]+(?:_[\da-f]+)*\b|(?:\b\d+(?:_\d+)*\.?(?:\d+(?:_\d+)*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
		i =
			/<?=>|\?\?=?|\.{3}|\??->|[!=]=?=?|::|\*\*=?|--|\+\+|&&|\|\||<<|>>|[?~]|[/^|%*&<>.+-]=?/,
		o = /[{}\[\](),:;]/;
	t.languages.php = {
		delimiter: {
			pattern: /\?>$|^<\?(?:php(?=\s)|=)?/i,
			alias: "important",
		},
		comment: e,
		variable: /\$+(?:\w+\b|(?=\{))/,
		package: {
			pattern:
				/(namespace\s+|use\s+(?:function\s+)?)(?:\\?\b[a-z_]\w*)+\b(?!\\)/i,
			lookbehind: !0,
			inside: { punctuation: /\\/ },
		},
		"class-name-definition": {
			pattern:
				/(\b(?:class|enum|interface|trait)\s+)\b[a-z_]\w*(?!\\)\b/i,
			lookbehind: !0,
			alias: "class-name",
		},
		"function-definition": {
			pattern: /(\bfunction\s+)[a-z_]\w*(?=\s*\()/i,
			lookbehind: !0,
			alias: "function",
		},
		keyword: [
			{
				pattern:
					/(\(\s*)\b(?:array|bool|boolean|float|int|integer|object|string)\b(?=\s*\))/i,
				alias: "type-casting",
				greedy: !0,
				lookbehind: !0,
			},
			{
				pattern:
					/([(,?]\s*)\b(?:array(?!\s*\()|bool|callable|(?:false|null)(?=\s*\|)|float|int|iterable|mixed|object|self|static|string)\b(?=\s*\$)/i,
				alias: "type-hint",
				greedy: !0,
				lookbehind: !0,
			},
			{
				pattern:
					/(\)\s*:\s*(?:\?\s*)?)\b(?:array(?!\s*\()|bool|callable|(?:false|null)(?=\s*\|)|float|int|iterable|mixed|never|object|self|static|string|void)\b/i,
				alias: "return-type",
				greedy: !0,
				lookbehind: !0,
			},
			{
				pattern:
					/\b(?:array(?!\s*\()|bool|float|int|iterable|mixed|object|string|void)\b/i,
				alias: "type-declaration",
				greedy: !0,
			},
			{
				pattern: /(\|\s*)(?:false|null)\b|\b(?:false|null)(?=\s*\|)/i,
				alias: "type-declaration",
				greedy: !0,
				lookbehind: !0,
			},
			{
				pattern: /\b(?:parent|self|static)(?=\s*::)/i,
				alias: "static-context",
				greedy: !0,
			},
			{ pattern: /(\byield\s+)from\b/i, lookbehind: !0 },
			/\bclass\b/i,
			{
				pattern:
					/((?:^|[^\s>:]|(?:^|[^-])>|(?:^|[^:]):)\s*)\b(?:abstract|and|array|as|break|callable|case|catch|clone|const|continue|declare|default|die|do|echo|else|elseif|empty|enddeclare|endfor|endforeach|endif|endswitch|endwhile|enum|eval|exit|extends|final|finally|fn|for|foreach|function|global|goto|if|implements|include|include_once|instanceof|insteadof|interface|isset|list|match|namespace|never|new|or|parent|print|private|protected|public|readonly|require|require_once|return|self|static|switch|throw|trait|try|unset|use|var|while|xor|yield|__halt_compiler)\b/i,
				lookbehind: !0,
			},
		],
		"argument-name": {
			pattern: /([(,]\s*)\b[a-z_]\w*(?=\s*:(?!:))/i,
			lookbehind: !0,
		},
		"class-name": [
			{
				pattern:
					/(\b(?:extends|implements|instanceof|new(?!\s+self|\s+static))\s+|\bcatch\s*\()\b[a-z_]\w*(?!\\)\b/i,
				greedy: !0,
				lookbehind: !0,
			},
			{
				pattern: /(\|\s*)\b[a-z_]\w*(?!\\)\b/i,
				greedy: !0,
				lookbehind: !0,
			},
			{ pattern: /\b[a-z_]\w*(?!\\)\b(?=\s*\|)/i, greedy: !0 },
			{
				pattern: /(\|\s*)(?:\\?\b[a-z_]\w*)+\b/i,
				alias: "class-name-fully-qualified",
				greedy: !0,
				lookbehind: !0,
				inside: { punctuation: /\\/ },
			},
			{
				pattern: /(?:\\?\b[a-z_]\w*)+\b(?=\s*\|)/i,
				alias: "class-name-fully-qualified",
				greedy: !0,
				inside: { punctuation: /\\/ },
			},
			{
				pattern:
					/(\b(?:extends|implements|instanceof|new(?!\s+self\b|\s+static\b))\s+|\bcatch\s*\()(?:\\?\b[a-z_]\w*)+\b(?!\\)/i,
				alias: "class-name-fully-qualified",
				greedy: !0,
				lookbehind: !0,
				inside: { punctuation: /\\/ },
			},
			{
				pattern: /\b[a-z_]\w*(?=\s*\$)/i,
				alias: "type-declaration",
				greedy: !0,
			},
			{
				pattern: /(?:\\?\b[a-z_]\w*)+(?=\s*\$)/i,
				alias: ["class-name-fully-qualified", "type-declaration"],
				greedy: !0,
				inside: { punctuation: /\\/ },
			},
			{
				pattern: /\b[a-z_]\w*(?=\s*::)/i,
				alias: "static-context",
				greedy: !0,
			},
			{
				pattern: /(?:\\?\b[a-z_]\w*)+(?=\s*::)/i,
				alias: ["class-name-fully-qualified", "static-context"],
				greedy: !0,
				inside: { punctuation: /\\/ },
			},
			{
				pattern: /([(,?]\s*)[a-z_]\w*(?=\s*\$)/i,
				alias: "type-hint",
				greedy: !0,
				lookbehind: !0,
			},
			{
				pattern: /([(,?]\s*)(?:\\?\b[a-z_]\w*)+(?=\s*\$)/i,
				alias: ["class-name-fully-qualified", "type-hint"],
				greedy: !0,
				lookbehind: !0,
				inside: { punctuation: /\\/ },
			},
			{
				pattern: /(\)\s*:\s*(?:\?\s*)?)\b[a-z_]\w*(?!\\)\b/i,
				alias: "return-type",
				greedy: !0,
				lookbehind: !0,
			},
			{
				pattern: /(\)\s*:\s*(?:\?\s*)?)(?:\\?\b[a-z_]\w*)+\b(?!\\)/i,
				alias: ["class-name-fully-qualified", "return-type"],
				greedy: !0,
				lookbehind: !0,
				inside: { punctuation: /\\/ },
			},
		],
		constant: n,
		function: {
			pattern: /(^|[^\\\w])\\?[a-z_](?:[\w\\]*\w)?(?=\s*\()/i,
			lookbehind: !0,
			inside: { punctuation: /\\/ },
		},
		property: { pattern: /(->\s*)\w+/, lookbehind: !0 },
		number: r,
		operator: i,
		punctuation: o,
	};
	var s = {
			pattern:
				/\{\$(?:\{(?:\{[^{}]+\}|[^{}]+)\}|[^{}])+\}|(^|[^\\{])\$+(?:\w+(?:\[[^\r\n\[\]]+\]|->\w+)?)/,
			lookbehind: !0,
			inside: t.languages.php,
		},
		a = [
			{
				pattern: /<<<'([^']+)'[\r\n](?:.*[\r\n])*?\1;/,
				alias: "nowdoc-string",
				greedy: !0,
				inside: {
					delimiter: {
						pattern: /^<<<'[^']+'|[a-z_]\w*;$/i,
						alias: "symbol",
						inside: { punctuation: /^<<<'?|[';]$/ },
					},
				},
			},
			{
				pattern:
					/<<<(?:"([^"]+)"[\r\n](?:.*[\r\n])*?\1;|([a-z_]\w*)[\r\n](?:.*[\r\n])*?\2;)/i,
				alias: "heredoc-string",
				greedy: !0,
				inside: {
					delimiter: {
						pattern: /^<<<(?:"[^"]+"|[a-z_]\w*)|[a-z_]\w*;$/i,
						alias: "symbol",
						inside: { punctuation: /^<<<"?|[";]$/ },
					},
					interpolation: s,
				},
			},
			{
				pattern: /`(?:\\[\s\S]|[^\\`])*`/,
				alias: "backtick-quoted-string",
				greedy: !0,
			},
			{
				pattern: /'(?:\\[\s\S]|[^\\'])*'/,
				alias: "single-quoted-string",
				greedy: !0,
			},
			{
				pattern: /"(?:\\[\s\S]|[^\\"])*"/,
				alias: "double-quoted-string",
				greedy: !0,
				inside: { interpolation: s },
			},
		];
	t.languages.insertBefore("php", "variable", {
		string: a,
		attribute: {
			pattern:
				/#\[(?:[^"'\/#]|\/(?![*/])|\/\/.*$|#(?!\[).*$|\/\*(?:[^*]|\*(?!\/))*\*\/|"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*')+\](?=\s*[a-z$#])/im,
			greedy: !0,
			inside: {
				"attribute-content": {
					pattern: /^(#\[)[\s\S]+(?=\]$)/,
					lookbehind: !0,
					inside: {
						comment: e,
						string: a,
						"attribute-class-name": [
							{
								pattern: /([^:]|^)\b[a-z_]\w*(?!\\)\b/i,
								alias: "class-name",
								greedy: !0,
								lookbehind: !0,
							},
							{
								pattern: /([^:]|^)(?:\\?\b[a-z_]\w*)+/i,
								alias: [
									"class-name",
									"class-name-fully-qualified",
								],
								greedy: !0,
								lookbehind: !0,
								inside: { punctuation: /\\/ },
							},
						],
						constant: n,
						number: r,
						operator: i,
						punctuation: o,
					},
				},
				delimiter: { pattern: /^#\[|\]$/, alias: "punctuation" },
			},
		},
	}),
		t.hooks.add("before-tokenize", function (l) {
			if (/<\?/.test(l.code)) {
				var u =
					/<\?(?:[^"'/#]|\/(?![*/])|("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|(?:\/\/|#(?!\[))(?:[^?\n\r]|\?(?!>))*(?=$|\?>|[\r\n])|#\[|\/\*(?:[^*]|\*(?!\/))*(?:\*\/|$))*?(?:\?>|$)/g;
				t.languages["markup-templating"].buildPlaceholders(l, "php", u);
			}
		}),
		t.hooks.add("after-tokenize", function (l) {
			t.languages["markup-templating"].tokenizePlaceholders(l, "php");
		});
})(Q);
Q.languages.python = {
	comment: { pattern: /(^|[^\\])#.*/, lookbehind: !0, greedy: !0 },
	"string-interpolation": {
		pattern:
			/(?:f|fr|rf)(?:("""|''')[\s\S]*?\1|("|')(?:\\.|(?!\2)[^\\\r\n])*\2)/i,
		greedy: !0,
		inside: {
			interpolation: {
				pattern:
					/((?:^|[^{])(?:\{\{)*)\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}])+\})+\})+\}/,
				lookbehind: !0,
				inside: {
					"format-spec": {
						pattern: /(:)[^:(){}]+(?=\}$)/,
						lookbehind: !0,
					},
					"conversion-option": {
						pattern: /![sra](?=[:}]$)/,
						alias: "punctuation",
					},
					rest: null,
				},
			},
			string: /[\s\S]+/,
		},
	},
	"triple-quoted-string": {
		pattern: /(?:[rub]|br|rb)?("""|''')[\s\S]*?\1/i,
		greedy: !0,
		alias: "string",
	},
	string: {
		pattern: /(?:[rub]|br|rb)?("|')(?:\\.|(?!\1)[^\\\r\n])*\1/i,
		greedy: !0,
	},
	function: {
		pattern: /((?:^|\s)def[ \t]+)[a-zA-Z_]\w*(?=\s*\()/g,
		lookbehind: !0,
	},
	"class-name": { pattern: /(\bclass\s+)\w+/i, lookbehind: !0 },
	decorator: {
		pattern: /(^[\t ]*)@\w+(?:\.\w+)*/m,
		lookbehind: !0,
		alias: ["annotation", "punctuation"],
		inside: { punctuation: /\./ },
	},
	keyword:
		/\b(?:_(?=\s*:)|and|as|assert|async|await|break|case|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|match|nonlocal|not|or|pass|print|raise|return|try|while|with|yield)\b/,
	builtin:
		/\b(?:__import__|abs|all|any|apply|ascii|basestring|bin|bool|buffer|bytearray|bytes|callable|chr|classmethod|cmp|coerce|compile|complex|delattr|dict|dir|divmod|enumerate|eval|execfile|file|filter|float|format|frozenset|getattr|globals|hasattr|hash|help|hex|id|input|int|intern|isinstance|issubclass|iter|len|list|locals|long|map|max|memoryview|min|next|object|oct|open|ord|pow|property|range|raw_input|reduce|reload|repr|reversed|round|set|setattr|slice|sorted|staticmethod|str|sum|super|tuple|type|unichr|unicode|vars|xrange|zip)\b/,
	boolean: /\b(?:False|None|True)\b/,
	number: /\b0(?:b(?:_?[01])+|o(?:_?[0-7])+|x(?:_?[a-f0-9])+)\b|(?:\b\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\B\.\d+(?:_\d+)*)(?:e[+-]?\d+(?:_\d+)*)?j?(?!\w)/i,
	operator: /[-+%=]=?|!=|:=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]/,
	punctuation: /[{}[\];(),.:]/,
};
Q.languages.python["string-interpolation"].inside.interpolation.inside.rest =
	Q.languages.python;
Q.languages.py = Q.languages.python;
Q.languages.r = {
	comment: /#.*/,
	string: { pattern: /(['"])(?:\\.|(?!\1)[^\\\r\n])*\1/, greedy: !0 },
	"percent-operator": { pattern: /%[^%\s]*%/, alias: "operator" },
	boolean: /\b(?:FALSE|TRUE)\b/,
	ellipsis: /\.\.(?:\.|\d+)/,
	number: [
		/\b(?:Inf|NaN)\b/,
		/(?:\b0x[\dA-Fa-f]+(?:\.\d*)?|\b\d+(?:\.\d*)?|\B\.\d+)(?:[EePp][+-]?\d+)?[iL]?/,
	],
	keyword:
		/\b(?:NA|NA_character_|NA_complex_|NA_integer_|NA_real_|NULL|break|else|for|function|if|in|next|repeat|while)\b/,
	operator: /->?>?|<(?:=|<?-)?|[>=!]=?|::?|&&?|\|\|?|[+*\/^$@~]/,
	punctuation: /[(){}\[\],;]/,
};
(function (t) {
	(t.languages.ruby = t.languages.extend("clike", {
		comment: { pattern: /#.*|^=begin\s[\s\S]*?^=end/m, greedy: !0 },
		"class-name": {
			pattern:
				/(\b(?:class|module)\s+|\bcatch\s+\()[\w.\\]+|\b[A-Z_]\w*(?=\s*\.\s*new\b)/,
			lookbehind: !0,
			inside: { punctuation: /[.\\]/ },
		},
		keyword:
			/\b(?:BEGIN|END|alias|and|begin|break|case|class|def|define_method|defined|do|each|else|elsif|end|ensure|extend|for|if|in|include|module|new|next|nil|not|or|prepend|private|protected|public|raise|redo|require|rescue|retry|return|self|super|then|throw|undef|unless|until|when|while|yield)\b/,
		operator:
			/\.{2,3}|&\.|===|<?=>|[!=]?~|(?:&&|\|\||<<|>>|\*\*|[+\-*/%<>!^&|=])=?|[?:]/,
		punctuation: /[(){}[\].,;]/,
	})),
		t.languages.insertBefore("ruby", "operator", {
			"double-colon": { pattern: /::/, alias: "punctuation" },
		});
	var e = {
		pattern: /((?:^|[^\\])(?:\\{2})*)#\{(?:[^{}]|\{[^{}]*\})*\}/,
		lookbehind: !0,
		inside: {
			content: {
				pattern: /^(#\{)[\s\S]+(?=\}$)/,
				lookbehind: !0,
				inside: t.languages.ruby,
			},
			delimiter: { pattern: /^#\{|\}$/, alias: "punctuation" },
		},
	};
	delete t.languages.ruby.function;
	var n =
			"(?:" +
			[
				/([^a-zA-Z0-9\s{(\[<=])(?:(?!\1)[^\\]|\\[\s\S])*\1/.source,
				/\((?:[^()\\]|\\[\s\S]|\((?:[^()\\]|\\[\s\S])*\))*\)/.source,
				/\{(?:[^{}\\]|\\[\s\S]|\{(?:[^{}\\]|\\[\s\S])*\})*\}/.source,
				/\[(?:[^\[\]\\]|\\[\s\S]|\[(?:[^\[\]\\]|\\[\s\S])*\])*\]/
					.source,
				/<(?:[^<>\\]|\\[\s\S]|<(?:[^<>\\]|\\[\s\S])*>)*>/.source,
			].join("|") +
			")",
		r =
			/(?:"(?:\\.|[^"\\\r\n])*"|(?:\b[a-zA-Z_]\w*|[^\s\0-\x7F]+)[?!]?|\$.)/
				.source;
	t.languages.insertBefore("ruby", "keyword", {
		"regex-literal": [
			{
				pattern: RegExp(/%r/.source + n + /[egimnosux]{0,6}/.source),
				greedy: !0,
				inside: { interpolation: e, regex: /[\s\S]+/ },
			},
			{
				pattern:
					/(^|[^/])\/(?!\/)(?:\[[^\r\n\]]+\]|\\.|[^[/\\\r\n])+\/[egimnosux]{0,6}(?=\s*(?:$|[\r\n,.;})#]))/,
				lookbehind: !0,
				greedy: !0,
				inside: { interpolation: e, regex: /[\s\S]+/ },
			},
		],
		variable: /[@$]+[a-zA-Z_]\w*(?:[?!]|\b)/,
		symbol: [
			{
				pattern: RegExp(/(^|[^:]):/.source + r),
				lookbehind: !0,
				greedy: !0,
			},
			{
				pattern: RegExp(
					/([\r\n{(,][ \t]*)/.source + r + /(?=:(?!:))/.source,
				),
				lookbehind: !0,
				greedy: !0,
			},
		],
		"method-definition": {
			pattern: /(\bdef\s+)\w+(?:\s*\.\s*\w+)?/,
			lookbehind: !0,
			inside: {
				function: /\b\w+$/,
				keyword: /^self\b/,
				"class-name": /^\w+/,
				punctuation: /\./,
			},
		},
	}),
		t.languages.insertBefore("ruby", "string", {
			"string-literal": [
				{
					pattern: RegExp(/%[qQiIwWs]?/.source + n),
					greedy: !0,
					inside: { interpolation: e, string: /[\s\S]+/ },
				},
				{
					pattern:
						/("|')(?:#\{[^}]+\}|#(?!\{)|\\(?:\r\n|[\s\S])|(?!\1)[^\\#\r\n])*\1/,
					greedy: !0,
					inside: { interpolation: e, string: /[\s\S]+/ },
				},
				{
					pattern: /<<[-~]?([a-z_]\w*)[\r\n](?:.*[\r\n])*?[\t ]*\1/i,
					alias: "heredoc-string",
					greedy: !0,
					inside: {
						delimiter: {
							pattern: /^<<[-~]?[a-z_]\w*|\b[a-z_]\w*$/i,
							inside: {
								symbol: /\b\w+/,
								punctuation: /^<<[-~]?/,
							},
						},
						interpolation: e,
						string: /[\s\S]+/,
					},
				},
				{
					pattern:
						/<<[-~]?'([a-z_]\w*)'[\r\n](?:.*[\r\n])*?[\t ]*\1/i,
					alias: "heredoc-string",
					greedy: !0,
					inside: {
						delimiter: {
							pattern: /^<<[-~]?'[a-z_]\w*'|\b[a-z_]\w*$/i,
							inside: {
								symbol: /\b\w+/,
								punctuation: /^<<[-~]?'|'$/,
							},
						},
						string: /[\s\S]+/,
					},
				},
			],
			"command-literal": [
				{
					pattern: RegExp(/%x/.source + n),
					greedy: !0,
					inside: {
						interpolation: e,
						command: { pattern: /[\s\S]+/, alias: "string" },
					},
				},
				{
					pattern:
						/`(?:#\{[^}]+\}|#(?!\{)|\\(?:\r\n|[\s\S])|[^\\`#\r\n])*`/,
					greedy: !0,
					inside: {
						interpolation: e,
						command: { pattern: /[\s\S]+/, alias: "string" },
					},
				},
			],
		}),
		delete t.languages.ruby.string,
		t.languages.insertBefore("ruby", "number", {
			builtin:
				/\b(?:Array|Bignum|Binding|Class|Continuation|Dir|Exception|FalseClass|File|Fixnum|Float|Hash|IO|Integer|MatchData|Method|Module|NilClass|Numeric|Object|Proc|Range|Regexp|Stat|String|Struct|Symbol|TMS|Thread|ThreadGroup|Time|TrueClass)\b/,
			constant: /\b[A-Z][A-Z0-9_]*(?:[?!]|\b)/,
		}),
		(t.languages.rb = t.languages.ruby);
})(Q);
(function (t) {
	for (
		var e = /\/\*(?:[^*/]|\*(?!\/)|\/(?!\*)|<self>)*\*\//.source, n = 0;
		n < 2;
		n++
	)
		e = e.replace(/<self>/g, function () {
			return e;
		});
	(e = e.replace(/<self>/g, function () {
		return /[^\s\S]/.source;
	})),
		(t.languages.rust = {
			comment: [
				{
					pattern: RegExp(/(^|[^\\])/.source + e),
					lookbehind: !0,
					greedy: !0,
				},
				{ pattern: /(^|[^\\:])\/\/.*/, lookbehind: !0, greedy: !0 },
			],
			string: {
				pattern:
					/b?"(?:\\[\s\S]|[^\\"])*"|b?r(#*)"(?:[^"]|"(?!\1))*"\1/,
				greedy: !0,
			},
			char: {
				pattern:
					/b?'(?:\\(?:x[0-7][\da-fA-F]|u\{(?:[\da-fA-F]_*){1,6}\}|.)|[^\\\r\n\t'])'/,
				greedy: !0,
			},
			attribute: {
				pattern: /#!?\[(?:[^\[\]"]|"(?:\\[\s\S]|[^\\"])*")*\]/,
				greedy: !0,
				alias: "attr-name",
				inside: { string: null },
			},
			"closure-params": {
				pattern:
					/([=(,:]\s*|\bmove\s*)\|[^|]*\||\|[^|]*\|(?=\s*(?:\{|->))/,
				lookbehind: !0,
				greedy: !0,
				inside: {
					"closure-punctuation": {
						pattern: /^\||\|$/,
						alias: "punctuation",
					},
					rest: null,
				},
			},
			"lifetime-annotation": { pattern: /'\w+/, alias: "symbol" },
			"fragment-specifier": {
				pattern: /(\$\w+:)[a-z]+/,
				lookbehind: !0,
				alias: "punctuation",
			},
			variable: /\$\w+/,
			"function-definition": {
				pattern: /(\bfn\s+)\w+/,
				lookbehind: !0,
				alias: "function",
			},
			"type-definition": {
				pattern: /(\b(?:enum|struct|trait|type|union)\s+)\w+/,
				lookbehind: !0,
				alias: "class-name",
			},
			"module-declaration": [
				{
					pattern: /(\b(?:crate|mod)\s+)[a-z][a-z_\d]*/,
					lookbehind: !0,
					alias: "namespace",
				},
				{
					pattern:
						/(\b(?:crate|self|super)\s*)::\s*[a-z][a-z_\d]*\b(?:\s*::(?:\s*[a-z][a-z_\d]*\s*::)*)?/,
					lookbehind: !0,
					alias: "namespace",
					inside: { punctuation: /::/ },
				},
			],
			keyword: [
				/\b(?:Self|abstract|as|async|await|become|box|break|const|continue|crate|do|dyn|else|enum|extern|final|fn|for|if|impl|in|let|loop|macro|match|mod|move|mut|override|priv|pub|ref|return|self|static|struct|super|trait|try|type|typeof|union|unsafe|unsized|use|virtual|where|while|yield)\b/,
				/\b(?:bool|char|f(?:32|64)|[ui](?:8|16|32|64|128|size)|str)\b/,
			],
			function: /\b[a-z_]\w*(?=\s*(?:::\s*<|\())/,
			macro: { pattern: /\b\w+!/, alias: "property" },
			constant: /\b[A-Z_][A-Z_\d]+\b/,
			"class-name": /\b[A-Z]\w*\b/,
			namespace: {
				pattern:
					/(?:\b[a-z][a-z_\d]*\s*::\s*)*\b[a-z][a-z_\d]*\s*::(?!\s*<)/,
				inside: { punctuation: /::/ },
			},
			number: /\b(?:0x[\dA-Fa-f](?:_?[\dA-Fa-f])*|0o[0-7](?:_?[0-7])*|0b[01](?:_?[01])*|(?:(?:\d(?:_?\d)*)?\.)?\d(?:_?\d)*(?:[Ee][+-]?\d+)?)(?:_?(?:f32|f64|[iu](?:8|16|32|64|size)?))?\b/,
			boolean: /\b(?:false|true)\b/,
			punctuation: /->|\.\.=|\.{1,3}|::|[{}[\];(),:]/,
			operator: /[-+*\/%!^]=?|=[=>]?|&[&=]?|\|[|=]?|<<?=?|>>?=?|[@?]/,
		}),
		(t.languages.rust["closure-params"].inside.rest = t.languages.rust),
		(t.languages.rust.attribute.inside.string = t.languages.rust.string);
})(Q);
(function (t) {
	(t.languages.sass = t.languages.extend("css", {
		comment: {
			pattern: /^([ \t]*)\/[\/*].*(?:(?:\r?\n|\r)\1[ \t].+)*/m,
			lookbehind: !0,
			greedy: !0,
		},
	})),
		t.languages.insertBefore("sass", "atrule", {
			"atrule-line": {
				pattern: /^(?:[ \t]*)[@+=].+/m,
				greedy: !0,
				inside: { atrule: /(?:@[\w-]+|[+=])/ },
			},
		}),
		delete t.languages.sass.atrule;
	var e = /\$[-\w]+|#\{\$[-\w]+\}/,
		n = [
			/[+*\/%]|[=!]=|<=?|>=?|\b(?:and|not|or)\b/,
			{ pattern: /(\s)-(?=\s)/, lookbehind: !0 },
		];
	t.languages.insertBefore("sass", "property", {
		"variable-line": {
			pattern: /^[ \t]*\$.+/m,
			greedy: !0,
			inside: { punctuation: /:/, variable: e, operator: n },
		},
		"property-line": {
			pattern: /^[ \t]*(?:[^:\s]+ *:.*|:[^:\s].*)/m,
			greedy: !0,
			inside: {
				property: [
					/[^:\s]+(?=\s*:)/,
					{ pattern: /(:)[^:\s]+/, lookbehind: !0 },
				],
				punctuation: /:/,
				variable: e,
				operator: n,
				important: t.languages.sass.important,
			},
		},
	}),
		delete t.languages.sass.property,
		delete t.languages.sass.important,
		t.languages.insertBefore("sass", "punctuation", {
			selector: {
				pattern:
					/^([ \t]*)\S(?:,[^,\r\n]+|[^,\r\n]*)(?:,[^,\r\n]+)*(?:,(?:\r?\n|\r)\1[ \t]+\S(?:,[^,\r\n]+|[^,\r\n]*)(?:,[^,\r\n]+)*)*/m,
				lookbehind: !0,
				greedy: !0,
			},
		});
})(Q);
Q.languages.scss = Q.languages.extend("css", {
	comment: {
		pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|\/\/.*)/,
		lookbehind: !0,
	},
	atrule: {
		pattern: /@[\w-](?:\([^()]+\)|[^()\s]|\s+(?!\s))*?(?=\s+[{;])/,
		inside: { rule: /@[\w-]+/ },
	},
	url: /(?:[-a-z]+-)?url(?=\()/i,
	selector: {
		pattern:
			/(?=\S)[^@;{}()]?(?:[^@;{}()\s]|\s+(?!\s)|#\{\$[-\w]+\})+(?=\s*\{(?:\}|\s|[^}][^:{}]*[:{][^}]))/,
		inside: {
			parent: { pattern: /&/, alias: "important" },
			placeholder: /%[-\w]+/,
			variable: /\$[-\w]+|#\{\$[-\w]+\}/,
		},
	},
	property: {
		pattern: /(?:[-\w]|\$[-\w]|#\{\$[-\w]+\})+(?=\s*:)/,
		inside: { variable: /\$[-\w]+|#\{\$[-\w]+\}/ },
	},
});
Q.languages.insertBefore("scss", "atrule", {
	keyword: [
		/@(?:content|debug|each|else(?: if)?|extend|for|forward|function|if|import|include|mixin|return|use|warn|while)\b/i,
		{ pattern: /( )(?:from|through)(?= )/, lookbehind: !0 },
	],
});
Q.languages.insertBefore("scss", "important", {
	variable: /\$[-\w]+|#\{\$[-\w]+\}/,
});
Q.languages.insertBefore("scss", "function", {
	"module-modifier": {
		pattern: /\b(?:as|hide|show|with)\b/i,
		alias: "keyword",
	},
	placeholder: { pattern: /%[-\w]+/, alias: "selector" },
	statement: { pattern: /\B!(?:default|optional)\b/i, alias: "keyword" },
	boolean: /\b(?:false|true)\b/,
	null: { pattern: /\bnull\b/, alias: "keyword" },
	operator: {
		pattern: /(\s)(?:[-+*\/%]|[=!]=|<=?|>=?|and|not|or)(?=\s)/,
		lookbehind: !0,
	},
});
Q.languages.scss.atrule.inside.rest = Q.languages.scss;
Q.languages.sql = {
	comment: {
		pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|(?:--|\/\/|#).*)/,
		lookbehind: !0,
	},
	variable: [
		{ pattern: /@(["'`])(?:\\[\s\S]|(?!\1)[^\\])+\1/, greedy: !0 },
		/@[\w.$]+/,
	],
	string: {
		pattern: /(^|[^@\\])("|')(?:\\[\s\S]|(?!\2)[^\\]|\2\2)*\2/,
		greedy: !0,
		lookbehind: !0,
	},
	identifier: {
		pattern: /(^|[^@\\])`(?:\\[\s\S]|[^`\\]|``)*`/,
		greedy: !0,
		lookbehind: !0,
		inside: { punctuation: /^`|`$/ },
	},
	function:
		/\b(?:AVG|COUNT|FIRST|FORMAT|LAST|LCASE|LEN|MAX|MID|MIN|MOD|NOW|ROUND|SUM|UCASE)(?=\s*\()/i,
	keyword:
		/\b(?:ACTION|ADD|AFTER|ALGORITHM|ALL|ALTER|ANALYZE|ANY|APPLY|AS|ASC|AUTHORIZATION|AUTO_INCREMENT|BACKUP|BDB|BEGIN|BERKELEYDB|BIGINT|BINARY|BIT|BLOB|BOOL|BOOLEAN|BREAK|BROWSE|BTREE|BULK|BY|CALL|CASCADED?|CASE|CHAIN|CHAR(?:ACTER|SET)?|CHECK(?:POINT)?|CLOSE|CLUSTERED|COALESCE|COLLATE|COLUMNS?|COMMENT|COMMIT(?:TED)?|COMPUTE|CONNECT|CONSISTENT|CONSTRAINT|CONTAINS(?:TABLE)?|CONTINUE|CONVERT|CREATE|CROSS|CURRENT(?:_DATE|_TIME|_TIMESTAMP|_USER)?|CURSOR|CYCLE|DATA(?:BASES?)?|DATE(?:TIME)?|DAY|DBCC|DEALLOCATE|DEC|DECIMAL|DECLARE|DEFAULT|DEFINER|DELAYED|DELETE|DELIMITERS?|DENY|DESC|DESCRIBE|DETERMINISTIC|DISABLE|DISCARD|DISK|DISTINCT|DISTINCTROW|DISTRIBUTED|DO|DOUBLE|DROP|DUMMY|DUMP(?:FILE)?|DUPLICATE|ELSE(?:IF)?|ENABLE|ENCLOSED|END|ENGINE|ENUM|ERRLVL|ERRORS|ESCAPED?|EXCEPT|EXEC(?:UTE)?|EXISTS|EXIT|EXPLAIN|EXTENDED|FETCH|FIELDS|FILE|FILLFACTOR|FIRST|FIXED|FLOAT|FOLLOWING|FOR(?: EACH ROW)?|FORCE|FOREIGN|FREETEXT(?:TABLE)?|FROM|FULL|FUNCTION|GEOMETRY(?:COLLECTION)?|GLOBAL|GOTO|GRANT|GROUP|HANDLER|HASH|HAVING|HOLDLOCK|HOUR|IDENTITY(?:COL|_INSERT)?|IF|IGNORE|IMPORT|INDEX|INFILE|INNER|INNODB|INOUT|INSERT|INT|INTEGER|INTERSECT|INTERVAL|INTO|INVOKER|ISOLATION|ITERATE|JOIN|KEYS?|KILL|LANGUAGE|LAST|LEAVE|LEFT|LEVEL|LIMIT|LINENO|LINES|LINESTRING|LOAD|LOCAL|LOCK|LONG(?:BLOB|TEXT)|LOOP|MATCH(?:ED)?|MEDIUM(?:BLOB|INT|TEXT)|MERGE|MIDDLEINT|MINUTE|MODE|MODIFIES|MODIFY|MONTH|MULTI(?:LINESTRING|POINT|POLYGON)|NATIONAL|NATURAL|NCHAR|NEXT|NO|NONCLUSTERED|NULLIF|NUMERIC|OFF?|OFFSETS?|ON|OPEN(?:DATASOURCE|QUERY|ROWSET)?|OPTIMIZE|OPTION(?:ALLY)?|ORDER|OUT(?:ER|FILE)?|OVER|PARTIAL|PARTITION|PERCENT|PIVOT|PLAN|POINT|POLYGON|PRECEDING|PRECISION|PREPARE|PREV|PRIMARY|PRINT|PRIVILEGES|PROC(?:EDURE)?|PUBLIC|PURGE|QUICK|RAISERROR|READS?|REAL|RECONFIGURE|REFERENCES|RELEASE|RENAME|REPEAT(?:ABLE)?|REPLACE|REPLICATION|REQUIRE|RESIGNAL|RESTORE|RESTRICT|RETURN(?:ING|S)?|REVOKE|RIGHT|ROLLBACK|ROUTINE|ROW(?:COUNT|GUIDCOL|S)?|RTREE|RULE|SAVE(?:POINT)?|SCHEMA|SECOND|SELECT|SERIAL(?:IZABLE)?|SESSION(?:_USER)?|SET(?:USER)?|SHARE|SHOW|SHUTDOWN|SIMPLE|SMALLINT|SNAPSHOT|SOME|SONAME|SQL|START(?:ING)?|STATISTICS|STATUS|STRIPED|SYSTEM_USER|TABLES?|TABLESPACE|TEMP(?:ORARY|TABLE)?|TERMINATED|TEXT(?:SIZE)?|THEN|TIME(?:STAMP)?|TINY(?:BLOB|INT|TEXT)|TOP?|TRAN(?:SACTIONS?)?|TRIGGER|TRUNCATE|TSEQUAL|TYPES?|UNBOUNDED|UNCOMMITTED|UNDEFINED|UNION|UNIQUE|UNLOCK|UNPIVOT|UNSIGNED|UPDATE(?:TEXT)?|USAGE|USE|USER|USING|VALUES?|VAR(?:BINARY|CHAR|CHARACTER|YING)|VIEW|WAITFOR|WARNINGS|WHEN|WHERE|WHILE|WITH(?: ROLLUP|IN)?|WORK|WRITE(?:TEXT)?|YEAR)\b/i,
	boolean: /\b(?:FALSE|NULL|TRUE)\b/i,
	number: /\b0x[\da-f]+\b|\b\d+(?:\.\d*)?|\B\.\d+\b/i,
	operator:
		/[-+*\/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?|\b(?:AND|BETWEEN|DIV|ILIKE|IN|IS|LIKE|NOT|OR|REGEXP|RLIKE|SOUNDS LIKE|XOR)\b/i,
	punctuation: /[;[\]()`,.]/,
};
Q.languages.swift = {
	comment: {
		pattern:
			/(^|[^\\:])(?:\/\/.*|\/\*(?:[^/*]|\/(?!\*)|\*(?!\/)|\/\*(?:[^*]|\*(?!\/))*\*\/)*\*\/)/,
		lookbehind: !0,
		greedy: !0,
	},
	"string-literal": [
		{
			pattern: RegExp(
				/(^|[^"#])/.source +
					"(?:" +
					/"(?:\\(?:\((?:[^()]|\([^()]*\))*\)|\r\n|[^(])|[^\\\r\n"])*"/
						.source +
					"|" +
					/"""(?:\\(?:\((?:[^()]|\([^()]*\))*\)|[^(])|[^\\"]|"(?!""))*"""/
						.source +
					")" +
					/(?!["#])/.source,
			),
			lookbehind: !0,
			greedy: !0,
			inside: {
				interpolation: {
					pattern: /(\\\()(?:[^()]|\([^()]*\))*(?=\))/,
					lookbehind: !0,
					inside: null,
				},
				"interpolation-punctuation": {
					pattern: /^\)|\\\($/,
					alias: "punctuation",
				},
				punctuation: /\\(?=[\r\n])/,
				string: /[\s\S]+/,
			},
		},
		{
			pattern: RegExp(
				/(^|[^"#])(#+)/.source +
					"(?:" +
					/"(?:\\(?:#+\((?:[^()]|\([^()]*\))*\)|\r\n|[^#])|[^\\\r\n])*?"/
						.source +
					"|" +
					/"""(?:\\(?:#+\((?:[^()]|\([^()]*\))*\)|[^#])|[^\\])*?"""/
						.source +
					")\\2",
			),
			lookbehind: !0,
			greedy: !0,
			inside: {
				interpolation: {
					pattern: /(\\#+\()(?:[^()]|\([^()]*\))*(?=\))/,
					lookbehind: !0,
					inside: null,
				},
				"interpolation-punctuation": {
					pattern: /^\)|\\#+\($/,
					alias: "punctuation",
				},
				string: /[\s\S]+/,
			},
		},
	],
	directive: {
		pattern: RegExp(
			/#/.source +
				"(?:" +
				(/(?:elseif|if)\b/.source +
					"(?:[ 	]*" +
					/(?:![ \t]*)?(?:\b\w+\b(?:[ \t]*\((?:[^()]|\([^()]*\))*\))?|\((?:[^()]|\([^()]*\))*\))(?:[ \t]*(?:&&|\|\|))?/
						.source +
					")+") +
				"|" +
				/(?:else|endif)\b/.source +
				")",
		),
		alias: "property",
		inside: {
			"directive-name": /^#\w+/,
			boolean: /\b(?:false|true)\b/,
			number: /\b\d+(?:\.\d+)*\b/,
			operator: /!|&&|\|\||[<>]=?/,
			punctuation: /[(),]/,
		},
	},
	literal: {
		pattern:
			/#(?:colorLiteral|column|dsohandle|file(?:ID|Literal|Path)?|function|imageLiteral|line)\b/,
		alias: "constant",
	},
	"other-directive": { pattern: /#\w+\b/, alias: "property" },
	attribute: { pattern: /@\w+/, alias: "atrule" },
	"function-definition": {
		pattern: /(\bfunc\s+)\w+/,
		lookbehind: !0,
		alias: "function",
	},
	label: {
		pattern:
			/\b(break|continue)\s+\w+|\b[a-zA-Z_]\w*(?=\s*:\s*(?:for|repeat|while)\b)/,
		lookbehind: !0,
		alias: "important",
	},
	keyword:
		/\b(?:Any|Protocol|Self|Type|actor|as|assignment|associatedtype|associativity|async|await|break|case|catch|class|continue|convenience|default|defer|deinit|didSet|do|dynamic|else|enum|extension|fallthrough|fileprivate|final|for|func|get|guard|higherThan|if|import|in|indirect|infix|init|inout|internal|is|isolated|lazy|left|let|lowerThan|mutating|none|nonisolated|nonmutating|open|operator|optional|override|postfix|precedencegroup|prefix|private|protocol|public|repeat|required|rethrows|return|right|safe|self|set|some|static|struct|subscript|super|switch|throw|throws|try|typealias|unowned|unsafe|var|weak|where|while|willSet)\b/,
	boolean: /\b(?:false|true)\b/,
	nil: { pattern: /\bnil\b/, alias: "constant" },
	"short-argument": /\$\d+\b/,
	omit: { pattern: /\b_\b/, alias: "keyword" },
	number: /\b(?:[\d_]+(?:\.[\de_]+)?|0x[a-f0-9_]+(?:\.[a-f0-9p_]+)?|0b[01_]+|0o[0-7_]+)\b/i,
	"class-name": /\b[A-Z](?:[A-Z_\d]*[a-z]\w*)?\b/,
	function: /\b[a-z_]\w*(?=\s*\()/i,
	constant: /\b(?:[A-Z_]{2,}|k[A-Z][A-Za-z_]+)\b/,
	operator: /[-+*/%=!<>&|^~?]+|\.[.\-+*/%=!<>&|^~?]+/,
	punctuation: /[{}[\]();,.:\\]/,
};
Q.languages.swift["string-literal"].forEach(function (t) {
	t.inside.interpolation.inside = Q.languages.swift;
});
(function (t) {
	(t.languages.typescript = t.languages.extend("javascript", {
		"class-name": {
			pattern:
				/(\b(?:class|extends|implements|instanceof|interface|new|type)\s+)(?!keyof\b)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?:\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>)?/,
			lookbehind: !0,
			greedy: !0,
			inside: null,
		},
		builtin:
			/\b(?:Array|Function|Promise|any|boolean|console|never|number|string|symbol|unknown)\b/,
	})),
		t.languages.typescript.keyword.push(
			/\b(?:abstract|declare|is|keyof|readonly|require)\b/,
			/\b(?:asserts|infer|interface|module|namespace|type)\b(?=\s*(?:[{_$a-zA-Z\xA0-\uFFFF]|$))/,
			/\btype\b(?=\s*(?:[\{*]|$))/,
		),
		delete t.languages.typescript.parameter,
		delete t.languages.typescript["literal-property"];
	var e = t.languages.extend("typescript", {});
	delete e["class-name"],
		(t.languages.typescript["class-name"].inside = e),
		t.languages.insertBefore("typescript", "function", {
			decorator: {
				pattern: /@[$\w\xA0-\uFFFF]+/,
				inside: {
					at: { pattern: /^@/, alias: "operator" },
					function: /^[\s\S]+/,
				},
			},
			"generic-function": {
				pattern:
					/#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>(?=\s*\()/,
				greedy: !0,
				inside: {
					function:
						/^#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*/,
					generic: {
						pattern: /<[\s\S]+/,
						alias: "class-name",
						inside: e,
					},
				},
			},
		}),
		(t.languages.ts = t.languages.typescript);
})(Q);
(function (t) {
	var e = t.util.clone(t.languages.typescript);
	(t.languages.tsx = t.languages.extend("jsx", e)),
		delete t.languages.tsx.parameter,
		delete t.languages.tsx["literal-property"];
	var n = t.languages.tsx.tag;
	(n.pattern = RegExp(
		/(^|[^\w$]|(?=<\/))/.source + "(?:" + n.pattern.source + ")",
		n.pattern.flags,
	)),
		(n.lookbehind = !0);
})(Q);
Q.languages.basic = {
	comment: { pattern: /(?:!|REM\b).+/i, inside: { keyword: /^REM/i } },
	string: { pattern: /"(?:""|[!#$%&'()*,\/:;<=>?^\w +\-.])*"/, greedy: !0 },
	number: /(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:E[+-]?\d+)?/i,
	keyword:
		/\b(?:AS|BEEP|BLOAD|BSAVE|CALL(?: ABSOLUTE)?|CASE|CHAIN|CHDIR|CLEAR|CLOSE|CLS|COM|COMMON|CONST|DATA|DECLARE|DEF(?: FN| SEG|DBL|INT|LNG|SNG|STR)|DIM|DO|DOUBLE|ELSE|ELSEIF|END|ENVIRON|ERASE|ERROR|EXIT|FIELD|FILES|FOR|FUNCTION|GET|GOSUB|GOTO|IF|INPUT|INTEGER|IOCTL|KEY|KILL|LINE INPUT|LOCATE|LOCK|LONG|LOOP|LSET|MKDIR|NAME|NEXT|OFF|ON(?: COM| ERROR| KEY| TIMER)?|OPEN|OPTION BASE|OUT|POKE|PUT|READ|REDIM|REM|RESTORE|RESUME|RETURN|RMDIR|RSET|RUN|SELECT CASE|SHARED|SHELL|SINGLE|SLEEP|STATIC|STEP|STOP|STRING|SUB|SWAP|SYSTEM|THEN|TIMER|TO|TROFF|TRON|TYPE|UNLOCK|UNTIL|USING|VIEW PRINT|WAIT|WEND|WHILE|WRITE)(?:\$|\b)/i,
	function:
		/\b(?:ABS|ACCESS|ACOS|ANGLE|AREA|ARITHMETIC|ARRAY|ASIN|ASK|AT|ATN|BASE|BEGIN|BREAK|CAUSE|CEIL|CHR|CLIP|COLLATE|COLOR|CON|COS|COSH|COT|CSC|DATE|DATUM|DEBUG|DECIMAL|DEF|DEG|DEGREES|DELETE|DET|DEVICE|DISPLAY|DOT|ELAPSED|EPS|ERASABLE|EXLINE|EXP|EXTERNAL|EXTYPE|FILETYPE|FIXED|FP|GO|GRAPH|HANDLER|IDN|IMAGE|IN|INT|INTERNAL|IP|IS|KEYED|LBOUND|LCASE|LEFT|LEN|LENGTH|LET|LINE|LINES|LOG|LOG10|LOG2|LTRIM|MARGIN|MAT|MAX|MAXNUM|MID|MIN|MISSING|MOD|NATIVE|NUL|NUMERIC|OF|OPTION|ORD|ORGANIZATION|OUTIN|OUTPUT|PI|POINT|POINTER|POINTS|POS|PRINT|PROGRAM|PROMPT|RAD|RADIANS|RANDOMIZE|RECORD|RECSIZE|RECTYPE|RELATIVE|REMAINDER|REPEAT|REST|RETRY|REWRITE|RIGHT|RND|ROUND|RTRIM|SAME|SEC|SELECT|SEQUENTIAL|SET|SETTER|SGN|SIN|SINH|SIZE|SKIP|SQR|STANDARD|STATUS|STR|STREAM|STYLE|TAB|TAN|TANH|TEMPLATE|TEXT|THERE|TIME|TIMEOUT|TRACE|TRANSFORM|TRUNCATE|UBOUND|UCASE|USE|VAL|VARIABLE|VIEWPORT|WHEN|WINDOW|WITH|ZER|ZONEWIDTH)(?:\$|\b)/i,
	operator: /<[=>]?|>=?|[+\-*\/^=&]|\b(?:AND|EQV|IMP|NOT|OR|XOR)\b/i,
	punctuation: /[,;:()]/,
};
Q.languages.vbnet = Q.languages.extend("basic", {
	comment: [
		{ pattern: /(?:!|REM\b).+/i, inside: { keyword: /^REM/i } },
		{ pattern: /(^|[^\\:])'.*/, lookbehind: !0, greedy: !0 },
	],
	string: {
		pattern: /(^|[^"])"(?:""|[^"])*"(?!")/,
		lookbehind: !0,
		greedy: !0,
	},
	keyword:
		/(?:\b(?:ADDHANDLER|ADDRESSOF|ALIAS|AND|ANDALSO|AS|BEEP|BLOAD|BOOLEAN|BSAVE|BYREF|BYTE|BYVAL|CALL(?: ABSOLUTE)?|CASE|CATCH|CBOOL|CBYTE|CCHAR|CDATE|CDBL|CDEC|CHAIN|CHAR|CHDIR|CINT|CLASS|CLEAR|CLNG|CLOSE|CLS|COBJ|COM|COMMON|CONST|CONTINUE|CSBYTE|CSHORT|CSNG|CSTR|CTYPE|CUINT|CULNG|CUSHORT|DATA|DATE|DECIMAL|DECLARE|DEF(?: FN| SEG|DBL|INT|LNG|SNG|STR)|DEFAULT|DELEGATE|DIM|DIRECTCAST|DO|DOUBLE|ELSE|ELSEIF|END|ENUM|ENVIRON|ERASE|ERROR|EVENT|EXIT|FALSE|FIELD|FILES|FINALLY|FOR(?: EACH)?|FRIEND|FUNCTION|GET|GETTYPE|GETXMLNAMESPACE|GLOBAL|GOSUB|GOTO|HANDLES|IF|IMPLEMENTS|IMPORTS|IN|INHERITS|INPUT|INTEGER|INTERFACE|IOCTL|IS|ISNOT|KEY|KILL|LET|LIB|LIKE|LINE INPUT|LOCATE|LOCK|LONG|LOOP|LSET|ME|MKDIR|MOD|MODULE|MUSTINHERIT|MUSTOVERRIDE|MYBASE|MYCLASS|NAME|NAMESPACE|NARROWING|NEW|NEXT|NOT|NOTHING|NOTINHERITABLE|NOTOVERRIDABLE|OBJECT|OF|OFF|ON(?: COM| ERROR| KEY| TIMER)?|OPEN|OPERATOR|OPTION(?: BASE)?|OPTIONAL|OR|ORELSE|OUT|OVERLOADS|OVERRIDABLE|OVERRIDES|PARAMARRAY|PARTIAL|POKE|PRIVATE|PROPERTY|PROTECTED|PUBLIC|PUT|RAISEEVENT|READ|READONLY|REDIM|REM|REMOVEHANDLER|RESTORE|RESUME|RETURN|RMDIR|RSET|RUN|SBYTE|SELECT(?: CASE)?|SET|SHADOWS|SHARED|SHELL|SHORT|SINGLE|SLEEP|STATIC|STEP|STOP|STRING|STRUCTURE|SUB|SWAP|SYNCLOCK|SYSTEM|THEN|THROW|TIMER|TO|TROFF|TRON|TRUE|TRY|TRYCAST|TYPE|TYPEOF|UINTEGER|ULONG|UNLOCK|UNTIL|USHORT|USING|VIEW PRINT|WAIT|WEND|WHEN|WHILE|WIDENING|WITH|WITHEVENTS|WRITE|WRITEONLY|XOR)|\B(?:#CONST|#ELSE|#ELSEIF|#END|#IF))(?:\$|\b)/i,
	punctuation: /[,;:(){}]/,
});
const RTe = [],
	IF = { mobile: "medium", tablet: "xlarge", desktop: "xxlarge" };
function cA(t) {
	return t.entryLayout === "content" ? "none" : "medium";
}
const Vy = E.createContext(null);
function xo() {
	return E.useContext(Vy);
}
function OTe(t) {
	const e = ee(2);
	let n;
	return (
		e[0] !== t.children
			? ((n = m.jsx(Vy.Provider, { value: null, children: t.children })),
				(e[0] = t.children),
				(e[1] = n))
			: (n = e[1]),
		n
	);
}
function FF(t, e) {
	return t.schema.kind === e;
}
function dA(t) {
	const e = ee(21),
		{
			formatInfo: n,
			forceValidation: r,
			slugField: i,
			entryLayout: o,
			previewProps: s,
		} = t;
	let a;
	e[0] === Symbol.for("react.memo_cache_sentinel")
		? ((a = { above: "mobile" }), (e[0] = a))
		: (a = e[0]);
	const l = Xye(a);
	if (o === "content" && n.contentField && l) {
		const { contentField: c } = n;
		let d = s;
		for (const b of c.path) {
			if (FF(d, "object")) {
				d = d.fields[b];
				continue;
			}
			if (FF(d, "conditional")) {
				if (b !== "value")
					throw new Error(
						"Conditional fields referenced in a contentField path must only reference the value field.",
					);
				d = d.value;
				continue;
			}
			throw new Error(
				"Path specified in contentField does not point to a content field",
			);
		}
		let f;
		e[1] !== r || e[2] !== d
			? ((f = m.jsx(Uy, { forceValidation: r, ...d })),
				(e[1] = r),
				(e[2] = d),
				(e[3] = f))
			: (f = e[3]);
		let h;
		e[4] !== c.path || e[5] !== f
			? ((h = m.jsx(KH, {
					children: m.jsx(Vy.Provider, {
						value: "main",
						children: m.jsx(Ob, {
							children: m.jsx(py, { part: c.path, children: f }),
						}),
					}),
				})),
				(e[4] = c.path),
				(e[5] = f),
				(e[6] = h))
			: (h = e[6]);
		let p;
		e[7] !== r || e[8] !== c.path || e[9] !== s
			? ((p = m.jsx(VH, {
					children: m.jsx(Vy.Provider, {
						value: "side",
						children: m.jsx(Ob, {
							children: m.jsx(pr, {
								padding: IF,
								children: m.jsx(Uy, {
									forceValidation: r,
									omitFieldAtPath: c.path,
									...s,
								}),
							}),
						}),
					}),
				})),
				(e[7] = r),
				(e[8] = c.path),
				(e[9] = s),
				(e[10] = p))
			: (p = e[10]);
		let g;
		e[11] !== h || e[12] !== p
			? ((g = m.jsxs(LH, {
					autoSaveId: "keystatic-content-split-view",
					defaultSize: 320,
					minSize: 240,
					maxSize: 480,
					flex: !0,
					children: [h, p],
				})),
				(e[11] = h),
				(e[12] = p),
				(e[13] = g))
			: (g = e[13]);
		let v;
		return (
			e[14] !== i || e[15] !== g
				? ((v = m.jsx(IH, {
						value: RTe,
						children: m.jsx(BH, { value: i, children: g }),
					})),
					(e[14] = i),
					(e[15] = g),
					(e[16] = v))
				: (v = e[16]),
			v
		);
	}
	let u;
	return (
		e[17] !== r || e[18] !== i || e[19] !== s
			? ((u = m.jsx(Ob, {
					children: m.jsx(iJ, {
						paddingY: IF,
						children: m.jsx(Ia, {
							forceValidation: r,
							slugField: i,
							...s,
						}),
					}),
				})),
				(e[17] = r),
				(e[18] = i),
				(e[19] = s),
				(e[20] = u))
			: (u = e[20]),
		u
	);
}
function X0(t) {
	return t === T5.sanitizeUrl(t);
}
const MTe = (t) => Xs(t, "link"),
	vJ = (t, e) => {
		if (MTe(t)) {
			W.unwrapNodes(t, { match: (i) => i.type === "link" });
			return;
		}
		const { selection: n } = t;
		n && ie.isCollapsed(n)
			? W.insertNodes(t, {
					type: "link",
					href: e,
					children: [{ text: e }],
				})
			: W.wrapNodes(
					t,
					{ type: "link", href: e, children: [{ text: "" }] },
					{ split: !0 },
				);
	},
	jTe = (t) => {
		const e = ee(56),
			{ attributes: n, children: r, element: i } = t,
			o = Le(Ht),
			s = wn(),
			[a, l] = v5(s, i),
			u = a.href;
		let c;
		e[0] !== a ? ((c = pe.string(a)), (e[0] = a), (e[1] = c)) : (c = e[1]);
		const d = c,
			[f, h] = E.useState(!1),
			g = k5() === i;
		let v, b;
		e[2] !== g || e[3] !== u
			? ((v = () => {
					g && !u && h(!0);
				}),
				(b = [u, g]),
				(e[2] = g),
				(e[3] = u),
				(e[4] = v),
				(e[5] = b))
			: ((v = e[4]), (b = e[5])),
			E.useEffect(v, b);
		let y;
		e[6] !== s || e[7] !== i
			? ((y = () => {
					W.unwrapNodes(s, { at: te.findPath(s, i) }), te.focus(s);
				}),
				(e[6] = s),
				(e[7] = i),
				(e[8] = y))
			: (y = e[8]);
		const x = Ri(y);
		let C;
		e[9] !== u || e[10] !== n || e[11] !== r
			? ((C = m.jsx("a", { href: u, ...n, children: r })),
				(e[9] = u),
				(e[10] = n),
				(e[11] = r),
				(e[12] = C))
			: (C = e[12]);
		let k;
		e[13] === Symbol.for("react.memo_cache_sentinel")
			? ((k = () => h(!0)), (e[13] = k))
			: (k = e[13]);
		let w;
		e[14] === Symbol.for("react.memo_cache_sentinel")
			? ((w = m.jsx(Re, {
					prominence: "low",
					onPress: k,
					children: m.jsx(ve, { src: V0 }),
				})),
				(e[14] = w))
			: (w = e[14]);
		let D;
		e[15] !== o
			? ((D = o.format("edit")), (e[15] = o), (e[16] = D))
			: (D = e[16]);
		let S;
		e[17] !== D
			? ((S = m.jsxs(Ze, { children: [w, m.jsx(Xe, { children: D })] })),
				(e[17] = D),
				(e[18] = S))
			: (S = e[18]);
		let $;
		e[19] !== u
			? (($ = () => {
					window.open(u, "_blank", "noopener,noreferrer");
				}),
				(e[19] = u),
				(e[20] = $))
			: ($ = e[20]);
		let A;
		e[21] === Symbol.for("react.memo_cache_sentinel")
			? ((A = m.jsx(ve, { src: S3 })), (e[21] = A))
			: (A = e[21]);
		let T;
		e[22] !== $
			? ((T = m.jsx(Re, { prominence: "low", onPress: $, children: A })),
				(e[22] = $),
				(e[23] = T))
			: (T = e[23]);
		let I;
		e[24] !== u
			? ((I = m.jsx(Xe, {
					children: m.jsx(ue, { truncate: 3, children: u }),
				})),
				(e[24] = u),
				(e[25] = I))
			: (I = e[25]);
		let F;
		e[26] !== T || e[27] !== I
			? ((F = m.jsxs(Ze, { children: [T, I] })),
				(e[26] = T),
				(e[27] = I),
				(e[28] = F))
			: (F = e[28]);
		let N;
		e[29] === Symbol.for("react.memo_cache_sentinel")
			? ((N = m.jsx(ve, { src: MW })), (e[29] = N))
			: (N = e[29]);
		let O;
		e[30] !== x
			? ((O = m.jsx(Re, { prominence: "low", onPress: x, children: N })),
				(e[30] = x),
				(e[31] = O))
			: (O = e[31]);
		let _;
		e[32] === Symbol.for("react.memo_cache_sentinel")
			? ((_ = m.jsx(Xe, { children: "Unlink" })), (e[32] = _))
			: (_ = e[32]);
		let j;
		e[33] !== O
			? ((j = m.jsxs(Ze, { children: [O, _] })), (e[33] = O), (e[34] = j))
			: (j = e[34]);
		let V;
		e[35] !== S || e[36] !== F || e[37] !== j
			? ((V = m.jsx(tf, {
					placement: "bottom start",
					children: m.jsxs(ke, {
						gap: "small",
						padding: "regular",
						children: [S, F, j],
					}),
				})),
				(e[35] = S),
				(e[36] = F),
				(e[37] = j),
				(e[38] = V))
			: (V = e[38]);
		let K;
		e[39] !== i || e[40] !== C || e[41] !== V
			? ((K = m.jsxs(ef, { element: i, children: [C, V] })),
				(e[39] = i),
				(e[40] = C),
				(e[41] = V),
				(e[42] = K))
			: (K = e[42]);
		let M;
		e[43] !== s
			? ((M = () => {
					h(!1), b5(s);
				}),
				(e[43] = s),
				(e[44] = M))
			: (M = e[44]);
		let G;
		e[45] !== f || e[46] !== l || e[47] !== d || e[48] !== u
			? ((G =
					f &&
					m.jsx(_Te, {
						text: d,
						href: u,
						onSubmit: (q) => {
							const { href: J } = q;
							l({ href: J });
						},
					})),
				(e[45] = f),
				(e[46] = l),
				(e[47] = d),
				(e[48] = u),
				(e[49] = G))
			: (G = e[49]);
		let H;
		e[50] !== M || e[51] !== G
			? ((H = m.jsx(mn, { onDismiss: M, children: G })),
				(e[50] = M),
				(e[51] = G),
				(e[52] = H))
			: (H = e[52]);
		let P;
		return (
			e[53] !== K || e[54] !== H
				? ((P = m.jsxs(m.Fragment, { children: [K, H] })),
					(e[53] = K),
					(e[54] = H),
					(e[55] = P))
				: (P = e[55]),
			P
		);
	};
function _Te(t) {
	const e = ee(40);
	let n, r;
	e[0] !== t
		? (({ onSubmit: r, ...n } = t), (e[0] = t), (e[1] = n), (e[2] = r))
		: ((n = e[1]), (r = e[2]));
	const [i, o] = E.useState(n.href || ""),
		[s, a] = E.useState(!1),
		{ dismiss: l } = Xd(),
		u = Le(Ht);
	let c;
	e[3] !== s || e[4] !== i
		? ((c = s && !X0(i)), (e[3] = s), (e[4] = i), (e[5] = c))
		: (c = e[5]);
	const d = c;
	let f;
	e[6] === Symbol.for("react.memo_cache_sentinel")
		? ((f = { display: "contents" }), (e[6] = f))
		: (f = e[6]);
	let h;
	e[7] !== d || e[8] !== l || e[9] !== r || e[10] !== i
		? ((h = (T) => {
				T.target === T.currentTarget &&
					(T.preventDefault(), d || (l(), r({ href: i })));
			}),
			(e[7] = d),
			(e[8] = l),
			(e[9] = r),
			(e[10] = i),
			(e[11] = h))
		: (h = e[11]);
	const p = n.href ? "Edit" : "Add";
	let g;
	e[12] !== p
		? ((g = m.jsxs(Ut, { children: [p, " link"] })),
			(e[12] = p),
			(e[13] = g))
		: (g = e[13]);
	let v;
	e[14] !== n.text
		? ((v = m.jsx(An, { label: "Text", value: n.text, isReadOnly: !0 })),
			(e[14] = n.text),
			(e[15] = v))
		: (v = e[15]);
	let b;
	e[16] === Symbol.for("react.memo_cache_sentinel")
		? ((b = () => a(!0)), (e[16] = b))
		: (b = e[16]);
	const y = d && "Please provide a valid URL.";
	let x;
	e[17] !== i || e[18] !== y
		? ((x = m.jsx(An, {
				autoFocus: !0,
				isRequired: !0,
				onBlur: b,
				label: "Link",
				onChange: o,
				value: i,
				errorMessage: y,
			})),
			(e[17] = i),
			(e[18] = y),
			(e[19] = x))
		: (x = e[19]);
	let C;
	e[20] !== v || e[21] !== x
		? ((C = m.jsx(Pr, {
				children: m.jsxs(ke, {
					gap: "large",
					direction: "column",
					children: [v, x],
				}),
			})),
			(e[20] = v),
			(e[21] = x),
			(e[22] = C))
		: (C = e[22]);
	let k;
	e[23] !== u
		? ((k = u.format("cancel")), (e[23] = u), (e[24] = k))
		: (k = e[24]);
	let w;
	e[25] !== l || e[26] !== k
		? ((w = m.jsx(vt, { onPress: l, children: k })),
			(e[25] = l),
			(e[26] = k),
			(e[27] = w))
		: (w = e[27]);
	let D;
	e[28] !== u
		? ((D = u.format("save")), (e[28] = u), (e[29] = D))
		: (D = e[29]);
	let S;
	e[30] !== D
		? ((S = m.jsx(vt, { prominence: "high", type: "submit", children: D })),
			(e[30] = D),
			(e[31] = S))
		: (S = e[31]);
	let $;
	e[32] !== w || e[33] !== S
		? (($ = m.jsxs(Nr, { children: [w, S] })),
			(e[32] = w),
			(e[33] = S),
			(e[34] = $))
		: ($ = e[34]);
	let A;
	return (
		e[35] !== h || e[36] !== g || e[37] !== C || e[38] !== $
			? ((A = m.jsx(vr, {
					size: "small",
					children: m.jsxs("form", {
						style: f,
						onSubmit: h,
						children: [g, C, $],
					}),
				})),
				(e[35] = h),
				(e[36] = g),
				(e[37] = C),
				(e[38] = $),
				(e[39] = A))
			: (A = e[39]),
		A
	);
}
let zTe = m.jsx(ve, { src: OW });
function LTe() {
	const t = ee(6),
		{ editor: e, links: n } = zs(),
		{ isDisabled: r, isSelected: i } = n;
	let o, s;
	t[0] !== e
		? ((s = () => {
				vJ(e, ""), te.focus(e);
			}),
			(t[0] = e),
			(t[1] = s))
		: (s = t[1]);
	let a;
	return (
		t[2] !== r || t[3] !== i || t[4] !== s
			? ((a = m.jsx(Re, {
					prominence: "low",
					isDisabled: r,
					isSelected: i,
					onPress: s,
					children: zTe,
				})),
				(t[2] = r),
				(t[3] = i),
				(t[4] = s),
				(t[5] = a))
			: (a = t[5]),
		(o = a),
		o
	);
}
const VTe = m.jsxs(Ze, {
		children: [
			m.jsx(LTe, {}),
			m.jsx(Xe, { children: m.jsx(ue, { children: "Link" }) }),
		],
	}),
	$C = {
		start: {
			key: "start",
			label: "Align Start",
			icon: m.jsx(ve, { src: X3e }),
		},
		center: {
			key: "center",
			label: "Align Center",
			icon: m.jsx(ve, { src: Q3e }),
		},
		end: { key: "end", label: "Align End", icon: m.jsx(ve, { src: Z3e }) },
	},
	KTe = (t) => {
		const e = ee(23),
			{ alignment: n } = t,
			r = zs();
		let i, o;
		if (e[0] !== n) {
			let x;
			e[2] === Symbol.for("react.memo_cache_sentinel")
				? ((x = (C) => $C[C]), (e[2] = x))
				: (x = e[2]),
				(o = Object.keys(n).map(x)),
				(e[0] = n),
				(e[1] = o);
		} else o = e[1];
		let s;
		e[3] !== o
			? ((s = [$C.start, ...o]), (e[3] = o), (e[4] = s))
			: (s = e[4]),
			(i = s);
		const a = i;
		let l;
		const u = $C[r.alignment.selected];
		let c;
		e[5] === Symbol.for("react.memo_cache_sentinel")
			? ((c = m.jsx(ve, { src: Il })), (e[5] = c))
			: (c = e[5]);
		let d;
		e[6] !== u.icon
			? ((d = m.jsxs(Re, { prominence: "low", children: [u.icon, c] })),
				(e[6] = u.icon),
				(e[7] = d))
			: (d = e[7]);
		let f;
		e[8] === Symbol.for("react.memo_cache_sentinel")
			? ((f = m.jsx(Xe, {
					children: m.jsx(ue, { children: "Text Alignment" }),
				})),
				(e[8] = f))
			: (f = e[8]);
		let h;
		e[9] !== d
			? ((h = m.jsxs(Ze, { children: [d, f] })), (e[9] = d), (e[10] = h))
			: (h = e[10]);
		let p;
		e[11] !== r.alignment.selected
			? ((p = [r.alignment.selected]),
				(e[11] = r.alignment.selected),
				(e[12] = p))
			: (p = e[12]);
		let g;
		e[13] !== r.editor
			? ((g = (x) => {
					x === "start"
						? W.unsetNodes(r.editor, "textAlign", {
								match: (C) =>
									C.type === "paragraph" ||
									C.type === "heading",
							})
						: W.setNodes(
								r.editor,
								{ textAlign: x },
								{
									match: (C) =>
										C.type === "paragraph" ||
										C.type === "heading",
								},
							),
						te.focus(r.editor);
				}),
				(e[13] = r.editor),
				(e[14] = g))
			: (g = e[14]);
		let v;
		e[15] === Symbol.for("react.memo_cache_sentinel")
			? ((v = (x) =>
					m.jsxs(
						Mt,
						{
							textValue: x.label,
							children: [
								m.jsx(ue, { children: x.label }),
								x.icon,
							],
						},
						x.key,
					)),
				(e[15] = v))
			: (v = e[15]);
		let b;
		e[16] !== p || e[17] !== a || e[18] !== g
			? ((b = m.jsx(Jo, {
					selectionMode: "single",
					selectedKeys: p,
					items: a,
					onAction: g,
					children: v,
				})),
				(e[16] = p),
				(e[17] = a),
				(e[18] = g),
				(e[19] = b))
			: (b = e[19]);
		let y;
		return (
			e[20] !== h || e[21] !== b
				? ((y = m.jsxs(Xo, { children: [h, b] })),
					(e[20] = h),
					(e[21] = b),
					(e[22] = y))
				: (y = e[22]),
			(l = y),
			l
		);
	},
	UTe = (t) => {
		Xs(t, "blockquote")
			? W.unwrapNodes(t, { match: (n) => n.type === "blockquote" })
			: W.wrapNodes(t, { type: "blockquote", children: [] });
	},
	HTe = () => {
		const t = ee(7),
			{ editor: e, blockquote: n } = zs(),
			{ isDisabled: r, isSelected: i } = n;
		let o, s;
		t[0] !== e
			? ((s = () => {
					UTe(e), te.focus(e);
				}),
				(t[0] = e),
				(t[1] = s))
			: (s = t[1]);
		let a;
		t[2] === Symbol.for("react.memo_cache_sentinel")
			? ((a = m.jsx(ve, { src: JD })), (t[2] = a))
			: (a = t[2]);
		let l;
		return (
			t[3] !== i || t[4] !== r || t[5] !== s
				? ((l = m.jsx(Re, {
						prominence: "low",
						isSelected: i,
						isDisabled: r,
						onPress: s,
						children: a,
					})),
					(t[3] = i),
					(t[4] = r),
					(t[5] = s),
					(t[6] = l))
				: (l = t[6]),
			(o = l),
			o
		);
	},
	WTe = m.jsxs(Ze, {
		children: [
			m.jsx(HTe, {}),
			m.jsxs(Xe, {
				children: [
					m.jsx(ue, { children: "Quote" }),
					m.jsx(fi, { children: ">⎵" }),
				],
			}),
		],
	}),
	W3 = [
		{ label: "C", value: "c" },
		{ label: "C++", value: "cpp" },
		{ label: "Arduino", value: "arduino" },
		{ label: "Bash", value: "bash" },
		{ label: "C#", value: "csharp" },
		{ label: "CSS", value: "css" },
		{ label: "Diff", value: "diff" },
		{ label: "Go", value: "go" },
		{ label: "INI", value: "ini" },
		{ label: "Java", value: "java" },
		{ label: "JavaScript", value: "javascript" },
		{ label: "JSX", value: "jsx" },
		{ label: "JSON", value: "json" },
		{ label: "Kotlin", value: "kotlin" },
		{ label: "Less", value: "less" },
		{ label: "Lua", value: "lua" },
		{ label: "Makefile", value: "makefile" },
		{ label: "Markdown", value: "markdown" },
		{ label: "Objective-C", value: "objectivec" },
		{ label: "Perl", value: "perl" },
		{ label: "PHP", value: "php" },
		{ label: "Python", value: "python" },
		{ label: "R", value: "r" },
		{ label: "Ruby", value: "ruby" },
		{ label: "Rust", value: "rust" },
		{ label: "Sass", value: "sass" },
		{ label: "SCSS", value: "scss" },
		{ label: "SQL", value: "sql" },
		{ label: "Swift", value: "swift" },
		{ label: "TypeScript", value: "typescript" },
		{ label: "TSX", value: "tsx" },
		{ label: "VB.NET", value: "vbnet" },
		{ label: "YAML", value: "yaml" },
	],
	Ky = new Map(W3.map((t) => [t.value, t.label])),
	PF = new Map(W3.map((t) => [t.label, t.value])),
	qTe = new Map(W3.map((t) => [Q.languages[t.value], t.value])),
	_c = new Map(
		Object.keys(Q.languages).flatMap((t) => {
			const e = qTe.get(Q.languages[t]);
			return e === void 0 ? [] : [[t, e]];
		}),
	),
	yJ = new Map(W3.map((t) => [t.value, []]));
for (const [t, e] of _c) yJ.get(e).push(t);
const NF = [
		{ label: "Plain text", value: "plain", aliases: [] },
		...[...yJ].map(([t, e]) => ({
			label: Ky.get(t),
			value: t,
			aliases: e,
		})),
	],
	GTe = new Map([..._c].map(([t, e]) => [t, Ky.get(e)]));
function YTe(t) {
	const e = wn(),
		[n, r] = E.useState(() =>
			ua(
				t.schema,
				Object.fromEntries(
					Object.keys(t.schema.fields).map((u) => [u, t.element[u]]),
				),
			),
		),
		[i, o] = E.useState(!1),
		s = E.useMemo(() => Ba(t.schema, r, () => {}), [t.schema])(n);
	let { dismiss: a } = Xd();
	const l = Le(Ht);
	return m.jsx(vr, {
		size: "small",
		children: m.jsxs("form", {
			style: { display: "contents" },
			onSubmit: (u) => {
				if (
					u.target === u.currentTarget &&
					(u.preventDefault(), o(!0), _s(t.schema, n, void 0))
				) {
					a();
					const c = te.findPath(e, t.element);
					console.log(n), W.setNodes(e, n, { at: c });
				}
			},
			children: [
				m.jsxs(Ut, { children: [t.nodeLabel, " details"] }),
				m.jsx(Pr, {
					children: m.jsx(Ia, {
						forceValidation: i,
						autoFocus: !0,
						...s,
					}),
				}),
				m.jsxs(Nr, {
					children: [
						m.jsx(vt, { onPress: a, children: l.format("cancel") }),
						m.jsx(vt, {
							prominence: "high",
							type: "submit",
							children: l.format("save"),
						}),
					],
				}),
			],
		}),
	});
}
function xJ(t) {
	const e = ee(10),
		n = Le(Ht);
	let r;
	e[0] === Symbol.for("react.memo_cache_sentinel")
		? ((r = m.jsx(ve, { src: V0 })), (e[0] = r))
		: (r = e[0]);
	let i;
	e[1] !== t.onPress
		? ((i = m.jsx(Re, {
				prominence: "low",
				onPress: t.onPress,
				children: r,
			})),
			(e[1] = t.onPress),
			(e[2] = i))
		: (i = e[2]);
	let o;
	e[3] !== n ? ((o = n.format("edit")), (e[3] = n), (e[4] = o)) : (o = e[4]);
	let s;
	e[5] !== o
		? ((s = m.jsx(Xe, { children: o })), (e[5] = o), (e[6] = s))
		: (s = e[6]);
	let a;
	return (
		e[7] !== i || e[8] !== s
			? ((a = m.jsxs(Ze, { children: [i, s] })),
				(e[7] = i),
				(e[8] = s),
				(e[9] = a))
			: (a = e[9]),
		a
	);
}
function kJ(t) {
	const e = ee(8),
		n = wn();
	let r;
	e[0] !== t || e[1] !== n
		? ((r = () => {
				t.onDismiss(), b5(n);
			}),
			(e[0] = t),
			(e[1] = n),
			(e[2] = r))
		: (r = e[2]);
	let i;
	e[3] !== t
		? ((i =
				t.isOpen &&
				m.jsx(YTe, {
					element: t.element,
					nodeLabel: t.nodeLabel,
					schema: t.schema,
				})),
			(e[3] = t),
			(e[4] = i))
		: (i = e[4]);
	let o;
	return (
		e[5] !== r || e[6] !== i
			? ((o = m.jsx(mn, { onDismiss: r, children: i })),
				(e[5] = r),
				(e[6] = i),
				(e[7] = o))
			: (o = e[7]),
		o
	);
}
function JTe() {
	const t = ee(8),
		{ editor: e, code: n } = zs(),
		{ isDisabled: r, isSelected: i } = n;
	let o, s;
	t[0] !== i || t[1] !== e
		? ((s = () => {
				i
					? W.unwrapNodes(e, { match: (u) => u.type === "code" })
					: W.wrapNodes(e, {
							type: "code",
							children: [{ text: "" }],
						}),
					te.focus(e);
			}),
			(t[0] = i),
			(t[1] = e),
			(t[2] = s))
		: (s = t[2]);
	let a;
	t[3] === Symbol.for("react.memo_cache_sentinel")
		? ((a = m.jsx(ve, { src: Kx })), (t[3] = a))
		: (a = t[3]);
	let l;
	return (
		t[4] !== i || t[5] !== r || t[6] !== s
			? ((l = m.jsx(Re, {
					isSelected: i,
					isDisabled: r,
					prominence: "low",
					onPress: s,
					children: a,
				})),
				(t[4] = i),
				(t[5] = r),
				(t[6] = s),
				(t[7] = l))
			: (l = t[7]),
		(o = l),
		o
	);
}
const XTe = m.jsxs(Ze, {
	children: [
		m.jsx(JTe, {}),
		m.jsxs(Xe, {
			children: [
				m.jsx(ue, { children: "Code block" }),
				m.jsx(fi, { children: "```" }),
			],
		}),
	],
});
function ZTe({ attributes: t, children: e, element: n }) {
	var r;
	const i = wn(),
		o = E.useRef(null),
		[s, a] = E.useState(
			n.language
				? (r = GTe.get(n.language)) !== null && r !== void 0
					? r
					: n.language
				: "Plain text",
		),
		[l, u] = E.useState(!1),
		{ documentFeatures: c } = Ls(),
		d =
			c.formatting.blockTypes.code &&
			Object.keys(c.formatting.blockTypes.code.schema.fields).length
				? c.formatting.blockTypes.code.schema
				: void 0;
	return m.jsxs(m.Fragment, {
		children: [
			m.jsx(aA, {
				children: m.jsxs(ef, {
					element: n,
					children: [
						m.jsx("pre", {
							spellCheck: "false",
							ref: o,
							children: m.jsx("code", { ...t, children: e }),
						}),
						m.jsx(tf, {
							children: m.jsxs(ke, {
								gap: "regular",
								padding: "regular",
								children: [
									m.jsx(L0, {
										"aria-label": "Language",
										width: "scale.2000",
										allowsCustomValue: !0,
										inputValue: s,
										onInputChange: a,
										onBlur: () => {
											const f = te.findPath(i, n),
												h = _c.get(s);
											if (h !== void 0) {
												if (h === "plain") {
													W.unsetNodes(
														i,
														"language",
														{ at: f },
													);
													return;
												}
												a(Ky.get(h)),
													W.setNodes(
														i,
														{ language: h },
														{ at: f },
													);
												return;
											}
											const p = PF.get(s);
											if (p !== void 0) {
												if (p === "plain") {
													W.unsetNodes(
														i,
														"language",
														{ at: f },
													);
													return;
												}
												W.setNodes(
													i,
													{ language: p },
													{ at: f },
												);
												return;
											}
											if (s === "") {
												W.unsetNodes(i, "language", {
													at: f,
												}),
													a("Plain text");
												return;
											}
											s !== n.language &&
												W.setNodes(
													i,
													{ language: s },
													{ at: f },
												);
										},
										onSelectionChange: (f) => {
											const h = te.findPath(i, n);
											if (
												(_c.has(s) && (f = _c.get(s)),
												f === null)
											)
												s === ""
													? W.unsetNodes(
															i,
															"language",
															{ at: h },
														)
													: W.setNodes(
															i,
															{ language: s },
															{ at: h },
														);
											else if (typeof f == "string") {
												if (f === "plain") {
													W.unsetNodes(
														i,
														"language",
														{ at: h },
													),
														a("Plain text");
													return;
												}
												W.setNodes(
													i,
													{ language: f },
													{ at: h },
												);
												const p = Ky.get(f);
												p && a(p);
											}
										},
										selectedKey: n.language
											? _c.get(n.language)
											: "plain",
										items: E.useMemo(
											() =>
												s === "Plain text" || PF.has(s)
													? NF
													: $3(NF, s, {
															keys: [
																"label",
																"value",
																"aliases",
															],
														}),
											[s],
										),
										children: (f) =>
											m.jsx(
												Mt,
												{ children: f.label },
												f.value,
											),
									}),
									m.jsx(H3, {}),
									d !== void 0 &&
										m.jsx(xJ, { onPress: () => u(!0) }),
									m.jsxs(Ze, {
										children: [
											m.jsx(Re, {
												prominence: "low",
												onPress: () => {
													W.removeNodes(i, {
														at: te.findPath(i, n),
													});
												},
												children: m.jsx(ve, {
													src: Wr,
												}),
											}),
											m.jsx(Xe, {
												tone: "critical",
												children: "Remove",
											}),
										],
									}),
								],
							}),
						}),
					],
				}),
			}),
			d !== void 0 &&
				m.jsx(kJ, {
					element: n,
					isOpen: l,
					nodeLabel: "Code block",
					schema: d,
					onDismiss: () => {
						u(!1);
					},
				}),
		],
	});
}
function jg(t, e) {
	const n = [...e];
	for (; n.length; ) {
		const r = n.shift();
		t = t[r];
	}
	return t;
}
function _b(t, e, n, r = []) {
	if (t.kind === "form" || t.kind === "child") {
		n(t, e, r);
		return;
	}
	if (t.kind === "object") {
		for (const [i, o] of Object.entries(t.fields))
			_b(o, e[i], n, [...r, i]);
		n(t, e, r);
		return;
	}
	if (t.kind === "array") {
		for (const [i, o] of e.entries()) _b(t.element, o, n, r.concat(i));
		return n(t, e, r);
	}
	if (t.kind === "conditional") {
		const i = e.discriminant;
		n(t, i, r.concat("discriminant")),
			_b(t.values[i.toString()], e.value, n, r.concat("value")),
			n(t, e, r);
		return;
	}
	qn(t);
}
function Eu(t, e, n, r = []) {
	if (t.kind === "form" || t.kind === "child")
		return n[t.kind] ? n[t.kind](t, e, r) : e;
	if (t.kind === "object") {
		const i = Object.fromEntries(
			Object.entries(t.fields).map(([o, s]) => [
				o,
				Eu(s, e[o], n, [...r, o]),
			]),
		);
		return n.object ? n[t.kind](t, i, r) : i;
	}
	if (t.kind === "array") {
		const i = e.map((o, s) => Eu(t.element, o, n, r.concat(s)));
		return n.array ? n[t.kind](t, i, r) : i;
	}
	if (t.kind === "conditional") {
		const i = Eu(
				t.discriminant,
				e.discriminant,
				n,
				r.concat("discriminant"),
			),
			o = Eu(t.values[i.toString()], e.value, n, r.concat("value")),
			s = { discriminant: i, value: o };
		return n.conditional ? n[t.kind](t, s, r) : s;
	}
	qn(t);
}
function zb(t, e, n, r) {
	if (r.length === 0) return n;
	const [i, ...o] = r;
	if (t.kind === "object") return { ...e, [i]: zb(t.fields[i], e[i], n, o) };
	if (t.kind === "conditional") {
		const s = e;
		return (
			wt(i === "value"),
			{
				discriminant: s.discriminant,
				value: zb(t.values[i], s.value, n, o),
			}
		);
	}
	if (t.kind === "array") {
		const s = e,
			a = [...s];
		return sf(a, Kr(s)), (a[i] = zb(t.element, a[i], n, o)), a;
	}
	wt(t.kind !== "form" && t.kind !== "child"), qn(t);
}
function QTe(t, e, n, r, i, o, s) {
	R.withoutNormalizing(t, () => {
		const a = new Map(),
			l = { kind: "object", fields: e.schema },
			u = Eu(l, r, {
				child(y, x, C) {
					if (!s && y.options.kind === "block" && x) {
						try {
							if (jg(n, C) === x) return null;
						} catch {}
						a.set(JSON.stringify(C), x.map(x5));
					}
					return null;
				},
			});
		o({ props: u });
		const c = Lb(u, n, l, [], [], []),
			d = () => pe.get(t, i),
			f = d();
		if (c.length === 0) {
			const y = f.children.map((x, C) => C).reverse();
			for (const x of y) W.removeNodes(t, { at: [...i, x] });
			W.insertNodes(
				t,
				{
					type: "component-inline-prop",
					propPath: void 0,
					children: [{ text: "" }],
				},
				{ at: [...i, 0] },
			);
			return;
		}
		const h = new Map();
		for (const [y, x] of f.children.entries())
			wt(
				x.type === "component-block-prop" ||
					x.type === "component-inline-prop",
			),
				h.set(
					x.propPath === void 0 ? void 0 : JSON.stringify(x.propPath),
					y,
				);
		const p = new Set(c);
		for (const y of c) {
			if (y.prevPath === void 0) continue;
			const x = JSON.stringify(y.prevPath),
				C = h.get(x);
			if (C !== void 0) {
				const k = f.children[C];
				wt(k.propPath !== void 0),
					Bd(y.path, k.propPath) ||
						W.setNodes(t, { propPath: y.path }, { at: [...i, C] }),
					p.delete(y),
					h.delete(x);
			}
		}
		let g = d().children.length;
		for (const y of p)
			W.insertNodes(
				t,
				{
					type: `component-${y.options.kind}-prop`,
					propPath: y.path,
					children: [
						y.options.kind === "block"
							? { type: "paragraph", children: [{ text: "" }] }
							: { text: "" },
					],
				},
				{ at: [...i, g] },
			),
				g++;
		const v = [];
		for (const [, y] of h) v.push(R.pathRef(t, [...i, y]));
		for (const y of v) {
			const x = y.unref();
			wt(x !== null), W.removeNodes(t, { at: x });
		}
		const b = new Map();
		for (const [y, x] of c.entries()) b.set(JSON.stringify(x.path), y);
		e: for (;;) {
			for (const [y, x] of d().children.entries()) {
				wt(
					x.type === "component-block-prop" ||
						x.type === "component-inline-prop",
				);
				const C = b.get(JSON.stringify(x.propPath));
				if ((wt(C !== void 0), y !== C)) {
					W.moveNodes(t, { at: [...i, y], to: [...i, C] });
					continue e;
				}
			}
			break;
		}
		for (const [y, x] of a) {
			const C = b.get(y);
			C !== void 0 &&
				(W.removeNodes(t, { at: [...i, C] }),
				W.insertNodes(
					t,
					{
						type: "component-block-prop",
						propPath: JSON.parse(y),
						children: x,
					},
					{ at: [...i, C] },
				));
		}
	});
}
function Lb(t, e, n, r, i, o) {
	switch (n.kind) {
		case "form":
			return [];
		case "child":
			return [{ path: r, prevPath: i, options: n.options }];
		case "conditional":
			const s = t.discriminant === e.discriminant;
			return Lb(
				t.value,
				s ? e.value : an(n.values[t.discriminant]),
				n.values[t.discriminant],
				r.concat("value"),
				s || i == null ? void 0 : i.concat("value"),
				s || o == null ? void 0 : o.concat("value"),
			);
		case "object": {
			const a = [];
			for (const l of Object.keys(n.fields))
				a.push(
					...Lb(
						t[l],
						e[l],
						n.fields[l],
						r.concat(l),
						i == null ? void 0 : i.concat(l),
						o == null ? void 0 : o.concat(l),
					),
				);
			return a;
		}
		case "array": {
			const a = [],
				l = Kr(e),
				u = Kr(t);
			for (const [c, d] of t.entries()) {
				const f = u[c],
					h = l.indexOf(f);
				let p;
				h === -1 ? (p = an(n.element)) : (p = e[h]),
					a.push(
						...Lb(
							d,
							p,
							n.element,
							r.concat(c),
							h === -1 || i == null ? void 0 : i.concat(h),
							h === -1 || o == null ? void 0 : o.concat(f),
						),
					);
			}
			return a;
		}
	}
}
const CJ = le.createContext({});
function eBe(t) {
	const { path: e } = t,
		r = E.useContext(CJ)[JSON.stringify(e)];
	return r === void 0 ? null : r;
}
function tBe({
	componentBlock: t,
	element: e,
	onChange: n,
	children: r,
	onRemove: i,
}) {
	const s = E.useMemo(
			() =>
				Ba(
					{ kind: "object", fields: t.schema },
					(d) => n(d, !0),
					(d) => m.jsx(eBe, { path: d }),
				),
			[n, t],
		)(e.props),
		a = {};
	let l,
		u = [];
	r.forEach((d) => {
		const f = d.props.children.props.element.propPath;
		if (f === void 0) l = d;
		else {
			const h = y5(f, e.props, t.schema);
			if (
				(h == null ? void 0 : h.kind) === "child" &&
				h.options.kind === "block" &&
				h.options.editIn === "modal"
			) {
				u.push(d);
				return;
			}
			a[JSON.stringify(nBe(f, e.props))] = d;
		}
	});
	const c = t.preview;
	return m.jsxs(CJ.Provider, {
		value: a,
		children: [
			E.useMemo(() => m.jsx(c, { onRemove: i, ...s }), [c, i, s]),
			m.jsxs("span", {
				className: X({
					caretColor: "transparent",
					"& ::selection": { backgroundColor: "transparent" },
					overflow: "hidden",
					width: 1,
					height: 1,
					position: "absolute",
				}),
				children: [l, u],
			}),
		],
	});
}
function nBe(t, e) {
	return t.map((n) => {
		var r;
		if (typeof n == "string") {
			var i;
			return (e = (i = e) === null || i === void 0 ? void 0 : i[n]), n;
		}
		if (!Array.isArray(e)) return (e = void 0), "";
		const o = Kr(e);
		return (e = (r = e) === null || r === void 0 ? void 0 : r[n]), o[n];
	});
}
function rBe(t) {
	var e;
	const n = ee(33),
		r = $z();
	let i, o;
	n[0] !== t.componentBlock.schema || n[1] !== t.elementProps
		? ((o = _s(
				{ kind: "object", fields: t.componentBlock.schema },
				t.elementProps,
				void 0,
			)),
			(n[0] = t.componentBlock.schema),
			(n[1] = t.elementProps),
			(n[2] = o))
		: (o = n[2]),
		(i = o);
	const s = i,
		[a, l] = E.useState(!1);
	let u;
	n[3] === Symbol.for("react.memo_cache_sentinel")
		? ((u = () => {
				l(!1);
			}),
			(n[3] = u))
		: (u = n[3]);
	const c = u;
	let d;
	n[4] === Symbol.for("react.memo_cache_sentinel")
		? ((d = () => {
				l(!0);
			}),
			(n[4] = d))
		: (d = n[4]);
	const f = d,
		h = (e = t.componentBlock.toolbar) !== null && e !== void 0 ? e : oBe;
	let p;
	n[5] !== t.componentBlock.label
		? ((p = m.jsx(C5, {
				children: m.jsx(ue, {
					casing: "uppercase",
					color: "neutralSecondary",
					weight: "medium",
					size: "small",
					children: t.componentBlock.label,
				}),
			})),
			(n[5] = t.componentBlock.label),
			(n[6] = p))
		: (p = n[6]);
	let g;
	n[7] !== h || n[8] !== s || n[9] !== t.onRemove || n[10] !== t.previewProps
		? ((g = m.jsx(h, {
				isValid: s,
				onRemove: t.onRemove,
				props: t.previewProps,
				onShowEditMode: f,
			})),
			(n[7] = h),
			(n[8] = s),
			(n[9] = t.onRemove),
			(n[10] = t.previewProps),
			(n[11] = g))
		: (g = n[11]);
	let v;
	n[12] === Symbol.for("react.memo_cache_sentinel")
		? ((v = () => c()), (n[12] = v))
		: (v = n[12]);
	let b;
	e: {
		if (!a) {
			b = void 0;
			break e;
		}
		let w;
		n[13] !== t.componentBlock.label
			? ((w = m.jsxs(Ut, {
					children: ["Edit ", t.componentBlock.label],
				})),
				(n[13] = t.componentBlock.label),
				(n[14] = w))
			: (w = n[14]);
		let D;
		n[15] !== t.previewProps
			? ((D = m.jsx(sBe, { props: t.previewProps, onClose: c })),
				(n[15] = t.previewProps),
				(n[16] = D))
			: (D = n[16]);
		let S;
		n[17] !== w || n[18] !== D
			? ((S = m.jsxs(vr, { children: [w, D] })),
				(n[17] = w),
				(n[18] = D),
				(n[19] = S))
			: (S = n[19]),
			(b = S);
	}
	let y;
	n[20] !== b
		? ((y = m.jsx(mn, { onDismiss: v, children: b })),
			(n[20] = b),
			(n[21] = y))
		: (y = n[21]);
	let x;
	n[22] !== t.renderedBlock || n[23] !== g || n[24] !== y
		? ((x = m.jsxs(E.Fragment, { children: [t.renderedBlock, g, y] })),
			(n[22] = t.renderedBlock),
			(n[23] = g),
			(n[24] = y),
			(n[25] = x))
		: (x = n[25]);
	let C;
	n[26] !== p || n[27] !== x
		? ((C = m.jsxs(ke, {
				gap: "medium",
				direction: "column",
				children: [p, x],
			})),
			(n[26] = p),
			(n[27] = x),
			(n[28] = C))
		: (C = n[28]);
	let k;
	return (
		n[29] !== r || n[30] !== t.attributes || n[31] !== C
			? ((k = m.jsx(iBe, { selected: r, ...t.attributes, children: C })),
				(n[29] = r),
				(n[30] = t.attributes),
				(n[31] = C),
				(n[32] = k))
			: (k = n[32]),
		k
	);
}
const iBe = E.forwardRef(function (e, n) {
	const r = ee(11);
	let i, o, s;
	r[0] !== e
		? (({ children: s, selected: i, ...o } = e),
			(r[0] = e),
			(r[1] = i),
			(r[2] = o),
			(r[3] = s))
		: ((i = r[1]), (o = r[2]), (s = r[3]));
	const a = i ? B.color.alias.borderSelected : B.color.alias.borderIdle;
	let l;
	r[4] !== a
		? ((l = X(E3, {
				position: "relative",
				paddingInlineStart: B.size.space.xlarge,
				marginBottom: B.size.space.xlarge,
				"::before": {
					display: "block",
					content: '" "',
					backgroundColor: a,
					borderRadius: 4,
					width: 4,
					position: "absolute",
					left: 0,
					top: 0,
					bottom: 0,
					zIndex: 1,
				},
			})),
			(r[4] = a),
			(r[5] = l))
		: (l = r[5]);
	let u;
	return (
		r[6] !== o || r[7] !== n || r[8] !== l || r[9] !== s
			? ((u = m.jsx("div", { ...o, ref: n, className: l, children: s })),
				(r[6] = o),
				(r[7] = n),
				(r[8] = l),
				(r[9] = s),
				(r[10] = u))
			: (u = r[10]),
		u
	);
});
function oBe(t) {
	const e = ee(26),
		{ onShowEditMode: n, onRemove: r, isValid: i } = t,
		o = Le(Ht);
	let s;
	e[0] === Symbol.for("react.memo_cache_sentinel")
		? ((s = { userSelect: "none" }), (e[0] = s))
		: (s = e[0]);
	let a;
	e[1] !== n ? ((a = () => n()), (e[1] = n), (e[2] = a)) : (a = e[2]);
	let l;
	e[3] !== o ? ((l = o.format("edit")), (e[3] = o), (e[4] = l)) : (l = e[4]);
	let u;
	e[5] !== a || e[6] !== l
		? ((u = m.jsx(Re, { onPress: a, children: l })),
			(e[5] = a),
			(e[6] = l),
			(e[7] = u))
		: (u = e[7]);
	let c;
	e[8] === Symbol.for("react.memo_cache_sentinel")
		? ((c = m.jsx(ve, { src: Wr })), (e[8] = c))
		: (c = e[8]);
	let d;
	e[9] !== r
		? ((d = m.jsx(Re, { prominence: "low", onPress: r, children: c })),
			(e[9] = r),
			(e[10] = d))
		: (d = e[10]);
	let f;
	e[11] !== o
		? ((f = o.format("delete")), (e[11] = o), (e[12] = f))
		: (f = e[12]);
	let h;
	e[13] !== f
		? ((h = m.jsx(Xe, { tone: "critical", children: f })),
			(e[13] = f),
			(e[14] = h))
		: (h = e[14]);
	let p;
	e[15] !== d || e[16] !== h
		? ((p = m.jsxs(Ze, { children: [d, h] })),
			(e[15] = d),
			(e[16] = h),
			(e[17] = p))
		: (p = e[17]);
	let g;
	e[18] !== u || e[19] !== p
		? ((g = m.jsxs(ke, {
				alignItems: "center",
				gap: "regular",
				UNSAFE_style: s,
				children: [u, p],
			})),
			(e[18] = u),
			(e[19] = p),
			(e[20] = g))
		: (g = e[20]);
	let v;
	e[21] !== i
		? ((v =
				!i &&
				m.jsx(Gh, {
					children: "Contains invalid fields. Please edit.",
				})),
			(e[21] = i),
			(e[22] = v))
		: (v = e[22]);
	let b;
	return (
		e[23] !== g || e[24] !== v
			? ((b = m.jsx(C5, {
					children: m.jsxs(ke, {
						direction: "column",
						gap: "medium",
						children: [g, v],
					}),
				})),
				(e[23] = g),
				(e[24] = v),
				(e[25] = b))
			: (b = e[25]),
		b
	);
}
function sBe({ onClose: t, props: e }) {
	const n = Le(Ht),
		r = E.useId(),
		[i, o] = E.useState(!1),
		[s, a] = E.useState(() => ch(e)),
		l = E.useMemo(() => Ba(e.schema, a, () => {}), [e.schema])(s);
	return m.jsxs(m.Fragment, {
		children: [
			m.jsx(Pr, {
				children: m.jsx(ke, {
					id: r,
					elementType: "form",
					onSubmit: (u) => {
						u.target === u.currentTarget &&
							(u.preventDefault(),
							_s(e.schema, s, void 0)
								? (console.log(Pu(s, e.schema)), jd(s, e), t())
								: o(!0));
					},
					direction: "column",
					gap: "xxlarge",
					children: m.jsx(Ia, { ...l, forceValidation: i }),
				}),
			}),
			m.jsxs(Nr, {
				children: [
					m.jsx(vt, { onPress: t, children: n.format("cancel") }),
					m.jsx(vt, {
						form: r,
						prominence: "high",
						type: "submit",
						children: "Done",
					}),
				],
			}),
		],
	});
}
function aBe(t) {
	var e;
	const n = ee(7),
		r = t.componentBlock.toolbar !== null,
		i = (e = t.componentBlock.toolbar) !== null && e !== void 0 ? e : lBe;
	let o;
	n[0] !== r || n[1] !== t || n[2] !== i
		? ((o = r
				? m.jsxs(ef, {
						element: t.element,
						children: [
							m.jsx("div", { children: t.renderedBlock }),
							m.jsx(tf, {
								children: m.jsx(i, {
									onRemove: t.onRemove,
									props: t.previewProps,
								}),
							}),
						],
					})
				: m.jsx("div", { children: t.renderedBlock })),
			(n[0] = r),
			(n[1] = t),
			(n[2] = i),
			(n[3] = o))
		: (o = n[3]);
	let s;
	return (
		n[4] !== t.attributes || n[5] !== o
			? ((s = m.jsx("div", {
					...t.attributes,
					className: E3,
					children: o,
				})),
				(n[4] = t.attributes),
				(n[5] = o),
				(n[6] = s))
			: (s = n[6]),
		s
	);
}
function lBe(t) {
	const e = ee(6),
		{ onRemove: n } = t;
	let r;
	e[0] === Symbol.for("react.memo_cache_sentinel")
		? ((r = m.jsx(ve, { src: m4e })), (e[0] = r))
		: (r = e[0]);
	let i;
	e[1] !== n
		? ((i = m.jsx(Re, { onPress: n, margin: "regular", children: r })),
			(e[1] = n),
			(e[2] = i))
		: (i = e[2]);
	let o;
	e[3] === Symbol.for("react.memo_cache_sentinel")
		? ((o = m.jsx(Xe, { tone: "critical", children: "Remove" })),
			(e[3] = o))
		: (o = e[3]);
	let s;
	return (
		e[4] !== i
			? ((s = m.jsxs(Ze, { children: [i, o] })), (e[4] = i), (e[5] = s))
			: (s = e[5]),
		s
	);
}
function Vb(t, e, n) {
	switch (e.kind) {
		case "form":
			return [];
		case "child":
			return [{ path: n, options: e.options }];
		case "conditional":
			return Vb(t.value, e.values[t.discriminant], n.concat("value"));
		case "object": {
			const r = [];
			return (
				Object.keys(e.fields).forEach((i) => {
					r.push(...Vb(t[i], e.fields[i], n.concat(i)));
				}),
				r
			);
		}
		case "array": {
			const r = [];
			return (
				t.forEach((i, o) => {
					r.push(...Vb(i, e.element, n.concat(o)));
				}),
				r
			);
		}
	}
}
function xE(t, e) {
	const n = Vb(t, { kind: "object", fields: e }, []);
	return n.length
		? n
		: [{ path: void 0, options: { kind: "inline", placeholder: "" } }];
}
function RF(t) {
	if (t.selection) {
		const e = R.above(t, { match: (n) => Lt(n) && n.type !== "paragraph" });
		if (
			e &&
			(e[0].type === "component-block-prop" ||
				e[0].type === "component-inline-prop")
		)
			return { isInside: !0, componentBlock: R.parent(t, e[1]), prop: e };
	}
	return { isInside: !1 };
}
const OF = new WeakMap();
function wJ([t, e], n, r) {
	let i = OF.get(r);
	if ((i || ((i = new WeakSet()), OF.set(r, i)), i.has(t))) return !1;
	let o = !1;
	if (
		(r.inlineMarks !== "inherit" &&
			Be.isText(t) &&
			(o = AH([t, e], n, r.inlineMarks, r.softBreaks)),
		$e.isElement(t))
	) {
		let s = t.children
			.map((a, l) => wJ([a, [...e, l]], n, r))
			.some((a) => a);
		r.kind === "block"
			? t.type === "component-block"
				? r.componentBlocks || (W.unwrapNodes(n, { at: e }), (o = !0))
				: (o = TH([t, e], n, r.documentFeatures) || s)
			: (o = $H([t, e], n, r.documentFeatures.links));
	}
	return o === !1 && i.add(t), o;
}
function uBe(t) {
	const e = new Set([t]);
	for (const n of e)
		if (n.kind !== "form") {
			if (n.kind === "child") return !0;
			if (n.kind === "array") e.add(n.element);
			else if (n.kind === "object")
				for (const r of Object.values(n.fields)) e.add(r);
			else if (n.kind === "conditional")
				for (const r of Object.values(n.values)) e.add(r);
			else qn(n);
		}
	return !1;
}
function EJ(t) {
	const e = new Set([t]);
	let n = !1;
	for (const r of e)
		if (r.kind !== "form")
			if (r.kind === "child") {
				if (n) return !1;
				n = !0;
			} else if (r.kind === "array") {
				if (uBe(r.element)) return !1;
			} else if (r.kind === "object")
				for (const i of Object.values(r.fields)) e.add(i);
			else if (r.kind === "conditional")
				for (const i of Object.values(r.values)) e.add(i);
			else qn(r);
	return n;
}
function cBe(t, e) {
	const n = [];
	return (
		_b(t, e, (r, i, o) => {
			r.kind === "array" && EJ(r.element) && n.push([o, r]);
		}),
		n
	);
}
function dBe(t) {
	const e = t.children[0];
	return (
		t.children.length === 1 &&
		((t.type === "component-inline-prop" &&
			e.type === void 0 &&
			e.text === "") ||
			(t.type === "component-block-prop" &&
				e.type === "paragraph" &&
				e.children.length === 1 &&
				e.children[0].type === void 0 &&
				e.children[0].text === ""))
	);
}
function fBe(t, e, n) {
	const r = ZK((a) => yH(e, a)),
		{ normalizeNode: i, deleteBackward: o, insertBreak: s } = n;
	return (
		(n.deleteBackward = (a) => {
			if (n.selection) {
				const l = RF(n);
				if (
					l.isInside &&
					ie.isCollapsed(n.selection) &&
					R.isStart(n, n.selection.anchor, l.prop[1]) &&
					l.prop[1][l.prop[1].length - 1] === 0
				) {
					W.unwrapNodes(n, { at: l.componentBlock[1] });
					return;
				}
			}
			o(a);
		}),
		(n.insertBreak = () => {
			const a = RF(n);
			if (n.selection && a.isInside) {
				const {
						prop: [l, u],
						componentBlock: [c, d],
					} = a,
					f = u[u.length - 1] === c.children.length - 1;
				if (l.type === "component-block-prop") {
					const [[h, p]] = R.nodes(n, {
							match: (v) => v.type === "paragraph",
						}),
						g = p[p.length - 1] === l.children.length - 1;
					if (pe.string(h) === "" && g) {
						f
							? W.moveNodes(n, {
									at: p,
									to: Y.next(a.componentBlock[1]),
								})
							: (W.move(n, { distance: 1, unit: "line" }),
								W.removeNodes(n, { at: p }));
						return;
					}
				}
				if (l.type === "component-inline-prop") {
					R.withoutNormalizing(n, () => {
						const h = t[c.component];
						if (l.propPath !== void 0 && h !== void 0) {
							const g = { kind: "object", fields: h.schema },
								v = oxe(g, l.propPath, c.props),
								b = [...v]
									.reverse()
									.findIndex((y) => y.kind === "array");
							if (b !== -1) {
								const y = v.length - 1 - b,
									x = v[y];
								wt(x.kind === "array");
								const C = jg(c.props, l.propPath.slice(0, y));
								if (EJ(x.element)) {
									pe.string(l) === "" &&
									C.length - 1 === l.propPath[y]
										? (W.removeNodes(n, { at: u }),
											f
												? (W.insertNodes(
														n,
														{
															type: "paragraph",
															children: [
																{ text: "" },
															],
														},
														{ at: Y.next(d) },
													),
													W.select(n, Y.next(d)))
												: W.move(n, {
														distance: 1,
														unit: "line",
													}))
										: s();
									return;
								}
							}
						}
						W.splitNodes(n, { always: !0 });
						const p = Y.next(u);
						f
							? W.moveNodes(n, { at: p, to: Y.next(d) })
							: (Dg(n, p, [...Y.next(p), 0]),
								W.removeNodes(n, { at: p }));
					});
					return;
				}
			}
			s();
		}),
		(n.normalizeNode = (a) => {
			const [l, u] = a;
			if (
				l.type === "component-inline-prop" &&
				!l.propPath &&
				(l.children.length !== 1 ||
					!Be.isText(l.children[0]) ||
					l.children[0].text !== "")
			) {
				W.removeNodes(n, { at: u });
				return;
			}
			if (l.type === "component-block") {
				const c = t[l.component];
				if (c) {
					const d = { kind: "object", fields: c.schema },
						f = Kb(l.props, d);
					if (f !== l.props) {
						W.setNodes(n, { props: f }, { at: u });
						return;
					}
					for (const [v, b] of cBe(d, l.props)) {
						if (
							l.children.length === 1 &&
							l.children[0].type === "component-inline-prop" &&
							l.children[0].propPath === void 0
						)
							break;
						const y = [];
						for (const [A, T] of l.children.entries())
							if (
								(T.type === "component-block-prop" ||
									T.type === "component-inline-prop") &&
								T.propPath !== void 0
							) {
								const I = T.propPath.concat();
								for (
									;
									I.length && typeof I.pop() != "number";

								);
								Bd(v, I) && y.push([A, T]);
							}
						const x = jg(l.props, v),
							C = Kr(x),
							k = new Set(C),
							w = new Set(),
							D = [],
							S = [],
							$ = () => {
								let A = Md();
								for (; k.has(A); ) A = Md();
								return A;
							};
						for (const [, A] of y) {
							const T = A.propPath[v.length];
							wt(typeof T == "number"),
								x.length <= T || (w.has(T) && dBe(A))
									? (D.push(an(b.element)), S.push($()))
									: (w.add(T),
										D.push(x[T]),
										S.push(w.has(T) ? $() : C[T]));
						}
						if ((sf(D, S), !Bd(x, D))) {
							const A = zb(d, l.props, D, v);
							W.setNodes(n, { props: A }, { at: u });
							for (const [T, [I, F]] of y.entries()) {
								const N = [...F.propPath];
								(N[v.length] = T),
									W.setNodes(
										n,
										{ propPath: N },
										{ at: [...u, I] },
									);
							}
							return;
						}
					}
					const h = new Map(
						xE(l.props, c.schema).map((v) => [
							JSON.stringify(v.path),
							v.options.kind,
						]),
					);
					if (
						(l.children.forEach((v) => {
							wt(
								v.type === "component-block-prop" ||
									v.type === "component-inline-prop",
							),
								h.delete(JSON.stringify(v.propPath));
						}),
						h.size)
					) {
						W.insertNodes(
							n,
							[...h].map(([v, b]) => ({
								type: `component-${b}-prop`,
								propPath: v && JSON.parse(v),
								children: [{ text: "" }],
							})),
							{ at: [...u, l.children.length] },
						);
						return;
					}
					const p = new Set(),
						g = {};
					xE(l.props, t[l.component].schema).forEach((v, b) => {
						g[JSON.stringify(v.path)] = {
							options: v.options,
							index: b,
						};
					});
					for (const [v, b] of l.children.entries()) {
						if (
							b.type !== "component-inline-prop" &&
							b.type !== "component-block-prop"
						)
							continue;
						const y = [...u, v],
							x = JSON.stringify(b.propPath);
						if (g[x] === void 0) {
							W.removeNodes(n, { at: y });
							return;
						}
						if (p.has(x)) {
							W.removeNodes(n, { at: y });
							return;
						}
						p.add(x);
						const C = g[x],
							k = C.index;
						if (v !== k) {
							W.moveNodes(n, { at: y, to: [...u, k] });
							return;
						}
						const w = `component-${C.options.kind}-prop`;
						if (b.type !== w) {
							W.setNodes(n, { type: w }, { at: y });
							return;
						}
						const D = r(C.options);
						if (wJ([b, y], n, D)) return;
					}
				}
			}
			i(a);
		}),
		n
	);
}
function Kb(t, e) {
	if (e.kind === "child" || e.kind === "form") return t;
	if (e.kind === "conditional") {
		const n = t,
			r = Kb(n.value, e.values[n.discriminant.toString()]);
		return r === n.value ? t : { discriminant: n.discriminant, value: r };
	}
	if (e.kind === "array") {
		const n = t,
			r = n.map((i) => Kb(i, e.element));
		return Bd(n, r) ? t : r;
	}
	if (e.kind === "object") {
		const n = t;
		let r = !1;
		const i = {};
		for (const [o, s] of Object.entries(e.fields)) {
			const a = n[o];
			if (a === void 0) {
				(r = !0), (i[o] = an(s));
				continue;
			}
			const l = Kb(a, s);
			l !== a && (r = !0), (i[o] = l);
		}
		return r ? i : t;
	}
	qn(e);
}
function hBe(t) {
	const e = ee(3);
	let n;
	return (
		e[0] !== t.attributes || e[1] !== t.children
			? ((n = m.jsx("span", { ...t.attributes, children: t.children })),
				(e[0] = t.attributes),
				(e[1] = t.children),
				(e[2] = n))
			: (n = e[2]),
		n
	);
}
function pBe(t, e) {
	const n = an({ kind: "object", fields: e.schema });
	return {
		type: "component-block",
		component: t,
		props: n,
		children: xE(n, e.schema).map((r) => ({
			type: `component-${r.options.kind}-prop`,
			propPath: r.path,
			children: [
				r.options.kind === "block"
					? { type: "paragraph", children: [{ text: "" }] }
					: { text: "" },
			],
		})),
	};
}
function fA(t, e, n) {
	const r = pBe(n, e[n]);
	To(t, r);
	const i = R.above(t, { match: (o) => o.type === "component-block" });
	if (i) {
		const o = R.start(t, i[1]);
		W.setSelection(t, { anchor: o, focus: o });
	}
}
const mBe = (t) => {
	const e = ee(52),
		{ attributes: n, children: r, element: i } = t,
		o = wn(),
		[s, a] = v5(o, i),
		u = Ls().componentBlocks[s.component];
	let c;
	e: {
		if (!u) {
			c = void 0;
			break e;
		}
		let T;
		if (e[0] !== s.children || e[1] !== s.props || e[2] !== u.schema) {
			const I = new Map();
			for (const F of s.children)
				F.type === "component-block-prop" &&
					F.propPath &&
					I.set(JSON.stringify(F.propPath), F.children);
			if (!I.size) {
				c = s.props;
				break e;
			}
			(T = Eu({ kind: "object", fields: u.schema }, s.props, {
				child(F, N, O) {
					if (F.options.kind === "block") {
						const _ = JSON.stringify(O),
							j = I.get(_);
						if (j) return j.map(x5);
					}
					return N;
				},
			})),
				(e[0] = s.children),
				(e[1] = s.props),
				(e[2] = u.schema),
				(e[3] = T),
				(e[4] = c);
		} else (T = e[3]), (c = e[4]);
		c = T;
	}
	const d = c;
	let f;
	e[5] !== i || e[6] !== s || e[7] !== d
		? ((f = {
				__elementToGetPath: i,
				currentElement: s,
				propsWithChildFields: d,
			}),
			(e[5] = i),
			(e[6] = s),
			(e[7] = d),
			(e[8] = f))
		: (f = e[8]);
	const h = E.useRef(f);
	let p;
	e[9] !== i || e[10] !== s || e[11] !== d
		? ((p = () => {
				h.current = {
					__elementToGetPath: i,
					currentElement: s,
					propsWithChildFields: d,
				};
			}),
			(e[9] = i),
			(e[10] = s),
			(e[11] = d),
			(e[12] = p))
		: (p = e[12]),
		E.useEffect(p);
	let g;
	e[13] !== o || e[14] !== i
		? ((g = () => {
				const T = te.findPath(o, i);
				W.removeNodes(o, { at: T });
			}),
			(e[13] = o),
			(e[14] = i),
			(e[15] = g))
		: (g = e[15]);
	const v = Ri(g);
	let b;
	e[16] !== o || e[17] !== u || e[18] !== a
		? ((b = (T, I) => {
				const F = h.current.propsWithChildFields;
				QTe(
					o,
					u,
					F,
					T(F),
					te.findPath(o, h.current.__elementToGetPath),
					a,
					I,
				);
			}),
			(e[16] = o),
			(e[17] = u),
			(e[18] = a),
			(e[19] = b))
		: (b = e[19]);
	const y = b;
	let x;
	e: {
		if (!u) {
			let I;
			e[20] === Symbol.for("react.memo_cache_sentinel")
				? ((I = () => {
						throw new Error(
							"expected component block to exist when called",
						);
					}),
					(e[20] = I))
				: (I = e[20]),
				(x = I);
			break e;
		}
		let T;
		if (e[21] !== u.schema || e[22] !== y) {
			let I;
			e[24] !== y
				? ((I = (N) => y(N, !1)), (e[24] = y), (e[25] = I))
				: (I = e[25]);
			let F;
			e[26] === Symbol.for("react.memo_cache_sentinel")
				? ((F = () => {}), (e[26] = F))
				: (F = e[26]),
				(T = Ba({ kind: "object", fields: u.schema }, I, F)),
				(e[21] = u.schema),
				(e[22] = y),
				(e[23] = T);
		} else T = e[23];
		x = T;
	}
	const C = x;
	if (!u) {
		let T;
		e[27] === Symbol.for("react.memo_cache_sentinel")
			? ((T = { border: "red 4px solid", padding: 8 }), (e[27] = T))
			: (T = e[27]);
		let I;
		e[28] === Symbol.for("react.memo_cache_sentinel")
			? ((I = { userSelect: "none" }), (e[28] = I))
			: (I = e[28]);
		const F = `The block "${s.component}" no longer exists.

Props:

${JSON.stringify(s.props, null, 2)}

Content:`;
		let N;
		e[29] !== F
			? ((N = m.jsx("pre", {
					contentEditable: !1,
					style: I,
					children: F,
				})),
				(e[29] = F),
				(e[30] = N))
			: (N = e[30]);
		let O;
		return (
			e[31] !== N || e[32] !== r
				? ((O = m.jsxs("div", { style: T, children: [N, r] })),
					(e[31] = N),
					(e[32] = r),
					(e[33] = O))
				: (O = e[33]),
			O
		);
	}
	const k = d;
	let w;
	e[34] !== C || e[35] !== k
		? ((w = C(k)), (e[34] = C), (e[35] = k), (e[36] = w))
		: (w = e[36]);
	const D = w;
	let S;
	e[37] !== r || e[38] !== u || e[39] !== s || e[40] !== y || e[41] !== v
		? ((S = m.jsx(tBe, {
				children: r,
				componentBlock: u,
				element: s,
				onChange: y,
				onRemove: v,
			})),
			(e[37] = r),
			(e[38] = u),
			(e[39] = s),
			(e[40] = y),
			(e[41] = v),
			(e[42] = S))
		: (S = e[42]);
	const $ = S;
	let A;
	return (
		e[43] !== u ||
		e[44] !== i ||
		e[45] !== n ||
		e[46] !== $ ||
		e[47] !== v ||
		e[48] !== D ||
		e[49] !== r ||
		e[50] !== s
			? ((A = u.chromeless
					? m.jsx(aBe, {
							element: i,
							attributes: n,
							renderedBlock: $,
							componentBlock: u,
							onRemove: v,
							previewProps: D,
						})
					: m.jsx(rBe, {
							attributes: n,
							children: r,
							componentBlock: u,
							onRemove: v,
							previewProps: D,
							renderedBlock: $,
							elementProps: s.props,
						})),
				(e[43] = u),
				(e[44] = i),
				(e[45] = n),
				(e[46] = $),
				(e[47] = v),
				(e[48] = D),
				(e[49] = r),
				(e[50] = s),
				(e[51] = A))
			: (A = e[51]),
		A
	);
};
function DJ(t) {
	To(t, { type: "divider", children: [{ text: "" }] }),
		R.insertNode(t, { type: "paragraph", children: [{ text: "" }] });
}
const gBe = () => {
		const t = ee(6),
			{ editor: e, dividers: n } = zs(),
			{ isDisabled: r } = n;
		let i, o;
		t[0] !== e
			? ((o = () => {
					DJ(e);
				}),
				(t[0] = e),
				(t[1] = o))
			: (o = t[1]);
		let s;
		t[2] === Symbol.for("react.memo_cache_sentinel")
			? ((s = m.jsx(ve, { src: Ix })), (t[2] = s))
			: (s = t[2]);
		let a;
		return (
			t[3] !== r || t[4] !== o
				? ((a = m.jsx(Re, {
						prominence: "low",
						isDisabled: r,
						onPress: o,
						children: s,
					})),
					(t[3] = r),
					(t[4] = o),
					(t[5] = a))
				: (a = t[5]),
			(i = a),
			i
		);
	},
	bBe = m.jsxs(Ze, {
		delay: 200,
		children: [
			m.jsx(gBe, {}),
			m.jsxs(Xe, {
				children: [
					m.jsx(ue, { children: "Divider" }),
					m.jsx(fi, { children: "---" }),
				],
			}),
		],
	});
function vBe(t) {
	const e = ee(7),
		{ attributes: n, children: r } = t,
		i = $z();
	let o;
	e[0] === Symbol.for("react.memo_cache_sentinel")
		? ((o = { caretColor: "transparent" }), (e[0] = o))
		: (o = e[0]);
	const s = i ? B.color.alias.borderSelected : B.color.alias.borderIdle;
	let a;
	e[1] !== s
		? ((a = m.jsx("hr", { style: { backgroundColor: s } })),
			(e[1] = s),
			(e[2] = a))
		: (a = e[2]);
	let l;
	return (
		e[3] !== n || e[4] !== a || e[5] !== r
			? ((l = m.jsxs("div", { ...n, style: o, children: [a, r] })),
				(e[3] = n),
				(e[4] = a),
				(e[5] = r),
				(e[6] = l))
			: (l = e[6]),
		l
	);
}
const yBe = (t) => {
		const e = ee(75),
			{ attributes: n, children: r, element: i } = t,
			o = wn(),
			s = i.layout,
			a = Ls().documentFeatures.layouts;
		let l, u, c, d, f, h, p, g, v, b, y, x, C, k, w;
		if (
			e[0] !== s ||
			e[1] !== a ||
			e[2] !== n ||
			e[3] !== i ||
			e[4] !== r ||
			e[5] !== o
		) {
			let K;
			e[21] !== s
				? ((K = (q) => q.toString() === s.toString()),
					(e[21] = s),
					(e[22] = K))
				: (K = e[22]);
			const M = a.findIndex(K);
			(k = E3), (w = n), (y = ef), (x = i);
			let G;
			e[23] === Symbol.for("react.memo_cache_sentinel")
				? ((G = X({
						columnGap: B.size.space.regular,
						display: "grid",
					})),
					(e[23] = G))
				: (G = e[23]);
			let H;
			if (e[24] !== s) {
				let q;
				e[26] === Symbol.for("react.memo_cache_sentinel")
					? ((q = (J) => `${J}fr`), (e[26] = q))
					: (q = e[26]),
					(H = s.map(q).join(" ")),
					(e[24] = s),
					(e[25] = H);
			} else H = e[25];
			let P;
			e[27] !== H
				? ((P = { gridTemplateColumns: H }), (e[27] = H), (e[28] = P))
				: (P = e[28]),
				e[29] !== P || e[30] !== r
					? ((C = m.jsx("div", {
							className: G,
							style: P,
							children: r,
						})),
						(e[29] = P),
						(e[30] = r),
						(e[31] = C))
					: (C = e[31]),
				(b = tf),
				(p = ke),
				(g = "regular"),
				(v = "regular"),
				(l = nf),
				(u = "single"),
				(c = "low"),
				(d = "compact"),
				e[32] !== o || e[33] !== i || e[34] !== a
					? ((f = (q) => {
							const J = te.findPath(o, i),
								Z = a[q];
							W.setNodes(
								o,
								{ type: "layout", layout: Z },
								{ at: J },
							),
								te.focus(o);
						}),
						(e[32] = o),
						(e[33] = i),
						(e[34] = a),
						(e[35] = f))
					: (f = e[35]),
				(h = M !== -1 ? [M.toString()] : []),
				(e[0] = s),
				(e[1] = a),
				(e[2] = n),
				(e[3] = i),
				(e[4] = r),
				(e[5] = o),
				(e[6] = l),
				(e[7] = u),
				(e[8] = c),
				(e[9] = d),
				(e[10] = f),
				(e[11] = h),
				(e[12] = p),
				(e[13] = g),
				(e[14] = v),
				(e[15] = b),
				(e[16] = y),
				(e[17] = x),
				(e[18] = C),
				(e[19] = k),
				(e[20] = w);
		} else
			(l = e[6]),
				(u = e[7]),
				(c = e[8]),
				(d = e[9]),
				(f = e[10]),
				(h = e[11]),
				(p = e[12]),
				(g = e[13]),
				(v = e[14]),
				(b = e[15]),
				(y = e[16]),
				(x = e[17]),
				(C = e[18]),
				(k = e[19]),
				(w = e[20]);
		let D;
		if (e[36] !== a) {
			let K;
			e[38] === Symbol.for("react.memo_cache_sentinel")
				? ((K = (M, G) => m.jsx(Mt, { children: kBe(M) }, G)),
					(e[38] = K))
				: (K = e[38]),
				(D = a.map(K)),
				(e[36] = a),
				(e[37] = D);
		} else D = e[37];
		let S;
		e[39] !== l ||
		e[40] !== u ||
		e[41] !== c ||
		e[42] !== d ||
		e[43] !== f ||
		e[44] !== h ||
		e[45] !== D
			? ((S = m.jsx(l, {
					selectionMode: u,
					prominence: c,
					density: d,
					onAction: f,
					selectedKeys: h,
					children: D,
				})),
				(e[39] = l),
				(e[40] = u),
				(e[41] = c),
				(e[42] = d),
				(e[43] = f),
				(e[44] = h),
				(e[45] = D),
				(e[46] = S))
			: (S = e[46]);
		let $;
		e[47] === Symbol.for("react.memo_cache_sentinel")
			? (($ = m.jsx(H3, {})), (e[47] = $))
			: ($ = e[47]);
		let A;
		e[48] !== o || e[49] !== i
			? ((A = () => {
					const K = te.findPath(o, i);
					W.removeNodes(o, { at: K });
				}),
				(e[48] = o),
				(e[49] = i),
				(e[50] = A))
			: (A = e[50]);
		let T;
		e[51] === Symbol.for("react.memo_cache_sentinel")
			? ((T = m.jsx(ve, { src: Wr })), (e[51] = T))
			: (T = e[51]);
		let I;
		e[52] !== A
			? ((I = m.jsx(Re, { prominence: "low", onPress: A, children: T })),
				(e[52] = A),
				(e[53] = I))
			: (I = e[53]);
		let F;
		e[54] === Symbol.for("react.memo_cache_sentinel")
			? ((F = m.jsx(Xe, { tone: "critical", children: "Remove" })),
				(e[54] = F))
			: (F = e[54]);
		let N;
		e[55] !== I
			? ((N = m.jsxs(Ze, { children: [I, F] })), (e[55] = I), (e[56] = N))
			: (N = e[56]);
		let O;
		e[57] !== p || e[58] !== g || e[59] !== v || e[60] !== S || e[61] !== N
			? ((O = m.jsxs(p, { padding: g, gap: v, children: [S, $, N] })),
				(e[57] = p),
				(e[58] = g),
				(e[59] = v),
				(e[60] = S),
				(e[61] = N),
				(e[62] = O))
			: (O = e[62]);
		let _;
		e[63] !== b || e[64] !== O
			? ((_ = m.jsx(b, { children: O })),
				(e[63] = b),
				(e[64] = O),
				(e[65] = _))
			: (_ = e[65]);
		let j;
		e[66] !== y || e[67] !== x || e[68] !== C || e[69] !== _
			? ((j = m.jsxs(y, { element: x, children: [C, _] })),
				(e[66] = y),
				(e[67] = x),
				(e[68] = C),
				(e[69] = _),
				(e[70] = j))
			: (j = e[70]);
		let V;
		return (
			e[71] !== k || e[72] !== w || e[73] !== j
				? ((V = m.jsx("div", { className: k, ...w, children: j })),
					(e[71] = k),
					(e[72] = w),
					(e[73] = j),
					(e[74] = V))
				: (V = e[74]),
			V
		);
	},
	xBe = (t) => {
		const e = ee(4),
			{ attributes: n, children: r } = t;
		let i;
		e[0] === Symbol.for("react.memo_cache_sentinel")
			? ((i = X({
					borderColor: B.color.border.neutral,
					borderRadius: B.size.radius.regular,
					borderStyle: "dashed",
					borderWidth: B.size.border.regular,
					padding: B.size.space.medium,
				})),
				(e[0] = i))
			: (i = e[0]);
		let o;
		return (
			e[1] !== n || e[2] !== r
				? ((o = m.jsx("div", { className: i, ...n, children: r })),
					(e[1] = n),
					(e[2] = r),
					(e[3] = o))
				: (o = e[3]),
			o
		);
	},
	SJ = (t, e) => {
		To(t, [
			{
				type: "layout",
				layout: e,
				children: [
					{
						type: "layout-area",
						children: [
							{ type: "paragraph", children: [{ text: "" }] },
						],
					},
				],
			},
		]);
		const n = R.above(t, { match: (r) => r.type === "layout" });
		n && W.select(t, [...n[1], 0]);
	};
function kBe(t) {
	return m.jsx("div", {
		role: "img",
		className: X({
			display: "grid",
			gridTemplateColumns: t.map((r) => `${r}fr`).join(" "),
			gap: 2,
			width: 16,
			height: 16,
		}),
		children: t.map((r, i) =>
			m.jsx(
				"div",
				{
					className: X({
						backgroundColor: "currentcolor",
						borderRadius: 1,
					}),
				},
				i,
			),
		),
	});
}
const CBe = m.jsx(ve, { src: g4e }),
	wBe = (t) => {
		const e = ee(9),
			{ layouts: n } = t,
			{ editor: r, layouts: i } = zs(),
			{ isSelected: o } = i;
		let s, a;
		e[0] !== r || e[1] !== n
			? ((a = () => {
					Xs(r, "layout")
						? W.unwrapNodes(r, {
								match: (d) => d.type === "layout",
							})
						: SJ(r, n[0]),
						te.focus(r);
				}),
				(e[0] = r),
				(e[1] = n),
				(e[2] = a))
			: (a = e[2]);
		let l;
		e[3] !== o || e[4] !== a
			? ((l = m.jsx(Re, {
					prominence: "low",
					isSelected: o,
					onPress: a,
					children: CBe,
				})),
				(e[3] = o),
				(e[4] = a),
				(e[5] = l))
			: (l = e[5]);
		let u;
		e[6] === Symbol.for("react.memo_cache_sentinel")
			? ((u = m.jsx(Xe, { children: "Layouts" })), (e[6] = u))
			: (u = e[6]);
		let c;
		return (
			e[7] !== l
				? ((c = m.jsxs(Ze, { children: [l, u] })),
					(e[7] = l),
					(e[8] = c))
				: (c = e[8]),
			(s = c),
			s
		);
	},
	EBe = (t, e) => {
		const n = gJ(t),
			r = Xs(t, e) && (n === "none" || n === e);
		R.withoutNormalizing(t, () => {
			W.unwrapNodes(t, {
				match: el,
				split: !0,
				mode: r ? "all" : "lowest",
			}),
				r ||
					W.wrapNodes(
						t,
						{ type: e, children: [] },
						{
							match: (i) =>
								i.type !== "list-item-content" && Lt(i),
						},
					);
		});
	};
function DBe(t) {
	const e = ee(21),
		{ editor: n, lists: r } = zs();
	let i, o;
	e[0] !== r.ordered.isDisabled || e[1] !== r.unordered.isDisabled
		? ((o = []),
			r.ordered.isDisabled && o.push("ordered"),
			r.unordered.isDisabled && o.push("unordered"),
			(e[0] = r.ordered.isDisabled),
			(e[1] = r.unordered.isDisabled),
			(e[2] = o))
		: (o = e[2]);
	let s;
	e[3] !== r.ordered.isSelected || e[4] !== r.unordered.isSelected
		? ((s = []),
			r.ordered.isSelected && s.push("ordered"),
			r.unordered.isSelected && s.push("unordered"),
			(e[3] = r.ordered.isSelected),
			(e[4] = r.unordered.isSelected),
			(e[5] = s))
		: (s = e[5]);
	let a;
	e[6] === Symbol.for("react.memo_cache_sentinel")
		? ((a = m.jsx(ve, { src: jv })), (e[6] = a))
		: (a = e[6]);
	let l;
	e[7] !== n
		? ((l = (h) => {
				const p = `${h}-list`;
				EBe(n, p), te.focus(n);
			}),
			(e[7] = n),
			(e[8] = l))
		: (l = e[8]);
	let u;
	e[9] !== t.lists.unordered
		? ((u =
				t.lists.unordered &&
				m.jsxs(
					Mt,
					{
						textValue: "Bullet List (- )",
						children: [
							m.jsx(ve, { src: jv }),
							m.jsx(ue, { children: "Bullet List" }),
							m.jsx(fi, { children: "-⎵" }),
						],
					},
					"unordered",
				)),
			(e[9] = t.lists.unordered),
			(e[10] = u))
		: (u = e[10]);
	let c;
	e[11] !== t.lists.ordered
		? ((c =
				t.lists.ordered &&
				m.jsxs(
					Mt,
					{
						textValue: "Numbered List (1.)",
						children: [
							m.jsx(ve, { src: YD }),
							m.jsx(ue, { children: "Numbered List" }),
							m.jsx(fi, { children: "1.⎵" }),
						],
					},
					"ordered",
				)),
			(e[11] = t.lists.ordered),
			(e[12] = c))
		: (c = e[12]);
	let d;
	e[13] !== u || e[14] !== c
		? ((d = [u, c].filter((h) => h !== !1)),
			(e[13] = u),
			(e[14] = c),
			(e[15] = d))
		: (d = e[15]);
	let f;
	return (
		e[16] !== s || e[17] !== o || e[18] !== l || e[19] !== d
			? ((f = m.jsx(nf, {
					flexShrink: 0,
					"aria-label": "Lists",
					selectionMode: "single",
					buttonLabelBehavior: "hide",
					density: "compact",
					prominence: "low",
					summaryIcon: a,
					selectedKeys: s,
					disabledKeys: o,
					onAction: l,
					children: d,
				})),
				(e[16] = s),
				(e[17] = o),
				(e[18] = l),
				(e[19] = d),
				(e[20] = f))
			: (f = e[20]),
		(i = f),
		i
	);
}
function SBe(t) {
	const e = R.above(t, { match: Lt });
	if (!e || e[0].type !== "list-item-content") return !1;
	const n = Y.parent(e[1]);
	if (n[n.length - 1] === 0) return !1;
	const r = Y.previous(n),
		i = pe.get(t, r);
	if (i.children.length !== 1)
		return (
			W.moveNodes(t, {
				at: n,
				to: [
					...r,
					i.children.length - 1,
					i.children[i.children.length - 1].children.length,
				],
			}),
			!0
		);
	const o = R.parent(t, Y.parent(e[1]))[0].type;
	return (
		R.withoutNormalizing(t, () => {
			W.wrapNodes(t, { type: o, children: [] }, { at: n }),
				W.moveNodes(t, { to: [...r, i.children.length], at: n });
		}),
		!0
	);
}
function ABe(t) {
	const e = R.above(t, { match: Lt });
	return e && e[0].type === "list-item-content"
		? (W.unwrapNodes(t, { match: el, split: !0 }), !0)
		: !1;
}
function q3(t) {
	return new Promise((e) => {
		const n = document.createElement("input");
		(n.type = "file"),
			(n.style.display = "none"),
			(n.accept = t),
			(n.onchange = () => {
				var r;
				const i =
					(r = n.files) === null || r === void 0 ? void 0 : r[0];
				i && e(i);
			}),
			document.body.appendChild(n),
			n.click();
	});
}
async function AJ(t) {
	const e = await q3(t);
	if (e)
		return {
			content: new Uint8Array(await e.arrayBuffer()),
			filename: e.name,
		};
}
function G3() {
	return AJ("image/*");
}
function hA(t, e) {
	const n = ee(4),
		[r, i] = E.useState(null);
	let o, s;
	return (
		n[0] !== t || n[1] !== e
			? ((o = () => {
					if (t) {
						const a = URL.createObjectURL(
							new Blob([t], { type: e }),
						);
						return i(a), () => URL.revokeObjectURL(a);
					} else i(null);
				}),
				(s = [e, t]),
				(n[0] = t),
				(n[1] = e),
				(n[2] = o),
				(n[3] = s))
			: ((o = n[2]), (s = n[3])),
		E.useEffect(o, s),
		r
	);
}
function $Be(t) {
	var e;
	const n = ee(36),
		{ value: r } = t;
	let i;
	n[0] === Symbol.for("react.memo_cache_sentinel")
		? ((i = () => !0), (n[0] = i))
		: (i = n[0]);
	const [o, s] = E.useReducer(i, !1),
		a = zJ(),
		l = hA(
			r === null ? null : r.data,
			(r == null ? void 0 : r.extension) === "svg"
				? "image/svg+xml"
				: void 0,
		),
		u = E.useId(),
		c = E.useId(),
		d = t.description ? c : void 0,
		f = (e = t.validation) === null || e === void 0 ? void 0 : e.isRequired;
	let h;
	n[1] !== u || n[2] !== f || n[3] !== t.label
		? ((h = m.jsx(qh, {
				id: u,
				elementType: "span",
				isRequired: f,
				children: t.label,
			})),
			(n[1] = u),
			(n[2] = f),
			(n[3] = t.label),
			(n[4] = h))
		: (h = n[4]);
	let p;
	n[5] !== t.description || n[6] !== c
		? ((p =
				t.description &&
				m.jsx(ue, {
					size: "small",
					color: "neutralSecondary",
					id: c,
					children: t.description,
				})),
			(n[5] = t.description),
			(n[6] = c),
			(n[7] = p))
		: (p = n[7]);
	let g;
	n[8] !== t
		? ((g = m.jsx(Re, {
				onPress: async () => {
					const D = await G3();
					if (D) {
						var S;
						const $ =
							(S = D.filename.match(/\.([^.]+$)/)) === null ||
							S === void 0
								? void 0
								: S[1];
						$ &&
							t.onChange({
								data: D.content,
								extension: $,
								filename: t.transformFilename
									? t.transformFilename(D.filename)
									: D.filename,
							});
					}
				},
				children: "Choose file",
			})),
			(n[8] = t),
			(n[9] = g))
		: (g = n[9]);
	let v;
	n[10] !== r || n[11] !== t || n[12] !== s
		? ((v =
				r !== null &&
				m.jsx(Re, {
					prominence: "low",
					onPress: () => {
						t.onChange(null), s();
					},
					children: "Remove",
				})),
			(n[10] = r),
			(n[11] = t),
			(n[12] = s),
			(n[13] = v))
		: (v = n[13]);
	let b;
	n[14] !== g || n[15] !== v
		? ((b = m.jsxs(Nr, { children: [g, v] })),
			(n[14] = g),
			(n[15] = v),
			(n[16] = b))
		: (b = n[16]);
	let y;
	n[17] !== l
		? ((y =
				l &&
				m.jsx(pr, {
					alignSelf: "start",
					backgroundColor: "canvas",
					borderRadius: "regular",
					border: "neutral",
					padding: "regular",
					children: m.jsx("img", {
						src: l,
						alt: "",
						style: {
							display: "block",
							maxHeight: B.size.alias.singleLineWidth,
							maxWidth: "100%",
						},
					}),
				})),
			(n[17] = l),
			(n[18] = y))
		: (y = n[18]);
	let x;
	n[19] !== a || n[20] !== r || n[21] !== t
		? ((x =
				a &&
				r !== null &&
				m.jsx(An, {
					label: "Filename",
					onChange: (D) => {
						t.onChange({ ...r, filename: D });
					},
					value: r.filename,
				})),
			(n[19] = a),
			(n[20] = r),
			(n[21] = t),
			(n[22] = x))
		: (x = n[22]);
	let C;
	if (n[23] !== t || n[24] !== o || n[25] !== r) {
		var k;
		(C =
			(t.forceValidation || o) &&
			((k = t.validation) === null || k === void 0
				? void 0
				: k.isRequired) &&
			r === null &&
			m.jsxs(Gh, { children: [t.label, " is required"] })),
			(n[23] = t),
			(n[24] = o),
			(n[25] = r),
			(n[26] = C);
	} else C = n[26];
	let w;
	return (
		n[27] !== d ||
		n[28] !== u ||
		n[29] !== h ||
		n[30] !== p ||
		n[31] !== b ||
		n[32] !== y ||
		n[33] !== x ||
		n[34] !== C
			? ((w = m.jsxs(ke, {
					"aria-describedby": d,
					"aria-labelledby": u,
					direction: "column",
					gap: "medium",
					role: "group",
					children: [h, p, b, y, x, C],
				})),
				(n[27] = d),
				(n[28] = u),
				(n[29] = h),
				(n[30] = p),
				(n[31] = b),
				(n[32] = y),
				(n[33] = x),
				(n[34] = C),
				(n[35] = w))
			: (w = n[35]),
		w
	);
}
const TBe = (t) => {
	const e = ee(59),
		{ attributes: n, children: r, element: i } = t,
		[o, s] = E.useState(!1),
		[a, l] = E.useState(),
		u = Le(Ht),
		c = wn(),
		[d, f] = v5(c, i),
		h = hA(
			d.src.content,
			d.src.filename.endsWith(".svg") ? "image/svg+xml" : void 0,
		),
		g = k5() === i;
	let v;
	e[0] === Symbol.for("react.memo_cache_sentinel")
		? ((v = {
				alignItems: "center",
				display: "flex",
				flexDirection: "column",
			}),
			(e[0] = v))
		: (v = e[0]);
	let b;
	e[1] === Symbol.for("react.memo_cache_sentinel")
		? ((b = (oe) => {
				const ne = oe.target;
				l(ne.width / ne.height);
			}),
			(e[1] = b))
		: (b = e[1]);
	let y;
	e[2] === Symbol.for("react.memo_cache_sentinel")
		? ((y = X({
				boxSizing: "border-box",
				borderRadius: B.size.radius.regular,
				display: "block",
				maxHeight: B.size.scale[3600],
				maxWidth: "100%",
				transition: bt("box-shadow"),
				"&[data-selected=true]": {
					boxShadow: `0 0 0 ${B.size.border.regular} ${B.color.alias.borderSelected}`,
				},
			})),
			(e[2] = y))
		: (y = e[2]);
	let x;
	e[3] !== n || e[4] !== h || e[5] !== d.alt || e[6] !== g
		? ((x = m.jsx("div", {
				style: v,
				children: m.jsx(C5, {
					children: m.jsx("img", {
						...n,
						src: h,
						alt: d.alt,
						"data-selected": g,
						onLoad: b,
						className: y,
					}),
				}),
			})),
			(e[3] = n),
			(e[4] = h),
			(e[5] = d.alt),
			(e[6] = g),
			(e[7] = x))
		: (x = e[7]);
	let C;
	e[8] === Symbol.for("react.memo_cache_sentinel")
		? ((C = () => s(!0)), (e[8] = C))
		: (C = e[8]);
	let k;
	e[9] === Symbol.for("react.memo_cache_sentinel")
		? ((k = m.jsx(Re, {
				prominence: "low",
				onPress: C,
				children: m.jsx(ve, { src: V0 }),
			})),
			(e[9] = k))
		: (k = e[9]);
	let w;
	e[10] !== u
		? ((w = u.format("edit")), (e[10] = u), (e[11] = w))
		: (w = e[11]);
	let D;
	e[12] !== w
		? ((D = m.jsxs(Ze, { children: [k, m.jsx(Xe, { children: w })] })),
			(e[12] = w),
			(e[13] = D))
		: (D = e[13]);
	let S;
	e[14] !== f
		? ((S = async () => {
				const oe = await G3();
				oe && f({ src: oe });
			}),
			(e[14] = f),
			(e[15] = S))
		: (S = e[15]);
	let $;
	e[16] === Symbol.for("react.memo_cache_sentinel")
		? (($ = m.jsx(ve, { src: VW })), (e[16] = $))
		: ($ = e[16]);
	let A;
	e[17] !== S
		? ((A = m.jsx(Re, { prominence: "low", onPress: S, children: $ })),
			(e[17] = S),
			(e[18] = A))
		: (A = e[18]);
	let T;
	e[19] === Symbol.for("react.memo_cache_sentinel")
		? ((T = m.jsx(Xe, { children: "Choose file" })), (e[19] = T))
		: (T = e[19]);
	let I;
	e[20] !== A
		? ((I = m.jsxs(Ze, { children: [A, T] })), (e[20] = A), (e[21] = I))
		: (I = e[21]);
	let F;
	e[22] !== D || e[23] !== I
		? ((F = m.jsxs(ke, { gap: "small", children: [D, I] })),
			(e[22] = D),
			(e[23] = I),
			(e[24] = F))
		: (F = e[24]);
	let N;
	e[25] === Symbol.for("react.memo_cache_sentinel")
		? ((N = m.jsx(ra, { orientation: "vertical" })), (e[25] = N))
		: (N = e[25]);
	let O;
	e[26] !== c || e[27] !== i
		? ((O = () => {
				W.removeNodes(c, { at: te.findPath(c, i) });
			}),
			(e[26] = c),
			(e[27] = i),
			(e[28] = O))
		: (O = e[28]);
	let _;
	e[29] === Symbol.for("react.memo_cache_sentinel")
		? ((_ = m.jsx(ve, { src: Wr })), (e[29] = _))
		: (_ = e[29]);
	let j;
	e[30] !== O
		? ((j = m.jsx(Re, { prominence: "low", onPress: O, children: _ })),
			(e[30] = O),
			(e[31] = j))
		: (j = e[31]);
	let V;
	e[32] === Symbol.for("react.memo_cache_sentinel")
		? ((V = m.jsx(Xe, { tone: "critical", children: "Remove" })),
			(e[32] = V))
		: (V = e[32]);
	let K;
	e[33] !== j
		? ((K = m.jsxs(Ze, { children: [j, V] })), (e[33] = j), (e[34] = K))
		: (K = e[34]);
	let M;
	e[35] !== F || e[36] !== K
		? ((M = m.jsx(tf, {
				hideArrow: !0,
				children: m.jsxs(ke, {
					gap: "regular",
					padding: "regular",
					children: [F, N, K],
				}),
			})),
			(e[35] = F),
			(e[36] = K),
			(e[37] = M))
		: (M = e[37]);
	let G;
	e[38] !== i || e[39] !== a || e[40] !== x || e[41] !== M
		? ((G = m.jsxs(ef, { element: i, children: [x, M] }, a)),
			(e[38] = i),
			(e[39] = a),
			(e[40] = x),
			(e[41] = M),
			(e[42] = G))
		: (G = e[42]);
	let H;
	e[43] !== n || e[44] !== r || e[45] !== G
		? ((H = m.jsxs(aA, { attributes: n, children: [r, G] })),
			(e[43] = n),
			(e[44] = r),
			(e[45] = G),
			(e[46] = H))
		: (H = e[46]);
	let P;
	e[47] !== c
		? ((P = () => {
				s(!1), b5(c);
			}),
			(e[47] = c),
			(e[48] = P))
		: (P = e[48]);
	let q;
	e[49] !== o || e[50] !== f || e[51] !== d
		? ((q =
				o &&
				m.jsx(BBe, {
					alt: d.alt,
					title: d.title,
					filename: d.src.filename,
					onSubmit: (oe) => {
						const { alt: ne, filename: de, title: se } = oe;
						f({
							alt: ne,
							title: se,
							src: { content: d.src.content, filename: de },
						});
					},
				})),
			(e[49] = o),
			(e[50] = f),
			(e[51] = d),
			(e[52] = q))
		: (q = e[52]);
	let J;
	e[53] !== P || e[54] !== q
		? ((J = m.jsx(mn, { onDismiss: P, children: q })),
			(e[53] = P),
			(e[54] = q),
			(e[55] = J))
		: (J = e[55]);
	let Z;
	return (
		e[56] !== H || e[57] !== J
			? ((Z = m.jsxs(m.Fragment, { children: [H, J] })),
				(e[56] = H),
				(e[57] = J),
				(e[58] = Z))
			: (Z = e[58]),
		Z
	);
};
function BBe(t) {
	const { images: e } = Ls().documentFeatures;
	if (!e)
		throw new Error("unexpected image rendered when images are disabled");
	const n = E.useMemo(() => Ir(e.schema), [e]),
		[r, i] = E.useState({ alt: t.alt, title: t.title }),
		o = E.useMemo(() => Ba(n, i, () => {}), [n])(r),
		[s, a] = IBe(t.filename),
		[l, u] = E.useState(!1);
	let [c, d] = E.useState(s),
		[f, h] = E.useState(!1),
		{ dismiss: p } = Xd(),
		g = Le(Ht);
	return m.jsx(vr, {
		size: "small",
		children: m.jsxs("form", {
			style: { display: "contents" },
			onSubmit: (v) => {
				v.target === v.currentTarget &&
					(v.preventDefault(),
					u(!0),
					c &&
						_s(n, r, void 0) &&
						(p(),
						t.onSubmit({
							alt: r.alt,
							title: r.title,
							filename: [c, a].join("."),
						})));
			},
			children: [
				m.jsx(Ut, { children: "Image details" }),
				m.jsx(Pr, {
					children: m.jsxs(ke, {
						gap: "large",
						direction: "column",
						children: [
							m.jsx(An, {
								label: "File name",
								onChange: d,
								onBlur: () => h(!0),
								value: c,
								isRequired: !0,
								errorMessage:
									(f || l) && !c
										? "Please provide a file name."
										: void 0,
								endElement: a
									? m.jsx(ke, {
											alignItems: "center",
											justifyContent: "center",
											paddingEnd: "regular",
											children: m.jsxs(ue, {
												color: "neutralTertiary",
												children: [".", a],
											}),
										})
									: null,
							}),
							m.jsx(Ia, {
								forceValidation: l,
								autoFocus: !0,
								...o,
							}),
						],
					}),
				}),
				m.jsxs(Nr, {
					children: [
						m.jsx(vt, { onPress: p, children: g.format("cancel") }),
						m.jsx(vt, {
							prominence: "high",
							type: "submit",
							children: g.format("save"),
						}),
					],
				}),
			],
		}),
	});
}
function IBe(t) {
	const e = t.lastIndexOf(".");
	return e === -1 ? [t, ""] : [t.substring(0, e), t.substring(e + 1)];
}
let FBe = m.jsx(ve, { src: E0 });
function PBe() {
	const t = ee(4),
		e = wn();
	let n;
	t[0] !== e
		? ((n = async () => {
				const i = await G3();
				i &&
					W.insertNodes(e, {
						type: "image",
						src: i,
						alt: "",
						title: "",
						children: [{ text: "" }],
					});
			}),
			(t[0] = e),
			(t[1] = n))
		: (n = t[1]);
	let r;
	return (
		t[2] !== n
			? ((r = m.jsx(m.Fragment, {
					children: m.jsx(Re, {
						prominence: "low",
						onPress: n,
						children: FBe,
					}),
				})),
				(t[2] = n),
				(t[3] = r))
			: (r = t[3]),
		r
	);
}
const NBe = m.jsxs(Ze, {
	children: [
		m.jsx(PBe, {}),
		m.jsx(Xe, { children: m.jsx(ue, { children: "Image" }) }),
	],
});
function RBe(t) {
	const { insertData: e } = t;
	return (
		(t.insertData = (n) => {
			const r = Array.from(n.files).filter((i) =>
				i.type.startsWith("image/"),
			);
			if (r.length) {
				Promise.all(
					r.map(async (i) => ({
						name: i.name,
						data: new Uint8Array(await i.arrayBuffer()),
					})),
				).then((i) => {
					To(t, {
						type: "image",
						src: { content: i[0].data, filename: i[0].name },
						alt: "",
						title: "",
						children: [{ text: "" }],
					});
				});
				return;
			}
			e(n);
		}),
		t
	);
}
function MF(t, e) {
	return { start: Math.min(t, e), end: Math.max(t, e) };
}
function Pf(t, e) {
	return t ? (e === 0 ? [0, 0] : [1, e - 1]) : [0, e];
}
function Nm(t) {
	var e, n, r, i;
	const o =
			(e = R.above(t, {
				match: mr("table-cell"),
				at:
					(n = t.selection) === null || n === void 0
						? void 0
						: n.anchor.path,
			})) === null || e === void 0
				? void 0
				: e[1],
		s =
			(r = R.above(t, {
				match: mr("table-cell"),
				at:
					(i = t.selection) === null || i === void 0
						? void 0
						: i.focus.path,
			})) === null || r === void 0
				? void 0
				: r[1],
		a = R.above(t, { match: mr("table") });
	if (
		t.selection &&
		a &&
		$e.isElement(a[0].children[0]) &&
		o &&
		s &&
		Y.equals(o.slice(0, -3), s.slice(0, -3))
	) {
		const [l, u] = R.edges(t, t.selection);
		return {
			tablePath: a[1],
			table: a[0],
			singleCell: Y.equals(o, s)
				? ut.equals(R.start(t, o), l) &&
					ut.equals(R.end(t, o), u) &&
					!ut.equals(l, u)
					? "selected"
					: "not-selected"
				: "many",
			row: MF(
				o[o.length - 2] + o[o.length - 3],
				s[s.length - 2] + s[o.length - 3],
			),
			column: MF(o[o.length - 1], s[s.length - 1]),
		};
	}
}
const Xi = (t) => ({
	type: "table-cell",
	...(t ? { header: !0 } : {}),
	children: [{ type: "paragraph", children: [{ text: "" }] }],
});
function $J(t) {
	return Be.isText(t) ? { ...t } : { ...t, children: t.children.map($J) };
}
function OBe(t) {
	const {
		deleteFragment: e,
		normalizeNode: n,
		getFragment: r,
		insertFragment: i,
		deleteBackward: o,
	} = t;
	return (
		(t.insertFragment = (s) => {
			const a = Nm(t);
			if (!a || s.length !== 1 || s[0].type !== "table") {
				i(s);
				return;
			}
			const l = s[0].children.flatMap((g) =>
				g.type === "table-head" || g.type === "table-body"
					? g.children
					: [],
			);
			if (!l.every(mr("table-row"))) {
				i(s);
				return;
			}
			let { row: u, column: c, tablePath: d, table: f } = a;
			const h = a.table.children[a.table.children.length === 1 ? 0 : 1];
			if (
				l[0].type !== "table-row" ||
				h.type !== "table-body" ||
				h.children[0].type !== "table-row"
			) {
				i(s);
				return;
			}
			const p = f.children[0].type === "table-head";
			a.singleCell !== "many" &&
				((u = {
					start: u.start,
					end: Math.min(
						u.start + l.length - 1,
						h.children.length - 1 + (p ? 1 : 0),
					),
				}),
				(c = {
					start: c.start,
					end: Math.min(
						c.start + l[0].children.length - 1,
						h.children[0].children.length - 1,
					),
				})),
				R.withoutNormalizing(t, () => {
					for (let g = u.start; g <= u.end; g++) {
						const v = l[(g - u.start) % l.length];
						for (let b = c.start; b <= c.end; b++) {
							const y = [...Pf(p, g), b],
								x = pe.get(f, y),
								C =
									v.children[
										(b - c.start) % v.children.length
									];
							if (
								x.type !== "table-cell" ||
								C.type !== "table-cell"
							)
								continue;
							const k = [...d, ...y];
							for (const w of [...x.children.keys()].reverse())
								W.removeNodes(t, { at: [...k, w] });
							W.insertNodes(t, C.children.map($J), {
								at: [...k, 0],
							});
						}
					}
					W.setSelection(t, {
						anchor: R.start(t, [...d, ...Pf(p, u.start), c.start]),
						focus: R.end(t, [...d, ...Pf(p, u.end), c.end]),
					});
				});
		}),
		(t.deleteBackward = (s) => {
			if (
				t.selection &&
				ie.isCollapsed(t.selection) &&
				t.selection.anchor.offset === 0
			) {
				const a = R.above(t, { match: mr("table-cell") });
				if (
					a &&
					a[0].children[0].type === "paragraph" &&
					a[0].children[0].children[0].type === void 0 &&
					Y.equals(t.selection.anchor.path, [...a[1], 0, 0])
				)
					return;
			}
			o(s);
		}),
		(t.getFragment = () => {
			const s = Nm(t);
			if (s && s.singleCell !== "not-selected") {
				var a;
				const { table: l } = s,
					u =
						l.children[0].type === "table-head" ||
						l.children[0].type === "table-body"
							? l.children[0]
							: void 0;
				if (!u) return r();
				const c =
						((a = l.children[1]) === null || a === void 0
							? void 0
							: a.type) === "table-body"
							? l.children[1]
							: void 0,
					d = c || u,
					f = u.type === "table-head",
					h = s.row.start === 0 && !!c,
					p = s.column.end - s.column.start + 1;
				return [
					{
						type: "table",
						children: [
							...(h
								? [
										{
											type: "table-head",
											children: [
												{
													type: "table-row",
													children: Array.from({
														length: p,
													}).map(
														(g, v) =>
															u.children[0]
																.children[
																v +
																	s.column
																		.start
															],
													),
												},
											],
										},
									]
								: []),
							{
								type: "table-body",
								children: Array.from({
									length:
										s.row.end - s.row.start + (h ? 0 : 1),
								}).map((g, v) => ({
									type: "table-row",
									children: Array.from({ length: p }).map(
										(b, y) =>
											d.children[
												v +
													s.row.start -
													(f && !h ? 1 : 0)
											].children[y + s.column.start],
									),
								})),
							},
						],
					},
				];
			}
			return r();
		}),
		(t.deleteFragment = (s) => {
			if (!t.selection || ie.isCollapsed(t.selection)) {
				e(s);
				return;
			}
			const a = Nm(t);
			if (!a || a.singleCell === "not-selected") {
				e(s);
				return;
			}
			const l = a.table.children[0];
			if (!$e.isElement(l) || !$e.isElement(l.children[0])) {
				e(s);
				return;
			}
			const u =
					a.table.children.reduce(
						(b, y) =>
							b +
							(y.type === "table-head" || y.type === "table-body"
								? y.children.length
								: 0),
						0,
					) - 1,
				{ row: c, column: d, tablePath: f } = a,
				h = c.start === 0 && c.end === u,
				p =
					d.start === 0 &&
					d.end === l.children[0].children.length - 1;
			if (h && p) {
				W.removeNodes(t, { at: f });
				return;
			}
			const g = l.type === "table-head";
			if (p) {
				R.withoutNormalizing(t, () => {
					for (let b = c.end; b >= c.start; b--) {
						if (g) {
							if (b === 0) {
								W.removeNodes(t, { at: [...f, 0] });
								continue;
							}
							W.removeNodes(t, { at: [...f, 1, b - 1] });
							continue;
						}
						W.removeNodes(t, { at: [...f, 0, b] });
					}
				});
				return;
			}
			if (h) {
				R.withoutNormalizing(t, () => {
					for (let x = d.end; x >= d.start; x--)
						for (let C = 0; C <= u; C++)
							W.removeNodes(t, { at: [...f, ...Pf(g, C), x] });
					const b = [...f, 0, 0, d.start],
						y = R.start(t, d.start === 0 ? b : Y.previous(b));
					W.select(t, y);
				});
				return;
			}
			const v = R.start(t, t.selection).path;
			R.withoutNormalizing(t, () => {
				for (let b = c.start; b <= c.end; b++)
					for (let y = d.start; y <= d.end; y++) {
						const x = [...Pf(g, b), y],
							C = pe.get(a.table, x);
						if (!$e.isElement(C)) continue;
						const k = [...f, ...x];
						W.insertNodes(
							t,
							{ type: "paragraph", children: [{ text: "" }] },
							{ at: [...k, 0] },
						);
						for (const w of [...C.children.keys()].reverse())
							W.removeNodes(t, { at: [...k, w + 1] });
					}
				W.select(t, v);
			});
		}),
		(t.normalizeNode = (s) => {
			const [a, l] = s;
			if (a.type === "table-head" && a.children.length > 1) {
				Dg(t, l, Y.next(l), (c, d) => d !== 0);
				return;
			}
			let u = !1;
			for (const c of ["table-body", "table-head"])
				if (a.type === c) {
					for (const [d, f] of a.children.entries())
						if (f.type === "table-row") {
							for (const [h, p] of f.children.entries())
								if (p.type === "table-cell") {
									const g = [...l, d, h];
									p.header &&
										c === "table-body" &&
										(W.unsetNodes(t, "header", { at: g }),
										(u = !0)),
										!p.header &&
											c === "table-head" &&
											(W.setNodes(
												t,
												{ header: !0 },
												{ at: g },
											),
											(u = !0));
								}
						}
				}
			if (!u) {
				if (a.type === "table") {
					const c = a.children.reduce(
						(f, h) =>
							h.type === "table-head" || h.type === "table-body"
								? h.children.reduce(
										(p, g) =>
											g.type === "table-row"
												? Math.max(p, g.children.length)
												: p,
										f,
									)
								: f,
						0,
					);
					let d = !1;
					for (const [f, h] of a.children.entries())
						if (h.type === "table-body" || h.type === "table-head")
							for (const [p, g] of h.children.entries())
								g.type === "table-row" &&
									g.children.length !== c &&
									(W.insertNodes(
										t,
										Array.from(
											{ length: c - g.children.length },
											() => Xi(h.type === "table-head"),
										),
										{ at: [...l, f, p, g.children.length] },
									),
									(d = !0));
					if (d) return;
					if (
						a.children.length === 1 &&
						a.children[0].type === "table-head"
					) {
						W.insertNodes(
							t,
							{
								type: "table-body",
								children: Array.from(
									{ length: a.children[0].children.length },
									() => Xi(!1),
								),
							},
							{ at: [...l, 1] },
						);
						return;
					}
					if (
						a.children.length === 2 &&
						a.children[1].type === "table-head"
					) {
						W.moveNodes(t, { at: [...l, 1], to: [...l, 0] });
						return;
					}
					if (a.children.length > 2) {
						Dg(t, l, Y.next(l), (f, h) => h !== 0 && h !== 1);
						return;
					}
				}
				n(s);
			}
		}),
		t
	);
}
const TJ = (t) => {
		W.insertNodes(t, {
			type: "table",
			children: [
				{
					type: "table-head",
					children: [
						{
							type: "table-row",
							children: [Xi(!0), Xi(!0), Xi(!0)],
						},
					],
				},
				{
					type: "table-body",
					children: [
						{
							type: "table-row",
							children: [Xi(!1), Xi(!1), Xi(!1)],
						},
						{
							type: "table-row",
							children: [Xi(!1), Xi(!1), Xi(!1)],
						},
					],
				},
			],
		});
	},
	_d = E.createContext(void 0);
function MBe(t, e, n) {
	var r;
	const i = new Set(),
		o =
			t.children[0].type === "table-head" ||
			t.children[0].type === "table-body"
				? t.children[0]
				: void 0;
	if (!o) return i;
	const s =
		((r = t.children[1]) === null || r === void 0 ? void 0 : r.type) ===
		"table-body"
			? t.children[1]
			: void 0;
	for (let a = e.start; a <= e.end; a++) {
		const l = s
			? a === 0
				? o.children[0]
				: s.children[a - 1]
			: o.children[a];
		if ($e.isElement(l))
			for (let u = n.start; u <= n.end; u++) i.add(l.children[u]);
	}
	return i;
}
function jBe(t) {
	const e = ee(14),
		n = Gx();
	let r;
	if (e[0] !== n || e[1] !== t) {
		r = Symbol.for("react.early_return_sentinel");
		e: {
			const a = Nm(n);
			if (a) {
				const l =
					a.singleCell === "not-selected"
						? new Set()
						: MBe(a.table, a.row, a.column);
				let u;
				if (e[3] !== n) {
					var i, o;
					(u =
						(i = R.above(n, {
							match: mr("table-cell"),
							at:
								(o = n.selection) === null || o === void 0
									? void 0
									: o.focus.path,
						})) === null || i === void 0
							? void 0
							: i[0]),
						(e[3] = n),
						(e[4] = u);
				} else u = e[4];
				let c;
				e[5] !== l || e[6] !== a.table || e[7] !== u
					? ((c = { cells: l, table: a.table, focus: u }),
						(e[5] = l),
						(e[6] = a.table),
						(e[7] = u),
						(e[8] = c))
					: (c = e[8]);
				let d;
				e[9] !== c || e[10] !== t.children
					? ((d = m.jsx(_d.Provider, {
							value: c,
							children: t.children,
						})),
						(e[9] = c),
						(e[10] = t.children),
						(e[11] = d))
					: (d = e[11]),
					(r = d);
				break e;
			}
		}
		(e[0] = n), (e[1] = t), (e[2] = r);
	} else r = e[2];
	if (r !== Symbol.for("react.early_return_sentinel")) return r;
	let s;
	return (
		e[12] !== t.children
			? ((s = m.jsx(_d.Provider, {
					value: void 0,
					children: t.children,
				})),
				(e[12] = t.children),
				(e[13] = s))
			: (s = e[13]),
		s
	);
}
const BJ = E.createContext({ top: new Map(), left: new Map() }),
	_Be = (t) => {
		var e;
		const n = ee(51),
			{ attributes: r, children: i, element: o } = t,
			s = wn(),
			a = E.useContext(_d),
			l = (a == null ? void 0 : a.table) === o ? a : void 0;
		let u;
		e: {
			const N = o.children[0];
			if (!$e.isElement(N) || !$e.isElement(N.children[0])) {
				let V;
				n[0] === Symbol.for("react.memo_cache_sentinel")
					? ((V = new Map()), (n[0] = V))
					: (V = n[0]);
				let K;
				n[1] === Symbol.for("react.memo_cache_sentinel")
					? ((K = { top: V, left: new Map() }), (n[1] = K))
					: (K = n[1]),
					(u = K);
				break e;
			}
			let O, _;
			if (n[2] !== N.children || n[3] !== l || n[4] !== o.children) {
				(O = new Map()), (_ = new Map());
				for (const [V, K] of N.children[0].children.entries())
					K.type === "table-cell" &&
						O.set(
							K,
							o.children.every((M) =>
								$e.isElement(M)
									? M.children.every(
											(G) =>
												$e.isElement(G) &&
												(l == null
													? void 0
													: l.cells.has(
															G.children[V],
														)),
										)
									: !1,
							),
						);
				for (const V of o.children)
					if (!(V.type !== "table-head" && V.type !== "table-body"))
						for (const K of V.children)
							K.type !== "table-row" ||
								K.children[0].type !== "table-cell" ||
								_.set(
									K.children[0],
									K.children.every((M) =>
										l == null ? void 0 : l.cells.has(M),
									),
								);
				(n[2] = N.children),
					(n[3] = l),
					(n[4] = o.children),
					(n[5] = O),
					(n[6] = _);
			} else (O = n[5]), (_ = n[6]);
			let j;
			n[7] !== O || n[8] !== _
				? ((j = { top: O, left: _ }),
					(n[7] = O),
					(n[8] = _),
					(n[9] = j))
				: (j = n[9]),
				(u = j);
		}
		const c = u;
		let d;
		n[10] !== l
			? ((d = X({
					width: "100%",
					tableLayout: "fixed",
					position: "relative",
					borderSpacing: 0,
					"& *::selection":
						l != null && l.cells.size
							? { backgroundColor: "transparent" }
							: void 0,
				})),
				(n[10] = l),
				(n[11] = d))
			: (d = n[11]);
		let f;
		n[12] !== d || n[13] !== i
			? ((f = m.jsx("table", { className: d, children: i })),
				(n[12] = d),
				(n[13] = i),
				(n[14] = f))
			: (f = n[14]);
		const h =
			((e = o.children[0]) === null || e === void 0 ? void 0 : e.type) ===
			"table-head";
		let p;
		n[15] !== s || n[16] !== o
			? ((p = () => {
					const N = te.findPath(s, o);
					R.withoutNormalizing(s, () => {
						if (o.children[0].type === "table-head") {
							W.moveNodes(s, {
								at: [...N, 0, 0],
								to: [...N, 1, 0],
							}),
								W.removeNodes(s, { at: [...N, 0] });
							return;
						}
						W.insertNodes(
							s,
							{ type: "table-head", children: [] },
							{ at: [...N, 0] },
						),
							W.moveNodes(s, {
								at: [...N, 1, 0],
								to: [...N, 0, 0],
							});
					});
				}),
				(n[15] = s),
				(n[16] = o),
				(n[17] = p))
			: (p = n[17]);
		let g;
		n[18] === Symbol.for("react.memo_cache_sentinel")
			? ((g = m.jsx(ve, { src: Gq })), (n[18] = g))
			: (g = n[18]);
		let v;
		n[19] !== h || n[20] !== p
			? ((v = m.jsx(Re, {
					prominence: "low",
					isSelected: h,
					onPress: p,
					children: g,
				})),
				(n[19] = h),
				(n[20] = p),
				(n[21] = v))
			: (v = n[21]);
		let b;
		n[22] === Symbol.for("react.memo_cache_sentinel")
			? ((b = m.jsx(Xe, { children: "Header row" })), (n[22] = b))
			: (b = n[22]);
		let y;
		n[23] !== v
			? ((y = m.jsxs(Ze, { children: [v, b] })), (n[23] = v), (n[24] = y))
			: (y = n[24]);
		let x;
		n[25] === Symbol.for("react.memo_cache_sentinel")
			? ((x = m.jsx(H3, {})), (n[25] = x))
			: (x = n[25]);
		let C;
		n[26] !== s || n[27] !== o
			? ((C = () => {
					W.removeNodes(s, { at: te.findPath(s, o) });
				}),
				(n[26] = s),
				(n[27] = o),
				(n[28] = C))
			: (C = n[28]);
		let k;
		n[29] === Symbol.for("react.memo_cache_sentinel")
			? ((k = m.jsx(ve, { src: Wr })), (n[29] = k))
			: (k = n[29]);
		let w;
		n[30] !== C
			? ((w = m.jsx(Re, { prominence: "low", onPress: C, children: k })),
				(n[30] = C),
				(n[31] = w))
			: (w = n[31]);
		let D;
		n[32] === Symbol.for("react.memo_cache_sentinel")
			? ((D = m.jsx(Xe, { tone: "critical", children: "Remove" })),
				(n[32] = D))
			: (D = n[32]);
		let S;
		n[33] !== w
			? ((S = m.jsxs(Ze, { children: [w, D] })), (n[33] = w), (n[34] = S))
			: (S = n[34]);
		let $;
		n[35] !== y || n[36] !== S
			? (($ = m.jsx(tf, {
					children: m.jsxs(ke, {
						gap: "regular",
						padding: "regular",
						children: [y, x, S],
					}),
				})),
				(n[35] = y),
				(n[36] = S),
				(n[37] = $))
			: ($ = n[37]);
		let A;
		n[38] !== o || n[39] !== f || n[40] !== $
			? ((A = m.jsxs(ef, { element: o, children: [f, $] })),
				(n[38] = o),
				(n[39] = f),
				(n[40] = $),
				(n[41] = A))
			: (A = n[41]);
		let T;
		n[42] !== r || n[43] !== A
			? ((T = m.jsx(aA, { attributes: r, children: A })),
				(n[42] = r),
				(n[43] = A),
				(n[44] = T))
			: (T = n[44]);
		let I;
		n[45] !== l || n[46] !== T
			? ((I = m.jsx(_d.Provider, { value: l, children: T })),
				(n[45] = l),
				(n[46] = T),
				(n[47] = I))
			: (I = n[47]);
		let F;
		return (
			n[48] !== c || n[49] !== I
				? ((F = m.jsx(BJ.Provider, { value: c, children: I })),
					(n[48] = c),
					(n[49] = I),
					(n[50] = F))
				: (F = n[50]),
			F
		);
	},
	zBe = (t) => {
		const e = ee(3),
			{ attributes: n, children: r } = t;
		let i;
		return (
			e[0] !== n || e[1] !== r
				? ((i = m.jsx("tbody", { ...n, children: r })),
					(e[0] = n),
					(e[1] = r),
					(e[2] = i))
				: (i = e[2]),
			i
		);
	},
	LBe = (t) => {
		const e = ee(3),
			{ attributes: n, children: r } = t;
		let i;
		return (
			e[0] !== n || e[1] !== r
				? ((i = m.jsx("thead", { ...n, children: r })),
					(e[0] = n),
					(e[1] = r),
					(e[2] = i))
				: (i = e[2]),
			i
		);
	},
	VBe = (t) => {
		var e;
		const n = ee(9),
			{ attributes: r, children: i, element: o } = t,
			s =
				(e = E.useContext(_d)) === null || e === void 0
					? void 0
					: e.table;
		let a;
		if (n[0] !== s || n[1] !== o) {
			var l;
			(a =
				(l = s == null ? void 0 : s.children.indexOf(o)) !== null &&
				l !== void 0
					? l
					: -1),
				(n[0] = s),
				(n[1] = o),
				(n[2] = a);
		} else a = n[2];
		let u;
		n[3] !== r || n[4] !== i
			? ((u = m.jsx("tr", { ...r, children: i })),
				(n[3] = r),
				(n[4] = i),
				(n[5] = u))
			: (u = n[5]);
		let c;
		return (
			n[6] !== a || n[7] !== u
				? ((c = m.jsx(KBe.Provider, { value: a, children: u })),
					(n[6] = a),
					(n[7] = u),
					(n[8] = c))
				: (c = n[8]),
			c
		);
	},
	KBe = E.createContext(-1);
function UBe(t) {
	const e = ee(38),
		{ attributes: n, children: r, element: i } = t,
		o = wn(),
		s = E.useContext(_d),
		a = E.useContext(BJ);
	let l;
	e[0] !== s || e[1] !== i
		? ((l = s == null ? void 0 : s.cells.has(i)),
			(e[0] = s),
			(e[1] = i),
			(e[2] = l))
		: (l = e[2]);
	const u = l,
		c = "calc(100% + 2px)",
		d = i.header ? "th" : "td",
		f = u ? B.color.alias.borderSelected : B.color.alias.borderIdle,
		h = `1px solid ${f}`,
		p = `1px solid ${f}`,
		g = a.top.has(i) ? `1px solid ${f}` : void 0,
		v = a.left.has(i) ? `1px solid ${f}` : void 0,
		b =
			s != null && s.cells.has(i)
				? B.color.alias.backgroundSelected
				: i.header
					? B.color.scale.slate3
					: void 0;
	let y;
	e[3] !== h || e[4] !== p || e[5] !== g || e[6] !== v || e[7] !== b
		? ((y = X({
				borderInlineEnd: h,
				borderBottom: p,
				borderTop: g,
				borderInlineStart: v,
				backgroundColor: b,
				position: "relative",
				margin: 0,
				padding: B.size.space.regular,
				fontWeight: "inherit",
				boxSizing: "border-box",
				textAlign: "start",
				verticalAlign: "top",
			})),
			(e[3] = h),
			(e[4] = p),
			(e[5] = g),
			(e[6] = v),
			(e[7] = b),
			(e[8] = y))
		: (y = e[8]);
	let x;
	e[9] !== u
		? ((x =
				u &&
				m.jsxs(m.Fragment, {
					children: [
						m.jsx("div", {
							contentEditable: !1,
							className: X({
								position: "absolute",
								top: -1,
								insetInlineStart: -1,
								background: B.color.alias.borderSelected,
								height: c,
								width: 1,
							}),
						}),
						m.jsx("div", {
							contentEditable: !1,
							className: X({
								position: "absolute",
								top: -1,
								insetInlineStart: -1,
								background: B.color.alias.borderSelected,
								height: 1,
								width: c,
							}),
						}),
					],
				})),
			(e[9] = u),
			(e[10] = x))
		: (x = e[10]);
	let C;
	e[11] !== a.top || e[12] !== i || e[13] !== o
		? ((C =
				a.top.has(i) &&
				m.jsx(TC, {
					location: "top",
					selected: !!a.top.get(i),
					label: "Select Column",
					onClick: () => {
						const A = te.findPath(o, i),
							T = R.above(o, { match: mr("table"), at: A });
						if (!T) return;
						const I = T[0].children.length - 1,
							F = T[0].children[I];
						if (F.type !== "table-body") return;
						const N = A[A.length - 1],
							O = [
								...T[1],
								T[0].children.length - 1,
								F.children.length - 1,
								N,
							];
						W.select(o, {
							anchor: R.start(o, A),
							focus: R.end(o, O),
						});
					},
				})),
			(e[11] = a.top),
			(e[12] = i),
			(e[13] = o),
			(e[14] = C))
		: (C = e[14]);
	let k;
	e[15] !== a.left || e[16] !== i || e[17] !== o
		? ((k =
				a.left.has(i) &&
				m.jsx(TC, {
					location: "left",
					selected: !!a.left.get(i),
					label: "Select Row",
					onClick: () => {
						const A = te.findPath(o, i);
						W.select(o, {
							anchor: R.start(o, Y.parent(A)),
							focus: R.end(o, Y.parent(A)),
						});
					},
				})),
			(e[15] = a.left),
			(e[16] = i),
			(e[17] = o),
			(e[18] = k))
		: (k = e[18]);
	let w;
	e[19] !== a || e[20] !== i || e[21] !== o
		? ((w =
				a.left.has(i) &&
				a.top.has(i) &&
				m.jsx(TC, {
					location: "top-left",
					selected: !!(a.top.get(i) && a.left.get(i)),
					label: "Select Table",
					onClick: () => {
						const A = te.findPath(o, i),
							T = R.above(o, { match: mr("table"), at: A });
						T &&
							W.select(o, {
								anchor: R.start(o, T[1]),
								focus: R.end(o, T[1]),
							});
					},
				})),
			(e[19] = a),
			(e[20] = i),
			(e[21] = o),
			(e[22] = w))
		: (w = e[22]);
	let D;
	e[23] !== r
		? ((D = m.jsx("div", { children: r })), (e[23] = r), (e[24] = D))
		: (D = e[24]);
	let S;
	e[25] !== s || e[26] !== i
		? ((S =
				(s == null ? void 0 : s.focus) === i &&
				m.jsx(WBe, { cell: i, table: s.table })),
			(e[25] = s),
			(e[26] = i),
			(e[27] = S))
		: (S = e[27]);
	let $;
	return (
		e[28] !== d ||
		e[29] !== y ||
		e[30] !== n ||
		e[31] !== x ||
		e[32] !== C ||
		e[33] !== k ||
		e[34] !== w ||
		e[35] !== D ||
		e[36] !== S
			? (($ = m.jsxs(d, {
					className: y,
					...n,
					children: [x, C, k, w, D, S],
				})),
				(e[28] = d),
				(e[29] = y),
				(e[30] = n),
				(e[31] = x),
				(e[32] = C),
				(e[33] = k),
				(e[34] = w),
				(e[35] = D),
				(e[36] = S),
				(e[37] = $))
			: ($ = e[37]),
		$
	);
}
function TC(t) {
	const e = ee(19),
		n = E.useContext(_d),
		r = wn(),
		{ location: i, selected: o } = t;
	let s;
	e[0] !== i || e[1] !== o
		? ((s = lt({ location: i, selected: o })),
			(e[0] = i),
			(e[1] = o),
			(e[2] = s))
		: (s = e[2]);
	let a;
	e[3] === Symbol.for("react.memo_cache_sentinel")
		? ((a = X({
				background: B.color.scale.slate3,
				border: `1px solid ${B.color.alias.borderIdle}`,
				margin: 0,
				padding: 0,
				position: "absolute",
				":hover": { background: B.color.scale.slate4 },
				"::before": { content: '""', inset: -1, position: "absolute" },
				"&[data-location=top]": {
					top: -9,
					insetInlineStart: -1,
					width: "calc(100% + 2px)",
					height: 8,
				},
				"&[data-location=left]": {
					top: -1,
					insetInlineStart: -9,
					width: 8,
					height: "calc(100% + 2px)",
				},
				"&[data-location=top-left]": {
					top: -9,
					insetInlineStart: -9,
					width: 8,
					height: 8,
				},
				"&:not([data-location=top])": { borderInlineEnd: "none" },
				"&:not([data-location=left])": { borderBottom: "none" },
				"&[data-selected=true]": {
					background: B.color.scale.indigo8,
					borderColor: B.color.alias.borderSelected,
				},
			})),
			(e[3] = a))
		: (a = e[3]);
	const l = n != null && n.focus ? "visible" : "hidden";
	let u;
	e[4] !== l ? ((u = { visibility: l }), (e[4] = l), (e[5] = u)) : (u = e[5]);
	let c;
	e[6] !== r || e[7] !== t
		? ((c = () => {
				te.focus(r), t.onClick();
			}),
			(e[6] = r),
			(e[7] = t),
			(e[8] = c))
		: (c = e[8]);
	let d;
	e[9] !== s || e[10] !== u || e[11] !== t.label || e[12] !== c
		? ((d = m.jsx("button", {
				tabIndex: -1,
				type: "button",
				...s,
				className: a,
				style: u,
				"aria-label": t.label,
				onClick: c,
			})),
			(e[9] = s),
			(e[10] = u),
			(e[11] = t.label),
			(e[12] = c),
			(e[13] = d))
		: (d = e[13]);
	let f;
	e[14] !== t
		? ((f =
				t.selected &&
				(t.location === "top"
					? m.jsx("div", {
							className: X({
								position: "absolute",
								top: -9,
								insetInlineEnd: -1,
								background: B.color.alias.borderSelected,
								height: 8,
								width: 1,
								zIndex: 2,
							}),
						})
					: m.jsx("div", {
							className: X({
								position: "absolute",
								bottom: -1,
								insetInlineStart: -9,
								background: B.color.alias.borderSelected,
								height: 1,
								width: 8,
								zIndex: 2,
							}),
						}))),
			(e[14] = t),
			(e[15] = f))
		: (f = e[15]);
	let h;
	return (
		e[16] !== d || e[17] !== f
			? ((h = m.jsxs("div", { contentEditable: !1, children: [d, f] })),
				(e[16] = d),
				(e[17] = f),
				(e[18] = h))
			: (h = e[18]),
		h
	);
}
const HBe = {
		deleteRow: {
			label: "Delete row",
			action: (t, e) => {
				const n = e.slice(0, -3),
					r = pe.get(t, n);
				if (r.type !== "table") return;
				const i = r.children[0].type === "table-head",
					o = Y.parent(e);
				W.removeNodes(t, {
					at: i && o[e.length - 3] === 0 ? Y.parent(o) : o,
				});
			},
		},
		deleteColumn: {
			label: "Delete column",
			action: (t, e) => {
				const n = e[e.length - 1],
					r = e.slice(0, -3),
					i = pe.get(t, r);
				i.type === "table" &&
					R.withoutNormalizing(t, () => {
						for (const [o, s] of i.children.entries())
							if (
								!(
									s.type !== "table-head" &&
									s.type !== "table-body"
								)
							)
								for (const a of s.children.keys())
									W.removeNodes(t, { at: [...r, o, a, n] });
					});
			},
		},
		insertRowBelow: {
			label: "Insert row below",
			action: (t, e) => {
				const n = pe.get(t, Y.parent(e)),
					r = e.slice(0, -3),
					i = pe.get(t, r);
				if (n.type !== "table-row" || i.type !== "table") return;
				const o = i.children[0].type === "table-head",
					s = [
						...r,
						o ? 1 : 0,
						o && e[e.length - 3] === 0 ? 0 : e[e.length - 2] + 1,
					];
				R.withoutNormalizing(t, () => {
					W.insertNodes(
						t,
						{
							type: "table-row",
							children: n.children.map(() => Xi(!1)),
						},
						{ at: s },
					),
						W.select(t, [...s, e[e.length - 1]]);
				});
			},
		},
		insertColumnRight: {
			label: "Insert column right",
			action: (t, e) => {
				const n = e[e.length - 1] + 1,
					r = e.slice(0, -3),
					i = pe.get(t, r);
				i.type === "table" &&
					R.withoutNormalizing(t, () => {
						for (const [o, s] of i.children.entries())
							if (
								!(
									s.type !== "table-head" &&
									s.type !== "table-body"
								)
							)
								for (const a of s.children.keys())
									W.insertNodes(
										t,
										Xi(s.type === "table-head"),
										{ at: [...r, o, a, n] },
									);
						W.select(t, R.start(t, Y.next(e)));
					});
			},
		},
	},
	BC = HBe;
function WBe(t) {
	const e = ee(13),
		n = wn(),
		r = B.size.space.small;
	let i;
	e[0] === Symbol.for("react.memo_cache_sentinel")
		? ((i = X({ top: r, insetInlineEnd: r, position: "absolute" })),
			(e[0] = i))
		: (i = e[0]);
	let o;
	e[1] === Symbol.for("react.memo_cache_sentinel")
		? ((o = X({
				borderRadius: B.size.radius.small,
				height: "auto",
				minWidth: 0,
				padding: 0,
				"&::before": {
					content: '""',
					inset: `calc(${r} * -1)`,
					position: "absolute",
				},
			})),
			(e[1] = o))
		: (o = e[1]);
	let s;
	e[2] === Symbol.for("react.memo_cache_sentinel")
		? ((s = m.jsx(Re, {
				prominence: "low",
				UNSAFE_className: o,
				children: m.jsx(ve, { src: Il }),
			})),
			(e[2] = s))
		: (s = e[2]);
	let a;
	e[3] !== n || e[4] !== t.cell
		? ((a = (h) => {
				h in BC && BC[h].action(n, te.findPath(n, t.cell));
			}),
			(e[3] = n),
			(e[4] = t.cell),
			(e[5] = a))
		: (a = e[5]);
	let l, u;
	e[6] === Symbol.for("react.memo_cache_sentinel")
		? ((l = Object.entries(BC).map((h) => {
				const [p, g] = h;
				return { ...g, key: p };
			})),
			(u = (h) => m.jsx(Mt, { children: h.label }, h.key)),
			(e[6] = l),
			(e[7] = u))
		: ((l = e[6]), (u = e[7]));
	let c;
	e[8] !== a
		? ((c = m.jsxs(Xo, {
				align: "end",
				children: [
					s,
					m.jsx(Jo, { onAction: a, items: l, children: u }),
				],
			})),
			(e[8] = a),
			(e[9] = c))
		: (c = e[9]);
	let d;
	e[10] === Symbol.for("react.memo_cache_sentinel")
		? ((d = m.jsx(Xe, { children: "Options" })), (e[10] = d))
		: (d = e[10]);
	let f;
	return (
		e[11] !== c
			? ((f = m.jsx("div", {
					contentEditable: !1,
					className: i,
					children: m.jsxs(Ze, { children: [c, d] }),
				})),
				(e[11] = c),
				(e[12] = f))
			: (f = e[12]),
		f
	);
}
const qBe = () => {
		const t = ee(7),
			{ editor: e, blockquote: n } = zs(),
			{ isDisabled: r, isSelected: i } = n;
		let o, s;
		t[0] !== e
			? ((s = () => {
					TJ(e), te.focus(e);
				}),
				(t[0] = e),
				(t[1] = s))
			: (s = t[1]);
		let a;
		t[2] === Symbol.for("react.memo_cache_sentinel")
			? ((a = m.jsx(ve, { src: XD })), (t[2] = a))
			: (a = t[2]);
		let l;
		return (
			t[3] !== i || t[4] !== r || t[5] !== s
				? ((l = m.jsx(Re, {
						prominence: "low",
						isSelected: i,
						isDisabled: r,
						onPress: s,
						children: a,
					})),
					(t[3] = i),
					(t[4] = r),
					(t[5] = s),
					(t[6] = l))
				: (l = t[6]),
			(o = l),
			o
		);
	},
	GBe = m.jsxs(Ze, {
		children: [
			m.jsx(qBe, {}),
			m.jsx(Xe, { children: m.jsx(ue, { children: "Table" }) }),
		],
	});
function YBe(t, e, n) {
	if (n === "left" || n === "right") {
		const l = R.above(t, { match: mr("table-row"), at: e });
		if (!l) return;
		const d = e[e.length - 1] + (n === "left" ? -1 : 1);
		return l[0].children[d] ? [...l[1], d] : void 0;
	}
	const r = R.above(t, { match: mr("table"), at: e });
	if (!r) return;
	const i = n === "up" ? -1 : 1,
		s = e[e.length - 3] + e[e.length - 2] + i,
		a = Pf(r[0].children[0].type === "table-head", s);
	if (pe.has(r[0], a)) return [...r[1], ...a, e[e.length - 1]];
}
function JBe({ documentFeatures: t, viewState: e }) {
	const n = Ls().componentBlocks;
	let r = !1,
		i = !1;
	for (const l of Object.values(n))
		l.toolbarIcon && (i = !0), l.toolbarIcon || (r = !0);
	const o = Object.values(t.formatting.inlineMarks).some((l) => l),
		s = t.formatting.alignment.center || t.formatting.alignment.end,
		a = t.formatting.listTypes.unordered || t.formatting.listTypes.ordered;
	return m.jsxs(ZBe, {
		children: [
			m.jsxs(QBe, {
				children: [
					!!t.formatting.headings.levels.length &&
						m.jsx(tIe, {
							headingLevels: t.formatting.headings.levels,
						}),
					o && m.jsx(sIe, { marks: t.formatting.inlineMarks }),
					(s || a) &&
						m.jsxs(jF, {
							children: [
								s &&
									m.jsx(KTe, {
										alignment: t.formatting.alignment,
									}),
								a &&
									m.jsx(DBe, {
										lists: t.formatting.listTypes,
									}),
							],
						}),
					(t.dividers ||
						t.links ||
						!!t.images ||
						t.formatting.blockTypes.blockquote ||
						t.tables ||
						!!t.layouts.length ||
						t.formatting.blockTypes.code ||
						i) &&
						m.jsxs(jF, {
							children: [
								t.dividers && bBe,
								t.links && VTe,
								t.images && NBe,
								t.formatting.blockTypes.blockquote && WTe,
								!!t.layouts.length &&
									m.jsx(wBe, { layouts: t.layouts }),
								t.formatting.blockTypes.code && XTe,
								t.tables && GBe,
								r && nIe,
							],
						}),
					m.jsx(pr, { flex: !0 }),
				],
			}),
			E.useMemo(
				() =>
					e &&
					m.jsxs(ke, {
						gap: "xsmall",
						children: [
							m.jsx(H3, {}),
							m.jsxs(Ze, {
								children: [
									m.jsx(vt, {
										prominence: "low",
										onPress: () => {
											e.toggle();
										},
										children: m.jsx(ve, {
											src: e.expanded ? W3e : H3e,
										}),
									}),
									m.jsx(Xe, {
										children: e.expanded
											? "Collapse"
											: "Expand",
									}),
								],
							}),
						],
					}),
				[e],
			),
			!!r && m.jsx(iIe, {}),
		],
	});
}
const jF = ({ children: t }) => m.jsx(ke, { gap: "regular", children: t }),
	XBe = ({ children: t }) =>
		xo() === "main"
			? m.jsx("div", {
					className: X({
						boxSizing: "border-box",
						display: "flex",
						paddingInline: B.size.space.medium,
						minWidth: 0,
						maxWidth: 800,
						marginInline: "auto",
						[en.above.mobile]: {
							paddingInline: B.size.space.xlarge,
						},
						[en.above.tablet]: {
							paddingInline: B.size.space.xxlarge,
						},
					}),
					children: t,
				})
			: m.jsx("div", { className: X({ display: "flex" }), children: t }),
	ZBe = ({ children: t }) => {
		let e = xo();
		return m.jsx(m.Fragment, {
			children: m.jsx("div", {
				"data-layout": e,
				className: X({
					backdropFilter: "blur(8px)",
					backgroundClip: "padding-box",
					backgroundColor: `color-mix(in srgb, transparent, ${B.color.background.canvas} 90%)`,
					borderBottom: `${B.size.border.regular} solid color-mix(in srgb, transparent, ${B.color.foreground.neutral} 10%)`,
					borderStartEndRadius: B.size.radius.medium,
					borderStartStartRadius: B.size.radius.medium,
					minWidth: 0,
					position: "sticky",
					top: 0,
					zIndex: 2,
					'&[data-layout="main"]': { borderRadius: 0 },
				}),
				children: m.jsx(XBe, { children: t }),
			}),
		});
	},
	QBe = (t) => {
		let e = xo();
		return m.jsx(ke, {
			"data-layout": e,
			paddingY: "regular",
			paddingX: "medium",
			gap: "large",
			flex: !0,
			minWidth: 0,
			UNSAFE_className: X({
				msOverflowStyle: "none",
				scrollbarWidth: "none",
				overflowX: "auto",
				"&::-webkit-scrollbar": { display: "none" },
				'&[data-layout="main"]': { paddingInline: 0 },
			}),
			...t,
		});
	},
	eIe = new Map([
		["normal", "normal"],
		["1", 1],
		["2", 2],
		["3", 3],
		["4", 4],
		["5", 5],
		["6", 6],
	]),
	tIe = ({ headingLevels: t }) => {
		const { editor: e, textStyles: n } = zs(),
			r = n.allowedHeadingLevels.length === 0,
			i = E.useMemo(() => {
				let s = [{ name: "Paragraph", id: "normal" }];
				return (
					t.forEach((a) => {
						s.push({ name: `Heading ${a}`, id: a.toString() });
					}),
					s
				);
			}, [t]),
			o = n.selected.toString();
		return E.useMemo(
			() =>
				m.jsx(eS, {
					flexShrink: 0,
					width: "scale.1700",
					prominence: "low",
					"aria-label": "Text block",
					items: i,
					isDisabled: r,
					selectedKey: o,
					onSelectionChange: (s) => {
						let a = eIe.get(s);
						a === "normal"
							? R.withoutNormalizing(e, () => {
									W.unsetNodes(e, "level", {
										match: (l) => l.type === "heading",
									}),
										W.setNodes(
											e,
											{ type: "paragraph" },
											{
												match: (l) =>
													l.type === "heading",
											},
										);
								})
							: a &&
								W.setNodes(
									e,
									{ type: "heading", level: a },
									{
										match: (l) =>
											l.type === "paragraph" ||
											l.type === "heading",
									},
								),
							te.focus(e);
					},
					children: (s) => m.jsx(Mt, { children: s.name }, s.id),
				}),
			[e, r, i, o],
		);
	},
	nIe = m.jsx(rIe, {});
function rIe() {
	const t = wn(),
		e = Ls().componentBlocks;
	return Object.entries(e)
		.filter(([, n]) => n.toolbarIcon)
		.map(([n, r]) =>
			m.jsxs(
				Ze,
				{
					children: [
						m.jsx(Re, {
							prominence: "low",
							onPress: () => {
								fA(t, e, n), te.focus(t);
							},
							children: m.jsx(ve, { src: r.toolbarIcon }),
						}),
						m.jsx(Xe, { children: r.label }),
					],
				},
				n,
			),
		);
}
function iIe() {
	let t = xo();
	const e = wn(),
		n = Ls().componentBlocks;
	return m.jsxs(Xo, {
		align: "end",
		children: [
			m.jsxs(Ze, {
				children: [
					m.jsxs(Re, {
						marginY: "regular",
						marginEnd: t === "main" ? void 0 : "medium",
						children: [
							m.jsx(ve, { src: Ux }),
							m.jsx(ve, { src: Il }),
						],
					}),
					m.jsxs(Xe, {
						children: [
							m.jsx(ue, { children: "Insert" }),
							m.jsx(fi, { children: "/" }),
						],
					}),
				],
			}),
			m.jsx(Jo, {
				onAction: (r) => {
					fA(e, n, r);
				},
				items: Object.entries(n).filter(([, r]) => !r.toolbarIcon),
				children: ([r, i]) => m.jsx(Mt, { children: i.label }, r),
			}),
		],
	});
}
const oIe = [
	{ key: "bold", label: "Bold", icon: i_, shortcut: "B" },
	{ key: "italic", label: "Italic", icon: o_, shortcut: "I" },
	{ key: "underline", label: "Underline", icon: J3e, shortcut: "U" },
	{ key: "strikethrough", label: "Strikethrough", icon: a_ },
	{ key: "code", label: "Code", icon: Kx },
	{ key: "superscript", label: "Superscript", icon: G3e },
	{ key: "subscript", label: "Subscript", icon: q3e },
	{ key: "clearFormatting", label: "Clear formatting", icon: s_ },
];
function sIe({ marks: t }) {
	const {
			editor: e,
			clearFormatting: { isDisabled: n },
			marks: r,
		} = zs(),
		i = IC(t),
		o = IC(Object.keys(r).filter((a) => r[a].isSelected)),
		s = IC(
			Object.keys(r)
				.filter((a) => r[a].isDisabled)
				.concat(n ? "clearFormatting" : []),
		);
	return E.useMemo(() => {
		const a = oIe.filter((l) => l.key === "clearFormatting" || i[l.key]);
		return m.jsx(nf, {
			UNSAFE_className: X({
				minWidth: `calc(${B.size.element.medium} * 4)`,
			}),
			prominence: "low",
			density: "compact",
			buttonLabelBehavior: "hide",
			overflowMode: "collapse",
			summaryIcon: m.jsx(ve, { src: Y3e }),
			items: a,
			selectionMode: "multiple",
			selectedKeys: o,
			disabledKeys: s,
			onAction: (l) => {
				if (l === "clearFormatting") kH(e);
				else {
					var u;
					const c = l;
					(u = R.marks(e)) !== null && u !== void 0 && u[c]
						? R.removeMark(e, c)
						: R.addMark(e, c, !0);
				}
				te.focus(e);
			},
			children: (l) =>
				m.jsxs(
					Mt,
					{
						textValue: l.label,
						children: [
							m.jsx(ue, { children: l.label }),
							"shortcut" in l &&
								m.jsx(fi, { meta: !0, children: l.shortcut }),
							m.jsx(ve, { src: l.icon }),
						],
					},
					l.key,
				),
		});
	}, [s, e, i, o]);
}
function IC(t) {
	return E.useMemo(() => t, [JSON.stringify(t)]);
}
const aIe = (t) => {
		const e = ee(37),
			{ attributes: n, children: r, element: i } = t,
			o = `h${i.level}`,
			s = wn(),
			{ documentFeatures: a } = Ls(),
			[l, u] = E.useState(!1);
		if (Object.keys(a.formatting.headings.schema.fields).length === 0) {
			let D;
			e[0] !== i.textAlign
				? ((D = { textAlign: i.textAlign }),
					(e[0] = i.textAlign),
					(e[1] = D))
				: (D = e[1]);
			let S;
			return (
				e[2] !== o || e[3] !== n || e[4] !== D || e[5] !== r
					? ((S = m.jsx(o, { ...n, style: D, children: r })),
						(e[2] = o),
						(e[3] = n),
						(e[4] = D),
						(e[5] = r),
						(e[6] = S))
					: (S = e[6]),
				S
			);
		}
		let c;
		e[7] !== i.textAlign
			? ((c = { textAlign: i.textAlign }),
				(e[7] = i.textAlign),
				(e[8] = c))
			: (c = e[8]);
		let d;
		e[9] !== r
			? ((d = m.jsx("div", { children: r })), (e[9] = r), (e[10] = d))
			: (d = e[10]);
		let f;
		e[11] === Symbol.for("react.memo_cache_sentinel")
			? ((f = m.jsx(xJ, { onPress: () => u(!0) })), (e[11] = f))
			: (f = e[11]);
		let h;
		e[12] !== s || e[13] !== i
			? ((h = () => {
					W.removeNodes(s, { at: te.findPath(s, i) });
				}),
				(e[12] = s),
				(e[13] = i),
				(e[14] = h))
			: (h = e[14]);
		let p;
		e[15] === Symbol.for("react.memo_cache_sentinel")
			? ((p = m.jsx(ve, { src: Wr })), (e[15] = p))
			: (p = e[15]);
		let g;
		e[16] !== h
			? ((g = m.jsx(Re, { prominence: "low", onPress: h, children: p })),
				(e[16] = h),
				(e[17] = g))
			: (g = e[17]);
		let v;
		e[18] === Symbol.for("react.memo_cache_sentinel")
			? ((v = m.jsx(Xe, { tone: "critical", children: "Remove" })),
				(e[18] = v))
			: (v = e[18]);
		let b;
		e[19] !== g
			? ((b = m.jsx(tf, {
					children: m.jsxs(ke, {
						gap: "regular",
						padding: "regular",
						children: [f, m.jsxs(Ze, { children: [g, v] })],
					}),
				})),
				(e[19] = g),
				(e[20] = b))
			: (b = e[20]);
		let y;
		e[21] !== i || e[22] !== d || e[23] !== b
			? ((y = m.jsxs(ef, { element: i, children: [d, b] })),
				(e[21] = i),
				(e[22] = d),
				(e[23] = b),
				(e[24] = y))
			: (y = e[24]);
		let x;
		e[25] !== o || e[26] !== c || e[27] !== y
			? ((x = m.jsx(o, { style: c, children: y })),
				(e[25] = o),
				(e[26] = c),
				(e[27] = y),
				(e[28] = x))
			: (x = e[28]);
		let C;
		e[29] === Symbol.for("react.memo_cache_sentinel")
			? ((C = () => u(!1)), (e[29] = C))
			: (C = e[29]);
		let k;
		e[30] !== i || e[31] !== a.formatting.headings.schema || e[32] !== l
			? ((k = m.jsx(kJ, {
					element: i,
					schema: a.formatting.headings.schema,
					isOpen: l,
					nodeLabel: "Heading",
					onDismiss: C,
				})),
				(e[30] = i),
				(e[31] = a.formatting.headings.schema),
				(e[32] = l),
				(e[33] = k))
			: (k = e[33]);
		let w;
		return (
			e[34] !== x || e[35] !== k
				? ((w = m.jsxs(m.Fragment, { children: [x, k] })),
					(e[34] = x),
					(e[35] = k),
					(e[36] = w))
				: (w = e[36]),
			w
		);
	},
	lIe = (t) => {
		switch (t.element.type) {
			case "layout":
				return m.jsx(yBe, {
					attributes: t.attributes,
					children: t.children,
					element: t.element,
				});
			case "layout-area":
				return m.jsx(xBe, { ...t });
			case "code":
				return m.jsx(ZTe, {
					attributes: t.attributes,
					children: t.children,
					element: t.element,
				});
			case "component-block":
				return m.jsx(mBe, {
					attributes: t.attributes,
					children: t.children,
					element: t.element,
				});
			case "component-inline-prop":
			case "component-block-prop":
				return m.jsx(hBe, { ...t });
			case "heading":
				return m.jsx(aIe, {
					attributes: t.attributes,
					children: t.children,
					element: t.element,
				});
			case "link":
				return m.jsx(jTe, {
					attributes: t.attributes,
					children: t.children,
					element: t.element,
				});
			case "ordered-list":
				return m.jsx("ol", { ...t.attributes, children: t.children });
			case "unordered-list":
				return m.jsx("ul", { ...t.attributes, children: t.children });
			case "list-item":
				return m.jsx("li", { ...t.attributes, children: t.children });
			case "list-item-content":
				return m.jsx("span", { ...t.attributes, children: t.children });
			case "blockquote":
				return m.jsx("blockquote", {
					...t.attributes,
					children: t.children,
				});
			case "divider":
				return m.jsx(vBe, { ...t });
			case "image":
				return m.jsx(TBe, {
					attributes: t.attributes,
					children: t.children,
					element: t.element,
				});
			case "table":
				return m.jsx(_Be, {
					attributes: t.attributes,
					children: t.children,
					element: t.element,
				});
			case "table-head":
				return m.jsx(LBe, {
					attributes: t.attributes,
					children: t.children,
					element: t.element,
				});
			case "table-body":
				return m.jsx(zBe, {
					attributes: t.attributes,
					children: t.children,
					element: t.element,
				});
			case "table-row":
				return m.jsx(VBe, {
					attributes: t.attributes,
					children: t.children,
					element: t.element,
				});
			case "table-cell":
				return m.jsx(UBe, {
					attributes: t.attributes,
					children: t.children,
					element: t.element,
				});
			default:
				let { textAlign: e } = t.element;
				return m.jsx("p", {
					style: { textAlign: e },
					...t.attributes,
					children: t.children,
				});
		}
	};
function uIe(t, e) {
	return [
		...Object.keys(e).map((r) => ({
			label: e[r].label,
			insert: (i) => {
				fA(i, e, r);
			},
		})),
		...t.textStyles.allowedHeadingLevels
			.filter((r) =>
				t.editorDocumentFeatures.formatting.headings.levels.includes(r),
			)
			.map((r) => ({
				label: `Heading ${r}`,
				insert(i) {
					To(i, {
						type: "heading",
						level: r,
						children: [{ text: "" }],
					});
				},
			})),
		!t.blockquote.isDisabled &&
			t.editorDocumentFeatures.formatting.blockTypes.blockquote && {
				label: "Blockquote",
				insert(r) {
					To(r, { type: "blockquote", children: [{ text: "" }] });
				},
			},
		!t.code.isDisabled &&
			t.editorDocumentFeatures.formatting.blockTypes.code && {
				label: "Code block",
				insert(r) {
					To(r, { type: "code", children: [{ text: "" }] });
				},
			},
		!!t.editorDocumentFeatures.images && {
			label: "Image",
			async insert(r) {
				const i = await G3();
				i &&
					To(r, {
						type: "image",
						src: i,
						alt: "",
						title: "",
						children: [{ text: "" }],
					});
			},
		},
		!!t.editorDocumentFeatures.tables && { label: "Table", insert: TJ },
		!t.dividers.isDisabled &&
			t.editorDocumentFeatures.dividers && {
				label: "Divider",
				insert(r) {
					To(r, { type: "divider", children: [{ text: "" }] });
				},
			},
		!!t.editorDocumentFeatures.layouts.length && {
			label: "Layout",
			insert(r) {
				SJ(r, t.editorDocumentFeatures.layouts[0]);
			},
		},
		!t.lists.ordered.isDisabled &&
			t.editorDocumentFeatures.formatting.listTypes.ordered && {
				label: "Numbered List",
				keywords: ["ordered list"],
				insert(r) {
					To(r, { type: "ordered-list", children: [{ text: "" }] });
				},
			},
		!t.lists.unordered.isDisabled &&
			t.editorDocumentFeatures.formatting.listTypes.unordered && {
				label: "Bullet List",
				keywords: ["unordered list"],
				insert(r) {
					To(r, { type: "unordered-list", children: [{ text: "" }] });
				},
			},
	].filter((r) => typeof r != "boolean");
}
function _F(t, e, n) {
	const r = te.findPath(t, e);
	W.delete(t, { at: { focus: R.start(t, r), anchor: R.end(t, r) } }),
		n.insert(t);
}
function cIe({ children: t, text: e }) {
	const n = zs(),
		{ editor: r } = n,
		{ componentBlocks: i } = Ls(),
		o = $3(uIe(n, i), e.text.slice(1), { keys: ["label", "keywords"] }).map(
			(b, y) => ({ ...b, index: y }),
		),
		s = E.useRef({ options: o, text: e });
	E.useEffect(() => {
		s.current = { options: o, text: e };
	});
	const a = E.useRef((b) => {});
	E.useEffect(() => {
		a.current = (b) => {
			if (!b.defaultPrevented)
				switch (b.key) {
					case "ArrowDown": {
						s.current.options.length &&
							(b.preventDefault(),
							h.selectionManager.setFocused(!0),
							h.selectionManager.setFocusedKey(
								(Number(h.selectionManager.focusedKey) ===
								s.current.options.length - 1
									? 0
									: Number(h.selectionManager.focusedKey) + 1
								).toString(),
							));
						return;
					}
					case "ArrowUp": {
						s.current.options.length &&
							(b.preventDefault(),
							h.selectionManager.setFocused(!0),
							h.selectionManager.setFocusedKey(
								(h.selectionManager.focusedKey === "0"
									? s.current.options.length - 1
									: Number(h.selectionManager.focusedKey) - 1
								).toString(),
							));
						return;
					}
					case "Enter": {
						const y =
							s.current.options[
								Number(h.selectionManager.focusedKey)
							];
						y && (_F(r, s.current.text, y), b.preventDefault());
						return;
					}
					case "Escape": {
						const y = te.findPath(r, s.current.text);
						W.unsetNodes(r, "insertMenu", { at: y }),
							b.preventDefault();
						return;
					}
				}
		};
	}),
		E.useEffect(() => {
			const b = te.toDOMNode(r, r);
			let y = (x) => a.current(x);
			return (
				b.addEventListener("keydown", y),
				() => {
					b.removeEventListener("keydown", y);
				}
			);
		}, [r]);
	const l = E.useRef(null),
		u = Bl({ isOpen: !0 }),
		{
			triggerProps: { onPress: c, ...d },
			overlayProps: f,
		} = px({ type: "listbox" }, u, l);
	let h = y0({
		items: o,
		children: (b) => m.jsx(Mt, { children: b.label }, b.index),
	});
	E.useEffect(() => {
		!h.selectionManager.isFocused &&
			h.collection.size &&
			(h.selectionManager.setFocused(!0),
			h.selectionManager.setFocusedKey("0"));
	}, [h]);
	const p = E.useRef(null);
	E.useEffect(() => {
		var b;
		const y =
			(b = p.current) === null ||
			b === void 0 ||
			(b = b.querySelector('[role="listbox"] [role="presentation"]')) ===
				null ||
			b === void 0
				? void 0
				: b.children[h.selectionManager.focusedKey];
		y &&
			g2e(y, {
				scrollMode: "if-needed",
				boundary: p.current,
				block: "nearest",
			});
	}, [h.selectionManager.focusedKey]);
	const g = E.useRef(null);
	let v = x0();
	return m.jsxs(E.Fragment, {
		children: [
			m.jsx("span", {
				...d,
				role: "button",
				className: X({
					color: B.color.foreground.accent,
					fontWeight: B.typography.fontWeight.medium,
				}),
				ref: l,
				children: t,
			}),
			m.jsx(g0, {
				width: "alias.singleLineWidth",
				placement: "bottom start",
				isNonModal: !0,
				hideArrow: !0,
				...f,
				state: u,
				triggerRef: l,
				children: m.jsx("div", {
					className: X({ overflow: "scroll", maxHeight: 300 }),
					ref: p,
					children: m.jsx(k0, {
						"aria-label": "Insert block",
						state: h,
						shouldUseVirtualFocus: !0,
						layout: v,
						ref: g,
						onAction: (b) => {
							_F(r, e, o[b]);
						},
					}),
				}),
			}),
		],
	});
}
const zF = new WeakSet(),
	LF = new WeakSet();
function IJ(t, e) {
	if (Be.isText(t)) return t.insertMenu ? e : void 0;
	if (!zF.has(t.children)) {
		for (const [n, r] of t.children.entries()) {
			if (LF.has(r)) continue;
			let i = IJ(r, [...e, n]);
			if (i) return i;
			LF.add(r);
		}
		zF.add(t.children);
	}
}
function VF(t) {
	var e;
	const n = IJ(t, []);
	return n &&
		!((e = R.marks(t)) !== null && e !== void 0 && e.insertMenu) &&
		(!t.selection ||
			!Y.equals(t.selection.anchor.path, n) ||
			!Y.equals(t.selection.focus.path, n))
		? (W.unsetNodes(t, "insertMenu", { at: n }), !0)
		: !1;
}
function dIe(t) {
	const { normalizeNode: e, apply: n, insertText: r } = t;
	return (
		(t.normalizeNode = ([i, o]) => {
			if (Be.isText(i) && i.insertMenu) {
				if (i.text[0] !== "/") {
					W.unsetNodes(t, "insertMenu", { at: o });
					return;
				}
				const s = /\s/.exec(i.text);
				if (s) {
					W.unsetNodes(t, "insertMenu", {
						at: {
							anchor: { path: o, offset: s.index },
							focus: R.end(t, o),
						},
						match: Be.isText,
						split: !0,
					});
					return;
				}
			}
			(R.isEditor(t) && VF(t)) || e([i, o]);
		}),
		(t.apply = (i) => {
			n(i), i.type === "set_selection" && VF(t);
		}),
		(t.insertText = (i) => {
			if ((r(i), t.selection && i === "/")) {
				const o = R.start(t, R.above(t, { match: Lt })[1]),
					s = R.before(t, t.selection.anchor, { unit: "character" });
				s &&
					(ut.equals(o, s) ||
						(s.offset !== 0 &&
							/\s/.test(pe.get(t, s.path).text[s.offset - 1]))) &&
					W.setNodes(
						t,
						{ insertMenu: !0 },
						{
							at: { anchor: s, focus: t.selection.anchor },
							match: Be.isText,
							split: !0,
						},
					);
			}
		}),
		t
	);
}
function fIe(t) {
	const e = ee(12),
		{ placeholder: n, children: r } = t,
		[i, o] = E.useState(0);
	let s;
	e[0] !== i
		? ((s = X({ position: "relative", display: "inline-block", width: i })),
			(e[0] = i),
			(e[1] = s))
		: (s = e[1]);
	let a;
	e[2] === Symbol.for("react.memo_cache_sentinel")
		? ((a = X({
				position: "absolute",
				pointerEvents: "none",
				display: "inline-block",
				left: 0,
				top: 0,
				maxWidth: "100%",
				whiteSpace: "nowrap",
				opacity: "0.5",
				userSelect: "none",
				fontStyle: "normal",
				fontWeight: "normal",
				textDecoration: "none",
				textAlign: "left",
			})),
			(e[2] = a))
		: (a = e[2]);
	let l;
	e[3] !== i
		? ((l = (d) => {
				if (d) {
					const f = d.offsetWidth;
					f !== i && o(f);
				}
			}),
			(e[3] = i),
			(e[4] = l))
		: (l = e[4]);
	let u;
	e[5] !== l || e[6] !== n
		? ((u = m.jsx("span", {
				contentEditable: !1,
				className: a,
				children: m.jsx("span", { ref: l, children: n }),
			})),
			(e[5] = l),
			(e[6] = n),
			(e[7] = u))
		: (u = e[7]);
	let c;
	return (
		e[8] !== s || e[9] !== u || e[10] !== r
			? ((c = m.jsxs("span", { className: s, children: [u, r] })),
				(e[8] = s),
				(e[9] = u),
				(e[10] = r),
				(e[11] = c))
			: (c = e[11]),
		c
	);
}
const hIe = (t) => {
		const e = ee(45);
		let { leaf: n, text: r, children: i, attributes: o } = t,
			s,
			a,
			l,
			u,
			c,
			d,
			f,
			h,
			p,
			g,
			v;
		if (
			(e[0] !== n
				? (({
						underline: g,
						strikethrough: c,
						bold: u,
						italic: d,
						code: l,
						keyboard: f,
						superscript: h,
						subscript: p,
						placeholder: s,
						insertMenu: a,
						...v
					} = n),
					(e[0] = n),
					(e[1] = s),
					(e[2] = a),
					(e[3] = l),
					(e[4] = u),
					(e[5] = c),
					(e[6] = d),
					(e[7] = f),
					(e[8] = h),
					(e[9] = p),
					(e[10] = g),
					(e[11] = v))
				: ((s = e[1]),
					(a = e[2]),
					(l = e[3]),
					(u = e[4]),
					(c = e[5]),
					(d = e[6]),
					(f = e[7]),
					(h = e[8]),
					(p = e[9]),
					(g = e[10]),
					(v = e[11])),
			s !== void 0)
		) {
			let y;
			e[12] !== s || e[13] !== i
				? ((y = m.jsx(fIe, { placeholder: s, children: i })),
					(e[12] = s),
					(e[13] = i),
					(e[14] = y))
				: (y = e[14]),
				(i = y);
		}
		if (a) {
			let y;
			e[15] !== r || e[16] !== i
				? ((y = m.jsx(cIe, { text: r, children: i })),
					(e[15] = r),
					(e[16] = i),
					(e[17] = y))
				: (y = e[17]),
				(i = y);
		}
		if (l) {
			let y;
			e[18] !== i
				? ((y = m.jsx("code", { children: i })),
					(e[18] = i),
					(e[19] = y))
				: (y = e[19]),
				(i = y);
		}
		if (u) {
			let y;
			e[20] !== i
				? ((y = m.jsx("strong", { children: i })),
					(e[20] = i),
					(e[21] = y))
				: (y = e[21]),
				(i = y);
		}
		if (c) {
			let y;
			e[22] !== i
				? ((y = m.jsx("s", { children: i })), (e[22] = i), (e[23] = y))
				: (y = e[23]),
				(i = y);
		}
		if (d) {
			let y;
			e[24] !== i
				? ((y = m.jsx("em", { children: i })), (e[24] = i), (e[25] = y))
				: (y = e[25]),
				(i = y);
		}
		if (f) {
			let y;
			e[26] !== i
				? ((y = m.jsx("kbd", { children: i })),
					(e[26] = i),
					(e[27] = y))
				: (y = e[27]),
				(i = y);
		}
		if (h) {
			let y;
			e[28] !== i
				? ((y = m.jsx("sup", { children: i })),
					(e[28] = i),
					(e[29] = y))
				: (y = e[29]),
				(i = y);
		}
		if (p) {
			let y;
			e[30] !== i
				? ((y = m.jsx("sub", { children: i })),
					(e[30] = i),
					(e[31] = y))
				: (y = e[31]),
				(i = y);
		}
		if (g) {
			let y;
			e[32] !== i
				? ((y = m.jsx("u", { children: i })), (e[32] = i), (e[33] = y))
				: (y = e[33]),
				(i = y);
		}
		if (e[34] !== v || e[35] !== i) {
			let y;
			e[37] === Symbol.for("react.memo_cache_sentinel")
				? ((y = (k) => k.startsWith("prism_")), (e[37] = y))
				: (y = e[37]);
			let x;
			e[38] === Symbol.for("react.memo_cache_sentinel")
				? ((x = (k) => mIe.get(k.replace("prism_", ""))), (e[38] = x))
				: (x = e[38]);
			const C = Object.keys(v).filter(y).map(x);
			if (C.length) {
				const k = C.join(" ");
				let w;
				e[39] !== k || e[40] !== i
					? ((w = m.jsx("span", { className: k, children: i })),
						(e[39] = k),
						(e[40] = i),
						(e[41] = w))
					: (w = e[41]),
					(i = w);
			}
			(e[34] = v), (e[35] = i), (e[36] = i);
		} else i = e[36];
		let b;
		return (
			e[42] !== o || e[43] !== i
				? ((b = m.jsx("span", { ...o, children: i })),
					(e[42] = o),
					(e[43] = i),
					(e[44] = b))
				: (b = e[44]),
			b
		);
	},
	pIe = (t) => m.jsx(hIe, { ...t }),
	mIe = new Map(
		[
			{
				types: ["comment", "prolog", "doctype", "cdata"],
				style: {
					color: B.color.foreground.neutralTertiary,
					fontStyle: "italic",
				},
			},
			{
				types: ["atrule", "attr-name", "class-name", "selector"],
				style: { color: B.color.scale.amber11 },
			},
			{
				types: [
					"boolean",
					"constant",
					"inserted-sign",
					"entity",
					"inserted",
					"number",
					"regex",
					"symbol",
					"variable",
				],
				style: { color: B.color.scale.green11 },
			},
			{
				types: [
					"attr-value",
					"builtin",
					"char",
					"constant",
					"generics",
					"url",
				],
				style: { color: B.color.scale.pink11 },
			},
			{ types: ["string"], style: { color: B.color.scale.indigo9 } },
			{
				types: [
					"annotation",
					"deleted",
					"deleted-sign",
					"decorator",
					"important",
					"tag",
				],
				style: { color: B.color.scale.red11 },
			},
			{
				types: ["function", "function-variable", "operator"],
				style: { color: B.color.scale.purple11 },
			},
			{
				types: ["tag", "selector", "keyword"],
				style: { color: B.color.scale.indigo11 },
			},
			{
				types: ["punctuation"],
				style: { color: B.color.foreground.neutralSecondary },
			},
		].flatMap((t) => {
			const e = X(t.style);
			return t.types.map((n) => [n, e]);
		}),
	),
	gIe = /^```(\w+)? ?$/;
function bIe(t, e, n) {
	const { insertBreak: r, normalizeNode: i, insertText: o } = n;
	function s(a) {
		var l;
		if (
			(a == null ? void 0 : a[0].type) !== "paragraph" ||
			a[0].children.length !== 1 ||
			a[0].children[0].type !== void 0
		)
			return !1;
		const u = gIe.exec(a[0].children[0].text);
		if (!u) return !1;
		const c = z0(n, t, e);
		return c &&
			(c.kind === "inline" ||
				!c.documentFeatures.formatting.blockTypes.code)
			? !1
			: (n.history.undos.push({
					operations: [],
					selectionBefore: n.selection,
				}),
				W.select(n, a[1]),
				W.delete(n),
				W.wrapNodes(
					n,
					{
						type: "code",
						...(u[1]
							? {
									language:
										(l = _c.get(u[1].toLowerCase())) !==
											null && l !== void 0
											? l
											: u[1],
								}
							: {}),
						children: [],
					},
					{ match: (d) => d.type === "paragraph" },
				),
				!0);
	}
	return (
		(n.insertBreak = () => {
			const a = R.above(n, { match: Lt });
			if (
				(a == null ? void 0 : a[0].type) === "code" &&
				Be.isText(a[0].children[0])
			) {
				const l = a[0].children[0].text;
				if (
					l[l.length - 1] ===
						`
` &&
					n.selection &&
					ie.isCollapsed(n.selection) &&
					ut.equals(R.end(n, a[1]), n.selection.anchor)
				) {
					r(),
						W.setNodes(n, { type: "paragraph", children: [] }),
						W.delete(n, {
							distance: 1,
							at: { path: [...a[1], 0], offset: l.length - 1 },
						});
					return;
				}
				n.insertText(`
`);
				return;
			}
			(n.selection && ie.isCollapsed(n.selection) && s(a)) || r();
		}),
		(n.insertText = (a) => {
			o(a),
				a === " " &&
					n.selection &&
					ie.isCollapsed(n.selection) &&
					s(R.above(n, { match: Lt }));
		}),
		(n.normalizeNode = ([a, l]) => {
			if (a.type === "code" && $e.isElement(a))
				for (const [u, c] of a.children.entries()) {
					if (!Be.isText(c)) {
						n.isVoid(c)
							? W.removeNodes(n, { at: [...l, u] })
							: W.unwrapNodes(n, { at: [...l, u] });
						return;
					}
					const d = Object.keys(c).filter((f) => f !== "text");
					if (d.length) {
						W.unsetNodes(n, d, { at: [...l, u] });
						return;
					}
				}
			i([a, l]);
		}),
		n
	);
}
const FJ = () => ({ type: "paragraph", children: [{ text: "" }] });
function vIe(t) {
	const { normalizeNode: e } = t;
	return (
		(t.normalizeNode = (n) => {
			const [r, i] = n;
			if (R.isEditor(r)) {
				let o = r.children[r.children.length - 1];
				if ((o == null ? void 0 : o.type) !== "paragraph") {
					W.insertNodes(t, FJ(), { at: [...i, r.children.length] });
					return;
				}
			}
			e(n);
		}),
		t
	);
}
function yIe(t) {
	const { normalizeNode: e, deleteBackward: n } = t;
	return (
		(t.deleteBackward = (r) => {
			if (
				t.selection &&
				ie.isCollapsed(t.selection) &&
				t.selection.anchor.offset === 0
			) {
				const [i, o] = R.above(t, {
					match: (s) => s.type === "layout-area",
				}) || [t, []];
				if (
					i.type === "layout-area" &&
					ut.equals(R.start(t, o), t.selection.anchor)
				)
					return;
			}
			n(r);
		}),
		(t.normalizeNode = (r) => {
			const [i, o] = r;
			if ($e.isElement(i) && i.type === "layout") {
				if (i.layout === void 0) {
					W.unwrapNodes(t, { at: o });
					return;
				}
				if (i.children.length < i.layout.length) {
					W.insertNodes(
						t,
						Array.from({
							length: i.layout.length - i.children.length,
						}).map(() => ({
							type: "layout-area",
							children: [FJ()],
						})),
						{ at: [...o, i.children.length] },
					);
					return;
				}
				if (i.children.length > i.layout.length) {
					Array.from({ length: i.children.length - i.layout.length })
						.map((s, a) => a)
						.reverse()
						.forEach((s) => {
							const a = [...o, s + i.layout.length],
								l = i.children[s + i.layout.length];
							Dg(
								t,
								a,
								[
									...o,
									i.layout.length - 1,
									i.children[i.layout.length - 1].children
										.length,
								],
								(u) =>
									u.type !== "paragraph" ||
									pe.string(l) !== "",
							),
								W.removeNodes(t, { at: a });
						});
					return;
				}
			}
			e(r);
		}),
		t
	);
}
const xIe = /(^|\s)\[(.+?)\]\((\S+)\)$/;
function kIe(t, e, n) {
	const { insertText: r, isInline: i, normalizeNode: o } = n;
	return (
		(n.isInline = (s) => (s.type === "link" ? !0 : i(s))),
		t.links &&
			(n.insertText = (s) => {
				if ((r(s), s !== ")" || !n.selection)) return;
				const a = R.start(n, R.above(n, { match: Lt })[1]),
					l = R.string(n, { anchor: n.selection.anchor, focus: a }),
					u = xIe.exec(l);
				if (!u) return;
				const c = z0(n, t, e);
				if ((c == null ? void 0 : c.documentFeatures.links) === !1)
					return;
				const [, d, f, h] = u;
				n.history.undos.push({
					operations: [],
					selectionBefore: n.selection,
				});
				const p = u.index === 0 ? a : $m(n, a, { distance: u.index }),
					g = $m(n, p, { distance: d === "" ? 1 : 2 }),
					v = $m(n, g, { distance: f.length });
				W.delete(n, { at: { anchor: v, focus: n.selection.anchor } }),
					W.delete(n, { at: { anchor: p, focus: g } }),
					W.wrapNodes(
						n,
						{ type: "link", href: h, children: [] },
						{
							at: { anchor: n.selection.anchor, focus: p },
							split: !0,
						},
					);
				const b = R.next(n);
				b && W.select(n, b[1]);
			}),
		(n.normalizeNode = ([s, a]) => {
			if (s.type === "link") {
				if (pe.string(s) === "") {
					W.unwrapNodes(n, { at: a });
					return;
				}
				for (const [u, c] of s.children.entries())
					if (c.type === "link") {
						W.unwrapNodes(n, { at: [...a, u] });
						return;
					}
			}
			if (nxe(s)) {
				let u = null;
				for (const [c, d] of s.children.entries()) {
					var l;
					if (
						d.type === "link" &&
						d.href ===
							((l = u) === null || l === void 0
								? void 0
								: l.node.href)
					) {
						const f = [...a, u.index],
							h = [...a, c],
							p = [...f, u.node.children.length];
						for (let g = d.children.length - 1; g >= 0; g--) {
							const v = [...h, g];
							W.moveNodes(n, { at: v, to: p });
						}
						W.removeNodes(n, { at: h });
						return;
					}
					(!Be.isText(d) || d.text !== "") && (u = null),
						d.type === "link" && (u = { index: c, node: d });
				}
			}
			o([s, a]);
		}),
		n
	);
}
function CIe(t, e) {
	return PJ(oz(), t, e);
}
function PJ(t, e, n) {
	return wIe(
		vIe(kIe(e, n, BTe(OBe(fBe(n, e, EIe(yIe(bIe(e, n, Exe(e, t))))))))),
	);
}
function wIe(t) {
	const { normalizeNode: e } = t;
	return (
		(t.normalizeNode = ([n, r]) => {
			if (!Be.isText(n) && n.type !== "link") {
				const i = R.isEditor(n) ? "editor" : n.type;
				if (typeof i != "string" || rd[i] === void 0) {
					W.unwrapNodes(t, { at: r });
					return;
				}
				const o = rd[i];
				if (
					o.kind === "blocks" &&
					n.children.length !== 0 &&
					n.children.every((a) => !Lt(a))
				) {
					W.wrapNodes(
						t,
						{ type: o.blockToWrapInlinesIn, children: [] },
						{ at: r, match: (a) => !Lt(a) },
					);
					return;
				}
				let s = !1;
				for (const [a, l] of [...n.children.entries()].reverse()) {
					const u = [...r, a];
					if (o.kind === "inlines") {
						if (!Be.isText(l) && Lt(l)) {
							kE(t, [l, u], r), (s = !0);
							continue;
						}
					} else {
						if (!Lt(l)) {
							W.wrapNodes(
								t,
								{ type: o.blockToWrapInlinesIn, children: [] },
								{ at: u },
							),
								(s = !0);
							continue;
						}
						if (!o.allowedChildren.has(l.type)) {
							kE(t, [l, u], r), (s = !0);
							continue;
						}
					}
				}
				if (s) return;
			}
			e([n, r]);
		}),
		t
	);
}
function kE(t, [e, n], r) {
	const i = e.type,
		o = rd[i],
		s = pe.get(t, r),
		a = R.isEditor(s) ? "editor" : s.type,
		l = rd[a];
	if (!o || o.invalidPositionHandleMode === "unwrap") {
		if (l.kind === "blocks" && l.blockToWrapInlinesIn) {
			W.setNodes(
				t,
				{
					type: l.blockToWrapInlinesIn,
					...Object.fromEntries(
						Object.keys(e)
							.filter((c) => c !== "type" && c !== "children")
							.map((c) => [c, null]),
					),
				},
				{ at: n },
			);
			return;
		}
		W.unwrapNodes(t, { at: n });
		return;
	}
	const u = rd[s.type || "editor"];
	if (
		(u == null ? void 0 : u.kind) === "blocks" &&
		u.allowedChildren.has(i)
	) {
		r.length === 0
			? W.moveNodes(t, { at: n, to: [n[0] + 1] })
			: W.moveNodes(t, { at: n, to: Y.next(r) });
		return;
	}
	if (R.isEditor(s)) {
		W.moveNodes(t, { at: n, to: [n[0] + 1] }),
			W.unwrapNodes(t, { at: [n[0] + 1] });
		return;
	}
	kE(t, [e, n], r.slice(0, -1));
}
function EIe(t) {
	const { isVoid: e } = t;
	return (
		(t.isVoid = (n) => n.type === "divider" || n.type === "image" || e(n)),
		t
	);
}
function DIe(t, e, n) {
	const { insertText: r } = n,
		i = Object.create(null),
		o = { ...t };
	let s = (a, l, u, c = "paragraph") => {
		if (!u(o)) return;
		const d = a[a.length - 1];
		i[d] || (i[d] = Object.create(null)),
			(i[d][a] = {
				insert: l,
				type: c,
				shouldBeEnabledInComponentBlock: u,
			});
	};
	return (
		s(
			"1. ",
			() => {
				W.wrapNodes(
					n,
					{ type: "ordered-list", children: [] },
					{ match: Lt },
				);
			},
			(a) => a.formatting.listTypes.ordered,
		),
		s(
			"- ",
			() => {
				W.wrapNodes(
					n,
					{ type: "unordered-list", children: [] },
					{ match: Lt },
				);
			},
			(a) => a.formatting.listTypes.unordered,
		),
		s(
			"* ",
			() => {
				W.wrapNodes(
					n,
					{ type: "unordered-list", children: [] },
					{ match: Lt },
				);
			},
			(a) => a.formatting.listTypes.unordered,
		),
		t.formatting.headings.levels.forEach((a) => {
			s(
				"#".repeat(a) + " ",
				() => {
					W.setNodes(
						n,
						{ type: "heading", level: a },
						{
							match: (l) =>
								l.type === "paragraph" || l.type === "heading",
						},
					);
				},
				(l) => l.formatting.headings.levels.includes(a),
				"heading-or-paragraph",
			);
		}),
		s(
			"> ",
			() => {
				W.wrapNodes(
					n,
					{ type: "blockquote", children: [] },
					{ match: (a) => a.type === "paragraph" },
				);
			},
			(a) => a.formatting.blockTypes.blockquote,
		),
		s(
			"---",
			() => {
				DJ(n);
			},
			(a) => a.dividers,
		),
		(n.insertText = (a) => {
			r(a);
			const l = i[a];
			if (l && n.selection && ie.isCollapsed(n.selection)) {
				const { anchor: u } = n.selection,
					c = R.above(n, { match: Lt });
				if (
					!c ||
					(c[0].type !== "paragraph" && c[0].type !== "heading")
				)
					return;
				const d = R.start(n, c[1]),
					f = { anchor: u, focus: d },
					h = R.string(n, f),
					p = l[h];
				if (!p || (p.type === "paragraph" && c[0].type !== "paragraph"))
					return;
				const g = z0(n, t, e);
				if (
					g &&
					(g.kind === "inline" ||
						!p.shouldBeEnabledInComponentBlock(g.documentFeatures))
				)
					return;
				n.history.undos.push({
					operations: [],
					selectionBefore: n.selection,
				}),
					W.select(n, f),
					W.delete(n),
					p.insert();
			}
		}),
		n
	);
}
function KF(t) {
	if (!t.selection) return { isInside: !1 };
	const [, e] = R.parent(t, t.selection);
	if (!e.length) return { isInside: !1 };
	const [n, r] = R.parent(t, e);
	return n.type === "blockquote"
		? { isInside: !0, path: r }
		: { isInside: !1 };
}
function SIe(t) {
	const { insertBreak: e, deleteBackward: n } = t;
	return (
		(t.deleteBackward = (r) => {
			if (
				t.selection &&
				KF(t).isInside &&
				ie.isCollapsed(t.selection) &&
				t.selection.anchor.offset === 0 &&
				t.selection.anchor.path[t.selection.anchor.path.length - 2] ===
					0
			) {
				W.unwrapNodes(t, {
					match: (o) => o.type === "blockquote",
					split: !0,
				});
				return;
			}
			n(r);
		}),
		(t.insertBreak = () => {
			const r = KF(t);
			if (t.selection && r.isInside) {
				const [i, o] = R.node(t, t.selection);
				if (Y.isDescendant(o, r.path) && pe.string(i) === "") {
					W.unwrapNodes(t, {
						match: (s) => s.type === "blockquote",
						split: !0,
					});
					return;
				}
			}
			e();
		}),
		t
	);
}
function AIe(t) {
	const { insertBreak: e } = t;
	return (
		(t.insertBreak = () => {
			e();
			const n = R.above(t, { match: (s) => s.type === "heading" });
			if (!n || !t.selection || !ie.isCollapsed(t.selection)) return;
			const r = n[1];
			if (ut.equals(R.end(t, r), t.selection.anchor)) {
				W.unwrapNodes(t, { at: r });
				return;
			}
			if (!Y.hasPrevious(r)) return;
			const i = Y.previous(r),
				o = pe.get(t, i);
			o.type === "heading" &&
				o.children.length === 1 &&
				Be.isText(o.children[0]) &&
				o.children[0].text === "" &&
				W.unwrapNodes(t, { at: i });
		}),
		t
	);
}
const UF = {
	bold: ["**", "__"],
	italic: ["*", "_"],
	strikethrough: ["~~"],
	code: ["`"],
};
function $Ie(t, e, n, r) {
	t.history.undos.push({ operations: [], selectionBefore: t.selection });
	const i = R.pointRef(t, r);
	W.delete(t, { at: t.selection.anchor, distance: n.length, reverse: !0 }),
		W.delete(t, { at: r, distance: n.length }),
		W.setNodes(
			t,
			{ [e]: !0 },
			{
				match: Be.isText,
				split: !0,
				at: { anchor: i.unref(), focus: t.selection.anchor },
			},
		),
		t.removeMark(e);
}
function TIe(t, e, n) {
	const { insertText: r, insertBreak: i } = n;
	n.insertBreak = () => {
		i();
		const a = R.marks(n);
		if (!a || !n.selection) return;
		const l = R.above(n, { match: Lt });
		if (!l) return;
		const u = $m(n, n.selection.anchor),
			c = Object.keys(a);
		if (!u || !Y.isDescendant(u.path, l[1])) {
			for (const f of c) n.removeMark(f);
			return;
		}
		const d = pe.get(n, u.path);
		for (const f of c) d[f] || n.removeMark(f);
	};
	const o = {},
		s = t.formatting.inlineMarks;
	return (
		Object.keys(UF).forEach((a) => {
			s[a] && (o[a] = UF[a]);
		}),
		Object.keys(o).length === 0 ||
			(n.insertText = (a) => {
				if ((r(a), n.selection && ie.isCollapsed(n.selection))) {
					for (const [l, u] of Object.entries(o))
						for (const c of u)
							if (a === c[c.length - 1]) {
								const d = BIe(n);
								let f = R.string(n, {
									anchor: n.selection.anchor,
									focus: d,
								});
								const h = /\s/.test(
										f.slice(-c.length - 1, -c.length),
									),
									p = c === f.slice(-c.length);
								if (h || !p) continue;
								const g = f.slice(0, -c.length - 1);
								for (const [v] of [...g].reverse().entries()) {
									if (g.slice(v, v + c.length) !== c)
										continue;
									const y =
											v === 0
												? d
												: $m(n, d, { distance: v }),
										x = R.after(n, y, {
											distance: c.length,
										});
									if (
										v !== 0 &&
										!/\s/.test(
											R.string(n, {
												anchor: R.before(n, y, {
													unit: "character",
												}),
												focus: y,
											}),
										)
									)
										continue;
									const C = R.string(n, {
										anchor: x,
										focus: n.selection.anchor,
									}).slice(0, -c.length);
									if (
										C === "" ||
										/\s/.test(C[0]) ||
										(l === "italic" &&
											(C[0] === "_" || C[0] === "*")) ||
										(l === "code" && C === "`")
									)
										continue;
									const k = z0(n, t, e);
									if (
										!(
											k &&
											k.inlineMarks !== "inherit" &&
											k.inlineMarks[l] === !1
										)
									) {
										$Ie(n, l, c, y);
										return;
									}
								}
							}
				}
			}),
		n
	);
}
function BIe(t) {
	return R.start(t, R.above(t, { match: Lt })[1]);
}
const ud = new Set(),
	Ub = new Set();
let Rm = null;
function $o(t, e) {
	const n = ud.has(t);
	ud.add(t);
	try {
		return e();
	} finally {
		n || ud.delete(t);
	}
}
function pA(t, e) {
	if (Rm !== null) return e();
	Rm = t;
	try {
		return e();
	} finally {
		Rm = null;
	}
}
function HF(t, e) {
	const n = new Set();
	for (const r of t) ud.has(r) || n.add(r), ud.add(r);
	try {
		return e();
	} finally {
		for (const r of n) ud.delete(r);
	}
}
function IIe(t, e) {
	const n = Ub.has(t);
	Ub.add(t);
	try {
		return e();
	} finally {
		n || Ub.delete(t);
	}
}
function Cs(t) {
	const e = { text: t };
	for (const n of ud) Ub.has(n) || (e[n] = !0);
	return Rm !== null
		? [
				{ text: "" },
				{ type: "link", href: Rm, children: [e] },
				{ text: "" },
			]
		: [e];
}
function WF(t) {
	const e = t.parentElement,
		n = e == null ? void 0 : e.getAttribute("data-align");
	if (n === "center" || n === "end") return n;
	if (t instanceof HTMLElement) {
		const r = t.style.textAlign;
		if (r === "center") return "center";
		if (r === "right" || r === "end") return "end";
	}
}
const FIe = { H1: 1, H2: 2, H3: 3, H4: 4, H5: 5, H6: 6 },
	PIe = {
		CODE: "code",
		DEL: "strikethrough",
		S: "strikethrough",
		STRIKE: "strikethrough",
		EM: "italic",
		I: "italic",
		STRONG: "bold",
		U: "underline",
		SUP: "superscript",
		SUB: "subscript",
		KBD: "keyboard",
	};
function NIe(t) {
	const e = new Set(),
		n = t.style,
		{ nodeName: r } = t,
		i = PIe[r];
	i && e.add(i);
	const { fontWeight: o, textDecoration: s, verticalAlign: a } = n;
	return (
		s === "underline"
			? e.add("underline")
			: s === "line-through" && e.add("strikethrough"),
		r === "SPAN" && t.classList.contains("code") && e.add("code"),
		((r === "B" && o !== "normal") ||
			(typeof o == "string" &&
				(o === "bold" ||
					o === "bolder" ||
					o === "1000" ||
					/^[5-9]\d{2}$/.test(o)))) &&
			e.add("bold"),
		n.fontStyle === "italic" && e.add("italic"),
		a === "super"
			? e.add("superscript")
			: a === "sub" && e.add("subscript"),
		e
	);
}
function RIe(t) {
	const e = new DOMParser().parseFromString(t, "text/html");
	return CE(Hb(e.body.childNodes));
}
function OIe(t) {
	if (!(t instanceof globalThis.HTMLElement)) {
		const n = t.textContent;
		return n ? Cs(n) : [];
	}
	if (t.nodeName === "BR")
		return Cs(`
`);
	if (t.nodeName === "IMG") {
		const n = t.getAttribute("alt");
		return Cs(n ?? "");
	}
	if (t.nodeName === "HR")
		return [{ type: "divider", children: [{ text: "" }] }];
	const e = NIe(t);
	return t.classList.contains("listtype-quote")
		? (e.delete("italic"),
			HF(e, () => [
				{ type: "blockquote", children: CE(Hb(t.childNodes)) },
			]))
		: HF(e, () => {
				const { nodeName: n } = t;
				if (n === "A") {
					const s = t.getAttribute("href");
					if (s)
						return pA(s, () =>
							IIe("underline", () => Hb(t.childNodes)),
						);
				}
				if (n === "PRE" && t.textContent)
					return [
						{
							type: "code",
							children: [{ text: t.textContent || "" }],
						},
					];
				const r = Hb(t.childNodes),
					i = CE(r);
				if (n === "LI") {
					let s;
					const a = {
						type: "list-item-content",
						children: i.filter((u) =>
							s === void 0 &&
							(u.type === "ordered-list" ||
								u.type === "unordered-list")
								? ((s = u), !1)
								: !0,
						),
					};
					return [{ type: "list-item", children: s ? [a, s] : [a] }];
				}
				if (n === "P")
					return [
						{ type: "paragraph", textAlign: WF(t), children: i },
					];
				const o = FIe[n];
				return typeof o == "number"
					? [
							{
								type: "heading",
								level: o,
								textAlign: WF(t),
								children: i,
							},
						]
					: n === "BLOCKQUOTE"
						? [{ type: "blockquote", children: i }]
						: n === "OL"
							? [{ type: "ordered-list", children: i }]
							: n === "UL"
								? [{ type: "unordered-list", children: i }]
								: n === "DIV" && !Lt(i[0])
									? [{ type: "paragraph", children: i }]
									: r;
			});
}
function Hb(t) {
	const e = [];
	for (const n of t) e.push(...OIe(n));
	return e;
}
function CE(t) {
	if (!t.length) return [{ text: "" }];
	if (t.some(Lt)) {
		const e = [];
		let n = [];
		const r = () => {
			n.length && (e.push({ type: "paragraph", children: n }), (n = []));
		};
		for (const i of t) {
			if (Lt(i)) {
				r(), e.push(i);
				continue;
			}
			pe.string(i).trim() !== "" && n.push(i);
		}
		return r(), e;
	}
	return t;
}
const MIe = { mdastExtensions: [fG(), wG()], extensions: [yG(), DG()] };
function qF(t) {
	let n = lG(t, MIe).children;
	return (
		n.length === 1 && n[0].type === "paragraph" && (n = n[0].children),
		Ws(n, t)
	);
}
function Ws(t, e) {
	const n = [];
	for (const r of t) {
		const i = jIe(r, e);
		i.length && n.push(...i);
	}
	return n.length || n.push({ text: "" }), n;
}
function jIe(t, e) {
	switch (t.type) {
		case "blockquote":
			return [{ type: "blockquote", children: Ws(t.children, e) }];
		case "link":
			return pA(t.url, () => Ws(t.children, e));
		case "code":
			return [{ type: "code", children: [{ text: t.value }] }];
		case "paragraph":
			return [{ type: "paragraph", children: Ws(t.children, e) }];
		case "heading":
			return [
				{
					type: "heading",
					level: t.depth,
					children: Ws(t.children, e),
				},
			];
		case "list":
			return [
				{
					type: t.ordered ? "ordered-list" : "unordered-list",
					children: Ws(t.children, e),
				},
			];
		case "listItem":
			return [{ type: "list-item", children: Ws(t.children, e) }];
		case "thematicBreak":
			return [{ type: "divider", children: [{ text: "" }] }];
		case "break":
			return Cs(`
`);
		case "delete":
			return $o("strikethrough", () => Ws(t.children, e));
		case "strong":
			return $o("bold", () => Ws(t.children, e));
		case "emphasis":
			return $o("italic", () => Ws(t.children, e));
		case "inlineCode":
			return $o("code", () => Cs(t.value));
		case "text":
			return Cs(t.value);
	}
	return Cs(e.slice(t.position.start.offset, t.position.end.offset));
}
const _Ie = /https?:\/\//;
function FC(t, e) {
	Lt(e[0]) ? To(t, e) : W.insertFragment(t, e);
}
const NJ = "x-keystatic-fragment",
	zIe = (t) => (t && t.ownerDocument && t.ownerDocument.defaultView) || null,
	RJ = (t) => {
		const e = zIe(t);
		return !!e && t instanceof e.Node;
	},
	OJ = (t) => RJ(t) && t.nodeType === 3,
	LIe = (t) => RJ(t) && t.nodeType === 1,
	MJ = (t) => {
		let e = "";
		if (OJ(t) && t.nodeValue) return t.nodeValue;
		if (LIe(t)) {
			for (const r of Array.from(t.childNodes)) e += MJ(r);
			const n = getComputedStyle(t).getPropertyValue("display");
			(n === "block" || n === "list" || t.tagName === "BR") &&
				(e += `
`);
		}
		return e;
	};
function VIe(t, e) {
	const { selection: n } = t;
	if (!n) return;
	const [r, i] = ie.edges(n),
		o = R.void(t, { at: r.path }),
		s = R.void(t, { at: i.path });
	if (ie.isCollapsed(n) && !o) return;
	const a = te.toDOMRange(t, n);
	let l = a.cloneContents(),
		u = l.childNodes[0];
	if (
		(l.childNodes.forEach((p) => {
			p.textContent && p.textContent.trim() !== "" && (u = p);
		}),
		s)
	) {
		const [p] = s,
			g = a.cloneRange(),
			v = te.toDOMNode(t, p);
		g.setEndAfter(v), (l = g.cloneContents());
	}
	if (
		(o && (u = l.querySelector("[data-slate-spacer]")),
		Array.from(l.querySelectorAll("[data-slate-zero-width]")).forEach(
			(p) => {
				const g = p.getAttribute("data-slate-zero-width") === "n";
				p.textContent = g
					? `
`
					: "";
			},
		),
		OJ(u))
	) {
		const p = u.ownerDocument.createElement("span");
		(p.style.whiteSpace = "pre"),
			p.appendChild(u),
			l.appendChild(p),
			(u = p);
	}
	const c = t.getFragment(),
		d = JSON.stringify(c, (p, g) =>
			g instanceof Uint8Array ? { [Wb]: nd(g) } : g,
		),
		f = window.btoa(encodeURIComponent(d));
	u.setAttribute("data-keystatic-fragment", f),
		e.setData(`application/${NJ}`, f);
	const h = l.ownerDocument.createElement("div");
	h.appendChild(l),
		h.setAttribute("hidden", "true"),
		l.ownerDocument.body.appendChild(h),
		e.setData("text/html", h.innerHTML),
		e.setData("text/plain", MJ(h)),
		l.ownerDocument.body.removeChild(h);
}
const KIe = /data-keystatic-fragment="(.+?)"/m,
	UIe = (t) => {
		const e = t.getData("text/html"),
			[, n] = e.match(KIe) || [];
		return n;
	},
	Wb = "$$keystaticUint8Array$$";
function HIe(t) {
	const { insertTextData: e } = t;
	return (
		(t.setFragmentData = (n) => {
			VIe(t, n);
		}),
		(t.insertFragmentData = (n) => {
			const r = n.getData(`application/${NJ}`) || UIe(n);
			if (r) {
				const i = decodeURIComponent(window.atob(r)),
					o = JSON.parse(i, (s, a) =>
						typeof a == "object" &&
						a !== null &&
						Wb in a &&
						typeof a[Wb] == "string"
							? h3(a[Wb])
							: a,
					);
				return t.insertFragment(o), !0;
			}
			return !1;
		}),
		(t.insertTextData = (n) => {
			const r = R.above(t, { match: Lt });
			if ((r == null ? void 0 : r[0].type) === "code") {
				const a = n.getData("text/plain");
				return t.insertText(a), !0;
			}
			let i = n.getData("vscode-editor-data");
			if (i)
				try {
					const a = JSON.parse(i);
					if (
						(a == null ? void 0 : a.mode) === "markdown" ||
						(a == null ? void 0 : a.mode) === "mdx"
					) {
						const l = n.getData("text/plain");
						if (l) {
							const u = qF(l);
							return FC(t, u), !0;
						}
					}
				} catch (a) {
					console.log(a);
				}
			const o = n.getData("text/plain");
			if (
				_Ie.test(o) &&
				X0(o) &&
				t.selection &&
				!ie.isCollapsed(t.selection) &&
				R.above(t, { match: (a) => Lt(a) && !Lt(a.children[0]) }) &&
				R.nodes(t, { match: (a) => a.type === "link" }).next().done
			)
				return (
					W.wrapNodes(
						t,
						{ type: "link", href: o, children: [] },
						{ split: !0 },
					),
					!0
				);
			const s = n.getData("text/html");
			if (s) {
				const a = RIe(s);
				return FC(t, a), !0;
			}
			if (o) {
				const a = qF(o);
				return FC(t, a), !0;
			}
			return e(n);
		}),
		t
	);
}
const GF = {
	"...": "…",
	"-->": "→",
	"->": "→",
	"<-": "←",
	"<--": "←",
	"--": "–",
};
function WIe(t) {
	const { insertText: e } = t;
	return (
		(t.insertText = (n) => {
			if (
				(e(n), n === " " && t.selection && ie.isCollapsed(t.selection))
			) {
				const r = t.selection.anchor,
					i = R.above(t, { match: Lt });
				i &&
					Object.keys(GF).forEach((o) => {
						const s = R.before(t, r, {
							unit: "character",
							distance: o.length + 1,
						});
						if (s && Y.isDescendant(s.path, i[1])) {
							const a = { anchor: r, focus: s };
							R.string(t, a).slice(0, o.length) === o &&
								(t.history.undos.push({
									operations: [],
									selectionBefore: t.selection,
								}),
								W.select(t, a),
								t.insertText(GF[o] + " "));
						}
					});
			}
		}),
		t
	);
}
function qIe(t) {
	return (
		(t.insertSoftBreak = () => {
			W.insertText(
				t,
				`
`,
			);
		}),
		t
	);
}
const PC = { "mod+b": "bold", "mod+i": "italic", "mod+u": "underline" };
function GIe(t, e) {
	const n = R.marks(t);
	if (n != null && n[e]) return !0;
	for (const r of R.nodes(t, { match: Be.isText })) if (r[0][e]) return !0;
	return !1;
}
const YIe = new Map([
		["ArrowUp", "up"],
		["ArrowDown", "down"],
		["ArrowLeft", "left"],
		["ArrowRight", "right"],
	]),
	JIe = (t, e) => (n) => {
		if (n.defaultPrevented) return;
		for (const a in PC)
			if (e.formatting.inlineMarks[PC[a]] && jf(a, n.nativeEvent)) {
				n.preventDefault();
				const l = PC[a];
				GIe(t, l) ? R.removeMark(t, l) : R.addMark(t, l, !0);
				return;
			}
		if (jf("mod+\\", n.nativeEvent)) {
			kH(t);
			return;
		}
		if (e.links && jf("mod+k", n.nativeEvent)) {
			n.preventDefault(), vJ(t, "");
			return;
		}
		if (n.key === "Tab" && (n.shiftKey ? ABe(t) : SBe(t))) {
			n.preventDefault();
			return;
		}
		if (n.key === "Tab" && t.selection) {
			const a = R.above(t, {
				match: (l) =>
					l.type === "layout-area" || l.type === "table-cell",
			});
			if (a) {
				const l = n.shiftKey
					? R.before(t, a[1], { unit: "block" })
					: R.after(t, a[1], { unit: "block" });
				W.setSelection(t, { anchor: l, focus: l }), n.preventDefault();
			}
		}
		if (jf("mod+a", n)) {
			const a = R.above(t, { match: mr("table") });
			if (a) {
				W.select(t, a[1]), n.preventDefault();
				return;
			}
		}
		const r = YIe.get(n.key),
			{ selection: i } = t;
		if (r && i) {
			const a = Nm(t);
			if (a) {
				var o, s;
				const l =
						(o = R.above(t, {
							match: mr("table-cell"),
							at: i.focus.path,
						})) === null || o === void 0
							? void 0
							: o[1],
					u =
						(s = R.above(t, {
							match: mr("table-cell"),
							at: i.anchor.path,
						})) === null || s === void 0
							? void 0
							: s[1];
				if (!l || !u) return;
				const c = YBe(t, l, r);
				if (c) {
					if (a.singleCell === "not-selected") {
						if (r !== "up" && r !== "down") return;
						const [d, f] = te.toDOMPoint(t, i.focus),
							h = R.above(t, { match: Lt, at: i.focus.path });
						if (
							!h ||
							(r === "up" &&
								h[1].slice(l.length).some((w) => w !== 0))
						)
							return;
						if (r === "down") {
							const [w] = R.parent(t, h[1]);
							if (w.children.length - 1 !== h[1][h[1].length - 1])
								return;
							for (const [D, S] of pe.ancestors(t, h[1], {
								reverse: !0,
							})) {
								if (D.type === "table-cell") break;
								const [$] = R.parent(t, S);
								if ($.children.length - 1 !== S[S.length - 1])
									return;
							}
						}
						const p = te.toDOMNode(t, h[0]),
							g = document.createRange();
						g.selectNodeContents(p);
						const v = Array.from(g.getClientRects()),
							b = document.createRange();
						b.setStart(d, f), b.setEnd(d, f);
						const y = Array.from(b.getClientRects()),
							x = y[y.length - 1],
							C = r === "up" ? "top" : "bottom",
							k =
								C === "top"
									? Math.min(...v.map((w) => w.top))
									: Math.max(...v.map((w) => w.bottom));
						if (x[C] === k) {
							const w = R[r === "up" ? "end" : "start"](t, c);
							W.select(t, {
								focus: w,
								anchor: n.shiftKey ? i.anchor : w,
							}),
								n.preventDefault();
						}
						return;
					}
					if (!n.shiftKey) return;
					Y.equals(c, u)
						? W.select(t, c)
						: W.select(t, {
								anchor: i.anchor,
								focus: R.start(t, c),
							}),
						n.preventDefault();
				}
			}
		}
	};
function XIe(t, e) {
	return HIe(
		RBe(
			qIe(
				dIe(
					WIe(
						AIe(
							SIe(TIe(t, e, DIe(t, e, PJ(v2e(Wpe(oz())), t, e)))),
						),
					),
				),
			),
		),
	);
}
function jJ(t) {
	const e = ee(31);
	let n, r, i, o, s;
	e[0] !== t
		? (({
				onChange: i,
				value: s,
				componentBlocks: r,
				documentFeatures: n,
				...o
			} = t),
			(e[0] = t),
			(e[1] = n),
			(e[2] = r),
			(e[3] = i),
			(e[4] = o),
			(e[5] = s))
		: ((n = e[1]), (r = e[2]), (i = e[3]), (o = e[4]), (s = e[5]));
	const a = xo();
	let l, u;
	e[6] !== n || e[7] !== r
		? ((u = XIe(n, r)), (e[6] = n), (e[7] = r), (e[8] = u))
		: (u = e[8]),
		(l = u);
	const c = l;
	let d;
	e[9] === Symbol.for("react.memo_cache_sentinel")
		? ((d = Se(
				X({
					backgroundColor: B.color.background.canvas,
					minWidth: 0,
					'&[data-layout="main"]': {
						flex: 1,
						display: "flex",
						flexDirection: "column",
					},
					'&:not([data-layout="main"])': {
						border: `${B.size.border.regular} solid ${B.color.border.neutral}`,
						borderRadius: B.size.radius.medium,
					},
				}),
				"keystar-document-editor",
			)),
			(e[9] = d))
		: (d = e[9]);
	let f;
	e[10] !== i || e[11] !== c
		? ((f = (C) => {
				var k;
				(k = i) === null || k === void 0 || k(C);
				const w = window.getSelection();
				if (w && !te.isFocused(c)) {
					const D = te.toDOMNode(c, c);
					w.anchorNode === D && te.focus(c);
				}
			}),
			(e[10] = i),
			(e[11] = c),
			(e[12] = f))
		: (f = e[12]);
	let h, p;
	e[13] !== i || e[14] !== n
		? ((p = i !== void 0 && m.jsx(JBe, { documentFeatures: n })),
			(e[13] = i),
			(e[14] = n),
			(e[15] = p))
		: (p = e[15]),
		(h = p);
	const g = i === void 0;
	let v;
	e[16] !== o || e[17] !== g
		? ((v = m.jsx(e7e, { ...o, readOnly: g })),
			(e[16] = o),
			(e[17] = g),
			(e[18] = v))
		: (v = e[18]);
	let b;
	e[19] === Symbol.for("react.memo_cache_sentinel")
		? ((b = !1), (e[19] = b))
		: (b = e[19]);
	let y;
	e[20] !== r ||
	e[21] !== n ||
	e[22] !== c ||
	e[23] !== s ||
	e[24] !== f ||
	e[25] !== h ||
	e[26] !== v
		? ((y = m.jsxs(QIe, {
				componentBlocks: r,
				documentFeatures: n,
				editor: c,
				value: s,
				onChange: f,
				children: [h, v, b],
			})),
			(e[20] = r),
			(e[21] = n),
			(e[22] = c),
			(e[23] = s),
			(e[24] = f),
			(e[25] = h),
			(e[26] = v),
			(e[27] = y))
		: (y = e[27]);
	let x;
	return (
		e[28] !== a || e[29] !== y
			? ((x = m.jsx("div", {
					"data-layout": a,
					className: d,
					children: y,
				})),
				(e[28] = a),
				(e[29] = y),
				(e[30] = x))
			: (x = e[30]),
		x
	);
}
const _J = E.createContext(!1);
function zJ() {
	return E.useContext(_J);
}
function ZIe(t) {
	return Math.random().toString(36);
}
function QIe(t) {
	const e = ee(15),
		{
			children: n,
			editor: r,
			onChange: i,
			value: o,
			componentBlocks: s,
			documentFeatures: a,
		} = t;
	let l, u;
	e[0] !== r ? ((u = ZIe()), (e[0] = r), (e[1] = u)) : (u = e[1]), (l = u);
	const c = l;
	let d;
	e[2] !== i || e[3] !== r
		? ((d = (p) => {
				i(p);
				const g = window.getSelection();
				if (g && !te.isFocused(r)) {
					const v = te.toDOMNode(r, r);
					g.anchorNode === v && te.focus(r);
				}
			}),
			(e[2] = i),
			(e[3] = r),
			(e[4] = d))
		: (d = e[4]);
	let f;
	e[5] !== s || e[6] !== a || e[7] !== n
		? ((f = m.jsx(jBe, {
				children: m.jsx(PTe, {
					componentBlocks: s,
					editorDocumentFeatures: a,
					children: n,
				}),
			})),
			(e[5] = s),
			(e[6] = a),
			(e[7] = n),
			(e[8] = f))
		: (f = e[8]);
	let h;
	return (
		e[9] !== c || e[10] !== r || e[11] !== o || e[12] !== d || e[13] !== f
			? ((h = m.jsx(_J.Provider, {
					value: !0,
					children: m.jsx(
						Upe,
						{ editor: r, value: o, onChange: d, children: f },
						c,
					),
				})),
				(e[9] = c),
				(e[10] = r),
				(e[11] = o),
				(e[12] = d),
				(e[13] = f),
				(e[14] = h))
			: (h = e[14]),
		h
	);
}
function wE(t) {
	return typeof t == "string"
		? t.length
		: Array.isArray(t.content)
			? t.content.reduce((e, n) => e + wE(n), 0)
			: wE(t.content);
}
function e7e(t) {
	const e = g5(),
		n = xo(),
		r = Gx(),
		{ componentBlocks: i, documentFeatures: o } = Ls(),
		s = E.useMemo(() => JIe(r, o), [r, o]);
	return m.jsx(lxe, {
		editor: r,
		children: m.jsx(rre, {
			size: n === "main" ? "medium" : "regular",
			children: m.jsx(Rpe, {
				placeholder: 'Start writing or press "/" for commands...',
				decorate: E.useCallback(
					([a, l]) => {
						let u = [];
						if (a.type === "component-block") {
							if (
								a.children.length === 1 &&
								$e.isElement(a.children[0]) &&
								a.children[0].type ===
									"component-inline-prop" &&
								a.children[0].propPath === void 0
							)
								return u;
							a.children.forEach((c, d) => {
								if (
									pe.string(c) === "" &&
									$e.isElement(c) &&
									(c.type === "component-block-prop" ||
										c.type === "component-inline-prop") &&
									c.propPath !== void 0
								) {
									const f = R.start(r, [...l, d]),
										h = sxe(
											c.propPath,
											i[a.component].schema,
											a.props,
										);
									h &&
										u.push({
											placeholder: h,
											anchor: f,
											focus: f,
										});
								}
							});
						}
						if (
							a.type === "code" &&
							a.children.length === 1 &&
							a.children[0].type === void 0 &&
							a.language &&
							a.language in Q.languages
						) {
							let f = function (h, p) {
								for (const g of p) {
									const v = wE(g),
										b = h + v;
									typeof g != "string" &&
										(u.push({
											["prism_" + g.type]: !0,
											anchor: { path: c, offset: h },
											focus: { path: c, offset: b },
										}),
										f(
											h,
											Array.isArray(g.content)
												? g.content
												: [g.content],
										)),
										(h = b);
								}
							};
							const c = [...l, 0],
								d = Q.tokenize(
									a.children[0].text,
									Q.languages[a.language],
								);
							f(0, d);
						}
						return u;
					},
					[r, i],
				),
				onKeyDown: s,
				renderElement: lIe,
				renderLeaf: pIe,
				...t,
				...lt({ container: e, layout: n }),
				className: Se(n7e, t.className),
			}),
		}),
	});
}
let t7e = {
	flex: 1,
	height: "auto",
	minHeight: B.size.scale[2e3],
	minWidth: 0,
	padding: B.size.space.medium,
	'&[data-layout="main"]': {
		boxSizing: "border-box",
		height: "100%",
		padding: 0,
		paddingTop: B.size.space.medium,
		minHeight: 0,
		minWidth: 0,
		maxWidth: 800,
		marginInline: "auto",
		[en.above.mobile]: { padding: B.size.space.xlarge },
		[en.above.tablet]: { padding: B.size.space.xxlarge },
		'&[data-container="wide"]': { padding: B.size.scale[600] },
	},
};
const n7e = X({ ...t7e, a: { color: B.color.foreground.accent } }),
	r7e = {};
let i7e = 0;
function YF() {
	return i7e++;
}
function o7e(t) {
	const e = ee(14),
		n = Ls();
	let r;
	e[0] !== t.value
		? ((r = () => ({ key: YF(), value: t.value })),
			(e[0] = t.value),
			(e[1] = r))
		: (r = e[1]);
	const [i, o] = E.useState(r);
	let s, a;
	e[2] !== n.documentFeatures || e[3] !== t.schema.options
		? ((a = ixe(n.documentFeatures, t.schema.options)),
			(e[2] = n.documentFeatures),
			(e[3] = t.schema.options),
			(e[4] = a))
		: (a = e[4]),
		(s = a);
	const l = s;
	i.value !== t.value && o({ key: YF(), value: t.value });
	let u;
	e[5] !== i.key ||
	e[6] !== i.value ||
	e[7] !== t ||
	e[8] !== n.componentBlocks ||
	e[9] !== l
		? ((u = (d) =>
				E.createElement(jJ, {
					...d,
					key: i.key,
					componentBlocks:
						t.schema.options.componentBlocks === "inherit"
							? n.componentBlocks
							: r7e,
					documentFeatures: l,
					onChange: (f) => {
						o((h) => ({ key: h.key, value: f })), t.onChange(f);
					},
					value: i.value,
				})),
			(e[5] = i.key),
			(e[6] = i.value),
			(e[7] = t),
			(e[8] = n.componentBlocks),
			(e[9] = l),
			(e[10] = u))
		: (u = e[10]);
	let c;
	return (
		e[11] !== t.schema.options.label || e[12] !== u
			? ((c = m.jsx(OTe, {
					children: m.jsx(bD, {
						label: t.schema.options.label,
						children: u,
					}),
				})),
				(e[11] = t.schema.options.label),
				(e[12] = u),
				(e[13] = c))
			: (c = e[13]),
		c
	);
}
function s7e(t) {
	const e = ee(5);
	let n;
	e[0] !== t ? ((n = uA(t)), (e[0] = t), (e[1] = n)) : (n = e[1]);
	const r = n;
	if (
		t.schema.options.kind === "block" &&
		(t.schema.options.editIn === "both" ||
			t.schema.options.editIn === "modal") &&
		r.value
	) {
		const i = t.schema;
		let o;
		return (
			e[2] !== i || e[3] !== r
				? ((o = m.jsx(o7e, { schema: i, ...r })),
					(e[2] = i),
					(e[3] = r),
					(e[4] = o))
				: (o = e[4]),
			o
		);
	}
	return null;
}
function LJ(t) {
	if (t.kind === "object") {
		var e;
		return (e = t.Input) !== null && e !== void 0 ? e : gTe;
	}
	if (t.kind === "conditional") {
		var n;
		return (n = t.Input) !== null && n !== void 0 ? n : yTe;
	}
	if (t.kind === "array") {
		var r;
		return (r = t.Input) !== null && r !== void 0 ? r : ETe;
	}
	return t.kind === "child" ? s7e : t.Input;
}
const Uy = E.memo(function (e) {
		var n;
		const r = ee(7);
		if (
			((n = e.omitFieldAtPath) === null || n === void 0
				? void 0
				: n.length) === 0
		)
			return null;
		let i;
		r[0] !== e.schema
			? ((i = LJ(e.schema)), (r[0] = e.schema), (r[1] = i))
			: (i = r[1]);
		const o = i,
			s = e,
			a = !!e.autoFocus,
			l = !!e.forceValidation;
		let u;
		return (
			r[2] !== o || r[3] !== s || r[4] !== a || r[5] !== l
				? ((u = m.jsx(o, { ...s, autoFocus: a, forceValidation: l })),
					(r[2] = o),
					(r[3] = s),
					(r[4] = a),
					(r[5] = l),
					(r[6] = u))
				: (u = r[6]),
			u
		);
	}),
	a7e = [],
	Ia = E.memo(function (e) {
		const n = ee(13);
		let r, i;
		n[0] !== e
			? (({ slugField: i, ...r } = e), (n[0] = e), (n[1] = r), (n[2] = i))
			: ((r = n[1]), (i = n[2]));
		let o;
		n[3] !== r.schema
			? ((o = LJ(r.schema)), (n[3] = r.schema), (n[4] = o))
			: (o = n[4]);
		const s = o,
			a = r,
			l = !!r.autoFocus,
			u = !!r.forceValidation;
		let c;
		n[5] !== s || n[6] !== a || n[7] !== l || n[8] !== u
			? ((c = m.jsx(s, { ...a, autoFocus: l, forceValidation: u })),
				(n[5] = s),
				(n[6] = a),
				(n[7] = l),
				(n[8] = u),
				(n[9] = c))
			: (c = n[9]);
		let d;
		return (
			n[10] !== i || n[11] !== c
				? ((d = m.jsx(IH, {
						value: a7e,
						children: m.jsx(BH, { value: i, children: c }),
					})),
					(n[10] = i),
					(n[11] = c),
					(n[12] = d))
				: (d = n[12]),
			d
		);
	});
class EE extends Error {
	constructor() {
		super("There are a variable number of child fields");
	}
}
function VJ(t) {
	try {
		const e = DE(t, [], new Set());
		return e.length === 1 ? e[0] : void 0;
	} catch (e) {
		if (e instanceof EE) return;
		throw e;
	}
}
function DE(t, e, n) {
	if (n.has(t)) return [];
	switch ((n.add(t), t.kind)) {
		case "form":
			return [];
		case "child":
			return [{ relativePath: e, options: t.options, kind: "child" }];
		case "conditional": {
			if (Om(t)) throw new EE();
			return [];
		}
		case "array": {
			if (t.asChildTag) {
				const r = DE(t.element, [], n);
				return r.length > 1
					? []
					: [
							{
								kind: "array",
								asChildTag: t.asChildTag,
								field: t,
								relativePath: e,
								child: r[0],
							},
						];
			}
			if (Om(t)) throw new EE();
			return [];
		}
		case "object": {
			const r = [];
			for (const [i, o] of Object.entries(t.fields))
				r.push(...DE(o, e.concat(i), n));
			return r;
		}
	}
}
function Om(t, e = new Set()) {
	if (e.has(t)) return !1;
	switch ((e.add(t), t.kind)) {
		case "form":
			return !1;
		case "child":
			return !0;
		case "conditional":
			return Object.values(t.values).some((n) => Om(n, e));
		case "object":
			return Object.keys(t.fields).some((n) => Om(t.fields[n], e));
		case "array":
			return Om(t.element, e);
	}
}
function mA(t) {
	if (t.type === "inline") return Ua(t.children);
	if (t.type === "link") return pA(t.attributes.href, () => Ua(t.children));
	if (t.type === "text") return Cs(t.attributes.content);
	if (t.type === "strong") return $o("bold", () => Ua(t.children));
	if (t.type === "code") return $o("code", () => Cs(t.attributes.content));
	if (t.type === "em") return $o("italic", () => Ua(t.children));
	if (t.type === "s") return $o("strikethrough", () => Ua(t.children));
	if (t.type === "tag") {
		if (t.tag === "u") return $o("underline", () => Ua(t.children));
		if (t.tag === "kbd") return $o("keyboard", () => Ua(t.children));
		if (t.tag === "sub") return $o("subscript", () => Ua(t.children));
		if (t.tag === "sup") return $o("superscript", () => Ua(t.children));
	}
	if (t.type === "softbreak") return Cs(" ");
	if (t.type === "hardbreak")
		return Cs(`
`);
	if (
		t.tag === "component-inline-prop" &&
		Array.isArray(t.attributes.propPath) &&
		t.attributes.propPath.every(
			(e) => typeof e == "string" || typeof e == "number",
		)
	)
		return {
			type: "component-inline-prop",
			children: qb(t.children),
			propPath: t.attributes.propPath,
		};
	throw new Error(`Unknown inline node type: ${t.type}`);
}
function Ua(t) {
	return t.flatMap(mA);
}
function qb(t) {
	const e = t.flatMap(mA),
		n = [];
	let r;
	for (const [o, s] of e.entries()) {
		var i;
		(s.type === void 0 &&
			s.text === "" &&
			((i = r) === null || i === void 0 ? void 0 : i.type) === void 0 &&
			o !== e.length - 1) ||
			(n.push(s), (r = s));
	}
	return n.length || n.push({ text: "" }), n;
}
function JF(t, e) {
	const n = t.children.flatMap((r) => Er(r, e));
	return n.length === 0
		? [{ type: "paragraph", children: [{ text: "" }] }]
		: (n[n.length - 1].type !== "paragraph" &&
				n.push({ type: "paragraph", children: [{ text: "" }] }),
			n);
}
function Er(t, e) {
	if (t.type === "blockquote")
		return {
			type: "blockquote",
			children: t.children.flatMap((i) => Er(i, e)),
		};
	if (t.type === "fence") {
		const { language: i, content: o, ...s } = t.attributes;
		return {
			type: "code",
			children: [{ text: o.replace(/\n$/, "") }],
			...(typeof i == "string" ? { language: i } : {}),
			...s,
		};
	}
	if (t.type === "heading")
		return {
			...t.attributes,
			level: t.attributes.level,
			type: "heading",
			children: qb(t.children),
		};
	if (t.type === "list")
		return {
			type: t.attributes.ordered ? "ordered-list" : "unordered-list",
			children: t.children.flatMap((i) => Er(i, e)),
		};
	if (t.type === "item") {
		var n;
		const i = [
			{
				type: "list-item-content",
				children: t.children.length
					? qb([t.children[0]])
					: [{ text: "" }],
			},
		];
		if (
			((n = t.children[1]) === null || n === void 0 ? void 0 : n.type) ===
			"list"
		) {
			const o = t.children[1];
			i.push({
				type: o.attributes.ordered ? "ordered-list" : "unordered-list",
				children: o.children.flatMap((s) => Er(s, e)),
			});
		}
		return { type: "list-item", children: i };
	}
	if (t.type === "paragraph") {
		if (
			t.children.length === 1 &&
			t.children[0].type === "inline" &&
			t.children[0].children.length === 1 &&
			t.children[0].children[0].type === "image"
		) {
			var r;
			const o = t.children[0].children[0];
			return {
				type: "image",
				src: decodeURI(o.attributes.src),
				alt: o.attributes.alt,
				title:
					(r = o.attributes.title) !== null && r !== void 0 ? r : "",
				children: [{ text: "" }],
			};
		}
		const i = qb(t.children);
		return i.length === 1 && i[0].type === "component-inline-prop"
			? i[0]
			: {
					type: "paragraph",
					children: i,
					textAlign: t.attributes.textAlign,
				};
	}
	if (t.type === "hr") return { type: "divider", children: [{ text: "" }] };
	if (t.type === "table")
		return { type: "table", children: t.children.flatMap((i) => Er(i, e)) };
	if (t.type === "tbody")
		return {
			type: "table-body",
			children: t.children.flatMap((i) => Er(i, e)),
		};
	if (t.type === "thead")
		return t.children.length
			? {
					type: "table-head",
					children: t.children.flatMap((i) => Er(i, e)),
				}
			: [];
	if (t.type === "tr")
		return {
			type: "table-row",
			children: t.children.flatMap((i) => Er(i, e)),
		};
	if (t.type === "td")
		return {
			type: "table-cell",
			children: t.children.flatMap((i) => Er(i, e)),
		};
	if (t.type === "th")
		return {
			type: "table-cell",
			header: !0,
			children: t.children.flatMap((i) => Er(i, e)),
		};
	if (t.type === "tag") {
		if (t.tag === "table") return Er(t.children[0], e);
		if (t.tag === "layout")
			return {
				type: "layout",
				layout: t.attributes.layout,
				children: t.children.flatMap((i) => Er(i, e)),
			};
		if (t.tag === "layout-area")
			return {
				type: "layout-area",
				children: t.children.flatMap((i) => Er(i, e)),
			};
		if (t.tag === "component-block")
			return {
				type: "component-block",
				component: t.attributes.component,
				props: t.attributes.props,
				children:
					t.children.length === 0
						? [
								{
									type: "component-inline-prop",
									children: [{ text: "" }],
								},
							]
						: t.children.flatMap((i) => Er(i, e)),
			};
		if (
			t.tag === "component-block-prop" &&
			Array.isArray(t.attributes.propPath) &&
			t.attributes.propPath.every(
				(i) => typeof i == "string" || typeof i == "number",
			)
		)
			return {
				type: "component-block-prop",
				children: t.children.flatMap((i) => Er(i, e)),
				propPath: t.attributes.propPath,
			};
		if (t.tag) {
			const i = e[t.tag];
			if (i) {
				const o = VJ({ kind: "object", fields: i.schema });
				if (o) {
					const s = JSON.parse(JSON.stringify(t.attributes)),
						a = [];
					return (
						KJ(t.children, a, s, o, [], e),
						{
							type: "component-block",
							component: t.tag,
							props: s,
							children: a,
						}
					);
				}
				return {
					type: "component-block",
					component: t.tag,
					props: t.attributes,
					children:
						t.children.length === 0
							? [
									{
										type: "component-inline-prop",
										children: [{ text: "" }],
									},
								]
							: t.children.flatMap((s) => Er(s, e)),
				};
			}
		}
		throw new Error(`Unknown tag: ${t.tag}`);
	}
	return mA(t);
}
function KJ(t, e, n, r, i, o) {
	if (r.kind === "child") {
		const s = t.flatMap((a) => Er(a, o));
		e.push({
			type: `component-${r.options.kind}-prop`,
			propPath: [...i, ...r.relativePath],
			children: s,
		});
	}
	if (r.kind === "array") {
		const s = [];
		for (let [u, c] of t.entries()) {
			if (
				(c.type === "paragraph" && (c = c.children[0].children[0]),
				c.type !== "tag")
			)
				throw new Error(
					`expected tag ${r.asChildTag}, found type: ${c.type}`,
				);
			if (c.tag !== r.asChildTag)
				throw new Error(
					`expected tag ${r.asChildTag}, found tag: ${c.tag}`,
				);
			const d = JSON.parse(JSON.stringify(c.attributes));
			r.child &&
				KJ(c.children, e, d, r.child, [...i, ...r.relativePath, u], o),
				s.push(d);
		}
		const a = r.relativePath[r.relativePath.length - 1],
			l = jg(n, r.relativePath.slice(0, -1));
		l[a] = s;
	}
}
function Nu(t, e) {
	return typeof t == "string"
		? `${t.replace(/\/*$/, "")}/${e === void 0 ? "" : e + "/"}`
		: "";
}
function SE(t, e, n, r, i, o, s) {
	return t.map((a) => {
		if (a.type === "component-block") {
			const u = e[a.component];
			if (!u) return a;
			const c = Ir(u.schema);
			return { ...a, props: l7e(c, a.props, n, r, i, s) };
		}
		if (a.type === "image" && typeof a.src == "string" && i === "edit") {
			var l;
			const u = UJ(o, s),
				c = a.src.slice(u.length),
				d =
					(l =
						typeof o.images == "object" &&
						typeof o.images.directory == "string"
							? r.get(xr(o.images.directory))
							: n) === null || l === void 0
						? void 0
						: l.get(c);
			return d
				? {
						type: "image",
						src: { filename: c, content: d },
						alt: a.alt,
						title: a.title,
						children: [{ text: "" }],
					}
				: {
						type: "paragraph",
						children: [{ text: `Missing image ${c}` }],
					};
		}
		if (typeof a.type == "string") {
			const u = SE(a.children, e, n, r, i, o, s);
			return { ...a, children: u };
		}
		return a;
	});
}
function l7e(t, e, n, r, i, o) {
	return Eu(t, e, {
		form: (s, a) => {
			if (s.formKind === "asset") {
				var l;
				if (i === "read") return s.reader.parse(a);
				const u = s.filename(a, {
					slug: o,
					suggestedFilenamePrefix: void 0,
				});
				return s.parse(a, {
					asset: u
						? s.directory
							? (l = r.get(s.directory)) === null || l === void 0
								? void 0
								: l.get(u)
							: n.get(u)
						: void 0,
					slug: o,
				});
			}
			if (s.formKind === "content" || s.formKind === "assets")
				throw new Error("Not implemented");
			return i === "read" ? s.reader.parse(a) : s.parse(a, void 0);
		},
	});
}
function UJ(t, e) {
	return Nu(typeof t.images == "object" ? t.images.publicPath : void 0, e);
}
function cd(t, e, n, r, i) {
	const o = [];
	return {
		value: Eu(e, t, {
			form(s, a, l) {
				if (l.length === 1 && n === l[0]) {
					if (s.formKind !== "slug")
						throw new Error("slugField is a not a slug field");
					return s.serializeWithSlug(a).value;
				}
				if (s.formKind === "asset") {
					const { asset: u, value: c } = s.serialize(a, {
						suggestedFilenamePrefix: i ? NC(l, e, t) : void 0,
						slug: r,
					});
					return (
						u &&
							o.push({
								path: u.filename,
								contents: u.content,
								parent: s.directory,
							}),
						c
					);
				}
				if (s.formKind === "content" || s.formKind === "assets") {
					let u, c, d;
					if (s.formKind === "content") {
						const h = s.serialize(a, { slug: r });
						h.content &&
							o.push({
								path: NC(l, e, t) + s.contentExtension,
								contents: h.content,
								parent: void 0,
							}),
							({ value: d, other: u, external: c } = h);
					} else
						({
							value: d,
							other: u,
							external: c,
						} = s.serialize(a, { slug: r }));
					for (const [h, p] of u)
						o.push({
							path: NC(l, e, t) + "/" + h,
							contents: p,
							parent: void 0,
						});
					const f = new Set(s.directories);
					for (const [h, p] of c) {
						if (!f.has(h))
							throw new Error(
								`Invalid directory ${h} in content field serialization`,
							);
						for (const [g, v] of p)
							o.push({ path: g, contents: v, parent: h });
					}
					return d;
				}
				return s.serialize(a).value;
			},
			object(s, a) {
				return Object.fromEntries(
					Object.entries(a).filter(([l, u]) => u !== void 0),
				);
			},
			array(s, a) {
				return a.map((l) => (l === void 0 ? null : l));
			},
			conditional(s, a) {
				return a.value === void 0
					? { discriminant: a.discriminant }
					: a;
			},
			child() {},
		}),
		extraFiles: o,
	};
}
function NC(t, e, n) {
	const r = [];
	for (const i of t) {
		if (e.kind === "array") {
			if (((n = n[i]), e.slugField && e.element.kind === "object")) {
				const o = tr(
					{ schema: e.element.fields, slugField: e.slugField },
					n,
				);
				r.push(o);
			} else r.push(i);
			e = e.element;
			continue;
		}
		if ((r.push(i), e.kind === "object")) {
			(n = n[i]), (e = e.fields[i]);
			continue;
		}
		if (e.kind === "conditional") {
			i === "discriminant"
				? (e = e.discriminant)
				: i === "value" && (e = e.values[n.discriminant]),
				(n = n[i]);
			continue;
		}
		throw new Error(`unexpected ${e.kind}`);
	}
	return r.join("/");
}
function zp(t) {
	return new Ue.Node("inline", {}, t.flatMap(Gb));
}
const u7e = {
	bold: { type: "strong" },
	code: { type: "code" },
	italic: { type: "em" },
	underline: { type: "tag", tag: "u" },
	keyboard: { type: "tag", tag: "kbd" },
	strikethrough: { type: "s" },
	subscript: { type: "tag", tag: "sub" },
	superscript: { type: "tag", tag: "sup" },
};
function Gb(t) {
	var e, n;
	if (t.type === "link")
		return new Ue.Node("link", { href: t.href }, t.children.flatMap(Gb));
	if (t.type !== void 0)
		throw new Error(`unexpected inline node type: ${t.type}`);
	const r = Object.keys(t)
			.filter((l) => l !== "text" && l !== "code")
			.sort(),
		i = t.text.split(/\n/);
	if (i.length > 1)
		return i.flatMap((l, u) => {
			if (u === 0) return Gb({ ...t, text: l });
			const c = Gb({ ...t, text: l });
			return [new Ue.Node("hardbreak"), ...(Array.isArray(c) ? c : [c])];
		});
	const o =
			(e = /^\s+/.exec(t.text)) === null || e === void 0 ? void 0 : e[0],
		s = (n = /\s+$/.exec(t.text)) === null || n === void 0 ? void 0 : n[0];
	let a = t.code
		? [new Ue.Node("code", { content: t.text.trim() }, [])]
		: [new Ue.Node("text", { content: t.text.trim() })];
	for (const l of r) {
		const u = u7e[l];
		u && (a = [new Ue.Node(u.type, {}, a, u.tag)]);
	}
	return (
		/^\s+$/.test(t.text)
			? a.unshift(new Ue.Node("text", { content: o }, []))
			: (o != null &&
					o.length &&
					a.unshift(new Ue.Node("text", { content: o }, [])),
				s != null &&
					s.length &&
					a.push(new Ue.Node("text", { content: s }, []))),
		a
	);
}
function c7e(t, e) {
	const n = [],
		r = { ...e, extraFiles: n };
	return {
		node: new Ue.Node(
			"document",
			{},
			t.flatMap((o) => AE(o, r)),
		),
		extraFiles: n,
	};
}
function HJ(t, e, n, r) {
	if (r.kind === "child") {
		const i = t.find((o) => Bd(o.propPath, r.relativePath));
		i && e.push(...i.children);
		return;
	}
	if (r.kind === "array") {
		const i = r.relativePath[r.relativePath.length - 1],
			o = jg(n, r.relativePath.slice(0, -1)),
			s = o[i];
		delete o[i];
		const a = new Map();
		for (const l of t) {
			const u = l.propPath.slice(r.relativePath.length + 1),
				c = l.propPath[r.relativePath.length];
			a.get(c) === void 0 && a.set(c, []),
				a.get(c).push({ children: l.children, propPath: u });
		}
		e.push(
			...s.map((l, u) => {
				var c;
				const d = (c = a.get(u)) !== null && c !== void 0 ? c : [],
					f = [];
				return (
					HJ(d, f, l, r.child), new Ue.Node("tag", l, f, r.asChildTag)
				);
			}),
		);
	}
}
function AE(t, e) {
	if (t.type === "paragraph") {
		const r = new Ue.Node(
			"paragraph",
			t.textAlign ? { textAlign: t.textAlign } : {},
			[zp(t.children)],
		);
		return (
			t.textAlign &&
				r.annotations.push({
					name: "textAlign",
					value: t.textAlign,
					type: "attribute",
				}),
			r
		);
	}
	if (t.type === "image")
		return (
			e.extraFiles.push({
				contents: t.src.content,
				path: t.src.filename,
				parent:
					typeof e.documentFeatures.images == "object" &&
					typeof e.documentFeatures.images.directory == "string"
						? xr(e.documentFeatures.images.directory)
						: void 0,
			}),
			new Ue.Node("paragraph", {}, [
				new Ue.Node("inline", {}, [
					new Ue.Node("image", {
						src: encodeURI(
							`${UJ(e.documentFeatures, e.slug)}${t.src.filename}`,
						),
						alt: t.alt,
						title: t.title,
					}),
				]),
			])
		);
	if (t.type === "code") {
		const r = {},
			{ children: i, language: o, type: s, ...a } = t,
			l =
				typeof e.documentFeatures.formatting.blockTypes.code == "object"
					? e.documentFeatures.formatting.blockTypes.code.schema
					: void 0;
		if (l && Object.keys(l.fields).length > 0) {
			const d = cd(ua(l, a), l, void 0, e.slug, !1);
			Object.assign(r, d.value), e.extraFiles.push(...d.extraFiles);
		}
		let u =
			i[0].text +
			`
`;
		const c = new Ue.Node("fence", { content: u, language: o, ...r }, [
			new Ue.Node("text", { content: u }),
		]);
		for (const [d, f] of Object.entries(r))
			c.annotations.push({ name: d, value: f, type: "attribute" });
		return c;
	}
	const n = (r) => AE(r, e);
	if (t.type === "blockquote")
		return new Ue.Node("blockquote", {}, t.children.map(n));
	if (t.type === "divider") return new Ue.Node("hr");
	if (t.type === "table") {
		const r = t.children.find((i) => i.type === "table-head");
		return new Ue.Node(
			"tag",
			{},
			[
				new Ue.Node("table", {}, [
					new Ue.Node("thead", {}, r ? r.children.map(n) : []),
					n(t.children.find((i) => i.type === "table-body")),
				]),
			],
			"table",
		);
	}
	if (t.type === "table-body")
		return new Ue.Node("tbody", {}, t.children.map(n));
	if (t.type === "table-row") return new Ue.Node("tr", {}, t.children.map(n));
	if (t.type === "table-cell")
		return new Ue.Node(t.header ? "th" : "td", {}, t.children.map(n));
	if (t.type === "heading") {
		const r = {};
		t.textAlign && (r.textAlign = t.textAlign);
		const { children: i, level: o, textAlign: s, type: a, ...l } = t,
			u = e.documentFeatures.formatting.headings.schema;
		Object.keys(u.fields).length > 0 &&
			Object.assign(r, cd(ua(u, l), u, void 0, e.slug, !1).value);
		const c = new Ue.Node("heading", { level: t.level, ...r }, [
			zp(t.children),
		]);
		for (const [d, f] of Object.entries(r))
			c.annotations.push({ name: d, value: f, type: "attribute" });
		return c;
	}
	if (t.type === "ordered-list")
		return new Ue.Node("list", { ordered: !0 }, t.children.map(n));
	if (t.type === "unordered-list")
		return new Ue.Node("list", { ordered: !1 }, t.children.map(n));
	if (t.type === "layout")
		return new Ue.Node(
			"tag",
			{ layout: t.layout },
			t.children.map(n),
			"layout",
		);
	if (t.type === "layout-area")
		return new Ue.Node("tag", {}, t.children.flatMap(n), "layout-area");
	if (t.type === "component-block") {
		const r =
				t.children.length === 1 &&
				t.children[0].type === "component-inline-prop" &&
				t.children[0].propPath === void 0,
			i = e.componentBlocks[t.component],
			o = [];
		for (const l of t.children)
			(l.type === "component-block-prop" ||
				l.type === "component-inline-prop") &&
				l.propPath !== void 0 &&
				o.push({
					type: l.type,
					propPath: l.propPath,
					children:
						l.type === "component-block-prop"
							? l.children.flatMap(n)
							: [zp(l.children)],
				});
		let s = t.props;
		if (i) {
			const l = cd(
				t.props,
				{ kind: "object", fields: i.schema },
				void 0,
				e.slug,
				!1,
			);
			(s = l.value), e.extraFiles.push(...l.extraFiles);
			const u = VJ({ kind: "object", fields: i.schema });
			if (u) {
				const c = [];
				return HJ(o, c, s, u), new Ue.Node("tag", s, c, t.component);
			}
		}
		const a = r
			? []
			: o.map(
					(l) =>
						new Ue.Node(
							"tag",
							{ propPath: l.propPath },
							l.children,
							l.type,
						),
				);
		return new Ue.Node("tag", s, a, t.component);
	}
	if (t.type === "component-block-prop" || t.type === "component-inline-prop")
		return new Ue.Node(
			"tag",
			{ propPath: t.propPath },
			t.type === "component-inline-prop"
				? [zp(t.children)]
				: t.children.flatMap(n),
			t.type,
		);
	if (t.type === "list-item") {
		const r = t.children[0];
		if (r.type !== "list-item-content")
			throw new Error(
				"list item content must contain a list-item-content",
			);
		const o = [zp(r.children)],
			s = t.children[1];
		return s && o.push(AE(s, e)), new Ue.Node("item", {}, o);
	}
	if (t.type === "list-item-content")
		throw new Error("list-item-content in unexpected position");
	debugger;
	throw new Error(`unexpected node type: ${t.type}`);
}
let d7e = 0;
function XF() {
	return d7e++;
}
const f7e = new TextEncoder();
function h7e(t, e, n, r) {
	const { extraFiles: i, node: o } = c7e(t, {
			componentBlocks: n,
			documentFeatures: r,
			slug: e.slug,
		}),
		s = new Map(),
		a = new Map();
	for (const l of i) {
		if (l.parent === void 0) {
			s.set(l.path, l.contents);
			continue;
		}
		a.has(l.parent) || a.set(l.parent, new Map()),
			a.get(l.parent).set(l.path, l.contents);
	}
	return {
		content: f7e.encode(_m(ju(_m(o)))),
		other: s,
		external: a,
		value: void 0,
	};
}
function p7e(t, e, n) {
	const r = CIe(t, e);
	return (r.children = n), R.normalize(r, { force: !0 }), r.children;
}
function m7e(t) {
	const e = ee(15),
		n = xo();
	let r;
	e[0] !== t.value
		? ((r = () => ({ key: XF(), value: t.value })),
			(e[0] = t.value),
			(e[1] = r))
		: (r = e[1]);
	const [i, o] = E.useState(r);
	i.value !== t.value && o({ key: XF(), value: t.value });
	let s;
	e[2] !== t.label || e[3] !== t.description
		? ((s = {
				label: t.label,
				labelElementType: "span",
				description: t.description,
			}),
			(e[2] = t.label),
			(e[3] = t.description),
			(e[4] = s))
		: (s = e[4]);
	let a = s;
	if (n === "main") {
		let d;
		e[5] !== t.label
			? ((d = { "aria-label": t.label }), (e[5] = t.label), (e[6] = d))
			: (d = e[6]),
			(a = d);
	}
	const l = n === "main" ? "100%" : void 0;
	let u;
	e[7] !== i.key || e[8] !== i.value || e[9] !== t
		? ((u = (d) =>
				E.createElement(jJ, {
					...d,
					key: i.key,
					componentBlocks: t.componentBlocks,
					documentFeatures: t.documentFeatures,
					onChange: (f) => {
						o((h) => ({ key: h.key, value: f })), t.onChange(f);
					},
					value: i.value,
				})),
			(e[7] = i.key),
			(e[8] = i.value),
			(e[9] = t),
			(e[10] = u))
		: (u = e[10]);
	let c;
	return (
		e[11] !== l || e[12] !== a || e[13] !== u
			? ((c = m.jsx(bD, { height: l, ...a, children: u })),
				(e[11] = l),
				(e[12] = a),
				(e[13] = u),
				(e[14] = c))
			: (c = e[14]),
		c
	);
}
const ZF = new TextDecoder(),
	g7e = Ag({
		label: "Alt text",
		description:
			"This text will be used by screen readers and search engines.",
	}),
	b7e = Hi({
		Input() {
			return null;
		},
		defaultValue() {
			return "";
		},
		parse(t) {
			if (t === void 0) return "";
			if (typeof t != "string") throw new st("Must be string");
			return t;
		},
		validate(t) {
			return t;
		},
		serialize(t) {
			return { value: t };
		},
		label: "Title",
	});
function v7e(t) {
	var e, n, r, i, o, s, a, l, u, c, d, f, h, p, g, v, b, y;
	const x =
			t.formatting === !0
				? {
						blockTypes: !0,
						headingLevels: !0,
						inlineMarks: !0,
						listTypes: !0,
						softBreaks: !0,
					}
				: (e = t.formatting) !== null && e !== void 0
					? e
					: {},
		C = t.images === !0 ? {} : t.images;
	return {
		formatting: {
			alignment:
				x.alignment === !0
					? { center: !0, end: !0 }
					: {
							center: !!(
								(n = x.alignment) !== null &&
								n !== void 0 &&
								n.center
							),
							end: !!(
								(r = x.alignment) !== null &&
								r !== void 0 &&
								r.end
							),
						},
			blockTypes:
				(x == null ? void 0 : x.blockTypes) === !0
					? { blockquote: !0, code: { schema: Ir({}) } }
					: {
							blockquote: !!(
								(i = x.blockTypes) !== null &&
								i !== void 0 &&
								i.blockquote
							),
							code: ((k) => {
								if (
									((k = x.blockTypes) === null || k === void 0
										? void 0
										: k.code) === void 0
								)
									return !1;
								if (
									x.blockTypes.code === !0 ||
									!x.blockTypes.code.schema
								)
									return { schema: Ir({}) };
								for (const w of [
									"type",
									"children",
									"language",
								])
									if (w in x.blockTypes.code.schema)
										throw new Error(
											`"${w}" cannot be a key in the schema for code blocks`,
										);
								return { schema: Ir(x.blockTypes.code.schema) };
							})(),
						},
			headings: ((k) => {
				const w = x == null ? void 0 : x.headingLevels,
					D =
						typeof w == "object" && "levels" in w
							? w
							: { levels: w, schema: void 0 };
				if (D.schema) {
					for (const S of ["type", "children", "level", "textAlign"])
						if (S in D.schema)
							throw new Error(
								`"${S}" cannot be a key in the schema for headings`,
							);
				}
				return {
					levels: [
						...new Set(
							D.levels === !0 ? [1, 2, 3, 4, 5, 6] : D.levels,
						),
					],
					schema: Ir(
						(k = D.schema) !== null && k !== void 0 ? k : {},
					),
				};
			})(),
			inlineMarks:
				x.inlineMarks === !0
					? {
							bold: !0,
							code: !0,
							italic: !0,
							keyboard: !1,
							strikethrough: !0,
							subscript: !1,
							superscript: !1,
							underline: !1,
						}
					: {
							bold: !!(
								(o = x.inlineMarks) !== null &&
								o !== void 0 &&
								o.bold
							),
							code: !!(
								(s = x.inlineMarks) !== null &&
								s !== void 0 &&
								s.code
							),
							italic: !!(
								(a = x.inlineMarks) !== null &&
								a !== void 0 &&
								a.italic
							),
							strikethrough: !!(
								(l = x.inlineMarks) !== null &&
								l !== void 0 &&
								l.strikethrough
							),
							underline: !!(
								(u = x.inlineMarks) !== null &&
								u !== void 0 &&
								u.underline
							),
							keyboard: !!(
								(c = x.inlineMarks) !== null &&
								c !== void 0 &&
								c.keyboard
							),
							subscript: !!(
								(d = x.inlineMarks) !== null &&
								d !== void 0 &&
								d.subscript
							),
							superscript: !!(
								(f = x.inlineMarks) !== null &&
								f !== void 0 &&
								f.superscript
							),
						},
			listTypes:
				x.listTypes === !0
					? { ordered: !0, unordered: !0 }
					: {
							ordered: !!(
								(h = x.listTypes) !== null &&
								h !== void 0 &&
								h.ordered
							),
							unordered: !!(
								(p = x.listTypes) !== null &&
								p !== void 0 &&
								p.unordered
							),
						},
			softBreaks: !!x.softBreaks,
		},
		links: !!t.links,
		layouts: [
			...new Set((t.layouts || []).map((k) => JSON.stringify(k))),
		].map((k) => JSON.parse(k)),
		dividers: !!t.dividers,
		images:
			C === void 0
				? !1
				: {
						...C,
						schema: {
							alt:
								(g =
									(v = C.schema) === null || v === void 0
										? void 0
										: v.alt) !== null && g !== void 0
									? g
									: g7e,
							title:
								(b =
									(y = C.schema) === null || y === void 0
										? void 0
										: y.title) !== null && b !== void 0
									? b
									: b7e,
						},
					},
		tables: !!t.tables,
	};
}
function y7e({ label: t, componentBlocks: e = {}, description: n, ...r }) {
	const i = v7e(r);
	return {
		kind: "form",
		formKind: "content",
		defaultValue() {
			return [{ type: "paragraph", children: [{ text: "" }] }];
		},
		Input(o) {
			return m.jsx(m7e, {
				componentBlocks: e,
				description: n,
				label: t,
				documentFeatures: i,
				...o,
			});
		},
		parse(o, s) {
			const a = ZF.decode(s.content),
				l = JF(ju(a), e);
			return SE(p7e(i, e, l), e, s.other, s.external, "edit", i, s.slug);
		},
		contentExtension: ".mdoc",
		validate(o) {
			return o;
		},
		directories: [
			...b3(
				Ir(
					Object.fromEntries(
						Object.entries(e).map(([o, s]) => [o, Ir(s.schema)]),
					),
				),
			),
			...(typeof i.images == "object" &&
			typeof i.images.directory == "string"
				? [xr(i.images.directory)]
				: []),
		],
		serialize(o, s) {
			return h7e(o, s, e, i);
		},
		reader: {
			parse(o, s) {
				const a = ZF.decode(s.content),
					l = JF(ju(a), e);
				return SE(l, e, new Map(), new Map(), "read", i, void 0);
			},
		},
	};
}
const _r = {
	blockParent: "ProseMirror-blockParent",
	focused: "ProseMirror-focused",
	hideselection: "ProseMirror-hideselection",
	nodeInSelection: "ProseMirror-nodeInSelection",
	nodeSelection: "ProseMirror-selectednode",
	placeholder: "ProseMirror-placeholder",
};
function WJ(t) {
	const e = new WeakMap();
	return (n) => {
		if (e.has(n)) return e.get(n);
		const r = t(n);
		return e.set(n, r), r;
	};
}
let x7e = B.color.background.canvas,
	k7e = B.color.alias.borderSelected,
	QF = B.size.border.medium,
	Lp = B.size.space.regular;
xx({
	".prosemirror-dropcursor-block": {
		"&::before, &::after": {
			backgroundColor: x7e,
			border: `${QF} solid ${k7e}`,
			borderRadius: "50%",
			content: '" "',
			height: Lp,
			position: "absolute",
			width: Lp,
			top: `calc(${Lp} / -2 - ${QF} / 2)`,
		},
		"&::before": { left: `calc(${Lp} * -1)` },
		"&::after": { right: `calc(${Lp} * -1)` },
	},
});
const C7e = [
		"area",
		"base",
		"br",
		"col",
		"embed",
		"hr",
		"img",
		"input",
		"link",
		"meta",
		"param",
		"source",
		"track",
		"wbr",
	],
	w7e = X`
  /* Provide our own selection indicator */
  .${_r.nodeSelection} {
    position: relative;
  }
  .${_r.nodeSelection}::after {
    background-color: ${B.color.alias.backgroundSelected};
    border-radius: ${B.size.radius.small};
    content: '';
    inset: calc(${B.size.alias.focusRingGap} * -1);
    pointer-events: none;
    position: absolute;
  }
  .${_r.nodeSelection}:is(${C7e.join(", ")}) {
    outline: ${B.size.alias.focusRing} solid
      ${B.color.border.accent};
    outline-offset: ${B.size.alias.focusRingGap};
  }
  .${_r.hideselection} *::selection {
    background: transparent;
  }
  .${_r.hideselection} *::-moz-selection {
    background: transparent;
  }
  .${_r.hideselection} {
    caret-color: transparent;
  }

  /* Style the placeholder element */
  .${_r.placeholder} {
    color: ${B.color.foreground.neutralTertiary};
    pointer-events: none;
  }

  /* Protect against generic img rules */
  img.ProseMirror-separator {
    display: inline !important;
    border: none !important;
    margin: 0 !important;
  }

  /* Provide an indicator for focusing places that don't allow regular selection */
  .ProseMirror-gapcursor {
    display: none;
    pointer-events: none;
    position: absolute;
  }
  .ProseMirror-gapcursor:after {
    content: '';
    display: block;
    position: absolute;
    top: -2px;
    width: 20px;
    border-top: 1px solid black;
    animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;
  }

  @keyframes ProseMirror-cursor-blink {
    to {
      visibility: hidden;
    }
  }

  .ProseMirror-focused .ProseMirror-gapcursor {
    display: block;
  }
  .ProseMirror > .ProseMirror-yjs-cursor:first-child {
    margin-top: 16px;
  }
  /* This gives the remote user caret. The colors are automatically overwritten*/
  .ProseMirror-yjs-cursor {
    position: relative;
    margin-left: -1px;
    margin-right: -1px;
    border-left: 1px solid black;
    border-right: 1px solid black;
    border-color: orange;
    word-break: normal;
    pointer-events: none;
  }
  /* This renders the username above the caret */
  .ProseMirror-yjs-cursor > div {
    position: absolute;
    top: -1.05em;
    left: -1px;
    font-size: 13px;
    background-color: rgb(250, 129, 0);
    font-family: ${B.typography.fontFamily.base};
    font-style: normal;
    font-weight: normal;
    line-height: normal;
    user-select: none;
    color: white;
    padding-left: 2px;
    padding-right: 2px;
    white-space: nowrap;
  }
`;
function qJ(t) {
	const e = E.useRef(t),
		n = E.useCallback((...r) => e.current(...r), []);
	return (
		E.useEffect(() => {
			e.current = t;
		}),
		n
	);
}
function Wf(t) {
	return (e, n) =>
		e.selection instanceof Qe && e.selection.node.type === t
			? !1
			: (n && n(e.tr.replaceSelectionWith(t.createAndFill())), !0);
}
function E7e(t, e) {
	return (n, r, i) => {
		const o = [];
		for (const s of n.selection.ranges)
			n.doc.nodesBetween(s.$from.pos, s.$to.pos, (a, l) => {
				a.type === t && o.push([l, l + a.nodeSize]);
			});
		if (!o.length) return yd(t)(n, r, i);
		if (r) {
			const s = n.tr;
			for (const [a, l] of o) s.setBlockType(a, l, e);
			r(s);
		}
		return !0;
	};
}
function GJ(t) {
	const e = t.contentMatch.defaultType,
		n = e.contentMatch.defaultType,
		r = kr(t.schema).nodes.table_header;
	return (i, o) => {
		const s = r.createAndFill(),
			a = n.createAndFill(),
			l = e.create(void 0, [s, s, s]),
			u = e.create(void 0, [a, a, a]);
		return (
			o == null ||
				o(i.tr.replaceSelectionWith(t.create(void 0, [l, u, u]))),
			!0
		);
	};
}
function D7e(t, e) {
	for (let n = t.depth; n > 0; n--) {
		let r = t.$from.node(n);
		if (r.type.contentMatch.defaultType === e)
			return { node: r, pos: t.$from.before(n) };
	}
}
function dd(t, e = null) {
	const n = t.contentMatch.defaultType;
	return function (r, i) {
		let { $from: o, $to: s } = r.selection,
			a = o.blockRange(s),
			l = !1,
			u = a;
		if (!a) return !1;
		const c = D7e(a, n);
		if ((c == null ? void 0 : c.node.type) == t) return YJ(n)(r, i);
		if (c && c.node.type !== t)
			return i && i(r.tr.setNodeMarkup(c.pos, t, e).scrollIntoView()), !0;
		if (
			a.depth >= 2 &&
			o.node(a.depth - 1).type.compatibleContent(t) &&
			a.startIndex == 0
		) {
			if (o.index(a.depth - 1) == 0) return !1;
			let f = r.doc.resolve(a.start - 2);
			(u = new Av(f, f, a.depth)),
				a.endIndex < a.parent.childCount &&
					(a = new Av(o, r.doc.resolve(s.end(a.depth)), a.depth)),
				(l = !0);
		}
		let d = zD(u, t, e, a);
		return d ? (i && i(S7e(r.tr, a, d, l, t).scrollIntoView()), !0) : !1;
	};
}
function S7e(t, e, n, r, i) {
	let o = be.empty;
	for (let c = n.length - 1; c >= 0; c--)
		o = be.from(n[c].type.create(n[c].attrs, o));
	t.step(
		new Fr(
			e.start - (r ? 2 : 0),
			e.end,
			e.start,
			e.end,
			new Ee(o, 0, 0),
			n.length,
			!0,
		),
	);
	let s = 0;
	for (let c = 0; c < n.length; c++) n[c].type == i && (s = c + 1);
	let a = n.length - s,
		l = e.start + n.length - (r ? 2 : 0),
		u = e.parent;
	for (let c = e.startIndex, d = e.endIndex, f = !0; c < d; c++, f = !1)
		!f && nh(t.doc, l, a) && (t.split(l, a), (l += 2 * a)),
			(l += u.child(c).nodeSize);
	return t;
}
function A7e(t) {
	return function (e, n) {
		let { $from: r, $to: i, node: o } = e.selection;
		if ((o && o.isBlock) || r.depth < 2 || !r.sameParent(i)) return !1;
		let s = r.node(-1);
		if (s.type != t) return !1;
		if (
			r.parent.content.size == 0 &&
			r.node(-1).childCount == r.indexAfter(-1)
		) {
			if (
				r.depth == 3 ||
				r.node(-3).type != t ||
				r.index(-2) != r.node(-2).childCount - 1
			)
				return !1;
			if (n) {
				let c = be.empty,
					d = r.index(-1) ? 1 : r.index(-2) ? 2 : 3;
				for (let v = r.depth - d; v >= r.depth - 3; v--)
					c = be.from(r.node(v).copy(c));
				let f =
					r.indexAfter(-1) < r.node(-2).childCount
						? 1
						: r.indexAfter(-2) < r.node(-3).childCount
							? 2
							: 3;
				c = c.append(be.from(t.createAndFill()));
				let h = r.before(r.depth - (d - 1)),
					p = e.tr.replace(h, r.after(-f), new Ee(c, 4 - d, 0)),
					g = -1;
				p.doc.nodesBetween(h, p.doc.content.size, (v, b) => {
					if (g > -1) return !1;
					v.isTextblock && v.content.size == 0 && (g = b + 1);
				}),
					g > -1 && p.setSelection(mt.near(p.doc.resolve(g))),
					n(p.scrollIntoView());
			}
			return !0;
		}
		let a = i.pos == r.end() ? s.contentMatchAt(0).defaultType : null,
			l = e.tr.delete(r.pos, i.pos),
			u = a ? [null, { type: a }] : void 0;
		return nh(l.doc, r.pos, 2, u)
			? (n && n(l.split(r.pos, 2, u).scrollIntoView()), !0)
			: !1;
	};
}
function YJ(t) {
	return function (e, n) {
		let { $from: r, $to: i } = e.selection,
			o = r.blockRange(
				i,
				(s) => s.childCount > 0 && s.firstChild.type == t,
			);
		return o
			? n
				? r.node(o.depth - 1).type == t
					? $7e(e, n, t, o)
					: T7e(e, n, o)
				: !0
			: !1;
	};
}
function $7e(t, e, n, r) {
	let i = t.tr,
		o = r.end,
		s = r.$to.end(r.depth);
	o < s &&
		(i.step(
			new Fr(
				o - 1,
				s,
				o,
				s,
				new Ee(be.from(n.create(null, r.parent.copy())), 1, 0),
				1,
				!0,
			),
		),
		(r = new Av(i.doc.resolve(r.$from.pos), i.doc.resolve(s), r.depth)));
	const a = v0(r);
	if (a == null) return !1;
	i.lift(r, a);
	let l = i.mapping.map(o, -1) - 1;
	return Qh(i.doc, l) && i.join(l), e(i.scrollIntoView()), !0;
}
function T7e(t, e, n) {
	let r = t.tr,
		i = n.parent;
	for (let h = n.end, p = n.endIndex - 1, g = n.startIndex; p > g; p--)
		(h -= i.child(p).nodeSize), r.delete(h - 1, h + 1);
	let o = r.doc.resolve(n.start),
		s = o.nodeAfter;
	if (r.mapping.map(n.end) != n.start + o.nodeAfter.nodeSize) return !1;
	let a = n.startIndex == 0,
		l = n.endIndex == i.childCount,
		u = o.node(-1),
		c = o.index(-1);
	if (
		!u.canReplace(
			c + (a ? 0 : 1),
			c + 1,
			s.content.append(l ? be.empty : be.from(i)),
		)
	)
		return !1;
	let d = o.pos,
		f = d + s.nodeSize;
	return (
		r.step(
			new Fr(
				d - (a ? 1 : 0),
				f + (l ? 1 : 0),
				d + 1,
				f - 1,
				new Ee(
					(a ? be.empty : be.from(i.copy(be.empty))).append(
						l ? be.empty : be.from(i.copy(be.empty)),
					),
					a ? 0 : 1,
					l ? 0 : 1,
				),
				a ? 0 : 1,
			),
		),
		e(r.scrollIntoView()),
		!0
	);
}
function B7e(t) {
	return function (e, n) {
		let { $from: r, $to: i } = e.selection,
			o = r.blockRange(
				i,
				(u) => u.childCount > 0 && u.firstChild.type == t,
			);
		if (!o) return !1;
		let s = o.startIndex;
		if (s == 0) return !1;
		let a = o.parent,
			l = a.child(s - 1);
		if (l.type != t) return !1;
		if (n) {
			let u = l.lastChild && l.lastChild.type == a.type,
				c = be.from(u ? t.create() : null),
				d = new Ee(
					be.from(t.create(null, be.from(a.type.create(null, c)))),
					u ? 3 : 1,
					0,
				),
				f = o.start,
				h = o.end;
			n(
				e.tr
					.step(new Fr(f - (u ? 3 : 1), h, f, h, d, 1, !0))
					.scrollIntoView(),
			);
		}
		return !0;
	};
}
const gA = "@@independentForGapCursor";
class Sn extends mt {
	constructor(e) {
		super(e, e);
	}
	map(e, n) {
		let r = e.resolve(n.map(this.head));
		return Sn.valid(r) ? new Sn(r) : mt.near(r);
	}
	content() {
		return Ee.empty;
	}
	eq(e) {
		return e instanceof Sn && e.head == this.head;
	}
	toJSON() {
		return { type: "ksgapcursor", pos: this.head };
	}
	static fromJSON(e, n) {
		if (typeof n.pos != "number")
			throw new RangeError("Invalid input for GapCursor.fromJSON");
		return new Sn(e.resolve(n.pos));
	}
	getBookmark() {
		return new bA(this.anchor);
	}
	static valid(e) {
		let n = e.parent;
		if (n.isTextblock || !I7e(e) || !F7e(e)) return !1;
		let r = n.type.spec.allowGapCursor;
		if (r != null) return r;
		let i = n.contentMatchAt(e.index()).defaultType;
		return i && i.isTextblock;
	}
	static findGapCursorFrom(e, n, r = !1) {
		e: for (;;) {
			if (!r && Sn.valid(e)) return e;
			let i = e.pos,
				o = null;
			for (let s = e.depth; ; s--) {
				let a = e.node(s);
				if (n > 0 ? e.indexAfter(s) < a.childCount : e.index(s) > 0) {
					o = a.child(n > 0 ? e.indexAfter(s) : e.index(s) - 1);
					break;
				} else if (s == 0) return null;
				i += n;
				let l = e.doc.resolve(i);
				if (Sn.valid(l)) return l;
			}
			for (;;) {
				let s = n > 0 ? o.firstChild : o.lastChild;
				if (!s) {
					if (o.isAtom && !o.isText && !Qe.isSelectable(o)) {
						(e = e.doc.resolve(i + o.nodeSize * n)), (r = !1);
						continue e;
					}
					break;
				}
				(o = s), (i += n);
				let a = e.doc.resolve(i);
				if (Sn.valid(a)) return a;
			}
			return null;
		}
	}
}
Sn.prototype.visible = !1;
Sn.findFrom = Sn.findGapCursorFrom;
try {
	mt.jsonID("ksgapcursor", Sn);
} catch {}
class bA {
	constructor(e) {
		this.pos = e;
	}
	map(e) {
		return new bA(e.map(this.pos));
	}
	resolve(e) {
		let n = e.resolve(this.pos);
		return Sn.valid(n) ? new Sn(n) : mt.near(n);
	}
}
function I7e(t) {
	for (let e = t.depth; e >= 0; e--) {
		let n = t.index(e),
			r = t.node(e);
		if (n == 0) {
			if (r.type.spec.isolating) return !0;
			continue;
		}
		for (let i = r.child(n - 1); ; i = i.lastChild) {
			if (
				(i.childCount == 0 && !i.inlineContent) ||
				i.isAtom ||
				i.type.spec.isolating ||
				i.type.spec[gA]
			)
				return !0;
			if (i.inlineContent) return !1;
		}
	}
	return !0;
}
function F7e(t) {
	for (let e = t.depth; e >= 0; e--) {
		let n = t.indexAfter(e),
			r = t.node(e);
		if (n == r.childCount) {
			if (r.type.spec.isolating) return !0;
			continue;
		}
		for (let i = r.child(n); ; i = i.firstChild) {
			if (
				(i.childCount == 0 && !i.inlineContent) ||
				i.isAtom ||
				i.type.spec.isolating ||
				i.type.spec[gA]
			)
				return !0;
			if (i.inlineContent) return !1;
		}
	}
	return !0;
}
function Y3(t) {
	const e = Le(Ht),
		n = E.useId(),
		[r, i] = E.useState(!1),
		[o, s] = E.useState(t.value),
		a = E.useMemo(() => Ba(t.schema, s, () => {}), [t.schema])(o),
		{ dismiss: l } = Xd();
	return m.jsxs(m.Fragment, {
		children: [
			m.jsx(Pr, {
				children: m.jsx(ke, {
					id: n,
					elementType: "form",
					onSubmit: (u) => {
						u.target === u.currentTarget &&
							(u.preventDefault(),
							_s(t.schema, o, void 0)
								? (t.onSave(o), l())
								: i(!0));
					},
					direction: "column",
					gap: "xxlarge",
					children: m.jsx(Ia, { ...a, forceValidation: r }),
				}),
			}),
			m.jsxs(Nr, {
				children: [
					m.jsx(vt, { onPress: l, children: e.format("cancel") }),
					m.jsx(vt, {
						form: n,
						prominence: "high",
						type: "submit",
						children: "Done",
					}),
				],
			}),
		],
	});
}
function Mm(t, e, n) {
	try {
		return jc(
			{ kind: "object", fields: t },
			e,
			[],
			[],
			(r, i) => {
				if (r.formKind === "asset") {
					var o;
					const s = r.filename(i, {
						slug: n.slug,
						suggestedFilenamePrefix: void 0,
					});
					return r.parse(i, {
						asset: s
							? r.directory
								? (o = n.otherFiles.get(r.directory)) ===
										null || o === void 0
									? void 0
									: o.get(s)
								: n.extraFiles.get(s)
							: void 0,
						slug: n.slug,
					});
				}
				if (r.formKind === "assets") throw new Error("Not implemented");
				if (r.formKind === "content")
					throw new Error("Not implemented");
				return r.parse(i, void 0);
			},
			!1,
		);
	} catch (r) {
		throw new Error(lJ(r));
	}
}
function fn(t, e) {
	const n = cd(t, { kind: "object", fields: e }, void 0, void 0, !1);
	return {
		value: n.value,
		extraFiles: n.extraFiles.map((r) => ({ ...r, contents: r.contents })),
	};
}
function vA(t, e) {
	const n = new Map(),
		r = new Map();
	for (const i of t.extraFiles)
		i.parent
			? (r.has(i.parent) || r.set(i.parent, new Map()),
				r.get(i.parent).set(i.path, i.contents))
			: n.set(i.path, i.contents);
	return Mm(e, t.value, { slug: void 0, extraFiles: n, otherFiles: r });
}
function Ru(t, e, n) {
	const r = vA(e, t),
		i = cd(r, { kind: "object", fields: t }, void 0, n.slug, !1);
	for (const o of i.extraFiles)
		o.parent
			? (n.otherFiles.has(o.parent) ||
					n.otherFiles.set(o.parent, new Map()),
				n.otherFiles.get(o.parent).set(o.path, o.contents))
			: n.extraFiles.set(o.path, o.contents);
	return i.value;
}
const Du = function (e, n) {
	const r = ee(3);
	let i, o;
	return (
		r[0] !== e || r[1] !== n
			? ((o = vA(e, n)), (r[0] = e), (r[1] = n), (r[2] = o))
			: (o = r[2]),
		(i = o),
		i
	);
};
function dm(t) {
	return JSON.stringify({
		value: t.value,
		extraFiles: t.extraFiles.map((e) => ({
			path: e.path,
			parent: e.parent,
			contents: nd(e.contents),
		})),
	});
}
function fm(t) {
	if (typeof t == "string") return !1;
	const e = t.dataset.props;
	if (!e) return !1;
	try {
		const n = JSON.parse(e);
		return {
			props: {
				value: n.value,
				extraFiles: n.extraFiles.map((r) => ({
					path: r.path,
					parent: r.parent,
					contents: h3(r.contents),
				})),
			},
		};
	} catch {
		return !1;
	}
}
function RC(t) {
	const e = ee(37),
		[n, r] = E.useState(!1),
		i = On();
	let o, s;
	e[0] !== t.component.schema
		? ((s = { kind: "object", fields: t.component.schema }),
			(e[0] = t.component.schema),
			(e[1] = s))
		: (s = e[1]),
		(o = s);
	const a = o,
		l = Du(t.node.attrs.props, t.component.schema),
		u = `${_r.blockParent} ${X({ marginBlock: "1em", position: "relative", ...(t.hasNodeSelection ? { "&::after": { backgroundColor: B.color.alias.backgroundSelected, borderRadius: B.size.radius.regular, content: "''", inset: 0, pointerEvents: "none", position: "absolute" } } : {}) })}${t.hasNodeSelection ? ` ${_r.hideselection}` : ""}`,
		c = t.hasNodeSelection
			? "color.alias.borderSelected"
			: "color.alias.borderDisabled",
		d = t.hasNodeSelection
			? "color.alias.backgroundSelected"
			: "color.alias.backgroundIdle",
		f = t.hasNodeSelection
			? B.color.foreground.accent
			: B.color.foreground.neutralTertiary;
	let h;
	e[2] !== f
		? ((h = X({
				color: f,
				textTransform: "uppercase",
				fontWeight: B.typography.fontWeight.semibold,
				fontSize: "0.9rem",
			})),
			(e[2] = f),
			(e[3] = h))
		: (h = e[3]);
	let p;
	e[4] !== i || e[5] !== t
		? ((p = () => {
				i(
					(S, $) => (
						$ && $(S.tr.setSelection(Qe.create(S.doc, t.getPos()))),
						!0
					),
				);
			}),
			(e[4] = i),
			(e[5] = t),
			(e[6] = p))
		: (p = e[6]);
	let g;
	e[7] !== h || e[8] !== p || e[9] !== t.component.label
		? ((g = m.jsx(pr, {
				flex: 1,
				paddingX: "regular",
				paddingY: "small",
				UNSAFE_className: h,
				onClick: p,
				children: t.component.label,
			})),
			(e[7] = h),
			(e[8] = p),
			(e[9] = t.component.label),
			(e[10] = g))
		: (g = e[10]);
	let v;
	e[11] !== t.component.schema
		? ((v =
				!!Object.keys(t.component.schema).length &&
				m.jsx(vt, {
					prominence: "low",
					onPress: () => {
						r(!0);
					},
					UNSAFE_className: X({ borderBottomRightRadius: 0 }),
					children: "Edit",
				})),
			(e[11] = t.component.schema),
			(e[12] = v))
		: (v = e[12]);
	let b;
	e[13] !== d || e[14] !== g || e[15] !== t.toolbar || e[16] !== v
		? ((b = m.jsxs(ke, {
				backgroundColor: d,
				contentEditable: !1,
				alignItems: "center",
				"data-ignore-content": "",
				children: [g, t.toolbar, v],
			})),
			(e[13] = d),
			(e[14] = g),
			(e[15] = t.toolbar),
			(e[16] = v),
			(e[17] = b))
		: (b = e[17]);
	let y;
	e[18] !== t.children
		? ((y = m.jsx(pr, { padding: "regular", children: t.children })),
			(e[18] = t.children),
			(e[19] = y))
		: (y = e[19]);
	let x;
	e[20] !== u || e[21] !== c || e[22] !== b || e[23] !== y
		? ((x = m.jsxs(pr, {
				UNSAFE_className: u,
				border: c,
				borderRadius: "regular",
				children: [b, y],
			})),
			(e[20] = u),
			(e[21] = c),
			(e[22] = b),
			(e[23] = y),
			(e[24] = x))
		: (x = e[24]);
	let C;
	e[25] === Symbol.for("react.memo_cache_sentinel")
		? ((C = () => {
				r(!1);
			}),
			(e[25] = C))
		: (C = e[25]);
	let k;
	e[26] !== n || e[27] !== t || e[28] !== i || e[29] !== a || e[30] !== l
		? ((k =
				n &&
				m.jsxs(vr, {
					children: [
						m.jsxs(Ut, { children: ["Edit ", t.component.label] }),
						m.jsx(Y3, {
							schema: a,
							value: l,
							onSave: (S) => {
								i(
									($, A) => (
										A &&
											A(
												$.tr.setNodeAttribute(
													t.getPos(),
													"props",
													fn(S, a.fields),
												),
											),
										!0
									),
								);
							},
						}),
					],
				})),
			(e[26] = n),
			(e[27] = t),
			(e[28] = i),
			(e[29] = a),
			(e[30] = l),
			(e[31] = k))
		: (k = e[31]);
	let w;
	e[32] !== k
		? ((w = m.jsx(mn, { onDismiss: C, children: k })),
			(e[32] = k),
			(e[33] = w))
		: (w = e[33]);
	let D;
	return (
		e[34] !== x || e[35] !== w
			? ((D = m.jsxs(m.Fragment, { children: [x, w] })),
				(e[34] = x),
				(e[35] = w),
				(e[36] = D))
			: (D = e[36]),
		D
	);
}
function P7e(t) {
	const e = new Map(Object.keys(t).map((n, r) => [n, `component${r}`]));
	return Object.fromEntries(
		Object.entries(t).flatMap(([n, r]) => {
			let i;
			const o = { kind: "object", fields: r.schema };
			if (r.kind === "block")
				i = {
					group: `${r.forSpecificLocations ? "" : "block "}${e.get(n)}`,
					defining: !0,
					attrs: { props: { default: fn(an(o), o.fields) } },
					reactNodeView: {
						component: function (a) {
							const l = On(),
								u = Du(a.node.attrs.props, r.schema);
							return "NodeView" in r && r.NodeView
								? m.jsx(r.NodeView, {
										isSelected:
											a.hasNodeSelection ||
											a.isNodeCompletelyWithinSelection,
										onRemove: () => {
											l((c, d) => {
												if (d) {
													const f = a.getPos();
													d(
														c.tr.delete(
															f,
															f + a.node.nodeSize,
														),
													);
												}
												return !0;
											});
										},
										onChange: (c) => {
											l(
												(d, f) => (
													f &&
														f(
															d.tr.setNodeAttribute(
																a.getPos(),
																"props",
																fn(c, o.fields),
															),
														),
													!0
												),
											);
										},
										value: u,
									})
								: m.jsx(RC, {
										node: a.node,
										hasNodeSelection:
											a.hasNodeSelection ||
											a.isNodeCompletelyWithinSelection,
										component: r,
										getPos: a.getPos,
										children:
											"ContentView" in r &&
											r.ContentView &&
											m.jsx(r.ContentView, { value: u }),
									});
						},
						rendersOwnContent: !1,
					},
					parseDOM: [
						{
							tag: `div[data-component="${n}"]`,
							getAttrs(s) {
								return typeof s == "string" ? !1 : fm(s);
							},
						},
					],
					toDOM(s) {
						return [
							"div",
							{
								"data-component": n,
								"data-props": dm(s.attrs.props),
							},
						];
					},
					insertMenu: r.forSpecificLocations
						? void 0
						: {
								label: r.label,
								command: Wf,
								forToolbar: !0,
								description: r.description,
								icon: r.icon,
							},
				};
			else if (r.kind === "wrapper")
				i = {
					group: `${r.forSpecificLocations ? "" : "block "}${e.get(n)}`,
					content: "block+",
					defining: !0,
					attrs: { props: { default: fn(an(o), o.fields) } },
					reactNodeView: {
						component: function (a) {
							const l = On(),
								u = Du(a.node.attrs.props, r.schema);
							return "NodeView" in r && r.NodeView
								? m.jsx(r.NodeView, {
										isSelected:
											a.hasNodeSelection ||
											a.isNodeCompletelyWithinSelection,
										onRemove: () => {
											l((c, d) => {
												if (d) {
													const f = a.getPos();
													d(
														c.tr.delete(
															f,
															f + a.node.nodeSize,
														),
													);
												}
												return !0;
											});
										},
										onChange: (c) => {
											l(
												(d, f) => (
													f &&
														f(
															d.tr.setNodeAttribute(
																a.getPos(),
																"props",
																fn(c, o.fields),
															),
														),
													!0
												),
											);
										},
										value: u,
										children: a.children,
									})
								: m.jsx(RC, {
										node: a.node,
										hasNodeSelection:
											a.hasNodeSelection ||
											a.isNodeCompletelyWithinSelection,
										component: r,
										getPos: a.getPos,
										children:
											"ContentView" in r && r.ContentView
												? m.jsx(r.ContentView, {
														value: u,
														children: a.children,
													})
												: a.children,
									});
						},
						rendersOwnContent: !1,
					},
					toDOM(s) {
						return [
							"div",
							{
								"data-component": n,
								"data-props": dm(s.attrs.props),
							},
							0,
						];
					},
					parseDOM: [
						{ tag: `div[data-component="${n}"]`, getAttrs: fm },
					],
					insertMenu: r.forSpecificLocations
						? void 0
						: {
								label: r.label,
								command: Wf,
								forToolbar: !0,
								description: r.description,
								icon: r.icon,
							},
				};
			else if (r.kind === "inline")
				i = {
					group: "inline",
					inline: !0,
					attrs: { props: { default: fn(an(o), o.fields) } },
					toDOM: (s) => [
						"span",
						{
							"data-component": n,
							"data-props": dm(s.attrs.props),
						},
					],
					parseDOM: [
						{ tag: `span[data-component="${n}"]`, getAttrs: fm },
					],
					reactNodeView: {
						component: function (a) {
							const l = Du(a.node.attrs.props, r.schema),
								u = On();
							return "NodeView" in r && r.NodeView
								? m.jsx("span", {
										contentEditable: !1,
										children: m.jsx(r.NodeView, {
											value: l,
											onChange: (c) => {
												u(
													(d, f) => (
														f &&
															f(
																d.tr.setNodeAttribute(
																	a.getPos(),
																	"props",
																	fn(
																		c,
																		o.fields,
																	),
																),
															),
														!0
													),
												);
											},
											isSelected:
												a.hasNodeSelection ||
												a.isNodeCompletelyWithinSelection,
											onRemove: () => {
												u((c, d) => {
													if (d) {
														const f = a.getPos();
														d(
															c.tr.delete(
																f,
																f +
																	a.node
																		.nodeSize,
															),
														);
													}
													return !0;
												});
											},
										}),
									})
								: "ContentView" in r && r.ContentView
									? m.jsx(pr, {
											elementType: "span",
											contentEditable: !1,
											border: a.hasNodeSelection
												? "color.alias.borderSelected"
												: "color.alias.borderIdle",
											borderRadius: "regular",
											children: m.jsx(r.ContentView, {
												value: l,
											}),
										})
									: m.jsx(pr, {
											elementType: "span",
											contentEditable: !1,
											border: a.hasNodeSelection
												? "color.alias.borderSelected"
												: "color.alias.borderIdle",
											"data-component": n,
											borderRadius: "regular",
											UNSAFE_className: X({
												"::after": {
													content:
														"attr(data-component)",
												},
											}),
										});
						},
						rendersOwnContent: !1,
					},
					insertMenu: {
						label: r.label,
						command: Wf,
						forToolbar: !0,
						description: r.description,
						icon: r.icon,
					},
				};
			else if (r.kind === "repeating") {
				const s = r.children.map((a) => ({
					key: a,
					label: t[a].label,
				}));
				i = {
					group: `${r.forSpecificLocations ? "" : "block "}${e.get(n)}`,
					content: `(${r.children.map((a) => e.get(a)).join(" | ")}){${r.validation.children.min},${r.validation.children.max === 1 / 0 ? "" : r.validation.children.max}}`,
					defining: !0,
					attrs: { props: { default: fn(an(o), o.fields) } },
					reactNodeView: {
						component: function (l) {
							const u = On(),
								c = Du(l.node.attrs.props, r.schema);
							return "NodeView" in r && r.NodeView
								? m.jsx(r.NodeView, {
										isSelected:
											l.hasNodeSelection ||
											l.isNodeCompletelyWithinSelection,
										onRemove: () => {
											u((d, f) => {
												if (f) {
													const h = l.getPos();
													f(
														d.tr.delete(
															h,
															h + l.node.nodeSize,
														),
													);
												}
												return !0;
											});
										},
										onChange: (d) => {
											u(
												(f, h) => (
													h &&
														h(
															f.tr.setNodeAttribute(
																l.getPos(),
																"props",
																fn(d, o.fields),
															),
														),
													!0
												),
											);
										},
										value: c,
										children: l.children,
									})
								: m.jsx(RC, {
										node: l.node,
										hasNodeSelection:
											l.hasNodeSelection ||
											l.isNodeCompletelyWithinSelection,
										component: r,
										getPos: l.getPos,
										toolbar:
											l.node.contentMatchAt(
												l.node.childCount,
											).defaultType &&
											(r.children.length === 1
												? m.jsx(vt, {
														onPress: () => {
															u(
																(d, f) => (
																	f &&
																		f(
																			d.tr.insert(
																				l.getPos() +
																					l
																						.node
																						.nodeSize -
																					1,
																				d.schema.nodes[
																					r
																						.children[0]
																				].createAndFill(),
																			),
																		),
																	!0
																),
															);
														},
														children: "Insert",
													})
												: m.jsxs(Xo, {
														children: [
															m.jsx(vt, {
																children:
																	"Insert",
															}),
															m.jsx(Jo, {
																onAction: (
																	d,
																) => {
																	u(
																		(
																			f,
																			h,
																		) => (
																			h &&
																				h(
																					f.tr.insert(
																						l.getPos() +
																							l
																								.node
																								.nodeSize -
																							1,
																						f.schema.nodes[
																							d
																						].createAndFill(),
																					),
																				),
																			!0
																		),
																	);
																},
																items: s,
																children: (d) =>
																	m.jsx(
																		Mt,
																		{
																			children:
																				d.label,
																		},
																		d.key,
																	),
															}),
														],
													})),
										children:
											"ContentView" in r && r.ContentView
												? m.jsx(r.ContentView, {
														value: c,
														children: l.children,
													})
												: l.children,
									});
						},
						rendersOwnContent: !1,
					},
					toDOM(a) {
						return [
							"div",
							{
								"data-component": n,
								"data-props": dm(a.attrs.props),
							},
							0,
						];
					},
					parseDOM: [
						{ tag: `div[data-component="${n}"]`, getAttrs: fm },
					],
					insertMenu: r.forSpecificLocations
						? void 0
						: {
								label: r.label,
								command: Wf,
								forToolbar: !0,
								description: r.description,
								icon: r.icon,
							},
				};
			}
			return i ? [[n, i]] : [];
		}),
	);
}
function N7e(t) {
	return Object.fromEntries(
		Object.entries(t).flatMap(([e, n]) => {
			var r;
			if (n.kind !== "mark") return [];
			const i = { kind: "object", fields: n.schema },
				o = (r = n.tag) !== null && r !== void 0 ? r : "span",
				s = {
					attrs: { props: { default: fn(an(i), i.fields) } },
					toDOM(a) {
						const l = document.createElement(o);
						l.setAttribute("data-component", e),
							l.setAttribute("data-props", dm(a.attrs.props));
						let u,
							c = () => (
								u || (u = vA(a.attrs.props, n.schema)), u
							);
						return (
							typeof n.className == "function"
								? (l.className = n.className({ value: c() }))
								: typeof n.className == "string" &&
									(l.className = n.className),
							typeof n.style == "function"
								? Object.assign(
										l.style,
										n.style({ value: c() }),
									)
								: n.style && Object.assign(l.style, n.style),
							l
						);
					},
					parseDOM: [
						{ tag: `${o}[data-component="${e}"]`, getAttrs: fm },
					],
				};
			return [[e, s]];
		}),
	);
}
const R7e = X({ marginBlock: "1em" }),
	O7e = ["p", { class: R7e }, 0],
	M7e = [
		"blockquote",
		{
			class: Se(
				_r.blockParent,
				X({
					[`&.${_r.nodeInSelection}, &.${_r.nodeSelection}`]: {
						borderColor: B.color.alias.borderSelected,
					},
				}),
			),
		},
		0,
	],
	j7e = [
		"hr",
		{
			contenteditable: "false",
			class: X({
				cursor: "pointer",
				[`&.${_r.nodeInSelection}, &.${_r.nodeSelection}`]: {
					backgroundColor: B.color.alias.borderSelected,
				},
			}),
		},
	],
	_7e = ["pre", { spellcheck: "false" }, ["code", {}, 0]],
	z7e = ["br"],
	L7e = ["ol", {}, 0],
	V7e = ["ul", {}, 0],
	K7e = ["li", {}, 0],
	JJ = "inline*",
	U7e = [
		{ description: "Use this for a top level heading", icon: Ece },
		{ description: "Use this for key sections", icon: Dce },
		{ description: "Use this for sub-sections", icon: Sce },
		{ description: "Use this for deep headings", icon: Ace },
		{ description: "Use this for grouping list items", icon: $ce },
		{ description: "Use this for low-level headings", icon: Tce },
	],
	e8 = { colspan: { default: 1 }, rowspan: { default: 1 } },
	XJ = X({
		borderBottom: `1px solid ${B.color.alias.borderIdle}`,
		borderInlineEnd: `1px solid ${B.color.alias.borderIdle}`,
		boxSizing: "border-box",
		margin: 0,
		padding: B.size.space.regular,
		position: "relative",
		textAlign: "start",
		verticalAlign: "top",
		"&.selectedCell": {
			backgroundColor: B.color.alias.backgroundSelected,
			"& *::selection": { backgroundColor: "transparent" },
		},
		"&.selectedCell::after": {
			border: `1px solid ${B.color.alias.borderSelected}`,
			position: "absolute",
			top: -1,
			left: -1,
			content: '""',
			height: "100%",
			width: "100%",
		},
	}),
	H7e = X(XJ, {
		backgroundColor: B.color.scale.slate3,
		fontWeight: B.typography.fontWeight.semibold,
	}),
	wr = {
		doc: { content: "block+" },
		paragraph: {
			content: JJ,
			group: "block",
			parseDOM: [
				{ tag: "p" },
				{ tag: "[data-ignore-content]", ignore: !0 },
			],
			toDOM() {
				return O7e;
			},
		},
		text: { group: "inline" },
		blockquote: {
			content: "block+",
			group: "block",
			defining: !0,
			parseDOM: [{ tag: "blockquote" }],
			toDOM() {
				return M7e;
			},
			insertMenu: {
				label: "Blockquote",
				description: "Insert a quote or citation",
				icon: JD,
				command: Sj,
			},
		},
		divider: {
			group: "block",
			parseDOM: [{ tag: "hr" }],
			toDOM() {
				return j7e;
			},
			insertMenu: {
				label: "Divider",
				description: "A horizontal line to separate content",
				icon: Bce,
				command: Wf,
			},
		},
		code_block: {
			content: "text*",
			group: "block",
			defining: !0,
			[gA]: !0,
			attrs: { language: { default: "" } },
			insertMenu: {
				label: "Code block",
				description: "Display code with syntax highlighting",
				icon: wce,
				command: yd,
			},
			marks: "",
			code: !0,
			parseDOM: [{ tag: "pre", preserveWhitespace: "full" }],
			toDOM() {
				return _7e;
			},
		},
		list_item: {
			content: "block+",
			parseDOM: [{ tag: "li" }],
			toDOM() {
				return K7e;
			},
			defining: !0,
		},
		unordered_list: {
			content: "list_item+",
			group: "block",
			parseDOM: [{ tag: "ul" }],
			toDOM() {
				return V7e;
			},
			insertMenu: {
				label: "Bullet list",
				description: "Insert an unordered list",
				icon: jv,
				command: dd,
			},
		},
		ordered_list: {
			content: "list_item+",
			group: "block",
			attrs: { start: { default: 1 } },
			parseDOM: [
				{
					tag: "ol",
					getAttrs: (t) =>
						typeof t == "string"
							? !1
							: !(t instanceof HTMLOListElement) || t.start < 0
								? { start: 1 }
								: { start: t.start },
				},
			],
			toDOM(t) {
				return t.attrs.start === 1
					? L7e
					: ["ol", { start: t.attrs.start }, 0];
			},
			insertMenu: {
				label: "Ordered list",
				description: "Insert an ordered list",
				icon: YD,
				command: dd,
			},
		},
		hard_break: {
			inline: !0,
			group: "inline",
			selectable: !1,
			parseDOM: [{ tag: "br" }],
			toDOM() {
				return z7e;
			},
		},
		table: {
			content: "table_row+",
			insertMenu: {
				label: "Table",
				description: "Insert a table",
				icon: XD,
				command: GJ,
			},
			tableRole: "table",
			isolating: !0,
			group: "block",
			parseDOM: [{ tag: "table" }],
			toDOM() {
				return [
					"table",
					{
						class: X({
							width: "100%",
							tableLayout: "fixed",
							position: "relative",
							borderSpacing: 0,
							borderInlineStart: `1px solid ${B.color.alias.borderIdle}`,
							borderTop: `1px solid ${B.color.alias.borderIdle}`,
							"&:has(.selectedCell) *::selection": {
								backgroundColor: "transparent",
							},
							".ProseMirror-widget + *": { marginTop: 0 },
						}),
					},
					["tbody", 0],
				];
			},
		},
		table_row: {
			content: "(table_cell | table_header)*",
			tableRole: "row",
			allowGapCursor: !1,
			parseDOM: [{ tag: "tr" }],
			toDOM() {
				return ["tr", 0];
			},
		},
		table_cell: {
			content: "block+",
			tableRole: "cell",
			isolating: !0,
			attrs: e8,
			parseDOM: [{ tag: "td" }],
			toDOM() {
				return ["td", { class: XJ }, 0];
			},
		},
		table_header: {
			content: "block+",
			tableRole: "header_cell",
			attrs: e8,
			isolating: !0,
			parseDOM: [{ tag: "th" }],
			toDOM() {
				return ["th", { class: H7e }, 0];
			},
		},
		image: {
			content: "",
			group: "inline",
			inline: !0,
			attrs: {
				src: {},
				filename: {},
				alt: { default: "" },
				title: { default: "" },
			},
			insertMenu: {
				label: "Image",
				description: "Insert an image",
				icon: E0,
				command: (t) => (e, n, r) => (
					n &&
						r &&
						(async () => {
							const i = await q3("image/*"),
								o = kr(t.schema);
							!i ||
								!o.config.image ||
								r.dispatch(
									r.state.tr.replaceSelectionWith(
										t.createChecked({
											src: new Uint8Array(
												await i.arrayBuffer(),
											),
											filename:
												o.config.image.transformFilename(
													i.name,
												),
										}),
									),
								);
						})(),
					!0
				),
			},
			nodeView(t) {
				const e = new Blob([t.attrs.src], {
						type: t.attrs.filename.endsWith(".svg")
							? "image/svg+xml"
							: void 0,
					}),
					n = document.createElement("img");
				return (
					(n.src = URL.createObjectURL(e)),
					(n.alt = t.attrs.alt),
					(n.title = t.attrs.title),
					(n.dataset.filename = t.attrs.filename),
					n.classList.add(
						X({
							boxSizing: "border-box",
							borderRadius: B.size.radius.regular,
							display: "inline-block",
							maxHeight: B.size.scale[3600],
							maxWidth: "100%",
							transition: bt("box-shadow"),
							"&::selection": { backgroundColor: "transparent" },
						}),
					),
					{
						dom: n,
						destroy() {
							URL.revokeObjectURL(n.src);
						},
					}
				);
			},
			toDOM(t) {
				return [
					"img",
					{
						src: `data:${t.attrs.filename.endsWith(".svg") ? "image/svg+xml" : "application/octet-stream"};base64,${nd(t.attrs.src)}`,
						alt: t.attrs.alt,
						title: t.attrs.title,
						"data-filename": t.attrs.filename,
					},
				];
			},
			parseDOM: [
				{
					tag: "img[src][data-filename]",
					getAttrs(t) {
						var e, n;
						if (typeof t == "string") return !1;
						const r = t.getAttribute("src"),
							i = t.getAttribute("data-filename");
						return !(r != null && r.startsWith("data:")) || !i
							? !1
							: {
									src: h3(
										r.replace(/^data:[a-z/-]+;base64,/, ""),
									),
									filename: i,
									alt:
										(e = t.getAttribute("alt")) !== null &&
										e !== void 0
											? e
											: "",
									title:
										(n = t.getAttribute("title")) !==
											null && n !== void 0
											? n
											: "",
								};
					},
				},
			],
		},
	},
	W7e = ["em", 0],
	q7e = ["strong", 0],
	G7e = ["code", 0],
	Y7e = ["s", 0],
	Vp = {
		link: {
			attrs: { href: {}, title: { default: "" } },
			inclusive: !1,
			parseDOM: [
				{
					tag: "a[href]",
					getAttrs(t) {
						var e;
						if (typeof t == "string") return !1;
						const n = t.getAttribute("href");
						return n
							? {
									href: n,
									title:
										(e = t.getAttribute("title")) !==
											null && e !== void 0
											? e
											: "",
								}
							: !1;
					},
				},
			],
			toDOM(t) {
				return [
					"a",
					{
						href: t.attrs.href,
						title: t.attrs.title === "" ? void 0 : t.attrs.title,
					},
					0,
				];
			},
		},
		italic: {
			shortcuts: ["Mod-i", "Mod-I"],
			parseDOM: [
				{ tag: "i" },
				{ tag: "em" },
				{ style: "font-style=italic" },
				{
					style: "font-style=normal",
					clearMark: (t) => t.type.name == "italic",
				},
			],
			toDOM() {
				return W7e;
			},
		},
		bold: {
			shortcuts: ["Mod-b", "Mod-B"],
			parseDOM: [
				{ tag: "strong" },
				{
					tag: "b",
					getAttrs: (t) =>
						typeof t == "string"
							? !1
							: t.style.fontWeight != "normal" && null,
				},
				{
					style: "font-weight=400",
					clearMark: (t) => t.type.name == "strong",
				},
				{
					style: "font-weight",
					getAttrs: (t) =>
						typeof t == "string"
							? /^(bold(er)?|[5-9]\d{2,})$/.test(t) && null
							: !1,
				},
			],
			toDOM() {
				return q7e;
			},
		},
		strikethrough: {
			shortcuts: ["Mod-Shift-s", "Mod-Shift-S"],
			parseDOM: [{ tag: "s" }],
			toDOM() {
				return Y7e;
			},
		},
		code: {
			shortcuts: ["Mod-`", "Mod-Shift-M", "Mod-E", "Mod-e"],
			parseDOM: [{ tag: "code" }],
			toDOM() {
				return G7e;
			},
		},
	};
function J3(t, e, n) {
	const r = {
		doc: wr.doc,
		paragraph: wr.paragraph,
		text: wr.text,
		hard_break: wr.hard_break,
		...P7e(e),
	};
	t.blockquote && (r.blockquote = wr.blockquote),
		t.divider && (r.divider = wr.divider),
		t.codeBlock &&
			(r.code_block = {
				...wr.code_block,
				attrs: {
					...wr.code_block.attrs,
					props: {
						default: fn(
							an({ kind: "object", fields: t.heading.schema }),
							t.heading.schema,
						),
					},
				},
			}),
		t.orderedList && (r.ordered_list = wr.ordered_list),
		t.unorderedList && (r.unordered_list = wr.unordered_list),
		(t.orderedList || t.unorderedList) && (r.list_item = wr.list_item),
		t.heading.levels.length &&
			(r.heading = {
				attrs: {
					level: { default: t.heading.levels[0] },
					props: {
						default: fn(
							an({ kind: "object", fields: t.heading.schema }),
							t.heading.schema,
						),
					},
				},
				content: JJ,
				group: "block",
				parseDOM: t.heading.levels.map((c) => ({
					tag: "h" + c,
					attrs: { level: c },
				})),
				defining: !0,
				toDOM(c) {
					return ["h" + c.attrs.level, 0];
				},
				insertMenu: t.heading.levels.map((c, d) => ({
					...U7e[d],
					label: "Heading " + c,
					command: (f) => yd(f, { level: c }),
				})),
			}),
		t.table &&
			((r.table = wr.table),
			(r.table_row = wr.table_row),
			n
				? (r.table_cell = { ...wr.table_cell, content: "paragraph" })
				: (r.table_cell = wr.table_cell),
			(r.table_header = wr.table_header)),
		t.image && (r.image = wr.image);
	const i = { ...N7e(e) };
	t.link && (i.link = Vp.link),
		t.italic && (i.italic = Vp.italic),
		t.bold && (i.bold = Vp.bold),
		t.strikethrough && (i.strikethrough = Vp.strikethrough),
		t.code && (i.code = Vp.code);
	const o = new aae({ nodes: r, marks: i }),
		s = o.nodes,
		a = o.marks,
		l = {
			schema: o,
			marks: a,
			nodes: s,
			config: t,
			components: e,
			insertMenuItems: [],
			format: n ? "mdx" : "markdoc",
		};
	ZJ.set(o, l);
	const u = [];
	for (const c of Object.values(o.nodes)) {
		const d = c.spec.insertMenu;
		if (d)
			if (Array.isArray(d))
				for (const f of d)
					u.push({
						label: f.label,
						description: f.description,
						icon: f.icon,
						command: f.command(c, l),
						forToolbar: f.forToolbar,
					});
			else
				u.push({
					label: d.label,
					description: d.description,
					icon: d.icon,
					command: d.command(c, l),
					forToolbar: d.forToolbar,
				});
	}
	return (
		(l.insertMenuItems = u
			.sort((c, d) => c.label.localeCompare(d.label))
			.map((c, d) => ({ ...c, id: d.toString() }))),
		l
	);
}
const ZJ = new WeakMap();
function kr(t) {
	const e = ZJ.get(t);
	if (!e) throw new Error("No editor schema for schema");
	return e;
}
const QJ = le.createContext(null);
function Fa() {
	const t = E.useContext(QJ);
	if (t === null)
		throw new Error(
			"useEditorState must be used inside ProseMirrorEditorView",
		);
	return t;
}
function On() {
	return X3().dispatchCommand;
}
function ca() {
	return X3().schema;
}
function af() {
	return X3().view;
}
function J7e() {
	const t = af(),
		e = Fa();
	return E.useCallback(() => {
		if (t.current && t.current.state !== e) {
			var n;
			(n = t.current) === null || n === void 0 || n.updateState(e);
		}
		return t.current;
	}, [t, e]);
}
function X7e(t, e) {
	const n = E.useRef(null),
		r = E.useRef(null),
		i = Jn(),
		o = qJ(e);
	return (
		E.useLayoutEffect(() => {
			if (n.current === null) return;
			const s = new Mwe(
				{ mount: n.current },
				{
					state: t,
					config: i,
					dispatchTransaction(a) {
						const l = s.state.apply(a);
						s.updateState(l), o(l);
					},
				},
			);
			return (
				(r.current = s),
				() => {
					s.destroy(), (r.current = null);
				}
			);
		}, [n, o, i]),
		E.useLayoutEffect(() => {
			var s;
			(s = r.current) === null || s === void 0 || s.updateState(t);
		}, [t]),
		{ view: r, mount: n }
	);
}
function Z7e(t) {
	const { mount: e } = X3();
	return m.jsx("div", { ...t, ref: e });
}
const eX = le.createContext(null);
function X3() {
	const t = E.useContext(eX);
	if (t === null)
		throw new Error(
			"editor hooks must be used inside a ProseMirrorEditorView",
		);
	return t;
}
const Q7e = E.forwardRef(function (e, n) {
	const { view: r, mount: i } = X7e(e.value, e.onChange);
	E.useImperativeHandle(
		n,
		() => ({
			get view() {
				return r.current;
			},
		}),
		[r],
	);
	const o = E.useMemo(
		() => ({
			view: r,
			mount: i,
			dispatchCommand: (s) => {
				r.current &&
					(s(r.current.state, r.current.dispatch, r.current),
					r.current.focus());
			},
			schema: kr(e.value.schema),
		}),
		[i, e.value.schema, r],
	);
	return m.jsx(eX.Provider, {
		value: o,
		children: m.jsx(QJ.Provider, { value: e.value, children: e.children }),
	});
});
function Z3(t, e) {
	return Nu(typeof t.image == "object" ? t.image.publicPath : void 0, e);
}
function eFe(t) {
	const e = t.nodes.image;
	return new Gn({
		props: {
			handleDrop(n, r) {
				var i;
				if (
					(i = r.dataTransfer) !== null &&
					i !== void 0 &&
					i.files.length
				) {
					const o = r.dataTransfer.files[0];
					let s = n.posAtCoords({ left: r.clientX, top: r.clientY });
					if (!s) return;
					let a = n.state.doc.resolve(s.pos);
					for (const [l, u] of Object.entries(t.components)) {
						if (
							(u.kind !== "block" && u.kind !== "inline") ||
							!u.handleFile
						)
							continue;
						const c = u.handleFile(o, n.props.config);
						if (c)
							return (
								(async () => {
									const d = await c,
										f = Ee.maxOpen(
											be.from(
												t.schema.nodes[l].createChecked(
													{ props: fn(d, u.schema) },
												),
											),
										),
										h = Iv(
											n.state.doc,
											n.state.selection.from,
											f,
										);
									h !== null &&
										n.dispatch(n.state.tr.replace(h, h, f));
								})(),
								!0
							);
					}
					if (o.type.startsWith("image/") && e && t.config.image) {
						const { transformFilename: l } = t.config.image;
						return (
							(async () => {
								const u = Ee.maxOpen(
										be.from(
											e.createChecked({
												src: new Uint8Array(
													await o.arrayBuffer(),
												),
												filename: l(o.name),
											}),
										),
									),
									c = Iv(n.state.doc, a.pos, u);
								if (c === null) return !1;
								n.dispatch(n.state.tr.replace(c, c, u));
							})(),
							!0
						);
					}
				}
			},
			handlePaste(n, r) {
				var i;
				if (
					(i = r.clipboardData) !== null &&
					i !== void 0 &&
					i.files.length
				) {
					const o = r.clipboardData.files[0];
					for (const [s, a] of Object.entries(t.components)) {
						if (a.kind !== "block" || !a.handleFile) continue;
						const l = a.handleFile(o, n.props.config);
						if (l)
							return (
								(async () => {
									const u = await l;
									n.dispatch(
										n.state.tr.replaceSelectionWith(
											t.schema.nodes[s].createChecked({
												props: fn(u, a.schema),
											}),
										),
									);
								})(),
								!0
							);
					}
					if (o.type.startsWith("image/") && e && t.config.image) {
						const { transformFilename: s } = t.config.image;
						return (
							(async () =>
								n.dispatch(
									n.state.tr.replaceSelectionWith(
										e.createChecked({
											src: new Uint8Array(
												await o.arrayBuffer(),
											),
											filename: s(o.name),
										}),
									),
								))(),
							!0
						);
					}
				}
			},
		},
	});
}
function tFe() {
	const t = ee(3);
	let e;
	t[0] === Symbol.for("react.memo_cache_sentinel")
		? ((e = (i, o, s) => (
				o &&
					s &&
					(async () => {
						const a = await q3("image/*"),
							l = kr(s.state.schema);
						!a ||
							!l.config.image ||
							s.dispatch(
								s.state.tr.replaceSelectionWith(
									s.state.schema.nodes.image.createChecked({
										src: new Uint8Array(
											await a.arrayBuffer(),
										),
										filename:
											l.config.image.transformFilename(
												a.name,
											),
									}),
								),
							);
					})(),
				!0
			)),
			(t[0] = e))
		: (e = t[0]);
	let n;
	t[1] === Symbol.for("react.memo_cache_sentinel")
		? ((n = m.jsx(Gf, {
				"aria-label": "Image",
				command: e,
				children: m.jsx(ve, { src: E0 }),
			})),
			(t[1] = n))
		: (n = t[1]);
	let r;
	return (
		t[2] === Symbol.for("react.memo_cache_sentinel")
			? ((r = m.jsxs(Ze, {
					children: [
						n,
						m.jsx(Xe, {
							children: m.jsx(ue, { children: "Image" }),
						}),
					],
				})),
				(t[2] = r))
			: (r = t[2]),
		r
	);
}
const tl = new Os("AutocompleteDecoration");
function nFe(t, e) {
	return e.find(t.from, t.to).length > 0;
}
const t8 = { kind: "inactive" };
function rFe(t, e, n, r, i) {
	return t.setMeta(tl, {
		action: "add",
		from: n,
		to: r,
		menu: e,
		pattern: i,
	});
}
function iFe() {
	const t = ee(4),
		e = Fa();
	let n;
	t[0] !== e ? ((n = tl.getState(e)), (t[0] = e), (t[1] = n)) : (n = t[1]);
	const r = n;
	if (!r || r.kind === "inactive") return null;
	let i;
	return (
		t[2] !== r
			? ((i = m.jsx(oFe, { state: r })), (t[2] = r), (t[3] = i))
			: (i = t[3]),
		i
	);
}
function oFe(t) {
	const e = ee(9),
		n = Fa();
	let r, i;
	e[0] !== t.state.decorations || e[1] !== n.doc
		? ((i = t.state.decorations.find()[0]),
			(r = n.doc.textBetween(i.from, i.to).slice(1)),
			(e[0] = t.state.decorations),
			(e[1] = n.doc),
			(e[2] = r),
			(e[3] = i))
		: ((r = e[2]), (i = e[3]));
	const o = r;
	let s;
	return (
		e[4] !== t.state.component ||
		e[5] !== o ||
		e[6] !== i.from ||
		e[7] !== i.to
			? ((s = m.jsx(t.state.component, {
					query: o,
					from: i.from,
					to: i.to,
				})),
				(e[4] = t.state.component),
				(e[5] = o),
				(e[6] = i.from),
				(e[7] = i.to),
				(e[8] = s))
			: (s = e[8]),
		s
	);
}
function Q3(t) {
	return t.setMeta(tl, { action: "remove" });
}
function sFe(t) {
	const e = tl.getState(t);
	if ((e == null ? void 0 : e.kind) === "active")
		return e.decorations.find()[0];
}
function tX(t) {
	const e = sFe(t);
	if (e) return Q3(t.tr.delete(e.from, e.to));
}
const aFe = X({ color: B.color.foreground.accent });
function lFe() {
	return new Gn({
		key: tl,
		state: {
			init: () => ({ kind: "inactive" }),
			apply(t, e, n, r) {
				const i = t.getMeta(tl);
				if ((i == null ? void 0 : i.action) === "add") {
					const d = Hn.inline(
							i.from,
							i.to,
							{ nodeName: "decoration-autocomplete", class: aFe },
							{ inclusiveStart: !1, inclusiveEnd: !0 },
						),
						f = r.doc.textBetween(i.from, i.to, ""),
						h = qt.create(t.doc, [d]);
					return {
						kind: "active",
						trigger: f,
						decorations: h,
						component: i.menu,
						pattern: i.pattern,
					};
				}
				if (e.kind === "inactive") return e;
				const o = e.decorations.map(t.mapping, t.doc),
					s = o.find();
				if (
					(i == null ? void 0 : i.action) === "remove" ||
					!nFe(t.selection, o) ||
					s.length !== 1
				)
					return t8;
				const { from: a, to: l } = s[0],
					u = "�",
					c = r.doc.textBetween(a, l, u, u);
				return e.trigger !== c.slice(0, e.trigger.length) ||
					c.includes(u) ||
					(e.pattern && !e.pattern.test(c))
					? t8
					: { ...e, decorations: o };
			},
		},
		props: {
			decorations: (t) => {
				const e = tl.getState(t);
				return (e == null ? void 0 : e.kind) === "active"
					? e.decorations
					: qt.empty;
			},
			handlePaste: n8,
			handleDrop: n8,
			handleKeyDown(t, e) {
				const n = tl.getState(t.state);
				return (n == null ? void 0 : n.kind) === "active" &&
					e.key === "Escape"
					? (Q3(t.state.tr), !0)
					: !1;
			},
		},
	});
}
function n8(t) {
	const e = tl.getState(t.state);
	return (
		(e == null ? void 0 : e.kind) === "active" &&
			t.dispatch(Q3(t.state.tr)),
		!1
	);
}
function uFe(t) {
	var e;
	const n = ee(20);
	let r, i, o, s;
	n[0] !== t
		? (({ listenerRef: i, onEscape: o, scrollRef: r, ...s } = t),
			(n[0] = t),
			(n[1] = r),
			(n[2] = i),
			(n[3] = o),
			(n[4] = s))
		: ((r = n[1]), (i = n[2]), (o = n[3]), (s = n[4]));
	const a = y0(t),
		l = x0(),
		u = E.useRef(null);
	let c;
	c = new Xh({ collection: a.collection, ref: u, layoutDelegate: l });
	const d = c,
		{ collectionProps: f } = $x({
			keyboardDelegate: d,
			ref: i,
			scrollRef: (e = r) !== null && e !== void 0 ? e : u,
			selectionManager: a.selectionManager,
			disallowEmptySelection: !0,
			disallowTypeAhead: !0,
			isVirtualized: !0,
			shouldFocusWrap: !0,
		});
	let h;
	n[5] !== a.selectionManager || n[6] !== t.onAction || n[7] !== o
		? ((h = (x) => {
				e: switch (x.key) {
					case "Enter": {
						var C;
						a.selectionManager.select(
							a.selectionManager.focusedKey,
						),
							(C = t.onAction) === null ||
								C === void 0 ||
								C.call(t, a.selectionManager.focusedKey),
							x.preventDefault();
						break e;
					}
					case "Escape": {
						var k;
						(k = o) === null || k === void 0 || k();
					}
				}
			}),
			(n[5] = a.selectionManager),
			(n[6] = t.onAction),
			(n[7] = o),
			(n[8] = h))
		: (h = n[8]);
	const p = h;
	let g;
	n[9] !== p || n[10] !== f.onKeyDown
		? ((g = hr(p, f.onKeyDown)),
			(n[9] = p),
			(n[10] = f.onKeyDown),
			(n[11] = g))
		: (g = n[11]);
	const v = g;
	let b;
	n[12] !== u || n[13] !== l || n[14] !== a || n[15] !== s
		? ((b = m.jsx(k0, {
				ref: u,
				renderEmptyState: cFe,
				layout: l,
				state: a,
				autoFocus: "first",
				shouldUseVirtualFocus: !0,
				shouldFocusWrap: !0,
				UNSAFE_className: jx,
				...s,
			})),
			(n[12] = u),
			(n[13] = l),
			(n[14] = a),
			(n[15] = s),
			(n[16] = b))
		: (b = n[16]);
	let y;
	return (
		n[17] !== v || n[18] !== b
			? ((y = { keydownListener: v, listbox: b }),
				(n[17] = v),
				(n[18] = b),
				(n[19] = y))
			: (y = n[19]),
		y
	);
}
function cFe() {
	return m.jsx(As, {
		alignItems: "center",
		gap: "regular",
		height: "element.regular",
		paddingX: "medium",
		children: m.jsx(ue, {
			color: "neutralSecondary",
			weight: "medium",
			children: "No results…",
		}),
	});
}
const $E = new Os("keydown");
function yA(t) {
	const e = ee(6),
		n = Fa();
	let r;
	e[0] !== n ? ((r = $E.getState(n)), (e[0] = n), (e[1] = r)) : (r = e[1]);
	const i = r,
		o = qJ(t);
	let s, a;
	e[2] !== i || e[3] !== o
		? ((s = () => {
				if (!i) return;
				const l = { fn: o };
				return (
					i.add(l),
					() => {
						i.delete(l);
					}
				);
			}),
			(a = [i, o]),
			(e[2] = i),
			(e[3] = o),
			(e[4] = s),
			(e[5] = a))
		: ((s = e[4]), (a = e[5])),
		E.useEffect(s, a);
}
function dFe() {
	return new Gn({
		key: $E,
		state: {
			init() {
				return new Set();
			},
			apply(t, e) {
				return e;
			},
		},
		props: {
			handleKeyDown(t, e) {
				const n = $E.getState(t.state);
				if (!n) return !1;
				for (const r of n) if (r.fn(e)) return !0;
				return !1;
			},
		},
	});
}
function fFe(t, e, n) {
	const r = t.state.doc.nodeAt(e);
	if (r !== null && n === e + r.nodeSize) {
		const a = t.nodeDOM(e);
		if (a instanceof Element) return r8(a, t);
	}
	const i = t.domAtPos(e),
		o = t.domAtPos(n),
		s = document.createRange();
	return s.setStart(i.node, i.offset), s.setEnd(o.node, o.offset), r8(s, t);
}
function nX(t, e) {
	const n = ee(5),
		[r, i] = E.useState(null),
		o = J7e();
	let s, a;
	return (
		n[0] !== o || n[1] !== t || n[2] !== e
			? ((s = () => {
					const l = o();
					if (!l) {
						i(null);
						return;
					}
					i(fFe(l, t, e));
				}),
				(a = [o, t, e]),
				(n[0] = o),
				(n[1] = t),
				(n[2] = e),
				(n[3] = s),
				(n[4] = a))
			: ((s = n[3]), (a = n[4])),
		E.useLayoutEffect(s, a),
		r
	);
}
function r8(t, e) {
	return {
		contextElement: e.dom,
		getBoundingClientRect: () => t.getBoundingClientRect(),
	};
}
function hFe(t) {
	const e = af(),
		n = nX(t.from, t.to),
		r = E.useMemo(
			() => ({
				get current() {
					var s, a;
					return (s =
						(a = e.current) === null || a === void 0
							? void 0
							: a.dom) !== null && s !== void 0
						? s
						: null;
				},
			}),
			[e],
		),
		{ keydownListener: i, listbox: o } = uFe({
			listenerRef: r,
			...t,
			UNSAFE_style: { width: 320, ...t.UNSAFE_style },
		});
	return (
		yA((s) => (i(s), s.defaultPrevented)),
		n &&
			m.jsx(e_, {
				adaptToBoundary: "stretch",
				portal: !1,
				minWidth: "element.medium",
				placement: "bottom-start",
				reference: n,
				children: o,
			})
	);
}
const pFe = {
		pattern: /(?:^|\s)\/$/,
		handler(t, e, n, r) {
			return rFe(t.tr, gFe, r - 1, r, void 0);
		},
	},
	mFe = WJ((t) => {
		const e = tX(t);
		return e ? { state: t.apply(e), tr: e } : { state: t };
	});
function i8(t) {
	return (e, n, r) => {
		const { state: i, tr: o } = mFe(e);
		return o ? (n && n(o), t(i, n, r)) : !1;
	};
}
function rX(t) {
	return m.jsxs(
		Mt,
		{
			textValue: t.label,
			children: [
				m.jsx(ue, { children: t.label }),
				t.description &&
					m.jsx(ue, { slot: "description", children: t.description }),
				t.icon && m.jsx(ve, { src: t.icon }),
			],
		},
		t.id,
	);
}
function gFe(t) {
	const e = ee(23),
		n = af(),
		r = On(),
		i = ca(),
		o = Fa();
	let s, a;
	if (e[0] !== i.insertMenuItems || e[1] !== t.query || e[2] !== o) {
		let h;
		e[4] !== o
			? ((h = (p) => p.command(o)), (e[4] = o), (e[5] = h))
			: (h = e[5]),
			(a = $3(i.insertMenuItems, t.query, { keys: ["label"] }).filter(h)),
			(e[0] = i.insertMenuItems),
			(e[1] = t.query),
			(e[2] = o),
			(e[3] = a);
	} else a = e[3];
	s = a;
	const l = s;
	let u;
	e[6] !== l || e[7] !== r || e[8] !== n.current || e[9] !== o.tr
		? ((u = (h) => {
				if (h.key !== " ") return !1;
				if (l.length === 1) return r(i8(l[0].command)), !0;
				if (l.length === 0) {
					var p;
					(p = n.current) === null ||
						p === void 0 ||
						p.dispatch(Q3(o.tr));
				}
				return !1;
			}),
			(e[6] = l),
			(e[7] = r),
			(e[8] = n.current),
			(e[9] = o.tr),
			(e[10] = u))
		: (u = e[10]),
		yA(u);
	let c;
	e[11] !== o || e[12] !== n.current
		? ((c = () => {
				var h;
				const p = tX(o);
				p &&
					((h = n.current) === null || h === void 0 || h.dispatch(p));
			}),
			(e[11] = o),
			(e[12] = n.current),
			(e[13] = c))
		: (c = e[13]);
	let d;
	e[14] !== l || e[15] !== r
		? ((d = (h) => {
				const p = l.find((g) => g.id === h);
				p && r(i8(p.command));
			}),
			(e[14] = l),
			(e[15] = r),
			(e[16] = d))
		: (d = e[16]);
	let f;
	return (
		e[17] !== t.from ||
		e[18] !== t.to ||
		e[19] !== l ||
		e[20] !== c ||
		e[21] !== d
			? ((f = m.jsx(hFe, {
					from: t.from,
					to: t.to,
					"aria-label": "Insert menu",
					items: l,
					children: rX,
					onEscape: c,
					onAction: d,
				})),
				(e[17] = t.from),
				(e[18] = t.to),
				(e[19] = l),
				(e[20] = c),
				(e[21] = d),
				(e[22] = f))
			: (f = e[22]),
		f
	);
}
function bFe(t) {
	const e = ee(33),
		[n, r] = E.useState(!1),
		i = Le(Ht);
	let o;
	e[0] === Symbol.for("react.memo_cache_sentinel")
		? ((o = () => r(!0)), (e[0] = o))
		: (o = e[0]);
	let s;
	e[1] === Symbol.for("react.memo_cache_sentinel")
		? ((s = m.jsx(Re, {
				prominence: "low",
				onPress: o,
				children: m.jsx(ve, { src: V0 }),
			})),
			(e[1] = s))
		: (s = e[1]);
	let a;
	e[2] !== i ? ((a = i.format("edit")), (e[2] = i), (e[3] = a)) : (a = e[3]);
	let l;
	e[4] !== a
		? ((l = m.jsxs(Ze, { children: [s, m.jsx(Xe, { children: a })] })),
			(e[4] = a),
			(e[5] = l))
		: (l = e[5]);
	let u;
	e[6] !== t.href
		? ((u = () => {
				window.open(t.href, "_blank", "noopener,noreferrer");
			}),
			(e[6] = t.href),
			(e[7] = u))
		: (u = e[7]);
	let c;
	e[8] === Symbol.for("react.memo_cache_sentinel")
		? ((c = m.jsx(ve, { src: S3 })), (e[8] = c))
		: (c = e[8]);
	let d;
	e[9] !== u
		? ((d = m.jsx(Re, { prominence: "low", onPress: u, children: c })),
			(e[9] = u),
			(e[10] = d))
		: (d = e[10]);
	let f;
	e[11] !== t.href
		? ((f = m.jsx(Xe, {
				children: m.jsx(ue, { truncate: 3, children: t.href }),
			})),
			(e[11] = t.href),
			(e[12] = f))
		: (f = e[12]);
	let h;
	e[13] !== d || e[14] !== f
		? ((h = m.jsxs(Ze, { children: [d, f] })),
			(e[13] = d),
			(e[14] = f),
			(e[15] = h))
		: (h = e[15]);
	let p;
	e[16] === Symbol.for("react.memo_cache_sentinel")
		? ((p = m.jsx(ve, { src: MW })), (e[16] = p))
		: (p = e[16]);
	let g;
	e[17] !== t.onUnlink
		? ((g = m.jsx(Re, {
				prominence: "low",
				onPress: t.onUnlink,
				children: p,
			})),
			(e[17] = t.onUnlink),
			(e[18] = g))
		: (g = e[18]);
	let v;
	e[19] === Symbol.for("react.memo_cache_sentinel")
		? ((v = m.jsx(Xe, { children: "Unlink" })), (e[19] = v))
		: (v = e[19]);
	let b;
	e[20] !== g
		? ((b = m.jsxs(Ze, { children: [g, v] })), (e[20] = g), (e[21] = b))
		: (b = e[21]);
	let y;
	e[22] === Symbol.for("react.memo_cache_sentinel")
		? ((y = () => {
				r(!1);
			}),
			(e[22] = y))
		: (y = e[22]);
	let x;
	e[23] !== n || e[24] !== t
		? ((x =
				n &&
				m.jsx(iX, {
					text: t.text,
					href: t.href,
					onSubmit: (w) => {
						const { href: D } = w;
						t.onHrefChange(D);
					},
				})),
			(e[23] = n),
			(e[24] = t),
			(e[25] = x))
		: (x = e[25]);
	let C;
	e[26] !== x
		? ((C = m.jsx(mn, { onDismiss: y, children: x })),
			(e[26] = x),
			(e[27] = C))
		: (C = e[27]);
	let k;
	return (
		e[28] !== l || e[29] !== h || e[30] !== b || e[31] !== C
			? ((k = m.jsxs(ke, {
					gap: "small",
					padding: "regular",
					children: [l, h, b, C],
				})),
				(e[28] = l),
				(e[29] = h),
				(e[30] = b),
				(e[31] = C),
				(e[32] = k))
			: (k = e[32]),
		k
	);
}
function iX(t) {
	const e = ee(40);
	let n, r;
	e[0] !== t
		? (({ onSubmit: r, ...n } = t), (e[0] = t), (e[1] = n), (e[2] = r))
		: ((n = e[1]), (r = e[2]));
	const [i, o] = E.useState(n.href || ""),
		[s, a] = E.useState(!1),
		{ dismiss: l } = Xd(),
		u = Le(Ht);
	let c;
	e[3] !== s || e[4] !== i
		? ((c = s && !X0(i)), (e[3] = s), (e[4] = i), (e[5] = c))
		: (c = e[5]);
	const d = c;
	let f;
	e[6] === Symbol.for("react.memo_cache_sentinel")
		? ((f = { display: "contents" }), (e[6] = f))
		: (f = e[6]);
	let h;
	e[7] !== d || e[8] !== l || e[9] !== r || e[10] !== i
		? ((h = (T) => {
				T.target === T.currentTarget &&
					(T.preventDefault(), d || (l(), r({ href: i })));
			}),
			(e[7] = d),
			(e[8] = l),
			(e[9] = r),
			(e[10] = i),
			(e[11] = h))
		: (h = e[11]);
	const p = n.href ? "Edit" : "Add";
	let g;
	e[12] !== p
		? ((g = m.jsxs(Ut, { children: [p, " link"] })),
			(e[12] = p),
			(e[13] = g))
		: (g = e[13]);
	let v;
	e[14] !== n.text
		? ((v = m.jsx(An, { label: "Text", value: n.text, isReadOnly: !0 })),
			(e[14] = n.text),
			(e[15] = v))
		: (v = e[15]);
	let b;
	e[16] === Symbol.for("react.memo_cache_sentinel")
		? ((b = () => a(!0)), (e[16] = b))
		: (b = e[16]);
	const y = d && "Please provide a valid URL.";
	let x;
	e[17] !== i || e[18] !== y
		? ((x = m.jsx(An, {
				autoFocus: !0,
				isRequired: !0,
				onBlur: b,
				label: "Link",
				onChange: o,
				value: i,
				errorMessage: y,
			})),
			(e[17] = i),
			(e[18] = y),
			(e[19] = x))
		: (x = e[19]);
	let C;
	e[20] !== v || e[21] !== x
		? ((C = m.jsx(Pr, {
				children: m.jsxs(ke, {
					gap: "large",
					direction: "column",
					children: [v, x],
				}),
			})),
			(e[20] = v),
			(e[21] = x),
			(e[22] = C))
		: (C = e[22]);
	let k;
	e[23] !== u
		? ((k = u.format("cancel")), (e[23] = u), (e[24] = k))
		: (k = e[24]);
	let w;
	e[25] !== l || e[26] !== k
		? ((w = m.jsx(vt, { onPress: l, children: k })),
			(e[25] = l),
			(e[26] = k),
			(e[27] = w))
		: (w = e[27]);
	let D;
	e[28] !== u
		? ((D = u.format("save")), (e[28] = u), (e[29] = D))
		: (D = e[29]);
	let S;
	e[30] !== D
		? ((S = m.jsx(vt, { prominence: "high", type: "submit", children: D })),
			(e[30] = D),
			(e[31] = S))
		: (S = e[31]);
	let $;
	e[32] !== w || e[33] !== S
		? (($ = m.jsxs(Nr, { children: [w, S] })),
			(e[32] = w),
			(e[33] = S),
			(e[34] = $))
		: ($ = e[34]);
	let A;
	return (
		e[35] !== h || e[36] !== g || e[37] !== C || e[38] !== $
			? ((A = m.jsx(vr, {
					size: "small",
					children: m.jsxs("form", {
						style: f,
						onSubmit: h,
						children: [g, C, $],
					}),
				})),
				(e[35] = h),
				(e[36] = g),
				(e[37] = C),
				(e[38] = $),
				(e[39] = A))
			: (A = e[39]),
		A
	);
}
function vFe(t) {
	const e = ee(42),
		n = Le(Ht),
		r = On(),
		[i, o] = E.useState(!1);
	let s;
	e[0] === Symbol.for("react.memo_cache_sentinel")
		? ((s = () => o(!0)), (e[0] = s))
		: (s = e[0]);
	let a;
	e[1] === Symbol.for("react.memo_cache_sentinel")
		? ((a = m.jsx(Re, {
				prominence: "low",
				onPress: s,
				children: m.jsx(ve, { src: V0 }),
			})),
			(e[1] = a))
		: (a = e[1]);
	let l;
	e[2] !== n ? ((l = n.format("edit")), (e[2] = n), (e[3] = l)) : (l = e[3]);
	let u;
	e[4] !== l
		? ((u = m.jsxs(Ze, { children: [a, m.jsx(Xe, { children: l })] })),
			(e[4] = l),
			(e[5] = u))
		: (u = e[5]);
	let c;
	e[6] !== r || e[7] !== t.pos
		? ((c = async () => {
				const T = await q3("image/*");
				if (!T) return;
				const I = new Uint8Array(await T.arrayBuffer());
				r((F, N) => {
					if (N) {
						const { tr: O } = F;
						O.setNodeAttribute(t.pos, "src", I);
						const _ = F.apply(O);
						O.setSelection(Qe.create(_.doc, t.pos)), N(O);
					}
					return !0;
				});
			}),
			(e[6] = r),
			(e[7] = t.pos),
			(e[8] = c))
		: (c = e[8]);
	let d;
	e[9] === Symbol.for("react.memo_cache_sentinel")
		? ((d = m.jsx(ve, { src: VW })), (e[9] = d))
		: (d = e[9]);
	let f;
	e[10] !== c
		? ((f = m.jsx(Re, { prominence: "low", onPress: c, children: d })),
			(e[10] = c),
			(e[11] = f))
		: (f = e[11]);
	let h;
	e[12] === Symbol.for("react.memo_cache_sentinel")
		? ((h = m.jsx(Xe, { children: "Choose file" })), (e[12] = h))
		: (h = e[12]);
	let p;
	e[13] !== f
		? ((p = m.jsxs(Ze, { children: [f, h] })), (e[13] = f), (e[14] = p))
		: (p = e[14]);
	let g;
	e[15] !== u || e[16] !== p
		? ((g = m.jsxs(ke, { gap: "small", children: [u, p] })),
			(e[15] = u),
			(e[16] = p),
			(e[17] = g))
		: (g = e[17]);
	let v;
	e[18] === Symbol.for("react.memo_cache_sentinel")
		? ((v = m.jsx(ra, { orientation: "vertical" })), (e[18] = v))
		: (v = e[18]);
	let b;
	e[19] !== r || e[20] !== t.pos || e[21] !== t.node.nodeSize
		? ((b = () => {
				r(
					(T, I) => (
						I && I(T.tr.delete(t.pos, t.pos + t.node.nodeSize)), !0
					),
				);
			}),
			(e[19] = r),
			(e[20] = t.pos),
			(e[21] = t.node.nodeSize),
			(e[22] = b))
		: (b = e[22]);
	let y;
	e[23] === Symbol.for("react.memo_cache_sentinel")
		? ((y = m.jsx(ve, { src: Wr })), (e[23] = y))
		: (y = e[23]);
	let x;
	e[24] !== b
		? ((x = m.jsx(Re, { prominence: "low", onPress: b, children: y })),
			(e[24] = b),
			(e[25] = x))
		: (x = e[25]);
	let C;
	e[26] === Symbol.for("react.memo_cache_sentinel")
		? ((C = m.jsx(Xe, { tone: "critical", children: "Remove" })),
			(e[26] = C))
		: (C = e[26]);
	let k;
	e[27] !== x
		? ((k = m.jsxs(Ze, { children: [x, C] })), (e[27] = x), (e[28] = k))
		: (k = e[28]);
	let w;
	e[29] !== g || e[30] !== k
		? ((w = m.jsxs(ke, {
				gap: "regular",
				padding: "regular",
				children: [g, v, k],
			})),
			(e[29] = g),
			(e[30] = k),
			(e[31] = w))
		: (w = e[31]);
	let D;
	e[32] === Symbol.for("react.memo_cache_sentinel")
		? ((D = () => {
				o(!1);
			}),
			(e[32] = D))
		: (D = e[32]);
	let S;
	e[33] !== i || e[34] !== r || e[35] !== t
		? ((S =
				i &&
				m.jsx(yFe, {
					alt: t.node.attrs.alt,
					title: t.node.attrs.title,
					filename: t.node.attrs.filename,
					onSubmit: (T) => {
						r((I, F) => {
							if (F) {
								const { tr: N } = I;
								N.setNodeMarkup(t.pos, void 0, {
									...t.node.attrs,
									...T,
								});
								const O = I.apply(N);
								N.setSelection(Qe.create(O.doc, t.pos)), F(N);
							}
							return !0;
						}),
							o(!1);
					},
				})),
			(e[33] = i),
			(e[34] = r),
			(e[35] = t),
			(e[36] = S))
		: (S = e[36]);
	let $;
	e[37] !== S
		? (($ = m.jsx(mn, { onDismiss: D, children: S })),
			(e[37] = S),
			(e[38] = $))
		: ($ = e[38]);
	let A;
	return (
		e[39] !== w || e[40] !== $
			? ((A = m.jsxs(m.Fragment, { children: [w, $] })),
				(e[39] = w),
				(e[40] = $),
				(e[41] = A))
			: (A = e[41]),
		A
	);
}
function yFe(t) {
	const e = ca(),
		[n, r] = E.useState({ alt: t.alt, title: t.title }),
		i = E.useMemo(
			() => ({ kind: "object", fields: e.config.image.schema }),
			[e.config.image],
		),
		o = E.useMemo(() => Ba(i, r, () => {}), [i])(n),
		[s, a] = xFe(t.filename),
		[l, u] = E.useState(!1);
	let [c, d] = E.useState(s),
		[f, h] = E.useState(!1),
		{ dismiss: p } = Xd(),
		g = Le(Ht);
	return m.jsx(vr, {
		size: "small",
		children: m.jsxs("form", {
			style: { display: "contents" },
			onSubmit: (v) => {
				v.target === v.currentTarget &&
					(v.preventDefault(),
					u(!0),
					c &&
						_s(i, n, void 0) &&
						(p(),
						t.onSubmit({
							alt: n.alt,
							title: n.title,
							filename: [c, a].join("."),
						})));
			},
			children: [
				m.jsx(Ut, { children: "Image details" }),
				m.jsx(Pr, {
					children: m.jsxs(ke, {
						gap: "large",
						direction: "column",
						children: [
							m.jsx(An, {
								label: "File name",
								onChange: d,
								onBlur: () => h(!0),
								value: c,
								isRequired: !0,
								errorMessage:
									(f || l) && !c
										? "Please provide a file name."
										: void 0,
								endElement: a
									? m.jsx(ke, {
											alignItems: "center",
											justifyContent: "center",
											paddingEnd: "regular",
											children: m.jsxs(ue, {
												color: "neutralTertiary",
												children: [".", a],
											}),
										})
									: null,
							}),
							m.jsx(Ia, {
								forceValidation: l,
								autoFocus: !0,
								...o,
							}),
						],
					}),
				}),
				m.jsxs(Nr, {
					children: [
						m.jsx(vt, { onPress: p, children: g.format("cancel") }),
						m.jsx(vt, {
							prominence: "high",
							type: "submit",
							children: g.format("save"),
						}),
					],
				}),
			],
		}),
	});
}
function xFe(t) {
	const e = t.lastIndexOf(".");
	return e === -1 ? [t, ""] : [t.substring(0, e), t.substring(e + 1)];
}
function o8(t) {
	const e = ee(14),
		[n, r] = E.useState(!1);
	let i, o;
	e[0] !== t.schema
		? ((o = { kind: "object", fields: t.schema }),
			(e[0] = t.schema),
			(e[1] = o))
		: (o = e[1]),
		(i = o);
	const s = i,
		a = Du(t.serialized, t.schema),
		l = On();
	let u;
	e[2] === Symbol.for("react.memo_cache_sentinel")
		? ((u = () => {
				r(!0);
			}),
			(e[2] = u))
		: (u = e[2]);
	let c;
	e[3] === Symbol.for("react.memo_cache_sentinel")
		? ((c = m.jsx(Re, {
				prominence: "low",
				onPress: u,
				children: m.jsx(ve, { src: wS }),
			})),
			(e[3] = c))
		: (c = e[3]);
	let d;
	e[4] === Symbol.for("react.memo_cache_sentinel")
		? ((d = m.jsxs(Ze, { children: [c, m.jsx(Xe, { children: "Edit" })] })),
			(e[4] = d))
		: (d = e[4]);
	let f;
	e[5] === Symbol.for("react.memo_cache_sentinel")
		? ((f = () => {
				r(!1);
			}),
			(e[5] = f))
		: (f = e[5]);
	let h;
	e[6] !== n || e[7] !== t || e[8] !== l || e[9] !== s || e[10] !== a
		? ((h =
				n &&
				m.jsxs(vr, {
					children: [
						m.jsxs(Ut, { children: ["Edit ", t.name] }),
						m.jsx(Y3, {
							schema: s,
							value: a,
							onSave: (g) => {
								l(
									(v, b) => (
										b &&
											b(
												v.tr.setNodeAttribute(
													t.pos,
													"props",
													fn(g, t.schema),
												),
											),
										!0
									),
								);
							},
						}),
					],
				})),
			(e[6] = n),
			(e[7] = t),
			(e[8] = l),
			(e[9] = s),
			(e[10] = a),
			(e[11] = h))
		: (h = e[11]);
	let p;
	return (
		e[12] !== h
			? ((p = m.jsxs(m.Fragment, {
					children: [d, m.jsx(mn, { onDismiss: f, children: h })],
				})),
				(e[12] = h),
				(e[13] = p))
			: (p = e[13]),
		p
	);
}
function kFe(t, e) {
	return Object.assign(t, { shouldShow: e });
}
const s8 = {
	code_block: function (e) {
		const n = On(),
			r = ca(),
			i = af();
		return m.jsxs(ke, {
			gap: "regular",
			padding: "regular",
			children: [
				m.jsx(An, {
					"aria-label": "Code block language",
					value: e.node.attrs.language,
					onChange: (o) => {
						const s = i.current;
						s.dispatch(
							s.state.tr.setNodeAttribute(e.pos, "language", o),
						);
					},
				}),
				!!Object.keys(r.config.codeBlock.schema).length &&
					m.jsx(o8, {
						name: "Code Block",
						schema: r.config.codeBlock.schema,
						pos: e.pos,
						serialized: e.node.attrs.props,
					}),
				m.jsx(ra, { orientation: "vertical" }),
				m.jsxs(Ze, {
					children: [
						m.jsx(Re, {
							prominence: "low",
							onPress: () => {
								n(
									(o, s) => (
										s &&
											s(
												o.tr.delete(
													e.pos,
													e.pos + e.node.nodeSize,
												),
											),
										!0
									),
								);
							},
							children: m.jsx(ve, { src: Wr }),
						}),
						m.jsx(Xe, { tone: "critical", children: "Remove" }),
					],
				}),
			],
		});
	},
	image: vFe,
	table: function (e) {
		var n;
		const r = On(),
			i = ca();
		return m.jsxs(ke, {
			gap: "regular",
			padding: "regular",
			children: [
				i.format === "markdoc" &&
					m.jsxs(m.Fragment, {
						children: [
							m.jsxs(Ze, {
								children: [
									m.jsx(Re, {
										prominence: "low",
										isSelected:
											((n = e.node.firstChild) === null ||
											n === void 0 ||
											(n = n.firstChild) === null ||
											n === void 0
												? void 0
												: n.type) ===
											i.nodes.table_header,
										onPress: () => {
											r(z3("row"));
										},
										children: m.jsx(ve, { src: Gq }),
									}),
									m.jsx(Xe, { children: "Header row" }),
								],
							}),
							m.jsx(ra, { orientation: "vertical" }),
						],
					}),
				m.jsxs(Ze, {
					children: [
						m.jsx(Re, {
							prominence: "low",
							onPress: () => {
								r(
									(o, s) => (
										s &&
											s(
												o.tr.delete(
													e.pos,
													e.pos + e.node.nodeSize,
												),
											),
										!0
									),
								);
							},
							children: m.jsx(ve, { src: Wr }),
						}),
						m.jsx(Xe, { tone: "critical", children: "Remove" }),
					],
				}),
			],
		});
	},
	heading: kFe(
		function (e) {
			const n = On(),
				r = ca();
			return m.jsxs(ke, {
				gap: "regular",
				padding: "regular",
				children: [
					m.jsx(o8, {
						name: "Heading",
						schema: r.config.heading.schema,
						pos: e.pos,
						serialized: e.node.attrs.props,
					}),
					m.jsx(ra, { orientation: "vertical" }),
					m.jsxs(Ze, {
						children: [
							m.jsx(Re, {
								prominence: "low",
								onPress: () => {
									n(
										(i, o) => (
											o &&
												o(
													i.tr.delete(
														e.pos,
														e.pos + e.node.nodeSize,
													),
												),
											!0
										),
									);
								},
								children: m.jsx(ve, { src: Wr }),
							}),
							m.jsx(Xe, { tone: "critical", children: "Remove" }),
						],
					}),
				],
			});
		},
		(t) => !!Object.keys(t.config.heading.schema).length,
	),
};
function qf(t, e) {
	const { parent: n, parentOffset: r } = t,
		i = n.childAfter(r);
	if (!i.node) return null;
	const o = i.node.marks.find((c) => c.type === e);
	if (!o) return null;
	let s = t.index(),
		a = t.start() + i.offset,
		l = s + 1,
		u = a + i.node.nodeSize;
	for (; s > 0 && o.isInSet(n.child(s - 1).marks); )
		(s -= 1), (a -= n.child(s).nodeSize);
	for (; l < n.childCount && o.isInSet(n.child(l).marks); )
		(u += n.child(l).nodeSize), (l += 1);
	return { from: a, to: u, mark: o };
}
const CFe = (t) => {
	const e = ee(14),
		n = On(),
		r = t.mark.attrs.href;
	if (typeof r != "string") return null;
	let i;
	e[0] !== t.state.doc || e[1] !== t.from || e[2] !== t.to
		? ((i = t.state.doc.textBetween(t.from, t.to)),
			(e[0] = t.state.doc),
			(e[1] = t.from),
			(e[2] = t.to),
			(e[3] = i))
		: (i = e[3]);
	let o, s;
	e[4] !== n || e[5] !== t.from || e[6] !== t.to
		? ((o = () => {
				n(
					(l, u) => (
						u &&
							u(
								l.tr.removeMark(
									t.from,
									t.to,
									l.schema.marks.link,
								),
							),
						!0
					),
				);
			}),
			(s = (l) => {
				n(
					(u, c) => (
						c &&
							c(
								u.tr
									.removeMark(
										t.from,
										t.to,
										u.schema.marks.link,
									)
									.addMark(
										t.from,
										t.to,
										u.schema.marks.link.create({ href: l }),
									),
							),
						!0
					),
				);
			}),
			(e[4] = n),
			(e[5] = t.from),
			(e[6] = t.to),
			(e[7] = o),
			(e[8] = s))
		: ((o = e[7]), (s = e[8]));
	let a;
	return (
		e[9] !== i || e[10] !== r || e[11] !== o || e[12] !== s
			? ((a = m.jsx(bFe, {
					text: i,
					href: r,
					onUnlink: o,
					onHrefChange: s,
				})),
				(e[9] = i),
				(e[10] = r),
				(e[11] = o),
				(e[12] = s),
				(e[13] = a))
			: (a = e[13]),
		a
	);
};
function wFe(t) {
	const e = ee(43);
	let n;
	e[0] !== t.state.schema
		? ((n = kr(t.state.schema)), (e[0] = t.state.schema), (e[1] = n))
		: (n = e[1]);
	const i = n.components[t.node.type.name],
		o = On(),
		[s, a] = E.useState(!1);
	let l, u;
	e[2] !== i.schema
		? ((u = { kind: "object", fields: i.schema }),
			(e[2] = i.schema),
			(e[3] = u))
		: (u = e[3]),
		(l = u);
	const c = l,
		d = Du(t.node.attrs.props, i.schema),
		f = af();
	if (i.kind === "inline" && i.ToolbarView) {
		let $;
		e[4] !== f.current || e[5] !== t.pos || e[6] !== c.fields
			? (($ = (I) => {
					const F = f.current;
					F.dispatch(
						F.state.tr.setNodeAttribute(
							t.pos,
							"props",
							fn(I, c.fields),
						),
					);
				}),
				(e[4] = f.current),
				(e[5] = t.pos),
				(e[6] = c.fields),
				(e[7] = $))
			: ($ = e[7]);
		let A;
		e[8] !== o || e[9] !== t.pos || e[10] !== t.node.nodeSize
			? ((A = () => {
					o(
						(I, F) => (
							F && F(I.tr.delete(t.pos, t.pos + t.node.nodeSize)),
							!0
						),
					);
				}),
				(e[8] = o),
				(e[9] = t.pos),
				(e[10] = t.node.nodeSize),
				(e[11] = A))
			: (A = e[11]);
		let T;
		return (
			e[12] !== i.ToolbarView || e[13] !== d || e[14] !== $ || e[15] !== A
				? ((T = m.jsx(i.ToolbarView, {
						value: d,
						onChange: $,
						onRemove: A,
					})),
					(e[12] = i.ToolbarView),
					(e[13] = d),
					(e[14] = $),
					(e[15] = A),
					(e[16] = T))
				: (T = e[16]),
			T
		);
	}
	let h;
	e[17] === Symbol.for("react.memo_cache_sentinel")
		? ((h = () => {
				a(!0);
			}),
			(e[17] = h))
		: (h = e[17]);
	let p;
	e[18] === Symbol.for("react.memo_cache_sentinel")
		? ((p = m.jsx(Re, {
				prominence: "low",
				onPress: h,
				children: m.jsx(ve, { src: wS }),
			})),
			(e[18] = p))
		: (p = e[18]);
	let g;
	e[19] === Symbol.for("react.memo_cache_sentinel")
		? ((g = m.jsxs(Ze, { children: [p, m.jsx(Xe, { children: "Edit" })] })),
			(e[19] = g))
		: (g = e[19]);
	let v;
	e[20] !== o || e[21] !== t.pos || e[22] !== t.node.nodeSize
		? ((v = () => {
				o(
					($, A) => (
						A && A($.tr.delete(t.pos, t.pos + t.node.nodeSize)), !0
					),
				);
			}),
			(e[20] = o),
			(e[21] = t.pos),
			(e[22] = t.node.nodeSize),
			(e[23] = v))
		: (v = e[23]);
	let b;
	e[24] === Symbol.for("react.memo_cache_sentinel")
		? ((b = m.jsx(ve, { src: Wr })), (e[24] = b))
		: (b = e[24]);
	let y;
	e[25] !== v
		? ((y = m.jsx(Re, { prominence: "low", onPress: v, children: b })),
			(e[25] = v),
			(e[26] = y))
		: (y = e[26]);
	let x;
	e[27] === Symbol.for("react.memo_cache_sentinel")
		? ((x = m.jsx(Xe, { tone: "critical", children: "Remove" })),
			(e[27] = x))
		: (x = e[27]);
	let C;
	e[28] !== y
		? ((C = m.jsxs(ke, {
				gap: "regular",
				padding: "regular",
				children: [g, m.jsxs(Ze, { children: [y, x] })],
			})),
			(e[28] = y),
			(e[29] = C))
		: (C = e[29]);
	let k;
	e[30] === Symbol.for("react.memo_cache_sentinel")
		? ((k = () => {
				a(!1);
			}),
			(e[30] = k))
		: (k = e[30]);
	let w;
	e[31] !== s ||
	e[32] !== i ||
	e[33] !== o ||
	e[34] !== t ||
	e[35] !== c ||
	e[36] !== d
		? ((w =
				s &&
				m.jsxs(vr, {
					children: [
						m.jsxs(Ut, { children: ["Edit ", i.label] }),
						m.jsx(Y3, {
							schema: c,
							value: d,
							onSave: ($) => {
								o(
									(A, T) => (
										T &&
											T(
												A.tr.setNodeAttribute(
													t.pos,
													"props",
													fn($, c.fields),
												),
											),
										!0
									),
								);
							},
						}),
					],
				})),
			(e[31] = s),
			(e[32] = i),
			(e[33] = o),
			(e[34] = t),
			(e[35] = c),
			(e[36] = d),
			(e[37] = w))
		: (w = e[37]);
	let D;
	e[38] !== w
		? ((D = m.jsx(mn, { onDismiss: k, children: w })),
			(e[38] = w),
			(e[39] = D))
		: (D = e[39]);
	let S;
	return (
		e[40] !== C || e[41] !== D
			? ((S = m.jsxs(m.Fragment, { children: [C, D] })),
				(e[40] = C),
				(e[41] = D),
				(e[42] = S))
			: (S = e[42]),
		S
	);
}
const EFe = (t) => {
	const e = ee(31);
	let n;
	e[0] !== t.state.schema
		? ((n = kr(t.state.schema)), (e[0] = t.state.schema), (e[1] = n))
		: (n = e[1]);
	const i = n.components[t.mark.type.name],
		o = On(),
		[s, a] = E.useState(!1);
	let l, u;
	e[2] !== i.schema
		? ((u = { kind: "object", fields: i.schema }),
			(e[2] = i.schema),
			(e[3] = u))
		: (u = e[3]),
		(l = u);
	const c = l,
		d = Du(t.mark.attrs.props, i.schema);
	let f;
	e[4] === Symbol.for("react.memo_cache_sentinel")
		? ((f = () => {
				a(!0);
			}),
			(e[4] = f))
		: (f = e[4]);
	let h;
	e[5] === Symbol.for("react.memo_cache_sentinel")
		? ((h = m.jsx(Re, {
				prominence: "low",
				onPress: f,
				children: m.jsx(ve, { src: wS }),
			})),
			(e[5] = h))
		: (h = e[5]);
	let p;
	e[6] === Symbol.for("react.memo_cache_sentinel")
		? ((p = m.jsxs(Ze, { children: [h, m.jsx(Xe, { children: "Edit" })] })),
			(e[6] = p))
		: (p = e[6]);
	let g;
	e[7] !== o || e[8] !== t.from || e[9] !== t.to || e[10] !== t.mark.type
		? ((g = () => {
				o(
					(S, $) => (
						$ && $(S.tr.removeMark(t.from, t.to, t.mark.type)), !0
					),
				);
			}),
			(e[7] = o),
			(e[8] = t.from),
			(e[9] = t.to),
			(e[10] = t.mark.type),
			(e[11] = g))
		: (g = e[11]);
	let v;
	e[12] === Symbol.for("react.memo_cache_sentinel")
		? ((v = m.jsx(ve, { src: Wr })), (e[12] = v))
		: (v = e[12]);
	let b;
	e[13] !== g
		? ((b = m.jsx(Re, { prominence: "low", onPress: g, children: v })),
			(e[13] = g),
			(e[14] = b))
		: (b = e[14]);
	let y;
	e[15] === Symbol.for("react.memo_cache_sentinel")
		? ((y = m.jsx(Xe, { tone: "critical", children: "Remove" })),
			(e[15] = y))
		: (y = e[15]);
	let x;
	e[16] !== b
		? ((x = m.jsxs(ke, {
				gap: "regular",
				padding: "regular",
				children: [p, m.jsxs(Ze, { children: [b, y] })],
			})),
			(e[16] = b),
			(e[17] = x))
		: (x = e[17]);
	let C;
	e[18] === Symbol.for("react.memo_cache_sentinel")
		? ((C = () => {
				a(!1);
			}),
			(e[18] = C))
		: (C = e[18]);
	let k;
	e[19] !== s ||
	e[20] !== i ||
	e[21] !== o ||
	e[22] !== t ||
	e[23] !== c ||
	e[24] !== d
		? ((k =
				s &&
				m.jsxs(vr, {
					children: [
						m.jsxs(Ut, { children: ["Edit ", i.label] }),
						m.jsx(Y3, {
							schema: c,
							value: d,
							onSave: (S) => {
								o(
									($, A) => (
										A &&
											A(
												$.tr
													.removeMark(
														t.from,
														t.to,
														t.mark.type,
													)
													.addMark(
														t.from,
														t.to,
														t.mark.type.create({
															props: fn(
																S,
																i.schema,
															),
														}),
													),
											),
										!0
									),
								);
							},
						}),
					],
				})),
			(e[19] = s),
			(e[20] = i),
			(e[21] = o),
			(e[22] = t),
			(e[23] = c),
			(e[24] = d),
			(e[25] = k))
		: (k = e[25]);
	let w;
	e[26] !== k
		? ((w = m.jsx(mn, { onDismiss: C, children: k })),
			(e[26] = k),
			(e[27] = w))
		: (w = e[27]);
	let D;
	return (
		e[28] !== x || e[29] !== w
			? ((D = m.jsxs(m.Fragment, { children: [x, w] })),
				(e[28] = x),
				(e[29] = w),
				(e[30] = D))
			: (D = e[30]),
		D
	);
};
function DFe(t) {
	if (t.selection instanceof kt) {
		const o = kr(t.schema);
		let s = null;
		for (const [a, l] of Object.entries(o.components)) {
			if (l.kind !== "mark" || !Object.keys(l.schema).length) continue;
			const u = o.schema.marks[a],
				c = qf(t.selection.$from, u),
				d = qf(t.selection.$to, u);
			if (
				c &&
				c.from === (d == null ? void 0 : d.from) &&
				c.to === d.to
			) {
				const f = c.to - c.from;
				(!s || f < s.to - s.from) &&
					(s = {
						adaptToBoundary: "flip",
						kind: "mark",
						component: EFe,
						mark: c.mark,
						from: c.from,
						to: c.to,
					});
			}
		}
		if (o.marks.link) {
			const a = qf(t.selection.$from, o.marks.link),
				l = qf(t.selection.$to, o.marks.link);
			if (
				a &&
				a.from === (l == null ? void 0 : l.from) &&
				a.to === l.to
			) {
				const u = a.to - a.from;
				if (!s || u < s.to - s.from)
					return {
						adaptToBoundary: "flip",
						kind: "mark",
						component: CFe,
						mark: a.mark,
						from: a.from,
						to: a.to,
					};
			}
		}
		if (s) return s;
	}
	const e = kr(t.schema);
	if (t.selection instanceof Qe) {
		var n;
		const o = t.selection.node;
		if (
			((n = e.components[o.type.name]) === null || n === void 0
				? void 0
				: n.kind) === "inline"
		)
			return {
				adaptToBoundary: "stick",
				kind: "node",
				node: o,
				component: wFe,
				pos: t.selection.from,
			};
		const s = s8[o.type.name];
		if (s !== void 0 && (!s.shouldShow || s.shouldShow(e)))
			return {
				adaptToBoundary: "stick",
				kind: "node",
				node: o,
				component: s,
				pos: t.selection.from,
			};
	}
	const r = t.selection.$from.start(
			t.selection.$from.sharedDepth(t.selection.to),
		),
		i = t.doc.resolve(r);
	for (let o = i.depth; o > 0; o--) {
		const s = i.node(o);
		if (!s) break;
		const a = s8[s.type.name];
		if (a !== void 0 && (!a.shouldShow || a.shouldShow(e)))
			return {
				adaptToBoundary: "stick",
				kind: "node",
				node: s,
				component: a,
				pos: i.start(o) - 1,
			};
	}
	return null;
}
function SFe(t) {
	const e = ee(4),
		n = t.decoration.kind === "node" ? t.decoration.pos : t.decoration.from,
		r =
			t.decoration.kind === "node"
				? t.decoration.pos + t.decoration.node.nodeSize
				: t.decoration.to,
		i = nX(n, r);
	let o;
	return (
		e[0] !== i || e[1] !== t.decoration || e[2] !== t.state
			? ((o =
					i &&
					m.jsx(e_, {
						adaptToBoundary: t.decoration.adaptToBoundary,
						minWidth: "element.medium",
						placement: "bottom",
						portal: !1,
						reference: i,
						children:
							t.decoration.kind === "node"
								? m.jsx(t.decoration.component, {
										...t.decoration,
										state: t.state,
									})
								: m.jsx(t.decoration.component, {
										...t.decoration,
										state: t.state,
									}),
					})),
				(e[0] = i),
				(e[1] = t.decoration),
				(e[2] = t.state),
				(e[3] = o))
			: (o = e[3]),
		o
	);
}
function AFe(t) {
	const e = ee(5);
	let n, r;
	e[0] !== t.state
		? ((r = DFe(t.state)), (e[0] = t.state), (e[1] = r))
		: (r = e[1]),
		(n = r);
	const i = n;
	if (!i) return null;
	let o;
	return (
		e[2] !== i || e[3] !== t.state
			? ((o = m.jsx(SFe, { decoration: i, state: t.state })),
				(e[2] = i),
				(e[3] = t.state),
				(e[4] = o))
			: (o = e[4]),
		o
	);
}
function Gf(t) {
	var e, n;
	const r = Fa(),
		i = On(),
		o = !!((e = t.isSelected) !== null && e !== void 0 && e.call(t, r)),
		s =
			!t.command(r) ||
			((n = t.isDisabled) === null || n === void 0
				? void 0
				: n.call(t, r));
	return E.useMemo(
		() =>
			m.jsx(Que, {
				"aria-label": t["aria-label"],
				isSelected: o,
				isDisabled: s,
				onPress: () => {
					i(t.command);
				},
				children: t.children,
			}),
		[s, o, t, i],
	);
}
function $Fe(t) {
	const [e, n] = E.useState(null),
		r = On(),
		i = af();
	return (
		yA((o) => {
			if (o.metaKey && (o.key === "k" || o.key === "K")) {
				const { state: s } = i.current;
				if (!Ac(t.link)(s))
					return (
						o.preventDefault(),
						n(s.doc.textBetween(s.selection.from, s.selection.to)),
						!0
					);
			}
			return !1;
		}),
		E.useMemo(
			() =>
				m.jsxs(m.Fragment, {
					children: [
						m.jsxs(Ze, {
							children: [
								m.jsx(Gf, {
									"aria-label": "Divider",
									command: (o, s) => {
										const a = qf(o.selection.$from, t.link),
											l = qf(o.selection.$to, t.link);
										if (
											a &&
											(!l ||
												a.mark ===
													(l == null
														? void 0
														: l.mark))
										) {
											if (s) {
												var u;
												s(
													o.tr.removeMark(
														a.from,
														(u =
															l == null
																? void 0
																: l.to) !==
															null && u !== void 0
															? u
															: a.to,
														t.link,
													),
												);
											}
											return !0;
										}
										if (o.selection.empty) return !1;
										if (s) {
											const c = o.doc.textBetween(
												o.selection.from,
												o.selection.to,
											);
											n(c);
										}
										return !0;
									},
									isSelected: Ac(t.link),
									children: m.jsx(ve, { src: OW }),
								}),
								m.jsxs(Xe, {
									children: [
										m.jsx(ue, { children: "Link" }),
										m.jsx(fi, { meta: !0, children: "K" }),
									],
								}),
							],
						}),
						m.jsx(mn, {
							onDismiss: () => {
								n(null);
							},
							children:
								e &&
								m.jsx(iX, {
									href: "",
									text: e,
									onSubmit: (o) => {
										n(null), r(wc(t.link, o));
									},
								}),
						}),
					],
				}),
			[t.link, r, e],
		)
	);
}
const TFe = E.memo(function (e) {
		const n = ca(),
			{ nodes: r, marks: i } = n;
		return m.jsxs(IFe, {
			...e,
			children: [
				m.jsxs(FFe, {
					children: [
						r.heading && m.jsx(RFe, { headingType: r.heading }),
						m.jsxs(Gue, {
							"aria-label": "Formatting options",
							children: [
								m.jsx(sk, {}),
								m.jsx(MFe, {}),
								m.jsx(sk, {}),
								m.jsx(_Fe, {}),
								m.jsx(sk, {}),
								m.jsxs(GD, {
									"aria-label": "Blocks",
									children: [
										r.divider &&
											m.jsxs(Ze, {
												children: [
													m.jsx(Gf, {
														"aria-label": "Divider",
														command: Wf(r.divider),
														isSelected: Z1(
															r.divider,
														),
														children: m.jsx(ve, {
															src: Ix,
														}),
													}),
													m.jsxs(Xe, {
														children: [
															m.jsx(ue, {
																children:
																	"Divider",
															}),
															m.jsx(fi, {
																children: "---",
															}),
														],
													}),
												],
											}),
										i.link && m.jsx($Fe, { link: i.link }),
										r.blockquote &&
											m.jsxs(Ze, {
												children: [
													m.jsx(Gf, {
														"aria-label": "Quote",
														command: (o, s) => {
															if (
																Z1(
																	r.blockquote,
																)(o)
															) {
																const {
																		$from: l,
																		$to: u,
																	} =
																		o.selection,
																	c =
																		l.blockRange(
																			u,
																			(
																				f,
																			) =>
																				f.type ===
																				r.blockquote,
																		);
																if (!c)
																	return !1;
																const d = v0(c);
																return d ===
																	null
																	? !1
																	: (s &&
																			s(
																				o.tr
																					.lift(
																						c,
																						d,
																					)
																					.scrollIntoView(),
																			),
																		!0);
															} else
																return Sj(
																	r.blockquote,
																)(o, s);
														},
														isSelected: Z1(
															r.blockquote,
														),
														children: m.jsx(ve, {
															src: JD,
														}),
													}),
													m.jsxs(Xe, {
														children: [
															m.jsx(ue, {
																children:
																	"Quote",
															}),
															m.jsx(fi, {
																children: ">⎵",
															}),
														],
													}),
												],
											}),
										r.code_block &&
											m.jsxs(Ze, {
												children: [
													m.jsx(Gf, {
														"aria-label":
															"Code block",
														command: E7e(
															r.code_block,
															r.paragraph,
														),
														isSelected: Z1(
															r.code_block,
														),
														children: m.jsx(ve, {
															src: Kx,
														}),
													}),
													m.jsxs(Xe, {
														children: [
															m.jsx(ue, {
																children:
																	"Code block",
															}),
															m.jsx(fi, {
																children: "```",
															}),
														],
													}),
												],
											}),
										r.table &&
											m.jsxs(Ze, {
												children: [
													m.jsx(Gf, {
														"aria-label": "Table",
														command: GJ(r.table),
														children: m.jsx(ve, {
															src: XD,
														}),
													}),
													m.jsx(Xe, {
														children: m.jsx(ue, {
															children: "Table",
														}),
													}),
												],
											}),
										r.image && m.jsx(tFe, {}),
									],
								}),
							],
						}),
					],
				}),
				m.jsx(OFe, {}),
			],
		});
	}),
	BFe = ({ children: t }) => {
		let e = xo();
		return m.jsx("div", {
			"data-layout": e,
			className: X({
				alignItems: "center",
				boxSizing: "border-box",
				display: "flex",
				height: B.size.element.medium,
				[en.above.mobile]: { height: B.size.element.large },
				'&[data-layout="main"]': {
					marginInline: "auto",
					maxWidth: 800,
					minWidth: 0,
					paddingInline: B.size.space.medium,
					[en.above.mobile]: { paddingInline: B.size.space.xlarge },
					[en.above.tablet]: { paddingInline: B.size.space.xxlarge },
				},
			}),
			children: t,
		});
	},
	IFe = (t) => {
		let e = xo();
		return m.jsx("div", {
			...t,
			"data-layout": e,
			className: X({
				backdropFilter: "blur(8px)",
				backgroundClip: "padding-box",
				backgroundColor: `color-mix(in srgb, transparent, ${B.color.background.canvas} 90%)`,
				borderBottom: `${B.size.border.regular} solid color-mix(in srgb, transparent, ${B.color.foreground.neutral} 10%)`,
				borderStartEndRadius: B.size.radius.medium,
				borderStartStartRadius: B.size.radius.medium,
				minWidth: 0,
				position: "sticky",
				top: 0,
				zIndex: 2,
				'&[data-layout="main"]': { borderRadius: 0 },
			}),
			children: m.jsx(BFe, { children: t.children }),
		});
	},
	FFe = (t) => {
		let e = xo();
		return m.jsx("div", {
			"data-layout": e,
			className: X({
				alignItems: "center",
				display: "flex",
				flex: 1,
				gap: B.size.space.regular,
				paddingInline: B.size.space.medium,
				minWidth: 0,
				overflowX: "auto",
				marginBlock: `calc(${B.size.alias.focusRing} * -1)`,
				paddingBlock: B.size.alias.focusRing,
				msOverflowStyle: "none",
				scrollbarWidth: "none",
				"&::-webkit-scrollbar": { display: "none" },
				'&[data-layout="main"]': { paddingInline: 0 },
			}),
			...t,
		});
	},
	PFe = new Map([
		["normal", "normal"],
		["1", 1],
		["2", 2],
		["3", 3],
		["4", 4],
		["5", 5],
		["6", 6],
	]);
function NFe(t, e, n) {
	var r;
	let i;
	for (const o of t.selection.ranges)
		if (
			(t.doc.nodesBetween(o.$from.pos, o.$to.pos, (s) => {
				if (s.type === e) {
					const a = s.attrs.level;
					i === void 0 ? (i = a) : i !== a && (i = "disabled");
				}
				s.type === n &&
					(i === void 0
						? (i = "normal")
						: i !== "normal" && (i = "disabled"));
			}),
			i === "disabled")
		)
			break;
	return (r = i) !== null && r !== void 0 ? r : "disabled";
}
const RFe = (t) => {
	const { nodes: e, config: n } = ca(),
		r = E.useMemo(() => {
			let a = [{ name: "Paragraph", id: "normal" }];
			return (
				n.heading.levels.forEach((l) => {
					a.push({ name: `Heading ${l}`, id: l.toString() });
				}),
				a
			);
		}, [n.heading.levels]),
		i = Fa(),
		o = NFe(i, t.headingType, e.paragraph),
		s = On();
	return E.useMemo(
		() =>
			m.jsx(eS, {
				flexShrink: 0,
				width: "scale.1700",
				prominence: "low",
				"aria-label": "Text block",
				items: r,
				isDisabled: o === "disabled",
				selectedKey: o === "disabled" ? "normal" : o.toString(),
				onSelectionChange: (a) => {
					let l = PFe.get(a);
					l === "normal"
						? s(yd(e.paragraph))
						: l && s(yd(t.headingType, { level: parseInt(l) }));
				},
				children: (a) => m.jsx(Mt, { children: a.name }, a.id),
			}),
		[r, o, e.paragraph, t.headingType, s],
	);
};
function OFe() {
	const t = xo(),
		e = On(),
		n = ca(),
		r = E.useMemo(
			() => n.insertMenuItems.filter((o) => o.forToolbar),
			[n.insertMenuItems],
		),
		i = E.useMemo(() => new Map(r.map((o) => [o.id, o])), [r]);
	return r.length === 0
		? null
		: m.jsxs(Xo, {
				align: "end",
				children: [
					m.jsxs(Ze, {
						children: [
							m.jsxs(Re, {
								marginEnd: t === "main" ? void 0 : "medium",
								children: [
									m.jsx(ve, { src: Ux }),
									m.jsx(ve, { src: Il }),
								],
							}),
							m.jsxs(Xe, {
								children: [
									m.jsx(ue, { children: "Insert" }),
									m.jsx(fi, { children: "/" }),
								],
							}),
						],
					}),
					m.jsx(Jo, {
						onAction: (o) => {
							var s;
							const a =
								(s = i.get(o)) === null || s === void 0
									? void 0
									: s.command;
							a && e(a);
						},
						items: r,
						children: rX,
					}),
				],
			});
}
const Ac = (t) => (e) => {
	if (e.selection instanceof kt && e.selection.empty)
		return e.selection.$cursor
			? !!t.isInSet(e.storedMarks || e.selection.$cursor.marks())
			: !1;
	for (const n of e.selection.ranges)
		if (e.doc.rangeHasMark(n.$from.pos, n.$to.pos, t)) return !0;
	return !1;
};
function MFe() {
	const t = Fa(),
		e = ca(),
		n = On(),
		r = E.useMemo(() => {
			const s = [];
			e.marks.bold &&
				s.push({
					key: "bold",
					label: "Bold",
					icon: i_,
					shortcut: "B",
					command: wc(e.marks.bold),
					isSelected: Ac(e.marks.bold),
				}),
				e.marks.italic &&
					s.push({
						key: "italic",
						label: "Italic",
						icon: o_,
						shortcut: "I",
						command: wc(e.marks.italic),
						isSelected: Ac(e.marks.italic),
					}),
				e.marks.strikethrough &&
					s.push({
						key: "strikethrough",
						label: "Strikethrough",
						icon: a_,
						command: wc(e.marks.strikethrough),
						isSelected: Ac(e.marks.strikethrough),
					}),
				e.marks.code &&
					s.push({
						key: "code",
						label: "Code",
						icon: Kx,
						command: wc(e.marks.code),
						isSelected: Ac(e.marks.code),
					});
			for (const [a, l] of Object.entries(e.components))
				l.kind === "mark" &&
					s.push({
						key: a,
						label: l.label,
						icon: l.icon,
						command: wc(e.schema.marks[a]),
						isSelected: Ac(e.schema.marks[a]),
					});
			return (
				s.push({
					key: "clearFormatting",
					label: "Clear formatting",
					icon: s_,
					command: zFe(),
					isSelected: () => !1,
				}),
				s
			);
		}, [e]),
		i = a8(r.filter((s) => s.isSelected(t)).map((s) => s.key)),
		o = a8(r.filter((s) => !s.command(t)).map((s) => s.key));
	return E.useMemo(
		() =>
			m.jsx(GD, {
				"aria-label": "Text formatting",
				value: i,
				onChange: (s) => {
					const a = r.find((l) => l.key === s);
					a && n(a.command);
				},
				disabledKeys: o,
				selectionMode: "multiple",
				children: r.map((s) =>
					m.jsxs(
						Ze,
						{
							children: [
								m.jsx(n_, {
									value: s.key,
									"aria-label": s.label,
									children: m.jsx(ve, { src: s.icon }),
								}),
								m.jsxs(Xe, {
									children: [
										m.jsx(ue, { children: s.label }),
										"shortcut" in s &&
											m.jsx(fi, {
												meta: !0,
												children: s.shortcut,
											}),
									],
								}),
							],
						},
						s.key,
					),
				),
			}),
		[o, r, n, i],
	);
}
function a8(t) {
	return E.useMemo(() => t, [JSON.stringify(t)]);
}
function jFe(t, e) {
	const n = t.selection.$from.sharedDepth(t.selection.to);
	for (let r = n; r > 0; r--) {
		const i = t.selection.$from.node(r);
		if (i.type === e.nodes.ordered_list) return "ordered_list";
		if (i.type === e.nodes.unordered_list) return "unordered_list";
	}
	return null;
}
function _Fe() {
	const t = Fa(),
		e = ca(),
		n = On(),
		r = !!e.nodes.ordered_list && dd(e.nodes.ordered_list)(t),
		i = !!e.nodes.unordered_list && dd(e.nodes.unordered_list)(t),
		o = jFe(t, e),
		s = E.useMemo(
			() =>
				[
					!!e.nodes.unordered_list && {
						label: "Bullet list",
						key: "unordered_list",
						shortcut: "-",
						icon: jv,
					},
					!!e.nodes.ordered_list && {
						label: "Numbered list",
						key: "ordered_list",
						shortcut: "1.",
						icon: YD,
					},
				].filter(l8),
			[e.nodes.unordered_list, e.nodes.ordered_list],
		),
		a = E.useMemo(
			() => [!r && "ordered_list", !i && "unordered_list"].filter(l8),
			[r, i],
		);
	return E.useMemo(
		() =>
			s.length === 0
				? null
				: m.jsx(GD, {
						"aria-label": "Lists",
						value: o,
						onChange: (l) => {
							const u = l,
								c = e.nodes[u];
							c && n(dd(c));
						},
						disabledKeys: a,
						selectionMode: "single",
						children: s.map((l) =>
							m.jsxs(
								Ze,
								{
									children: [
										m.jsx(n_, {
											value: l.key,
											"aria-label": l.label,
											children: m.jsx(ve, {
												src: l.icon,
											}),
										}),
										m.jsxs(Xe, {
											children: [
												m.jsx(ue, {
													children: l.label,
												}),
												m.jsx(fi, {
													meta: !0,
													children: l.shortcut,
												}),
											],
										}),
									],
								},
								l.key,
							),
						),
					}),
		[o, a, n, s, e.nodes],
	);
}
function l8(t) {
	return t !== !1;
}
function zFe() {
	return (t, e) =>
		t.selection.empty
			? !1
			: (e && e(t.tr.removeMark(t.selection.from, t.selection.to)), !0);
}
function Z1(t) {
	return (e) => {
		let n = !1;
		for (const r of e.selection.ranges)
			if (
				(e.doc.nodesBetween(r.$from.pos, r.$to.pos, (i) => {
					i.type === t && (n = !0);
				}),
				n)
			)
				break;
		return n;
	};
}
let LFe = 0;
function VFe(t) {
	const e = af();
	return m.jsx("span", {
		className: sX,
		ref: E.useCallback(
			(n) => {
				if (!n) return;
				n.appendChild(t.node);
				const r = e.current;
				r && r.hasFocus() && r.focus();
			},
			[t.node, e],
		),
	});
}
const KFe = E.memo(function (e) {
	const n = ee(9);
	let r;
	n[0] !== e.contentDOM
		? ((r = e.contentDOM ? m.jsx(VFe, { node: e.contentDOM }) : null),
			(n[0] = e.contentDOM),
			(n[1] = r))
		: (r = n[1]);
	let i;
	return (
		n[2] !== e.component ||
		n[3] !== e.node ||
		n[4] !== e.getPos ||
		n[5] !== e.hasNodeSelection ||
		n[6] !== e.isNodeCompletelyWithinSelection ||
		n[7] !== r
			? ((i = m.jsx(e.component, {
					node: e.node,
					getPos: e.getPos,
					hasNodeSelection: e.hasNodeSelection,
					isNodeCompletelyWithinSelection:
						e.isNodeCompletelyWithinSelection,
					children: r,
				})),
				(n[2] = e.component),
				(n[3] = e.node),
				(n[4] = e.getPos),
				(n[5] = e.hasNodeSelection),
				(n[6] = e.isNodeCompletelyWithinSelection),
				(n[7] = r),
				(n[8] = i))
			: (i = n[8]),
		i
	);
});
function UFe(t) {
	const e = ee(12);
	let n;
	e[0] !== t.state
		? ((n = TE.getState(t.state)), (e[0] = t.state), (e[1] = n))
		: (n = e[1]);
	const r = n;
	let i;
	e[2] !== r.nodeViews
		? ((i = () => new Map(r.nodeViews)), (e[2] = r.nodeViews), (e[3] = i))
		: (i = e[3]);
	const [o, s] = E.useState(i);
	let a, l;
	e[4] !== r
		? ((a = () =>
				r.register(() => {
					s(new Map(r.nodeViews));
				})),
			(l = [r]),
			(e[4] = r),
			(e[5] = a),
			(e[6] = l))
		: ((a = e[5]), (l = e[6])),
		E.useLayoutEffect(a, l);
	const u = t.state.selection instanceof Qe ? t.state.selection.from : void 0,
		c = t.state.selection.from,
		d = t.state.selection.to;
	let f;
	return (
		e[7] !== o || e[8] !== u || e[9] !== c || e[10] !== d
			? ((f = m.jsx(m.Fragment, {
					children: [...o].map((h) => {
						const [p, g] = h,
							{ contentDOM: v, dom: b, node: y, getPos: x } = g,
							C = oX(y.type);
						if (!C) return null;
						const k = x();
						return k === void 0
							? null
							: nl.createPortal(
									m.jsx(KFe, {
										hasNodeSelection: u === k,
										isNodeCompletelyWithinSelection:
											k >= c && k + y.nodeSize <= d,
										node: y,
										contentDOM: v,
										component: C.component,
										getPos: x,
									}),
									b,
									p,
								);
					}),
				})),
				(e[7] = o),
				(e[8] = u),
				(e[9] = c),
				(e[10] = d),
				(e[11] = f))
			: (f = e[11]),
		f
	);
}
function oX(t) {
	return t.spec.reactNodeView;
}
const sX = X({ display: "contents" });
function u8(t) {
	const e = document.createElement(t);
	return e.classList.add(sX), e;
}
const TE = new Os("reactNodeViews");
function HFe(t) {
	const e = new Set();
	for (const r of Object.values(t.nodes))
		(r.spec.reactNodeView || r.spec.nodeView) && e.add(r);
	return new Gn({
		key: TE,
		state: {
			init() {
				const r = new Set();
				return {
					nodeViews: new Map(),
					callbacks: r,
					register: (i) => (
						r.add(i),
						() => {
							r.delete(i);
						}
					),
				};
			},
			apply(r, i) {
				return i;
			},
		},
		props: {
			nodeViews: Object.fromEntries(
				[...e].map((r) => [
					r.name,
					(i, o, s) => {
						if (r.spec.nodeView) return r.spec.nodeView(i, o, s);
						const a = oX(r),
							l = document.createElement(
								r.isInline ? "span" : "div",
							),
							u =
								(a != null && a.rendersOwnContent) || r.isLeaf
									? void 0
									: u8(r.inlineContent ? "div" : "span"),
							c = u8(r.inlineContent ? "div" : "span");
						l.appendChild(c);
						const d = `${LFe++}`,
							f = {
								contentDOM: u,
								dom: c,
								getPos: s,
								key: d,
								node: i,
							},
							h = TE.getState(o.state);
						h.nodeViews.set(d, f);
						const p = () => {
							for (const g of h.callbacks) g();
						};
						return (
							p(),
							{
								dom: l,
								contentDOM: u,
								destroy() {
									h.nodeViews.delete(d), p();
								},
								ignoreMutation(g) {
									return !(u != null && u.contains(g.target));
								},
								deselectNode() {},
								selectNode() {},
								update(g) {
									return g.type !== r
										? !1
										: (h.nodeViews.set(d, {
												...f,
												node: g,
											}),
											p(),
											!0);
								},
							}
						);
					},
				]),
			),
		},
	});
}
const OC = {
	deleteRow: { label: "Delete row", command: RSe },
	deleteColumn: { label: "Delete column", command: BSe },
	insertRowBelow: { label: "Insert row below", command: PSe },
	insertColumnRight: { label: "Insert column right", command: $Se },
};
function WFe() {
	const t = ee(12),
		e = On(),
		n = B.size.space.small;
	let r;
	t[0] === Symbol.for("react.memo_cache_sentinel")
		? ((r = X({ top: n, insetInlineEnd: n, position: "absolute" })),
			(t[0] = r))
		: (r = t[0]);
	let i;
	t[1] === Symbol.for("react.memo_cache_sentinel")
		? ((i = X({
				borderRadius: B.size.radius.small,
				height: "auto",
				minWidth: 0,
				padding: 0,
				"&::before": {
					content: '""',
					inset: `calc(${n} * -1)`,
					position: "absolute",
				},
			})),
			(t[1] = i))
		: (i = t[1]);
	let o;
	t[2] === Symbol.for("react.memo_cache_sentinel")
		? ((o = m.jsx(Re, {
				prominence: "low",
				"aria-label": "Cell options",
				UNSAFE_className: i,
				children: m.jsx(ve, { src: Il }),
			})),
			(t[2] = o))
		: (o = t[2]);
	let s;
	t[3] !== e
		? ((s = (f) => {
				f in OC && e(OC[f].command);
			}),
			(t[3] = e),
			(t[4] = s))
		: (s = t[4]);
	let a, l;
	t[5] === Symbol.for("react.memo_cache_sentinel")
		? ((a = Object.entries(OC).map((f) => {
				const [h, p] = f;
				return { ...p, key: h };
			})),
			(l = (f) => m.jsx(Mt, { children: f.label }, f.key)),
			(t[5] = a),
			(t[6] = l))
		: ((a = t[5]), (l = t[6]));
	let u;
	t[7] !== s
		? ((u = m.jsxs(Xo, {
				align: "end",
				children: [
					o,
					m.jsx(Jo, { onAction: s, items: a, children: l }),
				],
			})),
			(t[7] = s),
			(t[8] = u))
		: (u = t[8]);
	let c;
	t[9] === Symbol.for("react.memo_cache_sentinel")
		? ((c = m.jsx(Xe, { children: "Options" })), (t[9] = c))
		: (c = t[9]);
	let d;
	return (
		t[10] !== u
			? ((d = m.jsx("div", {
					contentEditable: !1,
					className: r,
					children: m.jsxs(Ze, { children: [u, c] }),
				})),
				(t[10] = u),
				(t[11] = d))
			: (d = t[11]),
		d
	);
}
function c8(t) {
	const e = YFe(t.selection.$from);
	if (e !== void 0) {
		const n = document.createElement("div"),
			r = Hn.widget(e + 1, n, { element: n, side: 1 });
		return { set: qt.create(t.doc, [r]), element: n };
	}
}
const xA = new Gn({
	state: {
		init(t, e) {
			return c8(e);
		},
		apply(t, e, n, r) {
			return c8(r);
		},
	},
	props: {
		decorations(t) {
			var e;
			return (e = xA.getState(t)) === null || e === void 0
				? void 0
				: e.set;
		},
	},
});
function qFe() {
	return xA;
}
function GFe() {
	const t = ee(4),
		e = Fa();
	let n, r;
	if (t[0] !== e) {
		r = Symbol.for("react.early_return_sentinel");
		e: {
			var i;
			const o =
				(i = xA.getState(e)) === null || i === void 0
					? void 0
					: i.element;
			if (!o) {
				r = null;
				break e;
			}
			let s;
			t[3] === Symbol.for("react.memo_cache_sentinel")
				? ((s = m.jsx(WFe, {})), (t[3] = s))
				: (s = t[3]),
				(n = nl.createPortal(s, o));
		}
		(t[0] = e), (t[1] = n), (t[2] = r);
	} else (n = t[1]), (r = t[2]);
	return r !== Symbol.for("react.early_return_sentinel") ? r : n;
}
function YFe(t) {
	for (let e = t.depth; e > 0; e--) {
		const r = t.node(e).type.spec.tableRole;
		if (r === "cell" || r === "header_cell") return t.before(e);
	}
}
const JFe = E.createContext({ id: "" }),
	XFe = JFe.Provider;
function ZFe(t) {
	return `keystatic-editor-root-${t}`;
}
function QFe(t) {
	return `keystatic-editor-toolbar-${t}`;
}
function e8e(t) {
	return `keystatic-editor-content-${t}`;
}
const t8e = X({
		flex: 1,
		height: "auto",
		minHeight: B.size.scale[2e3],
		minWidth: 0,
		outline: 0,
		padding: B.size.space.medium,
		'[data-layout="main"] > div > &': {
			boxSizing: "border-box",
			height: "100%",
			padding: 0,
			paddingTop: B.size.space.medium,
			minHeight: 0,
			minWidth: 0,
			maxWidth: 800,
			marginInline: "auto",
			[en.above.mobile]: { padding: B.size.space.xlarge },
			[en.above.tablet]: { padding: B.size.space.xxlarge },
			'&[data-container="wide"]': { padding: B.size.scale[600] },
		},
	}),
	n8e = E.forwardRef(function (e, n) {
		const r = ee(46);
		let i, o, s;
		r[0] !== e
			? (({ value: i, onChange: o, ...s } = e),
				(r[0] = e),
				(r[1] = i),
				(r[2] = o),
				(r[3] = s))
			: ((i = r[1]), (o = r[2]), (s = r[3]));
		const [a, l] = E.useState(i);
		if ("yjs" in o) {
			var u;
			((u = dn.getState(a)) === null || u === void 0
				? void 0
				: u.type) !== o.yjs() && l(i);
		}
		const c = xo(),
			d = g5(),
			f = c === "main" ? "medium" : "regular";
		let h;
		r[4] !== c || r[5] !== d
			? ((h = lt({ layout: c, container: d })),
				(r[4] = c),
				(r[5] = d),
				(r[6] = h))
			: (h = r[6]);
		let p;
		r[7] !== f || r[8] !== h
			? ((p = { size: f, UNSAFE_className: t8e, ...h }),
				(r[7] = f),
				(r[8] = h),
				(r[9] = p))
			: (p = r[9]);
		const g = VP(p);
		let v, b;
		cm.getState(i) ? ((v = a ?? i), (b = l)) : ((v = i), (b = o));
		const y = E.useId();
		let x, C;
		r[10] !== y ? ((C = { id: y }), (r[10] = y), (r[11] = C)) : (C = r[11]),
			(x = C);
		const k = x;
		let w;
		r[12] !== y ? ((w = ZFe(y)), (r[12] = y), (r[13] = w)) : (w = r[13]);
		let D;
		r[14] === Symbol.for("react.memo_cache_sentinel")
			? ((D = X(w7e, {
					'&[data-layout="main"]': {
						flex: 1,
						display: "flex",
						flexDirection: "column",
					},
					'&:not([data-layout="main"])': {
						border: `${B.size.border.regular} solid ${B.color.border.neutral}`,
						borderRadius: B.size.radius.medium,
					},
				})),
				(r[14] = D))
			: (D = r[14]);
		let S;
		r[15] !== y ? ((S = QFe(y)), (r[15] = y), (r[16] = S)) : (S = r[16]);
		let $;
		r[17] !== S
			? (($ = m.jsx(TFe, { id: S, "data-keystatic-editor": "toolbar" })),
				(r[17] = S),
				(r[18] = $))
			: ($ = r[18]);
		let A;
		r[19] !== y ? ((A = e8e(y)), (r[19] = y), (r[20] = A)) : (A = r[20]);
		let T;
		r[21] !== s || r[22] !== g || r[23] !== A
			? ((T = m.jsx("div", {
					children: m.jsx(Z7e, {
						...s,
						...g,
						role: "textbox",
						"aria-multiline": "true",
						id: A,
						"data-keystatic-editor": "content",
					}),
				})),
				(r[21] = s),
				(r[22] = g),
				(r[23] = A),
				(r[24] = T))
			: (T = r[24]);
		let I;
		r[25] !== w || r[26] !== c || r[27] !== $ || r[28] !== T
			? ((I = m.jsxs(pr, {
					id: w,
					"data-keystatic-editor": "root",
					"data-layout": c,
					backgroundColor: "canvas",
					minWidth: 0,
					UNSAFE_className: D,
					children: [$, T],
				})),
				(r[25] = w),
				(r[26] = c),
				(r[27] = $),
				(r[28] = T),
				(r[29] = I))
			: (I = r[29]);
		let F;
		r[30] !== v
			? ((F = m.jsx(UFe, { state: v })), (r[30] = v), (r[31] = F))
			: (F = r[31]);
		let N;
		r[32] === Symbol.for("react.memo_cache_sentinel")
			? ((N = m.jsx(GFe, {})), (r[32] = N))
			: (N = r[32]);
		let O;
		r[33] !== v
			? ((O = m.jsx(AFe, { state: v })), (r[33] = v), (r[34] = O))
			: (O = r[34]);
		let _;
		r[35] === Symbol.for("react.memo_cache_sentinel")
			? ((_ = m.jsx(iFe, {})), (r[35] = _))
			: (_ = r[35]);
		let j;
		r[36] !== v ||
		r[37] !== b ||
		r[38] !== n ||
		r[39] !== I ||
		r[40] !== F ||
		r[41] !== O
			? ((j = m.jsxs(Q7e, {
					value: v,
					onChange: b,
					ref: n,
					children: [I, F, N, O, _],
				})),
				(r[36] = v),
				(r[37] = b),
				(r[38] = n),
				(r[39] = I),
				(r[40] = F),
				(r[41] = O),
				(r[42] = j))
			: (j = r[42]);
		let V;
		return (
			r[43] !== k || r[44] !== j
				? ((V = m.jsx(XFe, { value: k, children: j })),
					(r[43] = k),
					(r[44] = j),
					(r[45] = V))
				: (V = r[45]),
			V
		);
	}),
	MC = [];
function r8e(t) {
	if (!t.type.spec.code || !t.childCount) return MC;
	const e = t.content.child(0).text;
	if (
		!e ||
		typeof t.attrs.language != "string" ||
		!Object.prototype.hasOwnProperty.call(Q.languages, t.attrs.language)
	)
		return MC;
	const r = [],
		i = Q.tokenize(e, Q.languages[t.attrs.language]);
	function o(s, a) {
		for (const l of a) {
			const u = BE(l),
				c = s + u;
			if (typeof l != "string") {
				const d = s8e.get(l.type);
				d && r.push({ attrs: { class: d }, from: s, to: c }),
					o(s, Array.isArray(l.content) ? l.content : [l.content]);
			}
			s = c;
		}
	}
	return o(0, i), r;
}
function i8e(t) {
	let e = 0;
	const n = [];
	for (let r = 0; r < t.childCount; r++) {
		const i = t.child(r),
			o = aX(i);
		if (!o.length) {
			e += i.nodeSize;
			continue;
		}
		const s = e + 1;
		for (const a of o)
			n.push({ attrs: a.attrs, from: a.from + s, to: a.to + s });
		e += i.nodeSize;
	}
	return n;
}
const aX = WJ((t) => (t.isTextblock ? r8e(t) : i8e(t.content)));
function o8e() {
	return new Gn({
		props: {
			decorations(t) {
				const e = aX(t.doc).map((n) =>
					Hn.inline(n.from, n.to, n.attrs),
				);
				return qt.create(t.doc, e);
			},
		},
	});
}
function BE(t) {
	return typeof t == "string"
		? t.length
		: Array.isArray(t.content)
			? t.content.reduce((e, n) => e + BE(n), 0)
			: BE(t.content);
}
const s8e = new Map(
		[
			{
				types: ["comment", "prolog", "doctype", "cdata"],
				style: {
					color: B.color.foreground.neutralTertiary,
					fontStyle: "italic",
				},
			},
			{
				types: ["atrule", "attr-name", "class-name", "selector"],
				style: { color: B.color.scale.amber11 },
			},
			{
				types: [
					"boolean",
					"constant",
					"inserted-sign",
					"entity",
					"inserted",
					"number",
					"regex",
					"symbol",
					"variable",
				],
				style: { color: B.color.scale.green11 },
			},
			{
				types: [
					"attr-value",
					"builtin",
					"char",
					"constant",
					"generics",
					"url",
				],
				style: { color: B.color.scale.pink11 },
			},
			{ types: ["string"], style: { color: B.color.scale.indigo9 } },
			{
				types: [
					"annotation",
					"deleted",
					"deleted-sign",
					"decorator",
					"important",
					"tag",
				],
				style: { color: B.color.scale.red11 },
			},
			{
				types: ["function", "function-variable", "operator"],
				style: { color: B.color.scale.purple11 },
			},
			{
				types: ["tag", "selector", "keyword"],
				style: { color: B.color.scale.indigo11 },
			},
			{
				types: ["punctuation"],
				style: { color: B.color.foreground.neutralSecondary },
			},
		].flatMap((t) => {
			const e = X(t.style);
			return t.types.map((n) => [n, e]);
		}),
	),
	jC =
		typeof navigator < "u"
			? /Mac|iP(hone|[oa]d)/.test(navigator.platform)
			: !1,
	a8e = (t, e, n) => {
		const { $head: r, $anchor: i } = t.selection;
		return !r.parent.type.spec.code || !r.sameParent(i)
			? !1
			: Qp(kj, Cj, wj)(t, e, n);
	};
function l8e(t, e) {
	for (let n = e; n > 0; n--) {
		let r = t.before(n);
		const i = t.doc.nodeAt(r);
		if (i && i.type.spec.selectable !== !1) return r;
	}
}
const u8e = (t, e) => {
	const { $from: n, to: r } = t.selection,
		i = n.sharedDepth(r);
	if (i === 0) return !1;
	const o = l8e(n, i);
	return o === void 0
		? !1
		: (e && e(t.tr.setSelection(Qe.create(t.doc, o))), !0);
};
function c8e({ nodes: t, marks: e, config: n }, r) {
	const i = {},
		o = (u, c) => {
			i[u] ? (i[u] = Qp(i[u], c)) : (i[u] = c);
		};
	t.list_item &&
		(o("Enter", A7e(t.list_item)),
		o("Tab", B7e(t.list_item)),
		o("Shift-Tab", YJ(t.list_item))),
		o("Enter", Qp(Yae, kj, Cj, wj));
	let s = Qp(I$, Vae, Kae),
		a = Qp(I$, Hae, Wae);
	o("Backspace", s),
		o("Mod-Backspace", s),
		o("Shift-Backspace", s),
		o("Delete", a),
		o("Mod-Delete", a),
		o("Mod-a", Xae),
		jC &&
			(o("Ctrl-h", s),
			o("Alt-Backspace", s),
			o("Ctrl-d", a),
			o("Ctrl-Alt-Backspace", a),
			o("Alt-Delete", a),
			o("Alt-d", a),
			o("Ctrl-a", Qae),
			o("Ctrl-e", ele)),
		o("Mod-z", r ? c2e : NG),
		o("Shift-Mod-z", r ? D7 : fE),
		jC && o("Mod-y", r ? D7 : fE);
	const l = ["Mod-Enter", "Shift-Enter"];
	jC && l.push("Ctrl-Enter");
	for (const u of l) o(u, a8e), t.hard_break && o(u, d8e(t.hard_break));
	for (const u of Object.values(e))
		if (u.spec.shortcuts) {
			if (Array.isArray(u.spec.shortcuts)) {
				for (const c of u.spec.shortcuts) {
					if (typeof c != "string")
						throw new Error(`Invalid shortcut for mark ${u.name}`);
					o(c, wc(u));
				}
				continue;
			}
			throw new Error(`Invalid shortcuts for mark ${u.name}`);
		}
	if (
		(o("Alt-ArrowUp", qae),
		o("Alt-ArrowDown", Gae),
		o("Escape", u8e),
		t.unordered_list && o("Shift-Ctrl-8", dd(t.unordered_list)),
		t.ordered_list && o("Shift-Ctrl-9", dd(t.ordered_list)),
		o("Shift-Ctrl-0", yd(t.paragraph)),
		t.heading)
	)
		for (const u of n.heading.levels)
			o(`Shift-Ctrl-${u}`, yd(t.heading, { level: u }));
	return i;
}
function d8e(t) {
	return (e, n) => (
		n && n(e.tr.replaceSelectionWith(t.create()).scrollIntoView()), !0
	);
}
function f8e(t = {}) {
	return new Gn({
		view(e) {
			return new h8e(e, t);
		},
	});
}
class h8e {
	constructor(e, n) {
		Fe(this, "cursorPos", null);
		Fe(this, "element", null);
		var r;
		(this.editorView = e),
			(this.width = (r = n.width) !== null && r !== void 0 ? r : 1),
			(this.color = n.color === !1 ? void 0 : n.color || "black"),
			(this.class = n.class),
			(this.handlers = ["dragover", "dragend", "drop", "dragleave"].map(
				(i) => {
					let o = (s) => {
						this[i](s);
					};
					return (
						e.dom.addEventListener(i, o), { name: i, handler: o }
					);
				},
			));
	}
	destroy() {
		this.handlers.forEach(({ name: e, handler: n }) =>
			this.editorView.dom.removeEventListener(e, n),
		);
	}
	update(e, n) {
		this.cursorPos != null &&
			n.doc != e.state.doc &&
			(this.cursorPos > e.state.doc.content.size
				? this.setCursor(null)
				: this.updateOverlay());
	}
	setCursor(e) {
		e != this.cursorPos &&
			((this.cursorPos = e),
			e == null
				? (this.element.parentNode.removeChild(this.element),
					(this.element = null))
				: this.updateOverlay());
	}
	updateOverlay() {
		let e = this.editorView.state.doc.resolve(this.cursorPos),
			n = !e.parent.inlineContent,
			r;
		if (n) {
			let a = e.nodeBefore,
				l = e.nodeAfter;
			if (a || l) {
				let u = this.editorView.nodeDOM(
					this.cursorPos - (a ? a.nodeSize : 0),
				);
				if (u) {
					let c = u.getBoundingClientRect(),
						d = a ? c.bottom : c.top;
					a &&
						l &&
						(d =
							(d +
								this.editorView
									.nodeDOM(this.cursorPos)
									.getBoundingClientRect().top) /
							2),
						(r = {
							left: c.left,
							right: c.right,
							top: d - this.width / 2,
							bottom: d + this.width / 2,
						});
				}
			}
		}
		if (!r) {
			let a = this.editorView.coordsAtPos(this.cursorPos);
			r = {
				left: a.left - this.width / 2,
				right: a.left + this.width / 2,
				top: a.top,
				bottom: a.bottom,
			};
		}
		let i = this.editorView.dom.offsetParent;
		this.element ||
			((this.element = i.appendChild(document.createElement("div"))),
			this.class && (this.element.className = this.class),
			(this.element.style.cssText =
				"position: absolute; z-index: 50; pointer-events: none;"),
			this.color && (this.element.style.backgroundColor = this.color)),
			this.element.classList.toggle("prosemirror-dropcursor-block", n),
			this.element.classList.toggle("prosemirror-dropcursor-inline", !n);
		let o, s;
		if (
			!i ||
			(i == document.body && getComputedStyle(i).position == "static")
		)
			(o = -pageXOffset), (s = -pageYOffset);
		else {
			let a = i.getBoundingClientRect();
			(o = a.left - i.scrollLeft), (s = a.top - i.scrollTop);
		}
		(this.element.style.left = r.left - o + "px"),
			(this.element.style.top = r.top - s + "px"),
			(this.element.style.width = r.right - r.left + "px"),
			(this.element.style.height = r.bottom - r.top + "px");
	}
	scheduleRemoval(e) {
		this.timeout !== void 0 && clearTimeout(this.timeout),
			(this.timeout = setTimeout(() => this.setCursor(null), e));
	}
	dragover(e) {
		if (!this.editorView.editable) return;
		let n = this.editorView.posAtCoords({
				left: e.clientX,
				top: e.clientY,
			}),
			r =
				n &&
				n.inside >= 0 &&
				this.editorView.state.doc.nodeAt(n.inside),
			i = r && r.type.spec.disableDropCursor,
			o = typeof i == "function" ? i(this.editorView, n, e) : i;
		if (n && !o) {
			let s = n.pos;
			if (this.editorView.dragging && this.editorView.dragging.slice) {
				let a = Iv(
					this.editorView.state.doc,
					s,
					this.editorView.dragging.slice,
				);
				a != null && (s = a);
			}
			this.setCursor(s), this.scheduleRemoval(5e3);
		}
	}
	dragend() {
		this.scheduleRemoval(20);
	}
	drop() {
		this.scheduleRemoval(20);
	}
	dragleave(e) {
		(e.target == this.editorView.dom ||
			!this.editorView.dom.contains(e.relatedTarget)) &&
			this.setCursor(null);
	}
}
function p8e() {
	return new Gn({
		props: {
			decorations: v8e,
			createSelectionBetween(t, e, n) {
				return e.pos == n.pos && Sn.valid(n) ? new Sn(n) : null;
			},
			handleClick: g8e,
			handleKeyDown: m8e,
			handleDOMEvents: { beforeinput: b8e },
		},
	});
}
const m8e = G5({
	ArrowLeft: Q1("horiz", -1),
	ArrowRight: Q1("horiz", 1),
	ArrowUp: Q1("vert", -1),
	ArrowDown: Q1("vert", 1),
});
function Q1(t, e) {
	const n = t == "vert" ? (e > 0 ? "down" : "up") : e > 0 ? "right" : "left";
	return function (r, i, o) {
		let s = r.selection,
			a = e > 0 ? s.$to : s.$from,
			l = s.empty;
		if (s instanceof kt) {
			if (!o.endOfTextblock(n) || a.depth == 0) return !1;
			(l = !1), (a = r.doc.resolve(e > 0 ? a.after() : a.before()));
		}
		let u = Sn.findGapCursorFrom(a, e, l);
		return u ? (i && i(r.tr.setSelection(new Sn(u))), !0) : !1;
	};
}
function g8e(t, e, n) {
	if (!t || !t.editable) return !1;
	let r = t.state.doc.resolve(e);
	if (!Sn.valid(r)) return !1;
	let i = t.posAtCoords({ left: n.clientX, top: n.clientY });
	return i && i.inside > -1 && Qe.isSelectable(t.state.doc.nodeAt(i.inside))
		? !1
		: (t.dispatch(t.state.tr.setSelection(new Sn(r))), !0);
}
function b8e(t, e) {
	if (
		e.inputType != "insertCompositionText" ||
		!(t.state.selection instanceof Sn)
	)
		return !1;
	let { $from: n } = t.state.selection,
		r = n.parent
			.contentMatchAt(n.index())
			.findWrapping(t.state.schema.nodes.text);
	if (!r) return !1;
	let i = be.empty;
	for (let s = r.length - 1; s >= 0; s--)
		i = be.from(r[s].createAndFill(null, i));
	let o = t.state.tr.replace(n.pos, n.pos, new Ee(i, 0, 0));
	return o.setSelection(kt.near(o.doc.resolve(n.pos + 1))), t.dispatch(o), !1;
}
function v8e(t) {
	if (!(t.selection instanceof Sn)) return null;
	let e = document.createElement("div");
	return (
		(e.className = "ProseMirror-gapcursor"),
		qt.create(t.doc, [Hn.widget(t.selection.head, e, { key: "gapcursor" })])
	);
}
const y8e = 500;
function x8e({ rules: t, enterRules: e }) {
	return new Gn({
		props: {
			handleTextInput(n) {
				return (
					setTimeout(() => {
						_C(n, t);
					}),
					!1
				);
			},
			handleKeyDown(n, r) {
				return r.key === "Enter" ? _C(n, e) : !1;
			},
			handleDOMEvents: {
				compositionend: (n) => {
					setTimeout(() => {
						_C(n, t);
					});
				},
			},
		},
	});
}
function k8e(t, e, n, r) {
	const i = t.doc.resolve(e);
	if (i.parent.type.spec.code) return;
	const o = i.parent.textBetween(
		Math.max(0, i.parentOffset - y8e),
		i.parentOffset,
		null,
		"￼",
	);
	for (const s of r) {
		const a = s.pattern.exec(o);
		if (!a) continue;
		const l = e - a[0].length,
			u = s.handler(t, a, l, n);
		if (u) return u;
	}
}
function _C(t, e) {
	const n = t.state;
	if (t.composing || !(n.selection instanceof kt)) return !1;
	const { $cursor: r } = n.selection;
	if (!r) return !1;
	const i = k8e(n, r.pos, r.pos, e);
	if (!i) return !1;
	const o = ad.getState(t.state);
	return (
		o ? (o.undoManager.stopCapturing(), t.dispatch(i)) : t.dispatch(QSe(i)),
		!0
	);
}
function zC(t, e = null, n) {
	return (r, i, o, s) => {
		let a = e instanceof Function ? e(i) : e,
			l = r.tr.delete(o, s),
			u = l.doc.resolve(o),
			c = u.blockRange(),
			d = c && zD(c, t, a);
		if (!d) return null;
		l.wrap(c, d);
		let f = l.doc.resolve(o - 1).nodeBefore;
		return f && f.type == t && Qh(l.doc, o - 1) && !n && l.join(o - 1), l;
	};
}
function IE(t, e = null) {
	return (n, r, i, o) => {
		let s = n.doc.resolve(i),
			a = e instanceof Function ? e(r) : e;
		return a === !1 ||
			!s.node(-1).canReplaceWith(s.index(-1), s.indexAfter(-1), t)
			? null
			: n.tr.delete(i, o).setBlockType(i, i, t, a);
	};
}
function C8e(t, e = null) {
	return (n, r, i, o) => {
		let s = n.doc.resolve(i),
			a = e instanceof Function ? e(r) : e;
		return s.node(-1).canReplaceWith(s.index(-1), s.indexAfter(-1), t)
			? n.tr.delete(i, o).replaceSelectionWith(t.createAndFill(a))
			: null;
	};
}
function w8e(t) {
	return (e, n, r, i) => {
		let o = t;
		if (n[1]) {
			let s = n[0].lastIndexOf(n[1]);
			(o += n[0].slice(s + n[1].length)), (r += s);
			let a = r - i;
			a > 0 && ((o = n[0].slice(s - a, s) + o), (r = i));
		}
		return e.tr.insertText(o, r, i);
	};
}
const E8e = {
		"...": "…",
		"-->": "→",
		"->": "→",
		"<-": "←",
		"<--": "←",
		"--": "–",
		"(c)": "©",
		"(r)": "®",
		"(tm)": "™",
	},
	D8e = new Map([
		["bold", ["**", "__"]],
		["italic", ["*", "_"]],
		["strikethrough", ["~~"]],
		["code", ["`"]],
	]),
	S8e = Object.entries(E8e).map(([t, e]) => ({
		pattern: new RegExp(`(${um(t)})\\s$`),
		handler: w8e(e),
	}));
function A8e({ nodes: t, marks: e, config: n }) {
	const r = [...S8e];
	t.blockquote && r.push({ pattern: /^\s*>\s$/, handler: zC(t.blockquote) }),
		t.ordered_list &&
			r.push({
				pattern: /^\s*(\d+)(?:\.|\))\s$/,
				handler: zC(t.ordered_list, (o) => ({
					start: parseInt(o[1], 10),
				})),
			}),
		t.unordered_list &&
			r.push({
				pattern: /^\s*([-+*])\s$/,
				handler: zC(t.unordered_list),
			}),
		t.code_block &&
			r.push({
				pattern: /^```(\w+)?\s$/,
				handler: IE(t.code_block, (o) => {
					var s;
					return {
						language: (s = o[1]) !== null && s !== void 0 ? s : "",
					};
				}),
			}),
		t.divider && r.push({ pattern: /^---$/, handler: C8e(t.divider) }),
		t.heading &&
			r.push({
				pattern: /^(#{1,6})\s$/,
				handler: IE(t.heading, (o) =>
					n.heading.levels.includes(o[1].length)
						? { level: o[1].length }
						: null,
				),
			});
	for (const [o, s] of D8e) {
		const a = e[o];
		for (const l of s)
			a &&
				r.push({
					pattern: new RegExp(
						`${l[0] === "_" ? "(?:^|\\s)" : l === "*" ? "(?:^|[^\\*])" : ""}${um(l)}([^${um(l[0])}\\s]|(?:[^${um(l[0])}\\s].*[^\\s]))${um(l)}$`,
					),
					handler: (u, [, c], d, f) => {
						const h = f - c.length - l.length * 2;
						if (!d8(u.doc, h, f, a)) return null;
						const p = u.tr;
						return (
							p.addMark(h + l.length, f - l.length, a.create()),
							p.delete(f - l.length, f),
							p.delete(h, h + l.length),
							p.removeStoredMark(a),
							p
						);
					},
				});
	}
	const i = e.link;
	return (
		i &&
			r.push({
				pattern: /(?:^|[^!])\[(.*)\]\((.*)\)$/,
				handler(o, [, s, a], l, u) {
					const c = u - a.length - s.length - 4;
					if (!d8(o.doc, c, u, i)) return null;
					const d = o.tr;
					return (
						d.addMark(c, u, i.create({ href: a })),
						d.delete(c + 1 + s.length, u),
						d.delete(c, c + 1),
						d.removeStoredMark(i),
						d
					);
				},
			}),
		r.push(pFe),
		r
	);
}
function $8e({ nodes: t }) {
	const e = [];
	return (
		t.code_block &&
			e.push({
				pattern: /^```(\w+)?$/,
				handler: IE(t.code_block, (n) => {
					var r;
					return {
						language: (r = n[1]) !== null && r !== void 0 ? r : "",
					};
				}),
			}),
		e
	);
}
function d8(t, e, n, r) {
	let i = !0;
	return (
		t.nodesBetween(e, n, (o) => {
			!o.isText && !o.type.allowsMarkType(r) && (i = !1);
		}),
		i
	);
}
function f8(t) {
	return t === T5.sanitizeUrl(t);
}
const h8 = /^https?:\/\//;
function T8e(t, e, n) {
	let r = !1;
	return (
		t.doc.nodesBetween(t.pos, e.pos, (i) => {
			if (i.marks.some((o) => o.type === n.marks.link))
				return (r = !0), !1;
		}),
		r
	);
}
function B8e(t) {
	if (!t.marks.link) return new Gn({});
	const e = t.marks.link;
	return new Gn({
		props: {
			transformPasted(n) {
				var r, i;
				return n.content.childCount === 1 &&
					((r = n.content.firstChild) === null || r === void 0
						? void 0
						: r.type) === t.nodes.paragraph &&
					((i = n.content.firstChild.firstChild) === null ||
					i === void 0
						? void 0
						: i.text) !== void 0 &&
					h8.test(n.content.firstChild.firstChild.text) &&
					f8(n.content.firstChild.firstChild.text) &&
					n.content.firstChild.firstChild.marks.length === 0
					? Ee.maxOpen(
							be.from(
								t.nodes.paragraph.createChecked(
									null,
									t.schema.text(
										n.content.firstChild.firstChild.text,
										[
											e.create({
												href: n.content.firstChild
													.firstChild.text,
												title: "",
											}),
										],
									),
								),
							),
						)
					: n;
			},
			handlePaste(n, r) {
				var i;
				const o =
					(i = r.clipboardData) === null || i === void 0
						? void 0
						: i.getData("text/plain");
				if (
					o &&
					h8.test(o) &&
					f8(o) &&
					!n.state.selection.empty &&
					n.state.selection.$from.parent ===
						n.state.selection.$to.parent &&
					!T8e(n.state.selection.$from, n.state.selection.$to, t)
				) {
					const { tr: s } = n.state;
					return (
						s.addMark(
							n.state.selection.from,
							n.state.selection.to,
							e.create({ href: o, title: "" }),
						),
						n.dispatch(s),
						!0
					);
				}
				return !1;
			},
		},
	});
}
function lX(t, e, n, r) {
	let i = [],
		o = 0,
		s = [],
		a = "";
	function l() {
		let c = i;
		for (let d = 0; d < o; d++) {
			const f = c[c.length - 1];
			if (!("children" in f))
				throw new Error("Expected children in last element");
			c = f.children;
		}
		return c;
	}
	const u = (c, d, f) => {
		var h;
		let p = c ? c.marks : [],
			g = a;
		if (
			((a = ""),
			(h = c) !== null &&
				h !== void 0 &&
				h.isText &&
				p.some((b) => p8(b.type) && !b.isInSet(s)))
		) {
			let [, b, y] = /^(\s*)(.*)$/m.exec(c.text);
			b && ((g += b), (c = y ? c.withText(y) : null), c || (p = s));
		}
		if (
			c &&
			c.isText &&
			p.some(
				(b) =>
					p8(b.type) &&
					(f == t.childCount - 1 || !b.isInSet(t.child(f + 1).marks)),
			)
		) {
			let [, b, y] = /^(.*?)(\s*)$/m.exec(c.text);
			y && ((a = y), (c = b ? c.withText(b) : null), c || (p = s));
		}
		e: for (const [b, y] of p.entries())
			if (m8(y.type))
				for (const [x, C] of s.entries()) {
					if (!m8(C.type)) break;
					if (y.eq(C)) {
						b > x
							? (p = p
									.slice(0, x)
									.concat(y)
									.concat(p.slice(x, b))
									.concat(p.slice(b + 1, p.length)))
							: x > b &&
								(p = p
									.slice(0, b)
									.concat(p.slice(b + 1, x))
									.concat(y)
									.concat(p.slice(x, p.length)));
						continue e;
					}
				}
		let v = 0;
		for (; v < Math.min(s.length, p.length) && p[v].eq(s[v]); ) ++v;
		for (; v < s.length; ) {
			const b = s.pop();
			b.type !== kr(b.type.schema).marks.code && o--;
		}
		if ((g && l().push(e(g)), c)) {
			for (; s.length < p.length; ) {
				let y = p[s.length];
				s.push(y);
				const x = r(y);
				x && (l().push(x), o++);
			}
			const b = n(c);
			b && l().push(b);
		}
	};
	return t.forEach(u), u(null, 0, t.childCount), i;
}
function p8(t) {
	const e = kr(t.schema);
	return (
		t === e.marks.bold ||
		t === e.marks.italic ||
		t === e.marks.strikethrough
	);
}
function m8(t) {
	const e = kr(t.schema);
	return (
		t === e.marks.bold ||
		t === e.marks.italic ||
		t === e.marks.strikethrough ||
		t === e.marks.link
	);
}
function I8e(t, e) {
	const n = [];
	return (
		t.forEach((r) => {
			n.push(kA(r, e));
		}),
		n
	);
}
function F8e(t, e) {
	return [
		new Ue.Node(
			"inline",
			{},
			lX(
				t,
				(n) => new Ue.Node("text", { content: n }),
				(n) => P8e(n, e),
				(n) => N8e(n, e),
			),
		),
	];
}
function P8e(t, e) {
	const { schema: n } = e;
	if (t.type === n.nodes.hard_break) return new Ue.Node("hardbreak");
	if (t.type === n.nodes.image) {
		const { src: i, filename: o } = t.attrs;
		if (
			typeof e.schema.config.image == "object" &&
			typeof e.schema.config.image.directory == "string"
		) {
			const s = xr(e.schema.config.image.directory);
			e.otherFiles.has(s) || e.otherFiles.set(s, new Map()),
				e.otherFiles.get(s).set(o, i);
		} else e.extraFiles.set(o, i);
		return new Ue.Node("image", {
			src: encodeURI(`${Z3(e.schema.config, e.slug)}${t.attrs.filename}`),
			alt: t.attrs.alt,
			title: t.attrs.title,
		});
	}
	const r = e.schema.components[t.type.name];
	if ((r == null ? void 0 : r.kind) === "inline") {
		const i = new Ue.Node(
			"tag",
			Ru(r.schema, t.attrs.props, e),
			[],
			t.type.name,
		);
		return (i.inline = !0), i;
	}
	if (t.text !== void 0)
		return new Ue.Node(
			t.marks.some((i) => i.type === n.marks.code) ? "code" : "text",
			{ content: t.text },
		);
}
function N8e(t, e) {
	const { schema: n } = e;
	if (t.type === n.marks.code) return;
	const r = n.components[t.type.name];
	if (r) {
		const o = new Ue.Node(
			"tag",
			Ru(r.schema, t.attrs.props, e),
			[],
			t.type.name,
		);
		return (o.inline = !0), o;
	}
	let i;
	if (
		(t.type === n.marks.bold && (i = "strong"),
		t.type === n.marks.italic && (i = "em"),
		t.type === n.marks.strikethrough && (i = "s"),
		i)
	)
		return new Ue.Node(i, {}, []);
	if (t.type === n.marks.link)
		return new Ue.Node("link", {
			href: t.attrs.href,
			title: t.attrs.title,
		});
}
function kA(t, e) {
	const n = (a) => I8e(a, e),
		r = (a) => F8e(a, e),
		i = kr(t.type.schema);
	if (t.type === i.nodes.doc)
		return new Ue.Node("document", {}, n(t.content));
	if (t.type === i.nodes.paragraph)
		return new Ue.Node("paragraph", {}, r(t.content));
	if (t.type === i.nodes.blockquote)
		return new Ue.Node("blockquote", {}, n(t.content));
	if (t.type === i.nodes.divider) return new Ue.Node("hr");
	if (t.type === i.nodes.table) {
		const a = n(t.content),
			l = new Ue.Node("thead", {}, []);
		a[0].children[0].type === "th" && l.children.push(a.shift());
		const u = new Ue.Node("tbody", {}, a);
		return new Ue.Node(
			"tag",
			{},
			[new Ue.Node("table", {}, [l, u])],
			"table",
		);
	}
	if (t.type === i.nodes.table_row)
		return new Ue.Node("tr", {}, n(t.content));
	if (t.type === i.nodes.table_header)
		return new Ue.Node("th", {}, n(t.content));
	if (t.type === i.nodes.table_cell)
		return new Ue.Node("td", {}, n(t.content));
	if (t.type === i.nodes.heading) {
		const a = Ru(i.config.heading.schema, t.attrs.props, e),
			l = new Ue.Node(
				"heading",
				{ level: t.attrs.level, ...a },
				r(t.content),
			);
		for (const [u, c] of Object.entries(a))
			l.annotations.push({ name: u, value: c, type: "attribute" });
		return l;
	}
	if (t.type === i.nodes.code_block) {
		const a = Ru(i.config.codeBlock.schema, t.attrs.props, e),
			l = new Ue.Node(
				"fence",
				typeof t.attrs.language == "string" &&
				t.attrs.language !== "plain"
					? {
							language: t.attrs.language,
							content:
								t.textBetween(0, t.content.size) +
								`
`,
							...a,
						}
					: {
							content:
								t.textBetween(0, t.content.size) +
								`
`,
							...a,
						},
				r(t.content),
			);
		for (const [u, c] of Object.entries(a))
			l.annotations.push({ name: u, value: c, type: "attribute" });
		return l;
	}
	if (t.type === i.nodes.list_item) {
		let a = n(t.content);
		return (
			a.length === 1 && a[0].type === "paragraph"
				? (a = a[0].children)
				: a.length === 2 &&
					a[0].type === "paragraph" &&
					a[0].children.length === 1 &&
					a[1].type === "list" &&
					(a = [a[0].children[0], a[1]]),
			new Ue.Node("item", {}, a)
		);
	}
	if (t.type === i.nodes.ordered_list)
		return new Ue.Node(
			"list",
			{ ordered: !0, start: t.attrs.start },
			n(t.content),
		);
	if (t.type === i.nodes.unordered_list)
		return new Ue.Node("list", { ordered: !1 }, n(t.content));
	const o = t.type.name,
		s = i.components[o];
	if (s) {
		const a =
			s.kind === "wrapper" || s.kind === "repeating" ? n(t.content) : [];
		return new Ue.Node("tag", Ru(s.schema, t.attrs.props, e), a, o);
	}
	return new Ue.Node("paragraph", {}, r(t.content));
}
let Yf;
function rs() {
	if (!Yf) throw new Error("state not set");
	return Yf;
}
function uX() {
	return rs().schema;
}
function uu(t) {
	rs().errors.push(t);
}
function R8e(t, e) {
	const n = rs(),
		r = n.marks;
	n.marks = t.addToSet(n.marks);
	try {
		return e();
	} finally {
		n.marks = r;
	}
}
function zc(t, e) {
	const n = [];
	for (const r of t) {
		const i = e4(r, e);
		i && (Array.isArray(i) ? n.push(...i) : n.push(i));
	}
	return n;
}
function Wi(t, e) {
	return (
		uu({
			error: {
				id: "unspecified-type",
				level: "critical",
				message: `${t.type} is not allowed`,
			},
			lines: t.lines,
			type: t.type,
			location: t.location,
		}),
		zc(t.children, e)
	);
}
function Kl(t, e, n) {
	let r = zc(t.children, e);
	const i = e.createAndFill(n, r);
	return (
		i ||
			uu({
				error: {
					id: "unexpected-children",
					level: "critical",
					message: `${t.type} has unexpected children`,
				},
				lines: t.lines,
				type: t.type,
				location: t.location,
			}),
		i
	);
}
function Kp(t, e, n) {
	return e
		? R8e(e instanceof Zh ? e.create() : e, () => zc(t.children, n))
		: Wi(t, n);
}
function cX(t, e, n, r, i) {
	Yf = {
		schema: e,
		errors: [],
		marks: [],
		extraFiles: n ?? new Map(),
		otherFiles: r ?? new Map(),
		slug: i,
	};
	try {
		let o = e4(t, void 0);
		if (Yf.errors.length)
			throw new Error(
				Yf.errors.map((s) => s.lines[0] + ":" + s.error.message).join(`
`),
			);
		if (!(o instanceof ia)) throw new Error("unexpected node");
		return o;
	} finally {
		Yf = void 0;
	}
}
function LC(t, e) {
	const n = uX(),
		r = [];
	for (const o of t.children) {
		const s = e4(o, n.nodes.paragraph);
		if (s) {
			if (!Array.isArray(s)) {
				if (s.isInline) {
					r.push(n.nodes.paragraph.createAndFill({}, s));
					continue;
				}
				r.push(s);
				continue;
			}
			if (o.type === "inline") {
				r.push(n.nodes.paragraph.createAndFill({}, s));
				continue;
			}
			r.push(...s);
		}
	}
	const i = e.createAndFill({}, r);
	return (
		i ||
			uu({
				error: {
					id: "unexpected-children",
					level: "critical",
					message: `${t.type} has unexpected children`,
				},
				lines: t.lines,
				type: t.type,
				location: t.location,
			}),
		i
	);
}
function e4(t, e) {
	if (t.errors.length) {
		for (const s of t.errors)
			uu({
				error: s,
				lines: t.lines,
				type: t.type,
				location: t.location,
			});
		return null;
	}
	if (t.type === "error")
		return (
			uu({
				error: {
					id: "error-node",
					level: "critical",
					message: "Unexpected error node without errors",
				},
				lines: t.lines,
				type: t.type,
				location: t.location,
			}),
			null
		);
	const n = uX();
	if (t.type === "inline") return zc(t.children, e);
	if (t.type === "em") return Kp(t, n.marks.italic, e);
	if (t.type === "code")
		return n.marks.code
			? n.schema.text(t.attributes.content, [
					...rs().marks,
					n.marks.code.create(),
				])
			: Wi(t, e);
	if (t.type === "s") return Kp(t, n.marks.strikethrough, e);
	if (t.type === "strong") return Kp(t, n.marks.bold, e);
	if (t.type === "softbreak")
		return n.schema.text(`
`);
	if (t.type === "hardbreak")
		return n.nodes.hard_break ? n.nodes.hard_break.create() : Wi(t, e);
	if (t.type === "blockquote")
		return n.nodes.blockquote ? Kl(t, n.nodes.blockquote, {}) : Wi(t, e);
	if (t.type === "heading") {
		if (!n.nodes.heading) return Wi(t, e);
		const { level: s, ...a } = t.attributes,
			l = rs(),
			u = l.schema.config.heading.schema;
		return Kl(t, n.nodes.heading, {
			level: t.attributes.level,
			props: fn(Mm(u, a, l), u),
		});
	}
	if (t.type === "paragraph") return Kl(t, n.nodes.paragraph, {});
	if (t.type === "comment") return [];
	if (t.type === "document") return Kl(t, n.nodes.doc, {});
	if (t.type === "fence") {
		if (!n.nodes.code_block) return Wi(t, e);
		let { language: s, content: a, ...l } = t.attributes;
		const u = rs(),
			c = u.schema.config.codeBlock.schema;
		return (
			(a = a.slice(0, -1)),
			n.nodes.code_block.createAndFill(
				{
					language:
						typeof t.attributes.language == "string"
							? t.attributes.language
							: "",
					props: fn(Mm(c, l, u), c),
				},
				a ? n.schema.text(a) : void 0,
			)
		);
	}
	if (t.type === "hr")
		return n.nodes.divider ? Kl(t, n.nodes.divider, {}) : Wi(t, e);
	if (t.type === "link") {
		var r;
		return Kp(
			t,
			(r = n.marks.link) === null || r === void 0
				? void 0
				: r.create({ href: t.attributes.href }),
			e,
		);
	}
	if (t.type === "text")
		return n.schema.text(t.attributes.content, rs().marks);
	if (t.type === "item")
		return n.nodes.list_item ? LC(t, n.nodes.list_item) : Wi(t, e);
	if (t.type === "list") {
		const s = t.attributes.ordered
			? n.nodes.ordered_list
			: n.nodes.unordered_list;
		return s
			? Kl(
					t,
					s,
					t.attributes.ordered && t.attributes.start !== void 0
						? { start: t.attributes.start }
						: {},
				)
			: Wi(t, e);
	}
	if (t.type === "table")
		return n.nodes.table ? Kl(t, n.nodes.table, {}) : Wi(t, e);
	if (t.type === "tbody" || t.type === "thead") return zc(t.children, e);
	if (t.type === "tr")
		return n.nodes.table_row ? Kl(t, n.nodes.table_row, {}) : Wi(t, e);
	if (t.type === "th")
		return n.nodes.table_header ? LC(t, n.nodes.table_header) : Wi(t, e);
	if (t.type === "td")
		return n.nodes.table_cell ? LC(t, n.nodes.table_cell) : Wi(t, e);
	if (t.type === "tag" && t.tag) {
		if (t.tag === "table") return e4(t.children[0], e);
		const s = n.components[t.tag];
		if (s) {
			const a = rs(),
				l = Mm(s.schema, t.attributes, a);
			if (s.kind === "mark")
				return Kp(
					t,
					n.schema.marks[t.tag].create({ props: fn(l, s.schema) }),
					e,
				);
			const u = n.schema.nodes[t.tag],
				c = zc(t.children, u),
				d = u.createAndFill({ props: fn(l, s.schema) }, c);
			return (
				d ||
					uu({
						error: {
							id: "unexpected-children",
							level: "critical",
							message: `${t.type} has unexpected children`,
						},
						lines: t.lines,
						type: t.type,
						location: t.location,
					}),
				s.kind === "inline" && !(e != null && e.isTextblock)
					? n.nodes.paragraph.createAndFill({}, d)
					: d
			);
		}
		return (
			uu({
				error: {
					id: "unspecified-type",
					level: "critical",
					message: `Missing component definition for ${t.tag}`,
				},
				lines: t.lines,
				type: t.type,
				location: t.location,
			}),
			zc(t.children, e)
		);
	}
	if (t.type === "image") {
		var i, o;
		const s = Z3(n.config, rs().slug),
			l = decodeURIComponent(t.attributes.src).slice(s.length),
			u =
				(i =
					typeof n.config.image == "object" &&
					typeof n.config.image.directory == "string"
						? rs().otherFiles.get(xr(n.config.image.directory))
						: rs().extraFiles) === null || i === void 0
					? void 0
					: i.get(l);
		return u && n.nodes.image
			? n.nodes.image.createChecked({
					src: u,
					alt: t.attributes.alt,
					title: t.attributes.title,
					filename: l,
				})
			: n.schema.text(
					`![${t.attributes.alt || ""}](${t.attributes.src || ""}${(o = t.attributes.title) !== null && o !== void 0 && o.length ? ` "${t.attributes.title}"` : ""})`,
				);
	}
	return (
		uu({
			error: {
				id: "unhandled-type",
				level: "critical",
				message: `Unhandled type ${t.type}`,
			},
			lines: t.lines,
			type: t.type,
			location: t.location,
		}),
		null
	);
}
function O8e() {
	return new Gn({
		props: {
			clipboardTextSerializer(t, e) {
				try {
					return _m(
						kA(e.state.doc.type.create({}, t.content), {
							otherFiles: new Map(),
							extraFiles: new Map(),
							schema: kr(e.state.schema),
							slug: void 0,
						}),
					);
				} catch (n) {
					return (
						console.log(
							"failed to serialize clipboard text as markdoc",
							n,
						),
						t.content.textBetween(
							0,
							t.content.size,
							`

`,
						)
					);
				}
			},
			clipboardTextParser(t, e, n, r) {
				try {
					return Ee.maxOpen(
						cX(ju(t), kr(r.state.schema), void 0, void 0, void 0)
							.content,
					);
				} catch (i) {
					return (
						console.log(
							"failed to parse clipboard text as markdoc",
							i,
						),
						j8e(t, e, n, r)
					);
				}
			},
			handlePaste(t, e) {
				if (
					(t.props.editable && !t.props.editable(t.state)) ||
					!e.clipboardData
				)
					return !1;
				const n = e.clipboardData.getData("text/html");
				if (n && M8e(n)) {
					const r = e.clipboardData.getData("text/plain");
					return t.pasteText(r), !0;
				}
				return !1;
			},
		},
	});
}
function M8e(t) {
	const n = new globalThis.DOMParser().parseFromString(t, "text/html"),
		r = n.body.firstElementChild;
	if (
		n.body.childElementCount !== 1 ||
		(r == null ? void 0 : r.tagName) !== "DIV" ||
		!(r instanceof HTMLElement) ||
		!r.style.fontFamily.includes("monospace")
	)
		return !1;
	for (const i of r.children)
		if (i.tagName !== "BR") {
			if (i.tagName !== "DIV") return !1;
			for (const o of i.children) if (o.tagName !== "SPAN") return !1;
		}
	return !0;
}
function j8e(t, e, n, r) {
	let i = e.marks(),
		{ schema: o } = r.state,
		s = Jd.fromSchema(o),
		a = document.createElement("div");
	return (
		t.split(/(?:\r\n?|\n)+/).forEach((u) => {
			let c = a.appendChild(document.createElement("p"));
			u && c.appendChild(s.serializeNode(o.text(u, i)));
		}),
		(
			r.someProp("clipboardParser") ||
			r.someProp("domParser") ||
			jD.fromSchema(r.state.schema)
		).parseSlice(a, {
			preserveWhitespace: !0,
			context: e,
			ruleFromNode(u) {
				return u.nodeName == "BR" &&
					!u.nextSibling &&
					u.parentNode &&
					!_8e.test(u.parentNode.nodeName)
					? { ignore: !0 }
					: null;
			},
		})
	);
}
const _8e =
	/^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
function z8e() {
	return new Gn({
		props: {
			decorations(t) {
				const e = [];
				let n, r;
				if (
					(t.selection instanceof kt &&
						({ from: n, to: r } = t.selection),
					t.selection instanceof ji &&
						((n = 0), (r = t.doc.content.size)),
					n !== void 0 && r !== void 0)
				) {
					const i = n,
						o = r;
					t.doc.nodesBetween(n, r, (s, a) => {
						if (s.isText) return;
						const l = a,
							u = a + s.nodeSize;
						l >= i &&
							u <= o &&
							e.push(
								Hn.node(a, a + s.nodeSize, {
									class: _r.nodeInSelection,
								}),
							);
					});
				}
				return qt.create(t.doc, e);
			},
		},
	});
}
function L8e(t) {
	return new Gn({
		props: {
			decorations(e) {
				var n;
				let r = e.doc;
				if (
					r.childCount === 1 &&
					(n = r.firstChild) !== null &&
					n !== void 0 &&
					n.isTextblock &&
					r.firstChild.content.size === 0
				) {
					let i = document.createElement("span");
					return (
						(i.className = _r.placeholder),
						(i.textContent = t),
						qt.create(r, [Hn.widget(1, i)])
					);
				}
			},
		},
	});
}
const V8e = (t) => {
	const e = document.createElement("span");
	e.classList.add("ProseMirror-yjs-cursor"), (e.style.borderColor = t.color);
	const n = document.createElement("div");
	return (
		(n.style.backgroundColor = t.color),
		n.insertBefore(document.createTextNode(t.name), null),
		e.insertBefore(n, null),
		e
	);
};
function t4(t, e, n, r, i) {
	const o = kr(t.type.schema);
	return _f.create({
		selection: e,
		storedMarks: n,
		plugins: [
			B8e(o),
			eFe(o),
			dFe(),
			...(r && i
				? [
						Wwe(r),
						u2e(i, {
							cursorBuilder: V8e,
							awarenessStateFilter(s, a, l) {
								const u = i.getLocalState();
								return (
									s !== a &&
									l.location ===
										(u == null ? void 0 : u.location) &&
									l.branch === (u == null ? void 0 : u.branch)
								);
							},
						}),
						h2e(),
					]
				: [e5e()]),
			f8e({ color: B.color.alias.borderSelected, width: 2 }),
			x8e({ rules: A8e(o), enterRules: $8e(o) }),
			p8e(),
			dSe(c8e(o, !!(r && i))),
			O8e(),
			z8e(),
			L8e('Start writing or press "/" for commands…'),
			HFe(t.type.schema),
			lFe(),
			HSe(),
			qFe(),
			o8e(),
		],
		doc: t,
	});
}
let Jf;
function Qi() {
	if (!Jf) throw new Error("state not set");
	return Jf;
}
function qa(t) {
	Qi().errors.push(t);
}
function K8e() {
	return Qi().schema;
}
function U8e(t, e) {
	const n = Qi(),
		r = n.marks;
	n.marks = t.addToSet(n.marks);
	try {
		return e();
	} finally {
		n.marks = r;
	}
}
function dh(t, e) {
	const n = [];
	for (const r of t) {
		const i = dX(r, e);
		i && (Array.isArray(i) ? n.push(...i) : n.push(i));
	}
	return n;
}
function Ai(t, e) {
	return (
		qa(`${t.type} is not allowed`), dh("children" in t ? t.children : [], e)
	);
}
function Us(t, e, n, r) {
	let i = dh("children" in t ? t.children : [], e);
	r && (i = r(i));
	const o = e.createAndFill(n, i);
	return o || qa(`${t.type} has unexpected children`), o;
}
function kf(t, e, n) {
	return e
		? U8e(e instanceof Zh ? e.create() : e, () =>
				dh("children" in t ? t.children : [], n),
			)
		: Ai(t, n);
}
function H8e(t, e, n, r, i) {
	(Jf = {
		schema: e,
		errors: [],
		marks: [],
		extraFiles: n ?? new Map(),
		otherFiles: r ?? new Map(),
		slug: i,
		definitions: new Map(),
	}),
		jG(t, (o) => {
			if (o.type === "definition") {
				const s = String(o.identifier).toUpperCase();
				Qi().definitions.has(s) || Qi().definitions.set(s, o);
			}
		});
	try {
		let o = dX(t, void 0);
		if (Jf.errors.length)
			throw new Error(
				Jf.errors.join(`
`),
			);
		if (!(o instanceof ia)) throw new Error("unexpected node");
		return o;
	} finally {
		Jf = void 0;
	}
}
const g8 = (t) => (e) => {
	const n = [];
	let r = [];
	for (const i of e) {
		if (i.isInline) {
			r.push(i);
			continue;
		}
		r.length && (n.push(t.nodes.paragraph.createChecked({}, r)), (r = [])),
			n.push(i);
	}
	return r.length && n.push(t.nodes.paragraph.createChecked({}, r)), n;
};
function W8e(t) {
	wt(t.body.length === 1);
	const e = t.body[0];
	return wt(e.type === "ExpressionStatement"), FE(e.expression);
}
function FE(t) {
	if (t.type === "Literal") {
		const e = t.value;
		return (
			wt(
				typeof e == "string" ||
					typeof e == "number" ||
					typeof e == "boolean" ||
					e === null,
			),
			e
		);
	}
	if (t.type === "ArrayExpression")
		return t.elements.map(
			(e) => (wt(e !== null && e.type !== "SpreadElement"), FE(e)),
		);
	if (t.type === "ObjectExpression")
		return Object.fromEntries(
			t.properties.map((e) => {
				wt(e.type === "Property" && !e.computed && e.kind === "init");
				const n = e.key,
					r =
						n.type === "Identifier"
							? n.name
							: n.type === "Literal"
								? n.value
								: void 0;
				return wt(typeof r == "string"), [r, FE(e.value)];
			}),
		);
	throw new Error(`Unexpected expression type ${t.type}`);
}
function dX(t, e) {
	const n = K8e();
	if (t.type === "emphasis") return kf(t, n.marks.italic, e);
	if (t.type === "inlineCode")
		return n.marks.code
			? n.schema.text(t.value, [...Qi().marks, n.marks.code.create()])
			: Ai(t, e);
	if (t.type === "delete") return kf(t, n.marks.strikethrough, e);
	if (t.type === "strong") return kf(t, n.marks.bold, e);
	if (t.type === "break")
		return n.nodes.hard_break ? n.nodes.hard_break.create() : Ai(t, e);
	if (t.type === "blockquote")
		return n.nodes.blockquote ? Us(t, n.nodes.blockquote, {}) : Ai(t, e);
	if (t.type === "heading")
		return n.nodes.heading
			? Us(t, n.nodes.heading, { level: t.depth })
			: Ai(t, e);
	if (t.type === "paragraph") return Us(t, n.nodes.paragraph, {});
	if (t.type === "root") return Us(t, n.nodes.doc, {});
	if (t.type === "code") {
		if (!n.nodes.code_block) return Ai(t, e);
		let s = typeof t.lang == "string" ? t.lang : "";
		return (
			t.meta && (s += " " + t.meta),
			n.nodes.code_block.createAndFill(
				{ language: s },
				n.schema.text(t.value),
			)
		);
	}
	if (t.type === "thematicBreak")
		return n.nodes.divider ? Us(t, n.nodes.divider, {}) : Ai(t, e);
	if (t.type === "link") {
		var r;
		return kf(
			t,
			(r = n.marks.link) === null || r === void 0
				? void 0
				: r.create({ href: t.url }),
			e,
		);
	}
	if (t.type === "linkReference") {
		var i;
		const s = Qi().definitions.get(t.identifier.toUpperCase());
		return s
			? kf(
					t,
					(i = n.marks.link) === null || i === void 0
						? void 0
						: i.create({ href: s.url }),
					e,
				)
			: (qa(`Could not find definition for ${t.identifier}`),
				dh(t.children, e));
	}
	if (t.type === "text") return n.schema.text(t.value, Qi().marks);
	if (t.type === "listItem")
		return n.nodes.list_item
			? Us(t, n.nodes.list_item, {}, g8(n))
			: Ai(t, e);
	if (t.type === "list") {
		const s = t.ordered ? n.nodes.ordered_list : n.nodes.unordered_list;
		return s
			? Us(t, s, t.ordered && t.start != null ? { start: t.start } : {})
			: Ai(t, e);
	}
	if (t.type === "table")
		return n.nodes.table ? Us(t, n.nodes.table, {}) : Ai(t, e);
	if (t.type === "tableRow")
		return n.nodes.table_row ? Us(t, n.nodes.table_row, {}) : Ai(t, e);
	if (t.type === "tableCell")
		return n.nodes.table_cell
			? Us(t, n.nodes.table_cell, {}, g8(n))
			: Ai(t, e);
	if (t.type === "mdxJsxFlowElement" || t.type === "mdxJsxTextElement") {
		if (!t.name) return Ai(t, e);
		const s = n.components[t.name];
		if (s) {
			const a = Qi(),
				l = {};
			for (const f of t.attributes) {
				if (f.type === "mdxJsxAttribute") {
					if (f.value == null) {
						l[f.name] = !0;
						continue;
					}
					try {
						l[f.name] =
							typeof f.value == "string"
								? f.value
								: W8e(f.value.data.estree);
					} catch {
						qa(`${t.type} has unexpected attributes`);
					}
					continue;
				}
				qa(`${t.type} has unexpected attributes`);
			}
			const u = Mm(s.schema, l, a);
			if (s.kind === "mark")
				return t.type === "mdxJsxFlowElement"
					? Ai(t, e)
					: kf(
							t,
							n.schema.marks[t.name].create({
								props: fn(u, s.schema),
							}),
							e,
						);
			const c = n.schema.nodes[t.name],
				d = c.createAndFill(
					{ props: fn(u, s.schema) },
					dh(t.children, c),
				);
			return (
				d || qa(`${t.type} has unexpected children`),
				s.kind === "inline" && !(e != null && e.isTextblock)
					? n.nodes.paragraph.createAndFill({}, d)
					: d
			);
		}
		return (
			qa(`Missing component definition for ${t.name}`),
			dh("children" in t ? t.children : [], e)
		);
	}
	if (t.type === "image" || t.type === "imageReference") {
		var o;
		const s =
			t.type === "image"
				? t
				: Qi().definitions.get(t.identifier.toUpperCase());
		if (!s)
			return qa(`Could not find definition for ${t.identifier}`), null;
		const a = Z3(n.config, Qi().slug),
			u = decodeURI(s.url).slice(a.length),
			c =
				(o =
					typeof n.config.image == "object" &&
					typeof n.config.image.directory == "string"
						? Qi().otherFiles.get(xr(n.config.image.directory))
						: Qi().extraFiles) === null || o === void 0
					? void 0
					: o.get(u);
		return c && n.nodes.image
			? n.nodes.image.createChecked({
					src: c,
					alt: t.alt,
					title: s.title,
					filename: u,
				})
			: n.schema.text(
					`![${t.alt || ""}](${s.url || ""}${s.title ? ` "${s.title}"` : ""})`,
				);
	}
	return t.type === "definition"
		? []
		: (qa(
				`Unhandled type ${t.type}: ${YG(t, { extensions: [XG(), nY()], rule: "-" })}`,
			),
			null);
}
function fX(t, e) {
	const n = [];
	return (
		t.forEach((r) => {
			n.push(X8e(r, e));
		}),
		n
	);
}
function q8e(t, e) {
	return lX(
		t,
		(n) => ({ type: "text", value: n }),
		(n) => G8e(n, e),
		(n) => Y8e(n, e),
	);
}
function CA(t) {
	return Object.entries(t).map(([e, n]) => ({
		type: "mdxJsxAttribute",
		name: e,
		value:
			n === !0
				? null
				: typeof n == "string"
					? n
					: {
							type: "mdxJsxAttributeValueExpression",
							value: JSON.stringify(n),
						},
	}));
}
function G8e(t, e) {
	const { schema: n } = e;
	if (t.type === n.nodes.hard_break) return { type: "break" };
	if (t.type === n.nodes.image) {
		const { src: i, filename: o } = t.attrs;
		if (
			typeof e.schema.config.image == "object" &&
			typeof e.schema.config.image.directory == "string"
		) {
			const s = xr(e.schema.config.image.directory);
			e.otherFiles.has(s) || e.otherFiles.set(s, new Map()),
				e.otherFiles.get(s).set(o, i);
		} else e.extraFiles.set(o, i);
		return {
			type: "image",
			url: encodeURI(`${Z3(e.schema.config, e.slug)}${t.attrs.filename}`),
			alt: t.attrs.alt,
			title: t.attrs.title,
		};
	}
	const r = e.schema.components[t.type.name];
	if ((r == null ? void 0 : r.kind) === "inline")
		return {
			type: "mdxJsxTextElement",
			name: t.type.name,
			attributes: CA(Ru(r.schema, t.attrs.props, e)),
			children: [],
		};
	if (t.text !== void 0)
		return {
			type: t.marks.some((i) => i.type === n.marks.code)
				? "inlineCode"
				: "text",
			value: t.text,
		};
}
function Y8e(t, e) {
	const { schema: n } = e;
	if (t.type === n.marks.code) return;
	const r = n.components[t.type.name];
	if (r)
		return {
			type: "mdxJsxTextElement",
			name: t.type.name,
			attributes: CA(Ru(r.schema, t.attrs.props, e)),
			children: [],
		};
	let i;
	if (
		(t.type === n.marks.bold && (i = "strong"),
		t.type === n.marks.italic && (i = "emphasis"),
		t.type === n.marks.strikethrough && (i = "delete"),
		i)
	)
		return { type: i, children: [] };
	if (t.type === n.marks.link)
		return {
			type: "link",
			url: t.attrs.href,
			title: t.attrs.title,
			children: [],
		};
}
function eb(t, e) {
	const n = [];
	return (
		t.content.forEach((r) => {
			n.push(e(r));
		}),
		n
	);
}
function b8(t) {
	return {
		type: "listItem",
		spread:
			t.length === 2 && t[0].type === "paragraph" && t[1].type === "list"
				? !1
				: void 0,
		children: t,
	};
}
function J8e(t, e) {
	return { type: "root", children: fX(t.content, e) };
}
function X8e(t, e) {
	const n = (l) => fX(l, e),
		r = (l) => q8e(l, e),
		i = kr(t.type.schema);
	if (t.type === i.nodes.paragraph)
		return { type: "paragraph", children: r(t.content) };
	if (t.type === i.nodes.blockquote)
		return { type: "blockquote", children: n(t.content) };
	if (t.type === i.nodes.divider) return { type: "thematicBreak" };
	if (t.type === i.nodes.table)
		return {
			type: "table",
			children: eb(t, (l) => ({
				type: "tableRow",
				children: eb(l, (u) => ({
					type: "tableCell",
					children: r(u.content.child(0).content),
				})),
			})),
		};
	if (t.type === i.nodes.heading)
		return {
			type: "heading",
			depth: t.attrs.level,
			children: r(t.content),
		};
	if (t.type === i.nodes.code_block) {
		var o;
		let l =
				typeof t.attrs.language == "string" &&
				t.attrs.language !== "plain"
					? t.attrs.language
					: void 0,
			u = null;
		return (
			(o = l) !== null &&
				o !== void 0 &&
				o.includes(" ") &&
				([l, u] = l.split(" ", 2)),
			{ type: "code", lang: l, meta: u, value: t.textContent }
		);
	}
	if (t.type === i.nodes.ordered_list)
		return {
			type: "list",
			ordered: !0,
			spread: !1,
			start: t.attrs.start,
			children: eb(t, (l) => b8(n(l.content))),
		};
	if (t.type === i.nodes.unordered_list)
		return {
			type: "list",
			spread: !1,
			children: eb(t, (l) => b8(n(l.content))),
		};
	const s = t.type.name,
		a = i.components[s];
	if (a) {
		const l =
			a.kind === "wrapper" || a.kind === "repeating" ? n(t.content) : [];
		return {
			type: "mdxJsxFlowElement",
			name: s,
			attributes: CA(Ru(a.schema, t.attrs.props, e)),
			children: l,
		};
	}
	return { type: "paragraph", children: r(t.content) };
}
function n4(t) {
	return t4(t.nodes.doc.createAndFill());
}
function hX(t, e, n, r, i) {
	const o = cX(ju(t), e, n, r, i);
	return t4(o);
}
function pX(t, e) {
	const n = new Map(),
		r = new Map(),
		i = kA(t.doc, {
			extraFiles: n,
			otherFiles: r,
			schema: kr(t.schema),
			slug: e,
		}),
		o = _m(i);
	return { content: _m(ju(o)), other: n, external: r };
}
function mX(t, e, n, r, i) {
	const o = lG(t, {
			extensions: [z$e(), w6e()],
			mdastExtensions: [r6e(), DAe()],
		}),
		s = H8e(o, e, n, r, i);
	return t4(s);
}
function gX(t, e) {
	const n = new Map(),
		r = new Map(),
		i = J8e(t.doc, {
			extraFiles: n,
			otherFiles: r,
			schema: kr(t.schema),
			slug: e,
		});
	return {
		content: YG(i, { extensions: [XG(), nY()], rule: "-" }),
		other: n,
		external: r,
	};
}
function r4(t) {
	const e = ee(12),
		n = xo();
	let r;
	e[0] !== t.label || e[1] !== t.description
		? ((r = {
				label: t.label,
				labelElementType: "span",
				description: t.description,
			}),
			(e[0] = t.label),
			(e[1] = t.description),
			(e[2] = r))
		: (r = e[2]);
	let i = r;
	if (n === "main") {
		let l;
		e[3] !== t.label
			? ((l = { "aria-label": t.label }), (e[3] = t.label), (e[4] = l))
			: (l = e[4]),
			(i = l);
	}
	const o = n === "main" ? "100%" : void 0;
	let s;
	e[5] !== t.value || e[6] !== t.onChange
		? ((s = (l) =>
				m.jsx(n8e, { ...l, value: t.value, onChange: t.onChange })),
			(e[5] = t.value),
			(e[6] = t.onChange),
			(e[7] = s))
		: (s = e[7]);
	let a;
	return (
		e[8] !== o || e[9] !== i || e[10] !== s
			? ((a = m.jsx(bD, { height: o, ...i, children: s })),
				(e[8] = o),
				(e[9] = i),
				(e[10] = s),
				(e[11] = a))
			: (a = e[11]),
		a
	);
}
function i4(t, e, n) {
	return t4(r2e(t.schema, e), void 0, void 0, e, n);
}
const Z8e = Ag({
		label: "Alt text",
		description:
			"This text will be used by screen readers and search engines.",
	}),
	Q8e = Hi({
		Input() {
			return null;
		},
		defaultValue() {
			return "";
		},
		parse(t) {
			if (t === void 0) return "";
			if (typeof t != "string") throw new st("Must be string");
			return t;
		},
		validate(t) {
			return t;
		},
		serialize(t) {
			return { value: t };
		},
		label: "Title",
	});
function Z0(t) {
	var e, n, r, i, o, s, a, l, u, c;
	return {
		bold: (e = t.bold) !== null && e !== void 0 ? e : !0,
		italic: (n = t.italic) !== null && n !== void 0 ? n : !0,
		strikethrough: (r = t.strikethrough) !== null && r !== void 0 ? r : !0,
		code: (i = t.code) !== null && i !== void 0 ? i : !0,
		heading: (() => {
			let d = [],
				f =
					typeof t.heading == "object" && !Array.isArray(t.heading)
						? t.heading.levels
						: t.heading;
			return (
				(f === !0 || f === void 0) && (d = [1, 2, 3, 4, 5, 6]),
				Array.isArray(f) && (d = f),
				{
					levels: d,
					schema:
						t.heading &&
						typeof t.heading == "object" &&
						"schema" in t.heading
							? t.heading.schema
							: {},
				}
			);
		})(),
		blockquote: (o = t.blockquote) !== null && o !== void 0 ? o : !0,
		orderedList: (s = t.orderedList) !== null && s !== void 0 ? s : !0,
		unorderedList: (a = t.unorderedList) !== null && a !== void 0 ? a : !0,
		table: (l = t.table) !== null && l !== void 0 ? l : !0,
		link: (u = t.link) !== null && u !== void 0 ? u : !0,
		image:
			t.image !== !1
				? ((d, f, h, p, g) => {
						const v = t.image === !0 ? void 0 : t.image;
						return {
							directory: v == null ? void 0 : v.directory,
							publicPath: v == null ? void 0 : v.publicPath,
							transformFilename:
								(d =
									v == null
										? void 0
										: v.transformFilename) !== null &&
								d !== void 0
									? d
									: (b) => b,
							schema: {
								alt:
									(f =
										v == null ||
										(h = v.schema) === null ||
										h === void 0
											? void 0
											: h.alt) !== null && f !== void 0
										? f
										: Z8e,
								title:
									(p =
										v == null ||
										(g = v.schema) === null ||
										g === void 0
											? void 0
											: g.title) !== null && p !== void 0
										? p
										: Q8e,
							},
						};
					})()
				: void 0,
		divider: (c = t.divider) !== null && c !== void 0 ? c : !0,
		codeBlock:
			t.codeBlock === !1
				? void 0
				: {
						schema:
							typeof t.codeBlock == "object"
								? t.codeBlock.schema
								: {},
					},
	};
}
function e9e(t) {
	if (t.kind === "object" || t.kind === "conditional")
		return { type: Object, required: !0 };
	if (t.kind === "array") return { type: Array, required: !0 };
	if (t.kind === "child") return {};
	if (t.formKind === void 0) {
		if (
			typeof t.defaultValue == "string" &&
			"options" in t &&
			Array.isArray(t.options) &&
			t.options.every(
				(e) =>
					typeof e == "object" &&
					e !== null &&
					"value" in e &&
					typeof e.value == "string",
			)
		)
			return {
				type: String,
				matches: t.options.map((e) => e.value),
				required: !0,
			};
		if (typeof t.defaultValue == "string") {
			let e = !1;
			try {
				t.parse("");
			} catch {
				e = !0;
			}
			return { type: String, required: e };
		}
		try {
			return t.parse(1), { type: Number };
		} catch {}
		return typeof t.defaultValue == "boolean"
			? { type: Boolean, required: !0 }
			: {};
	}
	if (t.formKind === "slug") {
		let e = !1;
		try {
			t.parse("", void 0);
		} catch {
			e = !0;
		}
		return { type: String, required: e };
	}
	if (t.formKind === "asset") {
		let e = !1;
		try {
			t.validate(null);
		} catch {
			e = !0;
		}
		return { type: String, required: e };
	}
	return {};
}
function VC(t) {
	return Object.fromEntries(
		Object.entries(t).map(([e, n]) => {
			const r = e9e(n);
			return [e, r];
		}),
	);
}
function t9e(t) {
	const e = Z0(t.options || {}),
		n = { nodes: { ...Ep }, tags: {} };
	e.heading.levels.length
		? (n.nodes.heading = {
				...Ep.heading,
				attributes: {
					...Ep.heading.attributes,
					...VC(e.heading.schema),
				},
			})
		: (n.nodes.heading = void 0),
		e.blockquote || (n.nodes.blockquote = void 0),
		e.codeBlock
			? (n.nodes.fence = {
					...Ep.fence,
					attributes: {
						...Ep.fence.attributes,
						...VC(e.codeBlock.schema),
					},
				})
			: (n.nodes.fence = void 0),
		!e.orderedList && !e.unorderedList && (n.nodes.list = void 0),
		e.bold || (n.nodes.strong = void 0),
		e.italic || (n.nodes.em = void 0),
		e.strikethrough || (n.nodes.s = void 0),
		e.link || (n.nodes.link = void 0),
		e.image || (n.nodes.image = void 0),
		e.divider || (n.nodes.hr = void 0),
		e.table || (n.nodes.table = void 0);
	for (const [o, s] of Object.entries(t.components || {})) {
		var r;
		const a = s.kind === "block" || s.kind === "inline";
		n.tags[o] = {
			render:
				(r = t.render) === null ||
				r === void 0 ||
				(r = r.tags) === null ||
				r === void 0
					? void 0
					: r[o],
			children: a ? [] : void 0,
			selfClosing: a,
			attributes: VC(s.schema),
			description: "description" in s ? s.description : void 0,
			inline: s.kind === "inline" || s.kind === "mark",
		};
	}
	for (const [o, s] of Object.entries(
		((i = t.render) === null || i === void 0 ? void 0 : i.nodes) || {},
	)) {
		var i;
		const a = n.nodes[o];
		a && (a.render = s);
	}
	return n;
}
const Hy = new TextDecoder(),
	bX = new TextEncoder();
function o4(t, e) {
	return [
		...b3(
			Ir(
				Object.fromEntries(
					Object.entries(t).map(([n, r]) => [n, Ir(r.schema)]),
				),
			),
		),
		...(typeof e.image == "object" && typeof e.image.directory == "string"
			? [xr(e.image.directory)]
			: []),
	];
}
function wA({
	label: t,
	description: e,
	options: n = {},
	components: r = {},
	extension: i = "mdoc",
}) {
	let o;
	const s = Z0(n);
	let a = () => (o || (o = J3(s, r, !1)), o);
	return {
		kind: "form",
		formKind: "content",
		defaultValue() {
			return n4(a());
		},
		Input(l) {
			return m.jsx(r4, { description: e, label: t, ...l });
		},
		parse: (l, { content: u, other: c, external: d, slug: f }) => {
			const h = Hy.decode(u);
			return hX(h, a(), c, d, f);
		},
		contentExtension: `.${i}`,
		validate(l) {
			return l;
		},
		directories: o4(r, s),
		serialize(l, { slug: u }) {
			const c = pX(l, u);
			return {
				content: bX.encode(c.content),
				external: c.external,
				other: c.other,
				value: void 0,
			};
		},
		reader: {
			parse: (l, { content: u }) => {
				const c = Hy.decode(u);
				return { node: ju(c) };
			},
		},
		collaboration: {
			toYjs(l) {
				return N3(l.doc);
			},
			fromYjs(l, u) {
				return i4(a(), l, u);
			},
		},
	};
}
wA.createMarkdocConfig = t9e;
wA.inline = function ({
	label: e,
	description: n,
	options: r = {},
	components: i = {},
}) {
	let o;
	const s = Z0(r);
	let a = () => (o || (o = J3(s, i, !1)), o);
	return {
		kind: "form",
		formKind: "assets",
		defaultValue() {
			return n4(a());
		},
		Input(l) {
			return m.jsx(r4, { description: n, label: e, ...l });
		},
		parse: (l, { other: u, external: c, slug: d }) => {
			if ((l === void 0 && (l = ""), typeof l != "string"))
				throw new st("Must be a string");
			return hX(l, a(), u, c, d);
		},
		validate(l) {
			return l;
		},
		directories: o4(i, s),
		serialize(l, { slug: u }) {
			const c = pX(l, u);
			return { external: c.external, other: c.other, value: c.content };
		},
		reader: {
			parse: (l) => {
				if ((l === void 0 && (l = ""), typeof l != "string"))
					throw new st("Must be a string");
				return { node: ju(l) };
			},
		},
		collaboration: {
			toYjs(l) {
				return N3(l.doc);
			},
			fromYjs(l, u) {
				return i4(a(), l, u);
			},
		},
	};
};
function vX({
	label: t,
	description: e,
	options: n = {},
	components: r = {},
	extension: i = "mdx",
}) {
	let o;
	const s = Z0(n);
	let a = () => (o || (o = J3(s, r, !0)), o);
	return {
		kind: "form",
		formKind: "content",
		defaultValue() {
			return n4(a());
		},
		Input(l) {
			return m.jsx(r4, { description: e, label: t, ...l });
		},
		parse: (l, { content: u, other: c, external: d, slug: f }) => {
			const h = Hy.decode(u);
			return mX(h, a(), c, d, f);
		},
		contentExtension: `.${i}`,
		validate(l) {
			return l;
		},
		directories: o4(r, s),
		serialize(l, { slug: u }) {
			const c = gX(l, u);
			return {
				content: bX.encode(c.content),
				external: c.external,
				other: c.other,
				value: void 0,
			};
		},
		reader: { parse: (l, { content: u }) => Hy.decode(u) },
		collaboration: {
			toYjs(l) {
				return N3(l.doc);
			},
			fromYjs(l, u) {
				return i4(a(), l, u);
			},
		},
	};
}
vX.inline = function ({
	label: e,
	description: n,
	options: r = {},
	components: i = {},
}) {
	let o;
	const s = Z0(r);
	let a = () => (o || (o = J3(s, i, !0)), o);
	return {
		kind: "form",
		formKind: "assets",
		defaultValue() {
			return n4(a());
		},
		Input(l) {
			return m.jsx(r4, { description: n, label: e, ...l });
		},
		parse: (l, { other: u, external: c, slug: d }) => {
			if ((l === void 0 && (l = ""), typeof l != "string"))
				throw new st("Must be a string");
			return mX(l, a(), u, c, d);
		},
		validate(l) {
			return l;
		},
		directories: o4(i, s),
		serialize(l, { slug: u }) {
			const c = gX(l, u);
			return { external: c.external, other: c.other, value: c.content };
		},
		reader: {
			parse: (l) => {
				if ((l === void 0 && (l = ""), typeof l != "string"))
					throw new st("Must be a string");
				return l;
			},
		},
		collaboration: {
			toYjs(l) {
				return N3(l.doc);
			},
			fromYjs(l, u) {
				return i4(a(), l, u);
			},
		},
	};
};
/*! js-yaml 4.1.0 https://github.com/nodeca/js-yaml @license MIT */ function yX(
	t,
) {
	return typeof t > "u" || t === null;
}
function n9e(t) {
	return typeof t == "object" && t !== null;
}
function r9e(t) {
	return Array.isArray(t) ? t : yX(t) ? [] : [t];
}
function i9e(t, e) {
	var n, r, i, o;
	if (e)
		for (o = Object.keys(e), n = 0, r = o.length; n < r; n += 1)
			(i = o[n]), (t[i] = e[i]);
	return t;
}
function o9e(t, e) {
	var n = "",
		r;
	for (r = 0; r < e; r += 1) n += t;
	return n;
}
function s9e(t) {
	return t === 0 && Number.NEGATIVE_INFINITY === 1 / t;
}
var a9e = yX,
	l9e = n9e,
	u9e = r9e,
	c9e = o9e,
	d9e = s9e,
	f9e = i9e,
	nr = {
		isNothing: a9e,
		isObject: l9e,
		toArray: u9e,
		repeat: c9e,
		isNegativeZero: d9e,
		extend: f9e,
	};
function xX(t, e) {
	var n = "",
		r = t.reason || "(unknown reason)";
	return t.mark
		? (t.mark.name && (n += 'in "' + t.mark.name + '" '),
			(n += "(" + (t.mark.line + 1) + ":" + (t.mark.column + 1) + ")"),
			!e &&
				t.mark.snippet &&
				(n +=
					`

` + t.mark.snippet),
			r + " " + n)
		: r;
}
function _g(t, e) {
	Error.call(this),
		(this.name = "YAMLException"),
		(this.reason = t),
		(this.mark = e),
		(this.message = xX(this, !1)),
		Error.captureStackTrace
			? Error.captureStackTrace(this, this.constructor)
			: (this.stack = new Error().stack || "");
}
_g.prototype = Object.create(Error.prototype);
_g.prototype.constructor = _g;
_g.prototype.toString = function (e) {
	return this.name + ": " + xX(this, e);
};
var Pi = _g;
function KC(t, e, n, r, i) {
	var o = "",
		s = "",
		a = Math.floor(i / 2) - 1;
	return (
		r - e > a && ((o = " ... "), (e = r - a + o.length)),
		n - r > a && ((s = " ..."), (n = r + a - s.length)),
		{
			str: o + t.slice(e, n).replace(/\t/g, "→") + s,
			pos: r - e + o.length,
		}
	);
}
function UC(t, e) {
	return nr.repeat(" ", e - t.length) + t;
}
function h9e(t, e) {
	if (((e = Object.create(e || null)), !t.buffer)) return null;
	e.maxLength || (e.maxLength = 79),
		typeof e.indent != "number" && (e.indent = 1),
		typeof e.linesBefore != "number" && (e.linesBefore = 3),
		typeof e.linesAfter != "number" && (e.linesAfter = 2);
	for (
		var n = /\r?\n|\r|\0/g, r = [0], i = [], o, s = -1;
		(o = n.exec(t.buffer));

	)
		i.push(o.index),
			r.push(o.index + o[0].length),
			t.position <= o.index && s < 0 && (s = r.length - 2);
	s < 0 && (s = r.length - 1);
	var a = "",
		l,
		u,
		c = Math.min(t.line + e.linesAfter, i.length).toString().length,
		d = e.maxLength - (e.indent + c + 3);
	for (l = 1; l <= e.linesBefore && !(s - l < 0); l++)
		(u = KC(
			t.buffer,
			r[s - l],
			i[s - l],
			t.position - (r[s] - r[s - l]),
			d,
		)),
			(a =
				nr.repeat(" ", e.indent) +
				UC((t.line - l + 1).toString(), c) +
				" | " +
				u.str +
				`
` +
				a);
	for (
		u = KC(t.buffer, r[s], i[s], t.position, d),
			a +=
				nr.repeat(" ", e.indent) +
				UC((t.line + 1).toString(), c) +
				" | " +
				u.str +
				`
`,
			a +=
				nr.repeat("-", e.indent + c + 3 + u.pos) +
				`^
`,
			l = 1;
		l <= e.linesAfter && !(s + l >= i.length);
		l++
	)
		(u = KC(
			t.buffer,
			r[s + l],
			i[s + l],
			t.position - (r[s] - r[s + l]),
			d,
		)),
			(a +=
				nr.repeat(" ", e.indent) +
				UC((t.line + l + 1).toString(), c) +
				" | " +
				u.str +
				`
`);
	return a.replace(/\n$/, "");
}
var p9e = h9e,
	m9e = [
		"kind",
		"multi",
		"resolve",
		"construct",
		"instanceOf",
		"predicate",
		"represent",
		"representName",
		"defaultStyle",
		"styleAliases",
	],
	g9e = ["scalar", "sequence", "mapping"];
function b9e(t) {
	var e = {};
	return (
		t !== null &&
			Object.keys(t).forEach(function (n) {
				t[n].forEach(function (r) {
					e[String(r)] = n;
				});
			}),
		e
	);
}
function v9e(t, e) {
	if (
		((e = e || {}),
		Object.keys(e).forEach(function (n) {
			if (m9e.indexOf(n) === -1)
				throw new Pi(
					'Unknown option "' +
						n +
						'" is met in definition of "' +
						t +
						'" YAML type.',
				);
		}),
		(this.options = e),
		(this.tag = t),
		(this.kind = e.kind || null),
		(this.resolve =
			e.resolve ||
			function () {
				return !0;
			}),
		(this.construct =
			e.construct ||
			function (n) {
				return n;
			}),
		(this.instanceOf = e.instanceOf || null),
		(this.predicate = e.predicate || null),
		(this.represent = e.represent || null),
		(this.representName = e.representName || null),
		(this.defaultStyle = e.defaultStyle || null),
		(this.multi = e.multi || !1),
		(this.styleAliases = b9e(e.styleAliases || null)),
		g9e.indexOf(this.kind) === -1)
	)
		throw new Pi(
			'Unknown kind "' +
				this.kind +
				'" is specified for "' +
				t +
				'" YAML type.',
		);
}
var qr = v9e;
function v8(t, e) {
	var n = [];
	return (
		t[e].forEach(function (r) {
			var i = n.length;
			n.forEach(function (o, s) {
				o.tag === r.tag &&
					o.kind === r.kind &&
					o.multi === r.multi &&
					(i = s);
			}),
				(n[i] = r);
		}),
		n
	);
}
function y9e() {
	var t = {
			scalar: {},
			sequence: {},
			mapping: {},
			fallback: {},
			multi: { scalar: [], sequence: [], mapping: [], fallback: [] },
		},
		e,
		n;
	function r(i) {
		i.multi
			? (t.multi[i.kind].push(i), t.multi.fallback.push(i))
			: (t[i.kind][i.tag] = t.fallback[i.tag] = i);
	}
	for (e = 0, n = arguments.length; e < n; e += 1) arguments[e].forEach(r);
	return t;
}
function PE(t) {
	return this.extend(t);
}
PE.prototype.extend = function (e) {
	var n = [],
		r = [];
	if (e instanceof qr) r.push(e);
	else if (Array.isArray(e)) r = r.concat(e);
	else if (e && (Array.isArray(e.implicit) || Array.isArray(e.explicit)))
		e.implicit && (n = n.concat(e.implicit)),
			e.explicit && (r = r.concat(e.explicit));
	else
		throw new Pi(
			"Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })",
		);
	n.forEach(function (o) {
		if (!(o instanceof qr))
			throw new Pi(
				"Specified list of YAML types (or a single Type object) contains a non-Type object.",
			);
		if (o.loadKind && o.loadKind !== "scalar")
			throw new Pi(
				"There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.",
			);
		if (o.multi)
			throw new Pi(
				"There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.",
			);
	}),
		r.forEach(function (o) {
			if (!(o instanceof qr))
				throw new Pi(
					"Specified list of YAML types (or a single Type object) contains a non-Type object.",
				);
		});
	var i = Object.create(PE.prototype);
	return (
		(i.implicit = (this.implicit || []).concat(n)),
		(i.explicit = (this.explicit || []).concat(r)),
		(i.compiledImplicit = v8(i, "implicit")),
		(i.compiledExplicit = v8(i, "explicit")),
		(i.compiledTypeMap = y9e(i.compiledImplicit, i.compiledExplicit)),
		i
	);
};
var x9e = PE,
	k9e = new qr("tag:yaml.org,2002:str", {
		kind: "scalar",
		construct: function (t) {
			return t !== null ? t : "";
		},
	}),
	C9e = new qr("tag:yaml.org,2002:seq", {
		kind: "sequence",
		construct: function (t) {
			return t !== null ? t : [];
		},
	}),
	w9e = new qr("tag:yaml.org,2002:map", {
		kind: "mapping",
		construct: function (t) {
			return t !== null ? t : {};
		},
	}),
	E9e = new x9e({ explicit: [k9e, C9e, w9e] });
function D9e(t) {
	if (t === null) return !0;
	var e = t.length;
	return (
		(e === 1 && t === "~") ||
		(e === 4 && (t === "null" || t === "Null" || t === "NULL"))
	);
}
function S9e() {
	return null;
}
function A9e(t) {
	return t === null;
}
var $9e = new qr("tag:yaml.org,2002:null", {
	kind: "scalar",
	resolve: D9e,
	construct: S9e,
	predicate: A9e,
	represent: {
		canonical: function () {
			return "~";
		},
		lowercase: function () {
			return "null";
		},
		uppercase: function () {
			return "NULL";
		},
		camelcase: function () {
			return "Null";
		},
		empty: function () {
			return "";
		},
	},
	defaultStyle: "lowercase",
});
function T9e(t) {
	if (t === null) return !1;
	var e = t.length;
	return (
		(e === 4 && (t === "true" || t === "True" || t === "TRUE")) ||
		(e === 5 && (t === "false" || t === "False" || t === "FALSE"))
	);
}
function B9e(t) {
	return t === "true" || t === "True" || t === "TRUE";
}
function I9e(t) {
	return Object.prototype.toString.call(t) === "[object Boolean]";
}
var F9e = new qr("tag:yaml.org,2002:bool", {
	kind: "scalar",
	resolve: T9e,
	construct: B9e,
	predicate: I9e,
	represent: {
		lowercase: function (t) {
			return t ? "true" : "false";
		},
		uppercase: function (t) {
			return t ? "TRUE" : "FALSE";
		},
		camelcase: function (t) {
			return t ? "True" : "False";
		},
	},
	defaultStyle: "lowercase",
});
function P9e(t) {
	return (
		(48 <= t && t <= 57) || (65 <= t && t <= 70) || (97 <= t && t <= 102)
	);
}
function N9e(t) {
	return 48 <= t && t <= 55;
}
function R9e(t) {
	return 48 <= t && t <= 57;
}
function O9e(t) {
	if (t === null) return !1;
	var e = t.length,
		n = 0,
		r = !1,
		i;
	if (!e) return !1;
	if (((i = t[n]), (i === "-" || i === "+") && (i = t[++n]), i === "0")) {
		if (n + 1 === e) return !0;
		if (((i = t[++n]), i === "b")) {
			for (n++; n < e; n++)
				if (((i = t[n]), i !== "_")) {
					if (i !== "0" && i !== "1") return !1;
					r = !0;
				}
			return r && i !== "_";
		}
		if (i === "x") {
			for (n++; n < e; n++)
				if (((i = t[n]), i !== "_")) {
					if (!P9e(t.charCodeAt(n))) return !1;
					r = !0;
				}
			return r && i !== "_";
		}
		if (i === "o") {
			for (n++; n < e; n++)
				if (((i = t[n]), i !== "_")) {
					if (!N9e(t.charCodeAt(n))) return !1;
					r = !0;
				}
			return r && i !== "_";
		}
	}
	if (i === "_") return !1;
	for (; n < e; n++)
		if (((i = t[n]), i !== "_")) {
			if (!R9e(t.charCodeAt(n))) return !1;
			r = !0;
		}
	return !(!r || i === "_");
}
function M9e(t) {
	var e = t,
		n = 1,
		r;
	if (
		(e.indexOf("_") !== -1 && (e = e.replace(/_/g, "")),
		(r = e[0]),
		(r === "-" || r === "+") &&
			(r === "-" && (n = -1), (e = e.slice(1)), (r = e[0])),
		e === "0")
	)
		return 0;
	if (r === "0") {
		if (e[1] === "b") return n * parseInt(e.slice(2), 2);
		if (e[1] === "x") return n * parseInt(e.slice(2), 16);
		if (e[1] === "o") return n * parseInt(e.slice(2), 8);
	}
	return n * parseInt(e, 10);
}
function j9e(t) {
	return (
		Object.prototype.toString.call(t) === "[object Number]" &&
		t % 1 === 0 &&
		!nr.isNegativeZero(t)
	);
}
var _9e = new qr("tag:yaml.org,2002:int", {
		kind: "scalar",
		resolve: O9e,
		construct: M9e,
		predicate: j9e,
		represent: {
			binary: function (t) {
				return t >= 0
					? "0b" + t.toString(2)
					: "-0b" + t.toString(2).slice(1);
			},
			octal: function (t) {
				return t >= 0
					? "0o" + t.toString(8)
					: "-0o" + t.toString(8).slice(1);
			},
			decimal: function (t) {
				return t.toString(10);
			},
			hexadecimal: function (t) {
				return t >= 0
					? "0x" + t.toString(16).toUpperCase()
					: "-0x" + t.toString(16).toUpperCase().slice(1);
			},
		},
		defaultStyle: "decimal",
		styleAliases: {
			binary: [2, "bin"],
			octal: [8, "oct"],
			decimal: [10, "dec"],
			hexadecimal: [16, "hex"],
		},
	}),
	z9e = new RegExp(
		"^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$",
	);
function L9e(t) {
	return !(t === null || !z9e.test(t) || t[t.length - 1] === "_");
}
function V9e(t) {
	var e, n;
	return (
		(e = t.replace(/_/g, "").toLowerCase()),
		(n = e[0] === "-" ? -1 : 1),
		"+-".indexOf(e[0]) >= 0 && (e = e.slice(1)),
		e === ".inf"
			? n === 1
				? Number.POSITIVE_INFINITY
				: Number.NEGATIVE_INFINITY
			: e === ".nan"
				? NaN
				: n * parseFloat(e, 10)
	);
}
var K9e = /^[-+]?[0-9]+e/;
function U9e(t, e) {
	var n;
	if (isNaN(t))
		switch (e) {
			case "lowercase":
				return ".nan";
			case "uppercase":
				return ".NAN";
			case "camelcase":
				return ".NaN";
		}
	else if (Number.POSITIVE_INFINITY === t)
		switch (e) {
			case "lowercase":
				return ".inf";
			case "uppercase":
				return ".INF";
			case "camelcase":
				return ".Inf";
		}
	else if (Number.NEGATIVE_INFINITY === t)
		switch (e) {
			case "lowercase":
				return "-.inf";
			case "uppercase":
				return "-.INF";
			case "camelcase":
				return "-.Inf";
		}
	else if (nr.isNegativeZero(t)) return "-0.0";
	return (n = t.toString(10)), K9e.test(n) ? n.replace("e", ".e") : n;
}
function H9e(t) {
	return (
		Object.prototype.toString.call(t) === "[object Number]" &&
		(t % 1 !== 0 || nr.isNegativeZero(t))
	);
}
var W9e = new qr("tag:yaml.org,2002:float", {
		kind: "scalar",
		resolve: L9e,
		construct: V9e,
		predicate: H9e,
		represent: U9e,
		defaultStyle: "lowercase",
	}),
	q9e = E9e.extend({ implicit: [$9e, F9e, _9e, W9e] }),
	G9e = q9e,
	kX = new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"),
	CX = new RegExp(
		"^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$",
	);
function Y9e(t) {
	return t === null ? !1 : kX.exec(t) !== null || CX.exec(t) !== null;
}
function J9e(t) {
	var e,
		n,
		r,
		i,
		o,
		s,
		a,
		l = 0,
		u = null,
		c,
		d,
		f;
	if (((e = kX.exec(t)), e === null && (e = CX.exec(t)), e === null))
		throw new Error("Date resolve error");
	if (((n = +e[1]), (r = +e[2] - 1), (i = +e[3]), !e[4]))
		return new Date(Date.UTC(n, r, i));
	if (((o = +e[4]), (s = +e[5]), (a = +e[6]), e[7])) {
		for (l = e[7].slice(0, 3); l.length < 3; ) l += "0";
		l = +l;
	}
	return (
		e[9] &&
			((c = +e[10]),
			(d = +(e[11] || 0)),
			(u = (c * 60 + d) * 6e4),
			e[9] === "-" && (u = -u)),
		(f = new Date(Date.UTC(n, r, i, o, s, a, l))),
		u && f.setTime(f.getTime() - u),
		f
	);
}
function X9e(t) {
	return t.toISOString();
}
var Z9e = new qr("tag:yaml.org,2002:timestamp", {
	kind: "scalar",
	resolve: Y9e,
	construct: J9e,
	instanceOf: Date,
	represent: X9e,
});
function Q9e(t) {
	return t === "<<" || t === null;
}
var ePe = new qr("tag:yaml.org,2002:merge", { kind: "scalar", resolve: Q9e }),
	EA = `ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=
\r`;
function tPe(t) {
	if (t === null) return !1;
	var e,
		n,
		r = 0,
		i = t.length,
		o = EA;
	for (n = 0; n < i; n++)
		if (((e = o.indexOf(t.charAt(n))), !(e > 64))) {
			if (e < 0) return !1;
			r += 6;
		}
	return r % 8 === 0;
}
function nPe(t) {
	var e,
		n,
		r = t.replace(/[\r\n=]/g, ""),
		i = r.length,
		o = EA,
		s = 0,
		a = [];
	for (e = 0; e < i; e++)
		e % 4 === 0 &&
			e &&
			(a.push((s >> 16) & 255), a.push((s >> 8) & 255), a.push(s & 255)),
			(s = (s << 6) | o.indexOf(r.charAt(e)));
	return (
		(n = (i % 4) * 6),
		n === 0
			? (a.push((s >> 16) & 255), a.push((s >> 8) & 255), a.push(s & 255))
			: n === 18
				? (a.push((s >> 10) & 255), a.push((s >> 2) & 255))
				: n === 12 && a.push((s >> 4) & 255),
		new Uint8Array(a)
	);
}
function rPe(t) {
	var e = "",
		n = 0,
		r,
		i,
		o = t.length,
		s = EA;
	for (r = 0; r < o; r++)
		r % 3 === 0 &&
			r &&
			((e += s[(n >> 18) & 63]),
			(e += s[(n >> 12) & 63]),
			(e += s[(n >> 6) & 63]),
			(e += s[n & 63])),
			(n = (n << 8) + t[r]);
	return (
		(i = o % 3),
		i === 0
			? ((e += s[(n >> 18) & 63]),
				(e += s[(n >> 12) & 63]),
				(e += s[(n >> 6) & 63]),
				(e += s[n & 63]))
			: i === 2
				? ((e += s[(n >> 10) & 63]),
					(e += s[(n >> 4) & 63]),
					(e += s[(n << 2) & 63]),
					(e += s[64]))
				: i === 1 &&
					((e += s[(n >> 2) & 63]),
					(e += s[(n << 4) & 63]),
					(e += s[64]),
					(e += s[64])),
		e
	);
}
function iPe(t) {
	return Object.prototype.toString.call(t) === "[object Uint8Array]";
}
var oPe = new qr("tag:yaml.org,2002:binary", {
		kind: "scalar",
		resolve: tPe,
		construct: nPe,
		predicate: iPe,
		represent: rPe,
	}),
	sPe = Object.prototype.hasOwnProperty,
	aPe = Object.prototype.toString;
function lPe(t) {
	if (t === null) return !0;
	var e = [],
		n,
		r,
		i,
		o,
		s,
		a = t;
	for (n = 0, r = a.length; n < r; n += 1) {
		if (((i = a[n]), (s = !1), aPe.call(i) !== "[object Object]"))
			return !1;
		for (o in i)
			if (sPe.call(i, o))
				if (!s) s = !0;
				else return !1;
		if (!s) return !1;
		if (e.indexOf(o) === -1) e.push(o);
		else return !1;
	}
	return !0;
}
function uPe(t) {
	return t !== null ? t : [];
}
var cPe = new qr("tag:yaml.org,2002:omap", {
		kind: "sequence",
		resolve: lPe,
		construct: uPe,
	}),
	dPe = Object.prototype.toString;
function fPe(t) {
	if (t === null) return !0;
	var e,
		n,
		r,
		i,
		o,
		s = t;
	for (o = new Array(s.length), e = 0, n = s.length; e < n; e += 1) {
		if (
			((r = s[e]),
			dPe.call(r) !== "[object Object]" ||
				((i = Object.keys(r)), i.length !== 1))
		)
			return !1;
		o[e] = [i[0], r[i[0]]];
	}
	return !0;
}
function hPe(t) {
	if (t === null) return [];
	var e,
		n,
		r,
		i,
		o,
		s = t;
	for (o = new Array(s.length), e = 0, n = s.length; e < n; e += 1)
		(r = s[e]), (i = Object.keys(r)), (o[e] = [i[0], r[i[0]]]);
	return o;
}
var pPe = new qr("tag:yaml.org,2002:pairs", {
		kind: "sequence",
		resolve: fPe,
		construct: hPe,
	}),
	mPe = Object.prototype.hasOwnProperty;
function gPe(t) {
	if (t === null) return !0;
	var e,
		n = t;
	for (e in n) if (mPe.call(n, e) && n[e] !== null) return !1;
	return !0;
}
function bPe(t) {
	return t !== null ? t : {};
}
var vPe = new qr("tag:yaml.org,2002:set", {
		kind: "mapping",
		resolve: gPe,
		construct: bPe,
	}),
	wX = G9e.extend({ implicit: [Z9e, ePe], explicit: [oPe, cPe, pPe, vPe] }),
	Qu = Object.prototype.hasOwnProperty,
	Wy = 1,
	EX = 2,
	DX = 3,
	qy = 4,
	HC = 1,
	yPe = 2,
	y8 = 3,
	xPe =
		/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/,
	kPe = /[\x85\u2028\u2029]/,
	CPe = /[,\[\]\{\}]/,
	SX = /^(?:!|!!|![a-z\-]+!)$/i,
	AX =
		/^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
function x8(t) {
	return Object.prototype.toString.call(t);
}
function da(t) {
	return t === 10 || t === 13;
}
function fd(t) {
	return t === 9 || t === 32;
}
function Mi(t) {
	return t === 9 || t === 32 || t === 10 || t === 13;
}
function Xf(t) {
	return t === 44 || t === 91 || t === 93 || t === 123 || t === 125;
}
function wPe(t) {
	var e;
	return 48 <= t && t <= 57
		? t - 48
		: ((e = t | 32), 97 <= e && e <= 102 ? e - 97 + 10 : -1);
}
function EPe(t) {
	return t === 120 ? 2 : t === 117 ? 4 : t === 85 ? 8 : 0;
}
function DPe(t) {
	return 48 <= t && t <= 57 ? t - 48 : -1;
}
function k8(t) {
	return t === 48
		? "\0"
		: t === 97
			? "\x07"
			: t === 98
				? "\b"
				: t === 116 || t === 9
					? "	"
					: t === 110
						? `
`
						: t === 118
							? "\v"
							: t === 102
								? "\f"
								: t === 114
									? "\r"
									: t === 101
										? "\x1B"
										: t === 32
											? " "
											: t === 34
												? '"'
												: t === 47
													? "/"
													: t === 92
														? "\\"
														: t === 78
															? ""
															: t === 95
																? " "
																: t === 76
																	? "\u2028"
																	: t === 80
																		? "\u2029"
																		: "";
}
function SPe(t) {
	return t <= 65535
		? String.fromCharCode(t)
		: String.fromCharCode(
				((t - 65536) >> 10) + 55296,
				((t - 65536) & 1023) + 56320,
			);
}
var $X = new Array(256),
	TX = new Array(256);
for (var Cf = 0; Cf < 256; Cf++) ($X[Cf] = k8(Cf) ? 1 : 0), (TX[Cf] = k8(Cf));
function APe(t, e) {
	(this.input = t),
		(this.filename = e.filename || null),
		(this.schema = e.schema || wX),
		(this.onWarning = e.onWarning || null),
		(this.legacy = e.legacy || !1),
		(this.json = e.json || !1),
		(this.listener = e.listener || null),
		(this.implicitTypes = this.schema.compiledImplicit),
		(this.typeMap = this.schema.compiledTypeMap),
		(this.length = t.length),
		(this.position = 0),
		(this.line = 0),
		(this.lineStart = 0),
		(this.lineIndent = 0),
		(this.firstTabInLine = -1),
		(this.documents = []);
}
function BX(t, e) {
	var n = {
		name: t.filename,
		buffer: t.input.slice(0, -1),
		position: t.position,
		line: t.line,
		column: t.position - t.lineStart,
	};
	return (n.snippet = p9e(n)), new Pi(e, n);
}
function Je(t, e) {
	throw BX(t, e);
}
function Gy(t, e) {
	t.onWarning && t.onWarning.call(null, BX(t, e));
}
var C8 = {
	YAML: function (e, n, r) {
		var i, o, s;
		e.version !== null && Je(e, "duplication of %YAML directive"),
			r.length !== 1 &&
				Je(e, "YAML directive accepts exactly one argument"),
			(i = /^([0-9]+)\.([0-9]+)$/.exec(r[0])),
			i === null && Je(e, "ill-formed argument of the YAML directive"),
			(o = parseInt(i[1], 10)),
			(s = parseInt(i[2], 10)),
			o !== 1 && Je(e, "unacceptable YAML version of the document"),
			(e.version = r[0]),
			(e.checkLineBreaks = s < 2),
			s !== 1 &&
				s !== 2 &&
				Gy(e, "unsupported YAML version of the document");
	},
	TAG: function (e, n, r) {
		var i, o;
		r.length !== 2 && Je(e, "TAG directive accepts exactly two arguments"),
			(i = r[0]),
			(o = r[1]),
			SX.test(i) ||
				Je(
					e,
					"ill-formed tag handle (first argument) of the TAG directive",
				),
			Qu.call(e.tagMap, i) &&
				Je(
					e,
					'there is a previously declared suffix for "' +
						i +
						'" tag handle',
				),
			AX.test(o) ||
				Je(
					e,
					"ill-formed tag prefix (second argument) of the TAG directive",
				);
		try {
			o = decodeURIComponent(o);
		} catch {
			Je(e, "tag prefix is malformed: " + o);
		}
		e.tagMap[i] = o;
	},
};
function Ou(t, e, n, r) {
	var i, o, s, a;
	if (e < n) {
		if (((a = t.input.slice(e, n)), r))
			for (i = 0, o = a.length; i < o; i += 1)
				(s = a.charCodeAt(i)),
					s === 9 ||
						(32 <= s && s <= 1114111) ||
						Je(t, "expected valid JSON character");
		else
			xPe.test(a) &&
				Je(t, "the stream contains non-printable characters");
		t.result += a;
	}
}
function w8(t, e, n, r) {
	var i, o, s, a;
	for (
		nr.isObject(n) ||
			Je(
				t,
				"cannot merge mappings; the provided source object is unacceptable",
			),
			i = Object.keys(n),
			s = 0,
			a = i.length;
		s < a;
		s += 1
	)
		(o = i[s]), Qu.call(e, o) || ((e[o] = n[o]), (r[o] = !0));
}
function Zf(t, e, n, r, i, o, s, a, l) {
	var u, c;
	if (Array.isArray(i))
		for (
			i = Array.prototype.slice.call(i), u = 0, c = i.length;
			u < c;
			u += 1
		)
			Array.isArray(i[u]) &&
				Je(t, "nested arrays are not supported inside keys"),
				typeof i == "object" &&
					x8(i[u]) === "[object Object]" &&
					(i[u] = "[object Object]");
	if (
		(typeof i == "object" &&
			x8(i) === "[object Object]" &&
			(i = "[object Object]"),
		(i = String(i)),
		e === null && (e = {}),
		r === "tag:yaml.org,2002:merge")
	)
		if (Array.isArray(o))
			for (u = 0, c = o.length; u < c; u += 1) w8(t, e, o[u], n);
		else w8(t, e, o, n);
	else
		!t.json &&
			!Qu.call(n, i) &&
			Qu.call(e, i) &&
			((t.line = s || t.line),
			(t.lineStart = a || t.lineStart),
			(t.position = l || t.position),
			Je(t, "duplicated mapping key")),
			i === "__proto__"
				? Object.defineProperty(e, i, {
						configurable: !0,
						enumerable: !0,
						writable: !0,
						value: o,
					})
				: (e[i] = o),
			delete n[i];
	return e;
}
function DA(t) {
	var e;
	(e = t.input.charCodeAt(t.position)),
		e === 10
			? t.position++
			: e === 13
				? (t.position++,
					t.input.charCodeAt(t.position) === 10 && t.position++)
				: Je(t, "a line break is expected"),
		(t.line += 1),
		(t.lineStart = t.position),
		(t.firstTabInLine = -1);
}
function Kn(t, e, n) {
	for (var r = 0, i = t.input.charCodeAt(t.position); i !== 0; ) {
		for (; fd(i); )
			i === 9 &&
				t.firstTabInLine === -1 &&
				(t.firstTabInLine = t.position),
				(i = t.input.charCodeAt(++t.position));
		if (e && i === 35)
			do i = t.input.charCodeAt(++t.position);
			while (i !== 10 && i !== 13 && i !== 0);
		if (da(i))
			for (
				DA(t),
					i = t.input.charCodeAt(t.position),
					r++,
					t.lineIndent = 0;
				i === 32;

			)
				t.lineIndent++, (i = t.input.charCodeAt(++t.position));
		else break;
	}
	return (
		n !== -1 &&
			r !== 0 &&
			t.lineIndent < n &&
			Gy(t, "deficient indentation"),
		r
	);
}
function s4(t) {
	var e = t.position,
		n;
	return (
		(n = t.input.charCodeAt(e)),
		!!(
			(n === 45 || n === 46) &&
			n === t.input.charCodeAt(e + 1) &&
			n === t.input.charCodeAt(e + 2) &&
			((e += 3), (n = t.input.charCodeAt(e)), n === 0 || Mi(n))
		)
	);
}
function SA(t, e) {
	e === 1
		? (t.result += " ")
		: e > 1 &&
			(t.result += nr.repeat(
				`
`,
				e - 1,
			));
}
function $Pe(t, e, n) {
	var r,
		i,
		o,
		s,
		a,
		l,
		u,
		c,
		d = t.kind,
		f = t.result,
		h;
	if (
		((h = t.input.charCodeAt(t.position)),
		Mi(h) ||
			Xf(h) ||
			h === 35 ||
			h === 38 ||
			h === 42 ||
			h === 33 ||
			h === 124 ||
			h === 62 ||
			h === 39 ||
			h === 34 ||
			h === 37 ||
			h === 64 ||
			h === 96 ||
			((h === 63 || h === 45) &&
				((i = t.input.charCodeAt(t.position + 1)),
				Mi(i) || (n && Xf(i)))))
	)
		return !1;
	for (
		t.kind = "scalar", t.result = "", o = s = t.position, a = !1;
		h !== 0;

	) {
		if (h === 58) {
			if (
				((i = t.input.charCodeAt(t.position + 1)),
				Mi(i) || (n && Xf(i)))
			)
				break;
		} else if (h === 35) {
			if (((r = t.input.charCodeAt(t.position - 1)), Mi(r))) break;
		} else {
			if ((t.position === t.lineStart && s4(t)) || (n && Xf(h))) break;
			if (da(h))
				if (
					((l = t.line),
					(u = t.lineStart),
					(c = t.lineIndent),
					Kn(t, !1, -1),
					t.lineIndent >= e)
				) {
					(a = !0), (h = t.input.charCodeAt(t.position));
					continue;
				} else {
					(t.position = s),
						(t.line = l),
						(t.lineStart = u),
						(t.lineIndent = c);
					break;
				}
		}
		a &&
			(Ou(t, o, s, !1),
			SA(t, t.line - l),
			(o = s = t.position),
			(a = !1)),
			fd(h) || (s = t.position + 1),
			(h = t.input.charCodeAt(++t.position));
	}
	return Ou(t, o, s, !1), t.result ? !0 : ((t.kind = d), (t.result = f), !1);
}
function TPe(t, e) {
	var n, r, i;
	if (((n = t.input.charCodeAt(t.position)), n !== 39)) return !1;
	for (
		t.kind = "scalar", t.result = "", t.position++, r = i = t.position;
		(n = t.input.charCodeAt(t.position)) !== 0;

	)
		if (n === 39)
			if (
				(Ou(t, r, t.position, !0),
				(n = t.input.charCodeAt(++t.position)),
				n === 39)
			)
				(r = t.position), t.position++, (i = t.position);
			else return !0;
		else
			da(n)
				? (Ou(t, r, i, !0), SA(t, Kn(t, !1, e)), (r = i = t.position))
				: t.position === t.lineStart && s4(t)
					? Je(
							t,
							"unexpected end of the document within a single quoted scalar",
						)
					: (t.position++, (i = t.position));
	Je(t, "unexpected end of the stream within a single quoted scalar");
}
function BPe(t, e) {
	var n, r, i, o, s, a;
	if (((a = t.input.charCodeAt(t.position)), a !== 34)) return !1;
	for (
		t.kind = "scalar", t.result = "", t.position++, n = r = t.position;
		(a = t.input.charCodeAt(t.position)) !== 0;

	) {
		if (a === 34) return Ou(t, n, t.position, !0), t.position++, !0;
		if (a === 92) {
			if (
				(Ou(t, n, t.position, !0),
				(a = t.input.charCodeAt(++t.position)),
				da(a))
			)
				Kn(t, !1, e);
			else if (a < 256 && $X[a]) (t.result += TX[a]), t.position++;
			else if ((s = EPe(a)) > 0) {
				for (i = s, o = 0; i > 0; i--)
					(a = t.input.charCodeAt(++t.position)),
						(s = wPe(a)) >= 0
							? (o = (o << 4) + s)
							: Je(t, "expected hexadecimal character");
				(t.result += SPe(o)), t.position++;
			} else Je(t, "unknown escape sequence");
			n = r = t.position;
		} else
			da(a)
				? (Ou(t, n, r, !0), SA(t, Kn(t, !1, e)), (n = r = t.position))
				: t.position === t.lineStart && s4(t)
					? Je(
							t,
							"unexpected end of the document within a double quoted scalar",
						)
					: (t.position++, (r = t.position));
	}
	Je(t, "unexpected end of the stream within a double quoted scalar");
}
function IPe(t, e) {
	var n = !0,
		r,
		i,
		o,
		s = t.tag,
		a,
		l = t.anchor,
		u,
		c,
		d,
		f,
		h,
		p = Object.create(null),
		g,
		v,
		b,
		y;
	if (((y = t.input.charCodeAt(t.position)), y === 91))
		(c = 93), (h = !1), (a = []);
	else if (y === 123) (c = 125), (h = !0), (a = {});
	else return !1;
	for (
		t.anchor !== null && (t.anchorMap[t.anchor] = a),
			y = t.input.charCodeAt(++t.position);
		y !== 0;

	) {
		if ((Kn(t, !0, e), (y = t.input.charCodeAt(t.position)), y === c))
			return (
				t.position++,
				(t.tag = s),
				(t.anchor = l),
				(t.kind = h ? "mapping" : "sequence"),
				(t.result = a),
				!0
			);
		n
			? y === 44 && Je(t, "expected the node content, but found ','")
			: Je(t, "missed comma between flow collection entries"),
			(v = g = b = null),
			(d = f = !1),
			y === 63 &&
				((u = t.input.charCodeAt(t.position + 1)),
				Mi(u) && ((d = f = !0), t.position++, Kn(t, !0, e))),
			(r = t.line),
			(i = t.lineStart),
			(o = t.position),
			zh(t, e, Wy, !1, !0),
			(v = t.tag),
			(g = t.result),
			Kn(t, !0, e),
			(y = t.input.charCodeAt(t.position)),
			(f || t.line === r) &&
				y === 58 &&
				((d = !0),
				(y = t.input.charCodeAt(++t.position)),
				Kn(t, !0, e),
				zh(t, e, Wy, !1, !0),
				(b = t.result)),
			h
				? Zf(t, a, p, v, g, b, r, i, o)
				: d
					? a.push(Zf(t, null, p, v, g, b, r, i, o))
					: a.push(g),
			Kn(t, !0, e),
			(y = t.input.charCodeAt(t.position)),
			y === 44
				? ((n = !0), (y = t.input.charCodeAt(++t.position)))
				: (n = !1);
	}
	Je(t, "unexpected end of the stream within a flow collection");
}
function FPe(t, e) {
	var n,
		r,
		i = HC,
		o = !1,
		s = !1,
		a = e,
		l = 0,
		u = !1,
		c,
		d;
	if (((d = t.input.charCodeAt(t.position)), d === 124)) r = !1;
	else if (d === 62) r = !0;
	else return !1;
	for (t.kind = "scalar", t.result = ""; d !== 0; )
		if (((d = t.input.charCodeAt(++t.position)), d === 43 || d === 45))
			HC === i
				? (i = d === 43 ? y8 : yPe)
				: Je(t, "repeat of a chomping mode identifier");
		else if ((c = DPe(d)) >= 0)
			c === 0
				? Je(
						t,
						"bad explicit indentation width of a block scalar; it cannot be less than one",
					)
				: s
					? Je(t, "repeat of an indentation width identifier")
					: ((a = e + c - 1), (s = !0));
		else break;
	if (fd(d)) {
		do d = t.input.charCodeAt(++t.position);
		while (fd(d));
		if (d === 35)
			do d = t.input.charCodeAt(++t.position);
			while (!da(d) && d !== 0);
	}
	for (; d !== 0; ) {
		for (
			DA(t), t.lineIndent = 0, d = t.input.charCodeAt(t.position);
			(!s || t.lineIndent < a) && d === 32;

		)
			t.lineIndent++, (d = t.input.charCodeAt(++t.position));
		if ((!s && t.lineIndent > a && (a = t.lineIndent), da(d))) {
			l++;
			continue;
		}
		if (t.lineIndent < a) {
			i === y8
				? (t.result += nr.repeat(
						`
`,
						o ? 1 + l : l,
					))
				: i === HC &&
					o &&
					(t.result += `
`);
			break;
		}
		for (
			r
				? fd(d)
					? ((u = !0),
						(t.result += nr.repeat(
							`
`,
							o ? 1 + l : l,
						)))
					: u
						? ((u = !1),
							(t.result += nr.repeat(
								`
`,
								l + 1,
							)))
						: l === 0
							? o && (t.result += " ")
							: (t.result += nr.repeat(
									`
`,
									l,
								))
				: (t.result += nr.repeat(
						`
`,
						o ? 1 + l : l,
					)),
				o = !0,
				s = !0,
				l = 0,
				n = t.position;
			!da(d) && d !== 0;

		)
			d = t.input.charCodeAt(++t.position);
		Ou(t, n, t.position, !1);
	}
	return !0;
}
function E8(t, e) {
	var n,
		r = t.tag,
		i = t.anchor,
		o = [],
		s,
		a = !1,
		l;
	if (t.firstTabInLine !== -1) return !1;
	for (
		t.anchor !== null && (t.anchorMap[t.anchor] = o),
			l = t.input.charCodeAt(t.position);
		l !== 0 &&
		(t.firstTabInLine !== -1 &&
			((t.position = t.firstTabInLine),
			Je(t, "tab characters must not be used in indentation")),
		!(l !== 45 || ((s = t.input.charCodeAt(t.position + 1)), !Mi(s))));

	) {
		if (((a = !0), t.position++, Kn(t, !0, -1) && t.lineIndent <= e)) {
			o.push(null), (l = t.input.charCodeAt(t.position));
			continue;
		}
		if (
			((n = t.line),
			zh(t, e, DX, !1, !0),
			o.push(t.result),
			Kn(t, !0, -1),
			(l = t.input.charCodeAt(t.position)),
			(t.line === n || t.lineIndent > e) && l !== 0)
		)
			Je(t, "bad indentation of a sequence entry");
		else if (t.lineIndent < e) break;
	}
	return a
		? ((t.tag = r),
			(t.anchor = i),
			(t.kind = "sequence"),
			(t.result = o),
			!0)
		: !1;
}
function PPe(t, e, n) {
	var r,
		i,
		o,
		s,
		a,
		l,
		u = t.tag,
		c = t.anchor,
		d = {},
		f = Object.create(null),
		h = null,
		p = null,
		g = null,
		v = !1,
		b = !1,
		y;
	if (t.firstTabInLine !== -1) return !1;
	for (
		t.anchor !== null && (t.anchorMap[t.anchor] = d),
			y = t.input.charCodeAt(t.position);
		y !== 0;

	) {
		if (
			(!v &&
				t.firstTabInLine !== -1 &&
				((t.position = t.firstTabInLine),
				Je(t, "tab characters must not be used in indentation")),
			(r = t.input.charCodeAt(t.position + 1)),
			(o = t.line),
			(y === 63 || y === 58) && Mi(r))
		)
			y === 63
				? (v && (Zf(t, d, f, h, p, null, s, a, l), (h = p = g = null)),
					(b = !0),
					(v = !0),
					(i = !0))
				: v
					? ((v = !1), (i = !0))
					: Je(
							t,
							"incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line",
						),
				(t.position += 1),
				(y = r);
		else {
			if (
				((s = t.line),
				(a = t.lineStart),
				(l = t.position),
				!zh(t, n, EX, !1, !0))
			)
				break;
			if (t.line === o) {
				for (y = t.input.charCodeAt(t.position); fd(y); )
					y = t.input.charCodeAt(++t.position);
				if (y === 58)
					(y = t.input.charCodeAt(++t.position)),
						Mi(y) ||
							Je(
								t,
								"a whitespace character is expected after the key-value separator within a block mapping",
							),
						v &&
							(Zf(t, d, f, h, p, null, s, a, l),
							(h = p = g = null)),
						(b = !0),
						(v = !1),
						(i = !1),
						(h = t.tag),
						(p = t.result);
				else if (b)
					Je(
						t,
						"can not read an implicit mapping pair; a colon is missed",
					);
				else return (t.tag = u), (t.anchor = c), !0;
			} else if (b)
				Je(
					t,
					"can not read a block mapping entry; a multiline key may not be an implicit key",
				);
			else return (t.tag = u), (t.anchor = c), !0;
		}
		if (
			((t.line === o || t.lineIndent > e) &&
				(v && ((s = t.line), (a = t.lineStart), (l = t.position)),
				zh(t, e, qy, !0, i) && (v ? (p = t.result) : (g = t.result)),
				v || (Zf(t, d, f, h, p, g, s, a, l), (h = p = g = null)),
				Kn(t, !0, -1),
				(y = t.input.charCodeAt(t.position))),
			(t.line === o || t.lineIndent > e) && y !== 0)
		)
			Je(t, "bad indentation of a mapping entry");
		else if (t.lineIndent < e) break;
	}
	return (
		v && Zf(t, d, f, h, p, null, s, a, l),
		b &&
			((t.tag = u), (t.anchor = c), (t.kind = "mapping"), (t.result = d)),
		b
	);
}
function NPe(t) {
	var e,
		n = !1,
		r = !1,
		i,
		o,
		s;
	if (((s = t.input.charCodeAt(t.position)), s !== 33)) return !1;
	if (
		(t.tag !== null && Je(t, "duplication of a tag property"),
		(s = t.input.charCodeAt(++t.position)),
		s === 60
			? ((n = !0), (s = t.input.charCodeAt(++t.position)))
			: s === 33
				? ((r = !0), (i = "!!"), (s = t.input.charCodeAt(++t.position)))
				: (i = "!"),
		(e = t.position),
		n)
	) {
		do s = t.input.charCodeAt(++t.position);
		while (s !== 0 && s !== 62);
		t.position < t.length
			? ((o = t.input.slice(e, t.position)),
				(s = t.input.charCodeAt(++t.position)))
			: Je(t, "unexpected end of the stream within a verbatim tag");
	} else {
		for (; s !== 0 && !Mi(s); )
			s === 33 &&
				(r
					? Je(t, "tag suffix cannot contain exclamation marks")
					: ((i = t.input.slice(e - 1, t.position + 1)),
						SX.test(i) ||
							Je(
								t,
								"named tag handle cannot contain such characters",
							),
						(r = !0),
						(e = t.position + 1))),
				(s = t.input.charCodeAt(++t.position));
		(o = t.input.slice(e, t.position)),
			CPe.test(o) &&
				Je(t, "tag suffix cannot contain flow indicator characters");
	}
	o && !AX.test(o) && Je(t, "tag name cannot contain such characters: " + o);
	try {
		o = decodeURIComponent(o);
	} catch {
		Je(t, "tag name is malformed: " + o);
	}
	return (
		n
			? (t.tag = o)
			: Qu.call(t.tagMap, i)
				? (t.tag = t.tagMap[i] + o)
				: i === "!"
					? (t.tag = "!" + o)
					: i === "!!"
						? (t.tag = "tag:yaml.org,2002:" + o)
						: Je(t, 'undeclared tag handle "' + i + '"'),
		!0
	);
}
function RPe(t) {
	var e, n;
	if (((n = t.input.charCodeAt(t.position)), n !== 38)) return !1;
	for (
		t.anchor !== null && Je(t, "duplication of an anchor property"),
			n = t.input.charCodeAt(++t.position),
			e = t.position;
		n !== 0 && !Mi(n) && !Xf(n);

	)
		n = t.input.charCodeAt(++t.position);
	return (
		t.position === e &&
			Je(t, "name of an anchor node must contain at least one character"),
		(t.anchor = t.input.slice(e, t.position)),
		!0
	);
}
function OPe(t) {
	var e, n, r;
	if (((r = t.input.charCodeAt(t.position)), r !== 42)) return !1;
	for (
		r = t.input.charCodeAt(++t.position), e = t.position;
		r !== 0 && !Mi(r) && !Xf(r);

	)
		r = t.input.charCodeAt(++t.position);
	return (
		t.position === e &&
			Je(t, "name of an alias node must contain at least one character"),
		(n = t.input.slice(e, t.position)),
		Qu.call(t.anchorMap, n) || Je(t, 'unidentified alias "' + n + '"'),
		(t.result = t.anchorMap[n]),
		Kn(t, !0, -1),
		!0
	);
}
function zh(t, e, n, r, i) {
	var o,
		s,
		a,
		l = 1,
		u = !1,
		c = !1,
		d,
		f,
		h,
		p,
		g,
		v;
	if (
		(t.listener !== null && t.listener("open", t),
		(t.tag = null),
		(t.anchor = null),
		(t.kind = null),
		(t.result = null),
		(o = s = a = qy === n || DX === n),
		r &&
			Kn(t, !0, -1) &&
			((u = !0),
			t.lineIndent > e
				? (l = 1)
				: t.lineIndent === e
					? (l = 0)
					: t.lineIndent < e && (l = -1)),
		l === 1)
	)
		for (; NPe(t) || RPe(t); )
			Kn(t, !0, -1)
				? ((u = !0),
					(a = o),
					t.lineIndent > e
						? (l = 1)
						: t.lineIndent === e
							? (l = 0)
							: t.lineIndent < e && (l = -1))
				: (a = !1);
	if (
		(a && (a = u || i),
		(l === 1 || qy === n) &&
			(Wy === n || EX === n ? (g = e) : (g = e + 1),
			(v = t.position - t.lineStart),
			l === 1
				? (a && (E8(t, v) || PPe(t, v, g))) || IPe(t, g)
					? (c = !0)
					: ((s && FPe(t, g)) || TPe(t, g) || BPe(t, g)
							? (c = !0)
							: OPe(t)
								? ((c = !0),
									(t.tag !== null || t.anchor !== null) &&
										Je(
											t,
											"alias node should not have any properties",
										))
								: $Pe(t, g, Wy === n) &&
									((c = !0), t.tag === null && (t.tag = "?")),
						t.anchor !== null && (t.anchorMap[t.anchor] = t.result))
				: l === 0 && (c = a && E8(t, v))),
		t.tag === null)
	)
		t.anchor !== null && (t.anchorMap[t.anchor] = t.result);
	else if (t.tag === "?") {
		for (
			t.result !== null &&
				t.kind !== "scalar" &&
				Je(
					t,
					'unacceptable node kind for !<?> tag; it should be "scalar", not "' +
						t.kind +
						'"',
				),
				d = 0,
				f = t.implicitTypes.length;
			d < f;
			d += 1
		)
			if (((p = t.implicitTypes[d]), p.resolve(t.result))) {
				(t.result = p.construct(t.result)),
					(t.tag = p.tag),
					t.anchor !== null && (t.anchorMap[t.anchor] = t.result);
				break;
			}
	} else if (t.tag !== "!") {
		if (Qu.call(t.typeMap[t.kind || "fallback"], t.tag))
			p = t.typeMap[t.kind || "fallback"][t.tag];
		else
			for (
				p = null,
					h = t.typeMap.multi[t.kind || "fallback"],
					d = 0,
					f = h.length;
				d < f;
				d += 1
			)
				if (t.tag.slice(0, h[d].tag.length) === h[d].tag) {
					p = h[d];
					break;
				}
		p || Je(t, "unknown tag !<" + t.tag + ">"),
			t.result !== null &&
				p.kind !== t.kind &&
				Je(
					t,
					"unacceptable node kind for !<" +
						t.tag +
						'> tag; it should be "' +
						p.kind +
						'", not "' +
						t.kind +
						'"',
				),
			p.resolve(t.result, t.tag)
				? ((t.result = p.construct(t.result, t.tag)),
					t.anchor !== null && (t.anchorMap[t.anchor] = t.result))
				: Je(
						t,
						"cannot resolve a node with !<" +
							t.tag +
							"> explicit tag",
					);
	}
	return (
		t.listener !== null && t.listener("close", t),
		t.tag !== null || t.anchor !== null || c
	);
}
function MPe(t) {
	var e = t.position,
		n,
		r,
		i,
		o = !1,
		s;
	for (
		t.version = null,
			t.checkLineBreaks = t.legacy,
			t.tagMap = Object.create(null),
			t.anchorMap = Object.create(null);
		(s = t.input.charCodeAt(t.position)) !== 0 &&
		(Kn(t, !0, -1),
		(s = t.input.charCodeAt(t.position)),
		!(t.lineIndent > 0 || s !== 37));

	) {
		for (
			o = !0, s = t.input.charCodeAt(++t.position), n = t.position;
			s !== 0 && !Mi(s);

		)
			s = t.input.charCodeAt(++t.position);
		for (
			r = t.input.slice(n, t.position),
				i = [],
				r.length < 1 &&
					Je(
						t,
						"directive name must not be less than one character in length",
					);
			s !== 0;

		) {
			for (; fd(s); ) s = t.input.charCodeAt(++t.position);
			if (s === 35) {
				do s = t.input.charCodeAt(++t.position);
				while (s !== 0 && !da(s));
				break;
			}
			if (da(s)) break;
			for (n = t.position; s !== 0 && !Mi(s); )
				s = t.input.charCodeAt(++t.position);
			i.push(t.input.slice(n, t.position));
		}
		s !== 0 && DA(t),
			Qu.call(C8, r)
				? C8[r](t, r, i)
				: Gy(t, 'unknown document directive "' + r + '"');
	}
	if (
		(Kn(t, !0, -1),
		t.lineIndent === 0 &&
		t.input.charCodeAt(t.position) === 45 &&
		t.input.charCodeAt(t.position + 1) === 45 &&
		t.input.charCodeAt(t.position + 2) === 45
			? ((t.position += 3), Kn(t, !0, -1))
			: o && Je(t, "directives end mark is expected"),
		zh(t, t.lineIndent - 1, qy, !1, !0),
		Kn(t, !0, -1),
		t.checkLineBreaks &&
			kPe.test(t.input.slice(e, t.position)) &&
			Gy(t, "non-ASCII line breaks are interpreted as content"),
		t.documents.push(t.result),
		t.position === t.lineStart && s4(t))
	) {
		t.input.charCodeAt(t.position) === 46 &&
			((t.position += 3), Kn(t, !0, -1));
		return;
	}
	if (t.position < t.length - 1)
		Je(t, "end of the stream or a document separator is expected");
	else return;
}
function IX(t, e) {
	(t = String(t)),
		(e = e || {}),
		t.length !== 0 &&
			(t.charCodeAt(t.length - 1) !== 10 &&
				t.charCodeAt(t.length - 1) !== 13 &&
				(t += `
`),
			t.charCodeAt(0) === 65279 && (t = t.slice(1)));
	var n = new APe(t, e),
		r = t.indexOf("\0");
	for (
		r !== -1 &&
			((n.position = r), Je(n, "null byte is not allowed in input")),
			n.input += "\0";
		n.input.charCodeAt(n.position) === 32;

	)
		(n.lineIndent += 1), (n.position += 1);
	for (; n.position < n.length - 1; ) MPe(n);
	return n.documents;
}
function jPe(t, e, n) {
	e !== null &&
		typeof e == "object" &&
		typeof n > "u" &&
		((n = e), (e = null));
	var r = IX(t, n);
	if (typeof e != "function") return r;
	for (var i = 0, o = r.length; i < o; i += 1) e(r[i]);
}
function _Pe(t, e) {
	var n = IX(t, e);
	if (n.length !== 0) {
		if (n.length === 1) return n[0];
		throw new Pi(
			"expected a single document in the stream, but found more",
		);
	}
}
var zPe = jPe,
	LPe = _Pe,
	VPe = { loadAll: zPe, load: LPe },
	FX = Object.prototype.toString,
	PX = Object.prototype.hasOwnProperty,
	AA = 65279,
	KPe = 9,
	zg = 10,
	UPe = 13,
	HPe = 32,
	WPe = 33,
	qPe = 34,
	NE = 35,
	GPe = 37,
	YPe = 38,
	JPe = 39,
	XPe = 42,
	NX = 44,
	ZPe = 45,
	Yy = 58,
	QPe = 61,
	eNe = 62,
	tNe = 63,
	nNe = 64,
	RX = 91,
	OX = 93,
	rNe = 96,
	MX = 123,
	iNe = 124,
	jX = 125,
	Zr = {};
Zr[0] = "\\0";
Zr[7] = "\\a";
Zr[8] = "\\b";
Zr[9] = "\\t";
Zr[10] = "\\n";
Zr[11] = "\\v";
Zr[12] = "\\f";
Zr[13] = "\\r";
Zr[27] = "\\e";
Zr[34] = '\\"';
Zr[92] = "\\\\";
Zr[133] = "\\N";
Zr[160] = "\\_";
Zr[8232] = "\\L";
Zr[8233] = "\\P";
var oNe = [
		"y",
		"Y",
		"yes",
		"Yes",
		"YES",
		"on",
		"On",
		"ON",
		"n",
		"N",
		"no",
		"No",
		"NO",
		"off",
		"Off",
		"OFF",
	],
	sNe = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
function aNe(t, e) {
	var n, r, i, o, s, a, l;
	if (e === null) return {};
	for (n = {}, r = Object.keys(e), i = 0, o = r.length; i < o; i += 1)
		(s = r[i]),
			(a = String(e[s])),
			s.slice(0, 2) === "!!" && (s = "tag:yaml.org,2002:" + s.slice(2)),
			(l = t.compiledTypeMap.fallback[s]),
			l && PX.call(l.styleAliases, a) && (a = l.styleAliases[a]),
			(n[s] = a);
	return n;
}
function lNe(t) {
	var e, n, r;
	if (((e = t.toString(16).toUpperCase()), t <= 255)) (n = "x"), (r = 2);
	else if (t <= 65535) (n = "u"), (r = 4);
	else if (t <= 4294967295) (n = "U"), (r = 8);
	else
		throw new Pi(
			"code point within a string may not be greater than 0xFFFFFFFF",
		);
	return "\\" + n + nr.repeat("0", r - e.length) + e;
}
var uNe = 1,
	Lg = 2;
function cNe(t) {
	(this.schema = t.schema || wX),
		(this.indent = Math.max(1, t.indent || 2)),
		(this.noArrayIndent = t.noArrayIndent || !1),
		(this.skipInvalid = t.skipInvalid || !1),
		(this.flowLevel = nr.isNothing(t.flowLevel) ? -1 : t.flowLevel),
		(this.styleMap = aNe(this.schema, t.styles || null)),
		(this.sortKeys = t.sortKeys || !1),
		(this.lineWidth = t.lineWidth || 80),
		(this.noRefs = t.noRefs || !1),
		(this.noCompatMode = t.noCompatMode || !1),
		(this.condenseFlow = t.condenseFlow || !1),
		(this.quotingType = t.quotingType === '"' ? Lg : uNe),
		(this.forceQuotes = t.forceQuotes || !1),
		(this.replacer = typeof t.replacer == "function" ? t.replacer : null),
		(this.implicitTypes = this.schema.compiledImplicit),
		(this.explicitTypes = this.schema.compiledExplicit),
		(this.tag = null),
		(this.result = ""),
		(this.duplicates = []),
		(this.usedDuplicates = null);
}
function D8(t, e) {
	for (
		var n = nr.repeat(" ", e), r = 0, i = -1, o = "", s, a = t.length;
		r < a;

	)
		(i = t.indexOf(
			`
`,
			r,
		)),
			i === -1
				? ((s = t.slice(r)), (r = a))
				: ((s = t.slice(r, i + 1)), (r = i + 1)),
			s.length &&
				s !==
					`
` &&
				(o += n),
			(o += s);
	return o;
}
function RE(t, e) {
	return (
		`
` + nr.repeat(" ", t.indent * e)
	);
}
function dNe(t, e) {
	var n, r, i;
	for (n = 0, r = t.implicitTypes.length; n < r; n += 1)
		if (((i = t.implicitTypes[n]), i.resolve(e))) return !0;
	return !1;
}
function Jy(t) {
	return t === HPe || t === KPe;
}
function Vg(t) {
	return (
		(32 <= t && t <= 126) ||
		(161 <= t && t <= 55295 && t !== 8232 && t !== 8233) ||
		(57344 <= t && t <= 65533 && t !== AA) ||
		(65536 <= t && t <= 1114111)
	);
}
function S8(t) {
	return Vg(t) && t !== AA && t !== UPe && t !== zg;
}
function A8(t, e, n) {
	var r = S8(t),
		i = r && !Jy(t);
	return (
		((n
			? r
			: r && t !== NX && t !== RX && t !== OX && t !== MX && t !== jX) &&
			t !== NE &&
			!(e === Yy && !i)) ||
		(S8(e) && !Jy(e) && t === NE) ||
		(e === Yy && i)
	);
}
function fNe(t) {
	return (
		Vg(t) &&
		t !== AA &&
		!Jy(t) &&
		t !== ZPe &&
		t !== tNe &&
		t !== Yy &&
		t !== NX &&
		t !== RX &&
		t !== OX &&
		t !== MX &&
		t !== jX &&
		t !== NE &&
		t !== YPe &&
		t !== XPe &&
		t !== WPe &&
		t !== iNe &&
		t !== QPe &&
		t !== eNe &&
		t !== JPe &&
		t !== qPe &&
		t !== GPe &&
		t !== nNe &&
		t !== rNe
	);
}
function hNe(t) {
	return !Jy(t) && t !== Yy;
}
function hm(t, e) {
	var n = t.charCodeAt(e),
		r;
	return n >= 55296 &&
		n <= 56319 &&
		e + 1 < t.length &&
		((r = t.charCodeAt(e + 1)), r >= 56320 && r <= 57343)
		? (n - 55296) * 1024 + r - 56320 + 65536
		: n;
}
function _X(t) {
	var e = /^\n* /;
	return e.test(t);
}
var zX = 1,
	OE = 2,
	LX = 3,
	VX = 4,
	Nf = 5;
function pNe(t, e, n, r, i, o, s, a) {
	var l,
		u = 0,
		c = null,
		d = !1,
		f = !1,
		h = r !== -1,
		p = -1,
		g = fNe(hm(t, 0)) && hNe(hm(t, t.length - 1));
	if (e || s)
		for (l = 0; l < t.length; u >= 65536 ? (l += 2) : l++) {
			if (((u = hm(t, l)), !Vg(u))) return Nf;
			(g = g && A8(u, c, a)), (c = u);
		}
	else {
		for (l = 0; l < t.length; u >= 65536 ? (l += 2) : l++) {
			if (((u = hm(t, l)), u === zg))
				(d = !0),
					h &&
						((f = f || (l - p - 1 > r && t[p + 1] !== " ")),
						(p = l));
			else if (!Vg(u)) return Nf;
			(g = g && A8(u, c, a)), (c = u);
		}
		f = f || (h && l - p - 1 > r && t[p + 1] !== " ");
	}
	return !d && !f
		? g && !s && !i(t)
			? zX
			: o === Lg
				? Nf
				: OE
		: n > 9 && _X(t)
			? Nf
			: s
				? o === Lg
					? Nf
					: OE
				: f
					? VX
					: LX;
}
function mNe(t, e, n, r, i) {
	t.dump = (function () {
		if (e.length === 0) return t.quotingType === Lg ? '""' : "''";
		if (!t.noCompatMode && (oNe.indexOf(e) !== -1 || sNe.test(e)))
			return t.quotingType === Lg ? '"' + e + '"' : "'" + e + "'";
		var o = t.indent * Math.max(1, n),
			s =
				t.lineWidth === -1
					? -1
					: Math.max(Math.min(t.lineWidth, 40), t.lineWidth - o),
			a = r || (t.flowLevel > -1 && n >= t.flowLevel);
		function l(u) {
			return dNe(t, u);
		}
		switch (
			pNe(e, a, t.indent, s, l, t.quotingType, t.forceQuotes && !r, i)
		) {
			case zX:
				return e;
			case OE:
				return "'" + e.replace(/'/g, "''") + "'";
			case LX:
				return "|" + $8(e, t.indent) + T8(D8(e, o));
			case VX:
				return ">" + $8(e, t.indent) + T8(D8(gNe(e, s), o));
			case Nf:
				return '"' + bNe(e) + '"';
			default:
				throw new Pi("impossible error: invalid scalar style");
		}
	})();
}
function $8(t, e) {
	var n = _X(t) ? String(e) : "",
		r =
			t[t.length - 1] ===
			`
`,
		i =
			r &&
			(t[t.length - 2] ===
				`
` ||
				t ===
					`
`),
		o = i ? "+" : r ? "" : "-";
	return (
		n +
		o +
		`
`
	);
}
function T8(t) {
	return t[t.length - 1] ===
		`
`
		? t.slice(0, -1)
		: t;
}
function gNe(t, e) {
	for (
		var n = /(\n+)([^\n]*)/g,
			r = (function () {
				var u = t.indexOf(`
`);
				return (
					(u = u !== -1 ? u : t.length),
					(n.lastIndex = u),
					B8(t.slice(0, u), e)
				);
			})(),
			i =
				t[0] ===
					`
` || t[0] === " ",
			o,
			s;
		(s = n.exec(t));

	) {
		var a = s[1],
			l = s[2];
		(o = l[0] === " "),
			(r +=
				a +
				(!i && !o && l !== ""
					? `
`
					: "") +
				B8(l, e)),
			(i = o);
	}
	return r;
}
function B8(t, e) {
	if (t === "" || t[0] === " ") return t;
	for (var n = / [^ ]/g, r, i = 0, o, s = 0, a = 0, l = ""; (r = n.exec(t)); )
		(a = r.index),
			a - i > e &&
				((o = s > i ? s : a),
				(l +=
					`
` + t.slice(i, o)),
				(i = o + 1)),
			(s = a);
	return (
		(l += `
`),
		t.length - i > e && s > i
			? (l +=
					t.slice(i, s) +
					`
` +
					t.slice(s + 1))
			: (l += t.slice(i)),
		l.slice(1)
	);
}
function bNe(t) {
	for (var e = "", n = 0, r, i = 0; i < t.length; n >= 65536 ? (i += 2) : i++)
		(n = hm(t, i)),
			(r = Zr[n]),
			!r && Vg(n)
				? ((e += t[i]), n >= 65536 && (e += t[i + 1]))
				: (e += r || lNe(n));
	return e;
}
function vNe(t, e, n) {
	var r = "",
		i = t.tag,
		o,
		s,
		a;
	for (o = 0, s = n.length; o < s; o += 1)
		(a = n[o]),
			t.replacer && (a = t.replacer.call(n, String(o), a)),
			(El(t, e, a, !1, !1) ||
				(typeof a > "u" && El(t, e, null, !1, !1))) &&
				(r !== "" && (r += "," + (t.condenseFlow ? "" : " ")),
				(r += t.dump));
	(t.tag = i), (t.dump = "[" + r + "]");
}
function I8(t, e, n, r) {
	var i = "",
		o = t.tag,
		s,
		a,
		l;
	for (s = 0, a = n.length; s < a; s += 1)
		(l = n[s]),
			t.replacer && (l = t.replacer.call(n, String(s), l)),
			(El(t, e + 1, l, !0, !0, !1, !0) ||
				(typeof l > "u" && El(t, e + 1, null, !0, !0, !1, !0))) &&
				((!r || i !== "") && (i += RE(t, e)),
				t.dump && zg === t.dump.charCodeAt(0)
					? (i += "-")
					: (i += "- "),
				(i += t.dump));
	(t.tag = o), (t.dump = i || "[]");
}
function yNe(t, e, n) {
	var r = "",
		i = t.tag,
		o = Object.keys(n),
		s,
		a,
		l,
		u,
		c;
	for (s = 0, a = o.length; s < a; s += 1)
		(c = ""),
			r !== "" && (c += ", "),
			t.condenseFlow && (c += '"'),
			(l = o[s]),
			(u = n[l]),
			t.replacer && (u = t.replacer.call(n, l, u)),
			El(t, e, l, !1, !1) &&
				(t.dump.length > 1024 && (c += "? "),
				(c +=
					t.dump +
					(t.condenseFlow ? '"' : "") +
					":" +
					(t.condenseFlow ? "" : " ")),
				El(t, e, u, !1, !1) && ((c += t.dump), (r += c)));
	(t.tag = i), (t.dump = "{" + r + "}");
}
function xNe(t, e, n, r) {
	var i = "",
		o = t.tag,
		s = Object.keys(n),
		a,
		l,
		u,
		c,
		d,
		f;
	if (t.sortKeys === !0) s.sort();
	else if (typeof t.sortKeys == "function") s.sort(t.sortKeys);
	else if (t.sortKeys)
		throw new Pi("sortKeys must be a boolean or a function");
	for (a = 0, l = s.length; a < l; a += 1)
		(f = ""),
			(!r || i !== "") && (f += RE(t, e)),
			(u = s[a]),
			(c = n[u]),
			t.replacer && (c = t.replacer.call(n, u, c)),
			El(t, e + 1, u, !0, !0, !0) &&
				((d =
					(t.tag !== null && t.tag !== "?") ||
					(t.dump && t.dump.length > 1024)),
				d &&
					(t.dump && zg === t.dump.charCodeAt(0)
						? (f += "?")
						: (f += "? ")),
				(f += t.dump),
				d && (f += RE(t, e)),
				El(t, e + 1, c, !0, d) &&
					(t.dump && zg === t.dump.charCodeAt(0)
						? (f += ":")
						: (f += ": "),
					(f += t.dump),
					(i += f)));
	(t.tag = o), (t.dump = i || "{}");
}
function F8(t, e, n) {
	var r, i, o, s, a, l;
	for (
		i = n ? t.explicitTypes : t.implicitTypes, o = 0, s = i.length;
		o < s;
		o += 1
	)
		if (
			((a = i[o]),
			(a.instanceOf || a.predicate) &&
				(!a.instanceOf ||
					(typeof e == "object" && e instanceof a.instanceOf)) &&
				(!a.predicate || a.predicate(e)))
		) {
			if (
				(n
					? a.multi && a.representName
						? (t.tag = a.representName(e))
						: (t.tag = a.tag)
					: (t.tag = "?"),
				a.represent)
			) {
				if (
					((l = t.styleMap[a.tag] || a.defaultStyle),
					FX.call(a.represent) === "[object Function]")
				)
					r = a.represent(e, l);
				else if (PX.call(a.represent, l)) r = a.represent[l](e, l);
				else
					throw new Pi(
						"!<" +
							a.tag +
							'> tag resolver accepts not "' +
							l +
							'" style',
					);
				t.dump = r;
			}
			return !0;
		}
	return !1;
}
function El(t, e, n, r, i, o, s) {
	(t.tag = null), (t.dump = n), F8(t, n, !1) || F8(t, n, !0);
	var a = FX.call(t.dump),
		l = r,
		u;
	r && (r = t.flowLevel < 0 || t.flowLevel > e);
	var c = a === "[object Object]" || a === "[object Array]",
		d,
		f;
	if (
		(c && ((d = t.duplicates.indexOf(n)), (f = d !== -1)),
		((t.tag !== null && t.tag !== "?") || f || (t.indent !== 2 && e > 0)) &&
			(i = !1),
		f && t.usedDuplicates[d])
	)
		t.dump = "*ref_" + d;
	else {
		if (
			(c && f && !t.usedDuplicates[d] && (t.usedDuplicates[d] = !0),
			a === "[object Object]")
		)
			r && Object.keys(t.dump).length !== 0
				? (xNe(t, e, t.dump, i), f && (t.dump = "&ref_" + d + t.dump))
				: (yNe(t, e, t.dump),
					f && (t.dump = "&ref_" + d + " " + t.dump));
		else if (a === "[object Array]")
			r && t.dump.length !== 0
				? (t.noArrayIndent && !s && e > 0
						? I8(t, e - 1, t.dump, i)
						: I8(t, e, t.dump, i),
					f && (t.dump = "&ref_" + d + t.dump))
				: (vNe(t, e, t.dump),
					f && (t.dump = "&ref_" + d + " " + t.dump));
		else if (a === "[object String]")
			t.tag !== "?" && mNe(t, t.dump, e, o, l);
		else {
			if (a === "[object Undefined]") return !1;
			if (t.skipInvalid) return !1;
			throw new Pi("unacceptable kind of an object to dump " + a);
		}
		t.tag !== null &&
			t.tag !== "?" &&
			((u = encodeURI(t.tag[0] === "!" ? t.tag.slice(1) : t.tag).replace(
				/!/g,
				"%21",
			)),
			t.tag[0] === "!"
				? (u = "!" + u)
				: u.slice(0, 18) === "tag:yaml.org,2002:"
					? (u = "!!" + u.slice(18))
					: (u = "!<" + u + ">"),
			(t.dump = u + " " + t.dump));
	}
	return !0;
}
function kNe(t, e) {
	var n = [],
		r = [],
		i,
		o;
	for (ME(t, n, r), i = 0, o = r.length; i < o; i += 1)
		e.duplicates.push(n[r[i]]);
	e.usedDuplicates = new Array(o);
}
function ME(t, e, n) {
	var r, i, o;
	if (t !== null && typeof t == "object")
		if (((i = e.indexOf(t)), i !== -1)) n.indexOf(i) === -1 && n.push(i);
		else if ((e.push(t), Array.isArray(t)))
			for (i = 0, o = t.length; i < o; i += 1) ME(t[i], e, n);
		else
			for (r = Object.keys(t), i = 0, o = r.length; i < o; i += 1)
				ME(t[r[i]], e, n);
}
function CNe(t, e) {
	e = e || {};
	var n = new cNe(e);
	n.noRefs || kNe(t, n);
	var r = t;
	return (
		n.replacer && (r = n.replacer.call({ "": r }, "", r)),
		El(n, 0, r, !0, !0)
			? n.dump +
				`
`
			: ""
	);
}
var wNe = CNe,
	ENe = { dump: wNe },
	DNe = VPe.load,
	SNe = ENe.dump;
const KX = new TextDecoder(),
	ANe = new TextEncoder();
function $Ne(t) {
	const n = KX.decode(t).match(/^---(?:\r?\n([^]*?))?\r?\n---\r?\n?/);
	if (n) {
		var r;
		const i = ANe.encode(n[0]);
		return {
			frontmatter: (r = n[1]) !== null && r !== void 0 ? r : "",
			content: t.slice(i.byteLength),
		};
	}
	return null;
}
function UX(t, e, n = !1) {
	const r = e.data === "json" ? JSON.parse : DNe;
	if (!e.contentField) {
		const o = KX.decode(t);
		return { loaded: r(o) };
	}
	const i = $Ne(t);
	if (n && !i) throw new Error("Frontmatter not found");
	return {
		loaded: i === null ? {} : r(i.frontmatter),
		extraFakeFile: {
			path: `${e.contentField.path.join("/")}${e.contentField.contentExtension}`,
			contents: i === null ? t : i.content,
		},
	};
}
const $A = m.jsxs(m.Fragment, {
		children: [
			m.jsx("path", {
				d: "M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8",
			}),
			m.jsx("path", { d: "M3 3v5h5M12 7v5l4 2" }),
		],
	}),
	P8 = new Gr("Notice", ["heading"]),
	TNe = { caution: bv, critical: bv, neutral: _V, positive: jV },
	BNe = {
		caution: "alert",
		critical: "alert",
		neutral: "status",
		positive: "status",
	};
function fo(t) {
	const e = ce(42);
	let n, r, i;
	e[0] !== t
		? (({ children: i, tone: n, ...r } = t),
			(e[0] = t),
			(e[1] = n),
			(e[2] = r),
			(e[3] = i))
		: ((n = e[1]), (r = e[2]), (i = e[3]));
	const o = n === void 0 ? "neutral" : n,
		s = E.useRef(null),
		a = ht(r);
	let l;
	e[4] === Symbol.for("react.memo_cache_sentinel")
		? ((l = P8.element("heading")), (e[4] = l))
		: (l = e[4]);
	const u = l,
		c = Lo(),
		d = Lo();
	let f;
	e[5] === Symbol.for("react.memo_cache_sentinel")
		? ((f = P8.selector("heading")), (e[5] = f))
		: (f = e[5]);
	const h = Yp(f, s),
		p = o === "neutral" ? "accent" : o,
		g = TNe[o];
	let v;
	e[6] === Symbol.for("react.memo_cache_sentinel")
		? ((v = X({ display: "grid", gap: B.size.space.large })), (e[6] = v))
		: (v = e[6]);
	const b = v;
	let y;
	const x = h
			? "content"
			: "heading-start / heading-start / content-end / content-end",
		C = h ? "regular" : void 0;
	let k;
	e[7] !== x || e[8] !== d || e[9] !== C
		? ((k = {
				elementType: "div",
				gridArea: x,
				id: d,
				paddingY: C,
				UNSAFE_className: b,
			}),
			(e[7] = x),
			(e[8] = d),
			(e[9] = C),
			(e[10] = k))
		: (k = e[10]);
	let w;
	e[11] !== c
		? ((w = {
				elementType: "div",
				gridArea: "heading",
				id: c,
				UNSAFE_className: u,
				size: "small",
			}),
			(e[11] = c),
			(e[12] = w))
		: (w = e[12]);
	let D;
	e[13] !== p
		? ((D = { color: p, weight: "medium" }), (e[13] = p), (e[14] = D))
		: (D = e[14]);
	let S;
	e[15] !== k || e[16] !== w || e[17] !== D
		? ((S = { content: k, heading: w, text: D }),
			(e[15] = k),
			(e[16] = w),
			(e[17] = D),
			(e[18] = S))
		: (S = e[18]),
		(y = S);
	const $ = y,
		A = BNe[o];
	let T;
	e[19] !== r ? ((T = Ge(r)), (e[19] = r), (e[20] = T)) : (T = e[20]);
	let I;
	e[21] === Symbol.for("react.memo_cache_sentinel")
		? ((I = ["icon heading", "icon content"]), (e[21] = I))
		: (I = e[21]);
	let F;
	e[22] === Symbol.for("react.memo_cache_sentinel")
		? ((F = ["icon.medium", "auto"]), (e[22] = F))
		: (F = e[22]);
	let N;
	e[23] !== g || e[24] !== p
		? ((N = m.jsx(ve, {
				src: g,
				size: "medium",
				color: p,
				gridArea: "icon",
				alignSelf: "start",
			})),
			(e[23] = g),
			(e[24] = p),
			(e[25] = N))
		: (N = e[25]);
	let O;
	e[26] !== i
		? ((O = $n(i)
				? m.jsx(Pr, { children: m.jsx(ue, { children: i }) })
				: i),
			(e[26] = i),
			(e[27] = O))
		: (O = e[27]);
	let _;
	e[28] !== $ || e[29] !== O
		? ((_ = m.jsx(Cn, { slots: $, children: O })),
			(e[28] = $),
			(e[29] = O),
			(e[30] = _))
		: (_ = e[30]);
	let j;
	return (
		e[31] !== c ||
		e[32] !== d ||
		e[33] !== A ||
		e[34] !== s ||
		e[35] !== a.className ||
		e[36] !== a.style ||
		e[37] !== T ||
		e[38] !== p ||
		e[39] !== N ||
		e[40] !== _
			? ((j = m.jsxs(gd, {
					"aria-live": "polite",
					"aria-labelledby": c,
					"aria-describedby": d,
					role: A,
					ref: s,
					tabIndex: 0,
					UNSAFE_className: a.className,
					UNSAFE_style: a.style,
					...T,
					backgroundColor: p,
					border: p,
					borderRadius: "medium",
					minWidth: 0,
					padding: "medium",
					width: "100%",
					alignItems: "center",
					areas: I,
					columnGap: "medium",
					columns: F,
					rows: `${Dre("icon.medium", "auto")} auto`,
					children: [N, _],
				})),
				(e[31] = c),
				(e[32] = d),
				(e[33] = A),
				(e[34] = s),
				(e[35] = a.className),
				(e[36] = a.style),
				(e[37] = T),
				(e[38] = p),
				(e[39] = N),
				(e[40] = _),
				(e[41] = j))
			: (j = e[41]),
		j
	);
}
const INe = m.jsxs(m.Fragment, {
		children: [
			m.jsx("path", { d: "M15 12v6M12 15h6" }),
			m.jsx("rect", { width: 14, height: 14, x: 8, y: 8, rx: 2, ry: 2 }),
			m.jsx("path", {
				d: "M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2",
			}),
		],
	}),
	TA = m.jsxs(m.Fragment, {
		children: [
			m.jsx("rect", { width: 8, height: 4, x: 8, y: 2, rx: 1, ry: 1 }),
			m.jsx("path", {
				d: "M8 4H6a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-2M16 4h2a2 2 0 0 1 2 2v4M21 14H11",
			}),
			m.jsx("path", { d: "m15 10-4 4 4 4" }),
		],
	}),
	BA = m.jsxs(m.Fragment, {
		children: [
			m.jsx("path", {
				d: "M15 2H9a1 1 0 0 0-1 1v2c0 .6.4 1 1 1h6c.6 0 1-.4 1-1V3c0-.6-.4-1-1-1Z",
			}),
			m.jsx("path", {
				d: "M8 4H6a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2M16 4h2a2 2 0 0 1 2 2v2m-9 6h10",
			}),
			m.jsx("path", { d: "m17 10 4 4-4 4" }),
		],
	});
function FNe(t, e) {
	let {
			isCurrent: n,
			isDisabled: r,
			"aria-current": i,
			elementType: o = "a",
			...s
		} = t,
		{ linkProps: a } = Wh({ isDisabled: r || n, elementType: o, ...s }, e),
		l = /^h[1-6]$/.test(o),
		u = {};
	return (
		l || (u = a),
		n &&
			((u["aria-current"] = i || "page"),
			(u.tabIndex = t.autoFocus ? -1 : void 0)),
		{ itemProps: { "aria-disabled": r, ...u } }
	);
}
var HX = {};
HX = { breadcrumbs: "عناصر الواجهة" };
var WX = {};
WX = { breadcrumbs: "Трохи хляб" };
var qX = {};
qX = { breadcrumbs: "Popis cesty" };
var GX = {};
GX = { breadcrumbs: "Brødkrummer" };
var YX = {};
YX = { breadcrumbs: "Breadcrumbs" };
var JX = {};
JX = { breadcrumbs: "Πλοηγήσεις breadcrumb" };
var XX = {};
XX = { breadcrumbs: "Breadcrumbs" };
var ZX = {};
ZX = { breadcrumbs: "Migas de pan" };
var QX = {};
QX = { breadcrumbs: "Lingiread" };
var eZ = {};
eZ = { breadcrumbs: "Navigointilinkit" };
var tZ = {};
tZ = { breadcrumbs: "Chemin de navigation" };
var nZ = {};
nZ = { breadcrumbs: "שבילי ניווט" };
var rZ = {};
rZ = { breadcrumbs: "Navigacijski putovi" };
var iZ = {};
iZ = { breadcrumbs: "Morzsamenü" };
var oZ = {};
oZ = { breadcrumbs: "Breadcrumb" };
var sZ = {};
sZ = { breadcrumbs: "パンくずリスト" };
var aZ = {};
aZ = { breadcrumbs: "탐색 표시" };
var lZ = {};
lZ = { breadcrumbs: "Naršymo kelias" };
var uZ = {};
uZ = { breadcrumbs: "Atpakaļceļi" };
var cZ = {};
cZ = { breadcrumbs: "Navigasjonsstier" };
var dZ = {};
dZ = { breadcrumbs: "Broodkruimels" };
var fZ = {};
fZ = { breadcrumbs: "Struktura nawigacyjna" };
var hZ = {};
hZ = { breadcrumbs: "Caminho detalhado" };
var pZ = {};
pZ = { breadcrumbs: "Categorias" };
var mZ = {};
mZ = { breadcrumbs: "Miez de pâine" };
var gZ = {};
gZ = { breadcrumbs: "Навигация" };
var bZ = {};
bZ = { breadcrumbs: "Navigačné prvky Breadcrumbs" };
var vZ = {};
vZ = { breadcrumbs: "Drobtine" };
var yZ = {};
yZ = { breadcrumbs: "Putanje navigacije" };
var xZ = {};
xZ = { breadcrumbs: "Sökvägar" };
var kZ = {};
kZ = { breadcrumbs: "İçerik haritaları" };
var CZ = {};
CZ = { breadcrumbs: "Навігаційна стежка" };
var wZ = {};
wZ = { breadcrumbs: "导航栏" };
var EZ = {};
EZ = { breadcrumbs: "導覽列" };
var DZ = {};
DZ = {
	"ar-AE": HX,
	"bg-BG": WX,
	"cs-CZ": qX,
	"da-DK": GX,
	"de-DE": YX,
	"el-GR": JX,
	"en-US": XX,
	"es-ES": ZX,
	"et-EE": QX,
	"fi-FI": eZ,
	"fr-FR": tZ,
	"he-IL": nZ,
	"hr-HR": rZ,
	"hu-HU": iZ,
	"it-IT": oZ,
	"ja-JP": sZ,
	"ko-KR": aZ,
	"lt-LT": lZ,
	"lv-LV": uZ,
	"nb-NO": cZ,
	"nl-NL": dZ,
	"pl-PL": fZ,
	"pt-BR": hZ,
	"pt-PT": pZ,
	"ro-RO": mZ,
	"ru-RU": gZ,
	"sk-SK": bZ,
	"sl-SI": vZ,
	"sr-SP": yZ,
	"sv-SE": xZ,
	"tr-TR": kZ,
	"uk-UA": CZ,
	"zh-CN": wZ,
	"zh-TW": EZ,
};
function PNe(t) {
	return t && t.__esModule ? t.default : t;
}
function NNe(t) {
	let { "aria-label": e, ...n } = t,
		r = Le(PNe(DZ), "@react-aria/breadcrumbs");
	return {
		navProps: {
			...Ge(n, { labelable: !0 }),
			"aria-label": e || r.format("breadcrumbs"),
		},
	};
}
const RNe = m.jsx("path", {
		d: "M20 20a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2h-7.9a2 2 0 0 1-1.69-.9L9.6 3.9A2 2 0 0 0 7.93 3H4a2 2 0 0 0-2 2v13a2 2 0 0 0 2 2ZM2 10h20",
	}),
	ONe = m.jsx("path", {
		d: "m6 14 1.5-2.9A2 2 0 0 1 9.24 10H20a2 2 0 0 1 1.94 2.5l-1.54 6a2 2 0 0 1-1.95 1.5H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h3.9a2 2 0 0 1 1.69.9l.81 1.2a2 2 0 0 0 1.67.9H18a2 2 0 0 1 2 2v2",
	}),
	jm = new Gr("Breadcrumbs", ["item", "link", "list", "separator"]);
function N8(t) {
	const e = ce(26),
		{ children: n, isCurrent: r, isDisabled: i, isMenu: o, size: s } = t,
		a = s === void 0 ? "regular" : s,
		{ direction: l } = Vt(),
		u = E.useRef(null),
		c = t.href ? "a" : "span";
	let d;
	e[0] !== t || e[1] !== c
		? ((d = { ...t, elementType: c }), (e[0] = t), (e[1] = c), (e[2] = d))
		: (d = e[2]);
	let { itemProps: f } = FNe(d, u);
	const { hoverProps: h, isHovered: p } = gn(t);
	let g;
	g = l === "rtl" ? FH : PH;
	const v = g;
	if (o) {
		let $;
		e[3] === Symbol.for("react.memo_cache_sentinel")
			? (($ = {}), (e[3] = $))
			: ($ = e[3]),
			(f = $);
	}
	let b;
	e[4] !== f || e[5] !== h
		? ((b = xe(f, h)), (e[4] = f), (e[5] = h), (e[6] = b))
		: (b = e[6]);
	const y = a !== "regular" ? a : void 0,
		x = p ? "hover" : void 0;
	let C;
	e[7] !== y || e[8] !== x
		? ((C = lt({ size: y, interaction: x })),
			(e[7] = y),
			(e[8] = x),
			(e[9] = C))
		: (C = e[9]);
	let k;
	e[10] !== p
		? ((k = Se(
				jm.element("link"),
				X({
					color: B.color.foreground.neutral,
					cursor: "default",
					fontSize: B.typography.text.regular.size,
					fontFamily: B.typography.fontFamily.base,
					fontWeight: B.typography.fontWeight.medium,
					outline: 0,
					MozOsxFontSmoothing: "auto",
					WebkitFontSmoothing: "auto",
					"&[data-size=small]": {
						fontSize: B.typography.text.small.size,
					},
					"&[data-size=medium]": {
						fontSize: B.typography.text.medium.size,
					},
					"&[data-size=large]": {
						fontSize: B.typography.text.large.size,
					},
					"&:not([aria-current=page])": {
						"&:not([aria-disabled=true])": { cursor: "pointer" },
						"&[data-interaction=hover]": {
							color: B.color.foreground.neutralEmphasis,
							textDecoration: "underline",
						},
						"&[data-focus=visible]": {
							color: B.color.foreground.neutralEmphasis,
							textDecoration: "underline",
							textDecorationStyle: "double",
						},
						"&[aria-disabled=true]": {
							color: B.color.alias.foregroundDisabled,
						},
					},
					"&[aria-current=page]": {
						color: B.color.foreground.neutralEmphasis,
						fontWeight: B.typography.fontWeight.semibold,
						overflow: "hidden",
						textOverflow: "ellipsis",
					},
				}),
				{ "is-hovered": p },
			)),
			(e[10] = p),
			(e[11] = k))
		: (k = e[11]);
	let w;
	e[12] !== c ||
	e[13] !== b ||
	e[14] !== C ||
	e[15] !== u ||
	e[16] !== k ||
	e[17] !== n
		? ((w = m.jsx(xn, {
				children: m.jsx(c, {
					...b,
					...C,
					ref: u,
					className: k,
					children: n,
				}),
			})),
			(e[12] = c),
			(e[13] = b),
			(e[14] = C),
			(e[15] = u),
			(e[16] = k),
			(e[17] = n),
			(e[18] = w))
		: (w = e[18]);
	let D;
	e[19] !== r || e[20] !== i || e[21] !== v
		? ((D =
				!r &&
				m.jsx(ve, {
					src: v,
					color: i
						? "color.alias.foregroundDisabled"
						: "neutralSecondary",
					marginX: "small",
					UNSAFE_className: jm.element("separator"),
				})),
			(e[19] = r),
			(e[20] = i),
			(e[21] = v),
			(e[22] = D))
		: (D = e[22]);
	let S;
	return (
		e[23] !== w || e[24] !== D
			? ((S = m.jsxs(E.Fragment, { children: [w, D] })),
				(e[23] = w),
				(e[24] = D),
				(e[25] = S))
			: (S = e[25]),
		S
	);
}
const MNe = 1,
	jNe = 4;
function _Ne(t, e) {
	t = vo(t);
	let {
			children: n,
			showRoot: r,
			size: i = "regular",
			isDisabled: o,
			onAction: s,
			...a
		} = t,
		l = [];
	E.Children.forEach(n, (D) => {
		E.isValidElement(D) && l.push(D);
	});
	let u = Ct(e),
		c = E.useRef(null),
		[d, f] = E.useState(!1),
		[h, p] = ox(l.length),
		{ navProps: g } = NNe(t),
		v = ht(a),
		b = E.useCallback(() => {
			let D = (S) => {
				let $ = c.current;
				if (!$) return S;
				let A = Array.from($.children);
				if (A.length <= 0) return S;
				let T = $.offsetWidth,
					I = l.length > S,
					F = 0,
					N = 0,
					O = jNe;
				if (
					(r && ((F += A.shift().offsetWidth), N++),
					I && ((F += A.shift().offsetWidth), O--),
					r && F >= T && N--,
					A.length > 0)
				) {
					let _ = A.pop();
					(_.style.overflow = "visible"),
						(F += _.offsetWidth),
						F < T && N++,
						(_.style.overflow = "");
				}
				for (let _ of A.reverse()) (F += _.offsetWidth), F < T && N++;
				return Math.max(MNe, Math.min(O, N));
			};
			p(function* () {
				yield l.length;
				let S = D(l.length);
				yield S, S < l.length && S > 1 && (yield D(S));
			});
		}, [l.length, p, r]);
	fa({ ref: u, onResize: b });
	let y = E.useRef(null);
	at(() => {
		n !== y.current && ((y.current = n), b());
	});
	let x = l;
	if (l.length > h) {
		var C;
		let S =
				(C = l[l.length - 1].key) !== null && C !== void 0
					? C
					: l.length - 1,
			$ = (F) => {
				F !== S && s && s(F);
			};
		x = [
			m.jsx(
				N8,
				{
					isMenu: !0,
					children: m.jsxs(Xo, {
						onOpenChange: f,
						children: [
							m.jsx(Re, {
								"aria-label": "…",
								prominence: "low",
								isDisabled: o,
								children: m.jsx(ve, { src: d ? ONe : RNe }),
							}),
							m.jsx(Jo, {
								selectionMode: "single",
								selectedKeys: [S],
								onAction: $,
								children: l,
							}),
						],
					}),
				},
				"menu",
			),
		];
		let T = [...l],
			I = h;
		if (r && h > 1) {
			let F = T.shift();
			F && x.unshift(F), I--;
		}
		x.push(...T.slice(-I));
	}
	let k = x.length - 1,
		w = x.map((D, S) => {
			var $;
			let A = S === k,
				T = ($ = D.key) !== null && $ !== void 0 ? $ : S,
				I = () => {
					s && s(T);
				};
			return m.jsx(
				"li",
				{
					className: Se(
						jm.element("item"),
						X({
							alignItems: "center",
							display: "inline-flex",
							whiteSpace: "nowrap",
							"&:last-child": { overflow: "hidden" },
						}),
					),
					children: E.createElement(
						N8,
						{
							...D.props,
							isCurrent: A,
							isDisabled: o,
							key: T,
							onPress: I,
							size: i,
						},
						D.props.children,
					),
				},
				S,
			);
		});
	return m.jsx("nav", {
		...g,
		...v,
		ref: u,
		className: Se(jm.element("root"), v.className),
		children: m.jsx("ul", {
			ref: c,
			className: Se(
				jm.element("list"),
				X({
					display: "flex",
					height: B.size.element.regular,
					justifyContent: "flex-start",
				}),
			),
			children: w,
		}),
	});
}
const zNe = E.forwardRef(_Ne);
function IA(t) {
	const e = ee(7),
		n = Jn(),
		r = w3().current;
	let i, o;
	e[0] !== r
		? ((o = r.kind === "loaded" ? r.data.tree : new Map()),
			(e[0] = r),
			(e[1] = o))
		: (o = e[1]);
	const s = o;
	let a;
	if (e[2] !== n || e[3] !== t || e[4] !== s) {
		let l;
		e[6] === Symbol.for("react.memo_cache_sentinel")
			? ((l = (u) => u.slug), (e[6] = l))
			: (l = e[6]),
			(a = wg(n, t, s).map(l)),
			(e[2] = n),
			(e[3] = t),
			(e[4] = s),
			(e[5] = a);
	} else a = e[5];
	return (i = a), i;
}
var LNe = `
https://bit.ly/2XbVrpR#`;
function a4(t, e, n) {
	if (!t) {
		var r =
				"Minfied Error #" +
				n +
				`
`,
			i = new Error(r + LNe + n);
		throw ((i.name = "Graphcache Error"), i);
	}
}
var VNe = {},
	l4 = (t) => t._directives || VNe,
	Pa = (t) => t.name.value,
	R8 = (t) => t.typeCondition.name.value,
	FA = (t) => (t.alias ? t.alias.value : t.name.value),
	KNe = [],
	Ho = (t) => (t.selectionSet ? t.selectionSet.selections : KNe),
	SZ = (t) => (t.typeCondition ? t.typeCondition.name.value : null),
	u4 = (t, e) => {
		var n = null;
		if (t.arguments)
			for (var r = 0, i = t.arguments.length; r < i; r++) {
				var o = t.arguments[r],
					s = Fh(o.value, e);
				s != null && (n || (n = {}), (n[Pa(o)] = s));
			}
		return n;
	},
	UNe = (t, e) => {
		if (!(!e || !t.variableDefinitions)) {
			for (
				var n = {}, r = 0, i = t.variableDefinitions.length;
				r < i;
				r++
			) {
				var o = Pa(t.variableDefinitions[r].variable);
				n[o] = e[o];
			}
			return n;
		}
	},
	AZ = (t, e) => {
		var n = {};
		if (!e) return n;
		if (t.variableDefinitions)
			for (var r = 0, i = t.variableDefinitions.length; r < i; r++) {
				var o = t.variableDefinitions[r],
					s = Pa(o.variable);
				n[s] =
					e[s] === void 0 && o.defaultValue
						? Fh(o.defaultValue, e)
						: e[s];
			}
		for (var a in e) a in n || (n[a] = e[a]);
		return n;
	};
function PA(t) {
	for (var e = 0; e < t.definitions.length; e++)
		if (t.definitions[e].kind === ea.OPERATION_DEFINITION)
			return t.definitions[e];
	a4(!1, "", 1);
}
var Xy = (t) => {
		for (var e = {}, n = 0; n < t.definitions.length; n++) {
			var r = t.definitions[n];
			r.kind === ea.FRAGMENT_DEFINITION && (e[Pa(r)] = r);
		}
		return e;
	},
	HNe = (t, e) => {
		var n = l4(t);
		if (n.include || n.skip)
			for (var r in n) {
				var i = n[r];
				if (
					i &&
					(r === "include" || r === "skip") &&
					i.arguments &&
					i.arguments[0] &&
					Pa(i.arguments[0]) === "if"
				) {
					var o = Fh(i.arguments[0].value, e);
					return r === "include" ? !!o : !o;
				}
			}
		return !0;
	},
	WNe = (t, e) => {
		var { defer: n } = l4(t);
		if (n) {
			for (var r of n.arguments || [])
				if (Pa(r) === "if") return !!Fh(r.value, e);
			return !0;
		}
		return !1;
	},
	qNe = (t) => {
		var { optional: e, required: n } = l4(t);
		if (n) return !1;
		if (e) return !0;
	},
	O8 = "__",
	M8 = (t, e, n, r) => {
		var i = TZ(t, e, n);
		return !!i && i.type.kind !== "NON_NULL";
	},
	$Z = (t, e, n, r) => {
		var i = TZ(t, e, n);
		if (!i) return !1;
		var o = i.type.kind === "NON_NULL" ? i.type.ofType : i.type;
		return o.kind === "LIST" && o.ofType.kind !== "NON_NULL";
	},
	GNe = (t, e, n) => {
		if (!n) return !1;
		var r = SZ(e);
		return !r || n === r
			? !0
			: t.types.has(r) && t.types.get(r).kind === "OBJECT"
				? r === n
				: ((function (o, s) {
						a4(
							o.types.has(s) &&
								(o.types.get(s).kind === "INTERFACE" ||
									o.types.get(s).kind === "UNION"),
							"",
							5,
						);
					})(t, r),
					BZ(t, n),
					t.isSubType(r, n));
	},
	TZ = (t, e, n, r) => {
		if (!(n.indexOf(O8) === 0 || e.indexOf(O8) === 0)) {
			BZ(t, e);
			var i = t.types.get(e).fields()[n];
			return i;
		}
	};
function BZ(t, e) {
	a4(t.types.has(e) && t.types.get(e).kind === "OBJECT", "", 3);
}
var hd = (t, e) => (e ? `${t}(${Cl(e)})` : t),
	Q0 = (t, e) => `${t}.${e}`,
	YNe = (t) => {
		var e = t.indexOf("(");
		return e > -1
			? {
					fieldKey: t,
					fieldName: t.slice(0, e),
					arguments: JSON.parse(t.slice(e + 1, -1)),
				}
			: { fieldKey: t, fieldName: t, arguments: null };
	},
	IZ = (t) => {
		var e = t.indexOf(".");
		return {
			entityKey: t.slice(0, e).replace(/%2e/g, "."),
			fieldKey: t.slice(e + 1),
		};
	},
	Kg = null,
	Zy = null,
	it = null,
	di = null,
	ho = null,
	dl = null,
	xp = !1,
	ec = !1;
function wa(t, e) {
	var n;
	if (t) {
		if (Kg.has(t)) return t;
		n = Zy.get(t);
	}
	return n == null && (n = e ? [] : {}), t && Zy.set(t, n), Kg.add(n), n;
}
var WC = (t) => !!t && Kg.has(t),
	$c = (t, e, n, r, i) => {
		(Kg = new WeakSet()),
			(Zy = new WeakMap()),
			(ho = t),
			(it = e),
			(dl = new Set()),
			(ec = !!r),
			(xp = !!i),
			n
				? ho === "read"
					? (di = n)
					: r || e.hydrating || e.optimisticOrder.length > 1
						? (!r && !e.commutativeKeys.has(n)
								? Yb(e, n)
								: r &&
									(e.optimisticOrder.indexOf(n) !== -1 &&
										!e.commutativeKeys.has(n) &&
										e.optimisticOrder.splice(
											e.optimisticOrder.indexOf(n),
											1,
										),
									e.commutativeKeys.delete(n)),
							(di = n),
							QNe(e, n))
						: ((di = null), OZ(e, n))
				: (di = null);
	},
	Tc = () => {
		var t = it,
			e = di;
		if (
			((ec = !1),
			(di = null),
			!t.hydrating && e && t.optimisticOrder.indexOf(e) > -1)
		)
			for (
				var n = t.optimisticOrder.length;
				--n >= 0 &&
				t.dirtyKeys.has(t.optimisticOrder[n]) &&
				t.commutativeKeys.has(t.optimisticOrder[n]);

			)
				eRe(t.optimisticOrder[n]);
		(Kg = null),
			(Zy = null),
			(ho = null),
			(it = null),
			(dl = null),
			!t.defer &&
				(t.storage || !t.optimisticOrder.length) &&
				((t.defer = !0),
				setTimeout(() => {
					$c("read", t, null), JNe(), tRe(), Tc(), (t.defer = !1);
				}));
	},
	j8 = (t, e, n) => {
		e && !n && t.deferredKeys.delete(e), $c("write", t, e, n), Tc();
	},
	FZ = new Set(),
	PZ = (t, e, n, r) => {
		var i = di ? t.optimistic.get(di) : t.base,
			o = i.get(e);
		o === void 0 && i.set(e, (o = Object.create(null))),
			r === void 0 && !di ? delete o[n] : (o[n] = r);
	},
	c4 = (t, e, n) => {
		for (
			var r,
				i = !ec && ho === "read" && di && it.commutativeKeys.has(di),
				o = 0,
				s = it.optimisticOrder.length;
			o < s;
			o++
		) {
			var a = it.optimisticOrder[o],
				l = t.optimistic.get(a);
			if (
				((i = i && a !== di),
				l &&
					(!i || !it.commutativeKeys.has(a)) &&
					(!ec || ho === "write" || it.commutativeKeys.has(a)) &&
					(r = l.get(e)) !== void 0 &&
					n in r)
			)
				return r[n];
		}
		return (r = t.base.get(e)) !== void 0 ? r[n] : void 0;
	};
function Qy(t) {
	return it.refCount.get(t) || 0;
}
var ex = (t, e) => {
		if (Array.isArray(t))
			for (var n = 0, r = t.length; n < r; n++) ex(t[n], e);
		else
			typeof t == "string" &&
				((i, o) => {
					var s = Qy(i),
						a = s + o > 0 ? s + o : 0;
					it.refCount.set(i, a),
						a ? !s && a && it.gc.delete(i) : it.gc.add(i);
				})(t, e);
	},
	_8 = (t, e, n) => {
		if (n !== void 0)
			for (var r in n) e.has(r) || (t.push(YNe(r)), e.add(r));
	},
	z8 = (t, e, n, r) => {
		_8(t, e, r.base.get(n));
		for (var i = 0, o = it.optimisticOrder.length; i < o; i++) {
			var s = r.optimistic.get(it.optimisticOrder[i]);
			s !== void 0 && _8(t, e, s.get(n));
		}
	},
	JNe = () => {
		if (!it.optimisticOrder.length) {
			for (var t of it.gc.keys())
				if ((it.gc.delete(t), !(Qy(t) > 0))) {
					var e = it.records.base.get(t);
					it.refCount.delete(t), it.records.base.delete(t);
					var n = e && e.__typename;
					if (n) {
						var r = it.types.get(n);
						r && r.delete(t);
					}
					var i = it.links.base.get(t);
					if (i) {
						it.links.base.delete(t);
						for (var o in i) ex(i[o], -1);
					}
				}
		}
	},
	e1 = (t, e) => {
		t !== it.queryRootKey
			? dl.add(t)
			: e !== void 0 && e !== "__typename" && dl.add(Q0(t, e));
	},
	NZ = (t, e) => {
		!ec &&
			it.storage &&
			it.persist.add(((n, r) => `${n.replace(/\./g, "%2e")}.${r}`)(t, e));
	},
	fl = (t, e) => (ho === "read" && e1(t, e), c4(it.records, t, e)),
	lf = (t, e) => (ho === "read" && e1(t, e), c4(it.links, t, e)),
	XNe = (t, e) => {
		var n = it.abstractToConcreteMap.get(t);
		if (n) n.add(e);
		else {
			var r = new Set();
			r.add(e), it.abstractToConcreteMap.set(t, r);
		}
	},
	Ug = (t, e, n) => {
		jZ(c4(it.records, t, e), n) || (e1(t, e), NZ(t, e)),
			PZ(it.records, t, e, n);
	},
	ZNe = (t, e) => fl(t, e) !== void 0 || lf(t, e) !== void 0,
	t1 = (t, e, n) => {
		var r = di ? it.links.optimistic.get(di) : it.links.base;
		if (!di) {
			var i = r && r.get(t);
			ex(i && i[e], -1), ex(n, 1);
		}
		jZ(c4(it.links, t, e), n) || (e1(t, e), NZ(t, e)),
			PZ(it.links, t, e, n);
	},
	Yb = (t, e, n) => {
		var r = t.optimisticOrder.indexOf(e);
		if ((r > -1 && t.optimisticOrder.splice(r, 1), n))
			for (
				t.deferredKeys.add(e), r = r > -1 ? r : 0;
				r < t.optimisticOrder.length &&
				!t.deferredKeys.has(t.optimisticOrder[r]) &&
				(!t.dirtyKeys.has(t.optimisticOrder[r]) ||
					!t.commutativeKeys.has(t.optimisticOrder[r]));
				r++
			);
		else
			t.deferredKeys.delete(e),
				r > -1 && !t.commutativeKeys.has(e) && RZ(t, e),
				(r = 0);
		t.optimisticOrder.splice(r, 0, e), t.commutativeKeys.add(e);
	},
	QNe = (t, e) => {
		t.optimisticOrder.indexOf(e) === -1 && t.optimisticOrder.unshift(e),
			t.dirtyKeys.has(e) ||
				(t.dirtyKeys.add(e),
				t.links.optimistic.set(e, new Map()),
				t.records.optimistic.set(e, new Map()));
	},
	RZ = (t, e) => {
		t.dirtyKeys.has(e) &&
			(t.dirtyKeys.delete(e),
			t.records.optimistic.delete(e),
			t.links.optimistic.delete(e),
			t.deferredKeys.delete(e));
	},
	OZ = (t, e) => {
		var n = t.optimisticOrder.indexOf(e);
		n > -1 && (t.optimisticOrder.splice(n, 1), t.commutativeKeys.delete(e)),
			RZ(t, e);
	},
	eRe = (t) => {
		var e = dl;
		(dl = new Set()), (ho = "write");
		var n = it.links.optimistic.get(t);
		if (n)
			for (var r of n.entries()) {
				var i = r[0],
					o = r[1];
				for (var s in o) t1(i, s, o[s]);
			}
		var a = it.records.optimistic.get(t);
		if (a)
			for (var l of a.entries()) {
				var u = l[0],
					c = l[1];
				for (var d in c) Ug(u, d, c[d]);
			}
		(dl = e), OZ(it, t);
	},
	MZ = (t) => {
		var { links: e, records: n } = it,
			r = [],
			i = new Set();
		return e1(t), z8(r, i, t, e), z8(r, i, t, n), r;
	},
	tRe = () => {
		if (it.storage) {
			(ec = !0), (ho = "read");
			var t = {};
			for (var e of it.persist.keys()) {
				var { entityKey: n, fieldKey: r } = IZ(e),
					i = void 0;
				(i = lf(n, r)) !== void 0
					? (t[e] = `:${Cl(i)}`)
					: (i = fl(n, r)) !== void 0
						? (t[e] = Cl(i))
						: (t[e] = void 0);
			}
			(ec = !1), it.storage.writeData(t), it.persist.clear();
		}
	};
function jZ(t, e) {
	return typeof t != typeof e || t !== e
		? !1
		: Array.isArray(t) && Array.isArray(e)
			? t.length !== e.length
				? !1
				: !t.some((n, r) => n !== e[r])
			: !0;
}
var Jb = null,
	tx = !1,
	jE = void 0,
	d4 = (t) =>
		t.__internal.path.length > 0 && t.__internal.errorMap
			? t.__internal.errorMap[t.__internal.path.join(".")]
			: void 0,
	nx = (t, e, n, r, i, o) => {
		var s = {
			store: t,
			variables: e,
			fragments: n,
			parent: { __typename: r },
			parentTypeName: r,
			parentKey: i,
			parentFieldKey: "",
			fieldName: "",
			error: void 0,
			partial: !1,
			hasNext: !1,
			optimistic: ec,
			__internal: { path: [], errorMap: void 0 },
		};
		if (o && o.graphQLErrors)
			for (var a = 0; a < o.graphQLErrors.length; a++) {
				var l = o.graphQLErrors[a];
				l.path &&
					l.path.length &&
					(s.__internal.errorMap ||
						(s.__internal.errorMap = Object.create(null)),
					(s.__internal.errorMap[l.path.join(".")] = l));
			}
		return s;
	},
	_E = (t, e, n, r, i, o) => {
		(Jb = t),
			(t.parent = e),
			(t.parentTypeName = n),
			(t.parentKey = r),
			(t.parentFieldKey = i),
			(t.fieldName = o),
			(t.error = d4(t));
	},
	nRe = (t, e, n, r, i) => {
		if (!e) return !1;
		var o = SZ(t);
		return !o || e === o
			? !0
			: !Ho(t).some((s) => {
					if (s.kind !== ea.FIELD) return !1;
					var a = hd(Pa(s), u4(s, r));
					return !ZNe(n, a);
				});
	};
function f4(t, e, n, r, i, o) {
	var s,
		a = 0;
	return function () {
		for (var u; s || a < i.length; )
			if (((u = void 0), (tx = n), (jE = r), s)) {
				if ((u = s())) return u;
				s = void 0;
			} else {
				var c = i[a++];
				if (HNe(c, o.variables)) {
					if (c.kind !== ea.FIELD) {
						var d =
							c.kind !== ea.INLINE_FRAGMENT
								? o.fragments[Pa(c)]
								: c;
						if (d) {
							var f =
								!d.typeCondition ||
								(o.store.schema
									? GNe(o.store.schema, d, t)
									: (ho === "read" &&
											rRe(
												d.typeCondition.name.value,
												t,
											)) ||
										nRe(
											d,
											t,
											e,
											o.variables,
											o.store.logger,
										));
							if (f || (ho === "write" && !o.store.schema)) {
								var h = qNe(c);
								f &&
									d.typeCondition &&
									t !== d.typeCondition.name.value &&
									XNe(d.typeCondition.name.value, t),
									(s = f4(
										t,
										e,
										n || WNe(c, o.variables),
										h !== void 0 ? h : r,
										Ho(d),
										o,
									));
							}
						}
					} else if (ho === "write" || !c._generated) return c;
				}
			}
	};
}
var rRe = (t, e) => {
		if (!e) return !1;
		if (t === e) return !0;
		var n = !((i) => it.types.has(i))(t);
		if (!n) return !1;
		var r = ((i) => it.abstractToConcreteMap.get(i) || FZ)(t);
		return r.size && r.has(e);
	},
	Xb = (t) => t ?? null,
	zE = (t, e) => {
		if (e) {
			if (Array.isArray(e)) {
				for (
					var n = new Array(e.length), r = 0, i = n.length;
					r < i;
					r++
				)
					n[r] = zE(t, e[r]);
				return n;
			}
		} else return e || null;
		var o = t.keyOfEntity(e);
		return o;
	},
	LE = (t, e, n, r) => {
		var i = xg(e.query),
			o = PA(i),
			s = t.rootFields[o.operation],
			a = Ho(o),
			l = nx(t, AZ(o, e.variables), Xy(i), s, s, r),
			u =
				s !== l.store.rootFields.query
					? _Z(l, s, a, n || wa())
					: Lh(l, s, a, n || wa());
		return {
			dependencies: dl,
			partial: l.partial || !u,
			hasNext: l.hasNext,
			data: u || null,
		};
	},
	_Z = (t, e, n, r) => {
		if (typeof (t.store.rootNames[e] ? e : r.__typename) != "string")
			return r;
		for (
			var i = f4(e, e, !1, void 0, n, t), o, s = xp, a = wa(r);
			(o = i());

		) {
			var l = FA(o),
				u = r[l];
			t.__internal.path.push(l);
			var c = void 0;
			o.selectionSet && u !== null ? (c = zZ(t, Ho(o), Xb(u))) : (c = u),
				(s = s || c !== u),
				c !== void 0 && (a[l] = c),
				t.__internal.path.pop();
		}
		return s ? a : r;
	},
	zZ = (t, e, n) => {
		if (Array.isArray(n)) {
			for (
				var r = new Array(n.length), i = xp, o = 0, s = n.length;
				o < s;
				o++
			)
				t.__internal.path.push(o),
					(r[o] = zZ(t, e, n[o])),
					(i = i || r[o] !== n[o]),
					t.__internal.path.pop();
			return i ? r : n;
		} else if (n === null) return null;
		var a = t.store.keyOfEntity(n);
		return a !== null ? Lh(t, a, e, n) || null : _Z(t, n.__typename, e, n);
	};
function iRe(t, e, n, r) {
	var i = r.store.resolvers[e],
		o = i && i[n],
		s;
	for (var a in t) {
		var l = t[a];
		if (l && a !== "include" && a !== "skip" && r.store.directives[a])
			return (s = r.store.directives[a](u4(l, r.variables))), s;
	}
	return s || o;
}
var Lh = (t, e, n, r, i) => {
		var { store: o } = t,
			s = e === o.rootFields.query,
			a = (i && o.keyOfEntity(i)) || e,
			l = s ? e : fl(a, "__typename") || (i && i.__typename);
		if (typeof l == "string" && !(i && l !== i.__typename)) {
			for (
				var u = f4(l, a, !1, void 0, n, t),
					c = !1,
					d = !1,
					f = xp,
					h,
					p = t.partial,
					g = wa(r);
				(h = u()) !== void 0;

			) {
				var v = Pa(h),
					b = u4(h, t.variables),
					y = FA(h),
					x = l4(h),
					C = iRe(x, l, v, t),
					k = hd(v, b),
					w = Q0(a, k),
					D = fl(a, k),
					S = i ? i[v] : void 0;
				t.__internal.path.push(y);
				var $ = void 0;
				if (v === "__typename") $ = l;
				else if (S !== void 0 && h.selectionSet === void 0) $ = S;
				else if (ho === "read" && C) {
					var A = g;
					if (
						(h.selectionSet === void 0 &&
							D !== void 0 &&
							(A = { ...g, [y]: D, [v]: D }),
						_E(t, A, l, a, k, v),
						($ = C(A, b || {}, o, t)),
						h.selectionSet &&
							($ = VE(
								t,
								l,
								v,
								w,
								Ho(h),
								g[y] !== void 0 ? g[y] : r[y],
								$,
								WC(r),
							)),
						o.schema &&
							$ === null &&
							!M8(o.schema, l, v, t.store.logger))
					)
						return;
				} else if (!h.selectionSet) $ = D;
				else if (S !== void 0)
					$ = VE(
						t,
						l,
						v,
						w,
						Ho(h),
						g[y] !== void 0 ? g[y] : r[y],
						S,
						WC(r),
					);
				else {
					var T = lf(a, k);
					T !== void 0
						? ($ = LZ(
								t,
								T,
								l,
								v,
								Ho(h),
								g[y] !== void 0 ? g[y] : r[y],
								WC(r),
							))
						: typeof D == "object" && D !== null && ($ = D);
				}
				if (
					(!tx &&
					$ === void 0 &&
					(x.optional ||
						(jE && !x.required) ||
						d4(t) ||
						(o.schema && M8(o.schema, l, v, t.store.logger)))
						? ((t.partial = !0), ($ = null))
						: $ === null && (x.required || jE === !1)
							? (t.store.logger, ($ = void 0))
							: (c = c || v !== "__typename"),
					t.__internal.path.pop(),
					(f = f || $ !== r[y]),
					$ !== void 0)
				)
					g[y] = $;
				else if (tx) d = !0;
				else {
					t.store.logger, (t.partial = p);
					return;
				}
			}
			return (
				(t.partial = t.partial || p),
				(t.hasNext = t.hasNext || d),
				s && t.partial && !c ? void 0 : f ? g : r
			);
		}
	},
	VE = (t, e, n, r, i, o, s, a) => {
		if (Array.isArray(s)) {
			for (
				var { store: l } = t,
					u = l.schema ? $Z(l.schema, e, n, t.store.logger) : !1,
					c = t.partial,
					d = wa(o, !0),
					f = xp || !Array.isArray(o) || s.length !== o.length,
					h = 0,
					p = s.length;
				h < p;
				h++
			) {
				t.__internal.path.push(h);
				var g = VE(
					t,
					e,
					n,
					Q0(r, `${h}`),
					i,
					o != null ? o[h] : void 0,
					s[h],
					a,
				);
				if ((t.__internal.path.pop(), g === void 0 && !u)) {
					t.partial = c;
					return;
				} else
					(t.partial = t.partial || (g === void 0 && u)),
						(d[h] = g ?? null),
						(f = f || d[h] !== o[h]);
			}
			return f ? d : o;
		} else {
			if (s == null) return s;
			if (a && o === null) return null;
			if (oRe(s)) {
				var v = o || wa(o);
				return typeof s == "string"
					? Lh(t, s, i, v)
					: Lh(t, r, i, v, s);
			} else return;
		}
	},
	LZ = (t, e, n, r, i, o, s) => {
		if (Array.isArray(e)) {
			for (
				var { store: a } = t,
					l = a.schema ? $Z(a.schema, n, r, t.store.logger) : !1,
					u = wa(o, !0),
					c = t.partial,
					d = xp || !Array.isArray(o) || e.length !== o.length,
					f = 0,
					h = e.length;
				f < h;
				f++
			) {
				t.__internal.path.push(f);
				var p = LZ(t, e[f], n, r, i, o != null ? o[f] : void 0, s);
				if ((t.__internal.path.pop(), p === void 0 && !l)) {
					t.partial = c;
					return;
				} else
					(t.partial = t.partial || (p === void 0 && l)),
						(u[f] = p || null),
						(d = d || u[f] !== o[f]);
			}
			return d ? u : o;
		} else if (e === null || (o === null && s)) return null;
		return Lh(t, e, i, o || wa(o));
	},
	oRe = (t) =>
		typeof t == "string" ||
		(typeof t == "object" && typeof t.__typename == "string"),
	VZ = (t, e, n) => {
		for (
			var r = e ? [{ fieldKey: hd(e, n) }] : MZ(t), i = 0, o = r.length;
			i < o;
			i++
		) {
			var { fieldKey: s } = r[i];
			lf(t, s) !== void 0 ? t1(t, s, void 0) : Ug(t, s, void 0);
		}
	},
	KE = (t, e) => {
		var n = ((i) => it.types.get(i) || FZ)(t);
		for (var r of n) e.includes(r) || VZ(r);
	},
	UE = (t, e, n, r) => {
		var i = xg(e.query),
			o = PA(i),
			s = { data: n || wa(), dependencies: dl },
			a = t.rootFields[o.operation],
			l = nx(t, AZ(o, e.variables), Xy(i), a, a, r);
		return NA(l, a, Ho(o), s.data), s;
	},
	NA = (t, e, n, r) => {
		var i = t.store.rootNames[e] || "query",
			o = !!t.store.rootNames[e],
			s = o ? e : r.__typename;
		if ((!s && e && t.optimistic && (s = fl(e, "__typename")), s))
			!o &&
				e &&
				(Ug(e, "__typename", s),
				((I, F) => {
					var N = it.types.get(I);
					if (N) N.add(F);
					else {
						var O = new Set();
						O.add(F), it.types.set(I, O);
					}
				})(s, e));
		else return;
		for (
			var a = t.store.updates[s], l = f4(s, e || s, !1, void 0, n, t), u;
			(u = l());

		) {
			var c = Pa(u),
				d = u4(u, t.variables),
				f = hd(c, d),
				h = FA(u),
				p = r[t.optimistic ? c : h];
			if (
				!(
					c === "__typename" ||
					(p === void 0 && (tx || (t.optimistic && i === "query")))
				)
			) {
				t.__internal.path.push(h);
				var g = void 0;
				if (t.optimistic && i === "mutation") {
					if (!(g = t.store.optimisticMutations[c])) continue;
				} else t.optimistic && typeof p == "function" && (g = p);
				if (
					(g &&
						(_E(t, r, s, e || s, f, c),
						(p = Xb(g(d || {}, t.store, t)))),
					p !== void 0)
				) {
					if (u.selectionSet)
						if (e && i === "query") {
							var v = Q0(e, f),
								b = HE(
									t,
									Ho(u),
									Xb(p),
									v,
									t.optimistic ? lf(e || s, f) : void 0,
								);
							t1(e || s, f, b);
						} else HE(t, Ho(u), Xb(p));
					else
						e &&
							i === "query" &&
							Ug(e || s, f, p !== null || !d4(t) ? p : void 0);
					var y = a && a[c];
					if (y)
						_E(t, r, s, e || s, f, c),
							(r[c] = p),
							y(r, d || {}, t.store, t);
					else if (
						s === t.store.rootFields.mutation &&
						!t.optimistic
					) {
						if (p && Array.isArray(p))
							for (
								var x = p.map(
										(I) => t.store.keyOfEntity(I) || "",
									),
									C = 0,
									k = p.length;
								C < k;
								C++
							) {
								var w = x[C];
								if (w && p[C].__typename) {
									var D = fl(w, "__typename"),
										S = Qy(w);
									D && !S && KE(p[C].__typename, x);
								}
							}
						else if (p && typeof p == "object") {
							var $ = t.store.keyOfEntity(p);
							if ($) {
								var A = fl($, "__typename"),
									T = Qy($);
								(!A || !T) &&
									p.__typename &&
									KE(p.__typename, [$]);
							}
						}
					}
					t.__internal.path.pop();
				}
			}
		}
	},
	HE = (t, e, n, r, i) => {
		if (Array.isArray(n)) {
			for (var o = new Array(n.length), s = 0, a = n.length; s < a; s++) {
				t.__internal.path.push(s);
				var l = r ? Q0(r, `${s}`) : void 0,
					u = HE(t, e, n[s], l, i != null ? i[s] : void 0);
				(o[s] = u), t.__internal.path.pop();
			}
			return o;
		} else if (n === null) return d4(t) ? void 0 : null;
		var c = t.store.keyOfEntity(n) || (typeof i == "string" ? i : null);
		n.__typename;
		var d = c || r;
		return NA(t, d, e, n), d || null;
	};
class sRe {
	constructor(e) {
		e || (e = {}),
			(this.logger = e.logger),
			(this.resolvers = e.resolvers || {}),
			(this.directives = e.directives || {}),
			(this.optimisticMutations = e.optimistic || {}),
			(this.keys = e.keys || {}),
			(this.globalIDs = Array.isArray(e.globalIDs)
				? new Set(e.globalIDs)
				: !!e.globalIDs);
		var n = "Query",
			r = "Mutation",
			i = "Subscription";
		if (e.schema) {
			var o = (({ __schema: a }) => {
				var l = new Map(),
					u = (g) => {
						var v;
						return () => {
							if (!v) {
								v = {};
								for (var b = 0; b < g.length; b++)
									v[g[b].name] = g[b];
							}
							return v;
						};
					},
					c = (g) => {
						switch (g.kind) {
							case "OBJECT":
							case "INTERFACE":
								return {
									name: g.name,
									kind: g.kind,
									interfaces: u(g.interfaces || []),
									fields: u(
										g.fields.map((v) => ({
											name: v.name,
											type: v.type,
											args: u(v.args),
										})),
									),
								};
							case "UNION":
								return {
									name: g.name,
									kind: g.kind,
									types: u(g.possibleTypes || []),
								};
						}
					},
					d = {
						query: a.queryType ? a.queryType.name : null,
						mutation: a.mutationType ? a.mutationType.name : null,
						subscription: a.subscriptionType
							? a.subscriptionType.name
							: null,
						types: void 0,
						isSubType(g, v) {
							var b = l.get(g),
								y = l.get(v);
							return !b || !y
								? !1
								: b.kind === "UNION"
									? !!b.types()[v]
									: b.kind !== "OBJECT" && y.kind === "OBJECT"
										? !!y.interfaces()[g]
										: g === v;
						},
					};
				if (a.types) {
					d.types = l;
					for (var f = 0; f < a.types.length; f++) {
						var h = a.types[f];
						if (h && h.name) {
							var p = c(h);
							p && l.set(h.name, p);
						}
					}
				}
				return d;
			})(e.schema);
			(n = o.query || n),
				(r = o.mutation || r),
				(i = o.subscription || i),
				o.types && (this.schema = o);
		}
		(this.updates = e.updates || {}),
			(this.rootFields = { query: n, mutation: r, subscription: i }),
			(this.rootNames = {
				[n]: "query",
				[r]: "mutation",
				[i]: "subscription",
			}),
			(this.data =
				((s = n),
				{
					hydrating: !1,
					defer: !1,
					gc: new Set(),
					types: new Map(),
					persist: new Set(),
					queryRootKey: s,
					refCount: new Map(),
					links: { optimistic: new Map(), base: new Map() },
					abstractToConcreteMap: new Map(),
					records: { optimistic: new Map(), base: new Map() },
					deferredKeys: new Set(),
					commutativeKeys: new Set(),
					dirtyKeys: new Set(),
					optimisticOrder: [],
					storage: null,
				}));
		var s;
		this.schema;
	}
	keyOfField(e, n) {
		return hd(e, n);
	}
	keyOfEntity(e) {
		if (Jb && e === Jb.parent) return Jb.parentKey;
		if (e == null || typeof e == "string") return e || null;
		if (e.__typename) {
			if (this.rootNames[e.__typename]) return e.__typename;
		} else return null;
		var n = null;
		this.keys[e.__typename]
			? (n = this.keys[e.__typename](e) || null)
			: e.id != null
				? (n = `${e.id}`)
				: e._id != null && (n = `${e._id}`);
		var r = e.__typename;
		return this.globalIDs === !0 ||
			(this.globalIDs && this.globalIDs.has(r)) ||
			!n
			? n
			: `${r}:${n}`;
	}
	resolve(e, n, r) {
		var i = this.keyOfEntity(e);
		if (i) {
			var o = hd(n, r),
				s = fl(i, o);
			if (s !== void 0) return s;
			var a = lf(i, o);
			return a !== void 0 && (a = zE(this, a)), a;
		}
	}
	invalidate(e, n, r) {
		var i = this.keyOfEntity(e);
		e && typeof e == "string" && !n && !r && !this.resolve(e, "__typename")
			? KE(e, [])
			: (a4(i, "", 19), VZ(i, n, r));
	}
	inspectFields(e) {
		var n = this.keyOfEntity(e);
		return n ? MZ(n) : [];
	}
	updateQuery(e, n) {
		var r = Tu(e.query, e.variables),
			i = n(this.readQuery(r));
		i !== null && UE(this, r, i, void 0);
	}
	readQuery(e) {
		var n = Tu(e.query, e.variables);
		return LE(this, n, void 0, void 0).data;
	}
	readFragment(e, n, r, i) {
		return ((o, s, a, l, u) => {
			var c = Xy(s),
				d;
			if (u) {
				if (!(d = c[u])) return null;
			} else if (!(d = c[Object.keys(c)[0]])) return null;
			var f = R8(d);
			typeof a != "string" && !a.__typename && (a.__typename = f);
			var h = o.keyOfEntity(a);
			if (!h) return null;
			var p = nx(o, l || {}, c, f, h, void 0),
				g = Lh(p, h, Ho(d), wa()) || null;
			return g;
		})(this, xg(e), n, r, i);
	}
	writeFragment(e, n, r, i) {
		((o, s, a, l, u) => {
			var c = Xy(s),
				d;
			if (u) {
				if (!(d = c[u])) return null;
			} else if (!(d = c[Object.keys(c)[0]])) return null;
			var f = R8(d),
				h = { __typename: f, ...a },
				p = o.keyOfEntity(h);
			if (p) {
				var g = nx(o, l || {}, c, f, p, void 0);
				NA(g, p, Ho(d), h);
			}
		})(this, xg(e), n, r, i);
	}
	link(e, n, ...r) {
		var i = r.length === 2 ? r[0] : null,
			o = r.length === 2 ? r[1] : r[0],
			s = this.keyOfEntity(e);
		s && t1(s, hd(n, i), zE(this, o));
	}
}
var L8 = (t, e) => sl(t.kind, t, { ...t.context, requestPolicy: e }),
	aRe =
		(t) =>
		({ forward: e, client: n, dispatchDebug: r }) => {
			var i = new sRe(t);
			t &&
				t.storage &&
				((i.data.hydrating = !0),
				t.storage.readData().then((k) => {
					((w, D, S) => {
						$c("write", w, null);
						for (var $ in S) {
							var A = S[$];
							if (A !== void 0) {
								var { entityKey: T, fieldKey: I } = IZ($);
								A[0] === ":"
									? lf(T, I) === void 0 &&
										t1(T, I, JSON.parse(A.slice(1)))
									: fl(T, I) === void 0 &&
										Ug(T, I, JSON.parse(A));
							}
						}
						(w.storage = D), (w.hydrating = !1), Tc();
					})(i.data, t.storage, k),
						t.storage.onCacheHydrated &&
							t.storage.onCacheHydrated();
				}));
			var o = new Map(),
				s = [],
				a = new Map(),
				l = new Map(),
				u = new Set(),
				c = new Set(),
				d = new Map(),
				f = new Set(),
				h = new Set(),
				p = (k) => {
					for (var w of k.values()) if (u.has(w)) return !0;
					return !1;
				},
				g = (k, w) => {
					if (w)
						for (var D of w.values()) {
							var S = d.get(D);
							if (S) for (var $ of S.values()) k.add($);
						}
				},
				v = (k, w, D) => {
					for (var S of w.values())
						if (S !== k.key) {
							var $ = a.get(S);
							if ($) {
								k.kind === "query" && h.add(S);
								var A = "cache-first";
								c.has(S) &&
									(c.delete(S), (A = "cache-and-network")),
									n.reexecuteOperation(L8($, A));
							}
						}
					if (!D) {
						var T = f;
						(f = h),
							k.kind === "query" && f.add(k.key),
							(h = T).clear();
					}
				},
				b = (k) => {
					var w = !1;
					if (k.kind === "query") Yb(i.data, k.key), a.set(k.key, k);
					else {
						if (k.kind === "teardown")
							return (
								a.delete(k.key),
								l.delete(k.key),
								f.delete(k.key),
								j8(i.data, k.key),
								k
							);
						if (
							k.kind === "mutation" &&
							k.context.requestPolicy !== "network-only"
						) {
							a.set(k.key, k), $c("write", i.data, k.key, !0, !1);
							var { dependencies: D } = UE(i, k, void 0, void 0);
							if ((Tc(), D.size)) {
								for (var S of D.values()) u.add(S);
								o.set(k.key, D);
								var $ = new Set();
								g($, D), v(k, $, !0), (w = !0);
							}
						}
					}
					return sl(
						k.kind,
						{
							key: k.key,
							query: xg(k.query),
							variables: k.variables
								? UNe(PA(k.query), k.variables)
								: k.variables,
						},
						{ ...k.context, optimistic: w },
					);
				},
				y = (k, w) => {
					for (var D of w.values()) {
						var S = d.get(D);
						S || d.set(D, (S = new Set())), S.add(k.key);
					}
				},
				x = (k) => {
					$c("read", i.data, void 0, !1, !1);
					var w = LE(i, k, l.get(k.key), void 0);
					Tc();
					var D = w.data
						? !w.partial && !w.hasNext
							? "hit"
							: "partial"
						: "miss";
					return (
						l.set(k.key, w.data),
						a.set(k.key, k),
						y(k, w.dependencies),
						{
							outcome: D,
							operation: k,
							data: w.data,
							dependencies: w.dependencies,
							hasNext: w.hasNext,
						}
					);
				},
				C = (k, w) => {
					var D = a.get(k.operation.key) || k.operation;
					if (D.kind === "mutation") {
						var S = o.get(D.key);
						g(w, S), o.delete(D.key);
					}
					(D.kind === "subscription" || k.hasNext) &&
						Yb(i.data, D.key, !0);
					var $,
						A = k.data;
					if (A) {
						$c("write", i.data, D.key, !1, !1);
						var T = UE(i, D, A, k.error).dependencies;
						Tc(), g(w, T);
						var I = D.kind === "query" ? l.get(D.key) : null;
						$c("read", i.data, D.key, !1, I !== A);
						var F = LE(i, D, I || A, k.error);
						Tc(),
							(A = F.data),
							D.kind === "query" &&
								(g(w, ($ = F.dependencies)), l.set(D.key, A));
					} else j8(i.data, D.key);
					return (
						$ && y(k.operation, $),
						{
							operation: D,
							data: A,
							error: k.error,
							extensions: k.extensions,
							hasNext: k.hasNext,
							stale: k.stale,
						}
					);
				};
			return (k) => {
				var w = Ph(
						ou(x)(
							hn(
								(F) =>
									F.kind === "query" &&
									F.context.requestPolicy !== "network-only",
							)(k),
						),
					),
					D = hn(
						(F) =>
							F.kind !== "query" ||
							F.context.requestPolicy === "network-only",
					)(k),
					S = ou((F) => F.operation)(
						hn(
							(F) =>
								F.outcome === "miss" &&
								F.operation.context.requestPolicy !==
									"cache-only" &&
								!p(F.dependencies) &&
								!f.has(F.operation.key),
						)(w),
					),
					$ = ou((F) => {
						var { requestPolicy: N } = F.operation.context,
							O =
								N !== "cache-only" &&
								(F.hasNext ||
									N === "cache-and-network" ||
									(N === "cache-first" &&
										F.outcome === "partial" &&
										!f.has(F.operation.key))),
							_ =
								N !== "cache-only" &&
								(O ||
									(F.outcome === "partial" &&
										f.has(F.operation.key) &&
										((j = i.data).commutativeKeys.has(
											(V = F.operation.key),
										) ||
											j.optimisticOrder.indexOf(V) >
												-1))),
							j,
							V,
							K = {
								operation: F.operation,
								data: F.data,
								error: F.error,
								extensions: F.extensions,
								stale: _ && !F.hasNext,
								hasNext: O && F.hasNext,
							};
						return (
							O &&
								(p(F.dependencies)
									? N === "cache-and-network" &&
										c.add(F.operation.key)
									: n.reexecuteOperation(
											L8(
												a.get(F.operation.key) ||
													F.operation,
												"network-only",
											),
										)),
							K
						);
					})(
						hn(
							(F) =>
								F.outcome !== "miss" ||
								F.operation.context.requestPolicy ===
									"cache-only",
						)(w),
					),
					A = e(ou(b)(Yu([D, S]))),
					T = ou((F) => {
						var N = new Set(),
							O = C(F, N);
						return v(F.operation, N, !1), O;
					})(hn((F) => !o.has(F.operation.key))(A)),
					I = l3((F) => {
						if (s.push(F) < o.size) return fve;
						for (var N = 0; N < s.length; N++)
							Yb(i.data, s[N].operation.key);
						u.clear();
						for (var O = [], _ = new Set(), j; (j = s.shift()); )
							O.push(C(j, _));
						return v(F.operation, _, !1), gU(O);
					})(hn((F) => o.has(F.operation.key))(A));
				return Yu([T, I, $]);
			};
		},
	qC = (t, e) => sl(t.kind, t, { ...t.context, authAttempt: e });
function lRe(t) {
	return ({ client: e, forward: n }) => {
		var r = new Set(),
			i = sy(),
			o = sy(),
			s = new Map();
		function a() {
			u = void 0;
			var d = s;
			(s = new Map()), d.forEach(i.next);
		}
		function l(d) {
			u = void 0;
			var f = s;
			(s = new Map()),
				f.forEach((h) => {
					o.next(xU(h, d));
				});
		}
		var u,
			c = null;
		return (d) => {
			function f() {
				u = Promise.resolve()
					.then(() =>
						t({
							mutate(b, y, x) {
								var C = e.createRequestOperation(
									"mutation",
									Tu(b, y),
									x,
								);
								return e5(
									u3(1)(
										hn(
											(k) =>
												k.operation.key === C.key &&
												C.context._instance ===
													k.operation.context
														._instance,
										)(
											m2(() => {
												var k = p(C);
												r.add(k.context._instance),
													i.next(k);
											})(v),
										),
									),
								);
							},
							appendHeaders(b, y) {
								var x =
									typeof b.context.fetchOptions == "function"
										? b.context.fetchOptions()
										: b.context.fetchOptions || {};
								return sl(b.kind, b, {
									...b.context,
									fetchOptions: {
										...x,
										headers: { ...x.headers, ...y },
									},
								});
							},
						}),
					)
					.then((b) => {
						b && (c = b), a();
					})
					.catch((b) => {
						l(b);
					});
			}
			f();
			function h(b) {
				s.set(b.key, qC(b, !0)),
					c && !u && (u = c.refreshAuth().then(a).catch(l));
			}
			function p(b) {
				return c ? c.addAuthToOperation(b) : b;
			}
			var g = hn(Boolean)(
					ou((b) =>
						b.kind === "teardown"
							? (s.delete(b.key), b)
							: b.context._instance && r.has(b.context._instance)
								? b
								: b.context.authAttempt
									? p(b)
									: u || !c
										? (u || f(),
											s.has(b.key) ||
												s.set(b.key, qC(b, !1)),
											null)
										: (function (x) {
													return (
														!x.context
															.authAttempt &&
														c &&
														c.willAuthError &&
														c.willAuthError(x)
													);
											  })(b)
											? (h(b), null)
											: p(qC(b, !1)),
					)(Yu([i.source, d])),
				),
				v = n(g);
			return Yu([
				o.source,
				hn((b) =>
					!r.has(b.operation.context._instance) &&
					b.error &&
					(function (x) {
						return (
							c &&
							c.didAuthError &&
							c.didAuthError(x.error, x.operation)
						);
					})(b) &&
					!b.operation.context.authAttempt
						? (h(b.operation), !1)
						: (r.has(b.operation.context._instance) &&
								r.delete(b.operation.context._instance),
							!0),
				)(v),
			]);
		};
	};
}
var GC =
		typeof window < "u"
			? window.crypto
			: typeof self < "u"
				? self.crypto
				: null,
	Up,
	uRe = async (t) => {
		if (GC && GC.subtle) {
			var e = await GC.subtle.digest(
				{ name: "SHA-256" },
				new TextEncoder().encode(t),
			);
			return new Uint8Array(e).reduce(
				(n, r) => n + r.toString(16).padStart(2, "0"),
				"",
			);
		} else if (
			await (async () => {
				if (!Up)
					try {
						Up = new Function(
							"require",
							'return require("crypto")',
						)(require);
					} catch {
						try {
							Up = new Function('return import("crypto")')();
						} catch {}
					}
				return Up;
			})()
		)
			return (await Up).createHash("sha256").update(t).digest("hex");
		return "";
	},
	cRe =
		(t) =>
		({ forward: e }) => {
			t || (t = {});
			var n = t.preferGetForPersistedQueries,
				r = !!t.enforcePersistedQueries,
				i = t.generateHash || uRe,
				o = !!t.enableForMutation,
				s = !!t.enableForSubscriptions,
				a = !0,
				l = (u) =>
					a &&
					!u.context.persistAttempt &&
					((o && u.kind === "mutation") ||
						(s && u.kind === "subscription") ||
						u.kind === "query");
			return (u) => {
				var c = sy(),
					d = hn((h) => !l(h))(u),
					f = l3((h) => {
						var p = (async (g) => {
							var v = sl(g.kind, g, {
									...g.context,
									persistAttempt: !0,
								}),
								b = await i(c3(g.query), g.query);
							return (
								b &&
									((v.extensions = {
										...v.extensions,
										persistedQuery: {
											version: 1,
											sha256Hash: b,
										},
									}),
									v.kind === "query" &&
										n &&
										(v.context.preferGetMethod = n)),
								v
							);
						})(h);
						return QS(
							hn((g) => g.kind === "teardown" && g.key === h.key)(
								u,
							),
						)(hve(p));
					})(hn(l)(u));
				return hn((h) => !!h)(
					ou((h) => {
						if (
							!r &&
							h.operation.extensions &&
							h.operation.extensions.persistedQuery
						) {
							if (
								h.error &&
								h.error.graphQLErrors.some(
									(v) =>
										v.message ===
										"PersistedQueryNotSupported",
								)
							) {
								a = !1;
								var p = sl(h.operation.kind, h.operation);
								return (
									p.extensions &&
										delete p.extensions.persistedQuery,
									c.next(p),
									null
								);
							} else if (
								h.error &&
								((v) =>
									v.graphQLErrors.some(
										(b) =>
											b.message ===
											"PersistedQueryNotFound",
									))(h.error)
							) {
								if (h.operation.extensions.persistedQuery.miss)
									return h;
								var g = sl(h.operation.kind, h.operation);
								return (
									(g.extensions = {
										...g.extensions,
										persistedQuery: {
											...(g.extensions || {})
												.persistedQuery,
											miss: !0,
										},
									}),
									c.next(g),
									null
								);
							}
						}
						return h;
					})(e(Yu([f, d, c.source]))),
				);
			};
		},
	KZ = {
		__typename: "PageInfo",
		endCursor: null,
		startCursor: null,
		hasNextPage: !1,
		hasPreviousPage: !1,
	},
	yc = (t) => (typeof t == "string" ? t : null),
	Ul = (t, e, n) => {
		for (var r = new Set(), i = 0, o = e.length; i < o; i++) {
			var s = t.resolve(e[i], "node");
			typeof s == "string" && r.add(s);
		}
		for (var a = e.slice(), l = 0, u = n.length; l < u; l++) {
			var c = n[l],
				d = t.resolve(c, "node");
			typeof d == "string" && !r.has(d) && (r.add(d), a.push(c));
		}
		return a;
	},
	Hl = (t, e) => {
		for (var n = new Set(), r = 0, i = t.length; r < i; r++) {
			var o = t[r];
			typeof o == "string" && n.add(o);
		}
		for (var s = t.slice(), a = 0, l = e.length; a < l; a++) {
			var u = e[a];
			typeof u == "string" && !n.has(u) && (n.add(u), s.push(u));
		}
		return s;
	},
	dRe = (t, e) => {
		for (var n in e)
			if (
				!(
					n === "first" ||
					n === "last" ||
					n === "after" ||
					n === "before"
				)
			) {
				if (!(n in t)) return !1;
				var r = t[n],
					i = e[n];
				if (
					typeof r != typeof i || typeof r != "object"
						? r !== i
						: Cl(r) !== Cl(i)
				)
					return !1;
			}
		for (var o in t)
			if (
				!(
					o === "first" ||
					o === "last" ||
					o === "after" ||
					o === "before"
				) &&
				!(o in e)
			)
				return !1;
		return !0;
	},
	fRe = (t, e, n) => {
		var r = yc(t.resolve(e, n));
		if (!r) return null;
		var i = t.resolve(r, "__typename"),
			o = t.resolve(r, "edges") || [],
			s = t.resolve(r, "nodes") || [];
		if (typeof i != "string") return null;
		var a = { __typename: i, edges: o, nodes: s, pageInfo: KZ },
			l = t.resolve(r, "pageInfo");
		if (typeof l == "string") {
			var u = yc(t.resolve(l, "__typename")),
				c = yc(t.resolve(l, "endCursor")),
				d = yc(t.resolve(l, "startCursor")),
				f = t.resolve(l, "hasNextPage"),
				h = t.resolve(l, "hasPreviousPage"),
				p = (a.pageInfo = {
					__typename: typeof u == "string" ? u : "PageInfo",
					hasNextPage: typeof f == "boolean" ? f : !!c,
					hasPreviousPage: typeof h == "boolean" ? h : !!d,
					endCursor: c,
					startCursor: d,
				});
			if (p.endCursor === null) {
				var g = o[o.length - 1];
				if (g) {
					var v = t.resolve(g, "cursor");
					p.endCursor = yc(v);
				}
			}
			if (p.startCursor === null) {
				var b = o[0];
				if (b) {
					var y = t.resolve(b, "cursor");
					p.startCursor = yc(y);
				}
			}
		}
		return a;
	},
	hRe = (t = {}) => {
		var e = t.mergeMode || "inwards";
		return (n, r, i, o) => {
			var { parentKey: s, fieldName: a } = o,
				l = i.inspectFields(s).filter((S) => S.fieldName === a),
				u = l.length;
			if (u !== 0) {
				for (
					var c = null,
						d = [],
						f = [],
						h = [],
						p = [],
						g = { ...KZ },
						v = 0;
					v < u;
					v++
				) {
					var { fieldKey: b, arguments: y } = l[v];
					if (!(y === null || !dRe(r, y))) {
						var x = fRe(i, s, b);
						if (
							x !== null &&
							!(x.nodes.length === 0 && x.edges.length === 0 && c)
						) {
							if (
								e === "inwards" &&
								typeof y.last == "number" &&
								typeof y.first == "number"
							) {
								var C = x.edges.slice(0, y.first + 1),
									k = x.edges.slice(-y.last),
									w = x.nodes.slice(0, y.first + 1),
									D = x.nodes.slice(-y.last);
								(d = Ul(i, d, C)),
									(f = Ul(i, k, f)),
									(h = Hl(h, w)),
									(p = Hl(D, p)),
									(g = x.pageInfo);
							} else
								y.after
									? ((d = Ul(i, d, x.edges)),
										(h = Hl(h, x.nodes)),
										(g.endCursor = x.pageInfo.endCursor),
										(g.hasNextPage =
											x.pageInfo.hasNextPage))
									: y.before
										? ((f = Ul(i, x.edges, f)),
											(p = Hl(x.nodes, p)),
											(g.startCursor =
												x.pageInfo.startCursor),
											(g.hasPreviousPage =
												x.pageInfo.hasPreviousPage))
										: typeof y.last == "number"
											? ((f = Ul(i, x.edges, f)),
												(p = Hl(x.nodes, p)),
												(g = x.pageInfo))
											: ((d = Ul(i, d, x.edges)),
												(h = Hl(h, x.nodes)),
												(g = x.pageInfo));
							x.pageInfo.__typename !== g.__typename &&
								(g.__typename = x.pageInfo.__typename),
								c !== x.__typename && (c = x.__typename);
						}
					}
				}
				if (typeof c == "string") {
					if (!yc(i.resolve(s, a, r)))
						if (o.store.schema) o.partial = !0;
						else return;
					return {
						__typename: c,
						edges: e === "inwards" ? Ul(i, d, f) : Ul(i, f, d),
						nodes: e === "inwards" ? Hl(h, p) : Hl(p, h),
						pageInfo: {
							__typename: g.__typename,
							endCursor: g.endCursor,
							startCursor: g.startCursor,
							hasNextPage: g.hasNextPage,
							hasPreviousPage: g.hasPreviousPage,
						},
					};
				}
			}
		};
	},
	pRe = function t(e, n) {
		if (e === n) return !0;
		if (e && n && typeof e == "object" && typeof n == "object") {
			if (e.constructor !== n.constructor) return !1;
			var r, i, o;
			if (Array.isArray(e)) {
				if (((r = e.length), r != n.length)) return !1;
				for (i = r; i-- !== 0; ) if (!t(e[i], n[i])) return !1;
				return !0;
			}
			if (e.constructor === RegExp)
				return e.source === n.source && e.flags === n.flags;
			if (e.valueOf !== Object.prototype.valueOf)
				return e.valueOf() === n.valueOf();
			if (e.toString !== Object.prototype.toString)
				return e.toString() === n.toString();
			if (
				((o = Object.keys(e)),
				(r = o.length),
				r !== Object.keys(n).length)
			)
				return !1;
			for (i = r; i-- !== 0; )
				if (!Object.prototype.hasOwnProperty.call(n, o[i])) return !1;
			for (i = r; i-- !== 0; ) {
				var s = o[i];
				if (!t(e[s], n[s])) return !1;
			}
			return !0;
		}
		return e !== e && n !== n;
	};
const mRe = Dl(pRe),
	gRe = new Intl.Collator(void 0, { sensitivity: "base" });
function bRe(t, e, n) {
	const r = t === "ascending" ? 1 : -1;
	return e == null
		? 1
		: n == null
			? -1
			: typeof e == "string" && typeof n == "string"
				? gRe.compare(e, n) * r
				: vRe(e, n) * r;
}
function vRe(t, e) {
	return t < e ? -1 : t > e ? 1 : 0;
}
function pd(t) {
	const e = ee(5);
	let n;
	e[0] === Symbol.for("react.memo_cache_sentinel")
		? ((n = { mobile: "medium", tablet: "xlarge", desktop: "xxlarge" }),
			(e[0] = n))
		: (n = e[0]);
	let r;
	e[1] !== t
		? ((r =
				"children" in t
					? t.children
					: m.jsxs(m.Fragment, {
							children: [
								t.icon &&
									m.jsx(ve, {
										src: t.icon,
										size: "large",
										color: "neutralEmphasis",
									}),
								t.title &&
									m.jsx(Ut, {
										align: "center",
										size: "medium",
										children: t.title,
									}),
								t.message &&
									m.jsx(ue, {
										align: "center",
										children: t.message,
									}),
								t.actions,
							],
						})),
			(e[1] = t),
			(e[2] = r))
		: (r = e[2]);
	let i;
	return (
		e[3] !== r
			? ((i = m.jsx(ke, {
					alignItems: "center",
					direction: "column",
					gap: "large",
					justifyContent: "center",
					minHeight: "scale.3000",
					paddingX: n,
					children: r,
				})),
				(e[3] = r),
				(e[4] = i))
			: (i = e[4]),
		i
	);
}
class UZ extends Error {
	constructor() {
		super("Not found"), (this.name = "NotFoundError");
	}
}
function HZ(t) {
	return typeof t == "object" && t !== null && t instanceof UZ;
}
function kp() {
	throw new UZ();
}
class yRe extends le.Component {
	constructor(e) {
		super(e), (this.state = { notFound: !1, lastHref: e.href });
	}
	static getDerivedStateFromError(e) {
		if (HZ(e)) return { notFound: !0 };
		throw e;
	}
	static getDerivedStateFromProps(e, n) {
		return e.href !== n.lastHref && n.notFound
			? { notFound: !1, lastHref: e.href }
			: { notFound: n.notFound, lastHref: e.href };
	}
	render() {
		return this.state.notFound ? this.props.fallback : this.props.children;
	}
}
function WZ(t) {
	const e = ee(3),
		n = En();
	let r;
	return (
		e[0] !== t || e[1] !== n.href
			? ((r = m.jsx(yRe, { ...t, href: n.href })),
				(e[0] = t),
				(e[1] = n.href),
				(e[2] = r))
			: (r = e[2]),
		r
	);
}
var r0;
class V8 extends Map {
	constructor(n, r) {
		super(r);
		qe(this, r0);
		Te(this, r0, n);
	}
	get(n) {
		return z(this, r0).call(this, n), super.get(n);
	}
}
r0 = new WeakMap();
function zd(t, e) {
	const n = up(t.dirpath, t.format),
		r = e.get(n);
	if (!r) throw new Error(`Could not find data file at ${n}`);
	const { loaded: i, extraFakeFile: o } = UX(
			r,
			t.format,
			t.requireFrontmatter,
		),
		s = new Map(e);
	o && s.set(`${t.dirpath}/${o.path}`, o.contents);
	const a = new Set([n]),
		l = Ir(t.schema);
	let u;
	const c = (f) => (a.add(f), s.get(f)),
		d = (f, h) => {
			const p = new V8((x) => {
					a.add(`${f}/${x}`);
				}),
				g = new Map();
			for (const [x] of s)
				if (x.startsWith(f + "/")) {
					const C = x.slice(f.length + 1);
					p.set(C, s.get(x));
				}
			for (const x of (v = h.directories) !== null && v !== void 0
				? v
				: []) {
				var v, b, y;
				const C = new V8((w) => a.add(k + w)),
					k = `${x}${((b = t.slug) === null || b === void 0 ? void 0 : b.slug) === void 0 ? "" : `/${(y = t.slug) === null || y === void 0 ? void 0 : y.slug}`}/`;
				for (const [w, D] of s)
					if (w.startsWith(k)) {
						const S = w.slice(k.length);
						C.set(S, D);
					}
				C.size && g.set(x, C);
			}
			return { other: p, external: g };
		};
	try {
		u = jc(
			l,
			i,
			[],
			[],
			(f, h, p, g) => {
				var v;
				if (
					p.length === 1 &&
					p[0] ===
						((v = t.slug) === null || v === void 0
							? void 0
							: v.field)
				) {
					if (f.formKind !== "slug")
						throw new Error("slugField is not a slug field");
					return f.parse(h, { slug: t.slug.slug });
				}
				if (f.formKind === "asset") {
					var b, y, x;
					const w = g.join("/"),
						D = f.filename(h, {
							suggestedFilenamePrefix: w,
							slug:
								(b = t.slug) === null || b === void 0
									? void 0
									: b.slug,
						}),
						S = D
							? c(
									`${f.directory ? `${f.directory}${((y = t.slug) === null || y === void 0 ? void 0 : y.slug) === void 0 ? "" : `/${t.slug.slug}`}` : t.dirpath}/${D}`,
								)
							: void 0;
					return f.parse(h, {
						asset: S,
						slug:
							(x = t.slug) === null || x === void 0
								? void 0
								: x.slug,
					});
				}
				if (f.formKind === "content" || f.formKind === "assets") {
					const w = `${t.dirpath}/${g.join("/")}`,
						{ external: D, other: S } = d(w, f);
					if (f.formKind === "content") {
						var C;
						const $ = w + f.contentExtension,
							A = c($);
						return f.parse(h, {
							content: A,
							other: S,
							external: D,
							slug:
								(C = t.slug) === null || C === void 0
									? void 0
									: C.slug,
						});
					}
					if (f.formKind === "assets") {
						var k;
						return f.parse(h, {
							other: S,
							external: D,
							slug:
								(k = t.slug) === null || k === void 0
									? void 0
									: k.slug,
						});
					}
				}
				return f.parse(h, void 0);
			},
			!1,
		);
	} catch (f) {
		throw uJ(f);
	}
	return (
		o && a.delete(`${t.dirpath}/${o.path}`),
		{ initialState: u, initialFiles: [...a] }
	);
}
function qZ(t) {
	return [...t.values()].flatMap((e) =>
		e.children ? qZ(e.children) : [e.entry],
	);
}
function RA(t) {
	var e;
	const { current: n } = w3(),
		r = Qd(),
		i = Qo(),
		o = n.kind === "loaded" ? n.data.tree : void 0,
		s = E.useMemo(() => {
			var c;
			return jU(
				Ir(t.schema),
				t.dirpath,
				(c = t.slug) === null || c === void 0 ? void 0 : c.slug,
				t.format,
			);
		}, [
			t.dirpath,
			t.format,
			t.schema,
			(e = t.slug) === null || e === void 0 ? void 0 : e.slug,
		]),
		a = E.useMemo(() => Am(s, o ?? new Map()), [s, o]),
		l = E.useMemo(() => o ?? new Map(), [a, s]),
		u = n.kind === "loaded";
	return bo(
		E.useCallback(() => {
			var c;
			if (!u) return zo;
			if (
				((c = al(l, up(t.dirpath, t.format))) === null || c === void 0
					? void 0
					: c.entry.sha) === void 0
			)
				return "not-found";
			const f = {
					dirpath: t.dirpath,
					format: t.format,
					schema: t.schema,
					slug: t.slug,
				},
				h = s
					.flatMap((p) => {
						const g = al(l, p);
						return g
							? g.children
								? qZ(g.children)
								: [g.entry]
							: [];
					})
					.map((p) => {
						const g = GZ(t.config, p.sha, p.path, r, i);
						return g instanceof Uint8Array
							? [p.path, g]
							: g.then((v) => [p.path, v]);
					});
			if (h.every((p) => Array.isArray(p))) {
				const { initialFiles: p, initialState: g } = zd(f, new Map(h));
				return { initialState: g, initialFiles: p, localTreeKey: a };
			}
			return Promise.all(h).then(async (p) => {
				const { initialState: g, initialFiles: v } = zd(f, new Map(p));
				return { initialState: g, initialFiles: v, localTreeKey: a };
			});
		}, [u, l, t.dirpath, t.format, t.config, t.schema, t.slug, s, r, i, a]),
	);
}
const xc = new dy({ max: 200 });
async function xRe(t) {
	const e = await o5(t);
	return xc.set(e, t), await UU(e, t), e;
}
async function kRe(t, e, n, r, i) {
	if ((i == null ? void 0 : i.isPrivate) === !1) {
		var o;
		return fetch(
			`https://raw.githubusercontent.com/${Td(i)}/${r}/${(o = Ju(t.storage)) !== null && o !== void 0 ? o : ""}${n}`,
		);
	}
	const s = await $d(t);
	return fetch(
		t.storage.kind === "github"
			? `https://api.github.com/repos/${Td(t.storage.repo)}/git/blobs/${e}`
			: `${Rl}/v1/github/blob/${e}`,
		{
			headers: {
				Authorization: `Bearer ${s.accessToken}`,
				Accept: "application/vnd.github.raw",
				...(t.storage.kind === "cloud" ? ic : {}),
			},
		},
	);
}
function GZ(t, e, n, r, i) {
	if (xc.has(e)) return xc.get(e);
	const o = (async () => {
		const s = t.storage.kind === "local";
		if (!s) {
			const a = await Sye(e);
			if (a) return xc.set(e, a), a;
		}
		return (
			s
				? fetch(`/api/keystatic/blob/${e}/${n}`, {
						headers: { "no-cors": "1" },
					})
				: kRe(t, e, n, r, i)
		)
			.then(async (a) => {
				if (!a.ok)
					throw new Error(`Could not fetch blob ${e} (${n}): ${a.status}
${await a.text()}`);
				return a.arrayBuffer();
			})
			.then((a) => {
				const l = new Uint8Array(a);
				return xc.set(e, l), t.storage.kind !== "local" && UU(e, l), l;
			})
			.catch((a) => {
				throw (xc.delete(e), a);
			});
	})();
	return xc.set(e, o), o;
}
function CRe(t) {
	var e;
	const n = ee(15),
		{ collection: r, config: i } = t,
		o = (e = i.collections) === null || e === void 0 ? void 0 : e[r];
	o || kp();
	const s = En();
	let a;
	if (n[0] !== s.search) {
		var l;
		(a =
			(l = new URLSearchParams(s.search).get("search")) !== null &&
			l !== void 0
				? l
				: ""),
			(n[0] = s.search),
			(n[1] = a);
	} else a = n[1];
	const [u, c] = E.useState(a);
	let d;
	n[2] !== s
		? ((d = (y) => {
				c(y);
				const x = new URLSearchParams(s.search);
				y ? x.set("search", y) : x.delete("search"),
					s.replace(s.pathname + "?" + x.toString());
			}),
			(n[2] = s),
			(n[3] = d))
		: (d = n[3]);
	const f = d,
		h = ARe(u, 300),
		p = `${t.basePath}/collection/${encodeURIComponent(t.collection)}/create`;
	let g;
	n[4] !== o.label || n[5] !== p || n[6] !== u || n[7] !== f
		? ((g = m.jsx(wRe, {
				collectionLabel: o.label,
				createHref: p,
				searchTerm: u,
				onSearchTermChange: f,
			})),
			(n[4] = o.label),
			(n[5] = p),
			(n[6] = u),
			(n[7] = f),
			(n[8] = g))
		: (g = n[8]);
	let v;
	n[9] !== h || n[10] !== t
		? ((v = m.jsx(ERe, { searchTerm: h, ...t })),
			(n[9] = h),
			(n[10] = t),
			(n[11] = v))
		: (v = n[11]);
	let b;
	return (
		n[12] !== g || n[13] !== v
			? ((b = m.jsxs(cl, { containerWidth: "none", children: [g, v] })),
				(n[12] = g),
				(n[13] = v),
				(n[14] = b))
			: (b = n[14]),
		b
	);
}
function wRe(t) {
	const e = ee(50),
		{ collectionLabel: n, createHref: r } = t,
		i = Le(Ht),
		o = $l(en.above.mobile),
		[s, a] = E.useState(o),
		l = E.useRef(null);
	let u, c;
	e[0] !== o
		? ((u = () => {
				a(o);
			}),
			(c = [o]),
			(e[0] = o),
			(e[1] = u),
			(e[2] = c))
		: ((u = e[1]), (c = e[2])),
		E.useEffect(u, c);
	let d, f;
	e[3] === Symbol.for("react.memo_cache_sentinel")
		? ((d = () => {
				const N = (O) => {
					if (
						document.activeElement !== l.current &&
						jf("mod+f", O)
					) {
						var _;
						O.preventDefault(),
							(_ = l.current) === null ||
								_ === void 0 ||
								_.select();
					}
				};
				return (
					document.addEventListener("keydown", N),
					() => document.removeEventListener("keydown", N)
				);
			}),
			(f = []),
			(e[3] = d),
			(e[4] = f))
		: ((d = e[3]), (f = e[4])),
		E.useEffect(d, f);
	let h;
	e[5] !== n
		? ((h = m.jsx(Ut, {
				elementType: "h1",
				id: "page-title",
				size: "small",
				flex: !0,
				minWidth: 0,
				children: n,
			})),
			(e[5] = n),
			(e[6] = h))
		: (h = e[6]);
	const p = s ? "block" : "none";
	let g;
	e[7] !== p ? ((g = { display: p }), (e[7] = p), (e[8] = g)) : (g = e[8]);
	let v;
	e[9] !== i
		? ((v = i.format("search")), (e[9] = i), (e[10] = v))
		: (v = e[10]);
	let b;
	e[11] !== t || e[12] !== o
		? ((b = () => {
				t.onSearchTermChange(""),
					o ||
						setTimeout(() => {
							a(!1);
						}, 250);
			}),
			(e[11] = t),
			(e[12] = o),
			(e[13] = b))
		: (b = e[13]);
	let y;
	e[14] !== o || e[15] !== t.searchTerm
		? ((y = () => {
				!o && t.searchTerm === "" && a(!1);
			}),
			(e[14] = o),
			(e[15] = t.searchTerm),
			(e[16] = y))
		: (y = e[16]);
	let x;
	e[17] !== i
		? ((x = i.format("search")), (e[17] = i), (e[18] = x))
		: (x = e[18]);
	let C;
	e[19] !== l ||
	e[20] !== v ||
	e[21] !== t.onSearchTermChange ||
	e[22] !== t.searchTerm ||
	e[23] !== b ||
	e[24] !== y ||
	e[25] !== x
		? ((C = m.jsx(Qre, {
				ref: l,
				"aria-label": v,
				onChange: t.onSearchTermChange,
				onClear: b,
				onBlur: y,
				placeholder: x,
				value: t.searchTerm,
				width: "scale.2400",
			})),
			(e[19] = l),
			(e[20] = v),
			(e[21] = t.onSearchTermChange),
			(e[22] = t.searchTerm),
			(e[23] = b),
			(e[24] = y),
			(e[25] = x),
			(e[26] = C))
		: (C = e[26]);
	let k;
	e[27] !== g || e[28] !== C
		? ((k = m.jsx("div", { role: "search", style: g, children: C })),
			(e[27] = g),
			(e[28] = C),
			(e[29] = k))
		: (k = e[29]);
	let w;
	e[30] !== s
		? ((w = s || { above: "mobile" }), (e[30] = s), (e[31] = w))
		: (w = e[31]);
	let D;
	e[32] === Symbol.for("react.memo_cache_sentinel")
		? ((D = () => {
				a(!0);
				const N = document.createElement("input");
				(N.style.position = "absolute"),
					(N.style.opacity = "0"),
					document.body.appendChild(N),
					N.focus(),
					setTimeout(() => {
						var O;
						(O = l.current) === null || O === void 0 || O.focus(),
							N.remove();
					}, 0);
			}),
			(e[32] = D))
		: (D = e[32]);
	let S;
	e[33] === Symbol.for("react.memo_cache_sentinel")
		? ((S = m.jsx(ve, { src: nN })), (e[33] = S))
		: (S = e[33]);
	let $;
	e[34] !== w || e[35] !== D
		? (($ = m.jsx(Re, {
				"aria-label": "show search",
				isHidden: w,
				onPress: D,
				children: S,
			})),
			(e[34] = w),
			(e[35] = D),
			(e[36] = $))
		: ($ = e[36]);
	let A;
	e[37] !== s
		? ((A = s ? { below: "tablet" } : void 0), (e[37] = s), (e[38] = A))
		: (A = e[38]);
	let T;
	e[39] !== i
		? ((T = i.format("add")), (e[39] = i), (e[40] = T))
		: (T = e[40]);
	let I;
	e[41] !== r || e[42] !== A || e[43] !== T
		? ((I = m.jsx(vt, {
				marginStart: "auto",
				prominence: "high",
				href: r,
				isHidden: A,
				children: T,
			})),
			(e[41] = r),
			(e[42] = A),
			(e[43] = T),
			(e[44] = I))
		: (I = e[44]);
	let F;
	return (
		e[45] !== h || e[46] !== k || e[47] !== $ || e[48] !== I
			? ((F = m.jsxs(yp, { children: [h, k, $, I] })),
				(e[45] = h),
				(e[46] = k),
				(e[47] = $),
				(e[48] = I),
				(e[49] = F))
			: (F = e[49]),
		F
	);
}
function ERe(t) {
	const e = ee(11),
		n = w3(),
		r =
			n.merged.kind === "loaded"
				? n.merged.data.current.entries.get(r5(t.config, t.collection))
				: null;
	if (n.merged.kind === "error") {
		let o;
		e[0] !== t.basePath
			? ((o = m.jsx(vt, {
					tone: "accent",
					href: t.basePath,
					children: "Dashboard",
				})),
				(e[0] = t.basePath),
				(e[1] = o))
			: (o = e[1]);
		let s;
		return (
			e[2] !== n.merged.error.message || e[3] !== o
				? ((s = m.jsx(pd, {
						icon: gD,
						title: "Unable to load collection",
						message: n.merged.error.message,
						actions: o,
					})),
					(e[2] = n.merged.error.message),
					(e[3] = o),
					(e[4] = s))
				: (s = e[4]),
			s
		);
	}
	if (n.merged.kind === "loading") {
		let o;
		return (
			e[5] === Symbol.for("react.memo_cache_sentinel")
				? ((o = m.jsx(pd, {
						children: m.jsx(Cr, {
							"aria-label": "Loading Entries",
							isIndeterminate: !0,
							size: "large",
						}),
					})),
					(e[5] = o))
				: (o = e[5]),
			o
		);
	}
	if (!r) {
		const o = `${t.basePath}/collection/${encodeURIComponent(t.collection)}/create`;
		let s;
		return (
			e[6] !== o
				? ((s = m.jsx(pd, {
						icon: Ire,
						title: "Empty collection",
						message: m.jsxs(m.Fragment, {
							children: [
								"There aren't any entries yet.",
								" ",
								m.jsx(xh, {
									href: o,
									children: "Create the first entry",
								}),
								" ",
								"to see it here.",
							],
						}),
					})),
					(e[6] = o),
					(e[7] = s))
				: (s = e[7]),
			s
		);
	}
	let i;
	return (
		e[8] !== t || e[9] !== n.merged.data
			? ((i = m.jsx(DRe, { ...t, trees: n.merged.data })),
				(e[8] = t),
				(e[9] = n.merged.data),
				(e[10] = i))
			: (i = e[10]),
		i
	);
}
const wf = "@@slug",
	Hp = "@@status";
function DRe(t) {
	let { searchTerm: e } = t;
	const n = Qo(),
		r = Xr();
	let i = cp(t.config),
		o = En(),
		[s, a] = E.useState({ column: wf, direction: "ascending" }),
		l = i || r === (n == null ? void 0 : n.defaultBranch);
	const u = Qd(),
		c = t.config.collections[t.collection],
		d = E.useMemo(() => {
			const b = new Map(
				wg(t.config, t.collection, t.trees.default.tree).map((y) => [
					y.slug,
					y.key,
				]),
			);
			return wg(t.config, t.collection, t.trees.current.tree).map(
				(y) => ({
					name: y.slug,
					status: b.has(y.slug)
						? b.get(y.slug) === y.key
							? "Unchanged"
							: "Changed"
						: "Added",
					sha: y.sha,
				}),
			);
		}, [t.collection, t.config, t.trees]),
		f = bo(
			E.useCallback(async () => {
				var b;
				if (!((b = c.columns) !== null && b !== void 0 && b.length))
					return;
				const y = qo(t.config, t.collection),
					x = await Promise.all(
						d.map(async (w) => [
							w.name,
							await GZ(
								t.config,
								w.sha,
								up(Ni(t.config, t.collection, w.name), y),
								u,
								n,
							),
						]),
					),
					C = i5(t.config, t.collection),
					k = { kind: "object", fields: c.schema };
				return new Map(
					x.map(([w, D]) => {
						const { loaded: S } = UX(D, y),
							$ = jc(
								k,
								S,
								[],
								[],
								(A, T, I) => {
									if (A.formKind === "asset")
										return A.reader.parse(T);
									if (
										!(
											A.formKind === "content" ||
											A.formKind === "assets"
										)
									) {
										if (
											I.length === 1 &&
											w !== void 0 &&
											I[0] === c.slugField
										) {
											if (A.formKind !== "slug")
												throw new Error(
													`Slug field ${c.slugField} is not a slug field`,
												);
											return A.reader.parseWithSlug(T, {
												slug: w,
												glob: C,
											});
										}
										return A.reader.parse(T);
									}
								},
								!0,
							);
						return [w, $];
					}),
				);
			}, [c, t.config, t.collection, d, u, n]),
		),
		h = E.useMemo(() => {
			if (f.kind !== "loaded" || !f.data) return d;
			const { data: b } = f;
			return d.map((y) => ({ ...y, data: b.get(y.name) }));
		}, [d, f]),
		p = E.useMemo(
			() =>
				h.filter((b) => b.name.toLowerCase().includes(e.toLowerCase())),
			[h, e],
		),
		g = E.useMemo(
			() =>
				[...p].sort((b, y) => {
					const x = (k, w) => {
							var D;
							if (s.column === wf) {
								var S, $;
								return (S =
									($ = c.parseSlugForSort) === null ||
									$ === void 0
										? void 0
										: $.call(c, k.name)) !== null &&
									S !== void 0
									? S
									: k.name;
							}
							return s.column === Hp
								? k.status
								: (D = w == null ? void 0 : w[s.column]) !==
											null && D !== void 0
									? D
									: k.name;
						},
						C = f.kind === "loaded" ? f.data : void 0;
					return bRe(
						s.direction,
						x(b, C == null ? void 0 : C.get(b.name)),
						x(y, C == null ? void 0 : C.get(y.name)),
					);
				}),
			[c, p, f, s.column, s.direction],
		),
		v = E.useMemo(() => {
			var b;
			return (b = c.columns) !== null && b !== void 0 && b.length
				? [
						...(l
							? []
							: [
									{
										name: "Status",
										key: Hp,
										minWidth: 32,
										width: 32,
									},
								]),
						{ name: "Slug", key: wf },
						...c.columns.map((y) => {
							const x = c.schema[y];
							return {
								name: ("label" in x && x.label) || y,
								key: y,
							};
						}),
					]
				: l
					? [{ name: "Name", key: wf }]
					: [
							{
								name: "Status",
								key: Hp,
								minWidth: 32,
								width: 32,
							},
							{ name: "Name", key: wf },
						];
		}, [c, l]);
	return m.jsxs($se, {
		"aria-labelledby": "page-title",
		selectionMode: "none",
		onSortChange: a,
		sortDescriptor: s,
		density: "spacious",
		overflowMode: "truncate",
		prominence: "low",
		onAction: (b) => {
			o.push(SRe(t.basePath, t.collection, b));
		},
		renderEmptyState: () =>
			m.jsx(pd, {
				icon: Fre,
				title: "No results",
				message: `No items matching "${e}" were found.`,
			}),
		flex: !0,
		marginTop: { tablet: "large" },
		marginBottom: { mobile: "regular", tablet: "xlarge" },
		UNSAFE_className: X({
			marginInline: B.size.space.regular,
			[en.above.mobile]: {
				marginInline: `calc(${B.size.space.xlarge} - ${B.size.space.medium})`,
			},
			[en.above.tablet]: {
				marginInline: `calc(${B.size.space.xxlarge} - ${B.size.space.medium})`,
			},
			"[role=rowheader]": { cursor: "pointer" },
		}),
		children: [
			m.jsx(gie, {
				columns: v,
				children: ({ name: b, key: y, ...x }) =>
					y === Hp
						? m.jsx(
								d$,
								{
									isRowHeader: !0,
									allowsSorting: !0,
									...x,
									children: m.jsx(ve, {
										"aria-label": "Status",
										src: Pre,
									}),
								},
								y,
							)
						: m.jsx(
								d$,
								{
									isRowHeader: !0,
									allowsSorting: !0,
									...x,
									children: b,
								},
								y,
							),
			}),
			m.jsx(bie, {
				items: g,
				children: (b) => {
					var y;
					const x = m.jsx(
							j4,
							{
								textValue: b.status,
								children:
									b.status === "Added"
										? m.jsx(ve, {
												color: "positive",
												src: Nre,
											})
										: b.status === "Changed"
											? m.jsx(ve, {
													color: "accent",
													src: Rre,
												})
											: null,
							},
							Hp + b.name,
						),
						C = m.jsx(
							j4,
							{
								textValue: b.name,
								children: m.jsx(ue, {
									weight: "medium",
									children: b.name,
								}),
							},
							wf + b.name,
						);
					return (y = c.columns) !== null && y !== void 0 && y.length
						? m.jsx(
								M4,
								{
									children: [
										...(l ? [] : [x]),
										C,
										...c.columns.map((k) => {
											var w;
											let D;
											return (
												(D =
													(w = b.data) === null ||
													w === void 0
														? void 0
														: w[k]),
												D == null
													? (D = void 0)
													: (D = D + ""),
												m.jsx(
													j4,
													{
														textValue: D,
														children: m.jsx(ue, {
															weight: "medium",
															children: D,
														}),
													},
													k + b.name,
												)
											);
										}),
									],
								},
								b.name,
							)
						: l
							? m.jsx(M4, { children: C }, b.name)
							: m.jsxs(M4, { children: [x, C] }, b.name);
				},
			}),
		],
	});
}
function SRe(t, e, n) {
	return `${t}/collection/${encodeURIComponent(e)}/item/${encodeURIComponent(n)}`;
}
function ARe(t, e) {
	const n = ee(4),
		r = e,
		[i, o] = E.useState(t);
	let s, a;
	return (
		n[0] !== t || n[1] !== r
			? ((s = () => {
					const l = setTimeout(() => o(t), r);
					return () => {
						clearTimeout(l);
					};
				}),
				(a = [t, r]),
				(n[0] = t),
				(n[1] = r),
				(n[2] = s),
				(n[3] = a))
			: ((s = n[2]), (a = n[3])),
		E.useEffect(s, a),
		i
	);
}
function hl(t, e) {
	if (t.kind === "form")
		return t.formKind === "content" && t.collaboration
			? t.collaboration.toYjs(e)
			: e;
	if (t.kind === "child") return null;
	if (t.kind === "object")
		return new ba(
			Object.entries(t.fields).map(([n, r]) => [n, hl(r, e[n])]),
		);
	if (t.kind === "array") {
		const n = new Au();
		return n.push(e.map((r) => hl(t.element, r))), n;
	}
	if (t.kind === "conditional") {
		const n = e.discriminant;
		return new ba([
			["discriminant", n],
			["value", hl(t.values[n + ""], e.value)],
		]);
	}
	qn(t);
}
function ys(t, e, n) {
	if (t.kind === "form")
		return t.formKind === "content" && t.collaboration
			? t.collaboration.fromYjs(n, e)
			: n;
	if (t.kind === "child") return null;
	if (t.kind === "object")
		return Object.fromEntries(
			Object.entries(t.fields).map(([r, i]) => [r, ys(i, e, n.get(r))]),
		);
	if (t.kind === "array") {
		const r = n;
		if (!r) debugger;
		const i = r.map((o) => ys(t.element, e, o));
		return sf(i, Kr(r)), i;
	}
	if (t.kind === "conditional") {
		const r = n;
		return {
			discriminant: ys(t.discriminant, e, r.get("discriminant")),
			value: ys(t.values[r.get("discriminant") + ""], e, r.get("value")),
		};
	}
}
function $i(t, e) {
	if (t.kind === "form" || t.kind === "child") return e;
	if (t.kind === "object")
		return new ba(
			Object.entries(t.fields).map(([n, r]) => [n, $i(r, e[n])]),
		);
	if (t.kind === "array") {
		const n = new Au();
		return n.push(e.map((r) => $i(t.element, r))), n;
	}
	if (t.kind === "conditional") {
		const n = e.discriminant;
		return new ba([
			["discriminant", n],
			["value", $i(t.values[n.toString()], e.value)],
		]);
	}
}
const n1 = E.createContext(void 0),
	$Re = n1.Provider;
function YZ(t) {
	const e = ee(18),
		n = En(),
		r = E.useContext(n1);
	let i;
	if (e[0] !== n.href || e[1] !== r) {
		var o;
		(i =
			(o = new URL(n.href, "https://example.com").searchParams.get(
				"slug",
			)) !== null && o !== void 0
				? o
				: r == null
					? void 0
					: r.value),
			(e[0] = n.href),
			(e[1] = r),
			(e[2] = i);
	} else i = e[2];
	const s = i;
	let a;
	e[3] !== t.config.storage.repo
		? ((a = j0(t.config.storage.repo)),
			(e[3] = t.config.storage.repo),
			(e[4] = a))
		: (a = e[4]);
	const l = a;
	let u;
	e[5] !== l.name
		? ((u = m.jsx(An, {
				label: "Repo Name",
				width: "100%",
				isReadOnly: !0,
				value: l.name,
			})),
			(e[5] = l.name),
			(e[6] = u))
		: (u = e[6]);
	let c;
	e[7] !== l.name
		? ((c = m.jsx(Re, {
				onPress: () => {
					navigator.clipboard.writeText(l.name);
				},
				children: "Copy Repo Name",
			})),
			(e[7] = l.name),
			(e[8] = c))
		: (c = e[8]);
	let d;
	e[9] !== u || e[10] !== c
		? ((d = m.jsxs(ke, {
				alignItems: "end",
				gap: "regular",
				children: [u, c],
			})),
			(e[9] = u),
			(e[10] = c),
			(e[11] = d))
		: (d = e[11]);
	let f;
	e[12] !== s || e[13] !== r
		? ((f = s
				? m.jsx(vt, {
						prominence: "high",
						href: `https://github.com/apps/${s}/installations/new`,
						children: "Install GitHub App",
					})
				: m.jsx(fo, {
						tone: "caution",
						children: r
							? m.jsxs(ue, {
									children: [
										"The ",
										m.jsx("code", { children: r.envName }),
										" environment variable wasn't provided so we can't link to the GitHub app installation page. You should find the App on GitHub and add the repo yourself.",
									],
								})
							: m.jsx(ue, {
									children:
										"Find the App on GitHub and add the repo.",
								}),
					})),
			(e[12] = s),
			(e[13] = r),
			(e[14] = f))
		: (f = e[14]);
	let h;
	return (
		e[15] !== d || e[16] !== f
			? ((h = m.jsxs(ke, {
					direction: "column",
					gap: "regular",
					children: [d, f],
				})),
				(e[15] = d),
				(e[16] = f),
				(e[17] = h))
			: (h = e[17]),
		h
	);
}
function rx(t) {
	const e = Le(Ht),
		n = n5(),
		[r, i] = E.useState({ kind: "idle" });
	E.useEffect(() => {
		const s = async (a) => {
			if (a.key === "ks-refetch-installations" && a.newValue === "true") {
				localStorage.removeItem("ks-refetch-installations");
				try {
					var l;
					if (!(await $d(t.config))) throw new Error("Unauthorized");
					(l = (
						await n.query(hy, j0(t.config.storage.repo)).toPromise()
					).data) !== null &&
						l !== void 0 &&
						(l = l.repository) !== null &&
						l !== void 0 &&
						(l = l.forks.nodes) !== null &&
						l !== void 0 &&
						l.some(
							(d) =>
								(d == null ? void 0 : d.viewerPermission) ===
									"ADMIN" ||
								(d == null ? void 0 : d.viewerPermission) ===
									"WRITE" ||
								(d == null ? void 0 : d.viewerPermission) ===
									"MAINTAIN",
						) &&
						(await new Promise((d) => setTimeout(d, 100)),
						t.onCreate());
				} catch (u) {
					i({ kind: "error", error: u });
				}
			}
		};
		return (
			addEventListener("storage", s),
			() => removeEventListener("storage", s)
		);
	}, [n, t]);
	const o = E.useContext(n1);
	return m.jsxs(vr, {
		size: "small",
		isDismissable: !0,
		onDismiss: () => {
			t.onDismiss();
		},
		children: [
			m.jsx(Ut, { children: "Fork Repo" }),
			r.kind === "error"
				? m.jsxs(m.Fragment, {
						children: [
							m.jsx(Pr, {
								children: m.jsx(fo, {
									tone: "critical",
									children: r.error.message,
								}),
							}),
							m.jsx(Nr, {
								children: m.jsx(vt, {
									onPress: t.onDismiss,
									children: e.format("cancel"),
								}),
							}),
						],
					})
				: m.jsx(m.Fragment, {
						children: m.jsx(Pr, {
							children: m.jsxs(ke, {
								gap: "large",
								direction: "column",
								marginBottom: "large",
								children: [
									m.jsx(ue, {
										children:
											"You don't have permission to write to this repo so to save your changes, you need to fork the repo.",
									}),
									m.jsxs(ue, {
										children: [
											"To start,",
											" ",
											m.jsx(xh, {
												href: `https://github.com/${Td(t.config.storage.repo)}/fork`,
												target: "_blank",
												rel: "noopener noreferrer",
												children:
													"fork the repo on GitHub",
											}),
											". Then, come back to this page and",
											" ",
											m.jsx(xh, {
												href: `https://github.com/apps/${o == null ? void 0 : o.value}/installations/new?state=close`,
												target: "_blank",
												rel: "noopener noreferrer",
												children:
													"install the Keystatic GitHub App on your fork.",
											}),
										],
									}),
								],
							}),
						}),
					}),
		],
	});
}
const JZ = E.memo((t) => {
	const e = ee(5);
	let n;
	if (e[0] !== t.items) {
		let i;
		e[2] === Symbol.for("react.memo_cache_sentinel")
			? ((i = (o) =>
					m.jsx(Mt, { href: o.href, children: o.label }, o.key)),
				(e[2] = i))
			: (i = e[2]),
			(n = t.items.map(i)),
			(e[0] = t.items),
			(e[1] = n);
	} else n = e[1];
	let r;
	return (
		e[3] !== n
			? ((r = m.jsx(zNe, {
					flex: !0,
					size: "medium",
					minWidth: "alias.singleLineWidth",
					children: n,
				})),
				(e[3] = n),
				(e[4] = r))
			: (r = e[4]),
		r
	);
});
function XZ(t, e) {
	const n = ee(10),
		r = Jn(),
		i = IA(t);
	let o, s;
	n[0] !== i || n[1] !== e
		? ((s = new Set(i)),
			e && s.delete(e),
			(n[0] = i),
			(n[1] = e),
			(n[2] = s))
		: (s = n[2]);
	const a = r.collections[t];
	let l;
	n[3] !== r || n[4] !== t
		? ((l = i5(r, t)), (n[3] = r), (n[4] = t), (n[5] = l))
		: (l = n[5]);
	let u;
	return (
		n[6] !== a.slugField || n[7] !== s || n[8] !== l
			? ((u = { field: a.slugField, slugs: s, glob: l }),
				(n[6] = a.slugField),
				(n[7] = s),
				(n[8] = l),
				(n[9] = u))
			: (u = n[9]),
		(o = u),
		o
	);
}
function OA() {
	const t = ee(7),
		e = _0(),
		n = nH(),
		r = En();
	if (!e) return null;
	let i;
	t[0] !== n ? ((i = n.values()), (t[0] = n), (t[1] = i)) : (i = t[1]);
	let o;
	t[2] !== i ? ((o = [...i]), (t[2] = i), (t[3] = o)) : (o = t[3]);
	let s;
	return (
		t[4] !== r.href || t[5] !== o
			? ((s = m.jsx(As, {
					children: o.map((a) =>
						!a.user ||
						r.href !== `/keystatic/branch/${a.branch}/${a.location}`
							? null
							: m.jsx(m3, {
									src: a.user.avatarUrl,
									name: a.user.name,
								}),
					),
				})),
				(t[4] = r.href),
				(t[5] = o),
				(t[6] = s))
			: (s = t[6]),
		s
	);
}
xx({ body: { overflow: "hidden" } });
function ZZ(t) {
	const e =
		t.storage.kind === "github"
			? j0(t.storage.repo)
			: { owner: "repo-owner", name: "repo-name" };
	return Rve({
		url:
			t.storage.kind === "github"
				? "https://api.github.com/graphql"
				: `${Rl}/v1/github/graphql`,
		requestPolicy: "cache-and-network",
		exchanges: [
			lRe(async (n) => {
				let r = await $d(t);
				return {
					addAuthToOperation(i) {
						return (
							(r = I2(t)),
							r
								? n.appendHeaders(i, {
										Authorization: `Bearer ${r.accessToken}`,
										...(t.storage.kind === "cloud"
											? ic
											: {}),
									})
								: i
						);
					},
					didAuthError() {
						return !1;
					},
					willAuthError(i) {
						var o;
						return (
							(r = I2(t)),
							i.query.definitions[0].kind ===
								"OperationDefinition" &&
							(o = i.query.definitions[0].name) !== null &&
							o !== void 0 &&
							o.value.includes("AppShell") &&
							!r
								? (t.storage.kind === "github"
										? (window.location.href =
												"/api/keystatic/github/login")
										: O0("", t),
									!0)
								: !r
						);
					},
					async refreshAuth() {
						r = await $d(t);
					},
				};
			}),
			aRe({
				resolvers: { Repository: { refs: hRe() } },
				updates: {
					Mutation: {
						createRef(n, r, i, o) {
							i.updateQuery(
								{
									query:
										t.storage.kind === "github" ? hy : M2,
									variables: e,
								},
								(s) => {
									var a;
									return s != null &&
										(a = s.repository) !== null &&
										a !== void 0 &&
										(a = a.refs) !== null &&
										a !== void 0 &&
										a.nodes &&
										n.createRef &&
										typeof n.createRef == "object" &&
										"ref" in n.createRef
										? {
												...s,
												repository: {
													...s.repository,
													refs: {
														...s.repository.refs,
														nodes: [
															...s.repository.refs
																.nodes,
															n.createRef.ref,
														],
													},
												},
											}
										: s;
								},
							);
						},
						deleteRef(n, r, i, o) {
							i.updateQuery(
								{
									query:
										t.storage.kind === "github" ? hy : M2,
									variables: e,
								},
								(s) => {
									var a;
									if (
										s != null &&
										(a = s.repository) !== null &&
										a !== void 0 &&
										(a = a.refs) !== null &&
										a !== void 0 &&
										a.nodes &&
										n.deleteRef &&
										typeof n.deleteRef == "object" &&
										"__typename" in n.deleteRef &&
										typeof r.input == "object" &&
										r.input !== null &&
										"refId" in r.input &&
										typeof r.input.refId == "string"
									) {
										const l = r.input.refId;
										return {
											...s,
											repository: {
												...s.repository,
												refs: {
													...s.repository.refs,
													nodes: s.repository.refs.nodes.filter(
														(u) =>
															(u == null
																? void 0
																: u.id) !== l,
													),
												},
											},
										};
									}
									return s;
								},
							);
						},
					},
				},
			}),
			...(t.storage.kind === "github"
				? []
				: [
						cRe({
							enableForMutation: !0,
							enforcePersistedQueries: !0,
						}),
					]),
			Ive,
		],
	});
}
function TRe(t) {
	const e = ee(19),
		{ children: n, config: r } = t,
		i = Z$e(),
		{ push: o } = En();
	let s, a;
	e[0] !== o ? ((a = { navigate: o }), (e[0] = o), (e[1] = a)) : (a = e[1]),
		(s = a);
	const l = s;
	let u;
	e[2] === Symbol.for("react.memo_cache_sentinel")
		? ((u = m.jsx("meta", {
				name: "viewport",
				content: "width=device-width, initial-scale=1",
			})),
			(e[2] = u))
		: (u = e[2]);
	const c = r.locale || "en-US";
	let d, f;
	e[3] === Symbol.for("react.memo_cache_sentinel")
		? ((d = m.jsx(One, { bodyBackground: "surface" })),
			(f = m.jsx("link", {
				href: "https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap",
				rel: "stylesheet",
			})),
			(e[3] = d),
			(e[4] = f))
		: ((d = e[3]), (f = e[4]));
	let h, p;
	e[5] !== r ? ((p = ZZ(r)), (e[5] = r), (e[6] = p)) : (p = e[6]), (h = p);
	let g;
	e[7] !== h || e[8] !== n
		? ((g = m.jsx(Ove, { value: h, children: n })),
			(e[7] = h),
			(e[8] = n),
			(e[9] = g))
		: (g = e[9]);
	let v;
	e[10] === Symbol.for("react.memo_cache_sentinel")
		? ((v = m.jsx(Vme, {})), (e[10] = v))
		: (v = e[10]);
	let b;
	e[11] !== c || e[12] !== i.theme || e[13] !== l || e[14] !== g
		? ((b = m.jsxs(Hh, {
				locale: c,
				colorScheme: i.theme,
				router: l,
				children: [d, f, g, v],
			})),
			(e[11] = c),
			(e[12] = i.theme),
			(e[13] = l),
			(e[14] = g),
			(e[15] = b))
		: (b = e[15]);
	let y;
	return (
		e[16] !== i || e[17] !== b
			? ((y = m.jsxs(X$e, { value: i, children: [u, b] })),
				(e[16] = i),
				(e[17] = b),
				(e[18] = y))
			: (y = e[18]),
		y
	);
}
const QZ = new TextEncoder(),
	Ef = QZ.encode(`---
`);
function BRe(t, e) {
	const n = new Uint8Array(t.byteLength + e.byteLength + Ef.byteLength * 2);
	return (
		n.set(Ef),
		n.set(t, Ef.byteLength),
		n.set(Ef, Ef.byteLength + t.byteLength),
		n.set(e, Ef.byteLength * 2 + t.byteLength),
		n
	);
}
function r1(t) {
	var e, n;
	let { value: r, extraFiles: i } = cd(
		t.state,
		Ir(t.schema),
		(e = t.slug) === null || e === void 0 ? void 0 : e.field,
		(n = t.slug) === null || n === void 0 ? void 0 : n.value,
		!0,
	);
	const o = t.format.data;
	let s = QZ.encode(
		o === "json"
			? JSON.stringify(r, null, 2) +
					`
`
			: SNe(r),
	);
	if (t.format.contentField) {
		const a = `${t.format.contentField.path.join("/")}${t.format.contentField.contentExtension}`;
		let l;
		(i = i.filter((u) => (u.path !== a ? !0 : ((l = u.contents), !1)))),
			wt(l !== void 0, "Expected content field to be present"),
			(s = BRe(s, l));
	}
	return [
		{ path: up(t.basePath, t.format), contents: s },
		...i.map((a) => ({
			path: `${a.parent ? (t.slug ? `${a.parent}/${t.slug.value}` : a.parent) : t.basePath}/${a.path}`,
			contents: a.contents,
		})),
	];
}
function Cp(t) {
	const [e, n] = E.useState({ kind: "idle" }),
		r = Qd(),
		i = Xr(),
		o = rH(),
		[, s] = f3(eQ),
		a = Qo(),
		l = E.useContext(n1),
		u = uH();
	return [
		e,
		async (c) => {
			try {
				var d, f;
				const C = u.kind === "loaded" ? u.data.tree : void 0;
				if (!C) return !1;
				if (
					t.config.storage.kind === "github" &&
					a &&
					!a.hasWritePermission &&
					l !== null &&
					l !== void 0 &&
					l.value
				)
					return n({ kind: "needs-fork" }), !1;
				n({ kind: "loading" });
				const k =
					(d = Ju(t.config.storage)) !== null && d !== void 0
						? d
						: "";
				let w = r1({
					basePath: t.basePath,
					schema: t.schema,
					format: t.format,
					state: t.state,
					slug: t.slug,
				}).map((T) => ({ ...T, path: k + T.path }));
				const D = new Map(
						await Promise.all(
							w.map(async (T) => [T.path, await xRe(T.contents)]),
						),
					),
					S = new Set(
						(f = t.initialFiles) === null || f === void 0
							? void 0
							: f.map((T) => k + T),
					);
				for (const T of w) S.delete(T.path);
				w = w.filter((T) => {
					const I = D.get(T.path),
						F = al(C, T.path);
					return (F == null ? void 0 : F.entry.sha) !== I;
				});
				const $ = [...S].map((T) => ({ path: T })),
					A = await RU(C, { additions: w, deletions: [...S] });
				if (
					(await Oh(A.entries),
					t.config.storage.kind === "github" ||
						t.config.storage.kind === "cloud")
				) {
					var h, p, g, v, b;
					if (!a) throw new Error("Repo info not loaded");
					const T = {
							branchName:
								(h = c == null ? void 0 : c.branch) !== null &&
								h !== void 0
									? h
									: i,
							repositoryNameWithOwner: `${a.owner}/${a.name}`,
						},
						I = (_) =>
							s({
								input: {
									branch: T,
									expectedHeadOid: _,
									message: {
										headline: `Update ${t.basePath}`,
									},
									fileChanges: {
										additions: w.map((j) => ({
											...j,
											contents: k2(j.contents),
										})),
										deletions: $,
									},
								},
							});
					let F = await I(
						(p = c == null ? void 0 : c.sha) !== null &&
							p !== void 0
							? p
							: r,
					);
					const N =
						(g = F.error) === null ||
						g === void 0 ||
						(g = g.graphQLErrors[0]) === null ||
						g === void 0
							? void 0
							: g.originalError;
					if (N && "type" in N) {
						if (N.type === "BRANCH_PROTECTION_RULE_VIOLATION")
							return (
								n({
									kind: "needs-new-branch",
									reason: "Changes must be made via pull request to this branch. Create a new branch to save changes.",
								}),
								!1
							);
						if (N.type === "STALE_DATA") {
							var y, x;
							const _ = await ZZ(t.config)
								.query(FRe, {
									owner: a.owner,
									name: a.name,
									ref: `refs/heads/${i}`,
								})
								.toPromise();
							if (
								!(
									(y = _.data) !== null &&
									y !== void 0 &&
									(y = y.repository) !== null &&
									y !== void 0 &&
									(y = y.ref) !== null &&
									y !== void 0 &&
									y.target
								)
							)
								throw new Error("Branch not found");
							const j = F2(
								await dH(
									_.data.repository.ref.target.oid,
									t.config,
								),
								t.config,
							);
							if (
								Am(
									jU(
										Ir(t.schema),
										t.basePath,
										(x = t.slug) === null || x === void 0
											? void 0
											: x.value,
										t.format,
									),
									j.tree,
								) === t.currentLocalTreeKey
							)
								F = await I(_.data.repository.ref.target.oid);
							else
								return (
									n({
										kind: "needs-new-branch",
										reason: "This entry has been updated since it was opened. Create a new branch to save changes.",
									}),
									!1
								);
						}
					}
					if (
						(v = F.error) !== null &&
						v !== void 0 &&
						v.graphQLErrors.some(
							(_) =>
								"type" in _ &&
								_.type === "FORBIDDEN" &&
								_.message ===
									"Resource not accessible by integration",
						)
					)
						throw new Error(
							`The GitHub App is unable to commit to the repository. Please ensure that the Keystatic GitHub App is installed in the GitHub repository ${a.owner}/${a.name}`,
						);
					if (F.error) throw F.error;
					if (
						(b = F.data) === null ||
						b === void 0 ||
						(b = b.createCommitOnBranch) === null ||
						b === void 0 ||
						(b = b.ref) === null ||
						b === void 0
							? void 0
							: b.target
					)
						return n({ kind: "updated" }), !0;
					throw new Error("Failed to update");
				} else {
					const T = await fetch("/api/keystatic/update", {
						method: "POST",
						headers: {
							"Content-Type": "application/json",
							"no-cors": "1",
						},
						body: JSON.stringify({
							additions: w.map((N) => ({
								...N,
								contents: k2(N.contents),
							})),
							deletions: $,
						}),
					});
					if (!T.ok) throw new Error(await T.text());
					const I = await T.json(),
						{ tree: F } = await Oh(I);
					return o(await R0(F)), n({ kind: "updated" }), !0;
				}
			} catch (C) {
				return n({ kind: "error", error: C }), !1;
			}
		},
		() => {
			n({ kind: "idle" });
		},
	];
}
const eQ = yr`
  mutation CreateCommit($input: CreateCommitOnBranchInput!) {
    createCommitOnBranch(input: $input) {
      ref {
        id
        target {
          id
          oid
          ... on Commit {
            tree {
              id
              oid
            }
          }
        }
      }
    }
  }
`;
function IRe(t) {
	const [e, n] = E.useState({ kind: "idle" }),
		r = Qd(),
		i = Xr(),
		[, o] = f3(eQ),
		s = rH(),
		a = Qo(),
		l = E.useContext(n1),
		u = uH();
	return [
		e,
		async () => {
			try {
				const c = u.kind === "loaded" ? u.data.tree : void 0;
				if (!c) return !1;
				if (
					t.storage.kind === "github" &&
					a &&
					!a.hasWritePermission &&
					l !== null &&
					l !== void 0 &&
					l.value
				)
					return n({ kind: "needs-fork" }), !1;
				n({ kind: "loading" });
				const d = t.initialFiles.map((h) => {
						var p;
						return (
							((p = Ju(t.storage)) !== null && p !== void 0
								? p
								: "") + h
						);
					}),
					f = await RU(c, { additions: [], deletions: d });
				if (
					(await Oh(f.entries),
					t.storage.kind === "github" || t.storage.kind === "cloud")
				) {
					if (!a) throw new Error("Repo info not loaded");
					const { error: h } = await o({
						input: {
							branch: {
								repositoryNameWithOwner: `${a.owner}/${a.name}`,
								branchName: i,
							},
							message: { headline: `Delete ${t.basePath}` },
							expectedHeadOid: r,
							fileChanges: {
								deletions: d.map((p) => ({ path: p })),
							},
						},
					});
					if (
						h != null &&
						h.graphQLErrors.some(
							(p) =>
								"type" in p &&
								p.type === "FORBIDDEN" &&
								p.message ===
									"Resource not accessible by integration",
						)
					)
						throw new Error(
							`The GitHub App is unable to commit to the repository. Please ensure that the Keystatic GitHub App is installed in the GitHub repository ${a.owner}/${a.name}`,
						);
					if (h) throw h;
					return n({ kind: "updated" }), !0;
				} else {
					const h = await fetch("/api/keystatic/update", {
						method: "POST",
						headers: {
							"Content-Type": "application/json",
							"no-cors": "1",
						},
						body: JSON.stringify({
							additions: [],
							deletions: d.map((v) => ({ path: v })),
						}),
					});
					if (!h.ok) throw new Error(await h.text());
					const p = await h.json(),
						{ tree: g } = await Oh(p);
					return s(await R0(g)), n({ kind: "updated" }), !0;
				}
			} catch (c) {
				n({ kind: "error", error: c });
			}
		},
		() => {
			n({ kind: "idle" });
		},
	];
}
const FRe = yr`
  query FetchRef($owner: String!, $name: String!, $ref: String!) {
    repository(owner: $owner, name: $name) {
      id
      ref(qualifiedName: $ref) {
        id
        target {
          id
          oid
        }
      }
    }
  }
`;
function i1(t) {
	const e = ee(9);
	let n;
	e[0] !== t.slugField || e[1] !== t.schema
		? ((n = async (f) => {
				const h = t.slugField
						? tr(
								{
									schema: t.schema.fields,
									slugField: t.slugField,
								},
								f,
							)
						: void 0,
					p = cd(f, t.schema, t.slugField, h, !0);
				return {
					slug: h,
					value: p.value,
					extraFiles: Object.fromEntries(
						await Promise.all(
							p.extraFiles.map(async (g) => [
								JSON.stringify([g.path, g.parent]),
								await o5(g.contents),
							]),
						),
					),
				};
			}),
			(e[0] = t.slugField),
			(e[1] = t.schema),
			(e[2] = n))
		: (n = e[2]);
	const r = n;
	let i;
	e[3] !== t.initialState || e[4] !== r
		? ((i = () => (t.initialState === null ? null : r(t.initialState))),
			(e[3] = t.initialState),
			(e[4] = r),
			(e[5] = i))
		: (i = e[5]);
	const o = bo(i);
	let s;
	e[6] !== r || e[7] !== t.state
		? ((s = () => r(t.state)), (e[6] = r), (e[7] = t.state), (e[8] = s))
		: (s = e[8]);
	const a = bo(s);
	let l;
	e: {
		if (o.kind === "loaded" && a.kind === "loaded") {
			const f = o.data,
				h = a.data;
			l = !mRe(f, h);
			break e;
		}
		l = "unknown";
	}
	const u = l,
		[c, d] = E.useState(!1);
	return typeof u == "boolean" && u !== c && d(u), c;
}
function MA(t, e) {
	const n = ee(14),
		r = eH();
	let i, o;
	n[0] !== t || n[1] !== r.awareness || n[2] !== e
		? ((o = ys(t, r.awareness, e)),
			(n[0] = t),
			(n[1] = r.awareness),
			(n[2] = e),
			(n[3] = o))
		: (o = n[3]);
	const s = o;
	let a;
	n[4] !== s ? ((a = () => o), (n[4] = s), (n[5] = a)) : (a = n[5]);
	const l = o;
	let u;
	n[6] !== l || n[7] !== t || n[8] !== r.awareness || n[9] !== e
		? ((u = (f) => {
				const h = () => {
					(o = ys(t, r.awareness, e)), f();
				};
				return (
					e.observeDeep(h),
					() => {
						e.unobserveDeep(h);
					}
				);
			}),
			(n[6] = l),
			(n[7] = t),
			(n[8] = r.awareness),
			(n[9] = e),
			(n[10] = u))
		: (u = n[10]);
	let c;
	n[11] !== a || n[12] !== u
		? ((c = { getSnapshot: a, subscribe: u }),
			(n[11] = a),
			(n[12] = u),
			(n[13] = c))
		: (c = n[13]),
		(i = c);
	const d = i;
	return E.useSyncExternalStore(d.subscribe, d.getSnapshot, d.getSnapshot);
}
function PRe(t, e, n) {
	return t.has(e) || t.set(e, n(e)), t.get(e);
}
function NRe(t, e) {
	if (t.length !== e.length) return;
	const n = [...t].sort(),
		r = [...e].sort();
	if (n.join() !== r.join()) return;
	let i;
	for (let o = 0; o < t.length; o++)
		if (t[o] !== e[o]) {
			if (i === e[o]) continue;
			if (i !== void 0) return;
			i = t[o];
		}
	return i;
}
function RRe(t, e, n) {
	const r = {
			form(c, d) {
				return d;
			},
			array(c, d) {
				return {
					rawOnChange: d,
					inner: new Map(),
					onChange(f) {
						const h = d.yjs(),
							p = ys(c, n, h),
							g = Kr(h),
							v = new Set();
						for (const w of f)
							if (w.key !== void 0) {
								if (v.has(w.key))
									throw new Error(
										"Array elements must have unique keys",
									);
								v.add(w.key);
							}
						const b = f.map((w) => {
							if (w.key !== void 0) return w.key;
							let D = Md();
							for (; v.has(D); ) D = Md();
							return v.add(D), D;
						});
						sf(h, b);
						const y = NRe(g, b);
						if (y !== void 0) {
							const w = g.indexOf(y),
								D = b.indexOf(y);
							let S = h.get(w);
							S instanceof ir && (S = S.clone()),
								h.delete(w),
								h.insert(D, [S]);
							for (const [$, { value: A }] of f.entries()) {
								const T = g.indexOf(b[$]),
									I = vs(c.element, p[T], A);
								I !== p &&
									(h.delete(T),
									h.insert($, [$i(c.element, I)]));
							}
							return;
						}
						const x = g.join(),
							C = b.slice(0, g.length).join();
						if (x === C) {
							for (const [D, { value: S }] of f.entries()) {
								const $ = g.indexOf(b[D]),
									A = vs(c.element, p[$], S);
								A !== p &&
									(h.delete($),
									h.insert(D, [$i(c.element, A)]));
							}
							const w = [];
							for (const { value: D } of f.slice(g.length))
								w.push($i(c.element, ua(c.element, D)));
							w.length && h.insert(g.length, w);
							return;
						}
						const k = f.map((w, D) => {
							const S = b[D],
								$ = g.indexOf(S);
							if ($ !== -1) {
								const A = h.get($);
								if (w.value === void 0)
									return A instanceof ir ? A.clone() : A;
								const T = vs(c.element, p[$], w.value);
								return $i(c.element, T);
							}
							return $i(c.element, ua(c.element, w.value));
						});
						h.delete(0, h.length), h.insert(0, k);
					},
				};
			},
			conditional(c, d) {
				return {
					onChange: (f, h) => {
						if ((d.yjs().set("discriminant", f), h !== void 0)) {
							const p = ys(c, n, d.yjs().get("value"));
							d.yjs().set(
								"value",
								$i(c, vs(c.values[f.toString()], p, h)),
							);
						}
					},
					onChangeForValue: Object.assign(
						(f) => {
							const h = ys(c, n, d.yjs().get("value"));
							d.yjs().set("value", $i(c, f(h)));
						},
						{
							yjs() {
								return d.yjs().get("value");
							},
						},
					),
				};
			},
			object(c, d) {
				return {
					onChange: (f) => {
						for (const [h, p] of Object.entries(f)) {
							const g = ys(c.fields[h], n, d.yjs().get(h));
							d.yjs().set(
								h,
								$i(c.fields[h], vs(c.fields[h], g, p)),
							);
						}
					},
					innerOnChanges: Object.fromEntries(
						Object.entries(c.fields).map(([f, h]) => {
							let p = Object.assign(
								(g) => {
									d.yjs().set(f, $i(h, g));
								},
								{
									yjs() {
										return d.yjs().get(f);
									},
								},
							);
							return [f, p];
						}),
					),
				};
			},
		},
		i = {
			form(c, d, f) {
				return { value: d, onChange: f, schema: c };
			},
			object(c, d, f, h, p) {
				const g = {};
				for (const b of Object.keys(c.fields))
					g[b] = p(c.fields[b], d[b], f.innerOnChanges[b], b);
				return { fields: g, onChange: f.onChange, schema: c };
			},
			array(c, d, f, h, p) {
				const g = d,
					v = Kr(g),
					b = new Set(Kr(d)),
					y = {
						elements: g.map((x, C) => {
							const k = v[C];
							b.delete(k);
							const w = PRe(f.inner, k, () => {
									const S = Object.assign(
											(A) => {
												const T = f.rawOnChange.yjs(),
													F = Kr(T).indexOf(k),
													N = A(ys(c, n, T.get(F)));
												T.delete(F),
													T.insert(F, [
														$i(c.element, N),
													]);
											},
											{
												yjs() {
													const T = Kr(
														f.rawOnChange.yjs(),
													).indexOf(k);
													return f.rawOnChange
														.yjs()
														.get(T);
												},
											},
										),
										$ = p(c.element, x, S, k);
									return {
										element: $,
										elementWithKey: { ...$, key: k },
										onChange: S,
									};
								}),
								D = p(c.element, x, w.onChange, k);
							return (
								w.element !== D &&
									((w.element = D),
									(w.elementWithKey = { ...D, key: k })),
								w.elementWithKey
							);
						}),
						schema: c,
						onChange: f.onChange,
					};
				for (const x of b) f.inner.delete(x);
				return y;
			},
			conditional(c, d, f, h, p) {
				return {
					discriminant: d.discriminant,
					onChange: f.onChange,
					value: p(
						c.values[d.discriminant.toString()],
						d.value,
						f.onChangeForValue,
						"value",
					),
					schema: c,
				};
			},
		};
	function o(c, d, f, h, p) {
		return i[c.kind](c, d, f, h, p);
	}
	function s(c, d, f, h) {
		const p = new Map(),
			g = r[c.kind](c, f);
		return {
			value: d,
			inner: p,
			props: o(c, d, g, h, (b, y, x, C) => {
				const k = s(b, y, x, h.concat(C));
				return p.set(C, k), k.props;
			}),
			schema: c,
			cached: g,
		};
	}
	function a(c, d, f, h, p) {
		if (h.schema !== c) return Object.assign(h, s(c, d, f, p)), h.props;
		if (h.value === d) return h.props;
		h.value = d;
		const g = new Set(h.inner.keys());
		h.props = o(c, d, h.cached, p, (v, b, y, x) => {
			if ((g.delete(x), !h.inner.has(x))) {
				const C = s(v, b, y, p.concat(x));
				return h.inner.set(x, C), C.props;
			}
			return a(v, b, y, h.inner.get(x), p.concat(x));
		});
		for (const v of g) h.inner.delete(v);
		return h.props;
	}
	let l;
	const u = Object.assign(
		(c) => {
			const d = c(l.value),
				f = $i(t, d);
			for (const [h, p] of f.entries()) f.delete(h), e.set(h, p);
		},
		{
			yjs() {
				return e;
			},
		},
	);
	return (c) =>
		l === void 0 ? ((l = s(t, c, u, [])), l.props) : a(t, c, u, l, []);
}
function jA(t, e, n) {
	return E.useMemo(() => Ba(t, e, () => {}), [t, e])(n);
}
function _A(t, e, n) {
	const r = eH();
	return E.useMemo(() => RRe(t, e, r.awareness), [e, t, r.awareness])(n);
}
function wp(t) {
	const e = ee(5),
		r = Jn().collections[t];
	let i, o;
	e[0] !== r.schema
		? ((o = { kind: "object", fields: r.schema }),
			(e[0] = r.schema),
			(e[1] = o))
		: (o = e[1]),
		(i = o);
	const s = i;
	let a;
	return (
		e[2] !== s || e[3] !== r
			? ((a = { schema: s, collectionConfig: r }),
				(e[2] = s),
				(e[3] = r),
				(e[4] = a))
			: (a = e[4]),
		a
	);
}
function zA(t) {
	const e = ee(5),
		r = Jn().singletons[t];
	let i, o;
	e[0] !== r.schema
		? ((o = { kind: "object", fields: r.schema }),
			(e[0] = r.schema),
			(e[1] = o))
		: (o = e[1]),
		(i = o);
	const s = i;
	let a;
	return (
		e[2] !== s || e[3] !== r
			? ((a = { schema: s, singletonConfig: r }),
				(e[2] = s),
				(e[3] = r),
				(e[4] = a))
			: (a = e[4]),
		a
	);
}
class ORe extends le.Component {
	constructor(e) {
		super(e), (this.state = { message: null });
	}
	static getDerivedStateFromError(e) {
		if (HZ(e)) throw e;
		return { message: String(e) };
	}
	render() {
		return this.state.message
			? typeof this.props.fallback == "function"
				? this.props.fallback(this.state.message)
				: this.props.fallback
			: this.props.children;
	}
}
const MRe = sa({
		slug: CS(jt()),
		files: nme(
			jt(),
			Mz(Jx(Uint8Array), jt(), (t) => h3(t)),
		),
	}),
	jRe = new TextDecoder();
function _Re(t, e, n, r) {
	const o = new DOMParser()
		.parseFromString(t, "text/html")
		.querySelector("pre");
	if (o != null && o.dataset.keystaticEntry)
		try {
			var s, a;
			const l = JSON.parse(o.dataset.keystaticEntry),
				u = MRe.create(l),
				c = new Map(Object.entries(u.files));
			return zd(
				{
					dirpath:
						(s = u.slug) !== null && s !== void 0 ? s : "entry",
					format: e,
					schema: n,
					slug: r
						? {
								field: r,
								slug:
									(a = u.slug) !== null && a !== void 0
										? a
										: "",
							}
						: void 0,
					requireFrontmatter: !0,
				},
				c,
			).initialState;
		} catch {}
}
function zRe(t, e, n, r) {
	try {
		var i;
		const o =
			(i = r == null ? void 0 : r.slug) !== null && i !== void 0
				? i
				: "entry";
		return zd(
			{
				dirpath: o,
				format: e,
				schema: n,
				slug: r,
				requireFrontmatter: !0,
			},
			new Map([[up(o, e), t]]),
		).initialState;
	} catch {}
}
async function LA(t, e, n) {
	let r;
	try {
		r = await navigator.clipboard.read();
	} catch (i) {
		if (i instanceof DOMException && i.name === "NotAllowedError") {
			il.critical("Failed to paste because clipboard access was denied", {
				timeout: 5e3,
			});
			return;
		}
		il.critical("Failed to read clipboard", { timeout: 5e3 });
		return;
	}
	for (const i of r) {
		if (i.types.includes("text/html")) {
			const s = await (await i.getType("text/html")).text(),
				a = _Re(s, t, e, n == null ? void 0 : n.field);
			if (a) return a;
		}
		if (i.types.includes("text/plain")) {
			const s = await (await i.getType("text/plain")).arrayBuffer(),
				a = zRe(new Uint8Array(s), t, e, n);
			if (a) return a;
		}
	}
	il.critical("Entry not found in clipboard", { timeout: 5e3 });
}
function LRe(t, e, n, r) {
	var i;
	const o =
			(i = r == null ? void 0 : r.value) !== null && i !== void 0
				? i
				: "entry",
		s = r1({ basePath: o, format: e, schema: n, slug: r, state: t }),
		a = document.createElement("pre");
	a.dataset.keystaticEntry = JSON.stringify({
		slug: r == null ? void 0 : r.value,
		files: Object.fromEntries(s.map((d) => [d.path, nd(d.contents)])),
	});
	const l = up(o, e),
		u = s.find((d) => d.path === l);
	if (!u) throw new Error("No main entry file found");
	const c = jRe.decode(u.contents);
	return (a.textContent = c), { html: a.outerHTML, plain: c };
}
function VA(t, e, n, r) {
	const i = LRe(t, e, n, r);
	navigator.clipboard.write([
		new ClipboardItem({
			"text/plain": new Blob([i.plain], { type: "text/plain" }),
			"text/html": new Blob([i.html], { type: "text/html" }),
		}),
	]);
}
const VRe = sa({
	version: xS(1),
	savedAt: Yx(),
	slug: jt(),
	beforeTreeKey: jt(),
	files: kS(jt(), Jx(Uint8Array)),
});
function tQ(t) {
	var e, n;
	const r = ee(115),
		{
			collection: i,
			config: o,
			itemSlug: s,
			updateResult: a,
			onUpdate: l,
		} = t,
		{ collectionConfig: u, schema: c } = wp(i),
		d = En(),
		f = Qd();
	let h;
	r[0] !== o || r[1] !== i || r[2] !== s
		? ((h = Ni(o, i, s)), (r[0] = o), (r[1] = i), (r[2] = s), (r[3] = h))
		: (h = r[3]);
	const p = h;
	let g;
	r[4] !== o || r[5] !== i
		? ((g = qo(o, i)), (r[4] = o), (r[5] = i), (r[6] = g))
		: (g = r[6]);
	const v = g,
		b = Xr(),
		y = Qo(),
		[x, C] = E.useState(!1);
	let k;
	r[7] !== u.previewUrl || r[8] !== t || r[9] !== b
		? ((k = u.previewUrl
				? u.previewUrl
						.replace("{slug}", t.itemSlug)
						.replace("{branch}", b)
				: void 0),
			(r[7] = u.previewUrl),
			(r[8] = t),
			(r[9] = b),
			(r[10] = k))
		: (k = r[10]);
	const w = k,
		{ push: D, replace: S } = d,
		$ = XZ(i, s);
	let A;
	r[11] !== t.initialFiles || r[12] !== o.storage || r[13] !== p
		? ((A = {
				initialFiles: t.initialFiles,
				storage: o.storage,
				basePath: p,
			}),
			(r[11] = t.initialFiles),
			(r[12] = o.storage),
			(r[13] = p),
			(r[14] = A))
		: (A = r[14]);
	const [T, I, F] = IRe(A);
	let N;
	r[15] !== I || r[16] !== D || r[17] !== t.basePath || r[18] !== i
		? ((N = async () => {
				(await I()) &&
					D(`${t.basePath}/collection/${encodeURIComponent(i)}`);
			}),
			(r[15] = I),
			(r[16] = D),
			(r[17] = t.basePath),
			(r[18] = i),
			(r[19] = N))
		: (N = r[19]);
	const O = Ri(N);
	let _;
	r[20] !== D || r[21] !== t.basePath || r[22] !== i || r[23] !== s
		? ((_ = () => {
				D(
					`${t.basePath}/collection/${encodeURIComponent(i)}/create?duplicate=${s}`,
				);
			}),
			(r[20] = D),
			(r[21] = t.basePath),
			(r[22] = i),
			(r[23] = s),
			(r[24] = _))
		: (_ = r[24]);
	const j = _,
		V = a.kind === "loading" || !t.hasChanged;
	let K;
	r[25] !== V ||
	r[26] !== c ||
	r[27] !== t.state ||
	r[28] !== t.basePath ||
	r[29] !== $ ||
	r[30] !== u ||
	r[31] !== l ||
	r[32] !== s ||
	r[33] !== S ||
	r[34] !== i
		? ((K = async () => {
				if (V) return !1;
				if (!_s(c, t.state, $)) return C(!0), !1;
				const _e = tr(u, t.state),
					We = await l();
				return (
					We &&
						_e !== s &&
						S(
							`${t.basePath}/collection/${encodeURIComponent(i)}/item/${encodeURIComponent(_e)}`,
						),
					We
				);
			}),
			(r[25] = V),
			(r[26] = c),
			(r[27] = t.state),
			(r[28] = t.basePath),
			(r[29] = $),
			(r[30] = u),
			(r[31] = l),
			(r[32] = s),
			(r[33] = S),
			(r[34] = i),
			(r[35] = K))
		: (K = r[35]);
	const M = Ri(K);
	let G;
	r[36] !== t.state || r[37] !== v || r[38] !== u
		? ((G = () => {
				VA(t.state, v, u.schema, {
					field: u.slugField,
					value: tr(u, t.state),
				});
			}),
			(r[36] = t.state),
			(r[37] = v),
			(r[38] = u),
			(r[39] = G))
		: (G = r[39]);
	const H = Ri(G);
	let P;
	r[40] !== v || r[41] !== u || r[42] !== t.state || r[43] !== t.previewProps
		? ((P = async () => {
				const _e = await LA(v, u.schema, {
					field: u.slugField,
					slug: tr(u, t.state),
				});
				_e &&
					(jd(_e, t.previewProps),
					il.positive("Entry pasted", {
						shouldCloseOnAction: !0,
						actionLabel: "Undo",
						onAction: () => {
							jd(t.state, t.previewProps);
						},
					}));
			}),
			(r[40] = v),
			(r[41] = u),
			(r[42] = t.state),
			(r[43] = t.previewProps),
			(r[44] = P))
		: (P = r[44]);
	const q = Ri(P),
		J =
			o.storage.kind !== "local" && y
				? `${Cg(y)}${v.dataLocation === "index" ? `/tree/${b}/${(e = Ju(o.storage)) !== null && e !== void 0 ? e : ""}${p}` : `/blob/${b}/${(n = Ju(o.storage)) !== null && n !== void 0 ? n : ""}${p}${N0(v)}`}`
				: void 0;
	let Z, oe;
	r[45] !== a.kind || r[46] !== M
		? ((Z = () => {
				const _e = (We) => {
					a.kind !== "loading" &&
						jf("mod+s", We) &&
						(We.preventDefault(), M());
				};
				return (
					document.addEventListener("keydown", _e),
					() => document.removeEventListener("keydown", _e)
				);
			}),
			(oe = [a.kind, M]),
			(r[45] = a.kind),
			(r[46] = M),
			(r[47] = Z),
			(r[48] = oe))
		: ((Z = r[47]), (oe = r[48])),
		E.useEffect(Z, oe);
	const ne = a.kind === "loading";
	let de;
	r[49] !== ne ||
	r[50] !== t.hasChanged ||
	r[51] !== t.onReset ||
	r[52] !== O ||
	r[53] !== j ||
	r[54] !== H ||
	r[55] !== q ||
	r[56] !== J ||
	r[57] !== w
		? ((de = m.jsx(HRe, {
				formID: "item-edit-form",
				isLoading: ne,
				hasChanged: t.hasChanged,
				onDelete: O,
				onDuplicate: j,
				onCopy: H,
				onPaste: q,
				onReset: t.onReset,
				viewHref: J,
				previewHref: w,
			})),
			(r[49] = ne),
			(r[50] = t.hasChanged),
			(r[51] = t.onReset),
			(r[52] = O),
			(r[53] = j),
			(r[54] = H),
			(r[55] = q),
			(r[56] = J),
			(r[57] = w),
			(r[58] = de))
		: (de = r[58]);
	let se;
	r[59] !== a
		? ((se =
				a.kind === "error" &&
				m.jsx(fo, { tone: "critical", children: a.error.message })),
			(r[59] = a),
			(r[60] = se))
		: (se = r[60]);
	let re;
	r[61] !== T
		? ((re =
				T.kind === "error" &&
				m.jsx(fo, { tone: "critical", children: T.error.message })),
			(r[61] = T),
			(r[62] = re))
		: (re = r[62]);
	let he;
	r[63] !== M
		? ((he = (_e) => {
				_e.target === _e.currentTarget && (_e.preventDefault(), M());
			}),
			(r[63] = M),
			(r[64] = he))
		: (he = r[64]);
	const ye = t.previewProps;
	let Ae;
	r[65] !== ye ||
	r[66] !== x ||
	r[67] !== u.entryLayout ||
	r[68] !== v ||
	r[69] !== $
		? ((Ae = m.jsx(dA, {
				previewProps: ye,
				forceValidation: x,
				entryLayout: u.entryLayout,
				formatInfo: v,
				slugField: $,
			})),
			(r[65] = ye),
			(r[66] = x),
			(r[67] = u.entryLayout),
			(r[68] = v),
			(r[69] = $),
			(r[70] = Ae))
		: (Ae = r[70]);
	let Pe;
	r[71] !== he || r[72] !== Ae
		? ((Pe = m.jsx(pr, {
				id: "item-edit-form",
				height: "100%",
				minHeight: 0,
				minWidth: 0,
				elementType: "form",
				onSubmit: he,
				children: Ae,
			})),
			(r[71] = he),
			(r[72] = Ae),
			(r[73] = Pe))
		: (Pe = r[73]);
	let we;
	r[74] !== a ||
	r[75] !== i ||
	r[76] !== d ||
	r[77] !== s ||
	r[78] !== u ||
	r[79] !== t ||
	r[80] !== l ||
	r[81] !== f
		? ((we =
				a.kind === "needs-new-branch" &&
				m.jsx(KA, {
					branchOid: f,
					onCreate: async (_e) => {
						const We = `/keystatic/branch/${encodeURIComponent(_e)}/collection/${encodeURIComponent(i)}/item/`;
						d.push(We + encodeURIComponent(s));
						const Et = tr(u, t.state);
						(await l({ branch: _e, sha: f })) &&
							Et !== s &&
							d.replace(We + encodeURIComponent(Et));
					},
					reason: a.reason,
					onDismiss: t.onResetUpdateItem,
				})),
			(r[74] = a),
			(r[75] = i),
			(r[76] = d),
			(r[77] = s),
			(r[78] = u),
			(r[79] = t),
			(r[80] = l),
			(r[81] = f),
			(r[82] = we))
		: (we = r[82]);
	let Ke;
	r[83] !== t.onResetUpdateItem || r[84] !== we
		? ((Ke = m.jsx(mn, { onDismiss: t.onResetUpdateItem, children: we })),
			(r[83] = t.onResetUpdateItem),
			(r[84] = we),
			(r[85] = Ke))
		: (Ke = r[85]);
	let rt;
	r[86] !== a.kind ||
	r[87] !== t ||
	r[88] !== u ||
	r[89] !== s ||
	r[90] !== d ||
	r[91] !== i
		? ((rt =
				a.kind === "needs-fork" &&
				va(t.config) &&
				m.jsx(rx, {
					onCreate: async () => {
						const _e = tr(u, t.state);
						(await t.onUpdate()) &&
							_e !== s &&
							d.replace(
								`${t.basePath}/collection/${encodeURIComponent(i)}/item/${encodeURIComponent(_e)}`,
							);
					},
					onDismiss: t.onResetUpdateItem,
					config: t.config,
				})),
			(r[86] = a.kind),
			(r[87] = t),
			(r[88] = u),
			(r[89] = s),
			(r[90] = d),
			(r[91] = i),
			(r[92] = rt))
		: (rt = r[92]);
	let Ce;
	r[93] !== t.onResetUpdateItem || r[94] !== rt
		? ((Ce = m.jsx(mn, { onDismiss: t.onResetUpdateItem, children: rt })),
			(r[93] = t.onResetUpdateItem),
			(r[94] = rt),
			(r[95] = Ce))
		: (Ce = r[95]);
	let Me;
	r[96] !== T.kind ||
	r[97] !== t ||
	r[98] !== I ||
	r[99] !== d ||
	r[100] !== i ||
	r[101] !== F
		? ((Me =
				T.kind === "needs-fork" &&
				va(t.config) &&
				m.jsx(rx, {
					onCreate: async () => {
						await I(),
							d.push(
								`${t.basePath}/collection/${encodeURIComponent(i)}`,
							);
					},
					onDismiss: F,
					config: t.config,
				})),
			(r[96] = T.kind),
			(r[97] = t),
			(r[98] = I),
			(r[99] = d),
			(r[100] = i),
			(r[101] = F),
			(r[102] = Me))
		: (Me = r[102]);
	let me;
	r[103] !== F || r[104] !== Me
		? ((me = m.jsx(mn, { onDismiss: F, children: Me })),
			(r[103] = F),
			(r[104] = Me),
			(r[105] = me))
		: (me = r[105]);
	let De;
	return (
		r[106] !== de ||
		r[107] !== t ||
		r[108] !== se ||
		r[109] !== re ||
		r[110] !== Pe ||
		r[111] !== Ke ||
		r[112] !== Ce ||
		r[113] !== me
			? ((De = m.jsx(m.Fragment, {
					children: m.jsxs(Zb, {
						headerActions: de,
						...t,
						children: [se, re, Pe, Ke, Ce, me],
					}),
				})),
				(r[106] = de),
				(r[107] = t),
				(r[108] = se),
				(r[109] = re),
				(r[110] = Pe),
				(r[111] = Ke),
				(r[112] = Ce),
				(r[113] = me),
				(r[114] = De))
			: (De = r[114]),
		De
	);
}
function KRe(t) {
	var e;
	const n = ee(64),
		{
			collection: r,
			config: i,
			initialFiles: o,
			initialState: s,
			localTreeKey: a,
			draft: l,
		} = t,
		{ collectionConfig: u, schema: c } = wp(r),
		d = (e = l == null ? void 0 : l.state) !== null && e !== void 0 ? e : s;
	let f;
	n[0] !== d || n[1] !== a
		? ((f = { state: d, localTreeKey: a }),
			(n[0] = d),
			(n[1] = a),
			(n[2] = f))
		: (f = n[2]);
	const [h, p] = E.useState(f),
		{ state: g, localTreeKey: v } = h;
	d5(l, g, a), v !== a && p({ state: s, localTreeKey: a });
	let b;
	n[3] === Symbol.for("react.memo_cache_sentinel")
		? ((b = (G) => {
				p((H) => ({ localTreeKey: H.localTreeKey, state: G(H.state) }));
			}),
			(n[3] = b))
		: (b = n[3]);
	const x = jA(c, b, g);
	let C;
	n[4] !== s || n[5] !== c || n[6] !== g || n[7] !== u.slugField
		? ((C = {
				initialState: s,
				schema: c,
				state: g,
				slugField: u.slugField,
			}),
			(n[4] = s),
			(n[5] = c),
			(n[6] = g),
			(n[7] = u.slugField),
			(n[8] = C))
		: (C = n[8]);
	const k = i1(C);
	let w, D, S;
	if (n[9] !== u || n[10] !== g || n[11] !== i || n[12] !== r) {
		D = tr(u, g);
		let G;
		n[16] !== i || n[17] !== r
			? ((G = qo(i, r)), (n[16] = i), (n[17] = r), (n[18] = G))
			: (G = n[18]),
			(S = G),
			(w = Ni(i, r, D)),
			(n[9] = u),
			(n[10] = g),
			(n[11] = i),
			(n[12] = r),
			(n[13] = w),
			(n[14] = D),
			(n[15] = S);
	} else (w = n[13]), (D = n[14]), (S = n[15]);
	const $ = w;
	let A;
	n[19] !== u.slugField || n[20] !== D
		? ((A = { field: u.slugField, value: D }),
			(n[19] = u.slugField),
			(n[20] = D),
			(n[21] = A))
		: (A = n[21]);
	let T;
	n[22] !== g ||
	n[23] !== o ||
	n[24] !== i ||
	n[25] !== u.schema ||
	n[26] !== $ ||
	n[27] !== S ||
	n[28] !== a ||
	n[29] !== A
		? ((T = {
				state: g,
				initialFiles: o,
				config: i,
				schema: u.schema,
				basePath: $,
				format: S,
				currentLocalTreeKey: a,
				slug: A,
			}),
			(n[22] = g),
			(n[23] = o),
			(n[24] = i),
			(n[25] = u.schema),
			(n[26] = $),
			(n[27] = S),
			(n[28] = a),
			(n[29] = A),
			(n[30] = T))
		: (T = n[30]);
	const [I, F, N] = Cp(T);
	let O;
	n[31] !== r ||
	n[32] !== t.itemSlug ||
	n[33] !== k ||
	n[34] !== $ ||
	n[35] !== i ||
	n[36] !== u.schema ||
	n[37] !== u.slugField ||
	n[38] !== D ||
	n[39] !== g ||
	n[40] !== a
		? ((O = () => {
				const G = ["collection", r, t.itemSlug];
				if (k) {
					const H = r1({
							basePath: $,
							format: qo(i, r),
							schema: u.schema,
							slug: { field: u.slugField, value: D },
							state: g,
						}),
						P = new Map(H.map((J) => [J.path, J.contents]));
					a5(G, {
						beforeTreeKey: a,
						slug: D,
						files: P,
						savedAt: new Date(),
						version: 1,
					});
				} else l5(G);
			}),
			(n[31] = r),
			(n[32] = t.itemSlug),
			(n[33] = k),
			(n[34] = $),
			(n[35] = i),
			(n[36] = u.schema),
			(n[37] = u.slugField),
			(n[38] = D),
			(n[39] = g),
			(n[40] = a),
			(n[41] = O))
		: (O = n[41]);
	let _;
	n[42] !== r ||
	n[43] !== u ||
	n[44] !== i ||
	n[45] !== $ ||
	n[46] !== a ||
	n[47] !== t.itemSlug ||
	n[48] !== D ||
	n[49] !== g ||
	n[50] !== k
		? ((_ = [r, u, i, $, a, t.itemSlug, D, g, k]),
			(n[42] = r),
			(n[43] = u),
			(n[44] = i),
			(n[45] = $),
			(n[46] = a),
			(n[47] = t.itemSlug),
			(n[48] = D),
			(n[49] = g),
			(n[50] = k),
			(n[51] = _))
		: (_ = n[51]),
		E.useEffect(O, _);
	const j = Ri(F);
	let V;
	n[52] !== s || n[53] !== a
		? ((V = () => {
				p({ state: s, localTreeKey: a });
			}),
			(n[52] = s),
			(n[53] = a),
			(n[54] = V))
		: (V = n[54]);
	const K = V;
	let M;
	return (
		n[55] !== t ||
		n[56] !== j ||
		n[57] !== K ||
		n[58] !== I ||
		n[59] !== N ||
		n[60] !== x ||
		n[61] !== g ||
		n[62] !== k
			? ((M = m.jsx(tQ, {
					...t,
					onUpdate: j,
					onReset: K,
					updateResult: I,
					onResetUpdateItem: N,
					previewProps: x,
					state: g,
					hasChanged: k,
				})),
				(n[55] = t),
				(n[56] = j),
				(n[57] = K),
				(n[58] = I),
				(n[59] = N),
				(n[60] = x),
				(n[61] = g),
				(n[62] = k),
				(n[63] = M))
			: (M = n[63]),
		M
	);
}
function URe(t) {
	const e = ee(33),
		{
			collection: n,
			config: r,
			initialFiles: i,
			initialState: o,
			localTreeKey: s,
		} = t,
		{ collectionConfig: a, schema: l } = wp(n),
		u = MA(l, t.map),
		c = _A(l, t.map, u),
		d = tr(a, u);
	let f;
	e[0] !== t.config || e[1] !== t.collection
		? ((f = qo(t.config, t.collection)),
			(e[0] = t.config),
			(e[1] = t.collection),
			(e[2] = f))
		: (f = e[2]);
	const h = f;
	let p;
	e[3] !== o || e[4] !== l || e[5] !== u || e[6] !== a.slugField
		? ((p = {
				initialState: o,
				schema: l,
				state: u,
				slugField: a.slugField,
			}),
			(e[3] = o),
			(e[4] = l),
			(e[5] = u),
			(e[6] = a.slugField),
			(e[7] = p))
		: (p = e[7]);
	const g = i1(p),
		v = Ni(r, n, d);
	let b;
	e[8] !== a.slugField || e[9] !== d
		? ((b = { field: a.slugField, value: d }),
			(e[8] = a.slugField),
			(e[9] = d),
			(e[10] = b))
		: (b = e[10]);
	let y;
	e[11] !== u ||
	e[12] !== i ||
	e[13] !== r ||
	e[14] !== a.schema ||
	e[15] !== v ||
	e[16] !== h ||
	e[17] !== s ||
	e[18] !== b
		? ((y = {
				state: u,
				initialFiles: i,
				config: r,
				schema: a.schema,
				basePath: v,
				format: h,
				currentLocalTreeKey: s,
				slug: b,
			}),
			(e[11] = u),
			(e[12] = i),
			(e[13] = r),
			(e[14] = a.schema),
			(e[15] = v),
			(e[16] = h),
			(e[17] = s),
			(e[18] = b),
			(e[19] = y))
		: (y = e[19]);
	const [x, C, k] = Cp(y),
		w = Ri(C);
	let D;
	e[20] !== t.map || e[21] !== t.initialState || e[22] !== a.schema
		? ((D = () => {
				var A;
				(A = t.map.doc) === null ||
					A === void 0 ||
					A.transact(() => {
						for (const [T, I] of Object.entries(a.schema)) {
							const F = hl(I, t.initialState[T]);
							t.map.set(T, F);
						}
					});
			}),
			(e[20] = t.map),
			(e[21] = t.initialState),
			(e[22] = a.schema),
			(e[23] = D))
		: (D = e[23]);
	const S = D;
	let $;
	return (
		e[24] !== t ||
		e[25] !== w ||
		e[26] !== S ||
		e[27] !== x ||
		e[28] !== k ||
		e[29] !== c ||
		e[30] !== u ||
		e[31] !== g
			? (($ = m.jsx(tQ, {
					...t,
					onUpdate: w,
					onReset: S,
					updateResult: x,
					onResetUpdateItem: k,
					previewProps: c,
					state: u,
					hasChanged: g,
				})),
				(e[24] = t),
				(e[25] = w),
				(e[26] = S),
				(e[27] = x),
				(e[28] = k),
				(e[29] = c),
				(e[30] = u),
				(e[31] = g),
				(e[32] = $))
			: ($ = e[32]),
		$
	);
}
function HRe(t) {
	const e = ee(55),
		{
			formID: n,
			hasChanged: r,
			isLoading: i,
			onDelete: o,
			onDuplicate: s,
			onReset: a,
			onCopy: l,
			onPaste: u,
			previewHref: c,
			viewHref: d,
		} = t,
		f = $l(en.below.desktop),
		h = Le(Ht),
		[p, g] = E.useState(!1),
		[v, b] = E.useState(!1);
	let y, x;
	e[0] === Symbol.for("react.memo_cache_sentinel")
		? ((x = { key: "reset", label: "Reset changes", icon: $A }), (e[0] = x))
		: (x = e[0]);
	let C;
	e[1] === Symbol.for("react.memo_cache_sentinel")
		? ((C = { key: "delete", label: "Delete entry…", icon: Wr }),
			(e[1] = C))
		: (C = e[1]);
	let k;
	e[2] === Symbol.for("react.memo_cache_sentinel")
		? ((k = { key: "copy", label: "Copy entry", icon: TA }), (e[2] = k))
		: (k = e[2]);
	let w;
	e[3] === Symbol.for("react.memo_cache_sentinel")
		? ((w = { key: "paste", label: "Paste entry", icon: BA }), (e[3] = w))
		: (w = e[3]);
	let D;
	e[4] === Symbol.for("react.memo_cache_sentinel")
		? ((D = { key: "duplicate", label: "Duplicate entry…", icon: INe }),
			(e[4] = D))
		: (D = e[4]);
	let S;
	if (e[5] !== c || e[6] !== d) {
		if (((S = [x, C, k, w, D]), c)) {
			let ne;
			e[8] !== c
				? ((ne = {
						key: "preview",
						label: "Preview",
						icon: S3,
						href: c,
						target: "_blank",
						rel: "noopener noreferrer",
					}),
					(e[8] = c),
					(e[9] = ne))
				: (ne = e[9]),
				S.push(ne);
		}
		if (d) {
			let ne;
			e[10] !== d
				? ((ne = {
						key: "view",
						label: "View on GitHub",
						icon: Ex,
						href: d,
						target: "_blank",
						rel: "noopener noreferrer",
					}),
					(e[10] = d),
					(e[11] = ne))
				: (ne = e[11]),
				S.push(ne);
		}
		(e[5] = c), (e[6] = d), (e[7] = S);
	} else S = e[7];
	y = S;
	const $ = y;
	let A;
	e: {
		if (i) {
			let ne;
			e[12] === Symbol.for("react.memo_cache_sentinel")
				? ((ne = m.jsx(Cr, {
						"aria-label": "Saving changes",
						isIndeterminate: !0,
						size: "small",
						alignSelf: "center",
					})),
					(e[12] = ne))
				: (ne = e[12]),
				(A = ne);
			break e;
		}
		if (r) {
			let ne;
			e[13] !== f
				? ((ne = f
						? m.jsx(pr, {
								backgroundColor: "pendingEmphasis",
								height: "scale.75",
								width: "scale.75",
								borderRadius: "full",
								children: m.jsx(ue, {
									visuallyHidden: !0,
									children: "Unsaved",
								}),
							})
						: m.jsx($g, { tone: "pending", children: "Unsaved" })),
					(e[13] = f),
					(e[14] = ne))
				: (ne = e[14]),
				(A = ne);
			break e;
		}
		A = null;
	}
	const T = A;
	let I;
	e[15] === Symbol.for("react.memo_cache_sentinel")
		? ((I = { mobile: "small", tablet: "regular" }), (e[15] = I))
		: (I = e[15]);
	let F;
	e[16] === Symbol.for("react.memo_cache_sentinel")
		? ((F = m.jsx(OA, {})), (e[16] = F))
		: (F = e[16]);
	const N = f ? "element.regular" : void 0;
	let O;
	e[17] !== r
		? ((O = r ? [] : ["reset"]), (e[17] = r), (e[18] = O))
		: (O = e[18]);
	let _;
	e[19] !== a || e[20] !== l || e[21] !== u || e[22] !== r || e[23] !== s
		? ((_ = (ne) => {
				e: switch (ne) {
					case "reset": {
						a();
						break e;
					}
					case "delete": {
						g(!0);
						break e;
					}
					case "copy": {
						l();
						break e;
					}
					case "paste": {
						u();
						break e;
					}
					case "duplicate":
						r ? b(!0) : s();
				}
			}),
			(e[19] = a),
			(e[20] = l),
			(e[21] = u),
			(e[22] = r),
			(e[23] = s),
			(e[24] = _))
		: (_ = e[24]);
	let j;
	e[25] === Symbol.for("react.memo_cache_sentinel")
		? ((j = (ne) =>
				m.jsxs(
					Mt,
					{
						textValue: ne.label,
						href: ne.href,
						target: ne.target,
						rel: ne.rel,
						children: [
							m.jsx(ve, { src: ne.icon }),
							m.jsx(ue, { children: ne.label }),
						],
					},
					ne.key,
				)),
			(e[25] = j))
		: (j = e[25]);
	let V;
	e[26] !== N || e[27] !== $ || e[28] !== O || e[29] !== _
		? ((V = m.jsx(nf, {
				buttonLabelBehavior: "hide",
				overflowMode: "collapse",
				prominence: "low",
				density: "compact",
				maxWidth: N,
				items: $,
				disabledKeys: O,
				onAction: _,
				children: j,
			})),
			(e[26] = N),
			(e[27] = $),
			(e[28] = O),
			(e[29] = _),
			(e[30] = V))
		: (V = e[30]);
	let K;
	e[31] !== h
		? ((K = h.format("save")), (e[31] = h), (e[32] = K))
		: (K = e[32]);
	let M;
	e[33] !== n || e[34] !== i || e[35] !== K
		? ((M = m.jsx(vt, {
				form: n,
				isDisabled: i,
				prominence: "high",
				type: "submit",
				children: K,
			})),
			(e[33] = n),
			(e[34] = i),
			(e[35] = K),
			(e[36] = M))
		: (M = e[36]);
	let G;
	e[37] === Symbol.for("react.memo_cache_sentinel")
		? ((G = () => g(!1)), (e[37] = G))
		: (G = e[37]);
	let H;
	e[38] !== p || e[39] !== o
		? ((H =
				p &&
				m.jsx(Fw, {
					title: "Delete entry",
					tone: "critical",
					cancelLabel: "Cancel",
					primaryActionLabel: "Yes, delete",
					autoFocusButton: "cancel",
					onPrimaryAction: o,
					children: "Are you sure? This action cannot be undone.",
				})),
			(e[38] = p),
			(e[39] = o),
			(e[40] = H))
		: (H = e[40]);
	let P;
	e[41] !== H
		? ((P = m.jsx(mn, { onDismiss: G, children: H })),
			(e[41] = H),
			(e[42] = P))
		: (P = e[42]);
	let q;
	e[43] === Symbol.for("react.memo_cache_sentinel")
		? ((q = () => b(!1)), (e[43] = q))
		: (q = e[43]);
	let J;
	e[44] !== v || e[45] !== s
		? ((J =
				v &&
				m.jsx(Fw, {
					title: "Save and duplicate entry",
					tone: "neutral",
					cancelLabel: "Cancel",
					primaryActionLabel: "Save and duplicate",
					autoFocusButton: "primary",
					onPrimaryAction: s,
					children:
						"You have unsaved changes. Save this entry to duplicate it.",
				})),
			(e[44] = v),
			(e[45] = s),
			(e[46] = J))
		: (J = e[46]);
	let Z;
	e[47] !== J
		? ((Z = m.jsx(mn, { onDismiss: q, children: J })),
			(e[47] = J),
			(e[48] = Z))
		: (Z = e[48]);
	let oe;
	return (
		e[49] !== T || e[50] !== V || e[51] !== M || e[52] !== P || e[53] !== Z
			? ((oe = m.jsxs(ke, {
					alignItems: "center",
					gap: I,
					children: [F, T, V, M, P, Z],
				})),
				(e[49] = T),
				(e[50] = V),
				(e[51] = M),
				(e[52] = P),
				(e[53] = Z),
				(e[54] = oe))
			: (oe = e[54]),
		oe
	);
}
function KA(t) {
	var e;
	const n = ee(41),
		r = Le(Ht),
		i = Qo(),
		[o, s] = E.useState(""),
		[a, l] = UY(),
		{ error: u, fetching: c, data: d } = a,
		f =
			c ||
			!!(
				d != null &&
				(e = d.createRef) !== null &&
				e !== void 0 &&
				e.__typename
			),
		h = Jn();
	let p;
	n[0] !== h ? ((p = c5(h)), (n[0] = h), (n[1] = p)) : (p = n[1]);
	const g = p;
	let v;
	n[2] !== g
		? ((v = g
				? {
						UNSAFE_className: X({
							"& input": {
								paddingInlineStart: B.size.space.xsmall,
							},
						}),
						startElement: m.jsx(ke, {
							alignItems: "center",
							paddingStart: "regular",
							justifyContent: "center",
							pointerEvents: "none",
							children: m.jsx(ue, {
								color: "neutralSecondary",
								children: g,
							}),
						}),
					}
				: {}),
			(n[2] = g),
			(n[3] = v))
		: (v = n[3]);
	const b = v;
	let y;
	n[4] === Symbol.for("react.memo_cache_sentinel")
		? ((y = { display: "contents" }), (n[4] = y))
		: (y = n[4]);
	let x;
	n[5] !== g || n[6] !== o || n[7] !== l || n[8] !== t || n[9] !== i
		? ((x = async (N) => {
				var O;
				if (N.target !== N.currentTarget) return;
				N.preventDefault();
				const _ = (g ?? "") + o,
					j = `refs/heads/${_}`;
				(O = (
					await l({
						input: {
							name: j,
							oid: t.branchOid,
							repositoryId: i.id,
						},
					})
				).data) !== null &&
					O !== void 0 &&
					(O = O.createRef) !== null &&
					O !== void 0 &&
					O.__typename &&
					t.onCreate(_);
			}),
			(n[5] = g),
			(n[6] = o),
			(n[7] = l),
			(n[8] = t),
			(n[9] = i),
			(n[10] = x))
		: (x = n[10]);
	let C;
	n[11] !== r
		? ((C = r.format("newBranch")), (n[11] = r), (n[12] = C))
		: (C = n[12]);
	let k;
	n[13] !== C
		? ((k = m.jsx(Ut, { children: C })), (n[13] = C), (n[14] = k))
		: (k = n[14]);
	let w;
	n[15] !== u ? ((w = yE(u)), (n[15] = u), (n[16] = w)) : (w = n[16]);
	let D;
	n[17] !== o || n[18] !== t.reason || n[19] !== w || n[20] !== b
		? ((D = m.jsx(Pr, {
				children: m.jsx(ke, {
					gap: "large",
					direction: "column",
					children: m.jsx(An, {
						value: o,
						onChange: s,
						label: "Branch name",
						description: t.reason,
						autoFocus: !0,
						errorMessage: w,
						...b,
					}),
				}),
			})),
			(n[17] = o),
			(n[18] = t.reason),
			(n[19] = w),
			(n[20] = b),
			(n[21] = D))
		: (D = n[21]);
	let S;
	n[22] !== f
		? ((S =
				f &&
				m.jsx(Cr, {
					isIndeterminate: !0,
					size: "small",
					"aria-label": "Creating Branch",
				})),
			(n[22] = f),
			(n[23] = S))
		: (S = n[23]);
	let $;
	n[24] !== r
		? (($ = r.format("cancel")), (n[24] = r), (n[25] = $))
		: ($ = n[25]);
	let A;
	n[26] !== f || n[27] !== t.onDismiss || n[28] !== $
		? ((A = m.jsx(vt, {
				isDisabled: f,
				onPress: t.onDismiss,
				children: $,
			})),
			(n[26] = f),
			(n[27] = t.onDismiss),
			(n[28] = $),
			(n[29] = A))
		: (A = n[29]);
	let T;
	n[30] !== f
		? ((T = m.jsx(vt, {
				isDisabled: f,
				prominence: "high",
				type: "submit",
				children: "Create branch and save",
			})),
			(n[30] = f),
			(n[31] = T))
		: (T = n[31]);
	let I;
	n[32] !== S || n[33] !== A || n[34] !== T
		? ((I = m.jsxs(Nr, { children: [S, A, T] })),
			(n[32] = S),
			(n[33] = A),
			(n[34] = T),
			(n[35] = I))
		: (I = n[35]);
	let F;
	return (
		n[36] !== x || n[37] !== k || n[38] !== D || n[39] !== I
			? ((F = m.jsx(vr, {
					children: m.jsxs("form", {
						style: y,
						onSubmit: x,
						children: [k, D, I],
					}),
				})),
				(n[36] = x),
				(n[37] = k),
				(n[38] = D),
				(n[39] = I),
				(n[40] = F))
			: (F = n[40]),
		F
	);
}
function WRe(t) {
	var e;
	const n =
		(e = t.config.collections) === null || e === void 0
			? void 0
			: e[t.collection];
	n || kp();
	const r = E.useMemo(
			() => qo(t.config, t.collection),
			[t.config, t.collection],
		),
		i = E.useMemo(
			() => ({ slug: t.itemSlug, field: n.slugField }),
			[n.slugField, t.itemSlug],
		),
		o = bo(
			E.useCallback(async () => {
				try {
					const h = await u5([
						"collection",
						t.collection,
						t.itemSlug,
					]);
					if (!h) throw new Error("No draft found");
					const p = VRe.create(h);
					return {
						state: zd(
							{
								dirpath: Ni(t.config, t.collection, p.slug),
								format: qo(t.config, t.collection),
								schema: n.schema,
								slug: { field: n.slugField, slug: p.slug },
							},
							p.files,
						).initialState,
						savedAt: p.savedAt,
						treeKey: p.beforeTreeKey,
					};
				} catch {}
			}, [n, t.collection, t.config, t.itemSlug]),
		),
		s = RA({
			config: t.config,
			dirpath: Ni(t.config, t.collection, t.itemSlug),
			schema: n.schema,
			format: r,
			slug: i,
		}),
		l = `${Xr()}/${t.collection}/item/${t.itemSlug}`,
		u = x3(),
		c = s.kind !== "loaded",
		d = !c && s.data === "not-found",
		f = bo(
			E.useCallback(() => {
				if (u) {
					if (u === "loading" || c) return zo;
					if (!d)
						return (async () => {
							await u.doc.whenSynced;
							let h = u.data.get(l);
							if (h instanceof Ki) {
								const g = h.whenLoaded;
								h.load(), await g;
							} else (h = new Ki()), u.data.set(l, h);
							return h.getMap("data");
						})();
				}
			}, [c, d, l, u]),
		);
	return m.jsx(WZ, {
		fallback: m.jsx(Zb, {
			...t,
			children: m.jsx(la, {
				children: m.jsx(fo, {
					tone: "caution",
					children: "Entry not found.",
				}),
			}),
		}),
		children: m.jsx(ORe, {
			fallback: (h) =>
				m.jsx(Zb, {
					...t,
					children: m.jsx(la, {
						children: m.jsx(fo, { tone: "critical", children: h }),
					}),
				}),
			children: m.jsx(E.Suspense, {
				fallback: m.jsx(Zb, {
					...t,
					children: m.jsx(ke, {
						alignItems: "center",
						justifyContent: "center",
						minHeight: "scale.3000",
						children: m.jsx(Cr, {
							"aria-label": "Loading Item",
							isIndeterminate: !0,
							size: "large",
						}),
					}),
				}),
				children: m.jsx(qRe, {
					mapData: f,
					draftData: o,
					itemData: s,
					...t,
				}),
			}),
		}),
	});
}
function qRe(t) {
	const e = zU(t.config, t.collection),
		n = E.useDeferredValue(t.draftData),
		r = Hk(t.itemData);
	r === "not-found" && kp();
	const i = Hk(t.mapData);
	E.useMemo(() => {
		var s;
		if (!i || i.size) return;
		const { initialState: a } = r;
		(s = i.doc) === null ||
			s === void 0 ||
			s.transact(() => {
				for (const [l, u] of Object.entries(e.schema)) {
					const c = hl(u, a[l]);
					i.set(l, c);
				}
			});
	}, [e.schema, r, i]);
	const o = Hk(n);
	return i
		? m.jsx(URe, {
				collection: t.collection,
				basePath: t.basePath,
				config: t.config,
				itemSlug: t.itemSlug,
				initialState: r.initialState,
				initialFiles: r.initialFiles,
				localTreeKey: r.localTreeKey,
				map: i,
			})
		: m.jsx(KRe, {
				collection: t.collection,
				basePath: t.basePath,
				config: t.config,
				itemSlug: t.itemSlug,
				initialState: r.initialState,
				initialFiles: r.initialFiles,
				draft: o,
				localTreeKey: r.localTreeKey,
			});
}
function Zb(t) {
	const e = ee(17);
	let n, r, i;
	if (
		e[0] !== t.config ||
		e[1] !== t.collection ||
		e[2] !== t.basePath ||
		e[3] !== t.itemSlug
	) {
		const l = zU(t.config, t.collection),
			u = `${t.basePath}/collection/${t.collection}`;
		(n = [
			{ key: "collection", label: l.label, href: u },
			{ key: "item", label: t.itemSlug },
		]),
			(r = cl),
			(i = cA(l)),
			(e[0] = t.config),
			(e[1] = t.collection),
			(e[2] = t.basePath),
			(e[3] = t.itemSlug),
			(e[4] = n),
			(e[5] = r),
			(e[6] = i);
	} else (n = e[4]), (r = e[5]), (i = e[6]);
	let o;
	e[7] !== n
		? ((o = m.jsx(JZ, { items: n })), (e[7] = n), (e[8] = o))
		: (o = e[8]);
	let s;
	e[9] !== o || e[10] !== t.headerActions
		? ((s = m.jsxs(yp, { children: [o, t.headerActions] })),
			(e[9] = o),
			(e[10] = t.headerActions),
			(e[11] = s))
		: (s = e[11]);
	let a;
	return (
		e[12] !== r || e[13] !== i || e[14] !== s || e[15] !== t.children
			? ((a = m.jsxs(r, {
					containerWidth: i,
					children: [s, t.children],
				})),
				(e[12] = r),
				(e[13] = i),
				(e[14] = s),
				(e[15] = t.children),
				(e[16] = a))
			: (a = e[16]),
		a
	);
}
function GRe(t, e) {
	return E.useMemo(() => {
		if (t) {
			const { slugField: n } = e,
				r = t[e.slugField],
				i = e.schema[e.slugField];
			if (i.kind === "form" && i.formKind === "slug")
				try {
					const o = i.serializeWithSlug(r),
						s = i.parse(o.value, {
							slug: o.slug ? `${o.slug}-copy` : "",
						});
					return { ...t, [n]: s };
				} catch {}
			return { ...t, [n]: r };
		}
	}, [e, t]);
}
function YRe(t) {
	var e;
	const n = ee(53),
		r = En();
	let i, o;
	n[0] !== r.href
		? ((o = new URL(r.href, "http://localhost").searchParams.get(
				"duplicate",
			)),
			(n[0] = r.href),
			(n[1] = o))
		: (o = n[1]),
		(i = o);
	const s = i,
		a =
			(e = t.config.collections) === null || e === void 0
				? void 0
				: e[t.collection];
	a || kp();
	let l, u;
	n[2] !== t.config || n[3] !== t.collection
		? ((u = qo(t.config, t.collection)),
			(n[2] = t.config),
			(n[3] = t.collection),
			(n[4] = u))
		: (u = n[4]),
		(l = u);
	const c = l;
	let d;
	n[5] !== t.collection ||
	n[6] !== t.config ||
	n[7] !== s ||
	n[8] !== c ||
	n[9] !== a.schema ||
	n[10] !== a.slugField
		? ((d = async () => {
				const T = await u5([
					"collection-create",
					t.collection,
					...(s ? [s] : []),
				]);
				if (!T) throw new Error("No draft found");
				const I = JRe.create(T);
				return {
					state: zd(
						{
							dirpath: Ni(t.config, t.collection, I.slug),
							format: c,
							schema: a.schema,
							slug: { field: a.slugField, slug: I.slug },
						},
						I.files,
					).initialState,
					savedAt: I.savedAt,
				};
			}),
			(n[5] = t.collection),
			(n[6] = t.config),
			(n[7] = s),
			(n[8] = c),
			(n[9] = a.schema),
			(n[10] = a.slugField),
			(n[11] = d))
		: (d = n[11]);
	const f = bo(d);
	let h;
	e: {
		if (s) {
			let T;
			n[12] !== a.slugField || n[13] !== s
				? ((T = { field: a.slugField, slug: s }),
					(n[12] = a.slugField),
					(n[13] = s),
					(n[14] = T))
				: (T = n[14]),
				(h = T);
			break e;
		}
		if (a.template) {
			let T;
			n[15] !== a.slugField
				? ((T = { field: a.slugField, slug: "" }),
					(n[15] = a.slugField),
					(n[16] = T))
				: (T = n[16]),
				(h = T);
			break e;
		}
		h = void 0;
	}
	const p = h,
		g = !!s || !!a.template;
	let v;
	n[17] !== a.template || n[18] !== s || n[19] !== t
		? ((v =
				a.template && !s
					? a.template
					: Ni(t.config, t.collection, s ?? "")),
			(n[17] = a.template),
			(n[18] = s),
			(n[19] = t),
			(n[20] = v))
		: (v = n[20]);
	let b;
	n[21] !== t.config ||
	n[22] !== v ||
	n[23] !== a.schema ||
	n[24] !== c ||
	n[25] !== p
		? ((b = {
				config: t.config,
				dirpath: v,
				schema: a.schema,
				format: c,
				slug: p,
			}),
			(n[21] = t.config),
			(n[22] = v),
			(n[23] = a.schema),
			(n[24] = c),
			(n[25] = p),
			(n[26] = b))
		: (b = n[26]);
	const y = RA(b),
		x =
			g && y.kind === "loaded" && y.data !== "not-found"
				? y.data.initialState
				: void 0,
		C = GRe(x, a),
		k = Xr(),
		w = x3(),
		D = `${k}/${t.collection}/create${s != null && s.length ? `?duplicate=${s}` : ""}`;
	let S;
	n[27] !== w ||
	n[28] !== g ||
	n[29] !== x ||
	n[30] !== D ||
	n[31] !== a.schema
		? ((S = async () => {
				if (!w) return;
				if (w === "loading" || (await w.doc.whenSynced, g && !x))
					return zo;
				let T = w.data.get(D);
				if (T instanceof Ki) {
					const F = T.whenLoaded;
					T.load(), await F;
				} else (T = new Ki()), w.data.set(D, T);
				const I = T.getMap("data");
				return (
					I.size ||
						T.transact(() => {
							for (const [N, O] of Object.entries(a.schema)) {
								var F;
								const _ = hl(
									O,
									(F = x == null ? void 0 : x[N]) !== null &&
										F !== void 0
										? F
										: an(O),
								);
								I.set(N, _);
							}
						}),
					I
				);
			}),
			(n[27] = w),
			(n[28] = g),
			(n[29] = x),
			(n[30] = D),
			(n[31] = a.schema),
			(n[32] = S))
		: (S = n[32]);
	const $ = bo(S);
	if (g && y.kind === "error") {
		let T;
		return (
			n[33] !== y.error.message
				? ((T = m.jsx(la, {
						children: m.jsx(fo, {
							tone: "critical",
							children: y.error.message,
						}),
					})),
					(n[33] = y.error.message),
					(n[34] = T))
				: (T = n[34]),
			T
		);
	}
	if ($.kind === "error") {
		console.log($.error);
		let T;
		return (
			n[35] !== $.error.message
				? ((T = m.jsx(la, {
						children: m.jsx(fo, {
							tone: "critical",
							children: $.error.message,
						}),
					})),
					(n[35] = $.error.message),
					(n[36] = T))
				: (T = n[36]),
			T
		);
	}
	if (
		(g && y.kind === "loading") ||
		f.kind === "loading" ||
		$.kind === "loading"
	) {
		let T;
		return (
			n[37] === Symbol.for("react.memo_cache_sentinel")
				? ((T = m.jsx(ke, {
						alignItems: "center",
						justifyContent: "center",
						minHeight: "scale.3000",
						children: m.jsx(Cr, {
							"aria-label": "Loading Item",
							isIndeterminate: !0,
							size: "large",
						}),
					})),
					(n[37] = T))
				: (T = n[37]),
			T
		);
	}
	if (g && y.kind === "loaded" && y.data === "not-found") {
		let T;
		return (
			n[38] === Symbol.for("react.memo_cache_sentinel")
				? ((T = m.jsx(la, {
						children: m.jsx(fo, {
							tone: "caution",
							children: "Entry not found.",
						}),
					})),
					(n[38] = T))
				: (T = n[38]),
			T
		);
	}
	if (!$.data) {
		const T = f.kind === "loaded" ? f.data : void 0;
		let I;
		return (
			n[39] !== t.collection ||
			n[40] !== t.config ||
			n[41] !== t.basePath ||
			n[42] !== T ||
			n[43] !== s ||
			n[44] !== C
				? ((I = m.jsx(XRe, {
						collection: t.collection,
						config: t.config,
						basePath: t.basePath,
						draft: T,
						duplicateSlug: s,
						initialState: C,
					})),
					(n[39] = t.collection),
					(n[40] = t.config),
					(n[41] = t.basePath),
					(n[42] = T),
					(n[43] = s),
					(n[44] = C),
					(n[45] = I))
				: (I = n[45]),
			I
		);
	}
	let A;
	return (
		n[46] !== t.collection ||
		n[47] !== t.config ||
		n[48] !== t.basePath ||
		n[49] !== s ||
		n[50] !== C ||
		n[51] !== $.data
			? ((A = m.jsx(ZRe, {
					collection: t.collection,
					config: t.config,
					basePath: t.basePath,
					duplicateSlug: s,
					initialState: C,
					map: $.data,
				})),
				(n[46] = t.collection),
				(n[47] = t.config),
				(n[48] = t.basePath),
				(n[49] = s),
				(n[50] = C),
				(n[51] = $.data),
				(n[52] = A))
			: (A = n[52]),
		A
	);
}
const JRe = sa({
	version: xS(1),
	savedAt: Yx(),
	slug: jt(),
	files: kS(jt(), Jx(Uint8Array)),
});
function XRe(t) {
	var e, n;
	const r = ee(61),
		{ collectionConfig: i, schema: o } = wp(t.collection);
	let s, a;
	if (r[0] !== t.initialState || r[1] !== o) {
		var l;
		(a = (l = t.initialState) !== null && l !== void 0 ? l : an(o)),
			(r[0] = t.initialState),
			(r[1] = o),
			(r[2] = a);
	} else a = r[2];
	s = a;
	const u = s,
		[c, d] = E.useState(
			(e = (n = t.draft) === null || n === void 0 ? void 0 : n.state) !==
				null && e !== void 0
				? e
				: u,
		),
		f = jA(o, d, c);
	d5(t.draft, c, void 0);
	let h, p, g;
	if (
		r[3] !== i ||
		r[4] !== c ||
		r[5] !== t.config ||
		r[6] !== t.collection
	) {
		p = tr(i, c);
		let N;
		r[10] !== t.config || r[11] !== t.collection
			? ((N = qo(t.config, t.collection)),
				(r[10] = t.config),
				(r[11] = t.collection),
				(r[12] = N))
			: (N = r[12]),
			(g = N),
			(h = Ni(t.config, t.collection, p)),
			(r[3] = i),
			(r[4] = c),
			(r[5] = t.config),
			(r[6] = t.collection),
			(r[7] = h),
			(r[8] = p),
			(r[9] = g);
	} else (h = r[7]), (p = r[8]), (g = r[9]);
	const v = h;
	let b;
	r[13] !== i.slugField || r[14] !== p
		? ((b = { field: i.slugField, value: p }),
			(r[13] = i.slugField),
			(r[14] = p),
			(r[15] = b))
		: (b = r[15]);
	let y;
	r[16] !== c ||
	r[17] !== v ||
	r[18] !== t.config ||
	r[19] !== i.schema ||
	r[20] !== g ||
	r[21] !== b
		? ((y = {
				state: c,
				basePath: v,
				initialFiles: void 0,
				config: t.config,
				schema: i.schema,
				format: g,
				currentLocalTreeKey: void 0,
				slug: b,
			}),
			(r[16] = c),
			(r[17] = v),
			(r[18] = t.config),
			(r[19] = i.schema),
			(r[20] = g),
			(r[21] = b),
			(r[22] = y))
		: (y = r[22]);
	const [x, C, k] = Cp(y),
		w = Ri(C);
	let D;
	r[23] !== u || r[24] !== o || r[25] !== c || r[26] !== i.slugField
		? ((D = {
				initialState: u,
				schema: o,
				state: c,
				slugField: i.slugField,
			}),
			(r[23] = u),
			(r[24] = o),
			(r[25] = c),
			(r[26] = i.slugField),
			(r[27] = D))
		: (D = r[27]);
	const S = i1(D),
		$ = x.kind === "updated" || x.kind === "loading";
	let A;
	r[28] !== t.collection ||
	r[29] !== t.duplicateSlug ||
	r[30] !== S ||
	r[31] !== $ ||
	r[32] !== v ||
	r[33] !== g ||
	r[34] !== i.schema ||
	r[35] !== i.slugField ||
	r[36] !== p ||
	r[37] !== c
		? ((A = () => {
				const N = [
					"collection-create",
					t.collection,
					...(t.duplicateSlug ? [t.duplicateSlug] : []),
				];
				if (S && !$) {
					const O = r1({
							basePath: v,
							format: g,
							schema: i.schema,
							slug: { field: i.slugField, value: p },
							state: c,
						}),
						_ = new Map(O.map((V) => [V.path, V.contents]));
					a5(N, {
						slug: p,
						files: _,
						savedAt: new Date(),
						version: 1,
					});
				} else l5(N);
			}),
			(r[28] = t.collection),
			(r[29] = t.duplicateSlug),
			(r[30] = S),
			(r[31] = $),
			(r[32] = v),
			(r[33] = g),
			(r[34] = i.schema),
			(r[35] = i.slugField),
			(r[36] = p),
			(r[37] = c),
			(r[38] = A))
		: (A = r[38]);
	let T;
	r[39] !== i ||
	r[40] !== p ||
	r[41] !== c ||
	r[42] !== S ||
	r[43] !== t.duplicateSlug ||
	r[44] !== t.collection ||
	r[45] !== v ||
	r[46] !== g ||
	r[47] !== $
		? ((T = [i, p, c, S, t.duplicateSlug, t.collection, v, g, $]),
			(r[39] = i),
			(r[40] = p),
			(r[41] = c),
			(r[42] = S),
			(r[43] = t.duplicateSlug),
			(r[44] = t.collection),
			(r[45] = v),
			(r[46] = g),
			(r[47] = $),
			(r[48] = T))
		: (T = r[48]),
		E.useEffect(A, T);
	let I;
	r[49] !== u
		? ((I = () => {
				d(u);
			}),
			(r[49] = u),
			(r[50] = I))
		: (I = r[50]);
	let F;
	return (
		r[51] !== t.basePath ||
		r[52] !== t.collection ||
		r[53] !== x ||
		r[54] !== w ||
		r[55] !== k ||
		r[56] !== c ||
		r[57] !== p ||
		r[58] !== f ||
		r[59] !== I
			? ((F = m.jsx(nQ, {
					basePath: t.basePath,
					collection: t.collection,
					createResult: x,
					createItem: w,
					resetCreateItemState: k,
					state: c,
					slug: p,
					previewProps: f,
					onReset: I,
				})),
				(r[51] = t.basePath),
				(r[52] = t.collection),
				(r[53] = x),
				(r[54] = w),
				(r[55] = k),
				(r[56] = c),
				(r[57] = p),
				(r[58] = f),
				(r[59] = I),
				(r[60] = F))
			: (F = r[60]),
		F
	);
}
function ZRe(t) {
	const e = ee(34),
		{ collectionConfig: n, schema: r } = wp(t.collection),
		i = MA(r, t.map),
		o = _A(r, t.map, i);
	let s, a, l;
	if (
		e[0] !== n ||
		e[1] !== i ||
		e[2] !== t.config ||
		e[3] !== t.collection
	) {
		a = tr(n, i);
		let y;
		e[7] !== t.config || e[8] !== t.collection
			? ((y = qo(t.config, t.collection)),
				(e[7] = t.config),
				(e[8] = t.collection),
				(e[9] = y))
			: (y = e[9]),
			(l = y),
			(s = Ni(t.config, t.collection, a)),
			(e[0] = n),
			(e[1] = i),
			(e[2] = t.config),
			(e[3] = t.collection),
			(e[4] = s),
			(e[5] = a),
			(e[6] = l);
	} else (s = e[4]), (a = e[5]), (l = e[6]);
	const u = s;
	let c;
	e[10] !== n.slugField || e[11] !== a
		? ((c = { field: n.slugField, value: a }),
			(e[10] = n.slugField),
			(e[11] = a),
			(e[12] = c))
		: (c = e[12]);
	let d;
	e[13] !== i ||
	e[14] !== u ||
	e[15] !== t.config ||
	e[16] !== n.schema ||
	e[17] !== l ||
	e[18] !== c
		? ((d = {
				state: i,
				basePath: u,
				initialFiles: void 0,
				config: t.config,
				schema: n.schema,
				format: l,
				currentLocalTreeKey: void 0,
				slug: c,
			}),
			(e[13] = i),
			(e[14] = u),
			(e[15] = t.config),
			(e[16] = n.schema),
			(e[17] = l),
			(e[18] = c),
			(e[19] = d))
		: (d = e[19]);
	const [f, h, p] = Cp(d),
		g = Ri(h);
	let v;
	e[20] !== t.map || e[21] !== t.initialState || e[22] !== n.schema
		? ((v = () => {
				var y;
				(y = t.map.doc) === null ||
					y === void 0 ||
					y.transact(() => {
						for (const [k, w] of Object.entries(n.schema)) {
							var x, C;
							const D = hl(
								w,
								(x =
									(C = t.initialState) === null ||
									C === void 0
										? void 0
										: C[k]) !== null && x !== void 0
									? x
									: an(w),
							);
							t.map.set(k, D);
						}
					});
			}),
			(e[20] = t.map),
			(e[21] = t.initialState),
			(e[22] = n.schema),
			(e[23] = v))
		: (v = e[23]);
	let b;
	return (
		e[24] !== t.basePath ||
		e[25] !== t.collection ||
		e[26] !== f ||
		e[27] !== g ||
		e[28] !== p ||
		e[29] !== i ||
		e[30] !== a ||
		e[31] !== o ||
		e[32] !== v
			? ((b = m.jsx(nQ, {
					basePath: t.basePath,
					collection: t.collection,
					createResult: f,
					createItem: g,
					resetCreateItemState: p,
					state: i,
					slug: a,
					previewProps: o,
					onReset: v,
				})),
				(e[24] = t.basePath),
				(e[25] = t.collection),
				(e[26] = f),
				(e[27] = g),
				(e[28] = p),
				(e[29] = i),
				(e[30] = a),
				(e[31] = o),
				(e[32] = v),
				(e[33] = b))
			: (b = e[33]),
		b
	);
}
function nQ(t) {
	const e = ee(96),
		{ onReset: n } = t,
		r = Le(Ht),
		i = En(),
		o = Jn(),
		{ collectionConfig: s, schema: a } = wp(t.collection),
		[l, u] = E.useState(!1);
	let c;
	e[0] !== o || e[1] !== t.collection
		? ((c = qo(o, t.collection)),
			(e[0] = o),
			(e[1] = t.collection),
			(e[2] = c))
		: (c = e[2]);
	const d = c,
		f = Qd(),
		h = `${t.basePath}/collection/${encodeURIComponent(t.collection)}`,
		{ createResult: p } = t,
		g = p.kind === "updated" || p.kind === "loading" ? t.slug : void 0,
		v = XZ(t.collection, g);
	let b;
	e[3] !== p.kind ||
	e[4] !== a ||
	e[5] !== t ||
	e[6] !== v ||
	e[7] !== s ||
	e[8] !== i ||
	e[9] !== h
		? ((b = async () => {
				if (p.kind !== "loading") {
					if (!_s(a, t.state, v)) {
						u(!0);
						return;
					}
					if (await t.createItem()) {
						const we = tr(s, t.state);
						i.push(`${h}/item/${encodeURIComponent(we)}`),
							il.positive("Entry created", { timeout: 5e3 });
					}
				}
			}),
			(e[3] = p.kind),
			(e[4] = a),
			(e[5] = t),
			(e[6] = v),
			(e[7] = s),
			(e[8] = i),
			(e[9] = h),
			(e[10] = b))
		: (b = e[10]);
	const y = b;
	let x;
	e[11] !== t.state || e[12] !== d || e[13] !== s
		? ((x = () => {
				VA(t.state, d, s.schema, {
					field: s.slugField,
					value: tr(s, t.state),
				});
			}),
			(e[11] = t.state),
			(e[12] = d),
			(e[13] = s),
			(e[14] = x))
		: (x = e[14]);
	const C = x;
	let k;
	e[15] !== d || e[16] !== s || e[17] !== t.state || e[18] !== t.previewProps
		? ((k = async () => {
				const we = await LA(d, s.schema, {
					field: s.slugField,
					slug: tr(s, t.state),
				});
				we &&
					(jd(we, t.previewProps),
					il.positive("Entry pasted", {
						shouldCloseOnAction: !0,
						actionLabel: "Undo",
						onAction: () => {
							jd(t.state, t.previewProps);
						},
					}));
			}),
			(e[15] = d),
			(e[16] = s),
			(e[17] = t.state),
			(e[18] = t.previewProps),
			(e[19] = k))
		: (k = e[19]);
	const w = k,
		D = p.kind === "loading" || p.kind === "updated";
	let S, $;
	e[20] !== s.label || e[21] !== h
		? (($ = { key: "collection", label: s.label, href: h }),
			(e[20] = s.label),
			(e[21] = h),
			(e[22] = $))
		: ($ = e[22]);
	let A;
	e[23] !== r
		? ((A = r.format("add")), (e[23] = r), (e[24] = A))
		: (A = e[24]);
	let T;
	e[25] !== A
		? ((T = { key: "current", label: A }), (e[25] = A), (e[26] = T))
		: (T = e[26]);
	let I;
	e[27] !== $ || e[28] !== T
		? ((I = [$, T]), (e[27] = $), (e[28] = T), (e[29] = I))
		: (I = e[29]),
		(S = I);
	const F = S,
		N = $l(en.below.desktop);
	let O;
	e[30] !== s ? ((O = cA(s)), (e[30] = s), (e[31] = O)) : (O = e[31]);
	let _;
	e[32] !== F
		? ((_ = m.jsx(JZ, { items: F })), (e[32] = F), (e[33] = _))
		: (_ = e[33]);
	let j;
	e[34] === Symbol.for("react.memo_cache_sentinel")
		? ((j = m.jsx(OA, {})), (e[34] = j))
		: (j = e[34]);
	let V;
	e[35] !== D
		? ((V =
				D &&
				m.jsx(Cr, {
					"aria-label": "Creating entry",
					isIndeterminate: !0,
					size: "small",
				})),
			(e[35] = D),
			(e[36] = V))
		: (V = e[36]);
	const K = N ? "element.regular" : void 0;
	let M;
	e[37] !== n || e[38] !== C || e[39] !== w
		? ((M = (we) => {
				e: switch (we) {
					case "reset": {
						n(), u(!1);
						break e;
					}
					case "copy": {
						C();
						break e;
					}
					case "paste":
						w();
				}
			}),
			(e[37] = n),
			(e[38] = C),
			(e[39] = w),
			(e[40] = M))
		: (M = e[40]);
	let G;
	e[41] === Symbol.for("react.memo_cache_sentinel")
		? ((G = (we) =>
				m.jsxs(
					Mt,
					{
						textValue: we.label,
						children: [
							m.jsx(ve, { src: we.icon }),
							m.jsx(ue, { children: we.label }),
						],
					},
					we.key,
				)),
			(e[41] = G))
		: (G = e[41]);
	let H;
	e[42] !== K || e[43] !== M
		? ((H = m.jsx(nf, {
				buttonLabelBehavior: "hide",
				overflowMode: "collapse",
				prominence: "low",
				density: "compact",
				maxWidth: K,
				items: QRe,
				onAction: M,
				children: G,
			})),
			(e[42] = K),
			(e[43] = M),
			(e[44] = H))
		: (H = e[44]);
	let P;
	e[45] !== r
		? ((P = r.format("create")), (e[45] = r), (e[46] = P))
		: (P = e[46]);
	let q;
	e[47] !== D || e[48] !== P
		? ((q = m.jsx(vt, {
				isDisabled: D,
				prominence: "high",
				type: "submit",
				form: "item-create-form",
				marginStart: "auto",
				children: P,
			})),
			(e[47] = D),
			(e[48] = P),
			(e[49] = q))
		: (q = e[49]);
	let J;
	e[50] !== _ || e[51] !== V || e[52] !== H || e[53] !== q
		? ((J = m.jsxs(yp, { children: [_, j, V, H, q] })),
			(e[50] = _),
			(e[51] = V),
			(e[52] = H),
			(e[53] = q),
			(e[54] = J))
		: (J = e[54]);
	let Z;
	e[55] !== y
		? ((Z = (we) => {
				we.target === we.currentTarget && (we.preventDefault(), y());
			}),
			(e[55] = y),
			(e[56] = Z))
		: (Z = e[56]);
	let oe;
	e[57] !== p
		? ((oe =
				p.kind === "error" &&
				m.jsx(fo, { tone: "critical", children: p.error.message })),
			(e[57] = p),
			(e[58] = oe))
		: (oe = e[58]);
	let ne;
	e[59] !== t.previewProps ||
	e[60] !== l ||
	e[61] !== s.entryLayout ||
	e[62] !== d ||
	e[63] !== v
		? ((ne = m.jsx(dA, {
				previewProps: t.previewProps,
				forceValidation: l,
				entryLayout: s.entryLayout,
				formatInfo: d,
				slugField: v,
			})),
			(e[59] = t.previewProps),
			(e[60] = l),
			(e[61] = s.entryLayout),
			(e[62] = d),
			(e[63] = v),
			(e[64] = ne))
		: (ne = e[64]);
	let de;
	e[65] !== Z || e[66] !== oe || e[67] !== ne
		? ((de = m.jsxs(ke, {
				id: "item-create-form",
				elementType: "form",
				onSubmit: Z,
				direction: "column",
				gap: "xxlarge",
				height: "100%",
				minHeight: 0,
				minWidth: 0,
				children: [oe, ne],
			})),
			(e[65] = Z),
			(e[66] = oe),
			(e[67] = ne),
			(e[68] = de))
		: (de = e[68]);
	let se;
	e[69] !== O || e[70] !== J || e[71] !== de
		? ((se = m.jsxs(cl, { containerWidth: O, children: [J, de] })),
			(e[69] = O),
			(e[70] = J),
			(e[71] = de),
			(e[72] = se))
		: (se = e[72]);
	let re;
	e[73] !== p || e[74] !== i || e[75] !== t || e[76] !== f || e[77] !== s
		? ((re =
				p.kind === "needs-new-branch" &&
				m.jsx(KA, {
					branchOid: f,
					onCreate: async (we) => {
						if (
							(i.push(
								`/keystatic/branch/${encodeURIComponent(we)}/collection/${encodeURIComponent(t.collection)}/create`,
							),
							await t.createItem({ branch: we, sha: f }))
						) {
							const Ke = tr(s, t.state);
							i.push(
								`/keystatic/branch/${encodeURIComponent(we)}/collection/${encodeURIComponent(t.collection)}/item/${encodeURIComponent(Ke)}`,
							);
						}
					},
					reason: p.reason,
					onDismiss: t.resetCreateItemState,
				})),
			(e[73] = p),
			(e[74] = i),
			(e[75] = t),
			(e[76] = f),
			(e[77] = s),
			(e[78] = re))
		: (re = e[78]);
	let he;
	e[79] !== t.resetCreateItemState || e[80] !== re
		? ((he = m.jsx(mn, {
				onDismiss: t.resetCreateItemState,
				children: re,
			})),
			(e[79] = t.resetCreateItemState),
			(e[80] = re),
			(e[81] = he))
		: (he = e[81]);
	let ye;
	e[82] !== p.kind ||
	e[83] !== o ||
	e[84] !== t ||
	e[85] !== s ||
	e[86] !== i ||
	e[87] !== h
		? ((ye =
				p.kind === "needs-fork" &&
				va(o) &&
				m.jsx(rx, {
					onCreate: async () => {
						if (await t.createItem()) {
							const we = tr(s, t.state);
							i.push(`${h}/item/${encodeURIComponent(we)}`);
						}
					},
					onDismiss: t.resetCreateItemState,
					config: o,
				})),
			(e[82] = p.kind),
			(e[83] = o),
			(e[84] = t),
			(e[85] = s),
			(e[86] = i),
			(e[87] = h),
			(e[88] = ye))
		: (ye = e[88]);
	let Ae;
	e[89] !== t.resetCreateItemState || e[90] !== ye
		? ((Ae = m.jsx(mn, {
				onDismiss: t.resetCreateItemState,
				children: ye,
			})),
			(e[89] = t.resetCreateItemState),
			(e[90] = ye),
			(e[91] = Ae))
		: (Ae = e[91]);
	let Pe;
	return (
		e[92] !== se || e[93] !== he || e[94] !== Ae
			? ((Pe = m.jsxs(m.Fragment, { children: [se, he, Ae] })),
				(e[92] = se),
				(e[93] = he),
				(e[94] = Ae),
				(e[95] = Pe))
			: (Pe = e[95]),
		Pe
	);
}
const QRe = [
		{ key: "reset", label: "Reset", icon: $A },
		{ key: "copy", label: "Copy entry", icon: TA },
		{ key: "paste", label: "Paste entry", icon: BA },
	],
	UA = (t) => {
		const e = ee(5),
			{ children: n, title: r } = t;
		let i;
		e[0] !== r
			? ((i = m.jsx(ue, {
					casing: "uppercase",
					color: "neutralTertiary",
					size: "small",
					weight: "bold",
					elementType: "h2",
					children: r,
				})),
				(e[0] = r),
				(e[1] = i))
			: (i = e[1]);
		let o;
		return (
			e[2] !== i || e[3] !== n
				? ((o = m.jsxs(ke, {
						elementType: "section",
						direction: "column",
						gap: "medium",
						children: [i, n],
					})),
					(e[2] = i),
					(e[3] = n),
					(e[4] = o))
				: (o = e[4]),
			o
		);
	},
	kc = "fill",
	rQ = (t) =>
		m.jsx("div", {
			className: X({
				display: "grid",
				gap: B.size.space.large,
				gridAutoRows: B.size.element.xlarge,
				gridTemplateColumns: `[${kc}-start] 1fr [${kc}-end]`,
				[Gm.above.mobile]: {
					gridTemplateColumns: `[${kc}-start] 1fr 1fr [${kc}-end]`,
				},
				[Gm.above.tablet]: {
					gridTemplateColumns: `[${kc}-start] 1fr 1fr 1fr [${kc}-end]`,
				},
			}),
			...t,
		}),
	eOe = (t) => {
		const e = ee(12),
			n = E.useRef(null),
			{ linkProps: r } = Wh(t, n);
		let i;
		e[0] === Symbol.for("react.memo_cache_sentinel")
			? ((i = Se(
					X({
						color: B.color.foreground.neutral,
						outline: "none",
						"&:hover": {
							color: B.color.foreground.neutralEmphasis,
							"::before": {
								backgroundColor: B.color.alias.backgroundIdle,
								borderColor: B.color.border.neutral,
							},
						},
						"&:active": {
							"::before": {
								backgroundColor:
									B.color.alias.backgroundHovered,
								borderColor: B.color.alias.borderHovered,
							},
						},
						"&:focus-visible::before": {
							outline: `${B.size.alias.focusRing} solid ${B.color.alias.focusRing}`,
							outlineOffset: B.size.alias.focusRingGap,
						},
						"::before": {
							border: `${B.size.border.regular} solid ${B.color.border.muted}`,
							borderRadius: B.size.radius.medium,
							content: '""',
							position: "absolute",
							inset: 0,
							transition: bt([
								"background-color",
								"border-color",
							]),
						},
					}),
				)),
				(e[0] = i))
			: (i = e[0]);
		let o;
		e[1] !== n || e[2] !== t.href || e[3] !== t.label || e[4] !== r
			? ((o = m.jsx(Ut, {
					elementType: "h3",
					size: "small",
					truncate: !0,
					children: m.jsx("a", {
						ref: n,
						href: t.href,
						...r,
						className: i,
						children: t.label,
					}),
				})),
				(e[1] = n),
				(e[2] = t.href),
				(e[3] = t.label),
				(e[4] = r),
				(e[5] = o))
			: (o = e[5]);
		let s;
		e[6] !== o || e[7] !== t.children
			? ((s = m.jsxs(ke, {
					direction: "column",
					gap: "medium",
					flex: !0,
					children: [o, t.children],
				})),
				(e[6] = o),
				(e[7] = t.children),
				(e[8] = s))
			: (s = e[8]);
		let a;
		return (
			e[9] !== s || e[10] !== t.endElement
				? ((a = m.jsxs(ke, {
						alignItems: "center",
						backgroundColor: "canvas",
						padding: "large",
						position: "relative",
						children: [s, t.endElement],
					})),
					(e[9] = s),
					(e[10] = t.endElement),
					(e[11] = a))
				: (a = e[11]),
			a
		);
	};
function tOe() {
	return Le(Ht);
}
function nOe() {
	const t = ee(30),
		e = Qo(),
		n = Xr(),
		r = En(),
		i = tOe(),
		o = GY();
	let s;
	t[0] !== e ? ((s = e && Cg(e)), (t[0] = e), (t[1] = s)) : (s = t[1]);
	const a = s,
		l = n === (e == null ? void 0 : e.defaultBranch);
	let u;
	t[2] !== i
		? ((u = i.format("currentBranch")), (t[2] = i), (t[3] = u))
		: (u = t[3]);
	let c;
	t[4] === Symbol.for("react.memo_cache_sentinel")
		? ((c = m.jsx(ve, { src: PW, color: "neutralTertiary" })), (t[4] = c))
		: (c = t[4]);
	let d;
	t[5] !== n
		? ((d = m.jsxs(ke, {
				alignItems: "center",
				gap: "regular",
				border: "muted",
				borderRadius: "medium",
				backgroundColor: "canvas",
				padding: "large",
				children: [
					c,
					m.jsx(ue, {
						size: "medium",
						weight: "semibold",
						children: n,
					}),
				],
			})),
			(t[5] = n),
			(t[6] = d))
		: (d = t[6]);
	let f;
	t[7] === Symbol.for("react.memo_cache_sentinel")
		? ((f = m.jsx(ve, { src: WH })), (t[7] = f))
		: (f = t[7]);
	let h;
	t[8] !== i
		? ((h = i.format("newBranch")), (t[8] = i), (t[9] = h))
		: (h = t[9]);
	let p;
	t[10] !== h
		? ((p = m.jsxs(Re, { children: [f, m.jsx(ue, { children: h })] })),
			(t[10] = h),
			(t[11] = p))
		: (p = t[11]);
	let g;
	t[12] !== r
		? ((g = (C) =>
				m.jsx(KY, {
					onDismiss: C,
					onCreate: (k) => {
						C(),
							r.push(
								r.href.replace(
									/\/branch\/[^/]+/,
									"/branch/" + encodeURIComponent(k),
								),
							);
					},
				})),
			(t[12] = r),
			(t[13] = g))
		: (g = t[13]);
	let v;
	t[14] !== p || t[15] !== g
		? ((v = m.jsxs(zce, { children: [p, g] })),
			(t[14] = p),
			(t[15] = g),
			(t[16] = v))
		: (v = t[16]);
	let b;
	t[17] !== l || t[18] !== o || t[19] !== a || t[20] !== n || t[21] !== i
		? ((b =
				!l &&
				o !== void 0 &&
				(o === !1
					? m.jsxs(Re, {
							href: `${a}/pull/new/${n}`,
							target: "_blank",
							children: [
								m.jsx(ve, { src: gy }),
								m.jsx(ue, {
									children: i.format("createPullRequest"),
								}),
							],
						})
					: m.jsxs(Re, {
							href: `${a}/pull/${o}`,
							target: "_blank",
							children: [
								m.jsx(ve, { src: gy }),
								m.jsxs(ue, { children: ["Pull request #", o] }),
							],
						}))),
			(t[17] = l),
			(t[18] = o),
			(t[19] = a),
			(t[20] = n),
			(t[21] = i),
			(t[22] = b))
		: (b = t[22]);
	let y;
	t[23] !== v || t[24] !== b
		? ((y = m.jsxs(ke, { gap: "regular", wrap: !0, children: [v, b] })),
			(t[23] = v),
			(t[24] = b),
			(t[25] = y))
		: (y = t[25]);
	let x;
	return (
		t[26] !== u || t[27] !== d || t[28] !== y
			? ((x = m.jsxs(UA, { title: u, children: [d, y] })),
				(t[26] = u),
				(t[27] = d),
				(t[28] = y),
				(t[29] = x))
			: (x = t[29]),
		x
	);
}
function rOe() {
	const t = ee(9),
		e = VY();
	let n;
	if (t[0] !== e) {
		let a;
		t[2] === Symbol.for("react.memo_cache_sentinel")
			? ((a = (l) => "children" in l), (t[2] = a))
			: (a = t[2]),
			(n = e.some(a)),
			(t[0] = e),
			(t[1] = n);
	} else n = t[1];
	const r = n;
	let i;
	if (t[3] !== e) {
		let a;
		t[5] === Symbol.for("react.memo_cache_sentinel")
			? ((a = (l) => iQ(l)), (t[5] = a))
			: (a = t[5]),
			(i = e.map(a)),
			(t[3] = e),
			(t[4] = i);
	} else i = t[4];
	const o = i;
	let s;
	return (
		t[6] !== r || t[7] !== o
			? ((s = r
					? m.jsx(m.Fragment, { children: o })
					: m.jsx(UA, {
							title: "Content",
							children: m.jsx(rQ, { children: o }),
						})),
				(t[6] = r),
				(t[7] = o),
				(t[8] = s))
			: (s = t[8]),
		s
	);
}
let iOe = 0;
function iQ(t) {
	if (t.isDivider)
		return m.jsx(
			ke,
			{
				gridColumn: kc,
				children: m.jsx(ra, {
					alignSelf: "center",
					size: "medium",
					width: "alias.singleLineWidth",
				}),
			},
			iOe++,
		);
	if (t.children)
		return m.jsx(
			UA,
			{
				title: t.title,
				children: m.jsx(rQ, { children: t.children.map((r) => iQ(r)) }),
			},
			t.title,
		);
	let e = (() => {
			if (t.changed)
				return typeof t.changed == "number"
					? m.jsx($g, {
							tone: "accent",
							marginStart: "auto",
							children: Od(t.changed, {
								singular: "change",
								plural: "changes",
							}),
						})
					: m.jsx($g, { tone: "accent", children: "Changed" });
		})(),
		n =
			typeof t.entryCount != "number"
				? e
				: m.jsxs(ke, {
						gap: "medium",
						alignItems: "center",
						children: [
							e,
							m.jsx(Re, {
								"aria-label": "Add",
								href: `${t.href}/create`,
								children: m.jsx(ve, { src: Ux }),
							}),
						],
					});
	return m.jsx(
		eOe,
		{
			label: t.label,
			href: t.href,
			endElement: n,
			children:
				typeof t.entryCount == "number"
					? m.jsx(ue, {
							color: "neutralSecondary",
							children: Od(t.entryCount, {
								singular: "entry",
								plural: "entries",
							}),
						})
					: null,
		},
		t.key,
	);
}
function oOe(t) {
	const e = ee(19),
		n = Le(Ht),
		r = KU(),
		i = _0();
	let o;
	if (e[0] !== r || e[1] !== i) {
		var s;
		(o = r
			? {
					name: (s = r.name) !== null && s !== void 0 ? s : r.login,
					avatarUrl: r.avatarUrl,
				}
			: i == null
				? void 0
				: i.user),
			(e[0] = r),
			(e[1] = i),
			(e[2] = o);
	} else o = e[2];
	const a = o;
	let l;
	e[3] !== n
		? ((l = n.format("dashboard")), (e[3] = n), (e[4] = l))
		: (l = e[4]);
	let u;
	e[5] !== l
		? ((u = m.jsx(yp, {
				children: m.jsx(Ut, {
					elementType: "h1",
					id: "page-title",
					size: "small",
					children: l,
				}),
			})),
			(e[5] = l),
			(e[6] = u))
		: (u = e[6]);
	let c;
	e[7] !== a || e[8] !== i
		? ((c = a && m.jsx(sOe, { user: a, manageAccount: !!i })),
			(e[7] = a),
			(e[8] = i),
			(e[9] = c))
		: (c = e[9]);
	let d;
	e[10] !== t.config
		? ((d = !cp(t.config) && m.jsx(nOe, {})),
			(e[10] = t.config),
			(e[11] = d))
		: (d = e[11]);
	let f;
	e[12] === Symbol.for("react.memo_cache_sentinel")
		? ((f = m.jsx(rOe, {})), (e[12] = f))
		: (f = e[12]);
	let h;
	e[13] !== c || e[14] !== d
		? ((h = m.jsx(la, {
				isScrollable: !0,
				children: m.jsxs(ke, {
					direction: "column",
					gap: "xxlarge",
					children: [c, d, f],
				}),
			})),
			(e[13] = c),
			(e[14] = d),
			(e[15] = h))
		: (h = e[15]);
	let p;
	return (
		e[16] !== u || e[17] !== h
			? ((p = m.jsxs(cl, { containerWidth: "large", children: [u, h] })),
				(e[16] = u),
				(e[17] = h),
				(e[18] = p))
			: (p = e[18]),
		p
	);
}
function sOe(t) {
	const e = ee(15),
		{ user: n, manageAccount: r } = t;
	let i;
	e[0] === Symbol.for("react.memo_cache_sentinel")
		? ((i = { below: "tablet" }), (e[0] = i))
		: (i = e[0]);
	let o;
	e[1] !== n.avatarUrl || e[2] !== n.name
		? ((o = m.jsx(m3, { src: n.avatarUrl, name: n.name, size: "large" })),
			(e[1] = n.avatarUrl),
			(e[2] = n.name),
			(e[3] = o))
		: (o = e[3]);
	let s;
	e[4] === Symbol.for("react.memo_cache_sentinel")
		? ((s = { fontWeight: B.typography.fontWeight.bold }), (e[4] = s))
		: (s = e[4]);
	let a;
	e[5] !== n.name
		? ((a = m.jsxs(Ut, {
				size: "medium",
				elementType: "p",
				UNSAFE_style: s,
				children: ["Hello, ", n.name, "!"],
			})),
			(e[5] = n.name),
			(e[6] = a))
		: (a = e[6]);
	let l;
	e[7] !== r
		? ((l =
				r &&
				m.jsx(xh, {
					href: "https://keystatic.cloud/account",
					children: "Manage Account",
				})),
			(e[7] = r),
			(e[8] = l))
		: (l = e[8]);
	let u;
	e[9] !== a || e[10] !== l
		? ((u = m.jsxs(Hr, { gap: "medium", children: [a, l] })),
			(e[9] = a),
			(e[10] = l),
			(e[11] = u))
		: (u = e[11]);
	let c;
	return (
		e[12] !== o || e[13] !== u
			? ((c = m.jsxs(ke, {
					alignItems: "center",
					gap: "medium",
					isHidden: i,
					children: [o, u],
				})),
				(e[12] = o),
				(e[13] = u),
				(e[14] = c))
			: (c = e[14]),
		c
	);
}
const aOe = (t) => {
	const e = ee(13),
		n = $l(en.below.desktop),
		r = lA(),
		i = E.useRef(null),
		o = Zye(i),
		s = n || !r.isOpen;
	let a;
	e[0] !== n
		? ((a = n ? m.jsx(uTe, {}) : m.jsx(VH, { children: m.jsx(lTe, {}) })),
			(e[0] = n),
			(e[1] = a))
		: (a = e[1]);
	let l;
	e[2] !== i || e[3] !== t.children
		? ((l = m.jsx(KH, { ref: i, children: t.children })),
			(e[2] = i),
			(e[3] = t.children),
			(e[4] = l))
		: (l = e[4]);
	let u;
	e[5] !== s || e[6] !== r.toggle || e[7] !== a || e[8] !== l
		? ((u = m.jsxs(LH, {
				autoSaveId: "keystatic-app-split-view",
				isCollapsed: s,
				onCollapseChange: r.toggle,
				defaultSize: 260,
				minSize: 180,
				maxSize: 400,
				height: "100vh",
				children: [a, l],
			})),
			(e[5] = s),
			(e[6] = r.toggle),
			(e[7] = a),
			(e[8] = l),
			(e[9] = u))
		: (u = e[9]);
	let c;
	return (
		e[10] !== o || e[11] !== u
			? ((c = m.jsx(Jye, { value: o, children: u })),
				(e[10] = o),
				(e[11] = u),
				(e[12] = c))
			: (c = e[12]),
		c
	);
};
function lOe(t) {
	var e;
	const n = ee(2),
		r = fp(),
		i = Xr(),
		o = E.useContext(k3);
	if (
		(o == null ||
		(e = o.data) === null ||
		e === void 0 ||
		(e = e.repository) === null ||
		e === void 0 ||
		(e = e.refs) === null ||
		e === void 0
			? void 0
			: e.pageInfo.hasNextPage) === !1 &&
		!r.has(i)
	) {
		const s = `The branch ${i} does not exist in this repository.`;
		let a;
		return (
			n[0] !== s
				? ((a = m.jsx(pd, {
						icon: gD,
						title: "Branch not found",
						message: s,
					})),
					(n[0] = s),
					(n[1] = a))
				: (a = n[1]),
			a
		);
	}
	return t.children;
}
const uOe = (t) => {
	const e = ee(19);
	let n;
	e[0] !== t.children
		? ((n = m.jsx(oH.Consumer, {
				children: (u) =>
					u &&
					!(
						u != null &&
						u.graphQLErrors.some((c) => {
							var d;
							return (
								(c == null ||
								(d = c.originalError) === null ||
								d === void 0
									? void 0
									: d.type) === "NOT_FOUND"
							);
						})
					)
						? m.jsx(pd, {
								icon: gD,
								title: "Failed to load shell",
								message: u.message,
							})
						: t.children,
			})),
			(e[0] = t.children),
			(e[1] = n))
		: (n = e[1]);
	const r = n;
	let i;
	e[2] !== t.basePath
		? ((i = { basePath: t.basePath }), (e[2] = t.basePath), (e[3] = i))
		: (i = e[3]);
	let o;
	e[4] !== r
		? ((o = m.jsx(aTe, {
				children: m.jsx(aOe, { children: m.jsx(lOe, { children: r }) }),
			})),
			(e[4] = r),
			(e[5] = o))
		: (o = e[5]);
	let s;
	e[6] !== i || e[7] !== o
		? ((s = m.jsx(pH.Provider, { value: i, children: o })),
			(e[6] = i),
			(e[7] = o),
			(e[8] = s))
		: (s = e[8]);
	let a;
	e[9] !== t.config || e[10] !== s
		? ((a = m.jsx(hH.Provider, { value: t.config, children: s })),
			(e[9] = t.config),
			(e[10] = s),
			(e[11] = a))
		: (a = e[11]);
	const l = a;
	if (va(t.config) || t.config.storage.kind === "cloud") {
		let u;
		return (
			e[12] !== t.currentBranch || e[13] !== t.config || e[14] !== l
				? ((u = m.jsx(Wye, {
						currentBranch: t.currentBranch,
						config: t.config,
						children: l,
					})),
					(e[12] = t.currentBranch),
					(e[13] = t.config),
					(e[14] = l),
					(e[15] = u))
				: (u = e[15]),
			u
		);
	}
	if (cp(t.config)) {
		let u;
		return (
			e[16] !== t.config || e[17] !== l
				? ((u = m.jsx(Lye, { config: t.config, children: l })),
					(e[16] = t.config),
					(e[17] = l),
					(e[18] = u))
				: (u = e[18]),
			u
		);
	}
	return null;
};
function oQ(t) {
	const e = ee(96),
		n = $l(en.below.desktop),
		r = Qo(),
		i = Xr(),
		[o, s] = E.useState(!1),
		{ schema: a, singletonConfig: l } = zA(t.singleton),
		u = En();
	let c;
	e: {
		if (!l.previewUrl) {
			c = void 0;
			break e;
		}
		let me;
		e[0] !== l.previewUrl || e[1] !== i
			? ((me = l.previewUrl.replace("{branch}", i)),
				(e[0] = l.previewUrl),
				(e[1] = i),
				(e[2] = me))
			: (me = e[2]),
			(c = me);
	}
	const d = c;
	let f;
	e[3] !== t.config
		? ((f = va(t.config) || B2(t.config)), (e[3] = t.config), (e[4] = f))
		: (f = e[4]);
	const h = f;
	let p, g;
	if (
		e[5] !== t.config ||
		e[6] !== t.singleton ||
		e[7] !== t.initialState ||
		e[8] !== h ||
		e[9] !== r ||
		e[10] !== i
	) {
		var v, b;
		g = kg(t.config, t.singleton);
		const me = !!t.initialState,
			De = P0(t.config, t.singleton);
		(p =
			h && me && r
				? `${Cg(r)}${g.dataLocation === "index" ? `/tree/${i}/${(v = Ju(t.config.storage)) !== null && v !== void 0 ? v : ""}${De}` : `/blob/${(b = Ju(t.config.storage)) !== null && b !== void 0 ? b : ""}${i}/${De}${N0(g)}`}`
				: void 0),
			(e[5] = t.config),
			(e[6] = t.singleton),
			(e[7] = t.initialState),
			(e[8] = h),
			(e[9] = r),
			(e[10] = i),
			(e[11] = p),
			(e[12] = g);
	} else (p = e[11]), (g = e[12]);
	const y = p;
	let x, C;
	e[13] === Symbol.for("react.memo_cache_sentinel")
		? ((C = { key: "reset", label: "Reset", icon: $A }), (e[13] = C))
		: (C = e[13]);
	let k;
	e[14] === Symbol.for("react.memo_cache_sentinel")
		? ((k = { key: "copy", label: "Copy entry", icon: TA }), (e[14] = k))
		: (k = e[14]);
	let w;
	e[15] === Symbol.for("react.memo_cache_sentinel")
		? ((w = { key: "paste", label: "Paste entry", icon: BA }), (e[15] = w))
		: (w = e[15]);
	let D;
	if (e[16] !== d || e[17] !== y) {
		if (((D = [C, k, w]), d)) {
			let me;
			e[19] !== d
				? ((me = {
						key: "preview",
						label: "Preview",
						icon: S3,
						href: d,
						target: "_blank",
						rel: "noopener noreferrer",
					}),
					(e[19] = d),
					(e[20] = me))
				: (me = e[20]),
				D.push(me);
		}
		if (y) {
			let me;
			e[21] !== y
				? ((me = {
						key: "view",
						label: "View on GitHub",
						icon: Ex,
						href: y,
						target: "_blank",
						rel: "noopener noreferrer",
					}),
					(e[21] = y),
					(e[22] = me))
				: (me = e[22]),
				D.push(me);
		}
		(e[16] = d), (e[17] = y), (e[18] = D);
	} else D = e[18];
	x = D;
	const S = x,
		$ = Qd(),
		A = t.initialState === null;
	let T;
	e[23] !== t || e[24] !== a
		? ((T = async () => {
				if (!(t.updateResult.kind === "loading" || !t.hasChanged)) {
					if (!_s(a, t.state, void 0)) {
						s(!0);
						return;
					}
					await t.onUpdate();
				}
			}),
			(e[23] = t),
			(e[24] = a),
			(e[25] = T))
		: (T = e[25]);
	const I = T;
	let F;
	e[26] !== t.state || e[27] !== g || e[28] !== l.schema
		? ((F = () => {
				VA(t.state, g, l.schema, void 0);
			}),
			(e[26] = t.state),
			(e[27] = g),
			(e[28] = l.schema),
			(e[29] = F))
		: (F = e[29]);
	const N = F;
	let O;
	e[30] !== g ||
	e[31] !== l.schema ||
	e[32] !== t.previewProps ||
	e[33] !== t.state
		? ((O = async () => {
				const me = await LA(g, l.schema, void 0);
				me &&
					(jd(me, t.previewProps),
					il.positive("Entry pasted", {
						shouldCloseOnAction: !0,
						actionLabel: "Undo",
						onAction: () => {
							jd(t.state, t.previewProps);
						},
					}));
			}),
			(e[30] = g),
			(e[31] = l.schema),
			(e[32] = t.previewProps),
			(e[33] = t.state),
			(e[34] = O))
		: (O = e[34]);
	const _ = O;
	let j;
	e[35] !== l ? ((j = cA(l)), (e[35] = l), (e[36] = j)) : (j = e[36]);
	let V;
	e[37] !== l.label
		? ((V = m.jsx(Ut, {
				elementType: "h1",
				id: "page-title",
				size: "small",
				children: l.label,
			})),
			(e[37] = l.label),
			(e[38] = V))
		: (V = e[38]);
	let K;
	e[39] !== t || e[40] !== l
		? ((K =
				t.updateResult.kind === "loading"
					? m.jsx(Cr, {
							"aria-label": `Updating ${l.label}`,
							isIndeterminate: !0,
							size: "small",
							alignSelf: "center",
						})
					: t.hasChanged &&
						m.jsx($g, { tone: "pending", children: "Unsaved" })),
			(e[39] = t),
			(e[40] = l),
			(e[41] = K))
		: (K = e[41]);
	let M;
	e[42] !== V || e[43] !== K
		? ((M = m.jsxs(ke, {
				flex: !0,
				alignItems: "center",
				gap: "regular",
				children: [V, K],
			})),
			(e[42] = V),
			(e[43] = K),
			(e[44] = M))
		: (M = e[44]);
	let G;
	e[45] === Symbol.for("react.memo_cache_sentinel")
		? ((G = m.jsx(OA, {})), (e[45] = G))
		: (G = e[45]);
	const H = n ? "element.regular" : void 0;
	let P;
	e[46] !== t.hasChanged
		? ((P = t.hasChanged ? [] : ["reset"]),
			(e[46] = t.hasChanged),
			(e[47] = P))
		: (P = e[47]);
	let q;
	e[48] !== t || e[49] !== N || e[50] !== _
		? ((q = (me) => {
				e: switch (me) {
					case "reset": {
						t.onReset();
						break e;
					}
					case "copy": {
						N();
						break e;
					}
					case "paste":
						_();
				}
			}),
			(e[48] = t),
			(e[49] = N),
			(e[50] = _),
			(e[51] = q))
		: (q = e[51]);
	let J;
	e[52] === Symbol.for("react.memo_cache_sentinel")
		? ((J = (me) =>
				m.jsxs(
					Mt,
					{
						textValue: me.label,
						href: me.href,
						target: me.target,
						rel: me.rel,
						children: [
							m.jsx(ve, { src: me.icon }),
							m.jsx(ue, { children: me.label }),
						],
					},
					me.key,
				)),
			(e[52] = J))
		: (J = e[52]);
	let Z;
	e[53] !== H || e[54] !== S || e[55] !== P || e[56] !== q
		? ((Z = m.jsx(nf, {
				buttonLabelBehavior: "hide",
				overflowMode: "collapse",
				prominence: "low",
				density: "compact",
				maxWidth: H,
				items: S,
				disabledKeys: P,
				onAction: q,
				children: J,
			})),
			(e[53] = H),
			(e[54] = S),
			(e[55] = P),
			(e[56] = q),
			(e[57] = Z))
		: (Z = e[57]);
	const oe = t.updateResult.kind === "loading",
		ne = A ? "Create" : "Save";
	let de;
	e[58] !== oe || e[59] !== ne
		? ((de = m.jsx(vt, {
				form: "singleton-form",
				isDisabled: oe,
				prominence: "high",
				type: "submit",
				children: ne,
			})),
			(e[58] = oe),
			(e[59] = ne),
			(e[60] = de))
		: (de = e[60]);
	let se;
	e[61] !== M || e[62] !== Z || e[63] !== de
		? ((se = m.jsxs(yp, { children: [M, G, Z, de] })),
			(e[61] = M),
			(e[62] = Z),
			(e[63] = de),
			(e[64] = se))
		: (se = e[64]);
	let re;
	e[65] !== I
		? ((re = (me) => {
				me.target === me.currentTarget && (me.preventDefault(), I());
			}),
			(e[65] = I),
			(e[66] = re))
		: (re = e[66]);
	let he;
	e[67] !== t.updateResult
		? ((he =
				t.updateResult.kind === "error" &&
				m.jsx(fo, {
					tone: "critical",
					children: t.updateResult.error.message,
				})),
			(e[67] = t.updateResult),
			(e[68] = he))
		: (he = e[68]);
	const ye = t.previewProps;
	let Ae;
	e[69] !== ye || e[70] !== o || e[71] !== l.entryLayout || e[72] !== g
		? ((Ae = m.jsx(dA, {
				previewProps: ye,
				forceValidation: o,
				entryLayout: l.entryLayout,
				formatInfo: g,
				slugField: void 0,
			})),
			(e[69] = ye),
			(e[70] = o),
			(e[71] = l.entryLayout),
			(e[72] = g),
			(e[73] = Ae))
		: (Ae = e[73]);
	let Pe;
	e[74] !== t || e[75] !== u || e[76] !== $
		? ((Pe =
				t.updateResult.kind === "needs-new-branch" &&
				m.jsx(KA, {
					branchOid: $,
					onCreate: async (me) => {
						u.push(
							`/keystatic/branch/${encodeURIComponent(me)}/singleton/${encodeURIComponent(t.singleton)}`,
						),
							t.onUpdate({ branch: me, sha: $ });
					},
					reason: t.updateResult.reason,
					onDismiss: t.onResetUpdateItem,
				})),
			(e[74] = t),
			(e[75] = u),
			(e[76] = $),
			(e[77] = Pe))
		: (Pe = e[77]);
	let we;
	e[78] !== t.onResetUpdateItem || e[79] !== Pe
		? ((we = m.jsx(mn, { onDismiss: t.onResetUpdateItem, children: Pe })),
			(e[78] = t.onResetUpdateItem),
			(e[79] = Pe),
			(e[80] = we))
		: (we = e[80]);
	let Ke;
	e[81] !== t
		? ((Ke =
				t.updateResult.kind === "needs-fork" &&
				va(t.config) &&
				m.jsx(rx, {
					onCreate: async () => {
						t.onUpdate();
					},
					onDismiss: t.onResetUpdateItem,
					config: t.config,
				})),
			(e[81] = t),
			(e[82] = Ke))
		: (Ke = e[82]);
	let rt;
	e[83] !== t.onResetUpdateItem || e[84] !== Ke
		? ((rt = m.jsx(mn, { onDismiss: t.onResetUpdateItem, children: Ke })),
			(e[83] = t.onResetUpdateItem),
			(e[84] = Ke),
			(e[85] = rt))
		: (rt = e[85]);
	let Ce;
	e[86] !== re || e[87] !== he || e[88] !== Ae || e[89] !== we || e[90] !== rt
		? ((Ce = m.jsxs(ke, {
				elementType: "form",
				id: "singleton-form",
				onSubmit: re,
				direction: "column",
				gap: "xxlarge",
				height: "100%",
				minHeight: 0,
				minWidth: 0,
				children: [he, Ae, we, rt],
			})),
			(e[86] = re),
			(e[87] = he),
			(e[88] = Ae),
			(e[89] = we),
			(e[90] = rt),
			(e[91] = Ce))
		: (Ce = e[91]);
	let Me;
	return (
		e[92] !== j || e[93] !== se || e[94] !== Ce
			? ((Me = m.jsxs(cl, { containerWidth: j, children: [se, Ce] })),
				(e[92] = j),
				(e[93] = se),
				(e[94] = Ce),
				(e[95] = Me))
			: (Me = e[95]),
		Me
	);
}
function cOe(t) {
	const e = ee(49),
		{
			singleton: n,
			initialFiles: r,
			initialState: i,
			localTreeKey: o,
			config: s,
			draft: a,
		} = t,
		{ schema: l, singletonConfig: u } = zA(t.singleton);
	let c;
	e[0] !== s || e[1] !== n
		? ((c = P0(s, n)), (e[0] = s), (e[1] = n), (e[2] = c))
		: (c = e[2]);
	const d = c;
	let f;
	e[3] !== o || e[4] !== a || e[5] !== i || e[6] !== l
		? ((f = () => {
				var V;
				return {
					localTreeKey: o,
					state:
						(V = a == null ? void 0 : a.state) !== null &&
						V !== void 0
							? V
							: i === null
								? an(l)
								: i,
				};
			}),
			(e[3] = o),
			(e[4] = a),
			(e[5] = i),
			(e[6] = l),
			(e[7] = f))
		: (f = e[7]);
	const [h, p] = E.useState(f),
		{ state: g, localTreeKey: v } = h;
	d5(a, g, o),
		v !== o && p({ localTreeKey: o, state: i === null ? an(l) : i });
	const b = i === null,
		y =
			i1({ initialState: i, state: g, schema: l, slugField: void 0 }) ||
			b;
	let x;
	e[8] !== n ||
	e[9] !== y ||
	e[10] !== d ||
	e[11] !== s ||
	e[12] !== u.schema ||
	e[13] !== g ||
	e[14] !== o
		? ((x = () => {
				const V = ["singleton", n];
				if (y) {
					const K = r1({
							basePath: d,
							format: kg(s, n),
							schema: u.schema,
							slug: void 0,
							state: g,
						}),
						M = new Map(K.map((H) => [H.path, H.contents]));
					a5(V, {
						beforeTreeKey: o,
						files: M,
						savedAt: new Date(),
						version: 1,
					});
				} else l5(V);
			}),
			(e[8] = n),
			(e[9] = y),
			(e[10] = d),
			(e[11] = s),
			(e[12] = u.schema),
			(e[13] = g),
			(e[14] = o),
			(e[15] = x))
		: (x = e[15]);
	let C;
	e[16] !== s ||
	e[17] !== o ||
	e[18] !== g ||
	e[19] !== y ||
	e[20] !== n ||
	e[21] !== d ||
	e[22] !== u
		? ((C = [s, o, g, y, n, d, u]),
			(e[16] = s),
			(e[17] = o),
			(e[18] = g),
			(e[19] = y),
			(e[20] = n),
			(e[21] = d),
			(e[22] = u),
			(e[23] = C))
		: (C = e[23]),
		E.useEffect(x, C);
	let k;
	e[24] === Symbol.for("react.memo_cache_sentinel")
		? ((k = (V) => {
				p((K) => ({ localTreeKey: K.localTreeKey, state: V(K.state) }));
			}),
			(e[24] = k))
		: (k = e[24]);
	const D = jA(l, k, g);
	let S;
	e[25] !== s || e[26] !== n
		? ((S = kg(s, n)), (e[25] = s), (e[26] = n), (e[27] = S))
		: (S = e[27]);
	const $ = S;
	let A;
	e[28] !== g ||
	e[29] !== r ||
	e[30] !== s ||
	e[31] !== u.schema ||
	e[32] !== d ||
	e[33] !== $ ||
	e[34] !== o
		? ((A = {
				state: g,
				initialFiles: r,
				config: s,
				schema: u.schema,
				basePath: d,
				format: $,
				currentLocalTreeKey: o,
				slug: void 0,
			}),
			(e[28] = g),
			(e[29] = r),
			(e[30] = s),
			(e[31] = u.schema),
			(e[32] = d),
			(e[33] = $),
			(e[34] = o),
			(e[35] = A))
		: (A = e[35]);
	const [T, I, F] = Cp(A),
		N = Ri(I);
	let O;
	e[36] !== o || e[37] !== i || e[38] !== l
		? ((O = () => p({ localTreeKey: o, state: i === null ? an(l) : i })),
			(e[36] = o),
			(e[37] = i),
			(e[38] = l),
			(e[39] = O))
		: (O = e[39]);
	const _ = O;
	let j;
	return (
		e[40] !== t ||
		e[41] !== y ||
		e[42] !== _ ||
		e[43] !== N ||
		e[44] !== F ||
		e[45] !== T ||
		e[46] !== g ||
		e[47] !== D
			? ((j = m.jsx(oQ, {
					...t,
					hasChanged: y,
					onReset: _,
					onUpdate: N,
					onResetUpdateItem: F,
					updateResult: T,
					state: g,
					previewProps: D,
				})),
				(e[40] = t),
				(e[41] = y),
				(e[42] = _),
				(e[43] = N),
				(e[44] = F),
				(e[45] = T),
				(e[46] = g),
				(e[47] = D),
				(e[48] = j))
			: (j = e[48]),
		j
	);
}
function dOe(t) {
	const e = ee(27),
		{
			singleton: n,
			initialFiles: r,
			initialState: i,
			localTreeKey: o,
			config: s,
		} = t,
		{ schema: a, singletonConfig: l } = zA(t.singleton);
	let u;
	e[0] !== s || e[1] !== n
		? ((u = P0(s, n)), (e[0] = s), (e[1] = n), (e[2] = u))
		: (u = e[2]);
	const c = u,
		d = MA(a, t.map),
		f = _A(a, t.map, d),
		h = i === null,
		p =
			i1({ initialState: i, state: d, schema: a, slugField: void 0 }) ||
			h;
	let g;
	e[3] !== s || e[4] !== n
		? ((g = kg(s, n)), (e[3] = s), (e[4] = n), (e[5] = g))
		: (g = e[5]);
	const v = g;
	let b;
	e[6] !== d ||
	e[7] !== r ||
	e[8] !== s ||
	e[9] !== l.schema ||
	e[10] !== c ||
	e[11] !== v ||
	e[12] !== o
		? ((b = {
				state: d,
				initialFiles: r,
				config: s,
				schema: l.schema,
				basePath: c,
				format: v,
				currentLocalTreeKey: o,
				slug: void 0,
			}),
			(e[6] = d),
			(e[7] = r),
			(e[8] = s),
			(e[9] = l.schema),
			(e[10] = c),
			(e[11] = v),
			(e[12] = o),
			(e[13] = b))
		: (b = e[13]);
	const [y, x, C] = Cp(b),
		k = Ri(x);
	let w;
	e[14] !== t.map || e[15] !== t.initialState || e[16] !== l.schema
		? ((w = () => {
				t.map.doc.transact(() => {
					for (const [T, I] of Object.entries(l.schema)) {
						var $, A;
						const F = hl(
							I,
							($ =
								(A = t.initialState) === null || A === void 0
									? void 0
									: A[T]) !== null && $ !== void 0
								? $
								: an(I),
						);
						t.map.set(T, F);
					}
				});
			}),
			(e[14] = t.map),
			(e[15] = t.initialState),
			(e[16] = l.schema),
			(e[17] = w))
		: (w = e[17]);
	const D = w;
	let S;
	return (
		e[18] !== t ||
		e[19] !== p ||
		e[20] !== D ||
		e[21] !== k ||
		e[22] !== C ||
		e[23] !== y ||
		e[24] !== d ||
		e[25] !== f
			? ((S = m.jsx(oQ, {
					...t,
					hasChanged: p,
					onReset: D,
					onUpdate: k,
					onResetUpdateItem: C,
					updateResult: y,
					state: d,
					previewProps: f,
				})),
				(e[18] = t),
				(e[19] = p),
				(e[20] = D),
				(e[21] = k),
				(e[22] = C),
				(e[23] = y),
				(e[24] = d),
				(e[25] = f),
				(e[26] = S))
			: (S = e[26]),
		S
	);
}
const fOe = sa({
	version: xS(1),
	savedAt: Yx(),
	beforeTreeKey: CS(jt()),
	files: kS(jt(), Jx(Uint8Array)),
});
function hOe(t) {
	var e;
	const n = ee(55),
		r =
			(e = t.config.singletons) === null || e === void 0
				? void 0
				: e[t.singleton];
	r || kp();
	let i;
	n[0] !== r.label
		? ((i = m.jsx(yp, {
				children: m.jsx(Ut, {
					elementType: "h1",
					id: "page-title",
					size: "small",
					children: r.label,
				}),
			})),
			(n[0] = r.label),
			(n[1] = i))
		: (i = n[1]);
	const o = i;
	let s, a;
	n[2] !== t.config || n[3] !== t.singleton
		? ((a = kg(t.config, t.singleton)),
			(n[2] = t.config),
			(n[3] = t.singleton),
			(n[4] = a))
		: (a = n[4]),
		(s = a);
	const l = s;
	let u;
	n[5] !== t.config || n[6] !== t.singleton
		? ((u = P0(t.config, t.singleton)),
			(n[5] = t.config),
			(n[6] = t.singleton),
			(n[7] = u))
		: (u = n[7]);
	const c = u;
	let d;
	n[8] !== t.singleton || n[9] !== c || n[10] !== l || n[11] !== r.schema
		? ((d = async () => {
				const A = await u5(["singleton", t.singleton]);
				if (!A) throw new Error("No draft found");
				const T = fOe.create(A);
				return {
					state: zd(
						{
							dirpath: c,
							format: l,
							schema: r.schema,
							slug: void 0,
						},
						T.files,
					).initialState,
					savedAt: T.savedAt,
					treeKey: T.beforeTreeKey,
				};
			}),
			(n[8] = t.singleton),
			(n[9] = c),
			(n[10] = l),
			(n[11] = r.schema),
			(n[12] = d))
		: (d = n[12]);
	const f = bo(d);
	let h;
	n[13] !== t.config || n[14] !== c || n[15] !== r.schema || n[16] !== l
		? ((h = {
				config: t.config,
				dirpath: c,
				schema: r.schema,
				format: l,
				slug: void 0,
			}),
			(n[13] = t.config),
			(n[14] = c),
			(n[15] = r.schema),
			(n[16] = l),
			(n[17] = h))
		: (h = n[17]);
	const p = RA(h),
		v = `${Xr()}/${t.singleton}`,
		b = x3(),
		y = p.kind === "loading";
	let x;
	n[18] !== b || n[19] !== y || n[20] !== v
		? ((x = async () => {
				if (!b) return;
				if (b === "loading" || (await b.doc.whenSynced, y)) return zo;
				let A = b.data.get(v);
				if (A instanceof Ki) {
					const T = A.whenLoaded;
					A.load(), await T;
				} else (A = new Ki()), b.data.set(v, A);
				return A.getMap("data");
			}),
			(n[18] = b),
			(n[19] = y),
			(n[20] = v),
			(n[21] = x))
		: (x = n[21]);
	const C = bo(x);
	e: {
		if (
			C.kind !== "loaded" ||
			p.kind !== "loaded" ||
			!C.data ||
			C.data.size
		)
			break e;
		const A = C.data;
		A.doc.transact(() => {
			for (const [T, I] of Object.entries(r.schema)) {
				const F = hl(
					I,
					p.data === "not-found" ? an(I) : p.data.initialState[T],
				);
				A.set(T, F);
			}
		});
	}
	if (p.kind === "error") {
		let A;
		n[22] !== p.error.message
			? ((A = m.jsx(la, {
					children: m.jsx(fo, {
						margin: "xxlarge",
						tone: "critical",
						children: p.error.message,
					}),
				})),
				(n[22] = p.error.message),
				(n[23] = A))
			: (A = n[23]);
		let T;
		return (
			n[24] !== o || n[25] !== A
				? ((T = m.jsxs(cl, { children: [o, A] })),
					(n[24] = o),
					(n[25] = A),
					(n[26] = T))
				: (T = n[26]),
			T
		);
	}
	if (C.kind === "error") {
		let A;
		n[27] !== C.error.message
			? ((A = m.jsx(la, {
					children: m.jsx(fo, {
						margin: "xxlarge",
						tone: "critical",
						children: C.error.message,
					}),
				})),
				(n[27] = C.error.message),
				(n[28] = A))
			: (A = n[28]);
		let T;
		return (
			n[29] !== o || n[30] !== A
				? ((T = m.jsxs(cl, { children: [o, A] })),
					(n[29] = o),
					(n[30] = A),
					(n[31] = T))
				: (T = n[31]),
			T
		);
	}
	if (p.kind === "loading" || f.kind === "loading" || C.kind === "loading") {
		const A = `Loading ${r.label}`;
		let T;
		n[32] !== A
			? ((T = m.jsx(la, {
					children: m.jsx(ke, {
						alignItems: "center",
						justifyContent: "center",
						minHeight: "scale.3000",
						children: m.jsx(Cr, {
							"aria-label": A,
							isIndeterminate: !0,
							size: "large",
						}),
					}),
				})),
				(n[32] = A),
				(n[33] = T))
			: (T = n[33]);
		let I;
		return (
			n[34] !== o || n[35] !== T
				? ((I = m.jsxs(cl, { children: [o, T] })),
					(n[34] = o),
					(n[35] = T),
					(n[36] = I))
				: (I = n[36]),
			I
		);
	}
	if (C.data) {
		const A = p.data === "not-found" ? null : p.data.initialState;
		let T;
		n[37] !== p.data
			? ((T = p.data === "not-found" ? [] : p.data.initialFiles),
				(n[37] = p.data),
				(n[38] = T))
			: (T = n[38]);
		const I = p.data === "not-found" ? void 0 : p.data.localTreeKey;
		let F;
		return (
			n[39] !== t.singleton ||
			n[40] !== t.config ||
			n[41] !== A ||
			n[42] !== T ||
			n[43] !== I ||
			n[44] !== C.data
				? ((F = m.jsx(dOe, {
						singleton: t.singleton,
						config: t.config,
						initialState: A,
						initialFiles: T,
						localTreeKey: I,
						map: C.data,
					})),
					(n[39] = t.singleton),
					(n[40] = t.config),
					(n[41] = A),
					(n[42] = T),
					(n[43] = I),
					(n[44] = C.data),
					(n[45] = F))
				: (F = n[45]),
			F
		);
	}
	const k = p.data === "not-found" ? null : p.data.initialState;
	let w;
	n[46] !== p.data
		? ((w = p.data === "not-found" ? [] : p.data.initialFiles),
			(n[46] = p.data),
			(n[47] = w))
		: (w = n[47]);
	const D = p.data === "not-found" ? void 0 : p.data.localTreeKey,
		S = f.kind === "loaded" ? f.data : void 0;
	let $;
	return (
		n[48] !== t.singleton ||
		n[49] !== t.config ||
		n[50] !== k ||
		n[51] !== w ||
		n[52] !== D ||
		n[53] !== S
			? (($ = m.jsx(cOe, {
					singleton: t.singleton,
					config: t.config,
					initialState: k,
					initialFiles: w,
					localTreeKey: D,
					draft: S,
				})),
				(n[48] = t.singleton),
				(n[49] = t.config),
				(n[50] = k),
				(n[51] = w),
				(n[52] = D),
				(n[53] = S),
				(n[54] = $))
			: ($ = n[54]),
		$
	);
}
function pOe(t) {
	const e = ee(11);
	let n;
	e[0] === Symbol.for("react.memo_cache_sentinel")
		? ((n = m.jsx(Ut, { children: "You've installed Keystatic! 🎉" })),
			(e[0] = n))
		: (n = e[0]);
	let r;
	e[1] === Symbol.for("react.memo_cache_sentinel")
		? ((r = m.jsx(ue, {
				children:
					"To start using Keystatic, you need to install the GitHub app you've created.",
			})),
			(e[1] = r))
		: (r = e[1]);
	let i;
	e[2] !== t.config.storage.repo
		? ((i = Td(t.config.storage.repo)),
			(e[2] = t.config.storage.repo),
			(e[3] = i))
		: (i = e[3]);
	let o;
	e[4] !== i
		? ((o = m.jsxs(ue, {
				children: [
					"Make sure to add the App to the",
					" ",
					m.jsx("code", { children: i }),
					" ",
					"repository.",
				],
			})),
			(e[4] = i),
			(e[5] = o))
		: (o = e[5]);
	let s;
	e[6] !== t.config
		? ((s = m.jsx(YZ, { config: t.config })), (e[6] = t.config), (e[7] = s))
		: (s = e[7]);
	let a;
	return (
		e[8] !== o || e[9] !== s
			? ((a = m.jsx(ke, {
					alignItems: "center",
					justifyContent: "center",
					margin: "xxlarge",
					children: m.jsxs(ke, {
						backgroundColor: "surface",
						padding: "large",
						border: "color.alias.borderIdle",
						borderRadius: "medium",
						direction: "column",
						justifyContent: "center",
						gap: "xlarge",
						maxWidth: "scale.4600",
						children: [n, r, o, s],
					}),
				})),
				(e[8] = o),
				(e[9] = s),
				(e[10] = a))
			: (a = e[10]),
		a
	);
}
function mOe(t) {
	const e = ee(22),
		[n, r] = E.useState(""),
		[i, o] = E.useState(""),
		s = `https://github.com${i ? `/organizations/${i}` : ""}/settings/apps/new`;
	let a;
	e[0] === Symbol.for("react.memo_cache_sentinel")
		? ((a = m.jsx(ke, {
				justifyContent: "center",
				children: m.jsx(Ut, { children: "Keystatic Setup" }),
			})),
			(e[0] = a))
		: (a = e[0]);
	let l;
	e[1] === Symbol.for("react.memo_cache_sentinel")
		? ((l = m.jsx(ue, {
				children: "Keystatic doesn't have the required config.",
			})),
			(e[1] = l))
		: (l = e[1]);
	let u;
	e[2] === Symbol.for("react.memo_cache_sentinel")
		? ((u = m.jsx(ue, {
				children:
					"If you've already created your GitHub app, make sure to add the following environment variables:",
			})),
			(e[2] = u))
		: (u = e[2]);
	let c;
	e[3] === Symbol.for("react.memo_cache_sentinel")
		? ((c = m.jsxs(pr, {
				elementType: "ul",
				children: [
					m.jsx("li", {
						children: m.jsx("code", {
							children: "KEYSTATIC_GITHUB_CLIENT_ID",
						}),
					}),
					m.jsx("li", {
						children: m.jsx("code", {
							children: "KEYSTATIC_GITHUB_CLIENT_SECRET",
						}),
					}),
					m.jsx("li", {
						children: m.jsx("code", {
							children: "KEYSTATIC_SECRET",
						}),
					}),
				],
			})),
			(e[3] = c))
		: (c = e[3]);
	let d;
	e[4] === Symbol.for("react.memo_cache_sentinel")
		? ((d = m.jsx(ue, {
				children:
					"If you haven't created your GitHub app for Keystatic, you can create one below.",
			})),
			(e[4] = d))
		: (d = e[4]);
	let f;
	e[5] !== n
		? ((f = m.jsx(An, {
				label: "Deployed App URL",
				description:
					"This should the root of your domain. If you're not sure where Keystatic will be deployed, leave this blank and you can update the GitHub app later.",
				value: n,
				onChange: r,
			})),
			(e[5] = n),
			(e[6] = f))
		: (f = e[6]);
	let h;
	e[7] !== i
		? ((h = m.jsx(An, {
				label: "GitHub organization (if any)",
				description:
					"You must be an owner or GitHub App manager in the organization to create the GitHub App. Leave this blank to create the app in your personal account.",
				value: i,
				onChange: o,
			})),
			(e[7] = i),
			(e[8] = h))
		: (h = e[8]);
	let p;
	e[9] === Symbol.for("react.memo_cache_sentinel")
		? ((p = m.jsxs(ue, {
				children: [
					"After visiting GitHub to create the GitHub app, you'll be redirected back here and secrets generated from GitHub will be written to your",
					" ",
					m.jsx("code", { children: ".env" }),
					" file.",
				],
			})),
			(e[9] = p))
		: (p = e[9]);
	let g;
	e[10] === Symbol.for("react.memo_cache_sentinel")
		? ((g = X({ display: "none" })), (e[10] = g))
		: (g = e[10]);
	let v;
	e[11] !== t.config.storage.repo || e[12] !== n
		? ((v = JSON.stringify({
				name: `${j0(t.config.storage.repo).owner} Keystatic`,
				url: n
					? `${n}/keystatic`
					: `${window.location.origin}/keystatic`,
				public: !0,
				redirect_url: `${window.location.origin}/api/keystatic/github/created-app`,
				callback_urls: [
					`${window.location.origin}/api/keystatic/github/oauth/callback`,
					"http://127.0.0.1/api/keystatic/github/oauth/callback",
					...(n ? [`${n}/api/keystatic/github/oauth/callback`] : []),
				],
				request_oauth_on_install: !0,
				default_permissions: {
					contents: "write",
					metadata: "read",
					pull_requests: "read",
				},
			})),
			(e[11] = t.config.storage.repo),
			(e[12] = n),
			(e[13] = v))
		: (v = e[13]);
	let b;
	e[14] !== v
		? ((b = m.jsx("input", {
				type: "text",
				name: "manifest",
				className: g,
				value: v,
			})),
			(e[14] = v),
			(e[15] = b))
		: (b = e[15]);
	let y;
	e[16] === Symbol.for("react.memo_cache_sentinel")
		? ((y = m.jsx(vt, {
				prominence: "high",
				type: "submit",
				children: "Create GitHub App",
			})),
			(e[16] = y))
		: (y = e[16]);
	let x;
	return (
		e[17] !== s || e[18] !== f || e[19] !== h || e[20] !== b
			? ((x = m.jsx(ke, {
					alignItems: "center",
					justifyContent: "center",
					margin: "xxlarge",
					children: m.jsxs(ke, {
						backgroundColor: "surface",
						padding: "large",
						border: "color.alias.borderIdle",
						borderRadius: "medium",
						direction: "column",
						justifyContent: "center",
						gap: "xlarge",
						maxWidth: "scale.4600",
						elementType: "form",
						action: s,
						method: "post",
						children: [a, l, u, c, d, f, h, p, b, y],
					}),
				})),
				(e[17] = s),
				(e[18] = f),
				(e[19] = h),
				(e[20] = b),
				(e[21] = x))
			: (x = e[21]),
		x
	);
}
function gOe(t) {
	const e = ee(11);
	let n;
	e[0] !== t.config.storage.repo
		? ((n = Td(t.config.storage.repo)),
			(e[0] = t.config.storage.repo),
			(e[1] = n))
		: (n = e[1]);
	const r = n;
	let i;
	e[2] === Symbol.for("react.memo_cache_sentinel")
		? ((i = m.jsx(ke, {
				justifyContent: "center",
				children: m.jsx(Ut, { children: "Repo not found" }),
			})),
			(e[2] = i))
		: (i = e[2]);
	const o = `https://github.com/${r}`;
	let s;
	e[3] !== o || e[4] !== r
		? ((s = m.jsxs(ue, {
				children: [
					"Keystatic is configured for the",
					" ",
					m.jsx("a", { href: o, children: r }),
					" GitHub repo but Keystatic isn't able to access this repo. This is either because you don't have access to this repo or you haven't added the GitHub app to it.",
				],
			})),
			(e[3] = o),
			(e[4] = r),
			(e[5] = s))
		: (s = e[5]);
	let a;
	e[6] !== t.config
		? ((a = m.jsx(YZ, { config: t.config })), (e[6] = t.config), (e[7] = a))
		: (a = e[7]);
	let l;
	return (
		e[8] !== s || e[9] !== a
			? ((l = m.jsx(ke, {
					alignItems: "center",
					justifyContent: "center",
					margin: "xxlarge",
					children: m.jsxs(ke, {
						backgroundColor: "surface",
						padding: "large",
						border: "color.alias.borderIdle",
						borderRadius: "medium",
						direction: "column",
						justifyContent: "center",
						gap: "xlarge",
						maxWidth: "scale.4600",
						children: [i, s, a],
					}),
				})),
				(e[8] = s),
				(e[9] = a),
				(e[10] = l))
			: (l = e[10]),
		l
	);
}
const bOe = Xx({ state: jt(), from: jt(), code_verifier: jt() }),
	vOe = sa({ access_token: jt(), token_type: jt(), expires_in: $h() });
function yOe({ config: t }) {
	var e;
	const n = En(),
		r = new URL(window.location.href),
		i = r.searchParams.get("code"),
		o = r.searchParams.get("state"),
		s = E.useMemo(() => {
			const u = localStorage.getItem("keystatic-cloud-state");
			return (() => {
				try {
					return bOe.create(JSON.parse(u || ""));
				} catch {
					return null;
				}
			})();
		}, []),
		[a, l] = E.useState(null);
	return (
		E.useEffect(() => {
			var u;
			if (
				i &&
				o &&
				s &&
				(u = t.cloud) !== null &&
				u !== void 0 &&
				u.project
			) {
				const { project: c } = t.cloud;
				(async () => {
					const d = await fetch(`${Rl}/oauth/token`, {
						method: "POST",
						body: new URLSearchParams({
							code: i,
							client_id: c,
							redirect_uri: `${window.location.origin}/keystatic/cloud/oauth/callback`,
							code_verifier: s.code_verifier,
							grant_type: "authorization_code",
						}).toString(),
						headers: {
							"Content-Type": "application/x-www-form-urlencoded",
							...ic,
						},
					});
					if (!d.ok)
						throw new Error(`Bad response: ${d.status} ${d.statusText}

${await d.text()}`);
					const f = await d.json(),
						h = vOe.create(f);
					localStorage.setItem(
						"keystatic-cloud-access-token",
						JSON.stringify({
							token: h.access_token,
							project: c,
							validUntil: Date.now() + h.expires_in * 1e3,
						}),
					),
						n.push(`/keystatic/${s.from}`);
				})().catch((d) => {
					l(d);
				});
			}
		}, [i, o, n, s, t]),
		(e = t.cloud) !== null && e !== void 0 && e.project
			? !i || !o
				? m.jsx(ue, { children: "Missing code or state" })
				: !s || o !== s.state
					? m.jsx(ue, { children: "Invalid state" })
					: a
						? m.jsx(ue, { children: a.message })
						: m.jsx(ke, {
								justifyContent: "center",
								alignItems: "center",
								height: "100vh",
								children: m.jsx(Cr, {
									size: "large",
									isIndeterminate: !0,
									"aria-label": "Authenticating",
								}),
							})
			: m.jsx(ue, { children: "Missing Keystatic Cloud config" })
	);
}
function K8(t) {
	if (t.length === 0) return {};
	if (t.length === 2 && t[0] === "singleton") return { singleton: t[1] };
	if (t.length < 2 || t[0] !== "collection") return null;
	const e = t[1];
	if (t.length === 2) return { collection: e };
	if (t.length === 3 && t[2] === "create")
		return { collection: e, kind: "create" };
	if (t.length === 4 && t[2] === "item") {
		const n = t[3];
		return { collection: e, kind: "edit", slug: n };
	}
	return null;
}
function xOe(t) {
	const e = ee(6),
		{ push: n } = En(),
		{ data: r, error: i } = E.useContext(k3);
	let o, s;
	return (
		e[0] !== i || e[1] !== t.config || e[2] !== r || e[3] !== n
			? ((o = () => {
					var a, l, u, c, d;
					(i == null || (a = i.response) === null || a === void 0
						? void 0
						: a.status) === 401 &&
						(t.config.storage.kind === "github"
							? (window.location.href =
									"/api/keystatic/github/login")
							: O0("", t.config)),
						r != null &&
							(l = r.repository) !== null &&
							l !== void 0 &&
							l.defaultBranchRef &&
							n(
								`/keystatic/branch/${encodeURIComponent(r.repository.defaultBranchRef.name)}`,
							),
						((t.config.storage.kind === "github" &&
							!(
								r != null &&
								(u = r.repository) !== null &&
								u !== void 0 &&
								u.id
							) &&
							(i == null ||
							(c = i.graphQLErrors) === null ||
							c === void 0 ||
							(c = c[0]) === null ||
							c === void 0 ||
							(c = c.originalError) === null ||
							c === void 0
								? void 0
								: c.type) === "NOT_FOUND") ||
							(i == null ||
							(d = i.graphQLErrors) === null ||
							d === void 0 ||
							(d = d[0]) === null ||
							d === void 0 ||
							(d = d.originalError) === null ||
							d === void 0
								? void 0
								: d.type) === "FORBIDDEN") &&
							(window.location.href =
								"/api/keystatic/github/repo-not-found");
				}),
				(s = [r, i, n, t.config]),
				(e[0] = i),
				(e[1] = t.config),
				(e[2] = r),
				(e[3] = n),
				(e[4] = o),
				(e[5] = s))
			: ((o = e[4]), (s = e[5])),
		E.useEffect(o, s),
		null
	);
}
function kOe(t) {
	var e;
	const n = ee(37),
		{ config: r } = t,
		{ params: i } = En();
	let o = null,
		s,
		a;
	if (i.join("/") === "cloud/oauth/callback") {
		let g;
		return (
			n[0] !== r
				? ((g = m.jsx(yOe, { config: r })), (n[0] = r), (n[1] = g))
				: (g = n[1]),
			g
		);
	}
	let l;
	n[2] === Symbol.for("react.memo_cache_sentinel")
		? ((l = (g) => g), (n[2] = l))
		: (l = n[2]);
	let u = l;
	if (
		B2(r) ||
		(cp(r) && (e = r.cloud) !== null && e !== void 0 && e.project)
	) {
		let g;
		n[3] !== r
			? ((g = (v) => m.jsx(Uye, { config: r, children: v })),
				(n[3] = r),
				(n[4] = g))
			: (g = n[4]),
			(u = g);
	}
	if (va(r) || B2(r)) {
		const g = u;
		let v;
		if (
			(n[5] !== r || n[6] !== g
				? ((v = (y) =>
						m.jsx(wOe, {
							config: r,
							children: m.jsx(Hye, { config: r, children: g(y) }),
						})),
					(n[5] = r),
					(n[6] = g),
					(n[7] = v))
				: (v = n[7]),
			(u = v),
			i.length === 0)
		) {
			let y;
			n[8] !== r
				? ((y = m.jsx(xOe, { config: r })), (n[8] = r), (n[9] = y))
				: (y = n[9]);
			let x;
			return (
				n[10] !== u || n[11] !== y
					? ((x = u(y)), (n[10] = u), (n[11] = y), (n[12] = x))
					: (x = n[12]),
				x
			);
		}
		if (i.length === 1 && va(r)) {
			if (i[0] === "setup") {
				let y;
				return (
					n[13] !== r
						? ((y = m.jsx(mOe, { config: r })),
							(n[13] = r),
							(n[14] = y))
						: (y = n[14]),
					y
				);
			}
			if (i[0] === "repo-not-found") {
				let y;
				return (
					n[15] !== r
						? ((y = m.jsx(gOe, { config: r })),
							(n[15] = r),
							(n[16] = y))
						: (y = n[16]),
					y
				);
			}
			if (i[0] === "created-github-app") {
				let y;
				return (
					n[17] !== r
						? ((y = m.jsx(pOe, { config: r })),
							(n[17] = r),
							(n[18] = y))
						: (y = n[18]),
					y
				);
			}
		}
		if (i[0] !== "branch" || i.length < 2) {
			let y;
			return (
				n[19] === Symbol.for("react.memo_cache_sentinel")
					? ((y = m.jsx(ue, { children: "Not found" })), (n[19] = y))
					: (y = n[19]),
				y
			);
		}
		(o = i[1]), (a = `/keystatic/branch/${encodeURIComponent(o)}`);
		let b;
		n[20] !== i
			? ((b = K8(i.slice(2))), (n[20] = i), (n[21] = b))
			: (b = n[21]),
			(s = b);
	} else {
		let g;
		n[22] !== i ? ((g = K8(i)), (n[22] = i), (n[23] = g)) : (g = n[23]),
			(s = g),
			(a = "/keystatic");
	}
	const c = o || "";
	let d;
	n[24] === Symbol.for("react.memo_cache_sentinel")
		? ((d = m.jsx(cl, {
				children: m.jsx(la, {
					children: m.jsx(pd, {
						icon: yre,
						title: "Not found",
						message: "This page could not be found.",
					}),
				}),
			})),
			(n[24] = d))
		: (d = n[24]);
	let f;
	n[25] !== s || n[26] !== r || n[27] !== a
		? ((f = m.jsx(WZ, {
				fallback: d,
				children:
					s === null
						? m.jsx(COe, {})
						: s.collection
							? s.kind === "create"
								? m.jsx(
										YRe,
										{
											collection: s.collection,
											config: r,
											basePath: a,
										},
										s.collection,
									)
								: s.kind === "edit"
									? m.jsx(
											WRe,
											{
												collection: s.collection,
												basePath: a,
												config: r,
												itemSlug: s.slug,
											},
											s.collection,
										)
									: m.jsx(
											CRe,
											{
												basePath: a,
												collection: s.collection,
												config: r,
											},
											s.collection,
										)
							: s.singleton
								? m.jsx(
										hOe,
										{ config: r, singleton: s.singleton },
										s.singleton,
									)
								: m.jsx(oOe, { config: r, basePath: a }),
			})),
			(n[25] = s),
			(n[26] = r),
			(n[27] = a),
			(n[28] = f))
		: (f = n[28]);
	let h;
	n[29] !== r || n[30] !== c || n[31] !== a || n[32] !== f
		? ((h = m.jsx(uOe, {
				config: r,
				currentBranch: c,
				basePath: a,
				children: f,
			})),
			(n[29] = r),
			(n[30] = c),
			(n[31] = a),
			(n[32] = f),
			(n[33] = h))
		: (h = n[33]);
	let p;
	return (
		n[34] !== u || n[35] !== h
			? ((p = u(h)), (n[34] = u), (n[35] = h), (n[36] = p))
			: (p = n[36]),
		p
	);
}
function COe() {
	kp();
}
function wOe(t) {
	const e = ee(13),
		[n, r] = E.useState("unknown"),
		i = En();
	let o, s;
	if (
		(e[0] !== t.config
			? ((o = () => {
					$d(t.config).then((a) => {
						if (a) {
							r("valid");
							return;
						}
						r("explicit-auth");
					});
				}),
				(s = [t.config]),
				(e[0] = t.config),
				(e[1] = o),
				(e[2] = s))
			: ((o = e[1]), (s = e[2])),
		E.useEffect(o, s),
		n === "valid")
	)
		return t.children;
	if (n === "explicit-auth") {
		if (t.config.storage.kind === "github") {
			const a = `/api/keystatic/github/login${i.params.length ? `?${new URLSearchParams({ from: i.params.map(encodeURIComponent).join("/") })}` : ""}`;
			let l;
			e[3] === Symbol.for("react.memo_cache_sentinel")
				? ((l = m.jsx(ve, { src: Ex })), (e[3] = l))
				: (l = e[3]);
			let u;
			e[4] === Symbol.for("react.memo_cache_sentinel")
				? ((u = m.jsx(ue, { children: "Log in with GitHub" })),
					(e[4] = u))
				: (u = e[4]);
			let c;
			return (
				e[5] !== a
					? ((c = m.jsx(ke, {
							justifyContent: "center",
							alignItems: "center",
							height: "100vh",
							children: m.jsxs(vt, {
								href: a,
								target: "_top",
								children: [l, u],
							}),
						})),
						(e[5] = a),
						(e[6] = c))
					: (c = e[6]),
				c
			);
		}
		if (t.config.storage.kind === "cloud") {
			let a;
			e[7] !== i.params || e[8] !== t.config
				? ((a = () => {
						O0(
							i.params.map(encodeURIComponent).join("/"),
							t.config,
						);
					}),
					(e[7] = i.params),
					(e[8] = t.config),
					(e[9] = a))
				: (a = e[9]);
			let l;
			e[10] === Symbol.for("react.memo_cache_sentinel")
				? ((l = m.jsx(ue, { children: "Log in with Keystatic Cloud" })),
					(e[10] = l))
				: (l = e[10]);
			let u;
			return (
				e[11] !== a
					? ((u = m.jsx(ke, {
							justifyContent: "center",
							alignItems: "center",
							height: "100vh",
							children: m.jsx(vt, { onPress: a, children: l }),
						})),
						(e[11] = a),
						(e[12] = u))
					: (u = e[12]),
				u
			);
		}
	}
	return null;
}
function EOe(t) {
	const e = ee(2);
	let n, r;
	return (
		e[0] === Symbol.for("react.memo_cache_sentinel")
			? ((n = () => {
					window.location.hostname === "localhost" &&
						(window.location.href = window.location.href.replace(
							"localhost",
							"127.0.0.1",
						));
				}),
				(r = []),
				(e[0] = n),
				(e[1] = r))
			: ((n = e[0]), (r = e[1])),
		E.useEffect(n, r),
		window.location.hostname === "localhost" ? null : t.children
	);
}
function DOe(t) {
	const e = ee(8);
	t.config.storage.kind === "github" && Dye(t.config.storage.repo);
	let n;
	e[0] !== t.config
		? ((n = m.jsx(kOe, { config: t.config })),
			(e[0] = t.config),
			(e[1] = n))
		: (n = e[1]);
	let r;
	e[2] !== t.config || e[3] !== n
		? ((r = m.jsx(eye, {
				children: m.jsx(TRe, { config: t.config, children: n }),
			})),
			(e[2] = t.config),
			(e[3] = n),
			(e[4] = r))
		: (r = e[4]);
	let i;
	return (
		e[5] !== t.appSlug || e[6] !== r
			? ((i = m.jsx(SOe, {
					children: m.jsx(EOe, {
						children: m.jsx($Re, { value: t.appSlug, children: r }),
					}),
				})),
				(e[5] = t.appSlug),
				(e[6] = r),
				(e[7] = i))
			: (i = e[7]),
		i
	);
}
function SOe(t) {
	const e = ee(2),
		[n, r] = E.useState(!1);
	let i, o;
	return (
		e[0] === Symbol.for("react.memo_cache_sentinel")
			? ((i = () => {
					r(!0);
				}),
				(o = []),
				(e[0] = i),
				(e[1] = o))
			: ((i = e[0]), (o = e[1])),
		E.useEffect(i, o),
		n ? t.children : null
	);
}
function AOe(t) {
	return function () {
		return m.jsx(DOe, { config: t });
	};
}
function sQ(t, e, n) {
	if (e !== null && (typeof e != "number" || !Number.isInteger(e)))
		return `${n} must be a whole number`;
	if (t != null && t.isRequired && e === null) return `${n} is required`;
	if (e !== null) {
		if ((t == null ? void 0 : t.min) !== void 0 && e < t.min)
			return `${n} must be at least ${t.min}`;
		if ((t == null ? void 0 : t.max) !== void 0 && e > t.max)
			return `${n} must be at most ${t.max}`;
	}
}
function $Oe(t) {
	var e;
	const n = ee(15);
	let r;
	n[0] === Symbol.for("react.memo_cache_sentinel")
		? ((r = () => !0), (n[0] = r))
		: (r = n[0]);
	const [i, o] = E.useReducer(r, !1),
		s = (e = t.validation) === null || e === void 0 ? void 0 : e.isRequired;
	let a;
	n[1] !== t || n[2] !== i
		? ((a =
				t.forceValidation || i
					? sQ(t.validation, t.value, t.label)
					: void 0),
			(n[1] = t),
			(n[2] = i),
			(n[3] = a))
		: (a = n[3]);
	const l = t.value === null ? void 0 : t.value;
	let u;
	n[4] !== t
		? ((u = (d) => {
				t.onChange(d === void 0 ? null : d);
			}),
			(n[4] = t),
			(n[5] = u))
		: (u = n[5]);
	let c;
	return (
		n[6] !== t.label ||
		n[7] !== t.description ||
		n[8] !== t.autoFocus ||
		n[9] !== s ||
		n[10] !== a ||
		n[11] !== o ||
		n[12] !== l ||
		n[13] !== u
			? ((c = m.jsx(Wv, {
					label: t.label,
					description: t.description,
					isRequired: s,
					errorMessage: a,
					onBlur: o,
					autoFocus: t.autoFocus,
					value: l,
					onChange: u,
				})),
				(n[6] = t.label),
				(n[7] = t.description),
				(n[8] = t.autoFocus),
				(n[9] = s),
				(n[10] = a),
				(n[11] = o),
				(n[12] = l),
				(n[13] = u),
				(n[14] = c))
			: (c = n[14]),
		c
	);
}
function WE({ label: t, defaultValue: e, validation: n, description: r }) {
	return Hi({
		label: t,
		Input(i) {
			return m.jsx($Oe, {
				label: t,
				description: r,
				validation: n,
				...i,
			});
		},
		defaultValue() {
			return e ?? null;
		},
		parse(i) {
			if (i === void 0) return null;
			if (typeof i == "number") return i;
			throw new st("Must be a number");
		},
		validate(i) {
			const o = sQ(n, i, t);
			if (o !== void 0) throw new st(o);
			return Fs(i, n, t), i;
		},
		serialize(i) {
			return { value: i === null ? void 0 : i };
		},
	});
}
function aQ(t, e) {
	var n;
	return {
		kind: "array",
		element: t,
		label:
			(n = e == null ? void 0 : e.label) !== null && n !== void 0
				? n
				: "Items",
		description: e == null ? void 0 : e.description,
		itemLabel: e == null ? void 0 : e.itemLabel,
		asChildTag: e == null ? void 0 : e.asChildTag,
		slugField: e == null ? void 0 : e.slugField,
		validation: e == null ? void 0 : e.validation,
	};
}
function TOe(t) {
	const e = ee(13),
		n = cTe();
	let r;
	e[0] !== t
		? ((r = (l) => {
				t.onChange(l);
			}),
			(e[0] = t),
			(e[1] = r))
		: (r = e[1]);
	const i = n === 12 ? "alias.singleLineWidth" : "auto";
	let o;
	e[2] !== i
		? ((o = { mobile: "auto", tablet: i }), (e[2] = i), (e[3] = o))
		: (o = e[3]);
	let s;
	e[4] === Symbol.for("react.memo_cache_sentinel")
		? ((s = (l) => m.jsx(Mt, { children: l.label }, l.value)), (e[4] = s))
		: (s = e[4]);
	let a;
	return (
		e[5] !== t.label ||
		e[6] !== t.description ||
		e[7] !== t.options ||
		e[8] !== t.value ||
		e[9] !== t.autoFocus ||
		e[10] !== r ||
		e[11] !== o
			? ((a = m.jsx(eS, {
					label: t.label,
					description: t.description,
					items: t.options,
					selectedKey: t.value,
					onSelectionChange: r,
					autoFocus: t.autoFocus,
					width: o,
					children: s,
				})),
				(e[5] = t.label),
				(e[6] = t.description),
				(e[7] = t.options),
				(e[8] = t.value),
				(e[9] = t.autoFocus),
				(e[10] = r),
				(e[11] = o),
				(e[12] = a))
			: (a = e[12]),
		a
	);
}
function lQ({ label: t, options: e, defaultValue: n, description: r }) {
	const i = new Set(e.map((s) => s.value));
	if (!i.has(n))
		throw new Error(
			`A defaultValue of ${n} was provided to a select field but it does not match the value of one of the options provided`,
		);
	return {
		...Hi({
			label: t,
			Input(s) {
				return m.jsx(TOe, {
					label: t,
					options: e,
					description: r,
					...s,
				});
			},
			defaultValue() {
				return n;
			},
			parse(s) {
				if (s === void 0) return n;
				if (typeof s != "string") throw new st("Must be a string");
				if (!i.has(s)) throw new st("Must be a valid option");
				return s;
			},
			validate(s) {
				return s;
			},
			serialize(s) {
				return { value: s };
			},
		}),
		options: e,
	};
}
function BOe(t) {
	var e, n;
	const r = ee(77);
	let i;
	r[0] === Symbol.for("react.memo_cache_sentinel")
		? ((i = { kind: "closed" }), (r[0] = i))
		: (i = r[0]);
	const [o, s] = E.useState(i);
	let a;
	r[1] === Symbol.for("react.memo_cache_sentinel")
		? ((a = () => {
				s({ kind: "closed" });
			}),
			(r[1] = a))
		: (a = r[1]);
	const l = a,
		u =
			(e =
				(n = t.schema.validation) === null ||
				n === void 0 ||
				(n = n.length) === null ||
				n === void 0
					? void 0
					: n.min) !== null && e !== void 0
				? e
				: 0,
		c = E.useId(),
		d = Le(Ht),
		f = hJ(t),
		h = !!f;
	let p;
	r[2] !== t.schema.description ||
	r[3] !== t.schema.label ||
	r[4] !== f ||
	r[5] !== h
		? ((p = {
				description: t.schema.description,
				errorMessage: f,
				isInvalid: h,
				label: t.schema.label,
				labelElementType: "span",
			}),
			(r[2] = t.schema.description),
			(r[3] = t.schema.label),
			(r[4] = f),
			(r[5] = h),
			(r[6] = p))
		: (p = r[6]);
	const {
			descriptionProps: g,
			errorMessageProps: v,
			fieldProps: b,
			labelProps: y,
		} = Gd(p),
		x = u > 0;
	let C;
	r[7] !== x || r[8] !== y || r[9] !== t.schema.label
		? ((C = m.jsx(qh, {
				elementType: "span",
				isRequired: x,
				supplementRequiredState: !0,
				...y,
				children: t.schema.label,
			})),
			(r[7] = x),
			(r[8] = y),
			(r[9] = t.schema.label),
			(r[10] = C))
		: (C = r[10]);
	let k;
	r[11] !== t.schema.description || r[12] !== g
		? ((k =
				t.schema.description &&
				m.jsx(ue, {
					size: "small",
					color: "neutralSecondary",
					...g,
					children: t.schema.description,
				})),
			(r[11] = t.schema.description),
			(r[12] = g),
			(r[13] = k))
		: (k = r[13]);
	let w;
	r[14] === Symbol.for("react.memo_cache_sentinel")
		? ((w = m.jsx(Re, { alignSelf: "start", children: "Add" })),
			(r[14] = w))
		: (w = r[14]);
	let D;
	r[15] !== t.schema.element.discriminant.options
		? ((D = (V) => {
				var K;
				const M =
					(K = t.schema.element.discriminant.options.find(
						(G) => G.value.toString() === V.toString(),
					)) === null || K === void 0
						? void 0
						: K.value;
				M !== void 0 && s({ kind: "new", discriminant: M });
			}),
			(r[15] = t.schema.element.discriminant.options),
			(r[16] = D))
		: (D = r[16]);
	let S;
	r[17] === Symbol.for("react.memo_cache_sentinel")
		? ((S = (V) => m.jsx(Mt, { children: V.label }, V.value.toString())),
			(r[17] = S))
		: (S = r[17]);
	let $;
	r[18] !== t.schema.element.discriminant.options || r[19] !== D
		? (($ = m.jsxs(Xo, {
				children: [
					w,
					m.jsx(Jo, {
						items: t.schema.element.discriminant.options,
						onAction: D,
						children: S,
					}),
				],
			})),
			(r[18] = t.schema.element.discriminant.options),
			(r[19] = D),
			(r[20] = $))
		: ($ = r[20]);
	let A;
	r[21] === Symbol.for("react.memo_cache_sentinel")
		? ((A = (V) => {
				s({ kind: "edit", idx: V });
			}),
			(r[21] = A))
		: (A = r[21]);
	let T;
	r[22] !== t
		? ((T = m.jsx(pJ, {
				...t,
				"aria-label": t.schema.label,
				onOpenItem: A,
			})),
			(r[22] = t),
			(r[23] = T))
		: (T = r[23]);
	let I;
	r[24] !== f || r[25] !== v
		? ((I = f && m.jsx(Gh, { ...v, children: f })),
			(r[24] = f),
			(r[25] = v),
			(r[26] = I))
		: (I = r[26]);
	let F;
	e: {
		if (o.kind === "closed") {
			F = null;
			break e;
		}
		if (o.kind === "edit") {
			const ne = o.idx,
				de = t.elements[ne].value,
				{ discriminant: se } = t.elements[ne];
			let re;
			if (
				r[27] !== se ||
				r[28] !== t.schema.element.discriminant.options
			) {
				var N;
				(re =
					(N = t.schema.element.discriminant.options.find(
						(we) => we.value === se,
					)) === null || N === void 0
						? void 0
						: N.label),
					(r[27] = se),
					(r[28] = t.schema.element.discriminant.options),
					(r[29] = re);
			} else re = r[29];
			let he;
			r[30] !== re
				? ((he = m.jsxs(Ut, { children: ["Edit", " ", re] })),
					(r[30] = re),
					(r[31] = he))
				: (he = r[31]);
			let ye;
			r[32] !== c || r[33] !== de || r[34] !== ne
				? ((ye = m.jsx(IOe, {
						formId: c,
						onClose: l,
						previewProps: de,
						modalStateIndex: ne,
					})),
					(r[32] = c),
					(r[33] = de),
					(r[34] = ne),
					(r[35] = ye))
				: (ye = r[35]);
			let Ae;
			r[36] !== c
				? ((Ae = m.jsx(Nr, {
						children: m.jsx(vt, {
							form: c,
							prominence: "high",
							type: "submit",
							children: "Done",
						}),
					})),
					(r[36] = c),
					(r[37] = Ae))
				: (Ae = r[37]);
			let Pe;
			r[38] !== he || r[39] !== ye || r[40] !== Ae
				? ((Pe = m.jsxs(vr, { children: [he, ye, Ae] })),
					(r[38] = he),
					(r[39] = ye),
					(r[40] = Ae),
					(r[41] = Pe))
				: (Pe = r[41]),
				(F = Pe);
			break e;
		}
		const V = o.discriminant;
		let K;
		if (r[42] !== V || r[43] !== t.schema.element.discriminant.options) {
			var O;
			(K =
				(O = t.schema.element.discriminant.options.find(
					(ne) => ne.value === V,
				)) === null || O === void 0
					? void 0
					: O.label),
				(r[42] = V),
				(r[43] = t.schema.element.discriminant.options),
				(r[44] = K);
		} else K = r[44];
		let M;
		r[45] !== K
			? ((M = m.jsxs(Ut, { children: ["Add", " ", K] })),
				(r[45] = K),
				(r[46] = M))
			: (M = r[46]);
		let G;
		r[47] !== V || r[48] !== c || r[49] !== t
			? ((G = m.jsx(Pr, {
					children: m.jsx(FOe, {
						discriminant: V,
						formId: c,
						previewProps: t,
					}),
				})),
				(r[47] = V),
				(r[48] = c),
				(r[49] = t),
				(r[50] = G))
			: (G = r[50]);
		let H;
		r[51] !== d
			? ((H = d.format("cancel")), (r[51] = d), (r[52] = H))
			: (H = r[52]);
		let P;
		r[53] !== H
			? ((P = m.jsx(vt, { onPress: l, children: H })),
				(r[53] = H),
				(r[54] = P))
			: (P = r[54]);
		let q;
		r[55] !== d
			? ((q = d.format("add")), (r[55] = d), (r[56] = q))
			: (q = r[56]);
		let J;
		r[57] !== c || r[58] !== q
			? ((J = m.jsx(vt, {
					form: c,
					prominence: "high",
					type: "submit",
					children: q,
				})),
				(r[57] = c),
				(r[58] = q),
				(r[59] = J))
			: (J = r[59]);
		let Z;
		r[60] !== P || r[61] !== J
			? ((Z = m.jsxs(Nr, { children: [P, J] })),
				(r[60] = P),
				(r[61] = J),
				(r[62] = Z))
			: (Z = r[62]);
		let oe;
		r[63] !== M || r[64] !== G || r[65] !== Z
			? ((oe = m.jsxs(vr, { children: [M, G, Z] })),
				(r[63] = M),
				(r[64] = G),
				(r[65] = Z),
				(r[66] = oe))
			: (oe = r[66]),
			(F = oe);
	}
	let _;
	r[67] !== F
		? ((_ = m.jsx(mn, { onDismiss: l, children: F })),
			(r[67] = F),
			(r[68] = _))
		: (_ = r[68]);
	let j;
	return (
		r[69] !== b ||
		r[70] !== C ||
		r[71] !== k ||
		r[72] !== $ ||
		r[73] !== T ||
		r[74] !== I ||
		r[75] !== _
			? ((j = m.jsxs(Hr, {
					gap: "medium",
					role: "group",
					minWidth: 0,
					...b,
					children: [C, k, $, T, I, _],
				})),
				(r[69] = b),
				(r[70] = C),
				(r[71] = k),
				(r[72] = $),
				(r[73] = T),
				(r[74] = I),
				(r[75] = _),
				(r[76] = j))
			: (j = r[76]),
		j
	);
}
function IOe(t) {
	const e = ee(8);
	let n;
	e[0] !== t
		? ((n = (o) => {
				o.target === o.currentTarget &&
					(o.preventDefault(), t.onClose());
			}),
			(e[0] = t),
			(e[1] = n))
		: (n = e[1]);
	let r;
	e[2] !== t.previewProps
		? ((r = m.jsx(Ia, { autoFocus: !0, ...t.previewProps })),
			(e[2] = t.previewProps),
			(e[3] = r))
		: (r = e[3]);
	let i;
	return (
		e[4] !== t.formId || e[5] !== n || e[6] !== r
			? ((i = m.jsx(Pr, {
					children: m.jsx(Hr, {
						id: t.formId,
						elementType: "form",
						onSubmit: n,
						gap: "xxlarge",
						children: r,
					}),
				})),
				(e[4] = t.formId),
				(e[5] = n),
				(e[6] = r),
				(e[7] = i))
			: (i = e[7]),
		i
	);
}
function FOe(t) {
	const e = t.previewProps.schema.element.values[t.discriminant.toString()],
		[n, r] = E.useState(() => an(e)),
		[i, o] = E.useState(!1),
		s = E.useMemo(() => Ba(e, r, () => {}), [e, r])(n),
		{ dismiss: a } = Xd();
	return m.jsx(Hr, {
		id: t.formId,
		elementType: "form",
		onSubmit: (l) => {
			if (l.target === l.currentTarget) {
				if ((l.preventDefault(), !_s(e, n, void 0))) {
					o(!0);
					return;
				}
				t.previewProps.onChange([
					...t.previewProps.elements.map((u) => ({ key: u.key })),
					{
						key: void 0,
						value: Pu(
							{ value: n, discriminant: t.discriminant },
							t.previewProps.schema.element,
						),
					},
				]),
					a();
			}
		},
		gap: "xxlarge",
		children: m.jsx(Ia, { forceValidation: i, autoFocus: !0, ...s }),
	});
}
function POe(t, e) {
	const n = Object.entries(t);
	if (!n.length)
		throw new Error("fields.blocks must have at least one entry");
	const r = lQ({
			label: "Kind",
			defaultValue: n[0][0],
			options: Object.entries(t).map(([o, { label: s }]) => ({
				label: s,
				value: o,
			})),
		}),
		i = uQ(r, Object.fromEntries(n.map(([o, { schema: s }]) => [o, s])));
	return {
		...aQ(i, {
			label: e.label,
			description: e.description,
			validation: e.validation,
			itemLabel(o) {
				const s = o.discriminant,
					a = t[s];
				return a.itemLabel ? a.itemLabel(o.value) : a.label;
			},
		}),
		Input: BOe,
	};
}
function NOe(t) {
	const e = ee(10);
	let n;
	e[0] !== t.label
		? ((n = m.jsx(ue, { children: t.label })), (e[0] = t.label), (e[1] = n))
		: (n = e[1]);
	let r;
	e[2] !== t.description
		? ((r =
				t.description &&
				m.jsx(ue, { slot: "description", children: t.description })),
			(e[2] = t.description),
			(e[3] = r))
		: (r = e[3]);
	let i;
	return (
		e[4] !== t.value ||
		e[5] !== t.onChange ||
		e[6] !== t.autoFocus ||
		e[7] !== n ||
		e[8] !== r
			? ((i = m.jsxs(p0, {
					isSelected: t.value,
					onChange: t.onChange,
					autoFocus: t.autoFocus,
					children: [n, r],
				})),
				(e[4] = t.value),
				(e[5] = t.onChange),
				(e[6] = t.autoFocus),
				(e[7] = n),
				(e[8] = r),
				(e[9] = i))
			: (i = e[9]),
		i
	);
}
function ROe({ label: t, defaultValue: e = !1, description: n }) {
	return Hi({
		label: t,
		Input(r) {
			return m.jsx(NOe, { ...r, label: t, description: n });
		},
		defaultValue() {
			return e;
		},
		parse(r) {
			if (r === void 0) return e;
			if (typeof r != "boolean") throw new st("Must be a boolean");
			return r;
		},
		validate(r) {
			return r;
		},
		serialize(r) {
			return { value: r };
		},
	});
}
function OOe(t) {
	return {
		kind: "child",
		options:
			t.kind === "block"
				? {
						...t,
						dividers: t.dividers,
						formatting:
							t.formatting === "inherit"
								? {
										blockTypes: "inherit",
										headingLevels: "inherit",
										inlineMarks: "inherit",
										listTypes: "inherit",
										alignment: "inherit",
										softBreaks: "inherit",
									}
								: t.formatting,
						links: t.links,
						images: t.images,
						tables: t.tables,
						componentBlocks: t.componentBlocks,
					}
				: {
						kind: "inline",
						placeholder: t.placeholder,
						formatting:
							t.formatting === "inherit"
								? {
										inlineMarks: "inherit",
										softBreaks: "inherit",
									}
								: t.formatting,
						links: t.links,
					},
	};
}
function MOe(t) {
	const e = ee(41),
		{ image: n, onChange: r } = t,
		[i, o] = E.useState(n.src ? "good" : ""),
		s = SH();
	let a;
	e[0] !== t
		? ((a = (T) => {
				T.preventDefault();
				const I = T.clipboardData.getData("text/plain"),
					F = mxe(I);
				t.onChange(F);
			}),
			(e[0] = t),
			(e[1] = a))
		: (a = e[1]);
	const l = a;
	let u;
	e[2] !== r
		? ((u = (T) => {
				r(T), o("good");
			}),
			(e[2] = r),
			(e[3] = u))
		: (u = e[3]);
	const c = Ri(u),
		d = Jn(),
		f = !!(t.image.alt || t.image.width || t.image.height);
	let h, p;
	e[4] !== t.image.src || e[5] !== f || e[6] !== d || e[7] !== c
		? ((h = () => {
				if (!t.image.src) {
					o("");
					return;
				}
				if (X0(t.image.src)) {
					if (f) {
						o("good");
						return;
					}
					o("loading"),
						vxe(t.image.src, d)
							.then((T) => {
								c(T);
							})
							.catch(() => {
								o("error");
							});
				}
			}),
			(p = [d, f, c, t.image.src]),
			(e[4] = t.image.src),
			(e[5] = f),
			(e[6] = d),
			(e[7] = c),
			(e[8] = h),
			(e[9] = p))
		: ((h = e[8]), (p = e[9])),
		E.useEffect(h, p);
	const [g, v] = E.useState(!1),
		b =
			(g || t.forceValidation) && t.isRequired && !n.src
				? "Image URL is required."
				: void 0;
	let y;
	e[10] !== t
		? ((y = (T) => {
				(T.code === "Backspace" || T.code === "Delete") &&
					t.onChange(pI);
			}),
			(e[10] = t),
			(e[11] = y))
		: (y = e[11]);
	let x;
	e[12] === Symbol.for("react.memo_cache_sentinel")
		? ((x = () => v(!0)), (e[12] = x))
		: (x = e[12]);
	let C;
	e[13] !== s
		? ((C = m.jsxs(ue, {
				children: [
					"Upload an image, or copy a URL from the",
					" ",
					m.jsx(xh, {
						prominence: "high",
						href: s,
						target: "_blank",
						rel: "noreferrer",
						children: "Image Library",
					}),
					" ",
					"and paste it into this field.",
				],
			})),
			(e[13] = s),
			(e[14] = C))
		: (C = e[14]);
	let k;
	e[15] !== i || e[16] !== n || e[17] !== t
		? ((k =
				i === "loading"
					? m.jsx(ke, {
							height: "element.regular",
							width: "element.regular",
							alignItems: "center",
							justifyContent: "center",
							children: m.jsx(Cr, {
								size: "small",
								"aria-label": "Checking…",
								isIndeterminate: !0,
							}),
						})
					: n.src
						? m.jsx(wx, {
								onPress: () => {
									t.onChange(pI), o("");
								},
								preventFocus: !0,
							})
						: null),
			(e[15] = i),
			(e[16] = n),
			(e[17] = t),
			(e[18] = k))
		: (k = e[18]);
	let w;
	e[19] !== t.isRequired ||
	e[20] !== t.autoFocus ||
	e[21] !== b ||
	e[22] !== l ||
	e[23] !== y ||
	e[24] !== n.src ||
	e[25] !== C ||
	e[26] !== k
		? ((w = m.jsx(An, {
				label: "Image URL",
				isRequired: t.isRequired,
				errorMessage: b,
				autoFocus: t.autoFocus,
				onPaste: l,
				onKeyDown: y,
				onBlur: x,
				value: n.src,
				description: C,
				endElement: k,
			})),
			(e[19] = t.isRequired),
			(e[20] = t.autoFocus),
			(e[21] = b),
			(e[22] = l),
			(e[23] = y),
			(e[24] = n.src),
			(e[25] = C),
			(e[26] = k),
			(e[27] = w))
		: (w = e[27]);
	let D;
	e[28] !== r
		? ((D = m.jsx(Cxe, {
				alignSelf: "start",
				onUploaded: (T) => {
					r(T);
				},
			})),
			(e[28] = r),
			(e[29] = D))
		: (D = e[29]);
	let S;
	e[30] !== w || e[31] !== D
		? ((S = m.jsxs(Hr, { gap: "medium", children: [w, D] })),
			(e[30] = w),
			(e[31] = D),
			(e[32] = S))
		: (S = e[32]);
	let $;
	e[33] !== i || e[34] !== n || e[35] !== t || e[36] !== r
		? (($ =
				i === "good"
					? m.jsxs(m.Fragment, {
							children: [
								m.jsx(pr, {
									alignSelf: "start",
									backgroundColor: "canvas",
									borderRadius: "regular",
									border: "neutral",
									padding: "regular",
									children: m.jsx("img", {
										alt: n.alt,
										src: n.src,
										style: {
											display: "block",
											maxHeight:
												B.size.alias.singleLineWidth,
											maxWidth: "100%",
										},
									}),
								}),
								m.jsx(VN, {
									label: "Alt text",
									value: n.alt,
									onChange: (T) =>
										t.onChange({ ...n, alt: T }),
								}),
								m.jsx(yxe, {
									src: n.src,
									image: n,
									onChange: (T) => {
										r({ ...t.image, ...T });
									},
								}),
							],
						})
					: m.jsxs(Hr, {
							"aria-hidden": !0,
							alignItems: "center",
							backgroundColor: "surface",
							borderRadius: "regular",
							gap: "medium",
							paddingX: "large",
							paddingY: "xlarge",
							children: [
								m.jsx(ve, {
									src: E0,
									color: "neutralSecondary",
									size: "medium",
								}),
								m.jsx(ue, {
									align: "center",
									color: "neutralSecondary",
									size: "small",
									children:
										"Awaiting URL to display image preview and information…",
								}),
							],
						})),
			(e[33] = i),
			(e[34] = n),
			(e[35] = t),
			(e[36] = r),
			(e[37] = $))
		: ($ = e[37]);
	let A;
	return (
		e[38] !== S || e[39] !== $
			? ((A = m.jsxs(Hr, {
					gap: "xlarge",
					padding: "large",
					children: [S, $],
				})),
				(e[38] = S),
				(e[39] = $),
				(e[40] = A))
			: (A = e[40]),
		A
	);
}
function jOe(t) {
	var e, n;
	const r = ee(27),
		i = E.useId(),
		o = E.useId(),
		s = t.schema.description ? o : void 0;
	let a;
	r[0] !== i || r[1] !== t.schema.label
		? ((a = m.jsx(ue, {
				color: "neutralEmphasis",
				size: "medium",
				weight: "medium",
				id: i,
				children: t.schema.label,
			})),
			(r[0] = i),
			(r[1] = t.schema.label),
			(r[2] = a))
		: (a = r[2]);
	let l;
	r[3] !== t.schema.description || r[4] !== o
		? ((l =
				!!t.schema.description &&
				m.jsx(ue, {
					id: o,
					size: "regular",
					color: "neutralSecondary",
					children: t.schema.description,
				})),
			(r[3] = t.schema.description),
			(r[4] = o),
			(r[5] = l))
		: (l = r[5]);
	let u;
	r[6] !== a || r[7] !== l
		? ((u = m.jsxs(Hr, {
				backgroundColor: "surface",
				borderBottom: "muted",
				borderTopStartRadius: "medium",
				borderTopEndRadius: "medium",
				gap: "medium",
				minWidth: 0,
				padding: "large",
				children: [a, l],
			})),
			(r[6] = a),
			(r[7] = l),
			(r[8] = u))
		: (u = r[8]);
	const c = (e = t.fields.width.value) !== null && e !== void 0 ? e : void 0,
		d = (n = t.fields.height.value) !== null && n !== void 0 ? n : void 0;
	let f;
	r[9] !== t.fields.src.value ||
	r[10] !== t.fields.alt.value ||
	r[11] !== c ||
	r[12] !== d
		? ((f = {
				src: t.fields.src.value,
				alt: t.fields.alt.value,
				width: c,
				height: d,
			}),
			(r[9] = t.fields.src.value),
			(r[10] = t.fields.alt.value),
			(r[11] = c),
			(r[12] = d),
			(r[13] = f))
		: (f = r[13]);
	let h;
	r[14] !== t
		? ((h = (v) => {
				var b, y;
				t.onChange({
					src: v.src,
					alt: v.alt,
					width: (b = v.width) !== null && b !== void 0 ? b : null,
					height: (y = v.height) !== null && y !== void 0 ? y : null,
				});
			}),
			(r[14] = t),
			(r[15] = h))
		: (h = r[15]);
	let p;
	r[16] !== f ||
	r[17] !== h ||
	r[18] !== t.autoFocus ||
	r[19] !== t.isRequired ||
	r[20] !== t.forceValidation
		? ((p = m.jsx(MOe, {
				image: f,
				onChange: h,
				autoFocus: t.autoFocus,
				isRequired: t.isRequired,
				forceValidation: t.forceValidation,
			})),
			(r[16] = f),
			(r[17] = h),
			(r[18] = t.autoFocus),
			(r[19] = t.isRequired),
			(r[20] = t.forceValidation),
			(r[21] = p))
		: (p = r[21]);
	let g;
	return (
		r[22] !== i || r[23] !== s || r[24] !== u || r[25] !== p
			? ((g = m.jsxs(Hr, {
					"aria-labelledby": i,
					"aria-describedby": s,
					border: "muted",
					borderRadius: "medium",
					minWidth: 0,
					role: "group",
					children: [u, p],
				})),
				(r[22] = i),
				(r[23] = s),
				(r[24] = u),
				(r[25] = p),
				(r[26] = g))
			: (g = r[26]),
		g
	);
}
function _Oe({ label: t, description: e, validation: n }) {
	return {
		...Ir(
			{
				src: Ag({
					label: "URL",
					validation: {
						length: { min: n != null && n.isRequired ? 1 : 0 },
					},
				}),
				alt: Ag({ label: "Alt text" }),
				height: WE({ label: "Height" }),
				width: WE({ label: "Width" }),
			},
			{ label: t, description: e },
		),
		Input(r) {
			return m.jsx(jOe, {
				...r,
				isRequired: n == null ? void 0 : n.isRequired,
			});
		},
	};
}
function uQ(t, e) {
	return { kind: "conditional", discriminant: t, values: e };
}
function cQ(t, e, n) {
	if (e !== null && !/^\d{4}-\d{2}-\d{2}$/.test(e))
		return `${n} is not a valid date`;
	if (t != null && t.isRequired && e === null) return `${n} is required`;
	if (((t != null && t.min) || (t != null && t.max)) && e !== null) {
		const r = new Date(e);
		if ((t == null ? void 0 : t.min) !== void 0) {
			const i = new Date(t.min);
			if (r < i) return `${n} must be after ${i.toLocaleDateString()}`;
		}
		if ((t == null ? void 0 : t.max) !== void 0) {
			const i = new Date(t.max);
			if (r > i)
				return `${n} must be no later than ${i.toLocaleDateString()}`;
		}
	}
}
function zOe(t) {
	var e;
	const n = ee(15);
	let r;
	n[0] === Symbol.for("react.memo_cache_sentinel")
		? ((r = () => !0), (n[0] = r))
		: (r = n[0]);
	const [i, o] = E.useReducer(r, !1);
	let s;
	n[1] !== t
		? ((s = (d) => {
				t.onChange(d === "" ? null : d);
			}),
			(n[1] = t),
			(n[2] = s))
		: (s = n[2]);
	const a = t.value === null ? "" : t.value,
		l = (e = t.validation) === null || e === void 0 ? void 0 : e.isRequired;
	let u;
	n[3] !== i || n[4] !== t
		? ((u =
				i || t.forceValidation
					? cQ(t.validation, t.value, t.label)
					: void 0),
			(n[3] = i),
			(n[4] = t),
			(n[5] = u))
		: (u = n[5]);
	let c;
	return (
		n[6] !== t.label ||
		n[7] !== t.description ||
		n[8] !== t.autoFocus ||
		n[9] !== s ||
		n[10] !== a ||
		n[11] !== o ||
		n[12] !== l ||
		n[13] !== u
			? ((c = m.jsx(An, {
					label: t.label,
					description: t.description,
					type: "date",
					onChange: s,
					autoFocus: t.autoFocus,
					value: a,
					onBlur: o,
					isRequired: l,
					errorMessage: u,
				})),
				(n[6] = t.label),
				(n[7] = t.description),
				(n[8] = t.autoFocus),
				(n[9] = s),
				(n[10] = a),
				(n[11] = o),
				(n[12] = l),
				(n[13] = u),
				(n[14] = c))
			: (c = n[14]),
		c
	);
}
function LOe({ label: t, defaultValue: e, validation: n, description: r }) {
	return Hi({
		label: t,
		Input(i) {
			return m.jsx(zOe, {
				validation: n,
				label: t,
				description: r,
				...i,
			});
		},
		defaultValue() {
			if (e === void 0) return null;
			if (typeof e == "string") return e;
			const i = new Date(),
				o = i.getFullYear(),
				s = String(i.getMonth() + 1).padStart(2, "0"),
				a = String(i.getDate()).padStart(2, "0");
			return `${o}-${s}-${a}`;
		},
		parse(i) {
			if (i === void 0) return null;
			if (i instanceof Date) {
				const o = i.getUTCFullYear(),
					s = String(i.getUTCMonth() + 1).padStart(2, "0"),
					a = String(i.getUTCDate()).padStart(2, "0");
				return `${o}-${s}-${a}`;
			}
			if (typeof i != "string") throw new st("Must be a string");
			return i;
		},
		serialize(i) {
			if (i === null) return { value: void 0 };
			const o = new Date(i);
			return (
				(o.toISOString = () => i), (o.toString = () => i), { value: o }
			);
		},
		validate(i) {
			const o = cQ(n, i, t);
			if (o !== void 0) throw new st(o);
			return Fs(i, n, t), i;
		},
	});
}
function dQ(t, e, n) {
	if (e !== null && !/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}$/.test(e))
		return `${n} is not a valid datetime`;
	if (t != null && t.isRequired && e === null) return `${n} is required`;
	if (((t != null && t.min) || (t != null && t.max)) && e !== null) {
		const r = new Date(e);
		if ((t == null ? void 0 : t.min) !== void 0) {
			const i = new Date(t.min);
			if (r < i) return `${n} must be after ${i.toISOString()}`;
		}
		if ((t == null ? void 0 : t.max) !== void 0) {
			const i = new Date(t.max);
			if (r > i) return `${n} must be no later than ${i.toISOString()}`;
		}
	}
}
function VOe(t) {
	var e;
	const n = ee(15);
	let r;
	n[0] === Symbol.for("react.memo_cache_sentinel")
		? ((r = () => !0), (n[0] = r))
		: (r = n[0]);
	const [i, o] = E.useReducer(r, !1);
	let s;
	n[1] !== t
		? ((s = (d) => {
				t.onChange(d === "" ? null : d);
			}),
			(n[1] = t),
			(n[2] = s))
		: (s = n[2]);
	const a = t.value === null ? "" : t.value,
		l = (e = t.validation) === null || e === void 0 ? void 0 : e.isRequired;
	let u;
	n[3] !== i || n[4] !== t
		? ((u =
				i || t.forceValidation
					? dQ(t.validation, t.value, t.label)
					: void 0),
			(n[3] = i),
			(n[4] = t),
			(n[5] = u))
		: (u = n[5]);
	let c;
	return (
		n[6] !== t.label ||
		n[7] !== t.description ||
		n[8] !== t.autoFocus ||
		n[9] !== s ||
		n[10] !== a ||
		n[11] !== o ||
		n[12] !== l ||
		n[13] !== u
			? ((c = m.jsx(An, {
					label: t.label,
					description: t.description,
					type: "datetime-local",
					onChange: s,
					autoFocus: t.autoFocus,
					value: a,
					onBlur: o,
					isRequired: l,
					errorMessage: u,
				})),
				(n[6] = t.label),
				(n[7] = t.description),
				(n[8] = t.autoFocus),
				(n[9] = s),
				(n[10] = a),
				(n[11] = o),
				(n[12] = l),
				(n[13] = u),
				(n[14] = c))
			: (c = n[14]),
		c
	);
}
function KOe({ label: t, defaultValue: e, validation: n, description: r }) {
	return Hi({
		label: t,
		Input(i) {
			return m.jsx(VOe, {
				validation: n,
				label: t,
				description: r,
				...i,
			});
		},
		defaultValue() {
			if (e === void 0) return null;
			if (typeof e == "string") return e;
			if (e.kind === "now") {
				const i = new Date();
				return new Date(i.getTime() - i.getTimezoneOffset() * 60 * 1e3)
					.toISOString()
					.slice(0, -8);
			}
			return null;
		},
		parse(i) {
			if (i === void 0) return null;
			if (i instanceof Date) return i.toISOString().slice(0, -8);
			if (typeof i != "string") throw new st("Must be a string or date");
			return i;
		},
		serialize(i) {
			if (i === null) return { value: void 0 };
			const o = new Date(i + "Z");
			return (
				(o.toJSON = () => o.toISOString().slice(0, -8)),
				(o.toString = () => o.toISOString().slice(0, -8)),
				{ value: o }
			);
		},
		validate(i) {
			const o = dQ(n, i, t);
			if (o !== void 0) throw new st(o);
			return Fs(i, n, t), i;
		},
	});
}
function UOe() {
	return Hi({
		Input() {
			return null;
		},
		defaultValue() {
			return null;
		},
		parse() {
			return null;
		},
		serialize() {
			return { value: void 0 };
		},
		validate(t) {
			return t;
		},
		label: "Empty",
	});
}
function HOe() {
	return {
		kind: "form",
		formKind: "content",
		Input() {
			return null;
		},
		defaultValue() {
			return null;
		},
		parse() {
			return null;
		},
		contentExtension: ".mdoc",
		serialize() {
			return {
				value: void 0,
				content: new Uint8Array(),
				external: new Map(),
				other: new Map(),
			};
		},
		validate(t) {
			return t;
		},
		reader: {
			parse() {
				return null;
			},
		},
	};
}
function WOe(t) {
	return {
		kind: "form",
		formKind: "content",
		Input() {
			return null;
		},
		defaultValue() {
			return null;
		},
		parse() {
			return null;
		},
		contentExtension: `.${t.extension}`,
		serialize() {
			return {
				value: void 0,
				content: new Uint8Array(),
				external: new Map(),
				other: new Map(),
			};
		},
		validate(e) {
			return e;
		},
		reader: {
			parse() {
				return null;
			},
		},
	};
}
function qOe(t) {
	var e;
	const n = ee(34),
		{ value: r } = t;
	let i;
	n[0] === Symbol.for("react.memo_cache_sentinel")
		? ((i = () => !0), (n[0] = i))
		: (i = n[0]);
	const [o, s] = E.useReducer(i, !1),
		a = zJ(),
		l = hA(r === null ? null : r.data, void 0),
		u = E.useId(),
		c = E.useId(),
		d = t.description ? c : void 0,
		f = (e = t.validation) === null || e === void 0 ? void 0 : e.isRequired;
	let h;
	n[1] !== u || n[2] !== f || n[3] !== t.label
		? ((h = m.jsx(qh, {
				id: u,
				elementType: "span",
				isRequired: f,
				children: t.label,
			})),
			(n[1] = u),
			(n[2] = f),
			(n[3] = t.label),
			(n[4] = h))
		: (h = n[4]);
	let p;
	n[5] !== t.description || n[6] !== c
		? ((p =
				t.description &&
				m.jsx(ue, {
					size: "small",
					color: "neutralSecondary",
					id: c,
					children: t.description,
				})),
			(n[5] = t.description),
			(n[6] = c),
			(n[7] = p))
		: (p = n[7]);
	let g;
	n[8] !== t
		? ((g = m.jsx(Re, {
				onPress: async () => {
					const w = await AJ("");
					if (w) {
						var D, S;
						t.onChange({
							data: w.content,
							filename: t.transformFilename
								? t.transformFilename(w.filename)
								: w.filename,
							extension:
								(D =
									(S = w.filename.match(/\.([^.]+$)/)) ===
										null || S === void 0
										? void 0
										: S[1]) !== null && D !== void 0
									? D
									: "",
						});
					}
				},
				children: "Choose file",
			})),
			(n[8] = t),
			(n[9] = g))
		: (g = n[9]);
	let v;
	n[10] !== r || n[11] !== t || n[12] !== s || n[13] !== l
		? ((v =
				r !== null &&
				m.jsxs(m.Fragment, {
					children: [
						m.jsx(Re, {
							prominence: "low",
							onPress: () => {
								t.onChange(null), s();
							},
							children: "Remove",
						}),
						l &&
							m.jsx(vt, {
								href: l,
								download: r.filename,
								prominence: "low",
								children: "Download",
							}),
					],
				})),
			(n[10] = r),
			(n[11] = t),
			(n[12] = s),
			(n[13] = l),
			(n[14] = v))
		: (v = n[14]);
	let b;
	n[15] !== g || n[16] !== v
		? ((b = m.jsxs(Nr, { children: [g, v] })),
			(n[15] = g),
			(n[16] = v),
			(n[17] = b))
		: (b = n[17]);
	let y;
	n[18] !== a || n[19] !== r || n[20] !== t
		? ((y =
				a &&
				r !== null &&
				m.jsx(An, {
					label: "Filename",
					onChange: (w) => {
						t.onChange({ ...r, filename: w });
					},
					value: r.filename,
				})),
			(n[18] = a),
			(n[19] = r),
			(n[20] = t),
			(n[21] = y))
		: (y = n[21]);
	let x;
	if (n[22] !== t || n[23] !== o || n[24] !== r) {
		var C;
		(x =
			(t.forceValidation || o) &&
			((C = t.validation) === null || C === void 0
				? void 0
				: C.isRequired) &&
			r === null &&
			m.jsxs(Gh, { children: [t.label, " is required"] })),
			(n[22] = t),
			(n[23] = o),
			(n[24] = r),
			(n[25] = x);
	} else x = n[25];
	let k;
	return (
		n[26] !== d ||
		n[27] !== u ||
		n[28] !== h ||
		n[29] !== p ||
		n[30] !== b ||
		n[31] !== y ||
		n[32] !== x
			? ((k = m.jsxs(ke, {
					"aria-describedby": d,
					"aria-labelledby": u,
					direction: "column",
					gap: "medium",
					role: "group",
					children: [h, p, b, y, x],
				})),
				(n[26] = d),
				(n[27] = u),
				(n[28] = h),
				(n[29] = p),
				(n[30] = b),
				(n[31] = y),
				(n[32] = x),
				(n[33] = k))
			: (k = n[33]),
		k
	);
}
function GOe({
	label: t,
	directory: e,
	validation: n,
	description: r,
	publicPath: i,
	transformFilename: o,
}) {
	return {
		kind: "form",
		formKind: "asset",
		label: t,
		Input(s) {
			return m.jsx(qOe, {
				label: t,
				description: r,
				validation: n,
				transformFilename: o,
				...s,
			});
		},
		defaultValue() {
			return null;
		},
		filename(s, a) {
			if (typeof s == "string") return s.slice(Nu(i, a.slug).length);
		},
		parse(s, a) {
			var l, u;
			if (s === void 0) return null;
			if (typeof s != "string") throw new st("Must be a string");
			return a.asset === void 0
				? null
				: {
						data: a.asset,
						filename: s.slice(Nu(i, a.slug).length),
						extension:
							(l =
								(u = s.match(/\.([^.]+$)/)) === null ||
								u === void 0
									? void 0
									: u[1]) !== null && l !== void 0
								? l
								: "",
					};
		},
		validate(s) {
			return Fs(s, n, t), s;
		},
		serialize(s, a) {
			if (s === null) return { value: void 0, asset: void 0 };
			const l = a.suggestedFilenamePrefix
				? a.suggestedFilenamePrefix + "." + s.extension
				: s.filename;
			return {
				value: `${Nu(i, a.slug)}${l}`,
				asset: { filename: l, content: s.data },
			};
		},
		directory: e ? xr(e) : void 0,
		reader: {
			parse(s) {
				if (typeof s != "string" && s !== void 0)
					throw new st("Must be a string");
				const a = s === void 0 ? null : s;
				return Fs(a, n, t), a;
			},
		},
	};
}
function YOe({
	label: t,
	directory: e,
	validation: n,
	description: r,
	publicPath: i,
	transformFilename: o,
}) {
	return {
		kind: "form",
		formKind: "asset",
		label: t,
		Input(s) {
			return m.jsx($Be, {
				label: t,
				description: r,
				validation: n,
				transformFilename: o,
				...s,
			});
		},
		defaultValue() {
			return null;
		},
		filename(s, a) {
			if (typeof s == "string") return s.slice(Nu(i, a.slug).length);
		},
		parse(s, a) {
			var l, u;
			if (s === void 0) return null;
			if (typeof s != "string") throw new st("Must be a string");
			return a.asset === void 0
				? null
				: {
						data: a.asset,
						filename: s.slice(Nu(i, a.slug).length),
						extension:
							(l =
								(u = s.match(/\.([^.]+$)/)) === null ||
								u === void 0
									? void 0
									: u[1]) !== null && l !== void 0
								? l
								: "",
					};
		},
		validate(s) {
			return Fs(s, n, t), s;
		},
		serialize(s, a) {
			if (s === null) return { value: void 0, asset: void 0 };
			const l = a.suggestedFilenamePrefix
				? a.suggestedFilenamePrefix + "." + s.extension
				: s.filename;
			return {
				value: `${Nu(i, a.slug)}${l}`,
				asset: { filename: l, content: s.data },
			};
		},
		directory: e ? xr(e) : void 0,
		reader: {
			parse(s) {
				if (typeof s != "string" && s !== void 0)
					throw new st("Must be a string");
				const a = s === void 0 ? null : s;
				return Fs(a, n, t), a;
			},
		},
	};
}
function fQ(t, e) {
	var n, r, i, o;
	const s =
		(n =
			t == null || (r = t.length) === null || r === void 0
				? void 0
				: r.min) !== null && n !== void 0
			? n
			: 0;
	if (e.length < s)
		return `Must have at least ${Od(s, { singular: "item" })}.`;
	const a =
		(i =
			t == null || (o = t.length) === null || o === void 0
				? void 0
				: o.max) !== null && i !== void 0
			? i
			: 1 / 0;
	if (e.length > a)
		return `Must have at most ${Od(a, { singular: "item" })}.`;
}
function JOe(t) {
	var e;
	const n = E.useMemo(() => t.value.map((d) => ({ key: d })), [t.value]),
		[r, i] = E.useReducer(() => !0, !1),
		o = IA(t.collection),
		s = E.useMemo(() => o.map((d) => ({ slug: d })), [o]),
		a = (t.forceValidation || r) && fQ(t.validation, t.value),
		[l, u] = E.useState(a);
	E.useEffect(() => {
		u(a);
	}, [a]);
	const c = E.useMemo(() => {
		const d = new Set(t.value);
		return s.filter((f) => !d.has(f.slug));
	}, [t.value, s]);
	return m.jsxs(Hr, {
		gap: "medium",
		minWidth: 0,
		children: [
			m.jsx(L0, {
				label: t.label,
				description: t.description,
				selectedKey: null,
				placeholder: c.length === 0 ? "All selected" : void 0,
				onSelectionChange: (d) => {
					typeof d == "string" && t.onChange([...t.value, d]);
				},
				disabledKeys: ["No more items…"],
				onBlur: i,
				autoFocus: t.autoFocus,
				defaultItems: c.length ? c : [{ slug: "No more items…" }],
				isReadOnly: c.length === 0,
				isRequired:
					((e = t.validation) === null ||
					e === void 0 ||
					(e = e.length) === null ||
					e === void 0
						? void 0
						: e.min) !== void 0 && t.validation.length.min >= 1,
				errorMessage: l,
				width: "auto",
				children: (d) => m.jsx(Mt, { children: d.slug }, d.slug),
			}),
			m.jsx(XOe, {
				autoFocus: t.autoFocus,
				forceValidation: t.forceValidation,
				onChange: (d) => {
					t.onChange(d.map((f) => f.key));
				},
				elements: n,
				"aria-label": t.label,
			}),
		],
	});
}
function XOe(t) {
	const [e, n] = E.useState(() => new Set([]));
	let r = (s, a) => {
		const l = t.elements.findIndex((f) => f.key === a.key);
		if (l === -1) return;
		const u = t.elements.map((f) => ({ key: f.key })),
			c = a.dropPosition === "before" ? l : l + 1,
			d = s.map((f) => u.findIndex((h) => h.key === f));
		t.onChange(fJ(u, d, c));
	};
	const i = E.useMemo(() => Math.random().toString(36), []);
	let { dragAndDropHooks: o } = TM({
		getItems(s) {
			return [...s].map(
				(a) => ((a = JSON.stringify(a)), { [i]: a, "text/plain": a }),
			);
		},
		getAllowedDropOperations() {
			return ["move", "cancel"];
		},
		async onDrop(s) {
			if (s.target.type !== "root" && s.target.dropPosition !== "on") {
				let a = [];
				for (let l of s.items)
					if (l.kind === "text") {
						let u;
						l.types.has(i)
							? ((u = JSON.parse(await l.getText(i))), a.push(u))
							: l.types.has("text/plain") &&
								((u = await l.getText("text/plain")),
								(a = u
									.split(
										`
`,
									)
									.map((c) => c.replaceAll('"', ""))));
					}
				r(a, s.target);
			}
		},
		getDropOperation(s) {
			return s.type === "root" || s.dropPosition === "on"
				? "cancel"
				: "move";
		},
	});
	return m.jsxs(w4e, {
		maxHeight: "scale.3400",
		minHeight: "scale.1600",
		children: [
			m.jsx(RH, {
				"aria-label": t["aria-label"],
				items: t.elements,
				dragAndDropHooks: o,
				selectionMode: "multiple",
				onSelectionChange: n,
				selectedKeys: e,
				renderEmptyState: ZOe,
				UNSAFE_className: X({ borderRadius: B.size.radius.regular }),
				children: (s) => {
					const a = s.key;
					return m.jsx(Mt, { textValue: a, children: a }, s.key);
				},
			}),
			m.jsx(k4e, {
				selectedItemCount: e === "all" ? "all" : e.size,
				onClearSelection: () => n(new Set()),
				onAction: (s) => {
					if (s === "delete") {
						let a = t.elements;
						e instanceof Set
							? (a = t.elements.filter((l) => !e.has(l.key)))
							: e === "all" && (a = []),
							t.onChange(a),
							n(new Set());
					}
				},
				children: m.jsxs(
					Mt,
					{
						textValue: "Remove",
						children: [
							m.jsx(ve, { src: Wr }),
							m.jsx(ue, { children: "Remove" }),
						],
					},
					"delete",
				),
			}),
		],
	});
}
function ZOe() {
	return m.jsx(Hr, {
		gap: "large",
		alignItems: "center",
		justifyContent: "center",
		height: "100%",
		padding: "regular",
		children: m.jsx(ue, {
			align: "center",
			color: "neutralTertiary",
			children: "No items selected…",
		}),
	});
}
function QOe({ label: t, collection: e, validation: n, description: r }) {
	return Hi({
		label: t,
		Input(i) {
			return m.jsx(JOe, {
				label: t,
				collection: e,
				description: r,
				validation: n,
				...i,
			});
		},
		defaultValue() {
			return [];
		},
		parse(i) {
			if (i === void 0) return [];
			if (!Array.isArray(i) || !i.every(nne))
				throw new st("Must be an array of strings");
			return i;
		},
		validate(i) {
			const o = fQ(n, i);
			if (o) throw new st(o);
			return i;
		},
		serialize(i) {
			return { value: i };
		},
	});
}
function eMe(t) {
	const e = ee(14),
		n = E.useId(),
		r = E.useId(),
		i = t.description ? r : void 0;
	let o;
	e[0] !== n || e[1] !== t.label
		? ((o = m.jsx(qh, { elementType: "span", id: n, children: t.label })),
			(e[0] = n),
			(e[1] = t.label),
			(e[2] = o))
		: (o = e[2]);
	let s;
	e[3] !== t.description || e[4] !== r
		? ((s =
				t.description &&
				m.jsx(ue, {
					id: r,
					size: "small",
					color: "neutralSecondary",
					children: t.description,
				})),
			(e[3] = t.description),
			(e[4] = r),
			(e[5] = s))
		: (s = e[5]);
	let a;
	e[6] !== t
		? ((a = t.options.map((u) =>
				m.jsx(
					p0,
					{
						isSelected: t.value.includes(u.value),
						onChange: () => {
							t.value.includes(u.value)
								? t.onChange(
										t.value.filter((c) => c !== u.value),
									)
								: t.onChange([...t.value, u.value]);
						},
						children: u.label,
					},
					u.value,
				),
			)),
			(e[6] = t),
			(e[7] = a))
		: (a = e[7]);
	let l;
	return (
		e[8] !== n || e[9] !== i || e[10] !== o || e[11] !== s || e[12] !== a
			? ((l = m.jsxs(ke, {
					role: "group",
					"aria-labelledby": n,
					"aria-describedby": i,
					direction: "column",
					gap: "medium",
					children: [o, s, a],
				})),
				(e[8] = n),
				(e[9] = i),
				(e[10] = o),
				(e[11] = s),
				(e[12] = a),
				(e[13] = l))
			: (l = e[13]),
		l
	);
}
function tMe({ label: t, options: e, defaultValue: n = [], description: r }) {
	const i = new Map(e.map((s) => [s.value, s]));
	return {
		...Hi({
			label: t,
			Input(s) {
				return m.jsx(eMe, {
					label: t,
					description: r,
					options: e,
					...s,
				});
			},
			defaultValue() {
				return n;
			},
			parse(s) {
				if (s === void 0) return [];
				if (!Array.isArray(s))
					throw new st("Must be an array of options");
				if (!s.every((a) => typeof a == "string" && i.has(a)))
					throw new st(
						`Must be an array with one of ${e.map((a) => a.value).join(", ")}`,
					);
				return s;
			},
			validate(s) {
				return s;
			},
			serialize(s) {
				return { value: s };
			},
		}),
		options: e,
	};
}
function hQ(t, e, n, r) {
	if (e !== null && typeof e != "number") return `${r} must be a number`;
	if (t != null && t.isRequired && e === null) return `${r} is required`;
	if (e !== null) {
		if ((t == null ? void 0 : t.min) !== void 0 && e < t.min)
			return `${r} must be at least ${t.min}`;
		if ((t == null ? void 0 : t.max) !== void 0 && e > t.max)
			return `${r} must be at most ${t.max}`;
		if (
			n !== void 0 &&
			(t == null ? void 0 : t.validateStep) !== void 0 &&
			new FI(e).mod(new FI(n)).toNumber() !== 0
		)
			return `${r} must be a multiple of ${n}`;
	}
}
function nMe(t) {
	var e;
	const n = ee(16);
	let r;
	n[0] === Symbol.for("react.memo_cache_sentinel")
		? ((r = () => !0), (n[0] = r))
		: (r = n[0]);
	const [i, o] = E.useReducer(r, !1),
		s = (e = t.validation) === null || e === void 0 ? void 0 : e.isRequired;
	let a;
	n[1] !== t || n[2] !== i
		? ((a =
				t.forceValidation || i
					? hQ(t.validation, t.value, t.step, t.label)
					: void 0),
			(n[1] = t),
			(n[2] = i),
			(n[3] = a))
		: (a = n[3]);
	const l = t.value === null ? void 0 : t.value;
	let u;
	n[4] !== t
		? ((u = (d) => {
				t.onChange(d === void 0 ? null : d);
			}),
			(n[4] = t),
			(n[5] = u))
		: (u = n[5]);
	let c;
	return (
		n[6] !== t.label ||
		n[7] !== t.description ||
		n[8] !== t.autoFocus ||
		n[9] !== t.step ||
		n[10] !== s ||
		n[11] !== a ||
		n[12] !== o ||
		n[13] !== l ||
		n[14] !== u
			? ((c = m.jsx(Wv, {
					label: t.label,
					description: t.description,
					isRequired: s,
					errorMessage: a,
					onBlur: o,
					autoFocus: t.autoFocus,
					step: t.step,
					value: l,
					onChange: u,
				})),
				(n[6] = t.label),
				(n[7] = t.description),
				(n[8] = t.autoFocus),
				(n[9] = t.step),
				(n[10] = s),
				(n[11] = a),
				(n[12] = o),
				(n[13] = l),
				(n[14] = u),
				(n[15] = c))
			: (c = n[15]),
		c
	);
}
function rMe({
	label: t,
	defaultValue: e,
	step: n,
	validation: r,
	description: i,
}) {
	return Hi({
		label: t,
		Input(o) {
			return m.jsx(nMe, {
				label: t,
				description: i,
				validation: r,
				step: n,
				...o,
			});
		},
		defaultValue() {
			return e ?? null;
		},
		parse(o) {
			if (o === void 0) return null;
			if (typeof o == "number") return o;
			throw new st("Must be a number");
		},
		validate(o) {
			const s = hQ(r, o, n, t);
			if (s !== void 0) throw new st(s);
			return Fs(o, r, t), o;
		},
		serialize(o) {
			return { value: o === null ? void 0 : o };
		},
	});
}
function iMe(t) {
	var e, n;
	const r = ee(24);
	let i, o;
	r[0] !== t.pattern
		? ((o = t.pattern ? aq(t.pattern) : () => !0),
			(r[0] = t.pattern),
			(r[1] = o))
		: (o = r[1]),
		(i = o);
	const s = i;
	let a;
	r[2] === Symbol.for("react.memo_cache_sentinel")
		? ((a = () => !0), (r[2] = a))
		: (a = r[2]);
	const [l, u] = E.useReducer(a, !1),
		c = w3().current;
	let d, f;
	if (r[3] !== c || r[4] !== s) {
		const D = c.kind === "loaded" ? [...c.data.entries.values()] : [];
		let S;
		r[6] !== s
			? ((S = ($) => s($.path)), (r[6] = s), (r[7] = S))
			: (S = r[7]),
			(f = D.filter(S)),
			(r[3] = c),
			(r[4] = s),
			(r[5] = f);
	} else f = r[5];
	d = f;
	const h = d,
		p =
			(t.forceValidation || l) &&
			(e = t.validation) !== null &&
			e !== void 0 &&
			e.isRequired &&
			t.value === null
				? `${t.label} is required`
				: void 0,
		[g, v] = E.useState(p);
	let b, y;
	r[8] !== p
		? ((b = () => {
				v(p);
			}),
			(y = [p]),
			(r[8] = p),
			(r[9] = b),
			(r[10] = y))
		: ((b = r[9]), (y = r[10])),
		E.useEffect(b, y);
	let x;
	r[11] !== t
		? ((x = (D) => {
				(typeof D == "string" || D === null) && t.onChange(D);
			}),
			(r[11] = t),
			(r[12] = x))
		: (x = r[12]);
	const C =
		(n = t.validation) === null || n === void 0 ? void 0 : n.isRequired;
	let k;
	r[13] === Symbol.for("react.memo_cache_sentinel")
		? ((k = (D) => m.jsx(Mt, { children: D.path }, D.path)), (r[13] = k))
		: (k = r[13]);
	let w;
	return (
		r[14] !== t.label ||
		r[15] !== t.description ||
		r[16] !== t.value ||
		r[17] !== t.autoFocus ||
		r[18] !== x ||
		r[19] !== u ||
		r[20] !== C ||
		r[21] !== g ||
		r[22] !== h
			? ((w = m.jsx(L0, {
					label: t.label,
					description: t.description,
					selectedKey: t.value,
					onSelectionChange: x,
					onBlur: u,
					isRequired: C,
					errorMessage: g,
					autoFocus: t.autoFocus,
					defaultItems: h,
					width: "auto",
					children: k,
				})),
				(r[14] = t.label),
				(r[15] = t.description),
				(r[16] = t.value),
				(r[17] = t.autoFocus),
				(r[18] = x),
				(r[19] = u),
				(r[20] = C),
				(r[21] = g),
				(r[22] = h),
				(r[23] = w))
			: (w = r[23]),
		w
	);
}
function oMe({ label: t, pattern: e, validation: n, description: r }) {
	return Hi({
		label: t,
		Input(i) {
			return m.jsx(iMe, {
				label: t,
				pattern: e,
				description: r,
				validation: n,
				...i,
			});
		},
		defaultValue() {
			return null;
		},
		parse(i) {
			if (i === void 0) return null;
			if (typeof i != "string") throw new st("Must be a string");
			return i;
		},
		validate(i) {
			return Fs(i, n, t), i;
		},
		serialize(i) {
			return { value: i === null ? void 0 : i };
		},
	});
}
function sMe(t) {
	var e, n;
	const r = ee(20);
	let i;
	r[0] === Symbol.for("react.memo_cache_sentinel")
		? ((i = () => !0), (r[0] = i))
		: (i = r[0]);
	const [o, s] = E.useReducer(i, !1),
		a = IA(t.collection);
	let l, u;
	if (r[1] !== a) {
		let C;
		r[3] === Symbol.for("react.memo_cache_sentinel")
			? ((C = (k) => ({ slug: k })), (r[3] = C))
			: (C = r[3]),
			(u = a.map(C)),
			(r[1] = a),
			(r[2] = u);
	} else u = r[2];
	l = u;
	const c = l,
		d =
			(t.forceValidation || o) &&
			(e = t.validation) !== null &&
			e !== void 0 &&
			e.isRequired &&
			t.value === null
				? `${t.label} is required`
				: void 0,
		[f, h] = E.useState(d);
	let p, g;
	r[4] !== d
		? ((p = () => {
				h(d);
			}),
			(g = [d]),
			(r[4] = d),
			(r[5] = p),
			(r[6] = g))
		: ((p = r[5]), (g = r[6])),
		E.useEffect(p, g);
	let v;
	r[7] !== t
		? ((v = (C) => {
				(typeof C == "string" || C === null) && t.onChange(C);
			}),
			(r[7] = t),
			(r[8] = v))
		: (v = r[8]);
	const b =
		(n = t.validation) === null || n === void 0 ? void 0 : n.isRequired;
	let y;
	r[9] === Symbol.for("react.memo_cache_sentinel")
		? ((y = (C) => m.jsx(Mt, { children: C.slug }, C.slug)), (r[9] = y))
		: (y = r[9]);
	let x;
	return (
		r[10] !== t.label ||
		r[11] !== t.description ||
		r[12] !== t.value ||
		r[13] !== t.autoFocus ||
		r[14] !== v ||
		r[15] !== s ||
		r[16] !== c ||
		r[17] !== b ||
		r[18] !== f
			? ((x = m.jsx(L0, {
					label: t.label,
					description: t.description,
					selectedKey: t.value,
					onSelectionChange: v,
					onBlur: s,
					autoFocus: t.autoFocus,
					defaultItems: c,
					isRequired: b,
					errorMessage: f,
					width: "auto",
					children: y,
				})),
				(r[10] = t.label),
				(r[11] = t.description),
				(r[12] = t.value),
				(r[13] = t.autoFocus),
				(r[14] = v),
				(r[15] = s),
				(r[16] = c),
				(r[17] = b),
				(r[18] = f),
				(r[19] = x))
			: (x = r[19]),
		x
	);
}
function aMe({ label: t, collection: e, validation: n, description: r }) {
	return Hi({
		label: t,
		Input(i) {
			return m.jsx(sMe, {
				label: t,
				collection: e,
				description: r,
				validation: n,
				...i,
			});
		},
		defaultValue() {
			return null;
		},
		parse(i) {
			if (i === void 0) return null;
			if (typeof i != "string") throw new st("Must be a string");
			return i;
		},
		validate(i) {
			return Fs(i, n, t), i;
		},
		serialize(i) {
			return { value: i === null ? void 0 : i };
		},
	});
}
const lMe = new Set();
function uMe(t) {
	var e, n, r, i, o, s, a, l, u, c, d, f, h, p;
	const g = E.useContext(w5),
		v = E.useContext(Sg),
		b =
			v.length === 1 && v[0] === (g == null ? void 0 : g.field)
				? g
				: { slugs: lMe, glob: "*" },
		[y, x] = E.useState(!1),
		[C, k] = E.useState(!1),
		[w, D] = E.useState(t.value === t.defaultValue),
		S = (T) => {
			const I = t.naiveGenerateSlug(T);
			if (b.slugs.has(I)) {
				let F = 1;
				for (; b.slugs.has(`${I}-${F}`); ) F++;
				return `${I}-${F}`;
			}
			return I;
		},
		$ =
			(e =
				(n = t.args.slug) === null || n === void 0
					? void 0
					: n.label) !== null && e !== void 0
				? e
				: "Slug",
		A =
			t.forceValidation || C
				? Mh(
						t.value.slug,
						(r =
							(i = t.args.slug) === null ||
							i === void 0 ||
							(i = i.validation) === null ||
							i === void 0 ||
							(i = i.length) === null ||
							i === void 0
								? void 0
								: i.min) !== null && r !== void 0
							? r
							: 1,
						(o =
							(s = t.args.slug) === null ||
							s === void 0 ||
							(s = s.validation) === null ||
							s === void 0 ||
							(s = s.length) === null ||
							s === void 0
								? void 0
								: s.max) !== null && o !== void 0
							? o
							: 1 / 0,
						$,
						b,
						(a = t.args.slug) === null ||
							a === void 0 ||
							(a = a.validation) === null ||
							a === void 0
							? void 0
							: a.pattern,
					)
				: void 0;
	return m.jsxs(ke, {
		gap: "xlarge",
		direction: "column",
		children: [
			m.jsx(An, {
				label: t.args.name.label,
				description: t.args.name.description,
				autoFocus: t.autoFocus,
				value: t.value.name,
				isRequired: !!(
					(l = t.args.name.validation) !== null &&
					l !== void 0 &&
					(l = l.length) !== null &&
					l !== void 0 &&
					l.min
				),
				onChange: (T) => {
					t.onChange({ name: T, slug: w ? S(T) : t.value.slug });
				},
				onBlur: () => x(!0),
				errorMessage:
					t.forceValidation || y
						? Mh(
								t.value.name,
								(u =
									(c = t.args.name.validation) === null ||
									c === void 0 ||
									(c = c.length) === null ||
									c === void 0
										? void 0
										: c.min) !== null && u !== void 0
									? u
									: 0,
								(d =
									(f = t.args.name.validation) === null ||
									f === void 0 ||
									(f = f.length) === null ||
									f === void 0
										? void 0
										: f.max) !== null && d !== void 0
									? d
									: 1 / 0,
								t.args.name.label,
								void 0,
								(h = t.args.name.validation) === null ||
									h === void 0
									? void 0
									: h.pattern,
							)
						: void 0,
			}),
			m.jsxs(ke, {
				gap: "regular",
				alignItems: "end",
				children: [
					m.jsx(An, {
						flex: 1,
						label: $,
						description:
							(p = t.args.slug) === null || p === void 0
								? void 0
								: p.description,
						value: t.value.slug,
						onChange: (T) => {
							D(!1), t.onChange({ name: t.value.name, slug: T });
						},
						onBlur: () => k(!0),
						errorMessage: A,
						isRequired: !0,
					}),
					m.jsxs(ke, {
						gap: "regular",
						direction: "column",
						children: [
							m.jsxs(Re, {
								"aria-label": "regenerate",
								onPress: () => {
									t.onChange({
										name: t.value.name,
										slug: S(t.value.name),
									});
								},
								children: [
									m.jsx(ve, {
										src: kke,
										UNSAFE_className: X({
											[Gm.above.mobile]: {
												display: "none",
											},
										}),
									}),
									m.jsx(ue, {
										UNSAFE_className: X({
											[Gm.below.tablet]: {
												display: "none",
											},
										}),
										children: "Regenerate",
									}),
								],
							}),
							A !== void 0 &&
								m.jsx(pr, { height: "element.xsmall" }),
						],
					}),
				],
			}),
		],
	});
}
function U8(t) {
	if (t === void 0) return { name: "", slug: "" };
	if (typeof t != "object") throw new st("Must be an object");
	if (Object.keys(t).length !== 2) throw new st("Unexpected keys");
	if (!("name" in t) || !("slug" in t)) throw new st("Missing name or slug");
	if (typeof t.name != "string") throw new st("name must be a string");
	if (typeof t.slug != "string") throw new st("slug must be a string");
	return { name: t.name, slug: t.slug };
}
function H8(t, e) {
	if (t === void 0) return { name: "", slug: e };
	if (typeof t != "string") throw new st("Must be a string");
	return { name: t, slug: e };
}
function cMe(t) {
	var e, n, r, i, o, s;
	const a = {
			...t,
			name: {
				...t.name,
				validation: {
					pattern:
						(e = t.name.validation) === null || e === void 0
							? void 0
							: e.pattern,
					length: {
						min: Math.max(
							(n = t.name.validation) !== null &&
								n !== void 0 &&
								n.isRequired
								? 1
								: 0,
							(r =
								(i = t.name.validation) === null ||
								i === void 0 ||
								(i = i.length) === null ||
								i === void 0
									? void 0
									: i.min) !== null && r !== void 0
								? r
								: 0,
						),
						max:
							(o = t.name.validation) === null ||
							o === void 0 ||
							(o = o.length) === null ||
							o === void 0
								? void 0
								: o.max,
					},
				},
			},
		},
		l =
			((s = a.slug) === null || s === void 0 ? void 0 : s.generate) ||
			oCe;
	let u;
	function c() {
		if (!u) {
			var h, p;
			u = {
				name:
					(h = a.name.defaultValue) !== null && h !== void 0 ? h : "",
				slug: l(
					(p = a.name.defaultValue) !== null && p !== void 0 ? p : "",
				),
			};
		}
		return u;
	}
	function d(h, { slugField: p } = { slugField: void 0 }) {
		var g, v, b, y, x, C, k, w, D, S, $, A;
		const T = Mh(
			h.name,
			(g =
				(v = a.name.validation) === null ||
				v === void 0 ||
				(v = v.length) === null ||
				v === void 0
					? void 0
					: v.min) !== null && g !== void 0
				? g
				: 0,
			(b =
				(y = a.name.validation) === null ||
				y === void 0 ||
				(y = y.length) === null ||
				y === void 0
					? void 0
					: y.max) !== null && b !== void 0
				? b
				: 1 / 0,
			a.name.label,
			void 0,
			(x = a.name.validation) === null || x === void 0
				? void 0
				: x.pattern,
		);
		if (T !== void 0) throw new st(T);
		const I = Mh(
			h.slug,
			(C =
				(k = a.slug) === null ||
				k === void 0 ||
				(k = k.validation) === null ||
				k === void 0 ||
				(k = k.length) === null ||
				k === void 0
					? void 0
					: k.min) !== null && C !== void 0
				? C
				: 1,
			(w =
				(D = a.slug) === null ||
				D === void 0 ||
				(D = D.validation) === null ||
				D === void 0 ||
				(D = D.length) === null ||
				D === void 0
					? void 0
					: D.max) !== null && w !== void 0
				? w
				: 1 / 0,
			(S = ($ = a.slug) === null || $ === void 0 ? void 0 : $.label) !==
				null && S !== void 0
				? S
				: "Slug",
			p || { slugs: f, glob: "*" },
			(A = a.slug) === null ||
				A === void 0 ||
				(A = A.validation) === null ||
				A === void 0
				? void 0
				: A.pattern,
		);
		if (I !== void 0) throw new st(I);
		return h;
	}
	const f = new Set();
	return {
		kind: "form",
		formKind: "slug",
		label: a.name.label,
		Input(h) {
			return m.jsx(uMe, {
				args: a,
				naiveGenerateSlug: l,
				defaultValue: c(),
				...h,
			});
		},
		defaultValue: c,
		parse(h, p) {
			return (p == null ? void 0 : p.slug) !== void 0
				? H8(h, p.slug)
				: U8(h);
		},
		validate: d,
		serialize(h) {
			return { value: h };
		},
		serializeWithSlug(h) {
			return { value: h.name, slug: h.slug };
		},
		reader: {
			parse(h) {
				const p = U8(h);
				return d(p);
			},
			parseWithSlug(h, p) {
				return d(H8(h, p.slug), {
					slugField: { glob: p.glob, slugs: f },
				}).name;
			},
		},
	};
}
function pQ(t, e, n) {
	if (e !== null && (typeof e != "string" || !X0(e)))
		return `${n} is not a valid URL`;
	if (t != null && t.isRequired && e === null) return `${n} is required`;
}
function dMe(t) {
	var e;
	const n = ee(15);
	let r;
	n[0] === Symbol.for("react.memo_cache_sentinel")
		? ((r = () => !0), (n[0] = r))
		: (r = n[0]);
	const [i, o] = E.useReducer(r, !1),
		s = t.value === null ? "" : t.value;
	let a;
	n[1] !== t
		? ((a = (d) => {
				t.onChange(d === "" ? null : d);
			}),
			(n[1] = t),
			(n[2] = a))
		: (a = n[2]);
	const l =
		(e = t.validation) === null || e === void 0 ? void 0 : e.isRequired;
	let u;
	n[3] !== t || n[4] !== i
		? ((u =
				t.forceValidation || i
					? pQ(t.validation, t.value, t.label)
					: void 0),
			(n[3] = t),
			(n[4] = i),
			(n[5] = u))
		: (u = n[5]);
	let c;
	return (
		n[6] !== t.label ||
		n[7] !== t.description ||
		n[8] !== t.autoFocus ||
		n[9] !== s ||
		n[10] !== a ||
		n[11] !== o ||
		n[12] !== l ||
		n[13] !== u
			? ((c = m.jsx(An, {
					inputMode: "url",
					width: "auto",
					maxWidth: "scale.6000",
					label: t.label,
					description: t.description,
					autoFocus: t.autoFocus,
					value: s,
					onChange: a,
					onBlur: o,
					isRequired: l,
					errorMessage: u,
				})),
				(n[6] = t.label),
				(n[7] = t.description),
				(n[8] = t.autoFocus),
				(n[9] = s),
				(n[10] = a),
				(n[11] = o),
				(n[12] = l),
				(n[13] = u),
				(n[14] = c))
			: (c = n[14]),
		c
	);
}
function fMe({ label: t, defaultValue: e, validation: n, description: r }) {
	return Hi({
		label: t,
		Input(i) {
			return m.jsx(dMe, {
				label: t,
				description: r,
				validation: n,
				...i,
			});
		},
		defaultValue() {
			return e || null;
		},
		parse(i) {
			if (i === void 0) return null;
			if (typeof i != "string") throw new st("Must be a string");
			return i === "" ? null : i;
		},
		validate(i) {
			const o = pQ(n, i, t);
			if (o !== void 0) throw new st(o);
			return Fs(i, n, t), i;
		},
		serialize(i) {
			return { value: i === null ? void 0 : i };
		},
	});
}
function hMe() {
	return {
		kind: "form",
		Input() {
			return null;
		},
		defaultValue() {
			return { value: void 0 };
		},
		parse(t) {
			return { value: t };
		},
		serialize(t) {
			return t;
		},
		validate(t) {
			return t;
		},
		label: "Ignored",
		reader: {
			parse(t) {
				return t;
			},
		},
	};
}
var ze = Object.freeze({
	__proto__: null,
	array: aQ,
	blocks: POe,
	checkbox: ROe,
	child: OOe,
	cloudImage: _Oe,
	conditional: uQ,
	date: LOe,
	datetime: KOe,
	document: y7e,
	empty: UOe,
	emptyDocument: HOe,
	emptyContent: WOe,
	file: GOe,
	image: YOe,
	integer: WE,
	multiRelationship: QOe,
	multiselect: tMe,
	number: rMe,
	object: Ir,
	pathReference: oMe,
	relationship: aMe,
	select: lQ,
	slug: cMe,
	text: Ag,
	url: fMe,
	ignored: hMe,
	mdx: vX,
	markdoc: wA,
});
const pMe = { kind: "github", repo: { owner: "q1b", name: "q1b" } };
ze.markdoc.createMarkdocConfig({});
const mMe = {
		storage: pMe,
		ui: { brand: { name: "Admin Dashboard" } },
		singletons: {
			homepage: {
				label: "Homepage",
				path: "src/content/singletons/homepage/",
				format: { data: "json" },
				schema: {
					title: ze.text({ label: "Title" }),
					description: ze.text({
						label: "Description",
						multiline: !0,
					}),
					keywords: ze.array(
						ze.text({ label: "Enter Keyword for your website" }),
						{ label: "Keywords", itemLabel: (t) => t.value },
					),
					highlights: ze.array(
						ze.text({
							label: "Highlight",
							description:
								"Highlights that will be displayed on the homepage, such as software developer, youtuber",
						}),
						{
							label: "Whatever You Want to Highlight",
							description: "Items will be present over homepage",
							itemLabel: (t) => t.value,
						},
					),
				},
			},
			person: {
				label: "Profile",
				path: "src/content/singletons/profile/",
				format: { data: "json" },
				schema: {
					name: ze.text({ label: "Name" }),
					email_address: ze.text({
						label: "Email Address",
						description:
							"Be aware of the email address you are typing as this is going to be visible to everyone who is going to visit this website!",
					}),
					image: ze.image({
						label: "Profile Image",
						directory: "src/assets/images/profile",
						publicPath: "/src/assets/images/profile/",
					}),
					worksFor: ze.conditional(
						ze.checkbox({
							label: "Are you Currently Working ?",
							defaultValue: !1,
						}),
						{
							true: ze.text({ label: "Works For" }),
							false: ze.empty(),
						},
					),
					knowsAbout: ze.array(
						ze.object({
							name: ze.text({ label: "Name" }),
							public: ze.checkbox({
								label: "Public",
								defaultValue: !0,
							}),
						}),
						{
							label: "Knows About",
							itemLabel: (t) => t.fields.name.value,
						},
					),
					githubURL: ze.url({ label: "GitHub URL" }),
					xURL: ze.url({ label: "X URL" }),
					linkedInURL: ze.url({ label: "LinkedIn URL" }),
					resumePDF: ze.file({
						label: "PDF File of your Resume",
						directory: "src/assets/files/resume",
						publicPath: "/src/assets/files/resume/",
					}),
				},
			},
		},
		collections: {
			projects: {
				label: "Projects",
				slugField: "title",
				path: "src/data/projects/*",
				format: { data: "json", contentField: "content" },
				schema: {
					title: ze.slug({ name: { label: "Title" } }),
					shortDescription: ze.text({ label: "Short Description" }),
					visible: ze.checkbox({ label: "Visible" }),
					isMajorProject: ze.checkbox({ label: "Is Major Project" }),
					githubURL: ze.url({ label: "GitHub URL" }),
					websiteURL: ze.url({ label: "Website URL" }),
					article: ze.conditional(
						ze.checkbox({ label: "Is Article" }),
						{
							true: ze.object(
								{
									employmentType: ze.select({
										label: "Employment Type",
										options: [
											{
												label: "Full Time",
												value: "full-time",
											},
											{
												label: "Part Time",
												value: "part-time",
											},
											{
												label: "Self Employed",
												value: "self-employed",
											},
											{
												label: "Freelance",
												value: "freelance",
											},
											{
												label: "Internship",
												value: "internship",
											},
											{
												label: "Trainee",
												value: "trainee",
											},
										],
										defaultValue: "full-time",
									}),
									location: ze.text({ label: "Location" }),
									locationType: ze.select({
										label: "Location Type",
										options: [
											{
												label: "On-site",
												value: "on-site",
											},
											{
												label: "Hybrid",
												value: "hybrid",
											},
											{
												label: "Remote",
												value: "remote",
											},
										],
										defaultValue: "remote",
									}),
									startDate: ze.date({ label: "Start Date" }),
									endDate: ze.date({ label: "End Date" }),
									thumbnail: ze.object({
										"16/9": ze.image({
											label: "16/9 Aspect Ratio Image",
											directory:
												"src/assets/images/projects",
											publicPath:
												"/src/assets/images/projects/",
										}),
										"1/1": ze.image({
											label: "1/1 Aspect Ratio Image",
											directory:
												"src/assets/images/projects",
											publicPath:
												"/src/assets/images/projects/",
										}),
									}),
									media: ze.array(
										ze.object({
											name: ze.text({ label: "Name" }),
											file: ze.file({
												label: "Media",
												directory:
													"src/assets/images/projects",
												publicPath:
													"/src/assets/images/projects/",
											}),
										}),
										{
											label: "Media",
											description:
												"Letter of Recommendation, Certificates, etc.",
										},
									),
									company: ze.object(
										{
											name: ze.text({ label: "Name" }),
											url: ze.url({ label: "URL" }),
										},
										{
											label: "Company",
											description:
												"Details of the Company you worked for.",
										},
									),
								},
								{ label: "Article" },
							),
							false: ze.ignored(),
						},
					),
					content: ze.markdoc({ label: "Content" }),
				},
			},
			categories: {
				label: "Categories",
				slugField: "name",
				path: "src/data/categories/*",
				format: { data: "json" },
				schema: { name: ze.slug({ name: { label: "Name" } }) },
			},
			tags: {
				label: "Tags",
				slugField: "name",
				path: "src/data/tags/*",
				format: { data: "json" },
				schema: {
					name: ze.slug({ name: { label: "Name" } }),
					category: ze.relationship({
						label: "Category",
						collection: "categories",
					}),
				},
			},
			articles: {
				label: "Articles",
				slugField: "title",
				path: "src/data/articles/*",
				entryLayout: "content",
				format: { contentField: "content" },
				schema: {
					title: ze.slug({ name: { label: "Title" } }),
					subtitle: ze.text({ label: "Subtitle", multiline: !0 }),
					summary: ze.text({ label: "Summary", multiline: !0 }),
					content: ze.markdoc({ label: "Content" }),
					visible: ze.checkbox({
						label: "Visible",
						defaultValue: !1,
					}),
					pubDate: ze.date({ label: "Pub Date" }),
					thumbnail: ze.image({
						label: "Thumbnail",
						directory: "src/assets/images/articles",
						publicPath: "/src/assets/images/articles/",
					}),
					tags: ze.multiRelationship({
						label: "Tags",
						collection: "tags",
					}),
				},
			},
			webpages: {
				label: "Webpages",
				slugField: "path",
				path: "src/data/webpages/*",
				schema: {
					path: ze.slug({ name: { label: "Path" } }),
					title: ze.text({ label: "Title" }),
					description: ze.text({
						label: "Description",
						multiline: !0,
					}),
					keywords: ze.array(ze.text({ label: "Keywords" })),
				},
			},
		},
	},
	BMe = AOe(mMe);
export { BMe as default };
